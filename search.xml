<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>pictures</title>
    <url>/2021/05/22/pictures/</url>
    <content><![CDATA[<p><img src="/2021/05/22/pictures/2.png" alt="2"></p>
<p><img src="/2021/05/22/pictures/1.jpg" alt="3"></p>
<p><img src="/2021/05/22/pictures/3.png"></p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>《第一行代码-笔记》</title>
    <url>/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    <content><![CDATA[<div class="note warning modern"><p><strong>前言：</strong>目录结构还有待优化，可直接ctrl+F搜索有无需要了解的内容<br>本笔记属于个人初学android过程时总结，如有错误或者图片缺失，还请留言指正，十分感谢！<br>仅供学习参考，如需转载请注明来自[Durango]: <a href="http://www.durango.cn/">www.durango.cn</a></p>
</div>




<h1 id="第一章-第一行代码"><a href="#第一章-第一行代码" class="headerlink" title="第一章     第一行代码"></a>第一章     <strong>第一行代码</strong></h1><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><h3 id="Linux内核层、系统运行库、应用架构层、应用层"><a href="#Linux内核层、系统运行库、应用架构层、应用层" class="headerlink" title="Linux内核层、系统运行库、应用架构层、应用层"></a>Linux内核层、系统运行库、应用架构层、应用层</h3><h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><h3 id="活动（Activity）、服务（Service）、广播接收器（Broadcast-Receiver）、-内容提供者（Content-Provider"><a href="#活动（Activity）、服务（Service）、广播接收器（Broadcast-Receiver）、-内容提供者（Content-Provider" class="headerlink" title="活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、        内容提供者（Content Provider)"></a>活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、        内容提供者（Content Provider)</h3><h2 id="APP目录"><a href="#APP目录" class="headerlink" title="APP目录"></a>APP目录</h2><ul>
<li>1.build: 一些编译时自动生成的文件</li>
</ul>
<h4 id="2-libs-第三方jar包"><a href="#2-libs-第三方jar包" class="headerlink" title="2.libs: 第三方jar包"></a>2.libs: 第三方jar包</h4><h4 id="3-androidTest-测试用例，自动化监测"><a href="#3-androidTest-测试用例，自动化监测" class="headerlink" title="3.androidTest: 测试用例，自动化监测"></a>3.androidTest: 测试用例，自动化监测</h4><h4 id="4-java-放置Java代码"><a href="#4-java-放置Java代码" class="headerlink" title="4.java: 放置Java代码"></a>4.<font color="red">java</font>: 放置Java代码</h4><h4 id="5-res-资源文件"><a href="#5-res-资源文件" class="headerlink" title="5.res: 资源文件"></a>5<font color="red">.res</font>: 资源文件</h4><p>​                drawable: 图片</p>
<p>​                layout: 布局文件</p>
<p>​                values: 字符串</p>
<h4 id="6-AndroidMainfest-xml-项目配置文件，四大活动必须在此注册！"><a href="#6-AndroidMainfest-xml-项目配置文件，四大活动必须在此注册！" class="headerlink" title="6.AndroidMainfest.xml: 项目配置文件，四大活动必须在此注册！"></a>6.AndroidMainfest.xml: 项目配置文件，四大活动必须在此注册！</h4><p>​    ……</p>
<h2 id="主活动"><a href="#主活动" class="headerlink" title="主活动"></a>主活动</h2><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200912223928217.png" alt="image-20200912223928217"></p>
<h2 id="引入布局"><a href="#引入布局" class="headerlink" title="引入布局"></a><font color="red">引入布局</font></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setContentView( R.layout.hello_world_layout)</span><br></pre></td></tr></table></figure>



<h2 id="资源的引用"><a href="#资源的引用" class="headerlink" title="资源的引用"></a><font color="red">资源的引用</font></h2><h4 id="1-代码中"><a href="#1-代码中" class="headerlink" title="1.代码中"></a>1.代码中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R.string.hello_world</span><br></pre></td></tr></table></figure>

<p>​        R .类型 .名称</p>
<h4 id="2-XML中"><a href="#2-XML中" class="headerlink" title="2.XML中"></a>2.XML中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@.string.hello_world</span><br></pre></td></tr></table></figure>

<p>​    @ .类型 .名称</p>
<h3 id="定义id-id-名称"><a href="#定义id-id-名称" class="headerlink" title="定义id: @+id/名称"></a>定义id: @+id/名称</h3><h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><h4 id="（p26）"><a href="#（p26）" class="headerlink" title="（p26）"></a>（p26）</h4><h1 id="第二章-探究活动"><a href="#第二章-探究活动" class="headerlink" title="第二章 探究活动"></a>第二章 探究活动</h1><h2 id="活动是什么"><a href="#活动是什么" class="headerlink" title="活动是什么"></a>活动是什么</h2><h2 id="活动的基本用法"><a href="#活动的基本用法" class="headerlink" title="活动的基本用法"></a>活动的基本用法</h2><h3 id="一、手动创建活动"><a href="#一、手动创建活动" class="headerlink" title="一、手动创建活动"></a>一、手动创建活动</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172254284.png" alt="image-20200913172254284"></p>
<h3 id="二、创建和加载布局"><a href="#二、创建和加载布局" class="headerlink" title="二、创建和加载布局"></a>二、创建和加载布局</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172406723.png" alt="image-20200913172406723"></p>
<p>​                                                                                    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172431922.png" alt="image-20200913172431922"></p>
<h4 id="添加按钮："><a href="#添加按钮：" class="headerlink" title="添加按钮："></a><font color="orange">添加按钮：</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">	android:id=&quot;@+id/button_1&quot;</span><br><span class="line">	android:layout_width=&quot;match_parent&quot;</span><br><span class="line">	android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">	android:text=&quot;Button 1&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="加载布局："><a href="#加载布局：" class="headerlink" title="加载布局："></a><font color="orange">加载布局：</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setContentView(R.layout.布局文件名)</span><br></pre></td></tr></table></figure>

<h3 id="三、在AndroidManifest文件中注册"><a href="#三、在AndroidManifest文件中注册" class="headerlink" title="三、在AndroidManifest文件中注册"></a>三、在AndroidManifest文件中注册</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174606232.png" alt="image-20200913174606232"></p>
<h3 id="四、在活动中使用Toast提醒"><a href="#四、在活动中使用Toast提醒" class="headerlink" title="四、在活动中使用Toast提醒"></a>四、在活动中使用Toast提醒</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174713039.png" alt="image-20200913174713039"></p>
<h3 id="五、在活动中使用Menu"><a href="#五、在活动中使用Menu" class="headerlink" title="五、在活动中使用Menu"></a>五、在活动中使用Menu</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174848093.png" alt="image-20200913174848093"></h4><p>2.然后在main.xml文件中添加(创建两个菜单项)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;item</span><br><span class="line">	android:id=&quot;@+id/add_itme&quot;</span><br><span class="line">	android:title=&quot;Add&quot;/&gt;</span><br><span class="line">&lt;item</span><br><span class="line">	android:id=&quot;@+id/remove_itme&quot;</span><br><span class="line">	android:title=&quot;Remove&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-重写onCreateOptionMenu（）方法"><a href="#3-重写onCreateOptionMenu（）方法" class="headerlink" title="3.重写onCreateOptionMenu（）方法"></a>3.重写<font color="orange">onCreateOptionMenu（）</font>方法</h4><h4 id="在Java代码中使用快捷键-”Ctrl-O“"><a href="#在Java代码中使用快捷键-”Ctrl-O“" class="headerlink" title="在Java代码中使用快捷键 ”Ctrl+O“"></a>在Java代码中使用快捷键 ”Ctrl+O“</h4><p>​                                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913175533827.png" alt="image-20200913175533827"></p>
<h4 id="4-重写onOptionsItemSelected"><a href="#4-重写onOptionsItemSelected" class="headerlink" title="4.重写onOptionsItemSelected"></a>4.重写<font color="orange">onOptionsItemSelected</font></h4><p>​                                    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913180038921.png" alt="image-20200913180038921"></p>
<h3 id="六、摧毁一个活动"><a href="#六、摧毁一个活动" class="headerlink" title="六、摧毁一个活动"></a>六、摧毁一个活动</h3><h4 id="stop"><a href="#stop" class="headerlink" title="stop();"></a><font color="orange">stop();</font></h4><h2 id="使用Intent（意图）在活动之间穿梭"><a href="#使用Intent（意图）在活动之间穿梭" class="headerlink" title="使用Intent（意图）在活动之间穿梭"></a>使用Intent（意图）在活动之间穿梭</h2><h3 id="一、使用显式的Intent"><a href="#一、使用显式的Intent" class="headerlink" title="一、使用显式的Intent"></a>一、使用显式的Intent</h3><h4 id><a href="#" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913212452461.png" alt="image-20200913212452461"></h4><h4 id="首先构建一个Intent，传入FirstActivity-this作为上下文，传入SecondActicity-class作为目标活动，然后通过startActivity（）方法来执行这个Intent。"><a href="#首先构建一个Intent，传入FirstActivity-this作为上下文，传入SecondActicity-class作为目标活动，然后通过startActivity（）方法来执行这个Intent。" class="headerlink" title="首先构建一个Intent，传入FirstActivity.this作为上下文，传入SecondActicity.class作为目标活动，然后通过startActivity（）方法来执行这个Intent。"></a>首先构建一个Intent，传入FirstActivity.this作为<font color="orange">上下文</font>，传入SecondActicity.class作为<font color="orange">目标活动</font>，然后通过startActivity（）方法来执行这个Intent。</h4><h3 id="二、使用隐式的Intent（意图过滤器intent-filter"><a href="#二、使用隐式的Intent（意图过滤器intent-filter" class="headerlink" title="二、使用隐式的Intent（意图过滤器intent-filter)"></a>二、使用隐式的Intent（意图过滤器<font color="red">intent-filter</font>)</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913213406302.png" alt="image-20200913213406302"></h4><h4 id="-1"><a href="#-1" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913213734619.png" alt="image-20200913213734619"></h4><h4 id="2-DEFAULT是一种默认的category，在调用startActicity-方法时会自动将这个category添加到Intent中。"><a href="#2-DEFAULT是一种默认的category，在调用startActicity-方法时会自动将这个category添加到Intent中。" class="headerlink" title="2.DEFAULT是一种默认的category，在调用startActicity()方法时会自动将这个category添加到Intent中。"></a>2.DEFAULT是一种默认的category，在调用startActicity()方法时会自动将这个category添加到Intent中。</h4><h4 id="3-每个Intent只能指定一个action，却能指定多个category，这样增加："><a href="#3-每个Intent只能指定一个action，却能指定多个category，这样增加：" class="headerlink" title="3.每个Intent只能指定一个action，却能指定多个category，这样增加："></a>3.每个Intent只能指定一个action，却能指定多个category，这样增加：</h4><h4 id="intent-addCategory-“com-example-activity-MY-CATEGORY”-；"><a href="#intent-addCategory-“com-example-activity-MY-CATEGORY”-；" class="headerlink" title="intent.addCategory(“com.example.activity.MY_CATEGORY”)；"></a>intent.<font color="red">addCategory(“com.example.activity.MY_CATEGORY”)</font>；</h4><h4 id="4-然后在活动二的intent-filter中添加声明："><a href="#4-然后在活动二的intent-filter中添加声明：" class="headerlink" title="4.然后在活动二的intent-filter中添加声明："></a>4.然后在活动二的intent-filter中添加声明：</h4><h4 id="lt-category-android-name-”com-example-activity-MY-CATEGORY”"><a href="#lt-category-android-name-”com-example-activity-MY-CATEGORY”" class="headerlink" title="&lt;category android:name=”com.example.activity.MY_CATEGORY”"></a><font color="red">&lt;category android:name=”com.example.activity.MY_CATEGORY”</font></h4><h4 id="5-只有-lt-action-gt-和-lt-category-gt-同时匹配上-Intent中指定的-action-和-category-时，这个活动才能响应该Intent"><a href="#5-只有-lt-action-gt-和-lt-category-gt-同时匹配上-Intent中指定的-action-和-category-时，这个活动才能响应该Intent" class="headerlink" title="5.只有&lt;action&gt;和&lt;category&gt;同时匹配上 Intent中指定的 action 和 category 时，这个活动才能响应该Intent"></a>5.<font color="orange">只有&lt;action&gt;和&lt;category&gt;同时匹配上 Intent中指定的 action 和 category 时，这个活动才能响应该Intent</font></h4><h3 id="三、更多隐式的Intent"><a href="#三、更多隐式的Intent" class="headerlink" title="三、更多隐式的Intent"></a>三、更多隐式的Intent</h3><h4 id="1-使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动"><a href="#1-使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动" class="headerlink" title="1.使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动"></a>1.使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动</h4><p>​            <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913220158511.png" alt="image-20200913220158511"></p>
<h5 id="（1）这里我们首先指定了Intent的action是Intent-ACTION-VIEW，这是一个Android系统内置的动作，其常量值为-android-intent-action-VIEW。"><a href="#（1）这里我们首先指定了Intent的action是Intent-ACTION-VIEW，这是一个Android系统内置的动作，其常量值为-android-intent-action-VIEW。" class="headerlink" title="（1）这里我们首先指定了Intent的action是Intent.ACTION_VIEW，这是一个Android系统内置的动作，其常量值为                android.intent.action.VIEW。"></a>（1）这里我们首先指定了Intent的action是<font color="red">Intent.ACTION_VIEW</font>，这是一个Android系统内置的动作，其常量值为                android.intent.action.VIEW。</h5><h5 id="（2）然后通过Uri-parse-方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData-方法将这个uri对象-传递进去。"><a href="#（2）然后通过Uri-parse-方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData-方法将这个uri对象-传递进去。" class="headerlink" title="（2）然后通过Uri.parse()方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData()方法将这个uri对象                传递进去。"></a>（2）然后通过<font color="red">Uri.parse()</font>方法，将一个网址字符串解析成一个Uri对象，再调用Intent的<font color="red">setData()</font>方法将这个uri对象                传递进去。</h5><h5 id="（3）可能你会对setData-部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，-主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri-parse-方法中解析产生的。"><a href="#（3）可能你会对setData-部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，-主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri-parse-方法中解析产生的。" class="headerlink" title="（3）可能你会对setData()部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，                主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri.parse()方法中解析产生的。"></a>（3）可能你会对<font color="red">setData()</font>部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，                主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri.parse()方法中解析产生的。</h5><h4 id="2-与此对应，我们还可以在-lt-intent-filter-gt-标签中再配置一个-lt-data-gt-标签，用于更精确地"><a href="#2-与此对应，我们还可以在-lt-intent-filter-gt-标签中再配置一个-lt-data-gt-标签，用于更精确地" class="headerlink" title="2.与此对应，我们还可以在&lt;intent-filter&gt;标签中再配置一个&lt;data&gt;标签，用于更精确地"></a>2.与此对应，我们还可以在&lt;intent-filter&gt;标签中再配置一个&lt;<font color="red">data</font>&gt;标签，用于更精确地</h4><pre><code>            指定当前活动能够响应什么类型的数据。\&lt;data&gt;标签中主要可以配置以下内容。
            android:scheme。用于指定数据的协议部分，如上例中的http部分。
            android:host。用于指定数据的主机名部分，如上例中的www.baidu.com部分。
            android:port。用于指定数据的端口部分，一般紧随在主机名之后。
            android:path。用于指定主机名和端口之后的部分,如一段网址中跟在域名之后的内容。
            android:mimeType。用于指定可以处理的数据类型,允许使用通配符的方式进行指定。
</code></pre>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><h5 id="这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了"><a href="#这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了" class="headerlink" title="这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了"></a>这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了</h5><h3 id="四、向下一个活动传递数据"><a href="#四、向下一个活动传递数据" class="headerlink" title="四、向下一个活动传递数据"></a>四、<font color="red">向下一个活动传递数据</font></h3><h4 id="1-通过Intent的putExtra-方法携带数据"><a href="#1-通过Intent的putExtra-方法携带数据" class="headerlink" title="1.通过Intent的putExtra()方法携带数据"></a>1.通过Intent的<font color="orange">putExtra()</font>方法携带数据</h4><h4 id="-2"><a href="#-2" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915194843260.png" alt="image-20200915194843260"></h4><h6 id="putExtra-“extra-data”-data-第一个参数是“键”，第二个参数是“数据”"><a href="#putExtra-“extra-data”-data-第一个参数是“键”，第二个参数是“数据”" class="headerlink" title="*putExtra(“extra_data”, data)*第一个参数是“键”，第二个参数是“数据”"></a>*<font color="orange">putExtra(“extra_data”, data)</font>*第一个参数是<strong>“键”</strong>，第二个参数是“数据”</h6><h4 id="2-通过Intent的getStringExtra-键-获取数据"><a href="#2-通过Intent的getStringExtra-键-获取数据" class="headerlink" title="2.通过Intent的getStringExtra(键)获取数据"></a>2.通过Intent的<font color="orange">getStringExtra(键)</font>获取数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915200007173.png" alt="image-20200915200007173"></p>
<h5 id="getStringExtra-getIntExtra-getBooleanExtra"><a href="#getStringExtra-getIntExtra-getBooleanExtra" class="headerlink" title="getStringExtra() / getIntExtra() / getBooleanExtra()"></a><font color="orange">getStringExtra() / getIntExtra() / getBooleanExtra()</font></h5><h3 id="五、返回数据给上一个活动"><a href="#五、返回数据给上一个活动" class="headerlink" title="五、返回数据给上一个活动"></a>五、<font color="red">返回数据给上一个活动</font></h3><h4 id="1-通过startActivityForResult（）来启动SecondActivity"><a href="#1-通过startActivityForResult（）来启动SecondActivity" class="headerlink" title="1.通过startActivityForResult（）来启动SecondActivity"></a>1.通过<font color="orange">startActivityForResult（）</font>来启动SecondActivity</h4><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915213454637.png" alt="image-20200915213454637"></p>
<h4 id="2-使用setResult（）返回数据"><a href="#2-使用setResult（）返回数据" class="headerlink" title="2.使用setResult（）返回数据"></a>2.使用<font color="orange">setResult（）</font>返回数据</h4><p>​                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915213859847.png" alt="image-20200915213859847"></p>
<h4 id="3-在FirstActivity中重写-onActivityResult（）"><a href="#3-在FirstActivity中重写-onActivityResult（）" class="headerlink" title="3.在FirstActivity中重写 onActivityResult（）"></a>3.在FirstActivity中重写<font color="orange"> onActivityResult（）</font></h4><p>​                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915214529345.png" alt="image-20200915214529345"></p>
<ol>
<li>首先通过检查requCode来判断数据来源，（FirstActivity可能调用startActivityForResult()去启动很多不同的活动，每个活动都会回调到活动的onActivityResult()中）。</li>
<li>然后通过resultCode来判断处理结果是否成功（RESULT_OK|RESULT_CANCELED）</li>
<li>最后通过 getStringExtra(键)来获取data携带的数据。</li>
</ol>
<h3 id="六、Bundle与Intent结合传递大量数据"><a href="#六、Bundle与Intent结合传递大量数据" class="headerlink" title="六、Bundle与Intent结合传递大量数据"></a>六、<font color="cornflowerblue">Bundle与Intent结合传递大量数据</font></h3><h4 id="1-传数据"><a href="#1-传数据" class="headerlink" title="1,传数据"></a>1,传数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">bundle.putString(&quot;date_string&quot;,&quot;some thing you just typed&quot;);</span><br><span class="line">bundle.putInt(&quot;data_Int&quot;,256);</span><br><span class="line">Intent intent = new Intent(...);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h4 id="2-取数据"><a href="#2-取数据" class="headerlink" title="2.取数据"></a>2.取数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intent  intent = getIntent();</span><br><span class="line">Bundle bundle = indent.getExtres();</span><br><span class="line">String str = bundle.getString(&quot;data_string&quot;);</span><br><span class="line">int in = bundle.getInt(&quot;data_Int&quot;);</span><br></pre></td></tr></table></figure>



<h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><h3 id="一、返回栈"><a href="#一、返回栈" class="headerlink" title="一、返回栈"></a>一、返回栈</h3><p>其实Android是使用任务(Task）来管理活动的，一个任务就是一组存放在栈里的活动的集其实Android是使用任务(Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈(Back Stack )。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中人栈，并处于栈顶的位置。而每当我们按下Back键或调用finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个人栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。</p>
<h3 id="二、活动状态"><a href="#二、活动状态" class="headerlink" title="二、活动状态"></a>二、活动状态</h3><h4 id="1-运行状态"><a href="#1-运行状态" class="headerlink" title="1.运行状态"></a>1.<font color="cornflowerblue">运行状态</font></h4><h5 id="当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。"><a href="#当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。" class="headerlink" title="当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。"></a>当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。</h5><h4 id="2-暂停状态"><a href="#2-暂停状态" class="headerlink" title="2.暂停状态"></a>2.<font color="cornflowerblue">暂停状态</font></h4><h5 id="当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。"><a href="#当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。" class="headerlink" title="当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。"></a>当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。</h5><h4 id="3-停止状态"><a href="#3-停止状态" class="headerlink" title="3.停止状态"></a>3.<font color="cornflowerblue">停止状态</font></h4><h5 id="当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保-存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可-能会被系统回收。"><a href="#当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保-存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可-能会被系统回收。" class="headerlink" title="当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保    存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可    能会被系统回收。"></a>当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保    存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可    能会被系统回收。</h5><h4 id="4-摧毁状态"><a href="#4-摧毁状态" class="headerlink" title="4.摧毁状态"></a>4.<font color="cornflowerblue">摧毁状态</font></h4><h5 id="当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证-手机的内存充足。"><a href="#当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证-手机的内存充足。" class="headerlink" title="当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证    手机的内存充足。"></a>当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证    手机的内存充足。</h5><h3 id="三、活动的生存期"><a href="#三、活动的生存期" class="headerlink" title="三、活动的生存期"></a>三、活动的生存期</h3><h4 id="1-oncCreat-活动第一次被创建时调用"><a href="#1-oncCreat-活动第一次被创建时调用" class="headerlink" title="1.oncCreat(): 活动第一次被创建时调用"></a>1.oncCreat(): 活动第一次被创建时调用</h4><h4 id="2-onStart-在活动由不可见变为可见时调用"><a href="#2-onStart-在活动由不可见变为可见时调用" class="headerlink" title="2.onStart(): 在活动由不可见变为可见时调用"></a>2.onStart(): 在活动由不可见变为可见时调用</h4><h4 id="3-onResume-在活动准备好和用户进行交互时调用"><a href="#3-onResume-在活动准备好和用户进行交互时调用" class="headerlink" title="3.onResume(): 在活动准备好和用户进行交互时调用"></a>3.onResume(): 在活动准备好和用户进行交互时调用</h4><h4 id="4-onPause-在系统准备启动或者恢复另一个活动时调用"><a href="#4-onPause-在系统准备启动或者恢复另一个活动时调用" class="headerlink" title="4.onPause(): 在系统准备启动或者恢复另一个活动时调用"></a>4.onPause(): 在系统准备启动或者恢复另一个活动时调用</h4><h4 id="5-onStop-在活动完全不可见时调用"><a href="#5-onStop-在活动完全不可见时调用" class="headerlink" title="5.onStop(): 在活动完全不可见时调用"></a>5.onStop(): 在活动完全不可见时调用</h4><h4 id="6-onDestory-在活动被销毁时调用"><a href="#6-onDestory-在活动被销毁时调用" class="headerlink" title="6.onDestory(): 在活动被销毁时调用"></a>6.onDestory(): 在活动被销毁时调用</h4><h4 id="7-onRestart-在活动由停止状态变为运行状态时调用"><a href="#7-onRestart-在活动由停止状态变为运行状态时调用" class="headerlink" title="7.onRestart(): 在活动由停止状态变为运行状态时调用"></a>7.onRestart(): 在活动由停止状态变为运行状态时调用</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200919221411685.png" alt="image-20200919221411685" style="zoom: 67%;">

<p>​    完整生存期：onCreate() → onDestory()</p>
<p>​    可见生存期：onStart() → onStop()</p>
<p>​    前台生存期：onResume() → onPause()</p>
<h3 id="四、体验活动的生命周期"><a href="#四、体验活动的生命周期" class="headerlink" title="四、体验活动的生命周期"></a>四、体验活动的生命周期</h3><h4 id="1-新建两个活动分别为-NormalActicity-和-DialogActivity"><a href="#1-新建两个活动分别为-NormalActicity-和-DialogActivity" class="headerlink" title="1.新建两个活动分别为 NormalActicity 和 DialogActivity"></a>1.新建两个活动分别为 NormalActicity 和 DialogActivity</h4><h4 id="2-修改对话框活动的主题："><a href="#2-修改对话框活动的主题：" class="headerlink" title="2.修改对话框活动的主题："></a>2.修改对话框活动的主题：</h4><ol>
<li><h5 id="AppCompatActivity-android-theme-”-style-Theme-AppCompat-Dialog”"><a href="#AppCompatActivity-android-theme-”-style-Theme-AppCompat-Dialog”" class="headerlink" title="AppCompatActivity: android:theme=”@style/Theme.AppCompat.Dialog”"></a><font color="red">AppCompatActivity</font>: <strong>android:theme=”@style/Theme.AppCompat.Dialog”</strong></h5></li>
<li><h5 id="Activity-android-theme-”-android-style-Theme-Dialog”"><a href="#Activity-android-theme-”-android-style-Theme-Dialog”" class="headerlink" title="Activity:android:theme=”@android:style/Theme.Dialog”"></a><font color="red">Activity:android</font>:<strong>theme=”@android:style/Theme.Dialog”</strong></h5></li>
</ol>
<h4 id="3-在主活动中打印日志（充分利用日志过滤器）"><a href="#3-在主活动中打印日志（充分利用日志过滤器）" class="headerlink" title="3.在主活动中打印日志（充分利用日志过滤器）"></a>3.在主活动中打印日志（充分利用日志过滤器）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200919222550069.png" alt="image-20200919222550069"></p>
<h5 id="（1）可以看到，MainActivity-第一次被创建时会依次执行-onCreate-、onStart-和-onResume-方法；"><a href="#（1）可以看到，MainActivity-第一次被创建时会依次执行-onCreate-、onStart-和-onResume-方法；" class="headerlink" title="（1）可以看到，MainActivity 第一次被创建时会依次执行 onCreate()、onStart() 和 onResume()方法；"></a>（1）可以看到，MainActivity 第一次被创建时会依次执行 onCreate()、onStart() 和 onResume()方法；</h5><h5 id="（2）启动NormalActivity-会执行-onPause-和-onStop-因为NormalActivity已经完全遮住MainActivity了；"><a href="#（2）启动NormalActivity-会执行-onPause-和-onStop-因为NormalActivity已经完全遮住MainActivity了；" class="headerlink" title="（2）启动NormalActivity,会执行 onPause() 和 onStop(),因为NormalActivity已经完全遮住MainActivity了；"></a>（2）启动NormalActivity,会执行 onPause() 和 onStop(),因为NormalActivity已经完全遮住MainActivity了；</h5><h5 id="（3）返回MainActivity，会执行-onRestart-、onStart-和onResume"><a href="#（3）返回MainActivity，会执行-onRestart-、onStart-和onResume" class="headerlink" title="（3）返回MainActivity，会执行 onRestart()、onStart()和onResume();"></a>（3）返回MainActivity，会执行 onRestart()、onStart()和onResume();</h5><h5 id="（4）启动DialogActivity-只会执行onPause-方法，因为此时MainActivity没有完全遮住；"><a href="#（4）启动DialogActivity-只会执行onPause-方法，因为此时MainActivity没有完全遮住；" class="headerlink" title="（4）启动DialogActivity,只会执行onPause()方法，因为此时MainActivity没有完全遮住；"></a>（4）启动DialogActivity,只会执行onPause()方法，因为此时MainActivity没有完全遮住；</h5><h5 id="（5）返回MainActivity-只会执行onResume。"><a href="#（5）返回MainActivity-只会执行onResume。" class="headerlink" title="（5）返回MainActivity,只会执行onResume。"></a>（5）返回MainActivity,只会执行onResume。</h5><h3 id="五、活动被回收了怎么办"><a href="#五、活动被回收了怎么办" class="headerlink" title="五、活动被回收了怎么办"></a>五、活动被回收了怎么办</h3><h4 id="1-问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate-创建一个新的实例，造成数据的丢失。"><a href="#1-问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate-创建一个新的实例，造成数据的丢失。" class="headerlink" title="1.问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate()创建一个新的实例，造成数据的丢失。"></a>1.问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate()创建一个新的实例，造成数据的丢失。</h4><h4 id="2-通过onSaveInstanceState-回调方法保存数据"><a href="#2-通过onSaveInstanceState-回调方法保存数据" class="headerlink" title="2.通过onSaveInstanceState()回调方法保存数据"></a>2.通过<font color="red">onSaveInstanceState()</font>回调方法保存数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@0verride</span><br><span class="line">protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">	super.onSaveInstancestate(outState);</span><br><span class="line">	string tempData - &quot;Something you just typed&quot;;</span><br><span class="line">	outState.putString( &quot;data_key&quot; , tempData) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="-3"><a href="#-3" class="headerlink" title></a></h4><h4 id="3-在onCreate-中取值"><a href="#3-在onCreate-中取值" class="headerlink" title="3.在onCreate()中取值"></a>3.在onCreate()中取值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (savedInstancestate != null)&#123;</span><br><span class="line">	String tempData = savedInstanceState.getString(&quot;data_key&quot;);</span><br><span class="line">	Log.d(TAG,tempData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="活动的启动模式-（launchMode"><a href="#活动的启动模式-（launchMode" class="headerlink" title="活动的启动模式 （launchMode)"></a>活动的启动模式 （launchMode)</h2><h3 id="一、standard"><a href="#一、standard" class="headerlink" title="一、standard"></a>一、standard</h3><h4 id="1-standard是活动默认的启动模式"><a href="#1-standard是活动默认的启动模式" class="headerlink" title="1.standard是活动默认的启动模式"></a>1.standard是活动默认的启动模式</h4><p>​        每当启动一个新的活动，它就会在返回栈中人栈，并处于栈顶的位置。对于使用standard模式的活动，</p>
<p>​        系统不会在乎这个活动是否已经在返回栈中存在<font color="red">，每次启动都会创建该活动的一个新的实例</font>。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131226413.png" alt="image-20200922131226413" style="zoom: 67%;"></h4><h3 id="二、singleTop"><a href="#二、singleTop" class="headerlink" title="二、singleTop"></a>二、singleTop</h3><h4 id="1-当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。"><a href="#1-当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。" class="headerlink" title="1.当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。"></a>1.当活动的启动模式指定为singleTop，在启动活动时如果发现<font color="red">返回栈的栈顶已经是该活动</font>，则认为可以<font color="red">直接使用</font>它，不会再创建新的活动实例。</h4><h4 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131614840.png" alt="image-20200922131614840" style="zoom: 67%;"></h4><h3 id="三、singleTask"><a href="#三、singleTask" class="headerlink" title="三、singleTask"></a>三、singleTask</h3><h4 id="1-当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。"><a href="#1-当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。" class="headerlink" title="1.当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。"></a>1.当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则<font color="red">直接使用该实例，并把在这个活动之上的所有活动统统出栈</font>，如果没有发现就会创建一个新的活动实例。</h4><h4 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131805919.png" alt="image-20200922131805919" style="zoom: 67%;"></h4><h3 id="四、singleInstance"><a href="#四、singleInstance" class="headerlink" title="四、singleInstance"></a>四、singleInstance</h3><h4 id="1-指定为singleInstance的活动会启动一个新的返回栈，"><a href="#1-指定为singleInstance的活动会启动一个新的返回栈，" class="headerlink" title="1.指定为singleInstance的活动会启动一个新的返回栈，"></a>1.指定为singleInstance的活动会启动一个新的返回栈，</h4><p>在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了<font color="red">共享活动实例</font>的问题。</p>
<h4 id="2-3"><a href="#2-3" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922132137611.png" alt="image-20200922132137611" style="zoom:67%;"></h4><h2 id="活动的最佳实践"><a href="#活动的最佳实践" class="headerlink" title="活动的最佳实践"></a>活动的最佳实践</h2><h1 id="第三章-UI开发的点点滴滴"><a href="#第三章-UI开发的点点滴滴" class="headerlink" title="第三章 UI开发的点点滴滴"></a>第三章 UI开发的点点滴滴</h1><h2 id="如何编写程序界面"><a href="#如何编写程序界面" class="headerlink" title="如何编写程序界面"></a>如何编写程序界面</h2><h2 id="常用控件的使用方法"><a href="#常用控件的使用方法" class="headerlink" title="常用控件的使用方法"></a>常用控件的使用方法</h2><h3 id="一、TextView"><a href="#一、TextView" class="headerlink" title="一、TextView"></a>一、<font color="cornflowerblue">TextView</font></h3><h4 id="1-文本对齐方式-gravity"><a href="#1-文本对齐方式-gravity" class="headerlink" title="1.文本对齐方式(gravity)"></a>1.文本对齐方式(<font color="red">gravity</font>)</h4><h5 id="android-gravity-”center-top-bottom-left-right”"><a href="#android-gravity-”center-top-bottom-left-right”" class="headerlink" title="android: gravity=”center|top|bottom|left|right”"></a>android: gravity=”center|top|bottom|left|right”</h5><h4 id="2-文本颜色，大小（textColor、textSize）"><a href="#2-文本颜色，大小（textColor、textSize）" class="headerlink" title="2.文本颜色，大小（textColor、textSize）"></a>2.文本颜色，大小（<font color="red">textColor、textSize</font>）</h4><h5 id="字体以“sp”为单位"><a href="#字体以“sp”为单位" class="headerlink" title="字体以“sp”为单位"></a>字体以“sp”为单位</h5><h4 id="3-文本标签TextView其它的XML文件元素"><a href="#3-文本标签TextView其它的XML文件元素" class="headerlink" title="3.文本标签TextView其它的XML文件元素"></a>3.文本标签TextView其它的XML文件元素</h4><table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:autoLink</td>
<td>设置是否当文本为URL链接/email/电话号码/map时，文本显示为可单击的链接。可选值(none/web/email/phone/map/all)</td>
</tr>
<tr>
<td>android:autoText</td>
<td>如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。</td>
</tr>
<tr>
<td>android:linksClickable</td>
<td>设置链接是否单击连接，即使设置了autoLink。</td>
</tr>
<tr>
<td>android:maxLength</td>
<td>限制显示的文本长度，超出部分不显示。</td>
</tr>
<tr>
<td>android:lines</td>
<td>设置文本的行数，设置两行就显示两行，即使第二行没有数据。</td>
</tr>
<tr>
<td>android:maxLines</td>
<td>设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。</td>
</tr>
<tr>
<td>android:minLines</td>
<td>设置文本的最小行数，与lines类似。</td>
</tr>
<tr>
<td>android:lineSpacingExtra</td>
<td>设置行间距。</td>
</tr>
<tr>
<td>android:lineSpacingMultiplier</td>
<td>设置行间距的倍数。如”1.2”</td>
</tr>
<tr>
<td>android:textColor</td>
<td>设置文本颜色</td>
</tr>
<tr>
<td>android:textColorLink</td>
<td>文字链接的颜色.</td>
</tr>
<tr>
<td>android:textStyle</td>
<td>设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开</td>
</tr>
<tr>
<td>android:maxHeight</td>
<td>设置文本区域的最大高度</td>
</tr>
<tr>
<td>android:minHeight</td>
<td>设置文本区域的最小高度</td>
</tr>
<tr>
<td>android:minWidth</td>
<td>设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。</td>
</tr>
<tr>
<td>android:maxWidth</td>
<td>设置文本区域的最大宽度</td>
</tr>
</tbody></table>
<h3 id="二、Button"><a href="#二、Button" class="headerlink" title="二、Button"></a>二、<font color="cornflowerblue">Button</font></h3><h4 id="1-自动进行大小写转换（textAllCaps"><a href="#1-自动进行大小写转换（textAllCaps" class="headerlink" title="1.自动进行大小写转换（textAllCaps)"></a>1.自动进行大小写转换（<font color="red">textAllCaps</font>)</h4><h5 id="android-textALlCaps-”false-true”"><a href="#android-textALlCaps-”false-true”" class="headerlink" title="android: textALlCaps:”false|true”"></a>android: textALlCaps:”false|true”</h5><h4 id="2-4种事件监听器的注册方式"><a href="#2-4种事件监听器的注册方式" class="headerlink" title="2. 4种事件监听器的注册方式"></a>2. 4种事件监听器的注册方式</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141303023.png" alt="image-20200923141303023" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141336930.png" alt="image-20200923141336930" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141506965.png" alt="image-20200923141506965" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141521823.png" alt="image-20200923141521823" style="zoom:67%;">



<h3 id="三、EditText"><a href="#三、EditText" class="headerlink" title="三、EditText"></a>三、<font color="cornflowerblue">EditText</font></h3><h4 id="1-提示性文字（hint"><a href="#1-提示性文字（hint" class="headerlink" title="1.提示性文字（hint)"></a>1.提示性文字（<font color="red">hint</font>)</h4><h4 id="2-最大行数（maxLines）"><a href="#2-最大行数（maxLines）" class="headerlink" title="2.最大行数（maxLines）"></a>2.最大行数（<font color="red">maxLines</font>）</h4><h4 id="3-密码框（android-inputType-”TextPassword”）"><a href="#3-密码框（android-inputType-”TextPassword”）" class="headerlink" title="3.密码框（android: inputType=”TextPassword”）"></a>3.密码框（<font color="red">android: inputType=”TextPassword”</font>）</h4><h4 id="4-获取文本内容（-getText-toString-）"><a href="#4-获取文本内容（-getText-toString-）" class="headerlink" title="4.获取文本内容（,,, .getText().toString( )  ）"></a>4.获取文本内容（<font color="red">,,, .getText().toString( )</font>  ）</h4><h4 id="5-输入框EditText-其它的XML文件元素"><a href="#5-输入框EditText-其它的XML文件元素" class="headerlink" title="5.输入框EditText 其它的XML文件元素"></a>5.输入框EditText 其它的XML文件元素</h4><table>
<thead>
<tr>
<th><strong>属性名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>android:<strong>imeOptions</strong></td>
<td><strong>设置软键盘的<strong><strong>Enter</strong></strong>键</strong>。有如下值可设置：normal，actionUnspecified，actionNone，actionGo，actionSearch，actionSend，actionNext，actionDone，flagNoExtractUi，flagNoAccessoryAction，flagNoEnterAction。可用’|’设置多个。这里仅设置显示图标之用。</td>
</tr>
<tr>
<td>android:imeActionId</td>
<td>设置IME动作ID，在onEditorAction中捕获判断进行逻辑操作。</td>
</tr>
<tr>
<td>android:imeActionLabel</td>
<td>设置IME动作标签。但是不能保证一定会使用，猜想在输入法扩展的时候应该有用。</td>
</tr>
<tr>
<td>android:<strong>singleLine</strong></td>
<td>设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=”test_ singleLine “ android:singleLine=”true” android:layout_width=”20dp” 将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行</td>
</tr>
<tr>
<td>android:<strong>maxlines</strong></td>
<td>指定 EditText 的最大行数，当输入的内容超过指定最大行数时，文本就会向上滚动，而不继续拉伸EditText</td>
</tr>
</tbody></table>
<h3 id="四、ImageView"><a href="#四、ImageView" class="headerlink" title="四、ImageView"></a>四、<font color="cornflowerblue">ImageView</font></h3><h4 id="1-android-src"><a href="#1-android-src" class="headerlink" title="1.android:src"></a>1.android:src</h4><h4 id="2-android-background"><a href="#2-android-background" class="headerlink" title="2. android:background"></a>2. android:background</h4><h4 id="3-setImageResource-方法"><a href="#3-setImageResource-方法" class="headerlink" title="3.setImageResource()方法"></a>3.setImageResource()方法</h4><h3 id="五、ProgressBar-进度条"><a href="#五、ProgressBar-进度条" class="headerlink" title="五、ProgressBar (进度条)"></a>五、<font color="cornflowerblue">ProgressBar </font>(进度条)</h3><h4 id="1-（控件通用属性）visibility-”visiblle-invisible-gone”"><a href="#1-（控件通用属性）visibility-”visiblle-invisible-gone”" class="headerlink" title="1.（控件通用属性）visibility=”visiblle|invisible|gone”"></a>1.（控件通用属性）<font color="red">visibility</font>=”visiblle|invisible|gone”</h4><h4 id="2-代码中获取-控制控件可见性"><a href="#2-代码中获取-控制控件可见性" class="headerlink" title="2.代码中获取/控制控件可见性"></a>2.代码中获取/控制控件可见性</h4><p>​            获取：getVisibility()</p>
<p>​            设置：setVisibility(<font color="red">View.VISIBLE|View.INVISIBLE|View.GONE</font>)</p>
<h4 id="3-水平进度条"><a href="#3-水平进度条" class="headerlink" title="3.水平进度条"></a>3.水平进度条</h4><h5 id="（1）style-”-android-attr-progressBarStyleHorizontal”-类别"><a href="#（1）style-”-android-attr-progressBarStyleHorizontal”-类别" class="headerlink" title="（1）style=”?android:attr/progressBarStyleHorizontal”    //类别"></a>（1）style=”?android:attr/progressBarStyleHorizontal”    //类别</h5><h5 id="android-max-”100”-进度条最大值"><a href="#android-max-”100”-进度条最大值" class="headerlink" title="android:max=”100”    //进度条最大值"></a>android:max=”100”    //进度条最大值</h5><h5 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922172028074.png" alt="image-20200922172028074" style="zoom:50%;"></h5><h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><h4 id="-4"><a href="#-4" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141825784.png" alt="image-20200923141825784" style="zoom:50%;"></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141850913.png" alt="image-20200923141850913" style="zoom:50%;">

<h3 id="六、AlterDialog（对话框）"><a href="#六、AlterDialog（对话框）" class="headerlink" title="六、AlterDialog（对话框）"></a>六、<font color="cornflowerblue">AlterDialog</font>（对话框）</h3><h4 id="1-AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog-一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示"><a href="#1-AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog-一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示" class="headerlink" title="1.AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示:"></a>1.AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示:</h4><h4 id="2-4"><a href="#2-4" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922172454707.png" alt="image-20200922172454707" style="zoom:67%;"></h4><p>​            首先通过<font color="red">AlertDialog.Builder</font>创建一个AlertDialog 的实例,然后可以为这个对话框设置标题、<br>​    内容、可否取消等属性，接下来调用<font color="red">setPositiveButton()</font>方法为对话框设置确定按钮的点击<br>​    事件，调用<font color="red">setNegativeButton()</font>方法设置取消按钮的点击事件，最后调用<font color="red">show()</font>方法将对话<br>​    框显示出来。</p>
<h3 id="七、ProgressDialog-带进度条的提示框"><a href="#七、ProgressDialog-带进度条的提示框" class="headerlink" title="七、ProgressDialog(带进度条的提示框)"></a>七、<font color="cornflowerblue">ProgressDialog</font>(带进度条的提示框)</h3><h4 id="1-ProgressDialog-和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog-会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog-也比较相似"><a href="#1-ProgressDialog-和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog-会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog-也比较相似" class="headerlink" title="1.ProgressDialog 和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog 也比较相似"></a>1.ProgressDialog 和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog 也比较相似</h4><h4 id="2-5"><a href="#2-5" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922173459763.png" alt="image-20200922173459763" style="zoom:67%;"></h4><p>注意，如果在<font color="red">setCancelable()中传人了false</font>，表示ProgressDialog是不能通过Back键<br>取消掉的，这时你就一定要在代码中做好控制，当数据加载完成后必须要调用ProgressDialog 的<br>dismiss()方法来关闭对话框，否则ProgressDialog将会一直存在。</p>
<h3 id="八、RadioButton-单选按钮-和-Checkbox-复选框"><a href="#八、RadioButton-单选按钮-和-Checkbox-复选框" class="headerlink" title="八、RadioButton(单选按钮) 和 Checkbox(复选框)"></a>八、<font color="cornflowerblue">RadioButton(单选按钮) 和 Checkbox(复选框)</font></h3><h3 id="九、Spinner-下拉框"><a href="#九、Spinner-下拉框" class="headerlink" title="九、Spinner (下拉框)"></a>九、<font color="cornflowerblue">Spinner (下拉框)</font></h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142240994.png" alt="image-20200923142240994" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142315034.png" alt="image-20200923142315034" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142334764.png" alt="image-20200923142334764" style="zoom:67%;">



<h2 id="详解4种基本布局"><a href="#详解4种基本布局" class="headerlink" title="详解4种基本布局"></a>详解4种基本布局</h2><h3 id="一、线性布局（LinearLayout）"><a href="#一、线性布局（LinearLayout）" class="headerlink" title="一、线性布局（LinearLayout）"></a>一、线性布局（<font color="cornflowerblue">LinearLayout</font>）</h3><h4 id="1-排列方向orientation"><a href="#1-排列方向orientation" class="headerlink" title="1.排列方向orientation"></a>1.排列方向<font color="red">orientation</font></h4><h5 id="1-horizontal-2-vertical"><a href="#1-horizontal-2-vertical" class="headerlink" title="(1)horizontal        (2)vertical"></a>(1)horizontal        (2)vertical</h5><p>​    </p>
<h4 id="2-对齐方式"><a href="#2-对齐方式" class="headerlink" title="2.对齐方式"></a>2.对齐方式</h4><h5 id="（1）gravity-文字在控件中的对齐方式"><a href="#（1）gravity-文字在控件中的对齐方式" class="headerlink" title="（1）gravity: 文字在控件中的对齐方式"></a>（1）gravity: <font color="orange">文字在控件中</font>的对齐方式</h5><h5 id="（2）layout-gravity-控件在布局中的对齐方式"><a href="#（2）layout-gravity-控件在布局中的对齐方式" class="headerlink" title="（2）layout_gravity: 控件在布局中的对齐方式"></a>（2）<font color="red">layout_gravity</font>: <font color="orange">控件在布局中</font>的对齐方式</h5><p>​                top、bottom、left、right、center_vertical、center_horizontal</p>
<p>​        <strong>！注意</strong>：LinearLayout的排列方向是horizontal时，只有垂直方向上的对齐方式才会生效，因为此时    水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式。同样的道理，当LinearLayout的排列方向是vertical时，只有水平方向上的对齐方式才会生效。</p>
<h4 id="3-重要属性-layout-weight"><a href="#3-重要属性-layout-weight" class="headerlink" title="3.重要属性 layout_weight"></a>3.重要属性 <font color="red">layout_weight</font></h4><h5 id="1-允许我们使用比例的方式来指定控件的大小-它在手机屏幕的适配性方面可以起到非常重要"><a href="#1-允许我们使用比例的方式来指定控件的大小-它在手机屏幕的适配性方面可以起到非常重要" class="headerlink" title="(1)允许我们使用比例的方式来指定控件的大小,它在手机屏幕的适配性方面可以起到非常重要"></a>(1)允许我们使用<font color="red">比例的方式</font>来指定控件的大小,它在手机屏幕的适配性方面可以起到非常重要</h5><h5 id="2-定义水平-垂直方向的比例时，需要指定layout-width-”0dp”-layout-height-”0dp”"><a href="#2-定义水平-垂直方向的比例时，需要指定layout-width-”0dp”-layout-height-”0dp”" class="headerlink" title="(2)定义水平/垂直方向的比例时，需要指定layout_width=”0dp”/layout_height=”0dp”"></a>(2)定义水平/垂直方向的比例时，需要指定<font color="red">layout_width=”0dp”/layout_height=”0dp”</font></h5><h5 id="-5"><a href="#-5" class="headerlink" title></a></h5><h3 id="二、相对布局"><a href="#二、相对布局" class="headerlink" title="二、相对布局"></a>二、相对布局</h3><h4 id="1-相对于父布局进行定位"><a href="#1-相对于父布局进行定位" class="headerlink" title="1.相对于父布局进行定位"></a>1.相对于<font color="red">父布局</font>进行定位</h4><table>
<thead>
<tr>
<th align="left"><strong>属性声明</strong></th>
<th align="center"><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>android:layout_alignParentLeft</strong></td>
<td align="center">是否跟父布局左对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentRight</strong></td>
<td align="center">是否跟父布局右对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentTop</strong></td>
<td align="center">是否跟父布局顶部对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentBottom</strong></td>
<td align="center">是否跟父布局底部对齐</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerHorizontal</strong></td>
<td align="center">在父布局中水平居中</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerVertical</strong></td>
<td align="center">在父布局中垂直居中</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerInParent</strong></td>
<td align="center">在父布局的中间位置</td>
</tr>
</tbody></table>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922224343384.png" alt="image-20200922224343384" style="zoom: 33%;">



<h4 id="2-相对于兄弟组件定位"><a href="#2-相对于兄弟组件定位" class="headerlink" title="2.相对于兄弟组件定位"></a>2.相对于<font color="red">兄弟组件</font>定位</h4><p>​        </p>
<table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>android:layout_toRightOf</strong>=“控件id”</td>
<td>在指定控件右边</td>
</tr>
<tr>
<td><strong>android:layout_toLeftOf</strong>=“控件id”</td>
<td>在指定控件左边</td>
</tr>
<tr>
<td><strong>android:layout_above</strong>=“控件id”</td>
<td>在指定控件上边</td>
</tr>
<tr>
<td><strong>android:layout_below=“控件id”</strong></td>
<td>在指定控件下边</td>
</tr>
<tr>
<td><strong>android:layout_alignBaseline</strong>=“控件id”</td>
<td>与指定控件水平对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignLeft</strong>=“控件id”</td>
<td>与指定控件左对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignRight</strong>=“控件id”</td>
<td>与指定控件右对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignTop</strong>=“控件id”</td>
<td>与指定控件顶部对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignBottom</strong>=“控件id”</td>
<td>与指定控件底部对齐</td>
</tr>
</tbody></table>
<h4 id="3-margin-偏移-：设置组件与相对于的边距"><a href="#3-margin-偏移-：设置组件与相对于的边距" class="headerlink" title="3. margin(偏移)：设置组件与相对于的边距"></a>3.<font color="red"> margin(偏移)</font>：设置组件与相对于的边距</h4><table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>layout_margin</strong></td>
<td>设置组件上下左右的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginLeft</strong></td>
<td>设置组件离左边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginRight</strong></td>
<td>设置组件离右边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginTop</strong></td>
<td>设置组件离上边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginBottom</strong></td>
<td>设置组件离下边的偏移量</td>
</tr>
</tbody></table>
<h4 id="4-padding-填充-：设置组件内部元素间的边距"><a href="#4-padding-填充-：设置组件内部元素间的边距" class="headerlink" title="4.padding(填充)：设置组件内部元素间的边距"></a>4.<font color="red">padding(填充)</font>：设置组件内部元素间的边距</h4><table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>padding</strong></td>
<td>设置组件上下左右的偏移量</td>
</tr>
<tr>
<td><strong>paddingLeft</strong></td>
<td>设置组件离左边的偏移量</td>
</tr>
<tr>
<td><strong>paddingRight</strong></td>
<td>设置组件离右边的偏移量</td>
</tr>
<tr>
<td><strong>paddingTop</strong></td>
<td>设置组件离上边的偏移量</td>
</tr>
<tr>
<td><strong>paddingBottom</strong></td>
<td>设置组件离下边的偏移量</td>
</tr>
</tbody></table>
<h5 id="！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。"><a href="#！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。" class="headerlink" title="！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。"></a>！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。</h5><h3 id="三、帧布局"><a href="#三、帧布局" class="headerlink" title="三、帧布局"></a>三、帧布局</h3><h3 id="四、百分百布局"><a href="#四、百分百布局" class="headerlink" title="四、百分百布局"></a>四、百分百布局</h3><h4 id="1-percentFrameLayout-继承了FrameLayout的全部特性"><a href="#1-percentFrameLayout-继承了FrameLayout的全部特性" class="headerlink" title="1.percentFrameLayout: 继承了FrameLayout的全部特性"></a>1.<font color="red">percentFrameLayout</font>: 继承了FrameLayout的全部特性</h4><h4 id="percentRelativeLayout-继承了RelativeLayout的全部特性"><a href="#percentRelativeLayout-继承了RelativeLayout的全部特性" class="headerlink" title="percentRelativeLayout: 继承了RelativeLayout的全部特性"></a><font color="red">percentRelativeLayout</font>: 继承了RelativeLayout的全部特性</h4><h4 id="2-设置组件的宽高"><a href="#2-设置组件的宽高" class="headerlink" title="2.设置组件的宽高"></a>2.设置组件的宽高</h4><h5 id="app-layout-widthPercent-”-”"><a href="#app-layout-widthPercent-”-”" class="headerlink" title="app: layout_widthPercent=”..%”"></a>app: <font color="red">layout_widthPercent</font>=”..%”</h5><h5 id="app-layout-heightPercent-“-”"><a href="#app-layout-heightPercent-“-”" class="headerlink" title="app: layout_heightPercent=“..%”"></a>app: layout_heightPercent=“..%”</h5><h4 id="3-在项目的build-gradle中添加百分比布局库的依赖-保证百分比布局在Android所有系统版本上的兼容性"><a href="#3-在项目的build-gradle中添加百分比布局库的依赖-保证百分比布局在Android所有系统版本上的兼容性" class="headerlink" title="3.在项目的build.gradle中添加百分比布局库的依赖,保证百分比布局在Android所有系统版本上的兼容性"></a>3.在项目的build.gradle中添加百分比布局库的依赖,保证百分比布局在Android所有系统版本上的兼容性</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922230757044.png" alt="image-20200922230757044"></p>
<h4 id="4-使用百分比布局"><a href="#4-使用百分比布局" class="headerlink" title="4.使用百分比布局"></a>4.使用百分比布局</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922230933563.png" alt="image-20200922230933563"></p>
<h2 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h2><h3 id="1-引入布局"><a href="#1-引入布局" class="headerlink" title="1.引入布局"></a>1.引入布局</h3><h4 id="（1）创建一个标题栏布局title-xml文件"><a href="#（1）创建一个标题栏布局title-xml文件" class="headerlink" title="（1）创建一个标题栏布局title.xml文件"></a>（1）创建一个标题栏布局title.xml文件</h4><h4 id="（2）在活动中引用-lt-include-layout-“-layout-title”-gt"><a href="#（2）在活动中引用-lt-include-layout-“-layout-title”-gt" class="headerlink" title="（2）在活动中引用  &lt;include layout = “@layout/title”/ &gt;"></a>（2）在活动中引用  <font color="red">&lt;include layout = “@layout/title”/ &gt;</font></h4><h4 id="3-隐藏系统自带的标题栏"><a href="#3-隐藏系统自带的标题栏" class="headerlink" title="(3) 隐藏系统自带的标题栏"></a>(3) 隐藏系统自带的标题栏</h4><h4 id="ActionBar-actionbar-getSupportActionBar"><a href="#ActionBar-actionbar-getSupportActionBar" class="headerlink" title="ActionBar actionbar = getSupportActionBar("></a><font color="red">ActionBar actionbar = getSupportActionBar(</font></h4><pre><code>    &lt;font color=&#39;red&#39;&gt;if (actionbar !=null) &#123;&lt;/font&gt;
        &lt;font color=&#39;red&#39;&gt;actionbar.hide( );&lt;/font&gt;
    &lt;font color=&#39;red&#39;&gt;&#125;&lt;/font&gt;
</code></pre>
<h3 id="2-创建自定义控件（布局）"><a href="#2-创建自定义控件（布局）" class="headerlink" title="2.创建自定义控件（布局）"></a>2.创建自定义控件（布局）</h3><h4 id="（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题-但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。"><a href="#（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题-但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。" class="headerlink" title="（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题,但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。"></a>（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题,但是如果布局中有一些控件<font color="red">要求能够响应事件</font>，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用<font color="red">自定义控件</font>的方式来解决。</h4><h4 id="（2）创建一个自定义布局类-TitleLayout-包含组件的响应事件"><a href="#（2）创建一个自定义布局类-TitleLayout-包含组件的响应事件" class="headerlink" title="（2）创建一个自定义布局类 TitleLayout(包含组件的响应事件)"></a>（2）创建一个自定义布局类 TitleLayout(包含组件的响应事件)</h4><p>public class TitleLayout extends LinearLayout {</p>
<p>​    public TitleLayout(Context context，AttributeSet attrs) {<br>​            super(context,attrs);<br>​            <font color="red">LayoutInflater.from(context).inflate(R.layout.title, this);</font>    //动态加载布局文件</p>
<p>​                                                                        //布局id， 父布局</p>
<p>​            Button titleBack = (Button) findViewById(R.id.title_back);<br>​            Button titleEdit = (Button) findViewById(R.id.title_edit);<br>​            titleBack.setOnclickListener(new onclickListener(){<br>​                @override<br>​                public void onclick(View v) {<br>​                        <font color="red">( (Activity) getContext()).finish();</font>    //结束此次活动<br>​                }<br>​            });<br>​            titleEdit.setonclickListener(new OnclickListener() {<br>​                @override<br>​                public void onclick(View v){<br>​                Toast.makeText(getContext()，”You clicked Edit button”,<br>​                Toast.LENGTH_SHORT).show();<br>​                });</p>
<p>​        }</p>
<p>}</p>
<h4 id="3-在布局文件中添加这个自定义控件"><a href="#3-在布局文件中添加这个自定义控件" class="headerlink" title="3.在布局文件中添加这个自定义控件"></a>3.在布局文件中添加这个自定义控件</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200930140657613.png" alt="image-20200930140657613"></p>
<h5 id="添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我"><a href="#添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我" class="headerlink" title="添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我"></a>添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我</h5><pre><code>们需要指明&lt;font color=&#39;red&#39;&gt;控件的完整类名&lt;/font&gt;，&lt;font color=&#39;red&#39;&gt;包名在这里是不可以省略的&lt;/font&gt;。
</code></pre>
<h2 id="最常用和最难用的控件——ListView"><a href="#最常用和最难用的控件——ListView" class="headerlink" title="最常用和最难用的控件——ListView"></a>最常用和最难用的控件——ListView</h2><h3 id="一、ListView的简单用法"><a href="#一、ListView的简单用法" class="headerlink" title="一、ListView的简单用法"></a>一、ListView的简单用法</h3><h4 id="1-在布局中加入ListView控件"><a href="#1-在布局中加入ListView控件" class="headerlink" title="1.在布局中加入ListView控件"></a>1.在布局中加入ListView控件</h4><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193319537.png" alt="image-20201001193319537" style="zoom:67%;"></p>
<h4 id="2-准备数据（M）"><a href="#2-准备数据（M）" class="headerlink" title="2.准备数据（M）"></a>2.准备数据（M）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193518241.png" alt="image-20201001193518241"></p>
<h4 id="3-准备视图（V）"><a href="#3-准备视图（V）" class="headerlink" title="3.准备视图（V）"></a>3.准备视图（V）</h4><h5 id="ListView-listView-ListView-findViewById-R-id-list-view"><a href="#ListView-listView-ListView-findViewById-R-id-list-view" class="headerlink" title="ListView listView = (ListView) findViewById(R.id.list_view);"></a>ListView listView = (ListView) findViewById(R.id.list_view);</h5><h4 id="4-准备适配器-C"><a href="#4-准备适配器-C" class="headerlink" title="4.准备适配器(C)"></a>4.准备适配器(C)</h4><h5 id="ArrayAdapter-lt-String-gt-adapter-new-ArrayAdapter-lt-String-gt-MainActivity-this，-android-R-layout-simple-list-item-1-data"><a href="#ArrayAdapter-lt-String-gt-adapter-new-ArrayAdapter-lt-String-gt-MainActivity-this，-android-R-layout-simple-list-item-1-data" class="headerlink" title="ArrayAdapter&lt; String &gt;  adapter = new ArrayAdapter&lt; String&gt;(MainActivity.this，            android.R.layout.simple_list_item_1, data);"></a>ArrayAdapter&lt; String &gt;  adapter = new ArrayAdapter&lt; String&gt;(MainActivity.this，            android.R.layout.simple_list_item_1, data);</h5><ul>
<li>​    <font color="red">参数一：当前活动上下文</font></li>
<li>​    <font color="red">参数二：子项布局ID</font></li>
<li>​    <font color="red">参数三：数据数组</font></li>
</ul>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193946230.png" alt="image-20201001193946230" style="zoom:67%;">



<h3 id="二、定制ListView的界面"><a href="#二、定制ListView的界面" class="headerlink" title="二、定制ListView的界面"></a>二、定制ListView的界面</h3><h4 id="1-新建一个Fruit类，作为适配器的适配类型"><a href="#1-新建一个Fruit类，作为适配器的适配类型" class="headerlink" title="1.新建一个Fruit类，作为适配器的适配类型"></a>1.新建一个Fruit类，作为适配器的<font color="cornflowerblue">适配类型</font></h4><p>​    public class Fruit {<br>​            private String name;<br>​            private int imageId;</p>
<p>​            public Fruit(String name，int imageId) {<br>​                    this.name = name;<br>​                    this.imageId = imageId;<br>​            }<br>​            public String getName( ) {<br>​                    return name;</p>
<p>​            }</p>
<p>​            public int getImageId( ) {<br>​                    return imageId;</p>
<p>​            }</p>
<p>​    }</p>
<h4 id="2-自定义子项布局fruit-item-xml"><a href="#2-自定义子项布局fruit-item-xml" class="headerlink" title="2.自定义子项布局fruit_item.xml"></a>2.<font color="cornflowerblue">自定义子项布局</font>fruit_item.xml</h4><h5 id="-6"><a href="#-6" class="headerlink" title></a></h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201001194813625.png" alt="image-20201001194813625" style="zoom:67%;">



<h4 id="3-自定义适配器MyAdapter"><a href="#3-自定义适配器MyAdapter" class="headerlink" title="3.自定义适配器MyAdapter"></a>3.<font color="cornflowerblue">自定义适配器</font>MyAdapter</h4><p>​    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001195642103.png" alt="image-20201001195642103"></p>
<p>​    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001195931382.png" alt="image-20201001195931382"></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200025598.png" alt="image-20201001200025598" style="zoom:67%;">

<h4 id="-7"><a href="#-7" class="headerlink" title></a></h4><h4 id="4-初始化数据，创建数据列表"><a href="#4-初始化数据，创建数据列表" class="headerlink" title="4.初始化数据，创建数据列表"></a>4.初始化数据，创建数据列表</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200303132.png" alt="image-20201001200303132" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200312627.png" alt="image-20201001200312627" style="zoom: 80%;">



<h3 id="四、提升ListView的运行效率"><a href="#四、提升ListView的运行效率" class="headerlink" title="四、提升ListView的运行效率"></a>四、提升ListView的运行效率</h3><h4 id="1-重用convertView"><a href="#1-重用convertView" class="headerlink" title="1.重用convertView"></a>1.重用<font color="red">convertView</font></h4><h3 id="-8"><a href="#-8" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201004105237701.png" alt="image-20201004105237701" style="zoom: 80%;"></h3><h4 id="2-内部类ViewHolder对控件实例进行缓存"><a href="#2-内部类ViewHolder对控件实例进行缓存" class="headerlink" title="2.内部类ViewHolder对控件实例进行缓存"></a>2.内部类ViewHolder对控件实例进行缓存</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004105406460.png" alt="image-20201004105406460" style="zoom:80%;">

<h2 id="更强大的滚轮控件——RecyclerView"><a href="#更强大的滚轮控件——RecyclerView" class="headerlink" title="更强大的滚轮控件——RecyclerView"></a>更强大的滚轮控件——RecyclerView</h2><h3 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h3><h4 id="1-首先需要在项目的build-gradle中添加相应的依赖库"><a href="#1-首先需要在项目的build-gradle中添加相应的依赖库" class="headerlink" title="1.首先需要在项目的build.gradle中添加相应的依赖库"></a>1.首先需要在项目的build.gradle中添加相应的<font color="red">依赖库</font></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004130717161.png" alt="image-20201004130717161" style="zoom:80%;">

<h4 id="2-在布局中引用"><a href="#2-在布局中引用" class="headerlink" title="2.在布局中引用"></a>2.在布局中引用</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004130855069.png" alt="image-20201004130855069" style="zoom:80%;">



<h4 id="3-准备Fruit类、fruit-item-xml、"><a href="#3-准备Fruit类、fruit-item-xml、" class="headerlink" title="3.准备Fruit类、fruit_item.xml、"></a>3.准备Fruit类、fruit_item.xml、</h4><h4 id="4-为RecycleView准备一个适配器FruitAdapter-继承自RecyclerView-Adapter-并将泛型指定为FruitAdapter-ViewHolder"><a href="#4-为RecycleView准备一个适配器FruitAdapter-继承自RecyclerView-Adapter-并将泛型指定为FruitAdapter-ViewHolder" class="headerlink" title="4.为RecycleView准备一个适配器FruitAdapter,继承自RecyclerView.Adapter,并将泛型指定为FruitAdapter.ViewHolder"></a>4.为RecycleView准备一个适配器<font color="red">FruitAdapter</font>,继承自<font color="cornflowerblue">RecyclerView.Adapter,</font>并将泛型指定为<font color="cornflowerblue">FruitAdapter.ViewHolder</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004132129131.png" alt="image-20201004132129131"></p>
<h4 id="5-在活动中使用RecyclerView"><a href="#5-在活动中使用RecyclerView" class="headerlink" title="5.在活动中使用RecyclerView"></a>5.在活动中使用RecyclerView</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004160217803.png" alt="image-20201004160217803" style="zoom:80%;">

<h3 id="二、实现横向滚动和瀑布流布局"><a href="#二、实现横向滚动和瀑布流布局" class="headerlink" title="二、实现横向滚动和瀑布流布局"></a>二、实现横向滚动和瀑布流布局</h3><h4 id="1-横向滚动"><a href="#1-横向滚动" class="headerlink" title="1.横向滚动"></a>1.横向滚动</h4><h5 id="layoutManager-setOrientation-LineatLayoutManager-HORIZONTAL"><a href="#layoutManager-setOrientation-LineatLayoutManager-HORIZONTAL" class="headerlink" title="layoutManager.setOrientation(LineatLayoutManager.HORIZONTAL);"></a>layoutManager.<font color="red">setOrientation(LineatLayoutManager.HORIZONTAL);</font></h5><h4 id="2-瀑布流布局-StaggeredGridLayoutManager"><a href="#2-瀑布流布局-StaggeredGridLayoutManager" class="headerlink" title="2.瀑布流布局 StaggeredGridLayoutManager"></a>2.瀑布流布局 <font color="cornflowerblue">StaggeredGridLayoutManager</font></h4><h5 id="StaggeredGridLayoutManager-layoutManager-new-StaggeredGridLayoutManager-3-StaggeredGridLayoutManager-VERTICAL"><a href="#StaggeredGridLayoutManager-layoutManager-new-StaggeredGridLayoutManager-3-StaggeredGridLayoutManager-VERTICAL" class="headerlink" title="StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager (3, StaggeredGridLayoutManager.VERTICAL);"></a>StaggeredGridLayoutManager layoutManager = new <font color="red">StaggeredGridLayoutManager (3, StaggeredGridLayoutManager.VERTICAL)</font>;</h5><h5 id="recycleView-setLayoutManager-layoutManager"><a href="#recycleView-setLayoutManager-layoutManager" class="headerlink" title="recycleView.setLayoutManager(layoutManager);"></a>recycleView.setLayoutManager(layoutManager);</h5><p>​        </p>
<p>​    小技巧：设置不同长度文本</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004161014946.png" alt="image-20201004161014946" style="zoom:80%;">



<h3 id="三、RecyclerView的点击事件"><a href="#三、RecyclerView的点击事件" class="headerlink" title="三、RecyclerView的点击事件"></a>三、RecyclerView的点击事件</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004161141203.png" alt="image-20201004161141203"></p>
<h1 id="第四章-探究碎片"><a href="#第四章-探究碎片" class="headerlink" title="第四章 探究碎片"></a>第四章 探究碎片</h1><h2 id="碎片是什么"><a href="#碎片是什么" class="headerlink" title="碎片是什么"></a>碎片是什么</h2><h2 id="碎片的使用方式"><a href="#碎片的使用方式" class="headerlink" title="碎片的使用方式"></a>碎片的使用方式</h2><h3 id="一、静态使用Fragment"><a href="#一、静态使用Fragment" class="headerlink" title="一、静态使用Fragment"></a>一、<font color="cornflowerblue">静态使用</font>Fragment</h3><h4 id="1-这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。"><a href="#1-这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。" class="headerlink" title="1. 这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。"></a>1. 这是使用Fragment最简单的一种方式，把Fragment当成<font color="red">普通的控件</font>，直接写在Activity的布局文件中。</h4><h4 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h4><h5 id="（1）创建碎片布局文件-fragment-master-xml"><a href="#（1）创建碎片布局文件-fragment-master-xml" class="headerlink" title="（1）创建碎片布局文件 fragment_master.xml"></a>（1）创建碎片布局文件 <font color="orange">fragment_master.xml</font></h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153418988.png" alt="image-20201013153418988" style="zoom:80%;">

<h5 id="（2）创建碎片类MasterFragment-Java"><a href="#（2）创建碎片类MasterFragment-Java" class="headerlink" title="（2）创建碎片类MasterFragment.Java"></a>（2）创建碎片类<font color="orange">MasterFragment.Java</font></h5><p>​        使用inflater.inflate适配布局。实际应用中，也可以添加动态获取信息，绑定到布局控件中。</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153554997.png" alt="image-20201013153554997" style="zoom:80%;">

<p>​        ！补充：（1）（2）也可以通过<font color="red">向导新建</font>来实现</p>
<h5 id="（3）在布局文件中直接用创建好的Fragment控件"><a href="#（3）在布局文件中直接用创建好的Fragment控件" class="headerlink" title="（3）在布局文件中直接用创建好的Fragment控件"></a>（3）在布局文件中直接用创建好的Fragment控件</h5><p>​        要通过android:name 属性来显示的<font color="red">指明要添加的碎片类名</font></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153856622.png" alt="image-20201013153856622" style="zoom:80%;">



<h3 id="二、动态添加Fragment"><a href="#二、动态添加Fragment" class="headerlink" title="二、动态添加Fragment"></a>二、<font color="cornflowerblue">动态添加</font>Fragment</h3><h4 id="1-程序运行时根据具体情况，动态地添加Fragment到Activity活动中。"><a href="#1-程序运行时根据具体情况，动态地添加Fragment到Activity活动中。" class="headerlink" title="1.程序运行时根据具体情况，动态地添加Fragment到Activity活动中。"></a>1.程序运行时根据具体情况，<font color="red">动态地添加</font>Fragment到Activity活动中。</h4><h4 id="2-Fragment事务："><a href="#2-Fragment事务：" class="headerlink" title="2.Fragment事务："></a>2.<font color="orange">Fragment事务</font>：</h4><h5 id="（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。"><a href="#（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。" class="headerlink" title="（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。"></a>（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。</h5><pre><code>    （2）Android提供了&lt;font color=&#39;pink&#39;&gt;FragmentManager类&lt;/font&gt;管理Fragment：
    在Activity运行过程中，通过FragmentManager开启事务，通过调用&lt;font color=&#39;red&#39;&gt;add()，remove(), replace()&lt;/font&gt;实        现动态添加、删除、替换Fragement。
    FragmentManager使用&lt;font color=&#39;pink&#39;&gt;FragmentTransaction类&lt;/font&gt;来管理事务
</code></pre>
<h4 id="3-实现步骤"><a href="#3-实现步骤" class="headerlink" title="3.实现步骤"></a>3.实现步骤</h4><h5 id="（1）在上例基础上，新建一个碎片布局-fragment-another-xml及其类AnotherFragment-java"><a href="#（1）在上例基础上，新建一个碎片布局-fragment-another-xml及其类AnotherFragment-java" class="headerlink" title="（1）在上例基础上，新建一个碎片布局 fragment_another.xml及其类AnotherFragment.java"></a>（1）在上例基础上，新建一个碎片布局 fragment_another.xml及其类AnotherFragment.java</h5><h5 id="（2）修改MainActivity的布局文件acitivty-main-xml"><a href="#（2）修改MainActivity的布局文件acitivty-main-xml" class="headerlink" title="（2）修改MainActivity的布局文件acitivty_main.xml:"></a>（2）修改MainActivity的布局文件acitivty_main.xml:</h5><p>​            将右侧碎片替换成一个<font color="red">FrameLayout</font>布局。<br>​            <font color="orange">动态加载碎片时需要指定容器，一般使用FrameLayout。</font><br>​            随后可在代码中向FrameLayout中动态地添加碎片，在第一次运行时加载DetailFragement，单击按            钮后加载AnotherFragment</p>
<p>​        </p>
<h5 id="（3）在代码证动态加载碎片控件"><a href="#（3）在代码证动态加载碎片控件" class="headerlink" title="（3）在代码证动态加载碎片控件"></a>（3）在代码证动态加载碎片控件</h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155307418.png" alt="image-20201013155307418" style="zoom: 67%;">



<p>​        或者</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155506638.png" alt="image-20201013155506638" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155515431.png" alt="image-20201013155515431" style="zoom:80%;">

<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013160047336.png" alt="image-20201013160047336"></p>
<h4 id="4-在碎片中模拟返回栈"><a href="#4-在碎片中模拟返回栈" class="headerlink" title="4.在碎片中模拟返回栈"></a>4.在碎片中模拟返回栈</h4><h5 id="addToBackStack-用于将一个事务添加到返回栈"><a href="#addToBackStack-用于将一个事务添加到返回栈" class="headerlink" title="addToBackStack()用于将一个事务添加到返回栈"></a><font color="red">addToBackStack()</font>用于将一个事务添加到返回栈</h5><h4 id="5-碎片和活动之间进行通信"><a href="#5-碎片和活动之间进行通信" class="headerlink" title="5.碎片和活动之间进行通信"></a>5.碎片和活动之间进行通信</h4><h5 id="（1）在活动中获取碎片实例："><a href="#（1）在活动中获取碎片实例：" class="headerlink" title="（1）在活动中获取碎片实例："></a>（1）<font color="cornflowerblue">在活动中获取碎片实例：</font></h5><p>FramengtManager fm = getSupportFramengtManager();<br>DetailFragment frag = (DetailFragment)fm.<font color="red">findFragmentById</font>(R.id.fragment_detail);</p>
<h5 id="（2）在碎片中访问活动中的方法："><a href="#（2）在碎片中访问活动中的方法：" class="headerlink" title="（2）在碎片中访问活动中的方法："></a>（2）<font color="cornflowerblue">在碎片中访问活动中的方法：</font></h5><p>在碎片中直接通过调用getActivity()方法获得和当前碎片相关联的活动实例，例如：<br>MainActivity activity = (MainActivity)<font color="red">getActivity()</font>;</p>
<h2 id="碎片的生命周期"><a href="#碎片的生命周期" class="headerlink" title="碎片的生命周期"></a>碎片的生命周期</h2><h3 id="一、碎片的状态"><a href="#一、碎片的状态" class="headerlink" title="一、碎片的状态"></a>一、碎片的状态</h3><h4 id="1-运行状态："><a href="#1-运行状态：" class="headerlink" title="1.运行状态："></a>1.运行状态：</h4><p>当嵌入该Fragment的Activity是处于运行状态的，并且该Fragment是可见的，那么该Fragment是处于运行状态的。</p>
<h4 id="2-暂停状态："><a href="#2-暂停状态：" class="headerlink" title="2.暂停状态："></a>2.暂停状态：</h4><p>当嵌入该Fragment的Activity是处于暂停状态时，那么该Fragment也是处于暂停状态的。</p>
<h4 id="3-停止状态："><a href="#3-停止状态：" class="headerlink" title="3.停止状态："></a>3.停止状态：</h4><p>当嵌入该Fragment的Activity是处于停止状态时，那么该Fragment也会进入停止状态。<br>或者通过调用FragmentTransation的remove()、replace()方法将Fragment从Activity中移除，但如果在事务提交前调用addToBackStack()方法添加到返回栈，这时的碎片进入到停止状态。进入停止状态的碎片有可能被系统回收。但在回收前如果又被置于前台(从返回栈中返回)，将不需要被创建。</p>
<h4 id="4-销毁状态："><a href="#4-销毁状态：" class="headerlink" title="4.销毁状态："></a>4.销毁状态：</h4><p>当嵌入该Fragment的Activity是被销毁时，该Fragment进入到销毁状态。<br>或者通过调用FragmentTransation的remove()、replace()方法将Fragment从Activity中移除，但在事务提交前没有调用addToBackStack()方法添加到返回栈，这时的碎片进行到销毁状态。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194148649.png" alt="image-20201014194148649" style="zoom: 50%;"><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194253899.png" alt="image-20201014194253899" style="zoom: 67%;"></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194329244.png" alt="image-20201014194329244" style="zoom:67%;">



<h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><h3 id="layout-large-文件夹"><a href="#layout-large-文件夹" class="headerlink" title="layout - large 文件夹"></a>layout <font color="red">- large</font> 文件夹</h3><h3 id="layout-sw600dp文件夹"><a href="#layout-sw600dp文件夹" class="headerlink" title="layout - sw600dp文件夹"></a>layout<font color="red"> - sw600dp</font>文件夹</h3><h2 id="简易版的新闻应用"><a href="#简易版的新闻应用" class="headerlink" title="简易版的新闻应用"></a>简易版的新闻应用</h2><h3 id="一、准备一个新闻实体类-News-java"><a href="#一、准备一个新闻实体类-News-java" class="headerlink" title="一、准备一个新闻实体类 News.java"></a>一、准备一个新闻实体类 <font color="cornflowerblue">News.java</font></h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201014194855870.png" alt="image-20201014194855870" style="zoom:67%;">

<h3 id="二、接着新建布局文件news-content-frag-xml，用于作为内容碎片类的布局"><a href="#二、接着新建布局文件news-content-frag-xml，用于作为内容碎片类的布局" class="headerlink" title="二、接着新建布局文件news_content_frag.xml，用于作为内容碎片类的布局"></a>二、接着新建布局文件<font color="cornflowerblue">news_content_frag.xml</font>，用于作为<font color="cornflowerblue">内容碎片类</font>的布局</h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195315804.png" alt="image-20201014195315804" style="zoom:67%;">



<h3 id="三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment"><a href="#三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment" class="headerlink" title="三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment"></a>三、然后再新建一个<font color="cornflowerblue">内容碎片类NewsContentFragment</font>，继承自Fragment</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195546698.png" alt="image-20201014195546698"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195955104.png" alt="image-20201014195955104"></p>
<h3 id="四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击-com-example-fragmentbestpractice"><a href="#四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击-com-example-fragmentbestpractice" class="headerlink" title="四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击 com.example.fragmentbestpractice"></a>四、这样我们就把<font color="cornflowerblue">新闻内容的碎片和布局都创建好了</font>，但是它们都是在双页模式中使用的，如果<font color="red">想在单页模式中使用</font>的话，我们还需要再创建一个活动。右击 com.example.fragmentbestpractice</h3><p>包→New→Activity-→Empty Activity，新建一个NewsContentActivity，并将布局名指定成<br>news_content，然后修改news_content.xml中的代码，如下所示:</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014200437146.png" alt="image-20201014200437146"></p>
<h3 id="五、然后修改NewsContentActivity中的代码，如下所示"><a href="#五、然后修改NewsContentActivity中的代码，如下所示" class="headerlink" title="五、然后修改NewsContentActivity中的代码，如下所示:"></a>五、然后修改<font color="cornflowerblue">NewsContentActivity</font>中的代码，如下所示:</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014201305152.png" alt="image-20201014201305152"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014201739780.png" alt="image-20201014201739780"></p>
<h3 id="六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news-title-frag-xml"><a href="#六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news-title-frag-xml" class="headerlink" title="六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news title frag.xml"></a>六、接下来还需要再创建一个用于显示<font color="cornflowerblue">新闻列表碎片类的布局</font>，新建<font color="cornflowerblue">news title frag.xml</font></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202002701.png" alt="image-20201014202002701"></p>
<h3 id="七、新建news-item-xml作为RecyclerView子项的布局"><a href="#七、新建news-item-xml作为RecyclerView子项的布局" class="headerlink" title="七、新建news_item.xml作为RecyclerView子项的布局"></a>七、新建<font color="cornflowerblue">news_item.xml</font>作为RecyclerView子项的布局</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202257283.png" alt="image-20201014202257283"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202303375.png" alt="image-20201014202303375"></p>
<h3 id="八、既然新闻列表和子项的布局都已经创建好了-那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示"><a href="#八、既然新闻列表和子项的布局都已经创建好了-那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示" class="headerlink" title="八、既然新闻列表和子项的布局都已经创建好了,那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示:"></a>八、既然新闻列表和子项的布局都已经创建好了,那么接下来我们就需要一个用于展示新闻列表的地方。这里新建<font color="cornflowerblue">NewsTitleFragment</font>作为<font color="cornflowerblue">新闻列表的碎片类</font>，代码如下所示:</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014203519438.png" alt="image-20201014203519438"></p>
<h3 id="九、创建两个模式的主活动布局"><a href="#九、创建两个模式的主活动布局" class="headerlink" title="九、创建两个模式的主活动布局"></a>九、创建两个模式的<font color="cornflowerblue">主活动布局</font></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014203644781.png" alt="image-20201014203644781"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014204051184.png" alt="image-20201014204051184"></p>
<h3 id="十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示"><a href="#十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示" class="headerlink" title="十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示:"></a>十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中<font color="cornflowerblue">新建一个内部类NewsAdapter</font>来作为RecyclerView的<font color="cornflowerblue">适配器</font>，如下所示:</h3><h4 id="（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）"><a href="#（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）" class="headerlink" title="（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）"></a><font color="red">（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）</font></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014205746854.png" alt="image-20201014205746854" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210158025.png" alt="image-20201014210158025" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210210198.png" alt="image-20201014210210198" style="zoom:67%;">



<h3 id="十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示"><a href="#十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示" class="headerlink" title="十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示:"></a>十一、现在还剩最后一步收尾工作，就是向RecyclerView中<font color="cornflowerblue">填充数据</font>了。修改NewsTitle-Fragment中的代码，如下所示:</h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210535588.png" alt="image-20201014210535588" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210606503.png" alt="image-20201014210606503" style="zoom:67%;">







<h1 id="第五章-全局大喇叭——详解广播机制"><a href="#第五章-全局大喇叭——详解广播机制" class="headerlink" title="第五章 全局大喇叭——详解广播机制"></a>第五章 全局大喇叭——详解广播机制</h1><h2 id="广播机制简介"><a href="#广播机制简介" class="headerlink" title="广播机制简介"></a>广播机制简介</h2><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117133937067.png" alt="image-20201117133937067"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117134653797.png" alt="image-20201117134653797"></p>
<h3 id="一、一种传输信息的机制"><a href="#一、一种传输信息的机制" class="headerlink" title="一、一种传输信息的机制"></a>一、一种传输信息的机制</h3><h4 id="广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。"><a href="#广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。" class="headerlink" title="广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。"></a>广播消息可以是<font color="red">应用程序的数据信息</font>，也可以是<font color="red">Android的系统消息</font>，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。</h4><h4 id="Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。"><a href="#Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。" class="headerlink" title="Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。"></a>Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。</h4><h4 id="接收广播需要专门的广播接收器（Broadcast-Reciever）。"><a href="#接收广播需要专门的广播接收器（Broadcast-Reciever）。" class="headerlink" title="接收广播需要专门的广播接收器（Broadcast Reciever）。"></a>接收广播需要专门的广播接收器（Broadcast Reciever）。</h4><h4 id="广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。"><a href="#广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。" class="headerlink" title="广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。"></a>广播接收器通过<font color="red">设置好的过滤器</font>监听特定的广播消息然后进行响应。</h4><h3 id="二、广播的类型"><a href="#二、广播的类型" class="headerlink" title="二、广播的类型"></a>二、广播的类型</h3><h4 id="1-标准广播"><a href="#1-标准广播" class="headerlink" title="1.标准广播"></a>1.<font color="cornflowerblue">标准广播</font></h4><p>​        异步执行。在广播发出之后，所有的广播接收器都会在同一时刻接收到这条广播消息。</p>
<h4 id="2-有序广播"><a href="#2-有序广播" class="headerlink" title="2.有序广播"></a>2.有序广播</h4><h5 id="同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。"><a href="#同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。" class="headerlink" title="同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。"></a>同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。</h5><h5 id="广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。"><a href="#广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。" class="headerlink" title="广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。"></a>广播接收器是有先后顺序，<font color="red">优先级</font>高的广播接收器就可以先收到广播消息。</h5><h5 id="优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。"><a href="#优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。" class="headerlink" title="优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。"></a>优先级高的广播接收器可以<font color="red">截断</font>正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。</h5><h2 id="BroadcastReceiver介绍"><a href="#BroadcastReceiver介绍" class="headerlink" title="BroadcastReceiver介绍"></a>BroadcastReceiver介绍</h2><h3 id="一、BroadcastReceiver"><a href="#一、BroadcastReceiver" class="headerlink" title="一、BroadcastReceiver"></a>一、BroadcastReceiver</h3><h4 id="1-本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。"><a href="#1-本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。" class="headerlink" title="1.本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。"></a>1.本质上是一种<font color="red">全局监听器</font>，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。</h4><h4 id="2-BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如："><a href="#2-BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如：" class="headerlink" title="2. BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如："></a>2. BroadcastReceiver用于<font color="red">接收指定的广播</font>，通过<font color="red">设置过滤器</font>监听感兴趣的广播消息后进行响应，例如：</h4><p>启动Activity作为响应，或者通过NotificationManager提醒用户，或者启动Service等等。<br>自身并不实现图形用户界面。</p>
<h3 id="二、Broadcast开发过程"><a href="#二、Broadcast开发过程" class="headerlink" title="二、Broadcast开发过程"></a>二、Broadcast开发过程</h3><h4 id="1-定义广播接收器"><a href="#1-定义广播接收器" class="headerlink" title="1.定义广播接收器"></a>1.<font color="cornflowerblue">定义广播接收器</font></h4><h5 id="继承BroadcastReceiver基类，实现onReceiver方法："><a href="#继承BroadcastReceiver基类，实现onReceiver方法：" class="headerlink" title="继承BroadcastReceiver基类，实现onReceiver方法："></a>继承BroadcastReceiver基类，实现onReceiver方法：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135128320.png" alt="image-20201117135128320"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135631266.png" alt="image-20201117135631266"></p>
<h4 id="2-注册广播接收器"><a href="#2-注册广播接收器" class="headerlink" title="2.注册广播接收器"></a>2.<font color="cornflowerblue">注册广播接收器</font></h4><h5 id="（1）静态注册："><a href="#（1）静态注册：" class="headerlink" title="（1）静态注册："></a>（1）<font color="red">静态注册</font>：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135302391.png" alt="image-20201117135302391"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140345059.png" alt="image-20201117140345059"></p>
<h5 id="（2）动态注册：（可定义为内部类）"><a href="#（2）动态注册：（可定义为内部类）" class="headerlink" title="（2）动态注册：（可定义为内部类）"></a>（2）<font color="red">动态注册</font>：（可定义为内部类）</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135729313.png" alt="image-20201117135729313"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140330496.png" alt="image-20201117140330496"></p>
<h4 id="3-BroadcastReceiver响应"><a href="#3-BroadcastReceiver响应" class="headerlink" title="3.BroadcastReceiver响应"></a>3.BroadcastReceiver响应</h4><h5 id="（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive-方法，onReceive-方法执行完后，BroadcastReceiver的实例就会被销毁。"><a href="#（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive-方法，onReceive-方法执行完后，BroadcastReceiver的实例就会被销毁。" class="headerlink" title="（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive()方法，onReceive()方法执行完后，BroadcastReceiver的实例就会被销毁。"></a>（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并<font color="orange">自动触发它的onReceive()方法</font>，onReceive()方法执行完后，BroadcastReceiver的实例就会<font color="orange">被销毁</font>。</h5><h5 id="（2）-如果BroadcastReceiver的onReceive-方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive-方法里执行一些耗时的操作，否则会弹出ANR（Application-No-Response）对话框。"><a href="#（2）-如果BroadcastReceiver的onReceive-方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive-方法里执行一些耗时的操作，否则会弹出ANR（Application-No-Response）对话框。" class="headerlink" title="（2） 如果BroadcastReceiver的onReceive()方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive()方法里执行一些耗时的操作，否则会弹出ANR（Application No Response）对话框。"></a>（2） 如果BroadcastReceiver的onReceive()方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive()方法里执行一些耗时的操作，否则会弹出ANR（Application No Response）对话框。</h5><h2 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h2><h3 id="一、标准广播："><a href="#一、标准广播：" class="headerlink" title="一、标准广播："></a>一、标准广播：</h3><h4 id="1-是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast-Intent的传播。"><a href="#1-是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast-Intent的传播。" class="headerlink" title="1.是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播。"></a>1.是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播。</h4><h4 id="2-Intent-intent-new-Intent-“com-example-broadcasttest-MY-BROADCAST”"><a href="#2-Intent-intent-new-Intent-“com-example-broadcasttest-MY-BROADCAST”" class="headerlink" title="2. Intent intent = new Intent(“com.example.broadcasttest.MY_BROADCAST”);"></a>2. Intent intent = new Intent(“com.example.broadcasttest.MY_BROADCAST”);</h4><h4 id="sendBroadcast-intent"><a href="#sendBroadcast-intent" class="headerlink" title="sendBroadcast(intent);"></a><font color="red">sendBroadcast(intent);</font></h4><p>​            </p>
<h3 id="二、有序广播："><a href="#二、有序广播：" class="headerlink" title="二、有序广播："></a>二、有序广播：</h3><h4 id="1-该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast-方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras-Bundle-bundle-方法）。"><a href="#1-该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast-方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras-Bundle-bundle-方法）。" class="headerlink" title="1.该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast()方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras(Bundle bundle)方法）。"></a>1.该广播的接收者将<font color="red">按预先声明的优先级</font>依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast()方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras(Bundle bundle)方法）。</h4><h4 id="2-Intent-intent-new-Intent-“iet-jxufe-cn-android-OrderedBroadcastTest”"><a href="#2-Intent-intent-new-Intent-“iet-jxufe-cn-android-OrderedBroadcastTest”" class="headerlink" title="2. Intent intent=new Intent(“iet.jxufe.cn.android.OrderedBroadcastTest”);"></a>2. Intent intent=new Intent(“iet.jxufe.cn.android.OrderedBroadcastTest”);</h4><pre><code>        &lt;font color=&#39;red&#39;&gt;endOrderedBroadcast(intent,null);&lt;/font&gt;
    3.优先级设置
</code></pre>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140951277.png" alt="image-20201117140951277"></p>
<h2 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h2><h3 id="一、Android本地广播机制："><a href="#一、Android本地广播机制：" class="headerlink" title="一、Android本地广播机制："></a>一、Android本地广播机制：</h3><h4 id="广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播"><a href="#广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播" class="headerlink" title="广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播"></a>广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播</h4><h4 id="方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。"><a href="#方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。" class="headerlink" title="方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。"></a>方法：使用<font color="cornflowerblue">LocalBroadcastManager</font>对广播进行管理，对发送广播和注册广播接收器进行管理。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117141401456.png" alt="image-20201117141401456"></p>
<h1 id="第六章-数据存储全方案–持久化技术"><a href="#第六章-数据存储全方案–持久化技术" class="headerlink" title="第六章 数据存储全方案–持久化技术"></a>第六章 数据存储全方案–持久化技术</h1><h2 id="持久化技术简介"><a href="#持久化技术简介" class="headerlink" title="持久化技术简介"></a>持久化技术简介</h2><h3 id="1-数据存储方式"><a href="#1-数据存储方式" class="headerlink" title="1.数据存储方式"></a>1.数据存储方式</h3><ul>
<li><font color="red">文件存储</font></li>
<li><font color="red">SharedPreferences</font></li>
<li><font color="red">SQLite数据库</font></li>
</ul>
<h3 id="2-Android内部存储和外部存储"><a href="#2-Android内部存储和外部存储" class="headerlink" title="2.Android内部存储和外部存储"></a>2.Android内部存储和外部存储</h3><h4 id="（1）内存（Memory）："><a href="#（1）内存（Memory）：" class="headerlink" title="（1）内存（Memory）："></a>（1）内存（Memory）：</h4><p>​            RAM，类似于PC的内存条</p>
<h4 id="（2）内部存储（Internal-Storage）："><a href="#（2）内部存储（Internal-Storage）：" class="headerlink" title="（2）内部存储（Internal Storage）："></a>（2）内部存储（Internal Storage）：</h4><p>​            机身固有存储，类似于PC的硬盘 </p>
<h4 id="（3）外部存储（External-Storage）："><a href="#（3）外部存储（External-Storage）：" class="headerlink" title="（3）外部存储（External Storage）："></a>（3）外部存储（External Storage）：</h4><p>​                早期的Android设备(4.4之前) 指SDCard(扩展卡)，类似于PC上的U盘。</p>
<p>​        之后随着技术的进步，机身存储得到了快速增大(8G以上)，此时的外部存储是<font color="orange">概念级别的“外部存储”</font>，机        身<font color="red">固有的存储</font>有一部分被划分为“内部存储”，另一部分被划分为“外部存储”，但其实都是机身固有存储。        后期的外部存储也包括了SDCard。<br>​        所以不管Android手机是否有可移动的SDCard，他们总是有外部存储和内部存储。</p>
<h3 id="3-几个重要文件夹"><a href="#3-几个重要文件夹" class="headerlink" title="3.几个重要文件夹"></a>3.几个重要文件夹</h3><h4 id="打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹"><a href="#打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹" class="headerlink" title="打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：data文件夹、mnt文件夹、sdcard 文件夹、storage文件夹"></a>打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：<font color="red">data</font>文件夹、<font color="red">mnt</font>文件夹、<font color="red">sdcard</font> 文件夹、<font color="red">storage</font>文件夹</h4><h3 id="4-内部存储data"><a href="#4-内部存储data" class="headerlink" title="4.内部存储data"></a>4.<font color="cornflowerblue">内部存储data</font></h3><h4 id="1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："><a href="#1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：" class="headerlink" title="(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："></a>(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：</h4><ul>
<li><h5 id="文件夹app：存放着我们所有安装的app的apk文件"><a href="#文件夹app：存放着我们所有安装的app的apk文件" class="headerlink" title="文件夹app：存放着我们所有安装的app的apk文件"></a>文件夹<font color="red">app</font>：存放着我们所有安装的app的apk文件</h5></li>
<li><h5 id="文件夹data：一些包名，展开后，"><a href="#文件夹data：一些包名，展开后，" class="headerlink" title="文件夹data：一些包名，展开后，"></a>文件夹<font color="red">data</font>：一些包名，展开后，</h5><p>data/data/包名/<font color="orange">shared_prefs</font>(SharedPreference存储方式)</p>
<pre><code>data/data/包名/&lt;font color=&#39;orange&#39;&gt;databases&lt;/font&gt;（数据库存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;files&lt;/font&gt;（文件存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;cache&lt;/font&gt;
</code></pre>
</li>
</ul>
<h4 id="（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data"><a href="#（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data" class="headerlink" title="（2）路径的访问：Environment.getDataDirectory()获取内部存储根路径。/data"></a>（2）路径的访问：<font color="red">Environment.getDataDirectory()</font>获取内部存储根路径。/data</h4><h4 id="3-几点："><a href="#3-几点：" class="headerlink" title="(3)几点："></a>(3)几点：</h4><ol>
<li><h4 id="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"><a href="#系统默认只在内部存储中创建cache目录，并且此时cache目录是空的" class="headerlink" title="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"></a>系统默认<font color="orange">只在内部存储中创建cache目录</font>，并且此时cache目录是空的</h4></li>
<li><h4 id="此外，还可以根据需要自动创建：shared-prefs，databases，files目录"><a href="#此外，还可以根据需要自动创建：shared-prefs，databases，files目录" class="headerlink" title="此外，还可以根据需要自动创建：shared_prefs，databases，files目录"></a>此外，还可以根据需要<font color="orange">自动创建</font>：shared_prefs，databases，files目录</h4><p>但files可以<font color="orange">手动创建</font>，而shared_prefs，databases不能</p>
</li>
<li><h4 id="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"><a href="#别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。" class="headerlink" title="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"></a>别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。</h4></li>
</ol>
<h4 id="（4）内部存储的API"><a href="#（4）内部存储的API" class="headerlink" title="（4）内部存储的API"></a>（4）内部存储的API</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028153632199.png" alt="image-20201028153632199" style="zoom:80%;">





<h3 id="5-外部存储storage"><a href="#5-外部存储storage" class="headerlink" title="5.外部存储storage"></a>5.<font color="cornflowerblue">外部存储storage</font></h3><h4 id="1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"><a href="#1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。" class="headerlink" title="(1)一般是/storage/emulated/0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"></a>(1)一般是<font color="red">/storage/emulated/0</font>也有可能是其它文件夹，不同厂家不同版本有可能不一样。</h4><h4 id="storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy"><a href="#storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy" class="headerlink" title="/storage/sdcard0，/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy"></a><font color="red">/storage/sdcard0，</font>/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy</h4><ul>
<li><h5 id="公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等"><a href="#公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等" class="headerlink" title="公有目录：10大类，比如DCIM,Download等这些系统创建的文件夹。storage/emulated/0/Download等"></a><font color="red">公有目录</font>：10大类，比如DCIM,Download等这些系统创建的文件夹。<font color="orange">storage/emulated/0/Download</font>等</h5></li>
<li><h5 id="私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。"><a href="#私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。" class="headerlink" title="私有目录：Android文件夹，打开后有data文件夹。storage/emulated/0/Android/data/包名 文件夹：里面包含了许多包名组成的文件夹。"></a><font color="red">私有目录</font>：Android文件夹，打开后有<font color="red">data</font>文件夹。<font color="orange">storage/emulated/0/Android/data/包名 文件夹</font>：里面包含了许多包名组成的文件夹。</h5><h4 id="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"><a href="#（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。" class="headerlink" title="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"></a>（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的<font color="green">数据会一并删除</font>。</h4><p>如果直接在<font color="red">根目录</font>（<font color="orange">/storage/emulated/0</font>）下创建一个应用的文件夹，这样当该应用被卸载后，这些数据还保留在外部存储中，<font color="green">留下垃圾数据</font>。</p>
</li>
</ul>
<h4 id="（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。"><a href="#（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。" class="headerlink" title="（3）路径的访问：Environment.getExternalStorageDirectory()：获取机身存储的外部存储根路径。"></a>（3）路径的访问：<font color="red">Environment.getExternalStorageDirectory()</font>：获取机身存储的外部存储根路径。</h4><h4 id="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"><a href="#（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录" class="headerlink" title="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"></a>（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要<font color="red">手动创建私有目录</font></h4><h5 id="context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件"><a href="#context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件" class="headerlink" title="context.getExternalFilesDir(…)：在storage/emulated/0/Android/data/包名/files 中创建文件"></a>context.<font color="orange">getExternalFilesDir(…)</font>：在storage/emulated/0/Android/data/包名/files 中创建文件</h5><p>​    context.<font color="orange">getExternalCacheDir() </font>：在storage/emulated/0/Android/data/包名/cache 中创建文件</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028154738508.png" alt="image-20201028154738508" style="zoom:80%;">

<h3 id="6-内部存储与外部存储比较"><a href="#6-内部存储与外部存储比较" class="headerlink" title="6.内部存储与外部存储比较"></a>6.内部存储与外部存储比较</h3><p>​        外部存储目录空间较大，而内部存储空间有限<br>​        部分目录不会被自动创建，需要手动创建<br>​        两者<font color="red">都不需要权限</font><br>​        两者<font color="red">都会随着App的卸载而会自动被删除</font><br>​        对于内部存储，<font color="orange">只有</font>本App才可以访问<br>​        对于外部私有目录，本App可以直接访问，而其它App在自 Android 7.0 开始，系统对应用私有目录的访问权限进一步限制。其他 App 无法通过 file:// 这种形式的 Uri 直接读写该目录下的文件内容，而是通过 FileProvider 访问。<br>​        需要注意的是：由于用户可以直接查看并操作外部私有存储目录，那么也就意味着我们在操作这个目录下的文件的时候一定要做好异常和判空处理。</p>
<h3 id="7-数据存储与清除"><a href="#7-数据存储与清除" class="headerlink" title="7.数据存储与清除"></a>7.数据存储与清除</h3><h4 id="（1）数据存储："><a href="#（1）数据存储：" class="headerlink" title="（1）数据存储："></a>（1）数据存储：</h4><ul>
<li><p>默认情况下，存储在<font color="red">内部存储</font>：<br><font color="orange">data/app</font>：用户APP安装目录，存放apk；</p>
<p><font color="orange">data/data/包名/</font>：存放应用程序的数据</p>
</li>
<li><p>数据可以存放到指定的<font color="red">外部存储</font>：</p>
<p><font color="orange">/storage/sdcard</font>（共有目录）</p>
<p><font color="orange">/storage/sdcard0/Android/data/包名/</font>（私有目录）</p>
<h4 id="（2）清除数据："><a href="#（2）清除数据：" class="headerlink" title="（2）清除数据："></a>（2）清除数据：</h4></li>
</ul>
<h5 id="删除对应包中的cache，files，lib，shared-prefs，datbBases等等"><a href="#删除对应包中的cache，files，lib，shared-prefs，datbBases等等" class="headerlink" title="删除对应包中的cache，files，lib，shared_prefs，datbBases等等"></a>删除<font color="red">对应包中的</font><font color="cornflowerblue">cache</font>，files，lib，shared_prefs，datbBases等等</h5><p>​        （清除<font color="red">data/data/packagename中的</font>cache，files，lib， databases，shared_prefs等等）</p>
<p>​        （清除<font color="red">storage/emulated/0/Android/data/packagenam中的</font>文件）</p>
<h4 id="3-清除缓存："><a href="#3-清除缓存：" class="headerlink" title="(3) 清除缓存："></a>(3) 清除缓存：</h4><h5 id="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"><a href="#删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。" class="headerlink" title="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"></a>删除的是App运行过程中所产生的<font color="red">临时数据</font>，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在<font color="red">内存</font>中。</h5><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1.内部存储"></a>1.内部存储</h3><h4 id="（1）存："><a href="#（1）存：" class="headerlink" title="（1）存："></a>（1）存：</h4><p>方法1：使用 context.getFilesDir() 获取内部存储data/data/包名/files目录，然后创建文件，最后利用文件(全路径)新建FileOutputStream对象进行文件写入。<br>FileOutputStream fileOutputStream = new FileOutputStream(filePathName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160019136.png" alt="image-20201028160019136" style="zoom:80%;">

<p>方法2：直接使用Context.openFileOutput()方法(只需要文件名)获取FileOutputStream对象，进行文件写入。</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201028160258040.png" alt="image-20201028160258040" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160348975.png" alt="image-20201028160348975" style="zoom:80%;">

<h4 id="（2）取："><a href="#（2）取：" class="headerlink" title="（2）取："></a>（2）取：</h4><p>方法1：使用context.getFilesDir() 获取内部存储data/data/包名/files目录，然后利用文件(全路径)创建FileInputStream对象，进行内容读取。<br>FileInputStream fileInputStream = new FileInputStream(filePathName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/myBlog\source\_posts\安卓数据存储之文件存储\3.png" alt="image-20201028160834999" style="zoom:80%;">

<p>方法2：直接使用Context. openFileInput()方法(只需要文件名)获取FileInputStream对象，进行文件内容读取。<br>FileInputStream fileInputStream = openFileInput(fileName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160853113.png" alt="image-20201028160853113" style="zoom:80%;">

<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20210531224957336.png" alt="image-20210531224957336"></p>
<h3 id="2-外部存储"><a href="#2-外部存储" class="headerlink" title="2.外部存储"></a>2.外部存储</h3><h4 id="（1）外部根目录："><a href="#（1）外部根目录：" class="headerlink" title="（1）外部根目录："></a>（1）外部根目录：</h4><p>使用 <font color="red">Environment.getExternalStorageDirectory()</font> 获取</p>
<p>一般是/storage/emulated/0</p>
<h4 id="（2）外部公有目录："><a href="#（2）外部公有目录：" class="headerlink" title="（2）外部公有目录："></a>（2）外部公有目录：</h4><p>使用<font color="red">Environment.getExternalStoragePublicDirectory</font>获取</p>
<p>/storage/emulated/0/Music</p>
<p>针对外部<font color="red">共有目录、根目录</font>等位置的存取需要<font color="orange">添加权限</font>，Android 6.0 之后还需要做运行时权限申请。针对外部<font color="red">私有目录</font>的存取则<font color="orange">不需要添加权限</font>。<br>默认情况下，Android系统<font color="red">不会</font>为我们的App在外部存储中创建私有路径，需要<font color="red">手动创建</font>。<br>外部私有目录在App卸载时同步删除。</p>
<p>​    </p>
<h4 id="（3）获取外部私有目录"><a href="#（3）获取外部私有目录" class="headerlink" title="（3）获取外部私有目录"></a>（3）获取外部私有目录</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162002693.png" alt="image-20201028162002693" style="zoom:80%;">





<h4 id="（4）存："><a href="#（4）存：" class="headerlink" title="（4）存："></a>（4）存：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162420940.png" alt="image-20201028162420940"></p>
<h4 id="（5）取："><a href="#（5）取：" class="headerlink" title="（5）取："></a>（5）取：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162532386.png" alt="image-20201028162532386"></p>
<h2 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h2><h3 id="1-获取SharedPreferences对象"><a href="#1-获取SharedPreferences对象" class="headerlink" title="1.获取SharedPreferences对象"></a>1.获取<font color="cornflowerblue">SharedPreferences对象</font></h3><h4 id="1-Context-getSharedPreferences-方法"><a href="#1-Context-getSharedPreferences-方法" class="headerlink" title="(1) Context . getSharedPreferences()方法 "></a>(1) <font color="red">Context . getSharedPreferences()方法 </font></h4><p>​        此方法接受两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个。SharedPreferences 文件都是存放在 /data/data/&lt;包名&gt;/shared_prefs/ 目录下的。<br>​        第二个参数用于<font color="orange">指定操作模式</font>，主要为 MODE_PRIVATE（默认操作模式） 和 MODE_MULTI_PROCESS（多进程读写） 。</p>
<h4 id="2-Activity-类中的-getPreferences-方法"><a href="#2-Activity-类中的-getPreferences-方法" class="headerlink" title="(2)Activity 类中的 getPreferences() 方法"></a>(2)<font color="red">Activity 类中的 getPreferences() 方法</font></h4><p>这个方法和 Context 中的 getSharedPreferences() 方法类似，不过它只接收一个操作模式参数，使用这个方法时<font color="orange">会自动将当前活动的类名作为 SharedPreferences 的文件名</font>。</p>
<h4 id="3-PreferenceManager-类中的-getDefaultSharedPreferences-方法"><a href="#3-PreferenceManager-类中的-getDefaultSharedPreferences-方法" class="headerlink" title="(3) PreferenceManager 类中的 getDefaultSharedPreferences() 方法"></a>(3)<font color="red"> PreferenceManager 类中的 getDefaultSharedPreferences() 方法</font></h4><p>这是一个<font color="orange">静态方法</font>，它接收一个 Context 参数，并自动<font color="orange">使用当前应用程序的包名作为前缀</font>来命名 SharedPreferences 文件。</p>
<h3 id="2-通过SharedPreferences对象获取到Editor对象存数据"><a href="#2-通过SharedPreferences对象获取到Editor对象存数据" class="headerlink" title="2.通过SharedPreferences对象获取到Editor对象存数据"></a>2.通过SharedPreferences对象获取到<font color="cornflowerblue">Editor对象</font>存数据</h3><h4 id="（1）SharePreferences-Editor-editor-shared-edit"><a href="#（1）SharePreferences-Editor-editor-shared-edit" class="headerlink" title="（1）SharePreferences.Editor  editor = shared.edit();"></a>（1）SharePreferences.Editor  editor = shared.<font color="red">edit();</font></h4><p>调用 SharedPreferences 对象的 edit() 方法来获取一个 SharePreferences.Editor 对象。</p>
<h4 id="（2）editor-putString"><a href="#（2）editor-putString" class="headerlink" title="（2）editor.putString( )"></a>（2）editor<font color="red">.putString( )</font></h4><p>向 SharedPreferences.Editor 对象中添加数据，如果添加一个字符串则使用 editor.putString() 方法，以此类推。</p>
<h4 id="（3）editor-commit-editor-apply"><a href="#（3）editor-commit-editor-apply" class="headerlink" title="（3）editor.commit()  editor.apply()"></a>（3）<font color="red">editor.commit()  editor.apply()</font></h4><p>调用 editor.commit() 方法或者editor.apply()方法将添加的数据提交，从而完成数据存储操作。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164007127.png" alt="image-20201028164007127"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164138241.png" alt="image-20201028164138241"></p>
<h3 id="3-SharePreferences读取与删除数据"><a href="#3-SharePreferences读取与删除数据" class="headerlink" title="3.SharePreferences读取与删除数据"></a>3.SharePreferences<font color="cornflowerblue">读取与删除</font>数据</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164251857.png" alt="image-20201028164251857"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164334426.png" alt="image-20201028164334426"></p>
<h2 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h2><h3 id="一、创建数据库"><a href="#一、创建数据库" class="headerlink" title="一、创建数据库"></a>一、创建数据库</h3><h4 id="1-SQLiteOpenHelper-帮助类"><a href="#1-SQLiteOpenHelper-帮助类" class="headerlink" title="1.  SQLiteOpenHelper 帮助类"></a>1. <font color="cornflowerblue"> SQLiteOpenHelper</font> 帮助类</h4><ul>
<li><p>重写onCreate() 和 onUpgrade() 方法，分别在这两个方法实现创建、更新数据库的逻辑；</p>
</li>
<li><p>两个重要的实例方法：getReadableDatabase() 和 getWritableDatabese() ,这两个方法都可以创建或打开一个现有数据库（不存在则创建），并且返回一个可对数据库进行读/写操作的SQLiteDatabase对象</p>
</li>
<li><p>SQLiteOpenHelper构造方法（context, name, factory, version）</p>
<p>​        参数一：Context；    参数二：数据库名；    参数三：Cursor游标（null）    参数四：版本号</p>
<h4 id="2-新建-MyDatabaseHelper-继承自SQLiteOpenHelper"><a href="#2-新建-MyDatabaseHelper-继承自SQLiteOpenHelper" class="headerlink" title="2. 新建 MyDatabaseHelper 继承自SQLiteOpenHelper"></a>2. 新建 <font color="cornflowerblue">MyDatabaseHelper</font> 继承自SQLiteOpenHelper</h4><h5 id="重写oncreate"><a href="#重写oncreate" class="headerlink" title="重写oncreate()"></a>重写<font color="orange">oncreate()</font></h5></li>
</ul>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031132951195.png" alt="image-20201031132951195"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031133055726.png" alt="image-20201031133055726"></p>
<h4 id="3-创建数据库"><a href="#3-创建数据库" class="headerlink" title="3. 创建数据库"></a>3. 创建数据库</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031133544744.png" alt="image-20201031133544744"></p>
<h3 id="二、升级数据库"><a href="#二、升级数据库" class="headerlink" title="二、升级数据库"></a>二、升级数据库</h3><h4 id="1-在初始化时新执行一条SQL语句，新建一个Category表格"><a href="#1-在初始化时新执行一条SQL语句，新建一个Category表格" class="headerlink" title="1.在初始化时新执行一条SQL语句，新建一个Category表格"></a>1.在初始化时新执行一条SQL语句，新建一个Category表格</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134002931.png" alt="image-20201031134002931"></p>
<h4 id="2-重写onUpgrade"><a href="#2-重写onUpgrade" class="headerlink" title="2.重写onUpgrade()"></a>2.重写<font color="orange">onUpgrade()</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134120838.png" alt="image-20201031134120838"></p>
<p>​    升级时，如果表格存在，先删除掉再调用onCreate()重写创建</p>
<h4 id="3-更新数据库"><a href="#3-更新数据库" class="headerlink" title="3. 更新数据库"></a>3. 更新数据库</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134454199.png" alt="image-20201031134454199"></p>
<h3 id="三、添加数据-insert"><a href="#三、添加数据-insert" class="headerlink" title="三、添加数据 insert()"></a>三、添加数据 <font color="cornflowerblue">insert()</font></h3><h4 id="1-参数"><a href="#1-参数" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二：用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL，一般我们用不到这个功能，直接传入null即可</li>
<li>参数三：<font color="orange">ContentValues</font>对象，它提供了一系列的<font color="orange">put()</font>方法重载，用于向Contentvalues中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。</li>
</ul>
<h4 id="2-添加数据"><a href="#2-添加数据" class="headerlink" title="2.添加数据"></a>2.添加数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031140101787.png" alt="image-20201031140101787"></p>
<h3 id="四、更新数据-updata"><a href="#四、更新数据-updata" class="headerlink" title="四、更新数据 updata()"></a>四、更新数据 <font color="cornflowerblue">updata()</font></h3><h4 id="1-参数-1"><a href="#1-参数-1" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二：<font color="orange">ContentValues</font>对象，组装更新的数据</li>
<li>参数三、参数四：约束更新某一行或某几行的数据</li>
</ul>
<h4 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2.更新数据"></a>2.更新数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031140634673.png" alt="image-20201031140634673"></p>
<h5 id="更新Book表格中，name为“The-Da-Vinci-Code”-的价格为10-99"><a href="#更新Book表格中，name为“The-Da-Vinci-Code”-的价格为10-99" class="headerlink" title="更新Book表格中，name为“The Da Vinci Code” 的价格为10.99"></a>更新Book表格中，name为“The Da Vinci Code” 的价格为10.99</h5><h3 id="五、删除数据-delete"><a href="#五、删除数据-delete" class="headerlink" title="五、删除数据 delete()"></a>五、删除数据 <font color="cornflowerblue">delete()</font></h3><h4 id="1-参数-2"><a href="#1-参数-2" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二、参数三：约束删除某一行或某几行的数据</li>
</ul>
<h4 id="2-删除数据"><a href="#2-删除数据" class="headerlink" title="2.删除数据"></a>2.删除数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141159367.png" alt="image-20201031141159367"></p>
<h5 id="删除Book表格中，Pages大于500页的数据"><a href="#删除Book表格中，Pages大于500页的数据" class="headerlink" title="删除Book表格中，Pages大于500页的数据"></a>删除Book表格中，Pages大于500页的数据</h5><h3 id="六、查询数据-query"><a href="#六、查询数据-query" class="headerlink" title="六、查询数据 query()"></a>六、查询数据 <font color="cornflowerblue">query()</font></h3><h4 id="1-参数-3"><a href="#1-参数-3" class="headerlink" title="1.参数"></a>1.参数</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141347771.png" alt="image-20201031141347771"></p>
<h4 id="2-查询数据"><a href="#2-查询数据" class="headerlink" title="2.查询数据"></a>2.查询数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141717750.png" alt="image-20201031141717750"></p>
<h5 id="通过返回的Cursor对象来获取数据，moveToFirst-将游标移动到第一行位置；-getColunmIndex-获取某一列的位置索引"><a href="#通过返回的Cursor对象来获取数据，moveToFirst-将游标移动到第一行位置；-getColunmIndex-获取某一列的位置索引" class="headerlink" title="通过返回的Cursor对象来获取数据，moveToFirst():将游标移动到第一行位置； getColunmIndex():获取某一列的位置索引"></a>通过返回的Cursor对象来获取数据，<font color="orange">moveToFirst()</font>:将游标移动到第一行位置；<font color="orange"> getColunmIndex()</font>:获取某一列的位置索引</h5><h1 id="第七章-跨程序共享数据——探究内容提供器"><a href="#第七章-跨程序共享数据——探究内容提供器" class="headerlink" title="第七章 跨程序共享数据——探究内容提供器"></a>第七章 跨程序共享数据——探究内容提供器</h1><h2 id="内容提供器简介"><a href="#内容提供器简介" class="headerlink" title="内容提供器简介"></a>内容提供器简介</h2><h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><h3 id="一、危险权限"><a href="#一、危险权限" class="headerlink" title="一、危险权限"></a>一、危险权限</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201109144301759.png" alt="image-20201109144301759"></p>
<p>危险权限需要进行运行时权限处理，普通权限只要在AndroidMainfest.xml清单文件中添加一下权限声明就行</p>
<h3 id="二、运行时权限处理步骤"><a href="#二、运行时权限处理步骤" class="headerlink" title="二、运行时权限处理步骤"></a>二、<font color="cornflowerblue">运行时权限处理步骤</font></h3><h4 id="1-第一步：判断用户是否已经授权"><a href="#1-第一步：判断用户是否已经授权" class="headerlink" title="1. 第一步：判断用户是否已经授权"></a>1. <font color="pink">第一步</font>：判断用户是否已经授权</h4><h5 id="（1）ContextCompat-checkSelfPermission-MainActivity-this-Manifest-permission-READ-CONTACTS"><a href="#（1）ContextCompat-checkSelfPermission-MainActivity-this-Manifest-permission-READ-CONTACTS" class="headerlink" title="（1）ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_CONTACTS)"></a>（1）<font color="red">ContextCompat.checkSelfPermission</font>(MainActivity.this, Manifest.permission.READ_CONTACTS)</h5><h5 id="（2）参数一：Context；-参数二：权限名"><a href="#（2）参数一：Context；-参数二：权限名" class="headerlink" title="（2）参数一：Context； 参数二：权限名"></a>（2）参数一：Context； 参数二：权限名</h5><h5 id="（3）将其返回值与PackageManager-PERMISSION-GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。"><a href="#（3）将其返回值与PackageManager-PERMISSION-GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。" class="headerlink" title="（3）将其返回值与PackageManager.PERMISSION_GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。"></a>（3）将其返回值与<font color="red">PackageManager.PERMISSION_GRANTED</font>做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。</h5><h4 id="2-第二步：如果未授权，申请授权"><a href="#2-第二步：如果未授权，申请授权" class="headerlink" title="2.第二步：如果未授权，申请授权"></a>2.<font color="pink">第二步</font>：如果未授权，申请授权</h4><h5 id="（1）ActivityCompat-requestPermissions-MainActivity-this-new-String-Manifest-permission-READ-CONTACTS-1"><a href="#（1）ActivityCompat-requestPermissions-MainActivity-this-new-String-Manifest-permission-READ-CONTACTS-1" class="headerlink" title="（1）ActivityCompat.requestPermissions(MainActivity.this, new String[]{ Manifest.permission. READ_CONTACTS }, 1);"></a>（1）<font color="red">ActivityCompat.requestPermissions</font>(MainActivity.this, new String[]{ Manifest.permission. READ_CONTACTS }, 1);</h5><h5 id="（2）参数一：Activity的实例；-参数二：权限名的String数组；"><a href="#（2）参数一：Activity的实例；-参数二：权限名的String数组；" class="headerlink" title="（2）参数一：Activity的实例；    参数二：权限名的String数组；"></a>（2）参数一：Activity的实例；    参数二：权限名的String数组；</h5><h5 id="权限三：请求码，唯一即可"><a href="#权限三：请求码，唯一即可" class="headerlink" title="权限三：请求码，唯一即可"></a>权限三：请求码，唯一即可</h5><h5 id="（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult-方法，对授权结果进行处理。"><a href="#（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult-方法，对授权结果进行处理。" class="headerlink" title="（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult()方法，对授权结果进行处理。"></a>（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult()方法，对授权结果进行处理。</h5><h4 id="3-第三步：处理用户授权结果"><a href="#3-第三步：处理用户授权结果" class="headerlink" title="3.第三步：处理用户授权结果"></a>3.<font color="pink">第三步</font>：处理用户授权结果</h4><h5 id="（1）-onRequestPermissionsResult-方法中，用户授权的结果封装在grantResults参数当中"><a href="#（1）-onRequestPermissionsResult-方法中，用户授权的结果封装在grantResults参数当中" class="headerlink" title="（1） onRequestPermissionsResult()方法中，用户授权的结果封装在grantResults参数当中"></a>（1）<font color="red"> onRequestPermissionsResult()</font>方法中，用户授权的结果封装在grantResults参数当中</h5><h5 id="（2）grantResults-length-gt-0-amp-amp-grantResults-0-PackageManager-PERMISSION-GRANTED说明用户允许授权"><a href="#（2）grantResults-length-gt-0-amp-amp-grantResults-0-PackageManager-PERMISSION-GRANTED说明用户允许授权" class="headerlink" title="（2）grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED说明用户允许授权"></a>（2）grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED说明用户允许授权</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111130523831.png" alt="image-20201111130523831"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111130532512.png" alt="image-20201111130532512"></p>
<h2 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h2><h3 id="一、应用程序间的数据共享"><a href="#一、应用程序间的数据共享" class="headerlink" title="一、应用程序间的数据共享"></a>一、应用程序间的数据共享</h3><h4 id="1-三个重要类"><a href="#1-三个重要类" class="headerlink" title="1.三个重要类"></a>1.三个重要类</h4><h5 id="（1）ContentProvider：内容提供者。"><a href="#（1）ContentProvider：内容提供者。" class="headerlink" title="（1）ContentProvider：内容提供者。"></a>（1）<font color="cornflowerblue">ContentProvider</font>：内容提供者。</h5><p>内容提供者的用法一般有两种：<br>一种是使用<font color="orange">现有的</font>内容提供器来读取和操作相应程序中的数据。<br>另一种是<font color="orange">创建自己的</font>内容提供器对其数据提供外部访问接口。</p>
<h5 id="（2）ContentResolver：内容访问者"><a href="#（2）ContentResolver：内容访问者" class="headerlink" title="（2）ContentResolver：内容访问者"></a>（2）<font color="cornflowerblue">ContentResolver</font>：内容访问者</h5><p>提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作。</p>
<h5 id="（3）Uri："><a href="#（3）Uri：" class="headerlink" title="（3）Uri："></a>（3）<font color="cornflowerblue">Uri</font>：</h5><p>不同于SQLiteDatabase， ContentResolver中增删改查方法不接收表名参数，而是使用一个Uri参数代替，这个参数称为内容Uri。</p>
<p>格式：<font color="red">scheme:/ /Authority / path / id</font></p>
<ul>
<li>scheme： content://是一个标准的前缀，表明了这个数据被内容提供者管理，它不会修改。</li>
<li>authority：用于唯一标识一个ContentProvider，外部调用者可以根据此标识访问该ContentProvider。通常可将Authority设置为包名和类名的全称，以保证唯一性。例如包名是com.example.app，则authority可以命名为com.example.app.provider。</li>
<li>path：用于对同一应用程序的不同的数据进行区分，通常添加到authority的后面，例如/table1, /table2。</li>
<li>id：数据集中的每一条记录都有一个唯一的id。如果Uri中包含需要获取的记录的id，则只对该记录进行操作；如果Uri中没有id，则表示操作数据集中的所有记录。</li>
<li><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132317186.png" alt="image-20201111132317186"></li>
</ul>
<h4 id="2-使用ContentResolver访问共享数据"><a href="#2-使用ContentResolver访问共享数据" class="headerlink" title="2.使用ContentResolver访问共享数据"></a>2.使用ContentResolver访问共享数据</h4><h5 id="ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作"><a href="#ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作" class="headerlink" title="ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作"></a>ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行<font color="red">CRUD</font>操作</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132443856.png" alt="image-20201111132443856"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132412264.png" alt="image-20201111132412264"></p>
<h4 id="3-查询-获取-内容提供者中指定的数据"><a href="#3-查询-获取-内容提供者中指定的数据" class="headerlink" title="3. 查询(获取)内容提供者中指定的数据"></a>3. <font color="cornflowerblue">查询</font>(获取)内容提供者中指定的数据</h4><h5 id="（1）首先，确定访问目标"><a href="#（1）首先，确定访问目标" class="headerlink" title="（1）首先，确定访问目标"></a>（1）首先，确定访问目标</h5><h5 id="Uri-uri-Uri-parse-“content-com-example-app-provider-table1”"><a href="#Uri-uri-Uri-parse-“content-com-example-app-provider-table1”" class="headerlink" title="Uri uri = Uri.parse(“content://com.example.app.provider/table1”);"></a>Uri uri = Uri.parse(“content://com.example.app.provider/table1”);</h5><p>（2）然后，查询：<br>获取ContentResolver，将Uri对象作为参数，调用query()方法得到一个cursor对象</p>
<h5 id="Cursor-cursor-getContentResolver-query-uri-projection-selection-selectionArgs-sortOrder"><a href="#Cursor-cursor-getContentResolver-query-uri-projection-selection-selectionArgs-sortOrder" class="headerlink" title="Cursor  cursor = getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder);"></a><font color="red">Cursor  cursor = getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder);</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132642375.png" alt="image-20201111132642375"></p>
<h5 id="（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。"><a href="#（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。" class="headerlink" title="（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。"></a>（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133026107.png" alt="image-20201111133026107"></p>
<h4 id="4-向内容提供者共享的table1中添加数据"><a href="#4-向内容提供者共享的table1中添加数据" class="headerlink" title="4. 向内容提供者共享的table1中添加数据"></a>4. 向内容提供者共享的table1中<font color="cornflowerblue">添加</font>数据</h4><h5 id="将待添加的数据组装到ContentValues，然后调用ContentResolver类insert-方法，将uri和ContentValues作为参数传入。"><a href="#将待添加的数据组装到ContentValues，然后调用ContentResolver类insert-方法，将uri和ContentValues作为参数传入。" class="headerlink" title="将待添加的数据组装到ContentValues，然后调用ContentResolver类insert()方法，将uri和ContentValues作为参数传入。"></a>将待添加的数据组装到ContentValues，然后调用ContentResolver类insert()方法，将uri和ContentValues作为参数传入。</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133121157.png" alt="image-20201111133121157"></p>
<h4 id="5-向内容提供者共享的table1中更新数据"><a href="#5-向内容提供者共享的table1中更新数据" class="headerlink" title="5. 向内容提供者共享的table1中更新数据"></a>5. 向内容提供者共享的table1中<font color="cornflowerblue">更新</font>数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133151906.png" alt="image-20201111133151906"></p>
<h4 id="6-向内容提供者共享的table1中删除数据"><a href="#6-向内容提供者共享的table1中删除数据" class="headerlink" title="6.向内容提供者共享的table1中删除数据"></a>6.向内容提供者共享的table1中<font color="cornflowerblue">删除</font>数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133224468.png" alt="image-20201111133224468"></p>
<h2 id="创建自己的内容提供器-（P260）"><a href="#创建自己的内容提供器-（P260）" class="headerlink" title="创建自己的内容提供器*（P260）"></a>创建自己的内容提供器*（P260）</h2><h3 id="一、重写其中6个抽象方法"><a href="#一、重写其中6个抽象方法" class="headerlink" title="一、重写其中6个抽象方法"></a>一、重写其中6个抽象方法</h3><h4 id="1-public-boolean-onCreate-：ContentProvider创建时调用。"><a href="#1-public-boolean-onCreate-：ContentProvider创建时调用。" class="headerlink" title="1.public boolean onCreate()：ContentProvider创建时调用。"></a>1.public boolean <font color="cornflowerblue">onCreate()</font>：ContentProvider创建时调用。</h4><h4 id="2-public-int-delete-…-：根据传入的Uri删除指定条件下的数据。"><a href="#2-public-int-delete-…-：根据传入的Uri删除指定条件下的数据。" class="headerlink" title="2. public int delete(…)：根据传入的Uri删除指定条件下的数据。"></a>2. public int <font color="cornflowerblue">delete(…)</font>：根据传入的Uri删除指定条件下的数据。</h4><h4 id="3-public-Uri-insert-…-：根据传入的Uri插入数据。"><a href="#3-public-Uri-insert-…-：根据传入的Uri插入数据。" class="headerlink" title="3.public Uri insert(…)：根据传入的Uri插入数据。"></a>3.public Uri <font color="cornflowerblue">insert(…)</font>：根据传入的Uri插入数据。</h4><h4 id="4-public-Cursor-query-…-：根据传入的Uri查询指定的数据。"><a href="#4-public-Cursor-query-…-：根据传入的Uri查询指定的数据。" class="headerlink" title="4. public Cursor query(…)：根据传入的Uri查询指定的数据。"></a>4. public Cursor <font color="cornflowerblue">query(…)</font>：根据传入的Uri查询指定的数据。</h4><h4 id="5-public-int-update-…-：根据传入的Uri更新指定的数据。"><a href="#5-public-int-update-…-：根据传入的Uri更新指定的数据。" class="headerlink" title="5.public int update(…)：根据传入的Uri更新指定的数据。"></a>5.public int <font color="cornflowerblue">update(…)</font>：根据传入的Uri更新指定的数据。</h4><h4 id="6-getType"><a href="#6-getType" class="headerlink" title="6.getType()"></a>6.<font color="red">getType()</font></h4><h3 id="二、Uri参数：确定调用方希望访问的数据或表"><a href="#二、Uri参数：确定调用方希望访问的数据或表" class="headerlink" title="二、Uri参数：确定调用方希望访问的数据或表"></a>二、Uri参数：确定调用方希望访问的数据或表</h3><h4 id="表：content-com-example-app-privder-table1"><a href="#表：content-com-example-app-privder-table1" class="headerlink" title="表：content://com.example.app.privder/table1/"></a>表：content://com.example.app.privder/table1/</h4><h4 id="数据：content-com-example-app-privder-table1"><a href="#数据：content-com-example-app-privder-table1" class="headerlink" title="数据：content://com.example.app.privder/table1/#"></a>数据：content://com.example.app.privder/table1/#</h4><h3 id="三、通过UriMatcher类解析Uri参数，确定调用的数据或表"><a href="#三、通过UriMatcher类解析Uri参数，确定调用的数据或表" class="headerlink" title="三、通过UriMatcher类解析Uri参数，确定调用的数据或表"></a>三、通过UriMatcher类解析Uri参数，确定调用的数据或表</h3><h4 id="首先将需要共享的数据或数据表的内容URI用addURI-方法添加到自定义的内容提供器中"><a href="#首先将需要共享的数据或数据表的内容URI用addURI-方法添加到自定义的内容提供器中" class="headerlink" title="首先将需要共享的数据或数据表的内容URI用addURI()方法添加到自定义的内容提供器中"></a>首先将需要共享的数据或数据表的内容URI用<font color="red">addURI()方法</font>添加到自定义的内容提供器中</h4><h4 id="然后，在query-方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。"><a href="#然后，在query-方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。" class="headerlink" title="然后，在query()方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。"></a>然后，在query()方法中调用UriMatcher的<font color="red">match方法</font>对传入的Uri对象进行解析，<font color="orange">返回某个能匹配这个Uri对象的自定义代码</font>，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117132442004.png" alt="image-20201117132442004"></p>
<h3 id="四、getType-方法"><a href="#四、getType-方法" class="headerlink" title="四、getType()方法"></a>四、getType()方法</h3><p>一个内容URI所对应的MIME字符串由3部分组成：    </p>
<ul>
<li>以vnd开头</li>
<li>如果内容URI以路径结尾，则后接android.cursor.<font color="red">dir</font>/，如果内容URI以id结尾，则后接android.cursor<font color="red">.item</font>/</li>
<li>最后接上vnd.<authority>.<path></path></authority></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;<span class="comment">//教材265页</span></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Implement this to handle requests for the MIME type of the data</span></span><br><span class="line">       <span class="comment">// at the given URI.</span></span><br><span class="line">       <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">           <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.book&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.category&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.category&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="内容观察者ContentObersver"><a href="#内容观察者ContentObersver" class="headerlink" title="内容观察者ContentObersver"></a>内容观察者ContentObersver</h2><h3 id="一、ContentObserver（内容观察者）"><a href="#一、ContentObserver（内容观察者）" class="headerlink" title="一、ContentObserver（内容观察者）"></a>一、ContentObserver（内容观察者）</h3><h4 id="1-目的是观察-捕捉-特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器-Trigger-，当ContentObserver所观察的Uri发生变化时，便会触发它。"><a href="#1-目的是观察-捕捉-特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器-Trigger-，当ContentObserver所观察的Uri发生变化时，便会触发它。" class="headerlink" title="1.目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它。"></a>1.目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它。</h4><h4 id="2-触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri-MIME-Type有关的。"><a href="#2-触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri-MIME-Type有关的。" class="headerlink" title="2.触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri MIME Type有关的。"></a>2.触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri MIME Type有关的。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117133208124.png" alt="image-20201117133208124"></p>
<h4 id="3-当A应用程序的数据发生变化时，A应用程序调用notifyChange-方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange-方法。"><a href="#3-当A应用程序的数据发生变化时，A应用程序调用notifyChange-方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange-方法。" class="headerlink" title="3.当A应用程序的数据发生变化时，A应用程序调用notifyChange()方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange()方法。"></a>3.当A应用程序的数据发生变化时，A应用程序调用notifyChange()方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange()方法。</h4><h3 id="二、ContentObserver的几个常用的方法"><a href="#二、ContentObserver的几个常用的方法" class="headerlink" title="二、ContentObserver的几个常用的方法"></a>二、ContentObserver的几个常用的方法</h3><h4 id="1-构造方法-public-void-ContentObserver-Handler-handler"><a href="#1-构造方法-public-void-ContentObserver-Handler-handler" class="headerlink" title="1.构造方法 public void ContentObserver(Handler handler)"></a>1.构造方法 public void<font color="cornflowerblue"> ContentObserver(Handler handler)</font></h4><p>​        所有ContentObserver的派生类都需要调用该构造方法.<br>参数：handler，Handler对象。可以是主线程Handler(这时候可以更新UI )，也可以是任何Handler对象。</p>
<h4 id="2-void-onChange-boolean-selfChange"><a href="#2-void-onChange-boolean-selfChange" class="headerlink" title="2.void onChange(boolean selfChange)"></a>2.void <font color="cornflowerblue">onChange(boolean selfChange)</font></h4><p>​        观察到的Uri发生变化时，回调该方法去处理。<br>所有ContentObserver的派生类都需要重载该方法去处理逻辑。</p>
<h1 id="第八章-丰富你的程序——运用手机多媒体"><a href="#第八章-丰富你的程序——运用手机多媒体" class="headerlink" title="第八章 丰富你的程序——运用手机多媒体"></a>第八章 丰富你的程序——运用手机多媒体</h1><h2 id="播放多媒体文件"><a href="#播放多媒体文件" class="headerlink" title="播放多媒体文件"></a>播放多媒体文件</h2><h3 id="一、播放音频"><a href="#一、播放音频" class="headerlink" title="一、播放音频"></a>一、播放音频</h3><h4 id="1-MediaPlayer类"><a href="#1-MediaPlayer类" class="headerlink" title="1.MediaPlayer类"></a>1.<font color="cornflowerblue">MediaPlayer</font>类</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124130455169.png" alt="image-20201124130455169"></p>
<h4 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2.工作流程"></a>2.工作流程</h4><ul>
<li><h5 id="创建MediaPlayer对象；"><a href="#创建MediaPlayer对象；" class="headerlink" title="创建MediaPlayer对象；"></a>创建MediaPlayer对象；</h5></li>
<li><h5 id="初始化设置音频文件路径：setDataSource"><a href="#初始化设置音频文件路径：setDataSource" class="headerlink" title="初始化设置音频文件路径：setDataSource()"></a>初始化设置音频文件路径：setDataSource()</h5></li>
<li><h5 id="使MediaPlayer进入准备状态：pepare"><a href="#使MediaPlayer进入准备状态：pepare" class="headerlink" title="使MediaPlayer进入准备状态：pepare()"></a>使MediaPlayer进入准备状态：pepare()</h5></li>
<li><h5 id="开始播放音频：start"><a href="#开始播放音频：start" class="headerlink" title="开始播放音频：start()"></a>开始播放音频：start()</h5></li>
<li><h5 id="暂停播放音频：pause"><a href="#暂停播放音频：pause" class="headerlink" title="暂停播放音频：pause()"></a>暂停播放音频：pause()</h5></li>
<li><h5 id="停止播放音频：reset-setDataSource-pepare"><a href="#停止播放音频：reset-setDataSource-pepare" class="headerlink" title="停止播放音频：reset(), setDataSource(), pepare()"></a>停止播放音频：reset(), setDataSource(), pepare()</h5></li>
</ul>
<h1 id="第九章-看看精彩的技术——使用网络技术"><a href="#第九章-看看精彩的技术——使用网络技术" class="headerlink" title="第九章 看看精彩的技术——使用网络技术"></a>第九章 看看精彩的技术——使用网络技术</h1><h2 id="Android常见的网络通信方式"><a href="#Android常见的网络通信方式" class="headerlink" title="Android常见的网络通信方式"></a>Android常见的网络通信方式</h2><h3 id="一、基于TCP协议"><a href="#一、基于TCP协议" class="headerlink" title="一、基于TCP协议"></a>一、基于TCP协议</h3><p>（1）针对TCP的 Socket、ServerSocket<br>（2）针对UDP的DatagramSocket、DatagramPackage<br>（3）Apache Mina框架</p>
<h3 id="二、基于Http协议"><a href="#二、基于Http协议" class="headerlink" title="二、基于Http协议"></a>二、基于Http协议</h3><p>HttpURLConnection、HttpClient、AsyncHttpClient框架等</p>
<h3 id="三、直接使用-WebKit-访问网络"><a href="#三、直接使用-WebKit-访问网络" class="headerlink" title="三、直接使用 WebKit 访问网络"></a>三、直接使用 WebKit 访问网络</h3><h3 id="四、使用网络通信框架"><a href="#四、使用网络通信框架" class="headerlink" title="四、使用网络通信框架"></a>四、使用网络通信框架</h3><p>OkHttp，Volley，Retrofit</p>
<h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><h3 id="一、通信协议"><a href="#一、通信协议" class="headerlink" title="一、通信协议"></a>一、通信协议</h3><h4 id="1-计算机网络实现通信必须遵循守一些约定。核心要素包括："><a href="#1-计算机网络实现通信必须遵循守一些约定。核心要素包括：" class="headerlink" title="1.计算机网络实现通信必须遵循守一些约定。核心要素包括："></a>1.计算机网络实现通信必须遵循守一些约定。核心要素包括：</h4><h5 id="（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；"><a href="#（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；" class="headerlink" title="（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；"></a>（1）<font color="cornflowerblue">语义</font>：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；</h5><h5 id="（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；"><a href="#（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；" class="headerlink" title="（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；"></a>（2）<font color="cornflowerblue">语法</font>：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；</h5><h5 id="（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。"><a href="#（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。" class="headerlink" title="（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。"></a>（3）<font color="cornflowerblue">时序</font>：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。</h5><h4 id="2-常见的通信协议"><a href="#2-常见的通信协议" class="headerlink" title="2.常见的通信协议"></a>2.常见的通信协议</h4><ul>
<li>TCP/IP, IPX/SPX, NetBEUI, RS-232-C等</li>
<li>TCP/IP 是最基本的通信协议。</li>
<li>TCP/IP是一组协议的集合，是一组协议集合的简称。</li>
</ul>
<h3 id="二、TCP-IP-协议集"><a href="#二、TCP-IP-协议集" class="headerlink" title="二、TCP/IP 协议集"></a>二、TCP/IP 协议集</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214220514420.png" alt="image-20201214220514420"></p>
<h4 id="1-以QQ数据传输为例"><a href="#1-以QQ数据传输为例" class="headerlink" title="1.以QQ数据传输为例"></a>1.以QQ数据传输为例</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214220704145.png" alt="image-20201214220704145"></p>
<h4 id="2-TCP与UDP，传输层"><a href="#2-TCP与UDP，传输层" class="headerlink" title="2.TCP与UDP，传输层"></a>2.TCP与UDP，传输层</h4><h5 id="1、TCP面向连接（如打电话要先拨号建立连接）-UDP是无连接的，即发送数据之前不需要建立连接。"><a href="#1、TCP面向连接（如打电话要先拨号建立连接）-UDP是无连接的，即发送数据之前不需要建立连接。" class="headerlink" title="1、TCP面向连接（如打电话要先拨号建立连接）; UDP是无连接的，即发送数据之前不需要建立连接。"></a>1、<font color="red">TCP面向连接</font>（如打电话要先拨号建立连接）;<font color="red"> UDP是无连接的</font>，即发送数据之前不需要建立连接。</h5><h5 id="2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达-UDP尽最大努力交付，即不保证可靠交付。"><a href="#2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达-UDP尽最大努力交付，即不保证可靠交付。" class="headerlink" title="2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保证可靠交付。"></a>2、<font color="red">TCP提供可靠的服务</font>。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; <font color="red">UDP尽最大努力交付，即不保证可靠交付</font>。</h5><h5 id="3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流-UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。"><a href="#3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流-UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。" class="headerlink" title="3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。"></a>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</h5><h5 id="4、每一条TCP连接只能是点到点的-UDP支持一对一，一对多，多对一和多对多的交互通信。"><a href="#4、每一条TCP连接只能是点到点的-UDP支持一对一，一对多，多对一和多对多的交互通信。" class="headerlink" title="4、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信。"></a>4、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信。</h5><h5 id="5、TCP首部开销20字节-UDP的首部开销小，只有8个字节。"><a href="#5、TCP首部开销20字节-UDP的首部开销小，只有8个字节。" class="headerlink" title="5、TCP首部开销20字节;UDP的首部开销小，只有8个字节。"></a>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节。</h5><h5 id="6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。"><a href="#6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。" class="headerlink" title="6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。"></a>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</h5><h4 id="3-HTTP，应用层"><a href="#3-HTTP，应用层" class="headerlink" title="3.HTTP，应用层"></a>3.HTTP，应用层</h4><h5 id="（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。"><a href="#（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。" class="headerlink" title="（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。"></a>（1）Http是一个基于<font color="red">请求与响应，无状态的，应用层的</font>协议，常基于<font color="red">TCP</font>协议传输数据。</h5><h5 id="（2）用于定义Web浏览器与Web服务器之间交换数据的过程。"><a href="#（2）用于定义Web浏览器与Web服务器之间交换数据的过程。" class="headerlink" title="（2）用于定义Web浏览器与Web服务器之间交换数据的过程。"></a>（2）用于定义Web浏览器与Web服务器之间交换数据的过程。</h5><h5 id="（3）四个基于：请求与响应、无状态、应用层、TCP"><a href="#（3）四个基于：请求与响应、无状态、应用层、TCP" class="headerlink" title="（3）四个基于：请求与响应、无状态、应用层、TCP"></a>（3）四个基于：请求与响应、无状态、应用层、TCP</h5><h2 id="基于TCP协议的网络通信"><a href="#基于TCP协议的网络通信" class="headerlink" title="基于TCP协议的网络通信"></a>基于TCP协议的网络通信</h2><h3 id="一、IP地址、端口"><a href="#一、IP地址、端口" class="headerlink" title="一、IP地址、端口"></a>一、IP地址、端口</h3><h4 id="1-IP地址"><a href="#1-IP地址" class="headerlink" title="1.IP地址"></a>1.<font color="cornflowerblue">IP地址</font></h4><h5 id="IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192-168-0-0-1。"><a href="#IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192-168-0-0-1。" class="headerlink" title="IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192.168.0.0.1。"></a>IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192.168.0.0.1。</h5><h4 id="2-端口"><a href="#2-端口" class="headerlink" title="2.端口"></a>2.<font color="cornflowerblue">端口</font></h4><h5 id="端口号用来标记一台电脑中的不同应用程序。"><a href="#端口号用来标记一台电脑中的不同应用程序。" class="headerlink" title="端口号用来标记一台电脑中的不同应用程序。"></a>端口号用来标记一台电脑中的不同应用程序。</h5><h5 id="端口号范围是0-65535，其中0-1023是系统专用"><a href="#端口号范围是0-65535，其中0-1023是系统专用" class="headerlink" title="端口号范围是0-65535，其中0~1023是系统专用"></a>端口号范围是0-<font color="orange">65535</font>，其中0~1023是系统专用</h5><h3 id="二、Socket编程"><a href="#二、Socket编程" class="headerlink" title="二、Socket编程"></a>二、Socket编程</h3><p>略</p>
<h2 id="基于Http协议的网络通信"><a href="#基于Http协议的网络通信" class="headerlink" title="基于Http协议的网络通信"></a>基于Http协议的网络通信</h2><h3 id="一、HTTP协议工作原理"><a href="#一、HTTP协议工作原理" class="headerlink" title="一、HTTP协议工作原理"></a>一、HTTP协议工作原理</h3><h4 id="1-建立连接："><a href="#1-建立连接：" class="headerlink" title="1.建立连接："></a>1.<font color="cornflowerblue">建立连接</font>：</h4><p>客户机与服务器建立连接。输入网址、打开网页或单击超级链接。</p>
<h4 id="2-发送请求："><a href="#2-发送请求：" class="headerlink" title="2.发送请求："></a>2.<font color="cornflowerblue">发送请求</font>：</h4><p>客户机向服务器发送请求，格式为：<strong>统一资源标识符</strong>（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p>
<h4 id="3-响应请求："><a href="#3-响应请求：" class="headerlink" title="3.响应请求："></a>3.<font color="cornflowerblue">响应请求</font>：</h4><p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
<h4 id="4-接收响应："><a href="#4-接收响应：" class="headerlink" title="4.接收响应："></a>4.<font color="cornflowerblue">接收响应</font>：</h4><p>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后与服务器断开连接。</p>
<h3 id="二、HTTP请求报文"><a href="#二、HTTP请求报文" class="headerlink" title="二、HTTP请求报文"></a>二、HTTP<strong>请求报文</strong></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215125047712.png" alt="image-20201215125047712"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215124600803.png" alt="image-20201215124600803"></p>
<h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.<font color="cornflowerblue">请求行</font></h4><h5 id="（1）请求方法"><a href="#（1）请求方法" class="headerlink" title="（1）请求方法"></a>（1）请求方法</h5><p>HTTP/1.1 定义的请求方法有8种，最常的两种GET和POST。</p>
<h5 id="（2）请求地址"><a href="#（2）请求地址" class="headerlink" title="（2）请求地址"></a>（2）请求地址</h5><p>URL:<font color="orange">统一资源定位符</font>，是一种资源位置的抽象唯一识别方法。<br>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;<br>端口和路径有时可以省略（HTTP默认端口号是80），有时会带参数，GET请求</p>
<h5 id="（3）版本协议"><a href="#（3）版本协议" class="headerlink" title="（3）版本协议"></a>（3）版本协议</h5><p>格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p>
<h4 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2.请求头部"></a>2.<font color="cornflowerblue">请求头部</font></h4><h5 id="（1）由键值对组成，每行一对，关键字和值用英文冒号“-”分隔。"><a href="#（1）由键值对组成，每行一对，关键字和值用英文冒号“-”分隔。" class="headerlink" title="（1）由键值对组成，每行一对，关键字和值用英文冒号“:”分隔。"></a>（1）由<font color="red">键值对</font>组成，每行一对，关键字和值用英文冒号“:”分隔。</h5><h5 id="（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有："><a href="#（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有：" class="headerlink" title="（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有："></a>（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215125315165.png" alt="image-20201215125315165"></p>
<h5 id="（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。"><a href="#（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。" class="headerlink" title="（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。"></a>（3）请求头部的最后<font color="red">会有一个空行，表示请求头部结束</font>，接下来为请求数据，这一行非常重要，必不可少。</h5><h4 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3.请求数据"></a>3.<font color="cornflowerblue">请求数据</font></h4><h5 id="（1）可选部分，比如GET请求就没有请求数据。"><a href="#（1）可选部分，比如GET请求就没有请求数据。" class="headerlink" title="（1）可选部分，比如GET请求就没有请求数据。"></a>（1）可选部分，比如GET请求就没有请求数据。</h5><h5 id="（2）HTTP的请求方式包括GET-POST-PUT-HEAD-DELETE-TRACE-CONNECT-OPTIONS等，最常用的发送请求的方式主要有-get-和-post两种"><a href="#（2）HTTP的请求方式包括GET-POST-PUT-HEAD-DELETE-TRACE-CONNECT-OPTIONS等，最常用的发送请求的方式主要有-get-和-post两种" class="headerlink" title="（2）HTTP的请求方式包括GET,POST, PUT ,HEAD, DELETE, TRACE, CONNECT, OPTIONS等，最常用的发送请求的方式主要有 get 和 post两种"></a>（2）HTTP的请求方式包括GET,POST, PUT ,HEAD, DELETE, TRACE, CONNECT, OPTIONS等，最常用的发送请求的方式主要有 get 和 post两种</h5><h4 id="4-GET与POST"><a href="#4-GET与POST" class="headerlink" title="4. GET与POST"></a>4. GET与POST</h4><h5 id="（1）get"><a href="#（1）get" class="headerlink" title="（1）get"></a>（1）get</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215130633494.png" alt="image-20201215130633494"></p>
<h5 id="（2）post"><a href="#（2）post" class="headerlink" title="（2）post"></a>（2）post</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111436244.png" alt="image-20201216111436244"></p>
<h5 id="3-注意"><a href="#3-注意" class="headerlink" title="(3)注意"></a>(3)注意</h5><ul>
<li>GET 和 POST 两种请求方式都可以发送数据的，只是<font color="orange">发送机制</font>font&gt;不一样。</li>
<li>另外GET安全性非常低，Post<font color="orange">安全性较高</font>， 但是GET<font color="orange">执行效率</font>却比Post方法好。</li>
<li>一般<font color="orange">查询</font>的时候我们用<font color="orange">GET</font>，数据<font color="orange">增删改</font>的时候用<font color="orange">POST</font>。</li>
</ul>
<h5 id="4-其他区别"><a href="#4-其他区别" class="headerlink" title="(4)其他区别"></a>(4)其他区别</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111723498.png" alt="image-20201216111723498"></p>
<h3 id="三、HTTP响应报文"><a href="#三、HTTP响应报文" class="headerlink" title="三、HTTP响应报文"></a>三、HTTP响应报文</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111852290.png" alt="image-20201216111852290"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111859563.png" alt="image-20201216111859563"></p>
<h4 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1.状态行"></a>1.状态行</h4><h5 id="（1）由3部分组成，分别为：协议版本，状态码，状态码描述）"><a href="#（1）由3部分组成，分别为：协议版本，状态码，状态码描述）" class="headerlink" title="（1）由3部分组成，分别为：协议版本，状态码，状态码描述）"></a>（1）由3部分组成，分别为：协议版本，<font color="red">状态码</font>，状态码描述）</h5><h5 id="（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述"><a href="#（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述" class="headerlink" title="（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述"></a>（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述</h5><h5 id="（3）常见状态码"><a href="#（3）常见状态码" class="headerlink" title="（3）常见状态码"></a>（3）常见状态码</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112057996.png" alt="image-20201216112057996"></p>
<h5 id="2-响应头部"><a href="#2-响应头部" class="headerlink" title="2.响应头部"></a>2.响应头部</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112237974.png" alt="image-20201216112237974"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112254577.png" alt="image-20201216112254577"></p>
<h3 id="四、基于HTTP的网络编程"><a href="#四、基于HTTP的网络编程" class="headerlink" title="四、基于HTTP的网络编程"></a>四、基于HTTP的网络编程</h3><p>（HyperText Transfer protocol）<font color="cornflowerblue">超文本传输协议</font></p>
<h4 id="1-通过URL获取网络资源"><a href="#1-通过URL获取网络资源" class="headerlink" title="1.通过URL获取网络资源"></a>1.通过URL获取网络资源</h4><h5 id="（1）URL（Unifrom-Resource-Locator）统一资源定位器"><a href="#（1）URL（Unifrom-Resource-Locator）统一资源定位器" class="headerlink" title="（1）URL（Unifrom Resource Locator）统一资源定位器"></a>（1）URL（Unifrom Resource Locator）<font color="cornflowerblue">统一资源定位器</font></h5><p>可以定位到互联网的资源上。如果用户已经知道网络上某个资源的URL(如图片、音乐和视频文件等)，那么就可以直接通过使用URL来进行网络连接，获得资源</p>
<h5 id="（2）资源获取过程："><a href="#（2）资源获取过程：" class="headerlink" title="（2）资源获取过程："></a>（2）资源获取过程：</h5><ol>
<li>创建URL对象。</li>
<li>调用常用的方法来获取对应的资源。例如，使用<font color="red">openStream()</font>方法，打开与此URL的连接，并返回读取到的数据流。</li>
<li>将获得的数据流进行处理。例如，显示到ImageView上。</li>
</ol>
<p>说明：openStream() 实际是通过<font color="red">openConnection()</font>方法获取URLConnection对象，然后调用<font color="red">getInputStream()</font>方法，这个方法会隐式的调用connect() 方法发送连接请求。</p>
<p>URL url = new URL( “ …”);</p>
<p>HttpURLConnection connection = (HttpURLConnection) url.openConnection();</p>
<p>InputStream in = connection.getInputStream();</p>
<p>等加于</p>
<p>URL url = new URL( “ …”);</p>
<p>InputStream in = url.openStream();</p>
<h5 id="3-URL类常用的方法"><a href="#3-URL类常用的方法" class="headerlink" title="(3)URL类常用的方法"></a>(3)URL类常用的方法</h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216113912830.png" alt="image-20201216113912830">

<h5 id="（4）案例：图片资源获取并显示"><a href="#（4）案例：图片资源获取并显示" class="headerlink" title="（4）案例：图片资源获取并显示"></a>（4）案例：图片资源获取并显示</h5><p>1.布局文件：新建项目URLDemo，在布局文件中，准备一个ImageView控件。</p>
<p>2.初始化并准备异步任务类。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216114237925.png" alt="image-20201216114237925"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216114246080.png" alt="image-20201216114246080"></p>
<p>3.<strong>获取网络资源</strong>：在doInBackground()方法中执行联网以获取网络资源，获取到的图片信息作为返回结果，传给onPostExecute()中的参数</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216120334545.png" alt="image-20201216120334545"></p>
<p>4.<strong>资源显示</strong>：在onPostExecute()方法中进行图片显示。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216120421728.png" alt="image-20201216120421728"></p>
<p>5.增加上网权限。</p>
<p>&lt;uses-permission android:”android.permission.INTERNET”/&gt;</p>
<h4 id="2-通过URLConnection获取网络资源"><a href="#2-通过URLConnection获取网络资源" class="headerlink" title="2.通过URLConnection获取网络资源"></a>2.通过URLConnection获取网络资源</h4><h5 id="（1）URL-对象提供了openConnection-方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。"><a href="#（1）URL-对象提供了openConnection-方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。" class="headerlink" title="（1）URL 对象提供了openConnection()方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。"></a>（1）URL 对象提供了<font color="cornflowerblue">openConnection()</font>方法返回一个<font color="cornflowerblue">URLConnection</font>对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。</h5><h5 id="（2）实现步骤"><a href="#（2）实现步骤" class="headerlink" title="（2）实现步骤"></a>（2）实现步骤</h5><ol>
<li>创建<font color="orange">URL对象</font>。</li>
<li>建立与URL的连接：由于<font color="orange">URLConnection</font>为抽象类，其对象不能直接实例化，通常通过<font color="orange">openConnection</font>方法获得。</li>
<li>获取返回的<font color="orange">InputStream</font>。</li>
<li>将InputStream进行处理：例如，显示到相应的控件上。</li>
<li>关闭流操作</li>
</ol>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217124051779.png" alt="image-20201217124051779"></p>
<h5 id="（3）URLConnection常用方法"><a href="#（3）URLConnection常用方法" class="headerlink" title="（3）URLConnection常用方法"></a>（3）URLConnection常用方法</h5><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public int <font color="red">getContentLength</font>()</td>
<td>获得文件的长度</td>
</tr>
<tr>
<td>public String getContentType()</td>
<td>获得文件的类型</td>
</tr>
<tr>
<td>public long getDate()</td>
<td>获得文件创建的时间</td>
</tr>
<tr>
<td>public long getLastModified()</td>
<td>获得文件最后修改的时间</td>
</tr>
<tr>
<td>public InputStream <font color="red">getInputStream()</font></td>
<td>获得输入流，以便读取文件的数据</td>
</tr>
<tr>
<td>public OutputStream getOutputStream()</td>
<td>获得输出流，以便输出数据</td>
</tr>
<tr>
<td>public void <font color="red">setRequestProperty(String key,String value)</font></td>
<td>设置请求属性值</td>
</tr>
<tr>
<td>connect()</td>
<td>打开到此URL引用的资源的通信连接(如果尚未建立连接)，如果已打开连接(此时connected()为true)，则忽略该调用</td>
</tr>
</tbody></table>
<h4 id="3-使用HttpURLConnection获取网络资源"><a href="#3-使用HttpURLConnection获取网络资源" class="headerlink" title="3.使用HttpURLConnection获取网络资源"></a>3.使用HttpURLConnection获取网络资源</h4><h5 id="（1）HttpURLConnection常用方法"><a href="#（1）HttpURLConnection常用方法" class="headerlink" title="（1）HttpURLConnection常用方法"></a>（1）HttpURLConnection常用方法</h5><p>HttpURLConnection是URLConnection的子类</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>InputStream <font color="red">getInputStream()</font></td>
<td>返回从此处打开的连接读取的输入流</td>
</tr>
<tr>
<td>OutputStream getOutputStream()</td>
<td>返回写入到此连接的输出流</td>
</tr>
<tr>
<td>String <font color="red">getRequestMethod()</font></td>
<td>获取请求方法</td>
</tr>
<tr>
<td>int getResponseCode()</td>
<td>获取状态码</td>
</tr>
<tr>
<td>void setRequestMethod(String method)</td>
<td>设置URL请求的方法</td>
</tr>
<tr>
<td>void setDoInput(boolean doinput)</td>
<td>设置输入流</td>
</tr>
<tr>
<td>void setDoOutput(boolean dooutput)</td>
<td>设置输出流</td>
</tr>
<tr>
<td>void setUseCaches(boolean usecaches)</td>
<td>设置连接是否使用任何可用的缓存</td>
</tr>
<tr>
<td>void disconnect()</td>
<td>关闭连接</td>
</tr>
</tbody></table>
<h5 id="（2）GET方式：将参数放在url后一起传递"><a href="#（2）GET方式：将参数放在url后一起传递" class="headerlink" title="（2）GET方式：将参数放在url后一起传递"></a>（2）GET方式：将参数放在url后一起传递</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125144443.png" alt="image-20201217125144443"></p>
<h5 id="（2）POST方法"><a href="#（2）POST方法" class="headerlink" title="（2）POST方法"></a>（2）POST方法</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125444529.png" alt="image-20201217125444529"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125635416.png" alt="image-20201217125635416"></p>
<h2 id="使用WebView控件"><a href="#使用WebView控件" class="headerlink" title="使用WebView控件"></a>使用WebView控件</h2><h3 id="1-Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个-控件"><a href="#1-Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个-控件" class="headerlink" title="1.Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个 控件"></a>1.Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个 控件</h3><h3 id="2-WebView-网页视图-常用方法"><a href="#2-WebView-网页视图-常用方法" class="headerlink" title="2.WebView(网页视图)常用方法"></a>2.WebView(<font color="cornflowerblue">网页视图</font>)常用方法</h3><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>loadUrl(String url)</td>
<td>打开一个指定的Web资源页面</td>
</tr>
<tr>
<td>loadData(String data, StringmimeType,String encoding)</td>
<td>显示HTML格式的网页内容</td>
</tr>
<tr>
<td>getSettings()</td>
<td>获取WebView的设置对象</td>
</tr>
<tr>
<td>addJavascriptInterface()</td>
<td>将一个对象添加到JavaScript的全局对象Window中</td>
</tr>
<tr>
<td>clearCache()</td>
<td>清除缓存</td>
</tr>
<tr>
<td>destory()</td>
<td>销毁WebView</td>
</tr>
</tbody></table>
<h3 id="3-在应用中嵌入浏览器展示网页，并进行解析"><a href="#3-在应用中嵌入浏览器展示网页，并进行解析" class="headerlink" title="3.在应用中嵌入浏览器展示网页，并进行解析"></a>3.在应用中嵌入浏览器展示网页，并进行解析</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217130452896.png" alt="image-20201217130452896"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217130553473.png" alt="image-20201217130553473"></p>
<h2 id="使用OKHttp获取网络资源"><a href="#使用OKHttp获取网络资源" class="headerlink" title="使用OKHttp获取网络资源"></a>使用OKHttp获取网络资源</h2><h3 id="1-GET请求"><a href="#1-GET请求" class="headerlink" title="1.GET请求"></a>1.GET请求</h3><h4 id="（1）添加依赖"><a href="#（1）添加依赖" class="headerlink" title="（1）添加依赖"></a>（1）添加依赖</h4><h4 id="implementation-‘com-squareup-okhttp3-okhttp-3-10-0’"><a href="#implementation-‘com-squareup-okhttp3-okhttp-3-10-0’" class="headerlink" title="implementation ‘com.squareup.okhttp3:okhttp:3.10.0’"></a><font color="pink">implementation ‘com.squareup.okhttp3:okhttp:3.10.0’</font></h4><h4 id="（2）声明访问Internet的权限"><a href="#（2）声明访问Internet的权限" class="headerlink" title="（2）声明访问Internet的权限"></a>（2）声明访问Internet的权限</h4><h4 id="-9"><a href="#-9" class="headerlink" title></a><font color="red"><uses-permission android:name="android.permission.INTERNET"></uses-permission></font></h4><p>在application标签中添加<font color="red"> android:usesCleartextTraffic=”true”</font></p>
<h4 id="（3）创建-OkHttpClient实例"><a href="#（3）创建-OkHttpClient实例" class="headerlink" title="（3）创建 OkHttpClient实例"></a>（3）创建 OkHttpClient实例</h4><p><font color="red">OkHttpClient okHttpClient = new OkHttpClient();</font></p>
<h4 id="（4）构造Request对象。"><a href="#（4）构造Request对象。" class="headerlink" title="（4）构造Request对象。"></a>（4）构造Request对象。</h4><p><font color="red">final Request request = new Request.Builder() .url(url).get() </font>   //默认</p>
<p>就是GET请求，可以不写 .build();</p>
<h4 id="（5）构建Call对象"><a href="#（5）构建Call对象" class="headerlink" title="（5）构建Call对象"></a>（5）构建Call对象</h4><p><font color="red">Call call = okHttpClient.newCall(request);</font></p>
<h4 id="（6）-发送请求并获取服务器返回的数据。"><a href="#（6）-发送请求并获取服务器返回的数据。" class="headerlink" title="（6） 发送请求并获取服务器返回的数据。"></a>（6） 发送请求并获取服务器返回的数据。</h4><ul>
<li><h5 id="同步Get方法："><a href="#同步Get方法：" class="headerlink" title="同步Get方法："></a>同步Get方法：</h5></li>
</ul>
<h5 id="通过Call-execute-方法提交请求，放在子线程中执行，或者使用异步任务的方式"><a href="#通过Call-execute-方法提交请求，放在子线程中执行，或者使用异步任务的方式" class="headerlink" title="通过Call.execute()方法提交请求，放在子线程中执行，或者使用异步任务的方式"></a>通过<font color="red">Call.execute()</font>方法提交请求，放在<font color="orange">子线程</font>中执行，或者使用异步任务的方式</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217131925515.png" alt="image-20201217131925515"></p>
<ul>
<li><h5 id="异步Get方法："><a href="#异步Get方法：" class="headerlink" title="异步Get方法："></a>异步Get方法：</h5></li>
</ul>
<h5 id="通过Call-enqueue-Callback-方法来提交异步请求"><a href="#通过Call-enqueue-Callback-方法来提交异步请求" class="headerlink" title="通过Call.enqueue(Callback)方法来提交异步请求"></a>通过<font color="red">Call.enqueue(Callback)</font>方法来提交异步请求</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132051946.png" alt="image-20201217132051946"></p>
<h3 id="2-POST请求"><a href="#2-POST请求" class="headerlink" title="2.POST请求"></a>2.POST请求</h3><h4 id="（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如："><a href="#（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如：" class="headerlink" title="（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如："></a>（1）与上述GET请求相比，需要先构造一个<font color="red">RequestBody对象</font>用来存放待提交的数据，例如：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132351988.png" alt="image-20201217132351988"></p>
<h4 id="（2）然后在Request-Builder中调用一下post-方法，并将RequestBody对象传入："><a href="#（2）然后在Request-Builder中调用一下post-方法，并将RequestBody对象传入：" class="headerlink" title="（2）然后在Request.Builder中调用一下post()方法，并将RequestBody对象传入："></a>（2）然后在Request.Builder中调用一下post()方法，并将RequestBody对象传入：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132423939.png" alt="image-20201217132423939"></p>
<h4 id="（3）登录案例"><a href="#（3）登录案例" class="headerlink" title="（3）登录案例"></a>（3）登录案例</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133135117.png" alt="image-20201217133135117"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133213142.png" alt="image-20201217133213142"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133219867.png" alt="image-20201217133219867"></p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="一、JSON数据"><a href="#一、JSON数据" class="headerlink" title="一、JSON数据"></a>一、JSON数据</h3><h4 id="1-JSON-JavaScript-Object-Notation-是JavaScript的一个子集，是一种轻量级的数据交换格式。"><a href="#1-JSON-JavaScript-Object-Notation-是JavaScript的一个子集，是一种轻量级的数据交换格式。" class="headerlink" title="1.JSON(JavaScript Object Notation) 是JavaScript的一个子集，是一种轻量级的数据交换格式。"></a>1.JSON(JavaScript Object Notation) 是JavaScript的一个子集，是一种<font color="cornflowerblue">轻量级的数据交换格式</font>。</h4><h4 id="2-JSON的结构基于以下两点："><a href="#2-JSON的结构基于以下两点：" class="headerlink" title="2.JSON的结构基于以下两点："></a>2.JSON的结构基于以下两点：</h4><h5 id="（1）”名称-值”对的集合-：不同语言中，它被理解为对象-object-，记录-record-，结构-struct-，字典-dictionary-，哈希表-hash-table-，键列表-keyed-list-等。"><a href="#（1）”名称-值”对的集合-：不同语言中，它被理解为对象-object-，记录-record-，结构-struct-，字典-dictionary-，哈希表-hash-table-，键列表-keyed-list-等。" class="headerlink" title="（1）”名称/值”对的集合 ：不同语言中，它被理解为对象(object)，记录(record)，结构(struct)，字典(dictionary)，哈希表(hash table)，键列表(keyed list)等。"></a>（1）”名称/值”对的集合 ：不同语言中，它被理解为对象(object)，记录(record)，结构(struct)，字典(dictionary)，哈希表(hash table)，键列表(keyed list)等。</h5><h5 id="（2）值的有序列表：-多数语言中被理解为数组-array-。"><a href="#（2）值的有序列表：-多数语言中被理解为数组-array-。" class="headerlink" title="（2）值的有序列表： 多数语言中被理解为数组(array)。"></a>（2）值的有序列表： 多数语言中被理解为数组(array)。</h5><h4 id="3-JSON的形式主要有以下两种："><a href="#3-JSON的形式主要有以下两种：" class="headerlink" title="3.JSON的形式主要有以下两种："></a>3.JSON的形式主要有以下两种：</h4><h5 id="（1）对象"><a href="#（1）对象" class="headerlink" title="（1）对象"></a>（1）<font color="red">对象</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093521448.png" alt="image-20201219093521448"></p>
<h5 id="（2）数组"><a href="#（2）数组" class="headerlink" title="（2）数组"></a>（2）<font color="red">数组</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093539871.png" alt="image-20201219093539871"></p>
<h3 id="二、使用JSONObject解析JSON数据"><a href="#二、使用JSONObject解析JSON数据" class="headerlink" title="二、使用JSONObject解析JSON数据"></a>二、使用JSONObject解析JSON数据</h3><h4 id="1-案例：CityCodeDemo"><a href="#1-案例：CityCodeDemo" class="headerlink" title="1. 案例：CityCodeDemo"></a>1. 案例：CityCodeDemo</h4><p>通过Spinner控件，读取中国的城市名称，并通过选择获得该城市对应的编码值。</p>
<h5 id="1-准备JSON数据-创建assets目录"><a href="#1-准备JSON数据-创建assets目录" class="headerlink" title="(1)准备JSON数据,创建assets目录"></a>(1)准备JSON数据,创建assets目录</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093921547.png" alt="image-20201219093921547"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094342080.png" alt="image-20201219094342080"></p>
<h5 id="2-布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。"><a href="#2-布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。" class="headerlink" title="(2)布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。"></a>(2)布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。</h5><h5 id="3-启动异步任务，进行文件读取"><a href="#3-启动异步任务，进行文件读取" class="headerlink" title="(3)启动异步任务，进行文件读取"></a>(3)启动异步任务，进行文件读取</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094525406.png" alt="image-20201219094525406"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219095314825.png" alt="image-20201219095314825"></p>
<h5 id="（4）定义实体类。装载JSON的解析结果"><a href="#（4）定义实体类。装载JSON的解析结果" class="headerlink" title="（4）定义实体类。装载JSON的解析结果"></a>（4）定义实体类。装载JSON的解析结果</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094831461.png" alt="image-20201219094831461"></p>
<h5 id="（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表"><a href="#（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表" class="headerlink" title="（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表"></a>（5）<font color="red">解析JSON内容。将字符串转换为对应的CityCode实体对象列表</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219095531426.png" alt="image-20201219095531426"></p>
<h5 id="（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听"><a href="#（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听" class="headerlink" title="（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听"></a>（6）绑定界面控件。将解析得到的List<CityCode>通过适配器，绑定到spinner控件上，并设置子项监听</CityCode></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219100105438.png" alt="image-20201219100105438"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219100112597.png" alt="image-20201219100112597"></p>
<h4 id="2-安卓的资源文件assets"><a href="#2-安卓的资源文件assets" class="headerlink" title="2.安卓的资源文件assets"></a>2.安卓的资源文件assets</h4><h5 id="（1）Android资源文件的存放位置有三种："><a href="#（1）Android资源文件的存放位置有三种：" class="headerlink" title="（1）Android资源文件的存放位置有三种："></a>（1）Android资源文件的存放位置有三种：</h5><ul>
<li><h5 id="res目录下存放的可编译的资源文件；"><a href="#res目录下存放的可编译的资源文件；" class="headerlink" title="res目录下存放的可编译的资源文件；"></a><font color="orange">res</font>目录下存放的<font color="orange">可编译的资源文件</font>；</h5></li>
<li><h5 id="assets目录下存放的原生资源文件；"><a href="#assets目录下存放的原生资源文件；" class="headerlink" title="assets目录下存放的原生资源文件；"></a><font color="orange">assets</font>目录下存放的<font color="orange">原生资源文件</font>；</h5></li>
<li><h5 id="res-raw目录下存放的原生资源文件"><a href="#res-raw目录下存放的原生资源文件" class="headerlink" title="res/raw目录下存放的原生资源文件"></a><font color="orange">res/raw</font>目录下存放的<font color="orange">原生资源文件</font></h5></li>
</ul>
<h5 id="（2）assets与res-raw相同之处"><a href="#（2）assets与res-raw相同之处" class="headerlink" title="（2）assets与res/raw相同之处"></a>（2）assets与res/raw<font color="cornflowerblue">相同</font>之处</h5><ol>
<li>都可以用于放置APP所需的固定文件</li>
<li>该文件被打包到APK中时，不会被编码到二进制文件</li>
</ol>
<h5 id="（3）assets与res-raw不同之处"><a href="#（3）assets与res-raw不同之处" class="headerlink" title="（3）assets与res/raw不同之处"></a>（3）assets与res/raw<font color="cornflowerblue">不同</font>之处</h5><ol>
<li>assets目录不会被映射到R中，因此，资源无法通过R.id方式获取，必须要通过AssetManager进行操作与获取；res/raw目录下的资源会被映射到R中，可以通过getResource()方法获取资源。</li>
<li>多级目录：assets下可以有多级目录，res/raw下不可以有多级目录。</li>
</ol>
<h3 id="三、使用Goole-Gson解析JSON数据"><a href="#三、使用Goole-Gson解析JSON数据" class="headerlink" title="三、使用Goole Gson解析JSON数据"></a>三、使用Goole Gson解析JSON数据</h3><h4 id="1-Gson概述"><a href="#1-Gson概述" class="headerlink" title="1.Gson概述"></a>1.Gson概述</h4><h5 id="（1）Gson的解析非常简单-必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。"><a href="#（1）Gson的解析非常简单-必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。" class="headerlink" title="（1）Gson的解析非常简单:必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。"></a>（1）Gson的解析非常简单:必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。</h5><h5 id="（2）Gson有两个重要的方法"><a href="#（2）Gson有两个重要的方法" class="headerlink" title="（2）Gson有两个重要的方法"></a>（2）Gson有两个重要的方法</h5><p><font color="red">toJson（）</font>：序列化Java对象成JSON字符串</p>
<p><font color="red">fromJson()</font>：反序列化对象成Java对象</p>
<h4 id="2-解析Json数据"><a href="#2-解析Json数据" class="headerlink" title="2.解析Json数据"></a>2.解析Json数据</h4><h5 id="（1）准备一个Person类"><a href="#（1）准备一个Person类" class="headerlink" title="（1）准备一个Person类"></a>（1）准备一个Person类</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101538843.png" alt="image-20201219101538843"></p>
<h5 id="（2））toJson-方法用于将bean对象换为Json数据"><a href="#（2））toJson-方法用于将bean对象换为Json数据" class="headerlink" title="（2））toJson()方法用于将bean对象换为Json数据"></a>（2））toJson()方法用于将bean对象换为Json数据</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101558372.png" alt="image-20201219101558372"></p>
<h5 id="（3）fromJson-方法用于将Json数据转换为bean对象"><a href="#（3）fromJson-方法用于将Json数据转换为bean对象" class="headerlink" title="（3）fromJson()方法用于将Json数据转换为bean对象"></a>（3）fromJson()方法用于将Json数据转换为bean对象</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101620318.png" alt="image-20201219101620318"></p>
<h2 id="网络通信框架Volley"><a href="#网络通信框架Volley" class="headerlink" title="网络通信框架Volley"></a>网络通信框架Volley</h2><h3 id="一、Volley概述"><a href="#一、Volley概述" class="headerlink" title="一、Volley概述"></a>一、Volley概述</h3><h4 id="1-Volley特别适合数据量不大但通信频繁的场景"><a href="#1-Volley特别适合数据量不大但通信频繁的场景" class="headerlink" title="1.Volley特别适合数据量不大但通信频繁的场景"></a>1.Volley特别适合<font color="cornflowerblue">数据量不大但通信频繁</font>的场景</h4><h4 id="2-不使用Volley，从网上下载资源的步骤大致如下："><a href="#2-不使用Volley，从网上下载资源的步骤大致如下：" class="headerlink" title="2.不使用Volley，从网上下载资源的步骤大致如下："></a>2.不使用Volley，从网上下载资源的步骤大致如下：</h4><h5 id="（1）首先，在AsyncTask的doInBackground-中，使用HttpURLConnection从服务器获取相关资源。"><a href="#（1）首先，在AsyncTask的doInBackground-中，使用HttpURLConnection从服务器获取相关资源。" class="headerlink" title="（1）首先，在AsyncTask的doInBackground()中，使用HttpURLConnection从服务器获取相关资源。"></a>（1）首先，在AsyncTask的doInBackground()中，使用HttpURLConnection从服务器获取相关资源。</h5><h5 id="（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute-里设置到相应的控件中。"><a href="#（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute-里设置到相应的控件中。" class="headerlink" title="（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute()里设置到相应的控件中。"></a>（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute()里设置到相应的控件中。</h5><h5 id="而在Volley下，上述只需要一个函数就可以完成上述步骤"><a href="#而在Volley下，上述只需要一个函数就可以完成上述步骤" class="headerlink" title="而在Volley下，上述只需要一个函数就可以完成上述步骤"></a>而在Volley下，上述只需要一个函数就可以完成上述步骤</h5><h3 id="二、Volley的使用步骤"><a href="#二、Volley的使用步骤" class="headerlink" title="二、Volley的使用步骤"></a>二、Volley的使用步骤</h3><h4 id="1-声明RequestQueue"><a href="#1-声明RequestQueue" class="headerlink" title="1.声明RequestQueue"></a>1.声明<font color="cornflowerblue">RequestQueue</font></h4><h4 id="2-为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象"><a href="#2-为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象" class="headerlink" title="2.为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象"></a>2.为了获得请求的响应，我们需要根据响应的结果，<font color="cornflowerblue">调用不同的Request对象</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102328576.png" alt="image-20201219102328576"></p>
<h3 id="三、通过Volley获取字符串"><a href="#三、通过Volley获取字符串" class="headerlink" title="三、通过Volley获取字符串"></a>三、通过Volley获取字符串</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102423614.png" alt="image-20201219102423614"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102436859.png" alt="image-20201219102436859"></p>
<h3 id="四、通过Volley获取JSON数据"><a href="#四、通过Volley获取JSON数据" class="headerlink" title="四、通过Volley获取JSON数据"></a>四、通过Volley获取JSON数据</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102603231.png" alt="image-20201219102603231"></p>
<h3 id="五、通过Volley获取图片资源"><a href="#五、通过Volley获取图片资源" class="headerlink" title="五、通过Volley获取图片资源"></a>五、通过Volley获取图片资源</h3><h4 id="1-ImageRequest"><a href="#1-ImageRequest" class="headerlink" title="1.ImageRequest"></a>1.ImageRequest</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102644623.png" alt="image-20201219102644623"></p>
<h4 id="2-ImageLoader"><a href="#2-ImageLoader" class="headerlink" title="2.ImageLoader"></a>2.ImageLoader</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102720895.png" alt="image-20201219102720895"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102741316.png" alt="image-20201219102741316"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102801828.png" alt="image-20201219102801828"></p>
<h1 id="第十章-后台默默劳动者——服务"><a href="#第十章-后台默默劳动者——服务" class="headerlink" title="第十章 后台默默劳动者——服务"></a>第十章 后台默默劳动者——服务</h1><h2 id="Android多线程编程"><a href="#Android多线程编程" class="headerlink" title="Android多线程编程"></a>Android多线程编程</h2><h3 id="一、线程概述"><a href="#一、线程概述" class="headerlink" title="一、线程概述"></a>一、线程概述</h3><h4 id="1-Android系统中，App运行后默认创建一个线程，即主线程。"><a href="#1-Android系统中，App运行后默认创建一个线程，即主线程。" class="headerlink" title="1.Android系统中，App运行后默认创建一个线程，即主线程。"></a>1.Android系统中，App运行后默认创建一个线程，即<font color="red">主线程</font>。</h4><p>​        ——Activity、Service和BroadcastReceiver都是工作在主线程上。</p>
<h4 id="2-主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。"><a href="#2-主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。" class="headerlink" title="2.主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。"></a>2.主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做<font color="red">UI线程</font>。</h4><pre><code> 主线程中任何耗时的操作都会的降低用户界面的响应速度，甚至导致用户界面失去响应。
</code></pre>
<p>例如，发起一条网络请求时，考虑到网速等其他原因，服务器未必会立刻响应我们的请求</p>
<p>​    较好的解决方法是<font color="orange">将耗时的处理过程转移到子线程上</font>，这样可以避免负责界面更新的主线程（UI线程）无法处理界面事件，从而避免用户界面长时间失去响应。</p>
<h3 id="二、主线程和子线程"><a href="#二、主线程和子线程" class="headerlink" title="二、主线程和子线程"></a>二、主线程和子线程</h3><h4 id="1-主线程"><a href="#1-主线程" class="headerlink" title="1.主线程"></a>1.主线程</h4><ul>
<li><p>UI线程，负责处理与UI相关的事件，并把事件分发到对应的组件进行处理。</p>
</li>
<li><p>应用首次启动时，Android会启动一个Linux进程和一个主线程。</p>
</li>
<li><p>Android <font color="red">UI操作必须在UI线程中执行</font>。由于Android的UI是单线程(Single-threaded)的，当其任务繁重时，则需要其他线程来进行配合工作。</p>
</li>
</ul>
<h4 id="2-子线程"><a href="#2-子线程" class="headerlink" title="2.子线程"></a>2.子线程</h4><ul>
<li>非UI线程即为子线程，子线程一般都是<font color="red">后台线程</font>。</li>
<li>运用子线程的场合：进行数据、系统等其他非UI的操作或者把所有运行慢的、耗时的操作移出主线程，放到子线程中。</li>
<li>通常，子线程需要开发人员对其进行定义、启动、终止等操作控制。</li>
</ul>
<h3 id="三、同步与异步"><a href="#三、同步与异步" class="headerlink" title="三、同步与异步"></a>三、同步与异步</h3><h4 id="1-同步：需要等待放回结果"><a href="#1-同步：需要等待放回结果" class="headerlink" title="1.同步：需要等待放回结果"></a>1.同步：需要等待放回结果</h4><h4 id="异步：不需要等待返回结果"><a href="#异步：不需要等待返回结果" class="headerlink" title="异步：不需要等待返回结果"></a>异步：不需要等待返回结果</h4><h4 id="2-无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。"><a href="#2-无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。" class="headerlink" title="2.无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。"></a>2.无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要<font color="red">线程间通讯</font>的方法来实现在其他线程中发消息给主线程处理（更新UI）。</h4><h3 id="四、线程间通讯"><a href="#四、线程间通讯" class="headerlink" title="四、线程间通讯"></a>四、线程间通讯</h3><h4 id="1-Activity-runOnUiThread-Runnable"><a href="#1-Activity-runOnUiThread-Runnable" class="headerlink" title="1) Activity.runOnUiThread(Runnable)"></a>1) Activity.runOnUiThread(Runnable)</h4><h4 id="2-View-post-Runnable-View-postDelay-Runnable-long"><a href="#2-View-post-Runnable-View-postDelay-Runnable-long" class="headerlink" title="2) View.post(Runnable) ;View.postDelay(Runnable , long)"></a>2) View.post(Runnable) ;View.postDelay(Runnable , long)</h4><h4 id="3-Handler"><a href="#3-Handler" class="headerlink" title="3) Handler"></a>3) <font color="red">Handler</font></h4><h4 id="post-postDelay"><a href="#post-postDelay" class="headerlink" title="post, postDelay"></a><font color="red">post, postDelay</font></h4><h4 id="sendMessage-handleMessage"><a href="#sendMessage-handleMessage" class="headerlink" title="sendMessage, handleMessage"></a><font color="red">sendMessage, handleMessage</font></h4><h4 id="4-AsyncTask"><a href="#4-AsyncTask" class="headerlink" title="4) AsyncTask"></a>4) <font color="red">AsyncTask</font></h4><h4 id="5-广播"><a href="#5-广播" class="headerlink" title="5) 广播"></a>5) <font color="cornflowerblue">广播</font></h4><h3 id="五、线程的状态和生命周期"><a href="#五、线程的状态和生命周期" class="headerlink" title="五、线程的状态和生命周期"></a>五、线程的状态和生命周期</h3><ol>
<li><h4 id="创建状态"><a href="#创建状态" class="headerlink" title="创建状态"></a>创建状态</h4><p>用new运算符创建一个Thread类或子类的<font color="orange">实例对象</font>，但此时还未对这个线程分配任何资源</p>
</li>
<li><h4 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h4><p>分配系统资源，由<font color="orange">start()启动</font>方法来完成</p>
</li>
<li><h4 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h4><p>当可运行状态的线程被调度并获得CPU等资源。<font color="orange">进入run()</font>方法。</p>
</li>
<li><h4 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h4><p>由于人为或系统的原因，线程必须停止运行，以后还可以恢复运行的状态称为阻塞状态。</p>
</li>
<li><h4 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h4><p>run()方法完成或调用<font color="orange">stop()</font>或<font color="orange">destroy()</font>方法，不能继续运行。</p>
</li>
</ol>
<h3 id="六、线程的基本用法"><a href="#六、线程的基本用法" class="headerlink" title="六、线程的基本用法"></a>六、线程的基本用法</h3><h4 id="1-创建线程的方法"><a href="#1-创建线程的方法" class="headerlink" title="1. 创建线程的方法"></a>1. 创建线程的方法</h4><h5 id="（1）方法一：通过继承Thread类创建线程"><a href="#（1）方法一：通过继承Thread类创建线程" class="headerlink" title="（1）方法一：通过继承Thread类创建线程"></a>（1）方法一：通过<font color="red">继承Thread类</font>创建线程</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124132913675.png" alt="image-20201124132913675"></p>
<h5 id="（2）方法二：通过实现Runnable接口来创建线程"><a href="#（2）方法二：通过实现Runnable接口来创建线程" class="headerlink" title="（2）方法二：通过实现Runnable接口来创建线程"></a>（2）方法二：通过<font color="red">实现Runnable接口</font>来创建线程</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124133310441.png" alt="image-20201124133310441"></p>
<h5 id="（3）方法三：不实现Runnable接口，直接使用匿名类的方式"><a href="#（3）方法三：不实现Runnable接口，直接使用匿名类的方式" class="headerlink" title="（3）方法三：不实现Runnable接口，直接使用匿名类的方式"></a>（3）方法三：不实现Runnable接口，直接<font color="red">使用匿名类</font>的方式</h5><h5 id="（方式二的简化）"><a href="#（方式二的简化）" class="headerlink" title="（方式二的简化）"></a>（方式二的简化）</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124133439513.png" alt="image-20201124133439513"></p>
<h4 id="2-线程的运行与停止"><a href="#2-线程的运行与停止" class="headerlink" title="2.线程的运行与停止"></a>2.线程的运行与停止</h4><h5 id="（1）myThread-interrupt"><a href="#（1）myThread-interrupt" class="headerlink" title="（1）myThread. interrupt ();"></a>（1）myThread<font color="cornflowerblue">. interrupt ();</font></h5><p>​        线程启动后并获得资源后，即可进入运行状态，执行run()方法中的业务逻辑。<br>在run()方法返回后，线程<font color="orange">自动终止</font>。</p>
<p>或者由主线程通知子线程终止，一般<font color="orange">调用interrupt()方法</font>通告线程准备终止</p>
<h5 id="（2）Thread-interrupted"><a href="#（2）Thread-interrupted" class="headerlink" title="（2）Thread.interrupted()"></a>（2）Thread.<font color="cornflowerblue">interrupted()</font></h5><p>​        interrupt()方法改变了线程内部的一个布尔值，可在run()方法检测到这个布尔值的改变，从而<font color="orange">在适当的时候释放资源和终止</font>线程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">run</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">while</span>(!Thread.<span class="built_in">interrupted</span>())&#123;</span><br><span class="line">         ...	<span class="comment">//未调用myThread.interrupt()时循环执行</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="七、异步消息处理机制（Handler-Message）"><a href="#七、异步消息处理机制（Handler-Message）" class="headerlink" title="七、异步消息处理机制（Handler + Message）"></a>七、异步消息处理机制（Handler + Message）</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140620842.png" alt="image-20201124140620842"></p>
<h4 id="1-异步消息处理流程"><a href="#1-异步消息处理流程" class="headerlink" title="1.异步消息处理流程"></a>1.异步消息处理流程</h4><h5 id="（1）主线程：创建Handler对象，重写handleMessage方法"><a href="#（1）主线程：创建Handler对象，重写handleMessage方法" class="headerlink" title="（1）主线程：创建Handler对象，重写handleMessage方法"></a>（1）主线程：创建Handler对象，重写handleMessage方法</h5><h5 id="（2）子线程：创建Message对象，发送消息"><a href="#（2）子线程：创建Message对象，发送消息" class="headerlink" title="（2）子线程：创建Message对象，发送消息"></a>（2）子线程：创建Message对象，发送消息</h5><p>​                当子线程需要进行UI操作时，就<font color="orange">创建Message</font>对象，并通过Handler的            <font color="orange">sendMessage()方法</font>（参数是Message对象），将将这条消息发送出去。            这条待处理的消息会被 添加到主线程的<font color="orange">MessageQueue</font>中。</p>
<h5 id="（3）主线程：处理消息，回调handleMessage"><a href="#（3）主线程：处理消息，回调handleMessage" class="headerlink" title="（3）主线程：处理消息，回调handleMessage"></a>（3）主线程：处理消息，回调handleMessage</h5><p>​            主线程通过<font color="orange">Looper管理</font>MessageQueue，不断地尝试从消息队列中取出    待处理消息进行处理，取出消息时就会回调 Handler的<font color="orange">handlerMessage()</font>方法</p>
<p>​        </p>
<h4 id="2-Hander类"><a href="#2-Hander类" class="headerlink" title="2.Hander类"></a>2.<font color="cornflowerblue">Hander</font>类</h4><p>使用Hnadler类的sendMessage()方法把一个包含消息数据的Message对象压入到消息队列。其它可选方法还包括：<br>sendEmptyMessage(int)<br>sendMessage(Message)<br>sendMessageAtTime(Message,long)<br>sendMessageDelayed(Message,long)</p>
<h4 id="3-Message类"><a href="#3-Message类" class="headerlink" title="3.Message类"></a>3.<font color="cornflowerblue">Message</font>类</h4><h5 id="（1）Message对象："><a href="#（1）Message对象：" class="headerlink" title="（1）Message对象："></a>（1）Message对象：</h5><p>推荐使用<font color="red">Message.obtain()</font> 静态方法从消息池中获取一个Message对象。<br>如果消息池为空， 将使用构造方法实例化一个新Message，以利于消息资源的利用。<br>一般并不推荐直接使用它的构造方法</p>
<h5 id="（2）用来封装所发送消息的值："><a href="#（2）用来封装所发送消息的值：" class="headerlink" title="（2）用来封装所发送消息的值："></a>（2）用来封装所发送消息的值：</h5><p>int arg1：参数一，用于传递不复杂的数据，复杂数据使用setData()传递。<br>int arg2：参数二，用于传递不复杂的数据，复杂数据使用setData()传递。<br>Object obj：传递一个任意的对象。<br>int what：定义的消息码，一般用于设定消息的标志。</p>
<h5 id="3-传递复杂数据-setData"><a href="#3-传递复杂数据-setData" class="headerlink" title="(3)传递复杂数据 setData()"></a>(3)传递复杂数据 setData()</h5><p>​    –void setData( Bundle bundle)</p>
<p>​    –Bundle getData()</p>
<h4 id="2-案例实现：幸运大抽奖（方式一）"><a href="#2-案例实现：幸运大抽奖（方式一）" class="headerlink" title="2.案例实现：幸运大抽奖（方式一）"></a>2.案例实现：幸运大抽奖（方式一）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140746244.png" alt="image-20201124140746244"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140752579.png" alt="image-20201124140752579"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140759685.png" alt="image-20201124140759685"></p>
<h3 id="八、异步消息处理机制（Handler-Post）"><a href="#八、异步消息处理机制（Handler-Post）" class="headerlink" title="八、异步消息处理机制（Handler + Post）"></a>八、异步消息处理机制（Handler + Post）</h3><h4 id="1-Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。-在主线程中执行"><a href="#1-Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。-在主线程中执行" class="headerlink" title="1. Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。(在主线程中执行)"></a>1. Handler也可以把一个<font color="cornflowerblue">Runnable对象</font>压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。(<font color="red">在主线程中执行</font>)</h4><h5 id="（1）把一个Runnable对象入队到消息队列-方法有："><a href="#（1）把一个Runnable对象入队到消息队列-方法有：" class="headerlink" title="（1）把一个Runnable对象入队到消息队列,方法有："></a>（1）把一个Runnable对象入队到消息队列,方法有：</h5><ul>
<li><p><font color="red">post</font>(Runnable)</p>
</li>
<li><p>postAtTime(Runnable,long)</p>
</li>
<li><p>postDelayed(Runnable,long)</p>
</li>
</ul>
<h5 id="2-从消息队列中移除一个Runnable对象"><a href="#2-从消息队列中移除一个Runnable对象" class="headerlink" title="(2)从消息队列中移除一个Runnable对象"></a>(2)从消息队列中移除一个Runnable对象</h5><p>​            void <font color="red">removeCallbacks</font>(Runnable r)</p>
<h4 id="2-对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run-方法。一般在这个run-方法中写入需要在UI线程上的操作。"><a href="#2-对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run-方法。一般在这个run-方法中写入需要在UI线程上的操作。" class="headerlink" title="2.对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run()方法。一般在这个run()方法中写入需要在UI线程上的操作。"></a>2.对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，<font color="red">重写run()方法</font>。一般在这个run()方法中写入<font color="red">需要在UI线程上的操作</font>。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201130202655320.png" alt="image-20201130202655320"></p>
<h4 id="3-案例实现：幸运大抽奖（方式二）"><a href="#3-案例实现：幸运大抽奖（方式二）" class="headerlink" title="3. 案例实现：幸运大抽奖（方式二）"></a>3. 案例实现：幸运大抽奖（方式二）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201130203252201.png" alt="image-20201130203252201"></p>
<h2 id="服务的原理和用途"><a href="#服务的原理和用途" class="headerlink" title="服务的原理和用途"></a>服务的原理和用途</h2><h3 id="一、启动服务的两种状态"><a href="#一、启动服务的两种状态" class="headerlink" title="一、启动服务的两种状态"></a>一、启动服务的两种状态</h3><h4 id="1-启动状态：通过Context的startService-启动service"><a href="#1-启动状态：通过Context的startService-启动service" class="headerlink" title="1.启动状态：通过Context的startService()启动service"></a>1.<font color="cornflowerblue">启动状态</font>：通过Context的<font color="red">startService()</font>启动service</h4><h5 id="一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService-或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁"><a href="#一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService-或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁" class="headerlink" title="一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService()或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁"></a>一旦启动，服务即<font color="orange">可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响</font>，除非手动调用stopService()或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁</h5><h4 id="2-绑定状态：通过Context的bindService-绑定Service"><a href="#2-绑定状态：通过Context的bindService-绑定Service" class="headerlink" title="2.绑定状态：通过Context的bindService()绑定Service"></a>2.<font color="cornflowerblue">绑定状态</font>：通过Context的<font color="red">bindService()</font>绑定Service</h4><p>​        <font color="orange">绑定服务提供了一个客户端-服务器接口，允许调用方与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。</font> 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个调用方可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁</p>
<h3 id="二、在清单文件中的声明"><a href="#二、在清单文件中的声明" class="headerlink" title="二、在清单文件中的声明"></a>二、在清单文件中的声明</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201125094605395.png" alt="image-20201125094605395"></p>
<h3 id="四、使用Service"><a href="#四、使用Service" class="headerlink" title="四、使用Service"></a>四、使用Service</h3><h4 id="1-首先要创建服务，必须创建-Service-的子类（或使用它的一个现有子类如IntentService）。"><a href="#1-首先要创建服务，必须创建-Service-的子类（或使用它的一个现有子类如IntentService）。" class="headerlink" title="1.首先要创建服务，必须创建 Service 的子类（或使用它的一个现有子类如IntentService）。"></a>1.首先要创建服务，必须<font color="red">创建 Service 的子类</font>（或使用它的一个现有子类如IntentService）。</h4><h4 id="2-类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。"><a href="#2-类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。" class="headerlink" title="2.类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。"></a>2.类似Activity，Service有自己的生命周期，因此在实现中需要<font color="red">重写一些回调方法</font>，以处理服务生命周期的某些关键过程。</h4><h4 id="3-随后，组件-例如活动-以启动或者绑定方式启动服务，服务开始其生命过程"><a href="#3-随后，组件-例如活动-以启动或者绑定方式启动服务，服务开始其生命过程" class="headerlink" title="3.随后，组件(例如活动)以启动或者绑定方式启动服务，服务开始其生命过程"></a>3.随后，组件(例如活动)以<font color="red">启动或者绑定方式启动服务</font>，服务开始其生命过程</h4><h3 id="五、Service中常用回调方法"><a href="#五、Service中常用回调方法" class="headerlink" title="五、Service中常用回调方法"></a>五、Service中常用回调方法</h3><h4 id="1-abstract-IBinder-onBind-Intent-intent"><a href="#1-abstract-IBinder-onBind-Intent-intent" class="headerlink" title="1.abstract IBinder onBind(Intent intent)"></a>1.abstract IBinder <font color="cornflowerblue">onBind</font>(Intent intent)</h4><p>该方法是一个抽象方法，所有Service子类必须实现该方法。该方法将返回一个IBinder对象，应用程序可<font color="red">通过该对象与Service组件通信</font>；</p>
<h4 id="2-void-onCreate"><a href="#2-void-onCreate" class="headerlink" title="2.void onCreate()"></a>2.void <font color="cornflowerblue">onCreate()</font></h4><p>当Service<font color="red">第一次被创建时</font>，将立即回调该方法；</p>
<h4 id="3-void-onDestroy"><a href="#3-void-onDestroy" class="headerlink" title="3.void onDestroy()"></a>3.void <font color="cornflowerblue">onDestroy()</font></h4><p>当Service<font color="red">被关闭之前</font>，将回调该方法</p>
<h4 id="4-void-onStartCommand-Intent-intent-int-flags-int-startId"><a href="#4-void-onStartCommand-Intent-intent-int-flags-int-startId" class="headerlink" title="4.void onStartCommand(Intent intent,int flags,int startId)"></a>4.void <font color="cornflowerblue">onStartCommand(Intent intent,int flags,int startId)</font></h4><p>每次客户端调用startService(Intent intent)方法<font color="red">启动</font>该Service时<font color="red">都会回调</font>onStartCommand()方法</p>
<h4 id="5-boolean-onUnbind-Intent-intent"><a href="#5-boolean-onUnbind-Intent-intent" class="headerlink" title="5.boolean onUnbind(Intent intent)"></a>5.boolean <font color="cornflowerblue">onUnbind(Intent intent)</font></h4><p>当该Service上绑定的所有客户端都<font color="red">断开连接</font>时将会回调该方法。</p>
<h3 id="六、活动的生命周期"><a href="#六、活动的生命周期" class="headerlink" title="六、活动的生命周期"></a>六、活动的生命周期</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201125095321429.png" alt="image-20201125095321429"></p>
<h2 id="启动方式启动服务"><a href="#启动方式启动服务" class="headerlink" title="启动方式启动服务"></a>启动方式启动服务</h2><h3 id="一、StartService生命周期及进程相关"><a href="#一、StartService生命周期及进程相关" class="headerlink" title="一、StartService生命周期及进程相关"></a>一、StartService生命周期及进程相关</h3><h4 id="1-对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。"><a href="#1-对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。" class="headerlink" title="1.对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。"></a>1.对于同一类型的Service，<font color="red">Service实例永远只存在一个</font>，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。</h4><h4 id="2-以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService-或服务本身调用stopSelf-才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service"><a href="#2-以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService-或服务本身调用stopSelf-才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service" class="headerlink" title="2.以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService(..)或服务本身调用stopSelf(..)才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service"></a>2.以启动方式运行的服务，其<font color="red">生命周期是独立的，与Client本身的生命周期没有任何关系</font>，只有Client调用stopService(..)或服务本身调用stopSelf(..)才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service</h4><h4 id="3-Client-A-通过startService-启动Service后-可以在其他Client（如Client-B、Client-C）通过调用stopService-结束此Service"><a href="#3-Client-A-通过startService-启动Service后-可以在其他Client（如Client-B、Client-C）通过调用stopService-结束此Service" class="headerlink" title="3.Client A 通过startService(..)启动Service后,可以在其他Client（如Client B、Client C）通过调用stopService(..)结束此Service"></a>3.Client A 通过<font color="red">startService(..)</font>启动Service后,可以在其他Client（如Client B、Client C）通过调用<font color="red">stopService(..)结束</font>此Service</h4><h4 id="4-Client调用stopService-时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService-无需做当前Service是否有效的判断。"><a href="#4-Client调用stopService-时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService-无需做当前Service是否有效的判断。" class="headerlink" title="4.Client调用stopService(..)时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService(..)无需做当前Service是否有效的判断。"></a>4.Client调用stopService(..)时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService(..)<font color="red">无需做当前Service是否有效的判断。</font></h4><h4 id="5-startService-Intent-serviceIntent-，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。"><a href="#5-startService-Intent-serviceIntent-，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。" class="headerlink" title="5.startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。"></a>5.startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用<font color="red">显示Intent</font>。当处于不同App时，只能使用隐式Intent。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111515792.png" alt="image-20201214111515792"></p>
<h3 id="二、Client与Service通信相关"><a href="#二、Client与Service通信相关" class="headerlink" title="二、Client与Service通信相关"></a>二、Client与Service通信相关</h3><h4 id="1-启动Service时"><a href="#1-启动Service时" class="headerlink" title="1.启动Service时"></a>1.启动Service时</h4><h5 id="当Client调用startService-Intent-serviceIntent-启动Service时，Client可以将参数通过Intent直接传递给Service。"><a href="#当Client调用startService-Intent-serviceIntent-启动Service时，Client可以将参数通过Intent直接传递给Service。" class="headerlink" title="当Client调用startService(Intent serviceIntent)启动Service时，Client可以将参数通过Intent直接传递给Service。"></a>当Client调用startService(Intent serviceIntent)<font color="red">启动Service</font>时，Client可以<font color="red">将参数通过Intent直接传递</font>给Service。</h5><h4 id="2-Service执行过程中"><a href="#2-Service执行过程中" class="headerlink" title="2.Service执行过程中"></a>2.Service执行过程中</h4><h5 id="Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。"><a href="#Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。" class="headerlink" title="Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。"></a><font color="red">Service执行过程</font>中，如果需要将参数传递给Client，一般可以通过<font color="red">借助于发送广播</font>的方式（此时，Client需要注册此广播）。</h5><h2 id="绑定方式启动服务"><a href="#绑定方式启动服务" class="headerlink" title="绑定方式启动服务"></a>绑定方式启动服务</h2><h3 id="一、三个基本特征"><a href="#一、三个基本特征" class="headerlink" title="一、三个基本特征"></a>一、三个基本特征</h3><h4 id="1-C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器"><a href="#1-C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器" class="headerlink" title="1.C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器"></a>1.<font color="cornflowerblue">C-S模式</font>：绑定状态的服务代表着客户端-服务器接口中的<font color="orange">服务器</font></h4><h4 id="2-交互与通信：当其他组件（如-Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信-。"><a href="#2-交互与通信：当其他组件（如-Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信-。" class="headerlink" title="2.交互与通信：当其他组件（如 Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信 。"></a>2.<font color="cornflowerblue">交互与通信</font>：当其他组件（如 Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，<font color="orange">或者调用Service（服务端）的方法</font>，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信 。</h4><h4 id="3-生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件-如Activity-服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主-如Activity-解除绑定后，绑定服务就会被销毁。"><a href="#3-生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件-如Activity-服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主-如Activity-解除绑定后，绑定服务就会被销毁。" class="headerlink" title="3.生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主(如Activity)解除绑定后，绑定服务就会被销毁。"></a>3.<font color="cornflowerblue">生命周期</font>：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说所有<font color="orange">宿主(如Activity)解除绑定后，绑定服务就会被销毁</font>。</h4><h3 id="二、BindService生命周期"><a href="#二、BindService生命周期" class="headerlink" title="二、BindService生命周期"></a>二、BindService生命周期</h3><h4 id="1-onBind方法只被调用一次。（当调用bindService-方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind-方法。"><a href="#1-onBind方法只被调用一次。（当调用bindService-方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind-方法。" class="headerlink" title="1.onBind方法只被调用一次。（当调用bindService()方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind()方法。"></a>1.onBind方法只被调用一次。（当调用<font color="orange">bindService()</font>方法是）Service第一次被创建时会执行<font color="red">onCreate</font>方法，之后自动调用<font color="red">onBind()</font>方法。</h4><h4 id="2-当调用unBindService-方法时，Service会依次执行onUnbind-、onDestroy-方法结束生命周期"><a href="#2-当调用unBindService-方法时，Service会依次执行onUnbind-、onDestroy-方法结束生命周期" class="headerlink" title="2.当调用unBindService()方法时，Service会依次执行onUnbind()、onDestroy()方法结束生命周期"></a>2.当调用<font color="orange">unBindService()</font>方法时，Service会依次执行<font color="red">onUnbind()</font>、<font color="red">onDestroy()</font>方法结束生命周期</h4><h4 id="3-如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService-解除绑定。"><a href="#3-如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService-解除绑定。" class="headerlink" title="3.如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService()解除绑定。"></a>3.如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService()解除绑定。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/577f98926daf5.jpg" alt="img"></p>
<h3 id="三、一般流程！！！"><a href="#三、一般流程！！！" class="headerlink" title="三、一般流程！！！"></a>三、一般流程！！！</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111833380.png" alt="image-20201214111833380"></p>
<h4 id="1-服务端，Service中"><a href="#1-服务端，Service中" class="headerlink" title="1.服务端，Service中"></a>1.服务端，Service中</h4><h5 id="（1）创建Binder子类，返回服务实例对象"><a href="#（1）创建Binder子类，返回服务实例对象" class="headerlink" title="（1）创建Binder子类，返回服务实例对象"></a>（1）<font color="cornflowerblue">创建Binder子类，返回服务实例对象</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110207275.png" alt="image-20201214110207275"></p>
<h5 id="（2）在onBind-中返回Mybinder的实例对象iBinder"><a href="#（2）在onBind-中返回Mybinder的实例对象iBinder" class="headerlink" title="（2）在onBind()中返回Mybinder的实例对象iBinder"></a>（2）<font color="cornflowerblue">在onBind()中返回Mybinder的实例对象iBinder</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110333487.png" alt="image-20201214110333487"></p>
<h4 id="2-客户端，Activity中"><a href="#2-客户端，Activity中" class="headerlink" title="2.客户端，Activity中"></a>2.客户端，Activity中</h4><h5 id="（1）创建ServiceConnection实例，在onServiceConnected-中接收返回的Binder-实例，通过Binder实例的getService-方法获取服务实例myService"><a href="#（1）创建ServiceConnection实例，在onServiceConnected-中接收返回的Binder-实例，通过Binder实例的getService-方法获取服务实例myService" class="headerlink" title="（1）创建ServiceConnection实例，在onServiceConnected 中接收返回的Binder 实例，通过Binder实例的getService()方法获取服务实例myService"></a>（1）<font color="cornflowerblue">创建ServiceConnection实例，在onServiceConnected 中接收返回的Binder 实例，通过Binder实例的getService()方法获取服务实例myService</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110911643.png" alt="image-20201214110911643"></p>
<h5 id="2-绑定之后可以通过myService方法调用服务中的方法"><a href="#2-绑定之后可以通过myService方法调用服务中的方法" class="headerlink" title="(2)绑定之后可以通过myService方法调用服务中的方法"></a>(2)<font color="cornflowerblue">绑定之后可以通过myService方法调用服务中的方法</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111553877.png" alt="image-20201214111553877"></p>
<h5 id="（3）解除绑定"><a href="#（3）解除绑定" class="headerlink" title="（3）解除绑定"></a>（3）<font color="cornflowerblue">解除绑定</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111631223.png" alt="image-20201214111631223"></p>
<p><font color="red">注：也可以将服务中的方法写在内部类mybinder中，在活动的ServiceConnect实例的onServiceConnected()中获取myBinder实例，通过这个实例调用服务中的方法。（不推荐）</font></p>
<h2 id="混合使用启动方式和绑定方式"><a href="#混合使用启动方式和绑定方式" class="headerlink" title="混合使用启动方式和绑定方式"></a>混合使用启动方式和绑定方式</h2><h3 id="一、混合开启服务"><a href="#一、混合开启服务" class="headerlink" title="一、混合开启服务"></a>一、混合开启服务</h3><p>既然<font color="red">start开启的服务不能调用方法，bind方式开启的服务生命力又很弱</font>，那么能否两种方式的有点么？答案当然是肯定的，否则服务的应用能力就太弱了。</p>
<ol>
<li><h4 id="通过startService-方式开启服务-只能通过调用stopService停止"><a href="#通过startService-方式开启服务-只能通过调用stopService停止" class="headerlink" title="通过startService()方式开启服务(只能通过调用stopService停止)"></a>通过startService()方式开启服务(只能通过调用stopService停止)</h4></li>
<li><h4 id="通过bindService进行绑定，以进行服务的方法调用-当需要的时候"><a href="#通过bindService进行绑定，以进行服务的方法调用-当需要的时候" class="headerlink" title="通过bindService进行绑定，以进行服务的方法调用(当需要的时候)"></a>通过bindService进行绑定，以进行服务的方法调用(当需要的时候)</h4></li>
<li><h4 id="通过unbindService进行解绑-不需要调用方法了，在UI线程被销毁之前解绑"><a href="#通过unbindService进行解绑-不需要调用方法了，在UI线程被销毁之前解绑" class="headerlink" title="通过unbindService进行解绑(不需要调用方法了，在UI线程被销毁之前解绑)"></a>通过unbindService进行解绑(不需要调用方法了，在UI线程被销毁之前解绑)</h4></li>
<li><h4 id="通过stopService停止服务"><a href="#通过stopService停止服务" class="headerlink" title="通过stopService停止服务"></a>通过stopService停止服务</h4></li>
</ol>
<p>这样我们就可以灵活的使用Service，<font color="red">当需要的时候可以随时进行调用，不要的时候又可以长期运行于后台而不用保留UI线程</font>。这也是服务最常见的用法。</p>
<h3 id="二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。"><a href="#二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。" class="headerlink" title="二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。"></a>二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。</h3><h3 id="三、如果想停止服务，必须调用stopService，并且所有调用-bindService-的-Context调用unbindService解绑-或者之前调用-bindService-的-Context-不存在了。"><a href="#三、如果想停止服务，必须调用stopService，并且所有调用-bindService-的-Context调用unbindService解绑-或者之前调用-bindService-的-Context-不存在了。" class="headerlink" title="三、如果想停止服务，必须调用stopService，并且所有调用 bindService 的 Context调用unbindService解绑,或者之前调用 bindService 的 Context 不存在了。"></a>三、如果想停止服务，必须<font color="cornflowerblue">调用stopService</font>，并且所有调用 bindService 的 Context调用<font color="cornflowerblue">unbindService</font><font color="orange">解绑</font>,或者之前调用 bindService 的 Context<font color="orange"> 不存在</font>了。</h3><h2 id="服务的更多使用技巧"><a href="#服务的更多使用技巧" class="headerlink" title="服务的更多使用技巧"></a>服务的更多使用技巧</h2><h3 id="一、使用前台服务"><a href="#一、使用前台服务" class="headerlink" title="一、使用前台服务"></a>一、使用前台服务</h3><h4 id="1-服务运行在后台，优先级低，系统内存不足时，可能会被回收。"><a href="#1-服务运行在后台，优先级低，系统内存不足时，可能会被回收。" class="headerlink" title="1.服务运行在后台，优先级低，系统内存不足时，可能会被回收。"></a>1.服务运行在后台，优先级低，系统内存不足时，<font color="red">可能会被回收</font>。</h4><p>如果希望服务<font color="red">可以一直保持运行状态</font>，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台服务。</p>
<h4 id="2-与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。"><a href="#2-与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。" class="headerlink" title="2.与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。"></a>2.<font color="cornflowerblue">与普通服务相比</font>：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。</h4><h4 id="3-startForeground-和stopForeground-方法"><a href="#3-startForeground-和stopForeground-方法" class="headerlink" title="3.startForeground()和stopForeground()方法"></a>3.<font color="cornflowerblue">startForeground()</font>和<font color="cornflowerblue">stopForeground()</font>方法</h4><p>startForeground(1,notification);</p>
<h3 id="二、使用IntentService"><a href="#二、使用IntentService" class="headerlink" title="二、使用IntentService"></a>二、使用IntentService</h3><p>（未完待续……）</p>
]]></content>
      <categories>
        <category>《 Android基础》</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>《Android小菜》</title>
    <url>/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/</url>
    <content><![CDATA[<div class="note success modern"><p><strong>前言：</strong>目录结构还有待优化，可直接ctrl+F搜索有无需要了解的内容<br>本笔记属于个人初学android过程时总结，如有错误或者图片缺失，还请留言指正，十分感谢！<br>仅供学习参考，如需转载请注明来自[Durango]: <a href="http://www.durango.cn/">www.durango.cn</a></p>
</div>



<h1 id="第一章-控件与布局"><a href="#第一章-控件与布局" class="headerlink" title="第一章 控件与布局"></a>第一章 控件与布局</h1><h2 id="一、界面的美化-Shape和Selector例举"><a href="#一、界面的美化-Shape和Selector例举" class="headerlink" title="一、界面的美化(Shape和Selector例举)"></a>一、界面的美化(Shape和Selector例举)</h2><h3 id="1-背景颜色的渐变"><a href="#1-背景颜色的渐变" class="headerlink" title="1.背景颜色的渐变"></a>1.背景颜色的<font color="cornflowerblue">渐变</font></h3><h4 id="res-rawable-background-login-xml-整个布局的背景，渐变背景"><a href="#res-rawable-background-login-xml-整个布局的背景，渐变背景" class="headerlink" title="res/ rawable/ background_login.xml, 整个布局的背景，渐变背景"></a>res/ rawable/ background_login.xml, 整个布局的背景，渐变背景</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line"> &lt;gradient</span><br><span class="line"> android:angle=&quot;90&quot;</span><br><span class="line"> android:endColor=&quot;#FF72CAE1&quot;</span><br><span class="line"> android:startColor=&quot;#FFACDAE5&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-单色填充带圆角-按钮、局部的布局"><a href="#2-单色填充带圆角-按钮、局部的布局" class="headerlink" title="2.单色填充带圆角(按钮、局部的布局)"></a>2.单色填充带<font color="cornflowerblue">圆角</font>(按钮、局部的布局)</h3><h4 id="res-rawable-background-login-div-xml-登录框部分的背景，单色填充，带圆角"><a href="#res-rawable-background-login-div-xml-登录框部分的背景，单色填充，带圆角" class="headerlink" title="res/ rawable/background_login_div.xml, 登录框部分的背景，单色填充，带圆角"></a><strong>res/ rawable/background_login_div.xml,</strong> 登录框部分的背景，单色填充，带圆角</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line"> &lt;solid android:color=&quot;#55FFFFFF&quot; /&gt;</span><br><span class="line"> &lt;corners</span><br><span class="line"> android:bottomLeftRadius=&quot;10dp&quot;</span><br><span class="line"> android:bottomRightRadius=&quot;10dp&quot;</span><br><span class="line"> android:topLeftRadius=&quot;10dp&quot;</span><br><span class="line"> android:topRightRadius=&quot;10dp&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>



<h3 id="3-文本框不同状态的背景设置"><a href="#3-文本框不同状态的背景设置" class="headerlink" title="3.文本框不同状态的背景设置"></a>3.文本框<font color="cornflowerblue">不同状态的背景</font>设置</h3><h4 id="res-drawable-edit-login-xml-两个编辑输入框的背景，edit-login-是一个-selector，针对正在输入和其它状态设-置不同的背景图片，login-input-和-input-over-是-res-drawable-目录下的两张-png-图片-Educoder-平台已经共享-，名-字分别是-input-over-9-png-和-input-input-9-png"><a href="#res-drawable-edit-login-xml-两个编辑输入框的背景，edit-login-是一个-selector，针对正在输入和其它状态设-置不同的背景图片，login-input-和-input-over-是-res-drawable-目录下的两张-png-图片-Educoder-平台已经共享-，名-字分别是-input-over-9-png-和-input-input-9-png" class="headerlink" title="res/drawable/edit_login.xml**, 两个编辑输入框的背景，edit_login 是一个 selector，针对正在输入和其它状态设 置不同的背景图片，login_input 和 input_over 是 res/drawable 目录下的两张 png 图片(Educoder 平台已经共享)，名 字分别是 input_over.9.png 和 input_input.9.png"></a>res/drawable/edit_login.xml**, 两个编辑输入框的背景，edit_login 是一个 selector，针对正在输入和其它状态设 置不同的背景图片，login_input 和 input_over 是 res/drawable 目录下的两张 png 图片(Educoder 平台已经共享)，名 字分别是 input_over.9.png 和 input_input.9.png</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;item </span><br><span class="line">	 android:state_enabled=&quot;false&quot;</span><br><span class="line"> 	android:drawable=&quot;@drawable/login_input&quot;/&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:state_focused=&quot;true&quot;</span><br><span class="line"> 	android:drawable=&quot;@drawable/input_over&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>



<h3 id="4-按钮不同状态的文字颜色"><a href="#4-按钮不同状态的文字颜色" class="headerlink" title="4.按钮不同状态的文字颜色"></a>4.按钮<font color="cornflowerblue">不同状态的文字颜色</font></h3><h4 id="res-drawable-text-btn-selector-xml-两个按钮的-textColor-属性，这是按钮的文本颜色，这是一个-selector，使得按钮在不同状态下的文字颜色显示不同。"><a href="#res-drawable-text-btn-selector-xml-两个按钮的-textColor-属性，这是按钮的文本颜色，这是一个-selector，使得按钮在不同状态下的文字颜色显示不同。" class="headerlink" title="res/drawable/text_btn_selector.xml, 两个按钮的 textColor 属性，这是按钮的文本颜色，这是一个 selector，使得按钮在不同状态下的文字颜色显示不同。"></a><strong>res/drawable/text_btn_selector.xml</strong>, 两个按钮的 textColor 属性，这是按钮的文本颜色，这是一个 selector，使得按钮在不同状态下的文字颜色显示不同。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"> 		&lt;!-- 当前窗口失去焦点时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/black&quot; </span><br><span class="line"> 	android:state_window_focused=&quot;false&quot; /&gt;</span><br><span class="line">		 &lt;!-- 不可用时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/background_light&quot; 				  			android:state_enabled=&quot;false&quot; /&gt;</span><br><span class="line"> 		 &lt;!-- 按压时 --&gt;</span><br><span class="line"> &lt;item android:color=&quot;@android:color/holo_blue_light&quot;  		           		    	   android:state_pressed=&quot;true&quot; /&gt;</span><br><span class="line"> 		&lt;!-- 被选中时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/holo_green_dark&quot;</span><br><span class="line"> 	android:state_selected=&quot;true&quot; /&gt;</span><br><span class="line"> 		&lt;!-- 被激活时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/holo_green_light&quot; 	</span><br><span class="line"> 	android:state_activated=&quot;true&quot; /&gt;</span><br><span class="line">		&lt;!-- 默认时 --&gt;</span><br><span class="line"> &lt;item android:color=&quot;@android:color/white&quot; /&gt;</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>



<h2 id="二、Shape"><a href="#二、Shape" class="headerlink" title="二、Shape"></a>二、Shape</h2><h3 id="1-Shape可以画四种图形"><a href="#1-Shape可以画四种图形" class="headerlink" title="1.Shape可以画四种图形"></a>1.Shape可以画四种图形</h3><h4 id="矩形（rectangle）、椭圆（oval）、线（line）、圆环（ring）。"><a href="#矩形（rectangle）、椭圆（oval）、线（line）、圆环（ring）。" class="headerlink" title="矩形（rectangle）、椭圆（oval）、线（line）、圆环（ring）。"></a>矩形（<font color="red">rectangle</font>）、椭圆（<font color="red">oval</font>）、线（<font color="red">line</font>）、圆环（<font color="red">ring</font>）。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shape xmIns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">	android:shape=&quot;rectangle&quot;&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-五种效果（利用-xml-文件描述，作为一种资源，放于drawable目-录。）"><a href="#2-五种效果（利用-xml-文件描述，作为一种资源，放于drawable目-录。）" class="headerlink" title="2.五种效果（利用 xml 文件描述，作为一种资源，放于drawable目                        录。）"></a>2.五种效果（利用 xml 文件描述，作为一种<font color="orange">资源</font>，放于drawable目                        录。）</h3><h4 id="（1）solid：填充"><a href="#（1）solid：填充" class="headerlink" title="（1）solid：填充"></a>（1）<font color="red">solid</font>：填充</h4><pre><code>                        android:color指定填充的颜色；
</code></pre>
<h4 id="（2）-gradient：渐变"><a href="#（2）-gradient：渐变" class="headerlink" title="（2） gradient：渐变"></a>（2） <font color="red">gradient</font>：渐变</h4><ul>
<li><h4 id="android-startColor和android-endColor-分别为起始和结束颜色"><a href="#android-startColor和android-endColor-分别为起始和结束颜色" class="headerlink" title="android:startColor和android:endColor 分别为起始和结束颜色"></a>android:startColor和android:endColor 分别为起始和结束颜色</h4></li>
<li><h4 id="android-angle-是渐变角度，必须为45的整数倍。"><a href="#android-angle-是渐变角度，必须为45的整数倍。" class="headerlink" title="android:angle 是渐变角度，必须为45的整数倍。"></a>android:angle 是渐变角度，必须为45的整数倍。</h4></li>
<li><h4 id="android-type-”linear”，线性渐变-默认"><a href="#android-type-”linear”，线性渐变-默认" class="headerlink" title="android:type=”linear”，线性渐变(默认)"></a>android:type=”linear”，线性渐变(默认)</h4></li>
<li><h4 id="android-type-”radial”，径向渐变"><a href="#android-type-”radial”，径向渐变" class="headerlink" title="android:type=”radial”，径向渐变"></a>android:type=”radial”，径向渐变</h4></li>
<li><h4 id="android-gradientRadius-”50”，径向渐变需要指定半径"><a href="#android-gradientRadius-”50”，径向渐变需要指定半径" class="headerlink" title="android:gradientRadius=”50”，径向渐变需要指定半径"></a>android:gradientRadius=”50”，径向渐变需要指定半径</h4></li>
</ul>
<h4 id="（3）-stroke：描边"><a href="#（3）-stroke：描边" class="headerlink" title="（3） stroke：描边"></a>（3）<font color="red"> stroke</font>：描边</h4><ul>
<li><h4 id="android-width-”2dp”-描边的宽度"><a href="#android-width-”2dp”-描边的宽度" class="headerlink" title="android:width=”2dp”  描边的宽度"></a>android:width=”2dp”  描边的宽度</h4></li>
<li><h4 id="android-color-描边的颜色"><a href="#android-color-描边的颜色" class="headerlink" title="android:color  描边的颜色"></a>android:color  描边的颜色</h4></li>
<li><h4 id="还可以把描边为虚线的形式，设置方式为："><a href="#还可以把描边为虚线的形式，设置方式为：" class="headerlink" title="还可以把描边为虚线的形式，设置方式为："></a>还可以把描边为<font color="orange">虚线</font>的形式，设置方式为：</h4><p>android:dashWidth=”5dp”<br>android:dashGap=”3dp”</p>
</li>
</ul>
<h4 id="（4）corners：圆角"><a href="#（4）corners：圆角" class="headerlink" title="（4）corners：圆角"></a>（4）<font color="red">corners</font>：圆角</h4><ul>
<li><h4 id="android-Radius-”20dp”-设置四个角的半径"><a href="#android-Radius-”20dp”-设置四个角的半径" class="headerlink" title="android:Radius=”20dp”               设置四个角的半径"></a>android:Radius=”20dp”               设置四个角的半径</h4></li>
<li><h4 id="android-topLeftRadius-”20dp”-设置左上角的半径"><a href="#android-topLeftRadius-”20dp”-设置左上角的半径" class="headerlink" title="android:topLeftRadius=”20dp”         设置左上角的半径"></a>android:topLeftRadius=”20dp”         设置左上角的半径</h4></li>
<li><h4 id="android-topRightRadius-”20dp”-设置右上角的半径"><a href="#android-topRightRadius-”20dp”-设置右上角的半径" class="headerlink" title="android:topRightRadius=”20dp”        设置右上角的半径"></a>android:topRightRadius=”20dp”        设置右上角的半径</h4></li>
<li><h4 id="android-bottomLeftRadius-”20dp”-设置右下角的半径"><a href="#android-bottomLeftRadius-”20dp”-设置右下角的半径" class="headerlink" title="android:bottomLeftRadius=”20dp”      设置右下角的半径"></a>android:bottomLeftRadius=”20dp”      设置右下角的半径</h4></li>
<li><h4 id="android-bottomRightRadius-”20dp”-设置左下角的半径"><a href="#android-bottomRightRadius-”20dp”-设置左下角的半径" class="headerlink" title="android:bottomRightRadius=”20dp”     设置左下角的半径"></a>android:bottomRightRadius=”20dp”     设置左下角的半径</h4></li>
</ul>
<h4 id="（5）padding：间隔"><a href="#（5）padding：间隔" class="headerlink" title="（5）padding：间隔"></a>（5）<font color="red">padding</font>：间隔</h4><h5 id="可以设置上下左右四个方向的间隔。"><a href="#可以设置上下左右四个方向的间隔。" class="headerlink" title="可以设置上下左右四个方向的间隔。"></a>可以设置上下左右四个方向的间隔。</h5><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200922232849670.png" alt="image-20200922232849670"></p>
<h2 id="三、Selector"><a href="#三、Selector" class="headerlink" title="三、Selector"></a>三、Selector</h2><h3 id="1-以Button为例，关键状态属性如下："><a href="#1-以Button为例，关键状态属性如下：" class="headerlink" title="1.以Button为例，关键状态属性如下："></a>1.以Button为例，关键状态属性如下：</h3><table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>android:<strong>state_selected</strong></td>
<td>设置是否选中状态，true表示已选中，false表示未选中</td>
</tr>
<tr>
<td>android:<strong>state_focused</strong></td>
<td>设置是否获得焦点状态，true表示获得焦点，默认为false，表示未获得焦点</td>
</tr>
<tr>
<td>android:<strong>state_pressed</strong></td>
<td>设置是否按压状态，一般在true时设置该属性，表示已按压状态，默认为false</td>
</tr>
<tr>
<td>android:<strong>state_enabled</strong></td>
<td>设置是否响应事件,指所有事件；一般只在false时设置该属性，表示不可用状态</td>
</tr>
<tr>
<td>android:<strong>state_activated</strong>:</td>
<td>设置是否被激活状态，true表示被激活，false表示未激活，API Level 11及以上才支持，可通过代码调用控件的setActivated(boolean)方法设置是否激活该控件</td>
</tr>
</tbody></table>
<h3 id="2-示例：text-btn-selector-xml的代码，用于按钮的文本颜色t"><a href="#2-示例：text-btn-selector-xml的代码，用于按钮的文本颜色t" class="headerlink" title="2.示例：text_btn_selector.xml的代码，用于按钮的文本颜色t"></a>2.示例：text_btn_selector.xml的代码，用于按钮的文本颜色t</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- 不可用时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/background_light&quot;</span><br><span class="line">    	android:state_enabled=&quot;false&quot; /&gt;</span><br><span class="line">    &lt;!-- 按压时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/holo_blue_light&quot; </span><br><span class="line">    	android:state_pressed=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;!-- 被选中时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/holo_green_dark&quot;</span><br><span class="line">    	android:state_selected=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;!-- 被激活时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/holo_green_light&quot;</span><br><span class="line">    	android:state_activated=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;!-- 默认时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/white&quot; /&gt;</span><br><span class="line">&lt;/selector&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="在控件中引用-android-background-”-drawable-bg-btn-selector”"><a href="#在控件中引用-android-background-”-drawable-bg-btn-selector”" class="headerlink" title="在控件中引用 android:background=”@drawable/bg_btn_selector”"></a>在控件中引用 <font color="red">android:background=”@drawable/bg_btn_selector”</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Button </span><br><span class="line">    android:id=&quot;@+id/btn_default&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_margin=&quot;8dp&quot;</span><br><span class="line">    android:background=&lt;Button </span><br><span class="line">    android:id=&quot;@+id/btn_default&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_margin=&quot;8dp&quot;</span><br><span class="line">    android:background=&quot;@drawable/bg_btn_selector&quot;</span><br><span class="line">    android:text=&quot;默认按钮&quot;</span><br><span class="line">    android:textColor=&quot;@color/text_btn_selector&quot; /&gt;</span><br><span class="line">&quot;</span><br><span class="line">    android:text=&quot;默认按钮&quot;</span><br><span class="line">    android:textColor=&quot;@color/text_btn_selector&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923134625276.png" alt="image-20200923134625276" style="zoom: 80%;">



<h2 id="四、登录布局和背景优化"><a href="#四、登录布局和背景优化" class="headerlink" title="四、登录布局和背景优化"></a>四、登录布局和背景优化</h2><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135110680.png" alt="image-20200923135110680"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135119943.png" alt="image-20200923135119943"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135127485.png" alt="image-20200923135127485"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135145022.png" alt="image-20200923135145022"></p>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135612629.png" alt="image-20200923135612629" style="zoom:50%;">





<h2 id="五、View概念"><a href="#五、View概念" class="headerlink" title="五、View概念"></a>五、View概念</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul>
<li><h4 id="多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。"><a href="#多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。" class="headerlink" title="多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。"></a>多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。</h4></li>
<li><h4 id="Android应用的界面都是由View和ViewGroup对象构建的，"><a href="#Android应用的界面都是由View和ViewGroup对象构建的，" class="headerlink" title="Android应用的界面都是由View和ViewGroup对象构建的，"></a>Android应用的界面都是由View和ViewGroup对象构建的，</h4></li>
<li><h4 id="ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。"><a href="#ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。" class="headerlink" title="ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。"></a>ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。</h4></li>
</ul>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923140230137.png" alt="image-20200923140230137" style="zoom: 67%;">



<h3 id="2-View类的常用属性与方法"><a href="#2-View类的常用属性与方法" class="headerlink" title="2.View类的常用属性与方法"></a>2.View类的常用属性与方法</h3><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923140315637.png" alt="image-20200923140315637"></p>
<h3 id="3-用户界面组件包widget"><a href="#3-用户界面组件包widget" class="headerlink" title="3.用户界面组件包widget"></a>3.用户界面组件包widget</h3><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923140439546.png" alt="image-20200923140439546" style="zoom:80%;">





<h1 id="第二章-Android-列表"><a href="#第二章-Android-列表" class="headerlink" title="第二章 Android 列表"></a>第二章 Android 列表</h1><h2 id="一、AdapterView及其子类"><a href="#一、AdapterView及其子类" class="headerlink" title="一、AdapterView及其子类"></a>一、AdapterView及其子类</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002124214084.png" alt="image-20201002124214084" style="zoom: 50%;"></h3><h3 id="2-AdapterView子类"><a href="#2-AdapterView子类" class="headerlink" title="2.AdapterView子类"></a>2.AdapterView子类</h3><ul>
<li><h4 id="ListView：列表，通常含有一个TextView控件。"><a href="#ListView：列表，通常含有一个TextView控件。" class="headerlink" title="ListView：列表，通常含有一个TextView控件。"></a>ListView：列表，通常含有一个TextView控件。</h4></li>
<li><h4 id="Spinner：下拉列表，给用户提供选择。"><a href="#Spinner：下拉列表，给用户提供选择。" class="headerlink" title="Spinner：下拉列表，给用户提供选择。"></a>Spinner：下拉列表，给用户提供选择。</h4></li>
<li><h4 id="Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。"><a href="#Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。" class="headerlink" title="Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。"></a>Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。</h4></li>
<li><h4 id="GridView：网格图，以表格形式显示资源，可以左右滑动的。"><a href="#GridView：网格图，以表格形式显示资源，可以左右滑动的。" class="headerlink" title="GridView：网格图，以表格形式显示资源，可以左右滑动的。"></a>GridView：网格图，以表格形式显示资源，可以左右滑动的。</h4></li>
</ul>
<h2 id="二、ListView"><a href="#二、ListView" class="headerlink" title="二、ListView"></a>二、ListView</h2><h3 id="1-XML属性"><a href="#1-XML属性" class="headerlink" title="1.XML属性"></a>1.XML属性</h3><table>
<thead>
<tr>
<th><strong>XML****属性</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>android:divider</strong></td>
<td>设置分割条样式（颜色或者Drawable对象）</td>
</tr>
<tr>
<td><strong>android:dividerHeight</strong></td>
<td>设置分割条高度</td>
</tr>
<tr>
<td><font color="red">android:entries（数据源）</font></td>
<td>指定一个数组资源，用来填充ListView项</td>
</tr>
<tr>
<td><strong>android:footerDividersEnabled</strong></td>
<td>设置为false，则不在footer view之前绘制分割条</td>
</tr>
<tr>
<td><strong>android:headerDividersEnabled</strong></td>
<td>设置为false，则不在header view之后绘制分割条</td>
</tr>
<tr>
<td><strong>android:scrollbars</strong></td>
<td>设置是否显示滚动条</td>
</tr>
<tr>
<td><strong>android:fadingEdge</strong></td>
<td>设置是否去除ListView滑到顶部和底部时边缘的黑色阴影</td>
</tr>
<tr>
<td><strong>android:listSelector</strong></td>
<td>设置是否去除点击颜色</td>
</tr>
<tr>
<td><strong>android:cacheColorHint</strong></td>
<td>设置ListView去除滑动颜色</td>
</tr>
</tbody></table>
<h3 id="2-最简单的用法"><a href="#2-最简单的用法" class="headerlink" title="2.最简单的用法"></a>2.最简单的用法</h3><h4 id="布局文件中添加LsitView组件，然后在values-strings-xml文件中填加string-array的数组元素。然后通过android-entries调用加载数组资源，填充ListView项。"><a href="#布局文件中添加LsitView组件，然后在values-strings-xml文件中填加string-array的数组元素。然后通过android-entries调用加载数组资源，填充ListView项。" class="headerlink" title="布局文件中添加LsitView组件，然后在values/ strings.xml文件中填加string-array的数组元素。然后通过android:entries调用加载数组资源，填充ListView项。"></a>布局文件中添加LsitView组件，然后在values/ strings.xml文件中填加<font color="red">string-array</font>的数组元素。然后通过<font color="red">android:entries</font>调用加载数组资源，填充ListView项。</h4><h3 id="3-M-V-C原理"><a href="#3-M-V-C原理" class="headerlink" title="3.M-V-C原理"></a>3.M-V-C原理</h3><h4 id="（1）数据模型M-Model）存放数据-来自数组、列表、数据库-，利用控制器C（Controller）将数据显示在视图V（View）上。"><a href="#（1）数据模型M-Model）存放数据-来自数组、列表、数据库-，利用控制器C（Controller）将数据显示在视图V（View）上。" class="headerlink" title="（1）数据模型M(Model）存放数据(来自数组、列表、数据库)，利用控制器C（Controller）将数据显示在视图V（View）上。"></a>（1）数据模型M(Model）存放数据(来自数组、列表、数据库)，利用控制器C（Controller）将数据显示在视图V（View）上。</h4><h4 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点:"></a>（2）特点:</h4><ul>
<li><h4 id="将前端显示和后端数据分离"><a href="#将前端显示和后端数据分离" class="headerlink" title="将前端显示和后端数据分离"></a>将前端显示和后端数据分离</h4></li>
<li><h4 id="内容不能通过-ListView-add的形式添加列表项，需指定一个Adapter对象，-通过它获得显示数据"><a href="#内容不能通过-ListView-add的形式添加列表项，需指定一个Adapter对象，-通过它获得显示数据" class="headerlink" title="内容不能通过 ListView.add的形式添加列表项，需指定一个Adapter对象，    通过它获得显示数据"></a>内容不能通过 ListView.add的形式添加列表项，需指定一个Adapter对象，    通过它获得显示数据</h4></li>
<li><h4 id="数据源相当于-MVC-框架中的M（模型）"><a href="#数据源相当于-MVC-框架中的M（模型）" class="headerlink" title="数据源相当于 MVC 框架中的M（模型）"></a>数据源相当于 MVC 框架中的<font color="red">M</font>（模型）</h4></li>
<li><h4 id="ListView-相当于-MVC-框架中的V（视图）"><a href="#ListView-相当于-MVC-框架中的V（视图）" class="headerlink" title="ListView 相当于 MVC 框架中的V（视图）"></a>ListView 相当于 MVC 框架中的<font color="red">V</font>（视图）</h4></li>
<li><h4 id="Adapter-相当于-MVC-框架中的C（控制器）"><a href="#Adapter-相当于-MVC-框架中的C（控制器）" class="headerlink" title="Adapter 相当于 MVC 框架中的C（控制器）"></a>Adapter 相当于 MVC 框架中的<font color="red">C</font>（控制器）</h4></li>
</ul>
<h2 id="三、Adapter接口"><a href="#三、Adapter接口" class="headerlink" title="三、Adapter接口"></a>三、Adapter接口</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002125728655.png" alt="image-20201002125728655" style="zoom:50%;"></h3><h3 id="2-Adapter常用的实现类如下："><a href="#2-Adapter常用的实现类如下：" class="headerlink" title="2.Adapter常用的实现类如下："></a>2.Adapter常用的实现类如下：</h3><h4 id="1-ArrayAdapter：支持泛型操作，最为简单，一般用于将字符串数组或者任意对象-toString-数组绑定为列表项的数据源。"><a href="#1-ArrayAdapter：支持泛型操作，最为简单，一般用于将字符串数组或者任意对象-toString-数组绑定为列表项的数据源。" class="headerlink" title="(1)ArrayAdapter：支持泛型操作，最为简单，一般用于将字符串数组或者任意对象(toString)数组绑定为列表项的数据源。"></a>(1)ArrayAdapter：支持<font color="red">泛型</font>操作，最为简单，一般用于将<font color="red">字符串数组</font>或者任意对象(toString)数组绑定为列表项的数据源。</h4><h4 id="2-SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的列表项视图组件上，可以自定义出各种效果。"><a href="#2-SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的列表项视图组件上，可以自定义出各种效果。" class="headerlink" title="(2)SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的列表项视图组件上，可以自定义出各种效果。"></a>(2)SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的<font color="red">列表项</font>视图组件上，可以自定义出各种效果。</h4><h4 id="3-SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。"><a href="#3-SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。" class="headerlink" title="(3)SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。"></a>(3)SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。</h4><h4 id="4-BaseAdapter：是一个抽象类，继承它需要实现一些方法，具有较高的灵活性"><a href="#4-BaseAdapter：是一个抽象类，继承它需要实现一些方法，具有较高的灵活性" class="headerlink" title="(4)BaseAdapter：是一个抽象类，继承它需要实现一些方法，具有较高的灵活性"></a>(4)BaseAdapter：是一个<font color="red">抽象类</font>，继承它需要实现一些方法，具有较高的<font color="red">灵活性</font></h4><h2 id="四、ArrayAdapter"><a href="#四、ArrayAdapter" class="headerlink" title="四、ArrayAdapter"></a>四、ArrayAdapter</h2><h3 id="1-实现步骤："><a href="#1-实现步骤：" class="headerlink" title="1.实现步骤："></a>1.实现步骤：</h3><h4 id="（1）创建新项目：项目名称ArrayAdapterDemo。"><a href="#（1）创建新项目：项目名称ArrayAdapterDemo。" class="headerlink" title="（1）创建新项目：项目名称ArrayAdapterDemo。"></a>（1）创建新项目：项目名称ArrayAdapterDemo。</h4><h4 id="（2）在string-xml创建一个string-array，存储栏目信息。-M"><a href="#（2）在string-xml创建一个string-array，存储栏目信息。-M" class="headerlink" title="（2）在string.xml创建一个string-array，存储栏目信息。(M)"></a>（2）在string.xml创建一个<font color="red">string-array</font>，存储栏目信息。(M)</h4><h4 id="（3）在布局中添加ListView控件。-V"><a href="#（3）在布局中添加ListView控件。-V" class="headerlink" title="（3）在布局中添加ListView控件。(V)"></a>（3）在布局中添加ListView控件。(V)</h4><h4 id="（4）在MainActivity-Java设置布局中ListView的Adapter-C"><a href="#（4）在MainActivity-Java设置布局中ListView的Adapter-C" class="headerlink" title="（4）在MainActivity.Java设置布局中ListView的Adapter:(C)"></a>（4）在MainActivity.Java设置布局中ListView的Adapter:(C)</h4><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><h5 id="视图-M"><a href="#视图-M" class="headerlink" title="//视图  M"></a>//视图  M</h5><h4 id="ListView-listView-ListView-findViewById-R-id-news-category"><a href="#ListView-listView-ListView-findViewById-R-id-news-category" class="headerlink" title="ListView listView = (ListView) findViewById(R.id.news_category);"></a>ListView listView = (ListView) findViewById(R.id.news_category);</h4><h5 id="数据：strings-xml-V"><a href="#数据：strings-xml-V" class="headerlink" title="//数据：strings.xml  V"></a>//数据：strings.xml  V</h5><h4 id="String-mData-getResources-getStringArray-R-array-news-category"><a href="#String-mData-getResources-getStringArray-R-array-news-category" class="headerlink" title="String [ ] mData = getResources().getStringArray(R.array.news_category);"></a>String [ ] mData = <font color="orange">getResources().getStringArray(R.array.news_category);</font></h4><h5 id="桥接：Adapter-C"><a href="#桥接：Adapter-C" class="headerlink" title="//桥接：Adapter  C"></a>//桥接：Adapter  C</h5><h4 id="ArrayAdapter-adapter-new-ArrayAdapter-lt-gt-this-android-R-layout-simple-list-item-1-mData"><a href="#ArrayAdapter-adapter-new-ArrayAdapter-lt-gt-this-android-R-layout-simple-list-item-1-mData" class="headerlink" title="ArrayAdapter adapter = new ArrayAdapter&lt;&gt;(this, android.R.layout.simple_list_item_1, mData);"></a>ArrayAdapter<String> adapter = new ArrayAdapter&lt;&gt;(this, android.R.layout.simple_list_item_1, mData);</String></h4><h4 id="listView-setAdapter-adapter"><a href="#listView-setAdapter-adapter" class="headerlink" title="listView.setAdapter(adapter);"></a>listView.setAdapter(adapter);</h4><p>​    </p>
<h3 id="3-监听器"><a href="#3-监听器" class="headerlink" title="3.监听器"></a>3.监听器</h3><p>、<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002130844609.png" alt="image-20201002130844609"></p>
<h2 id="五、SimpleAdapter"><a href="#五、SimpleAdapter" class="headerlink" title="五、SimpleAdapter"></a>五、SimpleAdapter</h2><h3 id="1-实现步骤：-1"><a href="#1-实现步骤：-1" class="headerlink" title="1.实现步骤："></a>1.实现步骤：</h3><h4 id="（1）创建新项目：项目名称SimpleAdapterDemo。"><a href="#（1）创建新项目：项目名称SimpleAdapterDemo。" class="headerlink" title="（1）创建新项目：项目名称SimpleAdapterDemo。"></a>（1）创建新项目：项目名称SimpleAdapterDemo。</h4><h4 id="（2）ListView的子项布局："><a href="#（2）ListView的子项布局：" class="headerlink" title="（2）ListView的子项布局："></a>（2）ListView的<font color="red">子项布局</font>：</h4><h4 id="用来显示列表的每一行内容的xml文件。自定义一个布局-listview-item-xml。"><a href="#用来显示列表的每一行内容的xml文件。自定义一个布局-listview-item-xml。" class="headerlink" title="用来显示列表的每一行内容的xml文件。自定义一个布局:listview_item.xml。"></a>用来显示列表的每一行内容的xml文件。<font color="orange">自定义一个布局:listview_item.xml。</font></h4><h4 id="（3）数据准备"><a href="#（3）数据准备" class="headerlink" title="（3）数据准备"></a>（3）数据准备</h4><h4 id="一般使用HashMap构成的List，List的每一个元素（map）用于填充ListView-的一个item。HashMap的每个键值数据映射到布局文件中对应id的组件上。"><a href="#一般使用HashMap构成的List，List的每一个元素（map）用于填充ListView-的一个item。HashMap的每个键值数据映射到布局文件中对应id的组件上。" class="headerlink" title="一般使用HashMap构成的List，List的每一个元素（map）用于填充ListView    的一个item。HashMap的每个键值数据映射到布局文件中对应id的组件上。"></a>一般使用<font color="orange">HashMap构成的List</font>，List的每一个元素（map）用于填充ListView    的一个item。HashMap的每个键值数据<font color="orange">映射</font>到布局文件中对应id的组件上。</h4><h4 id="（4）数据适配：创建SimpleAdapter并设置"><a href="#（4）数据适配：创建SimpleAdapter并设置" class="headerlink" title="（4）数据适配：创建SimpleAdapter并设置"></a>（4）数据适配：创建SimpleAdapter并设置</h4><h4 id="参数依次是：this，getData-，子项布局文件的ID，HashMap的键值数组，布局文件的组件id。"><a href="#参数依次是：this，getData-，子项布局文件的ID，HashMap的键值数组，布局文件的组件id。" class="headerlink" title="参数依次是：this，getData()，子项布局文件的ID，HashMap的键值数组，布局文件的组件id。"></a>参数依次是：<font color="orange">this，getData()，子项布局文件的ID，HashMap的键值数组，布局文件的组件id</font>。</h4><h4 id="第4个参数的键值序列与第5个参数的组件id序列一一对应。"><a href="#第4个参数的键值序列与第5个参数的组件id序列一一对应。" class="headerlink" title="第4个参数的键值序列与第5个参数的组件id序列一一对应。"></a>第4个参数的键值序列与第5个参数的组件id序列一一对应。</h4><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><h4 id="子项布局"><a href="#子项布局" class="headerlink" title="子项布局"></a>子项布局</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002131857410.png" alt="image-20201002131857410"></p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132023296.png" alt="image-20201002132023296"></p>
<h4 id="数据适配"><a href="#数据适配" class="headerlink" title="数据适配"></a>数据适配</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132215242.png" alt="image-20201002132215242"></p>
<h3 id="3-子项点击事件"><a href="#3-子项点击事件" class="headerlink" title="3.子项点击事件"></a>3.子项点击事件</h3><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132331890.png" alt="image-20201002132331890">

<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132425472.png" alt="image-20201002132425472">



<h2 id="六、BaseAdapter"><a href="#六、BaseAdapter" class="headerlink" title="六、BaseAdapter"></a>六、BaseAdapter</h2><h3 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h3><h4 id="（1）创建新项目：项目名称BaseAdapterDemo。"><a href="#（1）创建新项目：项目名称BaseAdapterDemo。" class="headerlink" title="（1）创建新项目：项目名称BaseAdapterDemo。"></a>（1）创建新项目：项目名称BaseAdapterDemo。</h4><h4 id="（2）ListView的子项布局：-listview-item-bt-xml"><a href="#（2）ListView的子项布局：-listview-item-bt-xml" class="headerlink" title="（2）ListView的子项布局： listview_item_bt.xml"></a>（2）ListView的子项布局： listview_item_bt.xml</h4><p>​        一个ImageView，两个TextView和一个ImageButton。</p>
<h4 id="（3）设置自定义适配器MyAdapter"><a href="#（3）设置自定义适配器MyAdapter" class="headerlink" title="（3）设置自定义适配器MyAdapter"></a>（3）设置自定义适配器<font color="red">MyAdapter</font></h4><p>​        <font color="cornflowerblue">MyAdapter继承BaseAdapter</font>，需要重写<font color="orange">getCount(), getView()</font>等方法。<br>​                ListView在绘制的时候，系统首先调用getCount()函数，根据返回值得到ListView的长度，然后根据            这个长度调用getView()逐一绘制每一行。<br>​        在getView中使用了<font color="cornflowerblue">ViewHolder类</font>和对象。<br>​                使用ViewHolder可以进行性能优化，对控件实例进行缓存。ViewHolder是一个内部类，其中包含了单个项目布局中的各个控件。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002133333488.png" alt="image-20201002133333488"></h3><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002133841796.png" alt="image-20201002133841796"></p>
<h4 id="mInflater-LayoutInflater-from-getContext"><a href="#mInflater-LayoutInflater-from-getContext" class="headerlink" title="mInflater = LayoutInflater.from( getContext() )"></a><font color="cornflowerblue">mInflater = LayoutInflater.from( getContext() )</font></h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134333722.png" alt="image-20201002134333722"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134657576.png" alt="image-20201002134657576"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134926677.png" alt="image-20201002134926677"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135612766.png" alt="image-20201002135612766"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134944464.png" alt="image-20201002134944464"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135159245.png" alt="image-20201002135159245"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135718003.png" alt="image-20201002135718003"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135725265.png" alt="image-20201002135725265"></p>
<h2 id="七、RecyclerView-补充"><a href="#七、RecyclerView-补充" class="headerlink" title="七、RecyclerView(补充)"></a>七、RecyclerView(补充)</h2><h3 id="1-定义子项布局：采用CardView布局进行美化。"><a href="#1-定义子项布局：采用CardView布局进行美化。" class="headerlink" title="1.定义子项布局：采用CardView布局进行美化。"></a>1.定义子项布局：采用CardView布局进行美化。</h3><h4 id="（1）新建cardview-bt-xml（类似于前一例中的listview-item-bt-xml）"><a href="#（1）新建cardview-bt-xml（类似于前一例中的listview-item-bt-xml）" class="headerlink" title="（1）新建cardview_bt.xml（类似于前一例中的listview_item_bt.xml）"></a>（1）新建cardview_bt.xml（类似于前一例中的listview_item_bt.xml）</h4><p>定义cardCornerRadius=”5dp”, elevation = “1dp”<br>CardView 继承于Framelayout，不能直接放置各类控件，否则各类控件将会重叠在一起，因此一般在CardView布局中嵌套其它布局，在其中放置放置其它控件</p>
<h4 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201009121547035.png" alt="image-20201009121547035"></h4><h3 id="2-getAdapterPosition-获取当前点击项的position序号"><a href="#2-getAdapterPosition-获取当前点击项的position序号" class="headerlink" title="2.getAdapterPosition(); 获取当前点击项的position序号"></a>2.<font color="cornflowerblue">getAdapterPosition()</font>; 获取当前点击项的position序号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">holder.fruitItemView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        int position=holder.getAdapterPosition();   //获取当前点击项的position序号</span><br><span class="line">        Fruit fruit=mFruitList.get(position);       //获取当前点击项的Fruit实例</span><br><span class="line">        new AlertDialog.Builder(parent.getContext()).setTitle(&quot;营养价值：&quot;)</span><br><span class="line">                .setMessage(fruit.nutrition)</span><br><span class="line">                .setPositiveButton(&quot;ok&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-定位子项到第一项"><a href="#3-定位子项到第一项" class="headerlink" title="3.定位子项到第一项"></a>3.定位子项到第一项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int positions=fruitList.indexOf(fruit); //获取对象序号</span><br><span class="line">recyclerView.scrollToPosition(positions);</span><br><span class="line">LinearLayoutManager layoutManager1=(LinearLayoutManager)recyclerView.getLayoutManager();</span><br><span class="line">layoutManager1.scrollToPositionWithOffset(positions,0);     //对象定位到第一项</span><br></pre></td></tr></table></figure>



<h3 id="4-List按某个属性重新排序"><a href="#4-List按某个属性重新排序" class="headerlink" title="4.List按某个属性重新排序"></a>4.List按某个属性重新排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case R.id.like_order_up:</span><br><span class="line">    Collections.sort(fruitList, new Comparator&lt;Fruit&gt;() &#123;       //按喜爱度升序排序</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Fruit o1, Fruit o2) &#123;</span><br><span class="line">            return o1.likeNumber.compareTo(o2.likeNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    adapter.notifyDataSetChanged();     //刷新适配器</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case R.id.like_order_down:</span><br><span class="line">    Collections.sort(fruitList, new Comparator&lt;Fruit&gt;() &#123;       //按喜爱度降序排序</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Fruit o1, Fruit o2) &#123;</span><br><span class="line">            return o2.likeNumber.compareTo(o1.likeNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    adapter.notifyDataSetChanged();     //刷新适配器</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>





<h1 id="第三章-数据存储"><a href="#第三章-数据存储" class="headerlink" title="第三章 数据存储"></a>第三章 数据存储</h1><h2 id="一、数据持久化"><a href="#一、数据持久化" class="headerlink" title="一、数据持久化"></a>一、数据持久化</h2><h3 id="1-数据存储方式"><a href="#1-数据存储方式" class="headerlink" title="1.数据存储方式"></a>1.数据存储方式</h3><ul>
<li><font color="red">文件存储</font></li>
<li><font color="red">SharedPreferences</font></li>
<li><font color="red">SQLite数据库</font></li>
</ul>
<h3 id="2-Android内部存储和外部存储"><a href="#2-Android内部存储和外部存储" class="headerlink" title="2.Android内部存储和外部存储"></a>2.Android内部存储和外部存储</h3><h4 id="（1）内存（Memory）："><a href="#（1）内存（Memory）：" class="headerlink" title="（1）内存（Memory）："></a>（1）内存（Memory）：</h4><p>​            RAM，类似于PC的内存条</p>
<h4 id="（2）内部存储（Internal-Storage）："><a href="#（2）内部存储（Internal-Storage）：" class="headerlink" title="（2）内部存储（Internal Storage）："></a>（2）内部存储（Internal Storage）：</h4><p>​            机身固有存储，类似于PC的硬盘 </p>
<h4 id="（3）外部存储（External-Storage）："><a href="#（3）外部存储（External-Storage）：" class="headerlink" title="（3）外部存储（External Storage）："></a>（3）外部存储（External Storage）：</h4><p>​                早期的Android设备(4.4之前) 指SDCard(扩展卡)，类似于PC上的U盘。</p>
<p>​        之后随着技术的进步，机身存储得到了快速增大(8G以上)，此时的外部存储是<font color="orange">概念级别的“外部存储”</font>，机        身<font color="red">固有的存储</font>有一部分被划分为“内部存储”，另一部分被划分为“外部存储”，但其实都是机身固有存储。        后期的外部存储也包括了SDCard。<br>​        所以不管Android手机是否有可移动的SDCard，他们总是有外部存储和内部存储。</p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20210601224438335.png" alt="image-20210601224438335"></p>
<h3 id="3-几个重要文件夹"><a href="#3-几个重要文件夹" class="headerlink" title="3.几个重要文件夹"></a>3.几个重要文件夹</h3><h4 id="打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹"><a href="#打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹" class="headerlink" title="打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：data文件夹、mnt文件夹、sdcard 文件夹、storage文件夹"></a>打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：<font color="red">data</font>文件夹、<font color="red">mnt</font>文件夹、<font color="red">sdcard</font> 文件夹、<font color="red">storage</font>文件夹</h4><h3 id="4-内部存储data"><a href="#4-内部存储data" class="headerlink" title="4.内部存储data"></a>4.<font color="cornflowerblue">内部存储data</font></h3><h4 id="1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："><a href="#1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：" class="headerlink" title="(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："></a>(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：</h4><ul>
<li><h5 id="文件夹app：存放着我们所有安装的app的apk文件"><a href="#文件夹app：存放着我们所有安装的app的apk文件" class="headerlink" title="文件夹app：存放着我们所有安装的app的apk文件"></a>文件夹<font color="red">app</font>：存放着我们所有安装的app的apk文件</h5></li>
<li><h5 id="文件夹data：一些包名，展开后，"><a href="#文件夹data：一些包名，展开后，" class="headerlink" title="文件夹data：一些包名，展开后，"></a>文件夹<font color="red">data</font>：一些包名，展开后，</h5><p>data/data/包名/<font color="orange">shared_prefs</font>(SharedPreference存储方式)</p>
<pre><code>data/data/包名/&lt;font color=&#39;orange&#39;&gt;databases&lt;/font&gt;（数据库存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;files&lt;/font&gt;（文件存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;cache&lt;/font&gt;
</code></pre>
</li>
</ul>
<h4 id="（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data"><a href="#（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data" class="headerlink" title="（2）路径的访问：Environment.getDataDirectory()获取内部存储根路径。/data"></a>（2）路径的访问：<font color="red">Environment.getDataDirectory()</font>获取内部存储根路径。/data</h4><h4 id="3-几点："><a href="#3-几点：" class="headerlink" title="(3)几点："></a>(3)几点：</h4><ol>
<li><h4 id="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"><a href="#系统默认只在内部存储中创建cache目录，并且此时cache目录是空的" class="headerlink" title="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"></a>系统默认<font color="orange">只在内部存储中创建cache目录</font>，并且此时cache目录是空的</h4></li>
<li><h4 id="此外，还可以根据需要自动创建：shared-prefs，databases，files目录"><a href="#此外，还可以根据需要自动创建：shared-prefs，databases，files目录" class="headerlink" title="此外，还可以根据需要自动创建：shared_prefs，databases，files目录"></a>此外，还可以根据需要<font color="orange">自动创建</font>：shared_prefs，databases，files目录</h4><p>但files可以<font color="orange">手动创建</font>，而shared_prefs，databases不能</p>
</li>
<li><h4 id="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"><a href="#别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。" class="headerlink" title="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"></a>别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。</h4></li>
</ol>
<h4 id="（4）内部存储的API"><a href="#（4）内部存储的API" class="headerlink" title="（4）内部存储的API"></a>（4）内部存储的API</h4><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028153632199.png" alt="image-20201028153632199" style="zoom:80%;">





<h3 id="5-外部存储storage"><a href="#5-外部存储storage" class="headerlink" title="5.外部存储storage"></a>5.<font color="cornflowerblue">外部存储storage</font></h3><h4 id="1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"><a href="#1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。" class="headerlink" title="(1)一般是/storage/emulated/0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"></a>(1)一般是<font color="red">/storage/emulated/0</font>也有可能是其它文件夹，不同厂家不同版本有可能不一样。</h4><h4 id="storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy"><a href="#storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy" class="headerlink" title="/storage/sdcard0，/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy"></a><font color="red">/storage/sdcard0，</font>/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy</h4><ul>
<li><h5 id="公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等"><a href="#公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等" class="headerlink" title="公有目录：10大类，比如DCIM,Download等这些系统创建的文件夹。storage/emulated/0/Download等"></a><font color="red">公有目录</font>：10大类，比如DCIM,Download等这些系统创建的文件夹。<font color="orange">storage/emulated/0/Download</font>等</h5></li>
<li><h5 id="私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。"><a href="#私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。" class="headerlink" title="私有目录：Android文件夹，打开后有data文件夹。storage/emulated/0/Android/data/包名 文件夹：里面包含了许多包名组成的文件夹。"></a><font color="red">私有目录</font>：Android文件夹，打开后有<font color="red">data</font>文件夹。<font color="orange">storage/emulated/0/Android/data/包名 文件夹</font>：里面包含了许多包名组成的文件夹。</h5><h4 id="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"><a href="#（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。" class="headerlink" title="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"></a>（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的<font color="green">数据会一并删除</font>。</h4><p>如果直接在<font color="red">根目录</font>（<font color="orange">/storage/emulated/0</font>）下创建一个应用的文件夹，这样当该应用被卸载后，这些数据还保留在外部存储中，<font color="green">留下垃圾数据</font>。</p>
</li>
</ul>
<h4 id="（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。"><a href="#（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。" class="headerlink" title="（3）路径的访问：Environment.getExternalStorageDirectory()：获取机身存储的外部存储根路径。"></a>（3）路径的访问：<font color="red">Environment.getExternalStorageDirectory()</font>：获取机身存储的外部存储根路径。</h4><h4 id="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"><a href="#（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录" class="headerlink" title="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"></a>（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要<font color="red">手动创建私有目录</font></h4><h5 id="context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件"><a href="#context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件" class="headerlink" title="context.getExternalFilesDir(…)：在storage/emulated/0/Android/data/包名/files 中创建文件"></a>context.<font color="orange">getExternalFilesDir(…)</font>：在storage/emulated/0/Android/data/包名/files 中创建文件</h5><p>​    context.<font color="orange">getExternalCacheDir() </font>：在storage/emulated/0/Android/data/包名/cache 中创建文件</p>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028154738508.png" alt="image-20201028154738508" style="zoom:80%;">

<h3 id="6-内部存储与外部存储比较"><a href="#6-内部存储与外部存储比较" class="headerlink" title="6.内部存储与外部存储比较"></a>6.内部存储与外部存储比较</h3><p>​        外部存储目录空间较大，而内部存储空间有限<br>​        部分目录不会被自动创建，需要手动创建<br>​        两者<font color="red">都不需要权限</font><br>​        两者<font color="red">都会随着App的卸载而会自动被删除</font><br>​        对于内部存储，<font color="orange">只有</font>本App才可以访问<br>​        对于外部私有目录，本App可以直接访问，而其它App在自 Android 7.0 开始，系统对应用私有目录的访问权限进一步限制。其他 App 无法通过 file:// 这种形式的 Uri 直接读写该目录下的文件内容，而是通过 FileProvider 访问。<br>​        需要注意的是：由于用户可以直接查看并操作外部私有存储目录，那么也就意味着我们在操作这个目录下的文件的时候一定要做好异常和判空处理。</p>
<h3 id="7-数据存储与清除"><a href="#7-数据存储与清除" class="headerlink" title="7.数据存储与清除"></a>7.数据存储与清除</h3><h4 id="（1）数据存储："><a href="#（1）数据存储：" class="headerlink" title="（1）数据存储："></a>（1）数据存储：</h4><ul>
<li><p>默认情况下，存储在<font color="red">内部存储</font>：<br><font color="orange">data/app</font>：用户APP安装目录，存放apk；</p>
<p><font color="orange">data/data/包名/</font>：存放应用程序的数据</p>
</li>
<li><p>数据可以存放到指定的<font color="red">外部存储</font>：</p>
<p><font color="orange">/storage/sdcard</font>（共有目录）</p>
<p><font color="orange">/storage/sdcard0/Android/data/包名/</font>（私有目录）</p>
<h4 id="（2）清除数据："><a href="#（2）清除数据：" class="headerlink" title="（2）清除数据："></a>（2）清除数据：</h4></li>
</ul>
<h5 id="删除对应包中的cache，files，lib，shared-prefs，datbBases等等"><a href="#删除对应包中的cache，files，lib，shared-prefs，datbBases等等" class="headerlink" title="删除对应包中的cache，files，lib，shared_prefs，datbBases等等"></a>删除<font color="red">对应包中的</font><font color="cornflowerblue">cache</font>，files，lib，shared_prefs，datbBases等等</h5><p>​        （清除<font color="red">data/data/packagename中的</font>cache，files，lib， databases，shared_prefs等等）</p>
<p>​        （清除<font color="red">storage/emulated/0/Android/data/packagenam中的</font>文件）</p>
<h4 id="3-清除缓存："><a href="#3-清除缓存：" class="headerlink" title="(3) 清除缓存："></a>(3) 清除缓存：</h4><h5 id="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"><a href="#删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。" class="headerlink" title="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"></a>删除的是App运行过程中所产生的<font color="red">临时数据</font>，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在<font color="red">内存</font>中。</h5><h2 id="二、文件存储"><a href="#二、文件存储" class="headerlink" title="二、文件存储"></a>二、文件存储</h2><h3 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1.内部存储"></a>1.内部存储</h3><h4 id="（1）存："><a href="#（1）存：" class="headerlink" title="（1）存："></a>（1）存：</h4><ul>
<li>方法1：使用 context.getFilesDir() 获取内部存储data/data/包名/files目录，然后创建文件，最后利用文件(全路径)新建FileOutputStream对象进行文件写入。<br>FileOutputStream fileOutputStream = new FileOutputStream(filePathName);</li>
</ul>
<img src="《Android小菜》//image-20201028160019136.png" alt="image-20201028160019136" style="zoom:80%;">

<ul>
<li>方法2：直接使用Context.openFileOutput()方法(只需要文件名)获取FileOutputStream对象，进行文件写入。</li>
</ul>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028160258040.png" alt="image-20201028160258040" style="zoom:80%;">

<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028160348975.png" alt="image-20201028160348975" style="zoom:80%;">

<h4 id="（2）取："><a href="#（2）取：" class="headerlink" title="（2）取："></a>（2）取：</h4><ul>
<li>方法1：使用context.getFilesDir() 获取内部存储data/data/包名/files目录，然后利用文件(全路径)创建FileInputStream对象，进行内容读取。<br>FileInputStream fileInputStream = new FileInputStream(filePathName);</li>
</ul>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20210601224213396.png" alt="image-20210601224213396"></p>
<ul>
<li>方法2：直接使用Context. openFileInput()方法(只需要文件名)获取FileInputStream对象，进行文件内容读取。<br>FileInputStream fileInputStream = openFileInput(fileName);</li>
</ul>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028160853113.png" alt="image-20201028160853113" style="zoom:80%;">

<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20210601224250308.png" alt="image-20210601224250308"></p>
<h3 id="2-外部存储"><a href="#2-外部存储" class="headerlink" title="2.外部存储"></a>2.外部存储</h3><h4 id="（1）外部根目录："><a href="#（1）外部根目录：" class="headerlink" title="（1）外部根目录："></a>（1）外部根目录：</h4><p>使用 <font color="red">Environment.getExternalStorageDirectory()</font> 获取</p>
<p>一般是/storage/emulated/0</p>
<h4 id="（2）外部公有目录："><a href="#（2）外部公有目录：" class="headerlink" title="（2）外部公有目录："></a>（2）外部公有目录：</h4><p>使用<font color="red">Environment.getExternalStoragePublicDirectory</font>获取</p>
<p>/storage/emulated/0/Music</p>
<p>针对外部<font color="red">共有目录、根目录</font>等位置的存取需要<font color="orange">添加权限</font>，Android 6.0 之后还需要做运行时权限申请。针对外部<font color="red">私有目录</font>的存取则<font color="orange">不需要添加权限</font>。<br>默认情况下，Android系统<font color="red">不会</font>为我们的App在外部存储中创建私有路径，需要<font color="red">手动创建</font>。<br>外部私有目录在App卸载时同步删除。</p>
<p>​    </p>
<h4 id="（3）获取外部私有目录"><a href="#（3）获取外部私有目录" class="headerlink" title="（3）获取外部私有目录"></a>（3）获取外部私有目录</h4><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028162002693.png" alt="image-20201028162002693" style="zoom:80%;">





<h4 id="（4）存："><a href="#（4）存：" class="headerlink" title="（4）存："></a>（4）存：</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028162420940.png" alt="image-20201028162420940"></p>
<h4 id="（5）取："><a href="#（5）取：" class="headerlink" title="（5）取："></a>（5）取：</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028162532386.png" alt="image-20201028162532386"></p>
<h2 id="二、SharedPreferences存储"><a href="#二、SharedPreferences存储" class="headerlink" title="二、SharedPreferences存储"></a>二、SharedPreferences存储</h2><h3 id="1-获取SharedPreferences对象"><a href="#1-获取SharedPreferences对象" class="headerlink" title="1.获取SharedPreferences对象"></a>1.获取<font color="cornflowerblue">SharedPreferences对象</font></h3><h4 id="1-Context-getSharedPreferences-方法"><a href="#1-Context-getSharedPreferences-方法" class="headerlink" title="(1) Context . getSharedPreferences()方法 "></a>(1) <font color="red">Context . getSharedPreferences()方法 </font></h4><p>​        此方法接受两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个。SharedPreferences 文件都是存放在 /data/data/&lt;包名&gt;/shared_prefs/ 目录下的。<br>​        第二个参数用于<font color="orange">指定操作模式</font>，主要为 MODE_PRIVATE（默认操作模式） 和 MODE_MULTI_PROCESS（多进程读写） 。</p>
<h4 id="2-Activity-类中的-getPreferences-方法"><a href="#2-Activity-类中的-getPreferences-方法" class="headerlink" title="(2)Activity 类中的 getPreferences() 方法"></a>(2)<font color="red">Activity 类中的 getPreferences() 方法</font></h4><p>这个方法和 Context 中的 getSharedPreferences() 方法类似，不过它只接收一个操作模式参数，使用这个方法时<font color="orange">会自动将当前活动的类名作为 SharedPreferences 的文件名</font>。</p>
<h4 id="3-PreferenceManager-类中的-getDefaultSharedPreferences-方法"><a href="#3-PreferenceManager-类中的-getDefaultSharedPreferences-方法" class="headerlink" title="(3) PreferenceManager 类中的 getDefaultSharedPreferences() 方法"></a>(3)<font color="red"> PreferenceManager 类中的 getDefaultSharedPreferences() 方法</font></h4><p>这是一个<font color="orange">静态方法</font>，它接收一个 Context 参数，并自动<font color="orange">使用当前应用程序的包名作为前缀</font>来命名 SharedPreferences 文件。</p>
<h3 id="2-通过SharedPreferences对象获取到Editor对象存数据"><a href="#2-通过SharedPreferences对象获取到Editor对象存数据" class="headerlink" title="2.通过SharedPreferences对象获取到Editor对象存数据"></a>2.通过SharedPreferences对象获取到<font color="cornflowerblue">Editor对象</font>存数据</h3><h4 id="（1）SharePreferences-Editor-editor-shared-edit"><a href="#（1）SharePreferences-Editor-editor-shared-edit" class="headerlink" title="（1）SharePreferences.Editor  editor = shared.edit();"></a>（1）SharePreferences.Editor  editor = shared.<font color="red">edit();</font></h4><p>调用 SharedPreferences 对象的 edit() 方法来获取一个 SharePreferences.Editor 对象。</p>
<h4 id="（2）editor-putString"><a href="#（2）editor-putString" class="headerlink" title="（2）editor.putString( )"></a>（2）editor<font color="red">.putString( )</font></h4><p>向 SharedPreferences.Editor 对象中添加数据，如果添加一个字符串则使用 editor.putString() 方法，以此类推。</p>
<h4 id="（3）editor-commit-editor-apply"><a href="#（3）editor-commit-editor-apply" class="headerlink" title="（3）editor.commit()  editor.apply()"></a>（3）<font color="red">editor.commit()  editor.apply()</font></h4><p>调用 editor.commit() 方法或者editor.apply()方法将添加的数据提交，从而完成数据存储操作。</p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164007127.png" alt="image-20201028164007127"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164138241.png" alt="image-20201028164138241"></p>
<h3 id="3-SharePreferences读取与删除数据"><a href="#3-SharePreferences读取与删除数据" class="headerlink" title="3.SharePreferences读取与删除数据"></a>3.SharePreferences<font color="cornflowerblue">读取与删除</font>数据</h3><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164251857.png" alt="image-20201028164251857"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164334426.png" alt="image-20201028164334426">****</p>
]]></content>
      <categories>
        <category>《 Android基础》</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>标签外挂</title>
    <url>/2021/06/09/%E6%A0%87%E7%AD%BE%E5%A4%96%E6%8C%82/</url>
    <content><![CDATA[<h1 id="Note-Bootstrap-Callout"><a href="#Note-Bootstrap-Callout" class="headerlink" title="Note (Bootstrap Callout)"></a>Note (Bootstrap Callout)</h1><h2 id="用法一："><a href="#用法一：" class="headerlink" title="用法一："></a>用法一：</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">名称</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">class</td>
<td>【可选】标识，不同的标识有不同的配色（ default / primary / success / info / warning / danger ）</td>
</tr>
<tr>
<td align="center">no-icon</td>
<td>【可选】不显示 icon</td>
</tr>
<tr>
<td align="center">style</td>
<td>【可选】可以覆盖配置中的 style（simple/modern/flat/disabled）</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="simple"><a href="#simple" class="headerlink" title="simple"></a>simple</h3></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note simple %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<div class="note simple"><p>默认 提示块标签</p>
</div>

<div class="note default simple"><p>default 提示块标签</p>
</div>

<div class="note primary simple"><p>primary 提示块标签</p>
</div>

<div class="note success simple"><p>success 提示块标签</p>
</div>

<div class="note info simple"><p>info 提示块标签</p>
</div>

<div class="note warning simple"><p>warning 提示块标签</p>
</div>

<div class="note danger simple"><p>danger 提示块标签</p>
</div>



<ul>
<li><h3 id="modern"><a href="#modern" class="headerlink" title="modern"></a>modern</h3></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note modern %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<div class="note modern"><p>默认 提示块标签</p>
</div>

<div class="note default modern"><p>default 提示块标签</p>
</div>

<div class="note primary modern"><p>primary 提示块标签</p>
</div>

<div class="note success modern"><p>success 提示块标签</p>
</div>

<div class="note info modern"><p>info 提示块标签</p>
</div>

<div class="note warning modern"><p>warning 提示块标签</p>
</div>

<div class="note danger modern"><p>danger 提示块标签</p>
</div>



<ul>
<li><h3 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h3></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note flat %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<div class="note flat"><p>默认 提示块标签</p>
</div>

<div class="note default flat"><p>default 提示块标签</p>
</div>

<div class="note primary flat"><p>primary 提示块标签</p>
</div>

<div class="note success flat"><p>success 提示块标签</p>
</div>

<div class="note info flat"><p>info 提示块标签</p>
</div>

<div class="note warning flat"><p>warning 提示块标签</p>
</div>

<div class="note danger flat"><p>danger 提示块标签</p>
</div>



<ul>
<li><h3 id="disabled"><a href="#disabled" class="headerlink" title="disabled"></a>disabled</h3></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note disabled %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<div class="note disabled"><p>默认 提示块标签</p>
</div>

<div class="note default disabled"><p>default 提示块标签</p>
</div>

<div class="note primary disabled"><p>primary 提示块标签</p>
</div>

<div class="note success disabled"><p>success 提示块标签</p>
</div>

<div class="note info disabled"><p>info 提示块标签</p>
</div>

<div class="note warning disabled"><p>warning 提示块标签</p>
</div>

<div class="note danger disabled"><p>danger 提示块标签</p>
</div>



<h2 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>【可选】顔色(default / blue / pink / red / purple / orange / green)</td>
</tr>
<tr>
<td>icon</td>
<td>【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td>
</tr>
<tr>
<td>style</td>
<td>【可选】可以覆盖配置中的 style<br>（simple/modern/flat/disabled）</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="simple-1"><a href="#simple-1" class="headerlink" title="simple"></a>simple</h3></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<div class="note icon simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="modern-1"><a href="#modern-1" class="headerlink" title="modern"></a>modern</h3></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<div class="note icon modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="flat-1"><a href="#flat-1" class="headerlink" title="flat"></a>flat</h3></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat %&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<div class="note icon flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="disabled-1"><a href="#disabled-1" class="headerlink" title="disabled"></a>disabled</h3></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<div class="note icon disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="no-icon"><a href="#no-icon" class="headerlink" title="no-icon"></a>no-icon</h3></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<div class="note no-icon simple"><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue no-icon simple"><p>2021年快到了….</p>
</div>

<div class="note pink no-icon simple"><p>小心开车 安全至上</p>
</div>

<div class="note red no-icon simple"><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange no-icon simple"><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple no-icon simple"><p>剪刀石头布</p>
</div>

<div class="note green no-icon simple"><p>前端最讨厌的浏览器</p>
</div>

]]></content>
      <categories>
        <category>《hexo》</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像复习笔记</title>
    <url>/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><ul>
<li><p>1.数字图像：<br>一幅图像可定义为一个二维函数f(x,y),其中x和y是<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间(平面)坐标</span></span>,而在任何一对空间坐标(x, y)处的幅值f称为图像在该点处的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">强度或灰度</span></span>。当x, y和灰度值f是有限的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">离散数值</span></span>时，我们称该图像为数字图像。</p>
</li>
<li><p>2.数字图像处理：<br>是指借助于<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数字计算机</span></span>来处理数字图像。</p>
</li>
<li><p>3.像素：<br>数字图像是由有限数量的（二维的）元素组成的，每个元素都有一个特定的位置(x,y)和幅值f(x,y)。这些元素称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图画元素、图像元素或像素</span></span>。</p>
</li>
<li><p>4.图像增强：<br>对一幅图像进行某种操作，使其结果在特定应用中比原始图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">更适合</span></span>进行处理</p>
</li>
<li><p>5.图像复原：<br>图像复原也是改进图像外观的一个处理领域。然而，与图像增强不同，图像增强是<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">主观的</span></span>，而图像复原是<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">客观的;</span></span>;在某种意义上说，复原技术倾向于以<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像退化的数学或概率模型</span></span>为基础。另一方面，增强以<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">什么是好的增强效果</span></span>这种人的主观偏爱为基础。</p>
</li>
<li><p>6.图像处理系统基本组成结构：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数字化</span></span>设备（数码相机、数码摄像机）、图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">处理</span></span>设备（计算机和存储系统）、图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">输出</span></span>设备（打印机）</p>
</li>
<li><p>7.图像存储系统：<br>（1）图像文件格式体系：<br>互联网用：GIF、JPG<br>印 刷 用：TIF、JPG、TAG 、PCX<br>国际标准：TIF、JPG、BMP<br>（2）图像存储体系：(分级存储)<br>内存存储： 处理时使用<br>硬盘存储：处理、备份时用<br>备份存储：光盘、磁带<br>网络存储：SAN、 NAS</p>
</li>
<li><p>8.数字图像处理应用领域：传统领域（医学、地理学、生物学、军事）；最新领域（指纹识别、人脸识别、图像检索等）</p>
</li>
</ul>
<h1 id="第二章-数值图像基础"><a href="#第二章-数值图像基础" class="headerlink" title="第二章 数值图像基础"></a>第二章 数值图像基础</h1><div class="note info blue modern"><p><strong>两个名词解释</strong></p>
</div>

<ul>
<li><p>1.为了产生一幅数字图像，需要把连续的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">感知数据</span></span>转化为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数字形式</span></span>，这包括两种处理：取样和量化</p>
</li>
<li><p>2.取样：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间坐标</span></span>的数字化；(对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">坐标值</span></span>进行数字化)<br>量化：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">函数值（灰度值</span></span>的数字化；（对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">幅值</span></span>进行数字化）</p>
</li>
<li><p>3.非统一的图像的采样<br>在灰级变化<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">尖锐的</span></span>区域，用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">细腻的</span></span>采样，<br>在灰度级比较<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">平滑的</span></span>区域，用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">粗糙的</span></span>采样</p>
</li>
<li><p>4.非统一的图像的量化<br>✓ 在<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">边界附近</span></span>（灰度级变化尖锐）使用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">较少</span></span>的灰度级。剩余的灰度级可用于灰度级变化比较<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">平滑</span></span>的区域<br>✓ 避免或减少由于量化的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">太粗糙</span></span>，在灰度级变化比较平滑的区域出现<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">假轮廓</span></span>的现象</p>
</li>
<li><p>5.通常，图像在任何坐标(x,y)处的值记为f(x,y)，其中x和y都是整数。由一幅图像的坐标张成的实平面部分称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间域</span></span>，x和 y称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间变量或空间坐标</span></span>。</p>
</li>
<li><p>6.灰度跨越的值域非正式地称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">动态范围</span></span>。</p>
</li>
<li><p>7.空间分别率：图像中可辨别的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">最小细节</span></span>的度量，其中每单位<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">距离线对数</span></span>和每单位<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">距离点数</span></span>（像素数）都是最通用的度量。<br>灰度分别率：可分辨的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">最小灰度级</span></span>变化。</p>
</li>
<li><p>8.数字图像的表示包括：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">描述信息</span></span>（如图像高度和宽度）、图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: 查看答案">查看答案
  </button><span class="hide-content">数据</span></span>（顺序存放的连续数据）</p>
</li>
<li><p>9.图像的质量包括：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">层次、对比度、清晰度</span></span><br>(1)层次：图像实际拥有的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">灰度级</span></span>的数量（灰度级：表示像素<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">明暗程度</span></span>的整数量） 图像的实际层次越多，视觉效果就越好。<br>(2)对比度：一幅图像中<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">灰度反差</span></span>的大小（对比度=最大亮度/最小亮度）<br>(3)与清晰度相关的主要因素：亮度、对比度、尺寸大小、细微层次、颜色饱和度</p>
</li>
<li><p>10.4邻域：像素p(x,y)的4邻域是： (x+1,y)；(x-1,y)；(x,y+1)；(x,y-1)。用N4(p)表示像素p的4邻域 </p>
<p>D邻域定义：像素p(x,y)的D邻域是对角上的点 (x+1,y+1)；(x+1,y-1)；(x-<br>1,y+1)；(x-1,y-1)<br>用ND(p)表示像素p的D邻域</p>
<p>8邻域定义：像素p(x,y)的8邻域是：<br>4邻域的点 ＋ D邻域的点<br>用N8(p)表示像素p的8邻域。 N<del>8</del>(p) = N<del>4</del>(p) + N<del>D</del>(p) </p>
</li>
<li><p>10.连通性：是描述区域和边界的重要概念。<br>两个像素连通的两个必要条件是：（1）两个像素<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">位置是否相邻</span></span>；（2）两个像素的灰度值是否满足<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">特定的相似性准则</span></span>（或者是否相等）</p>
</li>
<li><p>11.像素的连通性：<br>(1)4连通：对于具有值V的像素p和q，如果q在集合N4(p)中，则称这两个像素是4 连通的<br>(2)8连通：对于具有值V的像素p和q，如果q在 集 合N8(p)中，则称这两个像素是8连通的<br>(3)对 于 具 有 值 V 的 像 素 p 和 q ，<br>如 果<br>I.q在集合N4(p)中，或<br>II. q在集合ND(p)中，并且N4(p)与N4(q)的交集为空（没有值V的像素） 则称这两个像素是m连通的，即4连通和D连通的混合连通。</p>
</li>
<li><p>12.像素p(x,y)和q(s,t)间的欧式距离:<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623151831018.png" alt="image-20210623151831018"></p>
</li>
</ul>
<p>  对于这个距离计算法，具有与(x,y) 距离小于等于某个值r的像素是：包含在以(x,y)为圆心，以r为半径的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">圆平面</span></span></p>
<ul>
<li><p>13.像素p(x,y)和q(s,t)之间的D4距离(城市距离、街区距离)：<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620200645833.png" alt="image-20210620200645833"><br>具有与(x,y)距离小于等于某个值r的那些像素形成一个<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">菱形</span></span></p>
</li>
<li><p>14.q(s,t)之间的D8距离（棋盘距离）：<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620200655280.png" alt="image-20210620200655280"><br>具有与(x,y)距离小于等于某个值r的那些像素形成一个<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">正方形</span></span></p>
</li>
</ul>
<h1 id="第三章-灰度变换和空间滤波"><a href="#第三章-灰度变换和空间滤波" class="headerlink" title="第三章 灰度变换和空间滤波"></a>第三章 灰度变换和空间滤波</h1><div class="note info blue modern"><p><strong>两个名词解释+一个简答 +程序</strong></p>
</div>

<ul>
<li><p>1.图像增强分为两类：<br>(1)空间域处理：对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像像素</span></span>直接处理<br>(2)频率域处理：修改图像的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">傅里叶变换</span></span><br>2.灰度变换函数:g(x,y)=T[f(x,y)] 或 s = T(r)</p>
</li>
<li><p>3.一些基本的灰度变换函数：<br>（1）反转变换：<font color="red">s = (L-1) - r</font><br>作用：黑的变白，白的变黑（特别适合用于增强嵌入在一幅图像暗区域中的白色或灰色细节，特别是当黑色面积在尺寸上占主导时）<br>（2）对数变换：<font color="red">s = c log(1+r)</font><br>有时原图的动态范围太大，超出某些显示设备的允许动态范围，如直接使用原图，则一部分细节可能丢失, 解决办法是对原图进行灰度压缩，如对数变换</p>
<p>作用：灰度压缩/扩展，对数函数有个重要特征，即它能压缩像素值变化较大的图像的动态范围。</p>
</li>
</ul>
<p>（3）幂次变换：<font color="red">s = c ^r^  </font></p>
<p>  γ&lt;1 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">提高灰度级</span></span>，在正比函数上方，使图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">变亮 </span></span><br>  γ&gt;1 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">降低灰度级</span></span>，在正比函数下方，使图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">变暗</span></span></p>
<ul>
<li><p>4.直方图的定义：h(r<del>k</del>)= n<del>k</del>    p(r<del>k</del>)= n<del>k</del>/n<br>第二种定义的好处：<br>✓ 使函数值正则化到[0,1]区间，成为实数函数 ；<br>✓ 函数值的范围与像素的总数无关 ；<br>✓ 给出灰度级rk在图像中出现的概率密度统计</p>
</li>
<li><p>补充：</p>
<ul>
<li>暗图像：直方图的分量集中在灰度级的低端</li>
<li>亮图像：直方图的分量集中在灰度级的高端</li>
<li>低对比度图像：具有较窄的直方图，且集中在灰度级的中部</li>
<li>高对比度图像：具有较宽的直方图，直方图的分量覆盖了很宽的灰度级范围，且像素没有分布不均匀</li>
</ul>
</li>
<li><p>5.直方图的均衡化：基本思想是把原始图的直方图变换为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">均匀分布</span></span>的形式，这样就增加了像素灰度值的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">动态范围</span></span>，从而达到增强图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">整体对比度</span></span>的效果 </p>
</li>
<li><p>6.直方图均衡化公式：s=T(r)    0&lt;=r&lt;=1<br>T(r)满足下列两个条件：<br>（1）T(r)在区间0≤r≤1中为单值且单调递增<br>（2）当0≤r≤1时,0≤T(r)≤1</p>
<p>条件（1）保证输出灰度不少于相应的输入灰度，防止灰度反变换时产生的人为缺陷</p>
<p>条件（2）保证灰度的输出范围与输入范围一致，且是一对一的映射关系，防止二义性</p>
</li>
<li><p>7.对于连续灰度值：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201010302.png" alt="image-20210620201010302"><br>对于离散灰度值:<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201019248.png" alt="image-20210620201019248"><br>(P76 【例3.5】！)</p>
</li>
<li><p>8.直方图规定化：希望处理后的图像具有<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">规定的直方图形状</span></span>，这种用于产生处理后有特殊直方图的方法，称为直方图匹配或直方图规定化。<br>（P80 【例 3.8】）</p>
</li>
<li><p>9.镜头检测方法：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">连续帧相减、直方图相减、时空切片分析</span></span></p>
</li>
<li><p>10.镜头：是指一系列连续记录的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像帧</span></span>，用于表示一个时间段或相同地点连续的动作。</p>
</li>
<li><p>11.连续帧相减：<br>(1)算法原理：计算相邻两帧<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">像素</span></span>变化的数目。当超过设定的阈值时，即找到镜头的边缘。<br>(2)缺点：对摄像机运动敏感，如放缩、平移<br>(3)解决办法：通过滤波器的使用来降低。在比较一帧的每个像素前，用它的邻近区域的平均值来代替，这也就过滤了输入图像的一些噪声。</p>
</li>
<li><p>12.直方图相减<br>(1)算法原理：统计相邻两帧中所有像素在不同灰度上的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">分布差异</span></span>，当差异的累加值超过阈值T时，即检测到镜头边缘。<br>(2)优点：对对象运动不敏感，因为直方图忽略了帧内的空间变化。<br>(3)缺点：可能两个图像有类似的直方图但却是完全不同的内容。然而这种事件概率是足够低的。</p>
</li>
<li><p>13.空间滤波和空间滤波器的定义 使用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间模板</span></span>进行的图像处理，被称为 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间滤波</span></span>。模板本身被称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间滤波器</span></span>（空间滤波器：邻域与预操作的集合）</p>
</li>
<li><p>14.<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201142147.png" alt="image-20210620201142147"></p>
</li>
</ul>
<p>其中w是滤波器系数，z是该系数对应的图像灰度值。</p>
<ul>
<li><p>15.平滑空间滤波器：<br>（1）线性滤波器：均值滤波器<br>（2）非线性滤波器：最大值滤波器、中值滤波器、最小值滤波器</p>
</li>
<li><p>16.均值滤波器：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">包含在滤波器邻域内像素的平均值</span></span> （用像素领域内的平均值代替该像素）<br>作用：减小图像灰度的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">“尖锐”</span></span>变化，减小<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">噪声</span></span>；边缘模糊<br>公式：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201443661.png" alt="image-20210620201443661"></p>
</li>
</ul>
<ul>
<li>17.统计排序滤波器：<br>是一种非线性滤波器，基于滤波器所在图像区域中<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">像素的排序</span></span>，由 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">排序结果决定的值</span></span>代替中心像素的值</li>
</ul>
<p>（1）中值滤波器：用像素领域内的中间值代替该像素<br>①用途：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">去除噪声</span></span><br>②公式：R = mid {zk | k = 1,2,…,n}<br>③<br>特点：在去除噪音的同时，可以比较好地保留<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">边的锐度</span></span>和<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像的细节</span></span>（优于均值滤波器）<br>能够有效去除<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">脉冲噪声</span></span>：以黑白点叠加在图像上</p>
<p>（2）最大值滤波器：用像素领域内的最大值代替该像素<br>①用途：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">寻找最亮点</span></span><br>②公式：R = max {zk | k = 1,2,…,n} </p>
<p>（3）最小值滤波器：用像素领域内的最小值代替该像素<br>①用途：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">寻找最暗点</span></span><br>②公式：R = min {zk | k = 1,2,…,n}</p>
<ul>
<li><p>18.锐化滤波器的应用：<br>突出图像中的细节，增强被模糊了的细节<br>✓ 印刷中的细微层次强调。弥补扫描对图像的钝化<br>✓ 超声探测成像，分辨率低，边缘模糊，通过锐化来改善<br>✓ 图像识别中，分割前的边缘提取<br>✓ 锐化处理恢复过度钝化、暴光不足的图像<br>✓ 尖端武器的目标识别、定位</p>
</li>
<li><p>19.二阶微分滤波器–拉普拉斯算子<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps1.jpg" alt="img"><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps2.jpg" alt="img"></p>
</li>
<li><p>20.一阶微分滤波器–梯度算子</p>
</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps3.jpg" alt="img"></p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps4.jpg" alt="img"></p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps5.jpg" alt="img"></p>
<h1 id="第六章-彩色图像处理"><a href="#第六章-彩色图像处理" class="headerlink" title="第六章 彩色图像处理"></a>第六章 彩色图像处理</h1><ul>
<li><p>1.为什么要研究彩色图像处理？<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">符合人类视觉特点：人类可以辨别几千种彩色色调和亮度；但相比之下只能辨别几十种灰度层次</span></span><br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">强有力的描绘子：常常可以简化从场景中提取和识别目标</span></span></p>
</li>
<li><p>2.彩色图像处理分为：全彩色图像处理、伪彩色图像处理</p>
</li>
<li><p>3.三原色：红、绿、蓝<br>二次色:    红+蓝=<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">深红M</span></span>        红+绿=<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">黄Y</span></span>        绿+蓝=<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">青色C</span></span></p>
</li>
<li><p>4.描述彩色光源质量的三个基本量：<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">辐射</span></span>（率）：从光源流出能量的总和，用瓦特（W）度量<br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">光强</span></span>：观察者从光源感知的（接收的）能量总和，用流明来度量<br>(3)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">亮度</span></span>：主观描绘子。实际上是不可能度量的，用来表示无色的强度概念。</p>
</li>
<li><p>5.用于区分不同颜色特性的基本量：<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">亮度</span></span>：具体表达了无色的强度概念<br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">色调</span></span>：是混合光波中与主波长有关的属性，表明观察者感知的主要颜色<br>(3)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">饱和度</span></span>：指的是相对纯净度，或一种颜色混合白光的数量。纯谱色是全饱和的。</p>
</li>
<li><p>6.彩色模型（彩色空间、彩色系统）<br>在某些标准下，用通常可以接收的方式方便地对彩色加以说明。本质上是对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">坐标系统</span></span>和<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">子空间</span></span>的说明。</p>
<p>现在大多数的彩色模型不是面向硬件的，就是面向应用的。</p>
</li>
<li><p>7.RGB（红绿蓝模型）<br>(1)用于彩色监视器和一大类彩色视频摄像机；<br>(2)是图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">成像、显示、打印</span></span>等设备的基础<br>(3)面向硬件</p>
</li>
<li><p>8.CMY和CMYK（青、深红、黄、黑）<br>(1)用于彩色<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">打印机</span></span>和<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">复印机</span></span><br>(2)为什么用CMYK：等量的CMY原色产生黑色，但不纯</p>
</li>
<li><p>9.HSI（色调、饱和度、亮度）<br>(1)特点：<br>①I（亮度）分量与图像的彩色信息无关（解除分量中灰度I和颜色HS的联系）<br>②H和S分量与人感受颜色的方式是紧密联系的<br>(2)应用于计算机视觉、图像检索、视频检索</p>
</li>
<li><p>10.彩色空间转换</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623221945843.png" alt="image-20210623221945843"></p>
</li>
<li><p>11.什么叫伪彩色图像处理？</p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">也叫假彩色图像处理，根据一定的准则对灰度值赋予彩色的处理</span></span>



<p>为什么需要伪彩色图像处理？</p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">人类可以辨别几千种彩色色调和亮度；但相比之下只能辨别几十种灰度层次</span></span></li>
<li><p>12.怎样进行伪彩色图像处理？</p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">强度（强度）分层技术</span></span>、<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">灰度级到彩色的转换</span></span></li>
<li><p>13.全彩色图像处理分类<br>(1)分别处理每一分量，然后合成彩色图像<br>(2)直接对彩色像素处理</p>
</li>
<li><p>14补色：在彩色环上，与一种的色调H<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">直接相对立</span></span>的另外一种色调</p>
</li>
</ul>
<h1 id="第八章-图像压缩"><a href="#第八章-图像压缩" class="headerlink" title="第八章 图像压缩"></a>第八章 图像压缩</h1><ul>
<li><p>1.为什么需要图像压缩？<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像的数据量通常很大，对存储、处理和传输带来许多问题</span></span><br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">不断扩大的图像应用</span></span></p>
</li>
<li><p>2.图像压缩分类<br>(1)无损压缩：在压缩和解压缩过程中没有信息损失<br>(2)有损压缩：能取得较高的压缩率，但压缩后不能通过解压缩恢复原状</p>
</li>
<li><p>3.压缩方法：预测编码方法、变换编码方法</p>
</li>
<li><p>4.数据冗余：<br>数据是用来表示信息的。如果不同的方法为表示给定量的信息使用了不同的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数据量</span></span>，那么使用较多数据量的方法中，有些数据必然是代表了无 用的信息，或者是重复地表示了其它数据已表示的信息，这就是数据冗余的概念</p>
</li>
<li><p>5.公式（相对数据冗余与压缩率的关系）</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps6.jpg" alt="img"><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps7.jpg" alt="img"></p>
</li>
<li><p>6.三种基本的数据冗余<br>（1）编码冗余<br>如果一个图像的灰度级编码，使用了多于<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">实际需要的编码符号</span></span>，就称该图像包含了编码冗余<br>（2）像素间冗余<br>对于一幅图像，很多<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">单个像素对视觉的贡献</span></span>是冗余的。它的值可以通过与它相邻的像素值为基础进行预测<br>（3）心理视觉冗余<br>有些信息在<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">通常的视觉过程中</span></span>通常的视觉过程中与另外一些信息相比并不那么重要，这些信息被认为是心理 视觉冗余的，去除这些信息并不会明显降低图像质量</p>
</li>
<li><p>7.保真度准则：<br>图像压缩可能会导致信息损失，需要有<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">评价信息损失</span></span>的测度，以描述解码图像相<br>对于原始图像的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">偏离程度</span></span>，这些测度称为保真度准则（量化信息丢失的本质的方法）<br>（1）均方根误差</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps8.jpg" alt="img"></p>
<p>（2）均方信噪比</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps9.jpg" alt="img"></p>
</li>
<li><p>8.图像压缩系统的功能流程图</p>
</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps10.jpg" alt="img"></p>
<ul>
<li>9.图像压缩系统模型（简）</li>
</ul>
<p>编码器：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps11.jpg" alt="img"></p>
<p>解码器：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps12.jpg" alt="img"></p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">转换器</span></span>（映射器）：减少像素间冗余
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">量化器</span></span>：减少心理视觉冗余，该步操作不可逆
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">符号编码器</span></span>：减少编码冗余
<p>（进行无损压缩时，去掉量化器）</p>
<ul>
<li>10.信源的熵：<br>每个信源输出的平均信息。</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps13.jpg" alt="img"></p>
<ul>
<li><p>11.变长编码：<br>(1)减少编码冗余<br>(2)变长编码，即把<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">最短的码字</span></span>赋予给<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">出现概率最大</span></span>的灰度级</p>
</li>
<li><p>12.霍夫曼编码（步骤）<br>(1)第一步：将所有需要考虑的符号进行概率排序，并将最低概率的符号合并为一个符号来替代下次信源化简过程中的符号，从而创建一个信源化简系统；<br>(2)第二步：对每个化简后的信源进行编码，从小的信源开始一直编码到原始信源。<br>(3)P346 【例】</p>
</li>
<li><p>13.LZW编码（消除像素间冗余/空间冗余）<br>将原始数据中的重复字符串建立一个字串表，然后用该重复字串在字串表中的索引替代原始数据达到压缩的目的。<br>P351</p>
</li>
</ul>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><ul>
<li>补色和反色</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">im = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">im_converted_mat = np.zeros_like(im, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(im.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(im.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="comment"># 补色公式max(r,g,b)+min(r,g,b)-[r,g,b]</span></span><br><span class="line">        maxrgb = im[x][y].<span class="built_in">max</span>()</span><br><span class="line">        minrgb = im[x][y].<span class="built_in">min</span>()</span><br><span class="line">        im_converted_mat[x][y] = (<span class="built_in">int</span>(maxrgb) + <span class="built_in">int</span>(minrgb)) * np.ones(<span class="number">3</span>) - im[x][y]</span><br><span class="line"></span><br><span class="line"><span class="comment">#反色公式[255,255,255]-[r,g,b]</span></span><br><span class="line">im_converted_mat2 = np.ones_like(im) * <span class="number">255</span> - im</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;ori&#x27;</span>, im)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;buse&#x27;</span>, im_converted_mat)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;fanse&#x27;</span>, im_converted_mat2)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;buse.jpg&#x27;</span>, im_converted_mat)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;fanse.jpg&#x27;</span>, im_converted_mat2)</span><br><span class="line">cv2.waitKey()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<ul>
<li>直方图均衡化Histogram</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img=cv.imread(<span class="string">&quot;his.jpg&quot;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">gray_static=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">width,height=np.shape(img) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        gray_static[img[i,j]]+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">n=width*height</span><br><span class="line"></span><br><span class="line"><span class="comment">#pdf（概率密度函数）用来存储每个灰度值出现的概率（比例），像素个数/总像素个数</span></span><br><span class="line">pdf=[i/n <span class="keyword">for</span> i <span class="keyword">in</span> gray_static]</span><br><span class="line"></span><br><span class="line"><span class="comment">#cdf（累计分布函数），用来存储每个灰度值的累计分布函数值</span></span><br><span class="line">cdf=pdf</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    cdf[i]=cdf[i]+cdf[i-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#直方图均衡化转化</span></span><br><span class="line">img_t=np.copy(img)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):   </span><br><span class="line">        img_t[i,j]=<span class="number">255</span>*cdf[img[i,j]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制并显示直方图</span></span><br><span class="line">plt.hist(img.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"><span class="comment">#plt.show()</span></span><br><span class="line">plt.hist(img_t.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;img&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;img_t&#x27;</span>,img_t)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<ul>
<li>均值滤波</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps14.jpg" alt="img"></p>
<ul>
<li>中值滤波</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps15.jpg" alt="img"></p>
<ul>
<li><p>锐化滤波</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps16.jpg" alt="img"></p>
</li>
</ul>
<ul>
<li><p>图像的熵</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps17.jpg" alt="img"></p>
</li>
</ul>
<ul>
<li>LZW-encode</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623235657253.png" alt="image-20210623235657253"></p>
<ul>
<li>LZW-decode</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623235728790.png" alt="image-20210623235728790"></p>
]]></content>
      <categories>
        <category>《数字图像处理》</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程并发</title>
    <url>/2021/06/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>问题描述：1个父线程，并发生成N（N作为参数传入）个子线程。设定全局变量 g_sum=0，每个子进程在 0至200中随机选择一个数；</p>
<p>若子线程的进程ID是奇数则g_sum=g_sum-随机数，<br>若子线程的进程ID是偶数则g_sum=g_sum+随机数，</p>
<p>每个子线程对g_sum操作完成后都要通知父线程，父线程收到通知后输出“子线程{进程ID}对g_sum进行了[加/减]{随机数}操作，当前g_sum={新值}”，父进程将每次g_sum的新值进行记录，并对已记录的数组进行升序排列，每次重新排列后进行一次输出。</p>
</div>



<h1 id="想法一-回调方式"><a href="#想法一-回调方式" class="headerlink" title="想法一  回调方式"></a>想法一  回调方式</h1><ul>
<li><h2 id="ThreadTest-java"><a href="#ThreadTest-java" class="headerlink" title="ThreadTest.java"></a>ThreadTest.java</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> g_sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; g_sumList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Object o= <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.g_sumList.add(g_sum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *子线程回调函数 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> id 进程id</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> num 加或减的数值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> flag	加或减的标志</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callBack</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> num, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">		String mark = flag == <span class="number">1</span> ? <span class="string">&quot;加&quot;</span> : <span class="string">&quot;减&quot;</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;子线程&quot;</span> + id + <span class="string">&quot;:对g_num进行了&quot;</span> + mark + <span class="string">&quot;&quot;</span> + num + <span class="string">&quot;操作，当前g_sum=&quot;</span> + g_sum);</span><br><span class="line">		<span class="comment">//将值记录到列表并排序，输出</span></span><br><span class="line">		g_sumList.add(g_sum);</span><br><span class="line">		Collections.sort(g_sumList);</span><br><span class="line">		SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();		<span class="comment">// 格式化时间 </span></span><br><span class="line">        sdf.applyPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss a&quot;</span>);			<span class="comment">// a为am/pm的标记  </span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();								<span class="comment">// 获取当前时间 </span></span><br><span class="line">		System.out.println(sdf.format(date)+<span class="string">&quot; g_sum历史值升序为：&quot;</span>);</span><br><span class="line">		System.out.println(g_sumList);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建N个子线程</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">generateThreads</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> randomNum;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> id = <span class="number">1</span>; id &lt;= N; id++) &#123;</span><br><span class="line">			randomNum = (<span class="keyword">int</span>) (Math.random() * <span class="number">200</span>);</span><br><span class="line">			<span class="comment">//通过自定义的Runnable类创建线程</span></span><br><span class="line">			MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable(id, randomNum);</span><br><span class="line">			Thread t=<span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadTest test = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">		test.generateThreads(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="MyRunnable-java"><a href="#MyRunnable-java" class="headerlink" title="MyRunnable.java"></a>MyRunnable.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> randomNum;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> randomNum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.randomNum = randomNum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (ThreadTest.o) &#123;	<span class="comment">//加同步锁，防止多个线程对g_sum操作造成脏读</span></span><br><span class="line">			<span class="keyword">if</span> (id % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				ThreadTest.g_sum += randomNum;</span><br><span class="line">				ThreadTest.callBack(id, randomNum, <span class="number">1</span>);				</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ThreadTest.g_sum -= randomNum;</span><br><span class="line">				ThreadTest.callBack(id, randomNum, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2></li>
</ul>
<img src="/2021/06/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/image-20210623000217372.png" alt="image-20210623000217372" style="zoom:80%;">

<div class="note warning simple"><p>子线程和父线程之间其实并没有进行通信，打印信息的静态回调方法callBack()虽然是在主类中定义，但是却是在子线程中调用的，而不是子线程将信息传递并通知给主线程，然后主线程打印。</p>
</div>



<h1 id="想法二-消息队列"><a href="#想法二-消息队列" class="headerlink" title="想法二  消息队列"></a>想法二  消息队列</h1><ul>
<li><h2 id="ThreadTest-java-1"><a href="#ThreadTest-java-1" class="headerlink" title="ThreadTest.java"></a>ThreadTest.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> g_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Deque&lt;Message&gt; messageDeque = <span class="keyword">new</span> ArrayDeque();</span><br><span class="line"> 	<span class="keyword">public</span>  List&lt;Integer&gt; g_sumList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> Object lock= <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">super</span>();</span><br><span class="line"> 		<span class="keyword">this</span>.g_sumList.add(g_sum);</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">//N个子线程并发创建执行</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">generateThreads</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">int</span> randomNum;</span><br><span class="line"> 		<span class="keyword">for</span> (<span class="keyword">int</span> id = <span class="number">1</span>; id &lt;= N; id++) &#123;</span><br><span class="line"> 			randomNum = (<span class="keyword">int</span>) (Math.random() * <span class="number">200</span>);</span><br><span class="line"> 			<span class="comment">//通过自定义的Runnable类创建线程</span></span><br><span class="line"> 			MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable(id, randomNum);</span><br><span class="line"> 			Thread t=<span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line"> 			t.start();</span><br><span class="line"> 		&#125;		</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> 		System.out.print(<span class="string">&quot;请输入问题规模：&quot;</span>);</span><br><span class="line"> 		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> 		<span class="keyword">int</span> N = in.nextInt();</span><br><span class="line"> 		ThreadTest test = <span class="keyword">new</span> ThreadTest();</span><br><span class="line"> 		<span class="keyword">synchronized</span> (lock) &#123;						<span class="comment">//加同步锁</span></span><br><span class="line"> 			test.generateThreads(N);				<span class="comment">//在主线程中并发创建N个进程</span></span><br><span class="line"> 			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"> 				<span class="keyword">if</span>(messageDeque.isEmpty()) &#123;</span><br><span class="line"> 					lock.wait();					<span class="comment">//消息队列为空时，主线程阻塞等待，等待lock解锁</span></span><br><span class="line"> 				&#125;												</span><br><span class="line"> 				<span class="keyword">while</span>(!messageDeque.isEmpty()) &#123;		</span><br><span class="line"> 					<span class="comment">//主线程从消息队列中取出消息并打印</span></span><br><span class="line"> 					Message mess = messageDeque.pop();</span><br><span class="line"> 					System.out.println(<span class="string">&quot;子线程&quot;</span>+mess.tid+<span class="string">&quot;进行了&quot;</span>+mess.op+<span class="string">&quot;&quot;</span>+mess.randomNum+<span class="string">&quot;操作，当前g_sum=&quot;</span>+mess.g_sum);</span><br><span class="line"> 					<span class="comment">//将g_sum的历史值记录到列表并排序</span></span><br><span class="line"> 					test.g_sumList.add(mess.g_sum);</span><br><span class="line"> 					Collections.sort(test.g_sumList);</span><br><span class="line"> 					<span class="comment">//打印g_sum的历史值列表</span></span><br><span class="line"> 					System.out.println(mess.opeTime+<span class="string">&quot; g_sum历史值升序为：&quot;</span>);</span><br><span class="line"> 					System.out.println(test.g_sumList);</span><br><span class="line"> 					System.out.println();</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="MyRunnable-java-1"><a href="#MyRunnable-java-1" class="headerlink" title="MyRunnable.java"></a>MyRunnable.java</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tid;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> randomNum;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> randomNum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.tid = id;</span><br><span class="line">		<span class="keyword">this</span>.randomNum = randomNum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (ThreadTest.lock) &#123;						<span class="comment">//加同步锁，防止多个线程同时（并发）对g_sum操作造成脏读</span></span><br><span class="line">			SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();		<span class="comment">// 格式化时间 </span></span><br><span class="line">	        sdf.applyPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss a&quot;</span>);			<span class="comment">// a为am/pm的标记  								</span></span><br><span class="line">	        String opeTime = sdf.format(<span class="keyword">new</span> Date());			<span class="comment">// 获取当前时间 </span></span><br><span class="line">	        </span><br><span class="line">			<span class="keyword">if</span> (tid % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				ThreadTest.g_sum += randomNum;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//创建一个消息，并添加到消息队列</span></span><br><span class="line">				Message message = <span class="keyword">new</span> Message(tid, <span class="string">&quot;加&quot;</span>, randomNum,ThreadTest.g_sum,opeTime);</span><br><span class="line">				ThreadTest.messageDeque.add(message);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//解锁，唤醒主线程，可以从消息队列取消息啦</span></span><br><span class="line">				ThreadTest.lock.notifyAll();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ThreadTest.g_sum -= randomNum;</span><br><span class="line">							</span><br><span class="line">				Message message = <span class="keyword">new</span> Message(tid, <span class="string">&quot;减&quot;</span>, randomNum,ThreadTest.g_sum,opeTime);</span><br><span class="line">				ThreadTest.messageDeque.add(message);</span><br><span class="line">				</span><br><span class="line">				ThreadTest.lock.notifyAll();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> sleepTime = (<span class="keyword">int</span>)(Math.random() * <span class="number">500</span>);			<span class="comment">//让线程随机休眠一定时间</span></span><br><span class="line">				Thread.sleep(sleepTime);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//子线程传递给父线程的消息类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> tid;				<span class="comment">//子线程id</span></span><br><span class="line">		<span class="keyword">public</span> String op;			<span class="comment">//加或减操作</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> randomNum;		<span class="comment">//随机数</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> g_sum;			<span class="comment">//操作后的g_sum</span></span><br><span class="line">		<span class="keyword">public</span> String opeTime;		<span class="comment">//操作时的时间</span></span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> tid, String op, <span class="keyword">int</span> randomNum,<span class="keyword">int</span> g_sum ,String time)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.tid = tid;</span><br><span class="line">			<span class="keyword">this</span>.op = op;</span><br><span class="line">			<span class="keyword">this</span>.randomNum = randomNum;</span><br><span class="line">			<span class="keyword">this</span>.g_sum = g_sum;</span><br><span class="line">	        <span class="keyword">this</span>.opeTime=time;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2></li>
</ul>
<img src="/2021/06/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/image-20210623081306586.png" alt="image-20210623081306586" style="zoom: 80%;">

<div class="note success simple"><p>主线程并发创建N个子线程后，转为阻塞等待状态，等待lock解锁获得执行权且消息队列非空，然后一次性打印消息队列中已经存放的消息。</p>
<p>子线程在进行“加减”操作完成后，创建一个消息（包含线程id、随机数、操作类型、操作结果、操作时间信息），并把这个消息添加到消息队列（一个静态全局的队列），然后Notifiy（通知）唤醒主线程，通知它消息队列有消息可以打印了。</p>
</div>]]></content>
      <tags>
        <tag>多线程</tag>
        <tag>JAVA</tag>
        <tag>同步锁</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络实验总结</title>
    <url>/2021/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><div class="tabs" id="基本命令"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#基本命令-1">基本命令</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="基本命令-1"><ul>
<li>回车：进入非特权模式 &gt;</li>
<li>enable: 进入特权模式 Router#</li>
<li>configure terminal: 进入配置状态模式Router(config)#</li>
<li>interface fastEthernet 0/1：进入接口配置状态Router(config-if)#</li>
<li>ip address  202.168.1.254  255.255.255.0：配置接口IP地址</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h1><div class="tabs" id="配置路由器"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#配置路由器-1">静态配置</button></li><li class="tab"><button type="button" data-href="#配置路由器-2">RIP</button></li><li class="tab"><button type="button" data-href="#配置路由器-3">OSPF</button></li><li class="tab"><button type="button" data-href="#配置路由器-4">OSPF+RIP</button></li><li class="tab"><button type="button" data-href="#配置路由器-5">EIGRP</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="配置路由器-1"><ul>
<li><p>静态配置：(config)#ip route &lt;网络号&gt; &lt;掩码&gt; &lt;下一跳&gt;</p>
</li>
<li><p>RIP：</p>
<ul>
<li>(config)#router RIP<br>(config-router)#network 192.168.1.0<br>(config-router)#network 192.168.3.0<br>(config-router)#ver 2<br>(config-router)#no auto-summary</li>
</ul>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-2"><ul>
<li>RIP：<ul>
<li>(config)#router RIP<br>(config-router)#network 192.168.1.0<br>(config-router)#network 192.168.3.0<br>(config-router)#ver 2<br>(config-router)#no auto-summary</li>
</ul>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-3"><ul>
<li>–R3<br> (config)#router OSPF 100        //100是进程ID<br> (config-router)#network  192.168.1.0  0.0.0.255  area  1<br> (config-router)#network  192.168.4.0  0.0.0.255  area  1<br> （特别注意area不要弄错！！！）</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-4"><ul>
<li>在路由器R4上左侧配置RIP V2路由协议；右侧配置OSPF协议<br> —-R4<br> (config) #router ospf 100<br> (config-router) #network 192.168.3.0 0.0.0.255 area 2<br> (config-router) #network 192.168.7.0 0.0.0.255 area 2<br> (config-router) #redistribute rip metric 10 subnets  //将RIP路由重分布给OSPF路由协议<br> (config-router)#exit<br> (config) #router rip<br> (config-router) #network 192.168.7.0<br> (config-router) #ver 2<br> (config-router) #no auto-s<br> (config-router) #redistribute ospf 100 matric 10    //将OSPF路由重分布给RIP路由协议</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-5"><ul>
<li>Router#conf t<br> Router(config)#router eigrp 100                        //启动EIGRP路由协议<br> Router(config-router)#network 202.192.0.0        //宣告直连主类网络号<br> Router(config-router)#network 202.192.1.0</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="NAT地址转换"><a href="#NAT地址转换" class="headerlink" title="NAT地址转换"></a>NAT地址转换</h1><div class="tabs" id="nat地址转换"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#nat地址转换-1">NAT地址转换</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="nat地址转换-1"><ul>
<li>（1）定义NAT设备（路由器）的内外接口<br>  （config）int f0/0<br>  （config-if）ip nat inside<br>  （config）int f0/1<br>  （config-if）ip nat outside </li>
<li>（2）定义NAT地址池<br>  — ip nat pool pool-name start-ip  end-ip netmask 子网掩码<br>  （config）ip nat pool out 202.106.0.4  202.106.0.24 netmask 255.255.255.0  </li>
<li>（3）利用ACL(地址控制列表Address Control List)定义允许转换的本地地址列表<br>  — access-list ACL号 permit  &lt;网段&gt;  &lt;子网掩码反码&gt;<br>  （config）access-list 10 permit 192.168.0.0 0.0.0.255</li>
<li>（4）定义内部本地地址与内部全局地址的转换关系<br>  （config）ip nat inside source list 10 pool out</li>
<li>（5） 配置静态地址转换<br>  （config）ip nat inside source static 192.168.0.1  202.106.0.3<br>  （config）ip nat outside source static 202.106.0.3 192.168.0.1 </li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="FTP服务"><a href="#FTP服务" class="headerlink" title="FTP服务"></a>FTP服务</h1><div class="tabs" id="ftp服务"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ftp服务-1">FTP服务</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ftp服务-1"><ul>
<li>ftp FTP服务器域名</li>
<li>Username：</li>
<li>Password:</li>
<li>dir:查看文件</li>
<li>get 文件名：下载文件</li>
<li>put 文件名：上传文件</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="Telnet远程登录"><a href="#Telnet远程登录" class="headerlink" title="Telnet远程登录"></a>Telnet远程登录</h1><div class="tabs" id="telnet远程登录"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#telnet远程登录-1">Telnet远程登录</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="telnet远程登录-1"><ul>
<li><p>1.配置路由器启动Telnet服务的基本流程<br>（通过配置线连接PC主机RS232和路由器console接口进行配置）</p>
<p>（1）设置“特权模式”使能加密密码：<br>Router(config)#enable secret 123</p>
<p>（2）设置控制台（console配置线）密码：<br>Router(config)#line console 0<br>Router(config-line)#password 456<br>Router(config-line)#login<br>Router(config-line)#exit</p>
<p>（3）设置远程登陆密码：<br>Router(config)#line vty 0 4<br>Router(config-line)#password 789<br>Router(config-line)#login<br>Router(config-line)#exit</p>
</li>
<li><p>2.通过PC主机远程登录到路由器<br>PC&gt;telnet 202.192.0.254<br>Password: 789<br>Router&gt;enable<br>Password: 12<br>Router#</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnGitBranch</title>
    <url>/2021/07/10/LearnGitBranch/</url>
    <content><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="Git-commit-提交"><a href="#Git-commit-提交" class="headerlink" title="Git commit(提交)"></a>Git commit(提交)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210707180217632.png" alt="image-20210707180217632"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180229217.png" alt="image-20210707180229217"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180240632.png" alt="image-20210707180240632"></p>
<h2 id="Git-Branch-分支"><a href="#Git-Branch-分支" class="headerlink" title="Git Branch(分支)"></a>Git Branch(分支)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210707180311964.png" alt="image-20210707180311964"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180321593.png" alt="image-20210707180321593"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180338498.png" alt="image-20210707180338498"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180354850.png" alt="image-20210707180354850"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180409051.png" alt="image-20210707180409051"></p>
<p><font color="red">git checkout -b bugFix</font></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708092926600.png" alt="image-20210708092926600"></p>
<h2 id="Git-Merge-合并1"><a href="#Git-Merge-合并1" class="headerlink" title="Git Merge(合并1)"></a>Git Merge(合并1)</h2><p>把<youBranch>合并到当前分支</youBranch></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180502520.png" alt="image-20210707180502520"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180520116.png" alt="image-20210707180520116"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180535801.png" alt="image-20210707180535801"></p>
<h2 id="Git-Rebase-合并2"><a href="#Git-Rebase-合并2" class="headerlink" title="Git Rebase(合并2)"></a>Git Rebase(合并2)</h2><p>把当前分支里的工作合并（复制）到<youbranch></youbranch></p>
<p>git rebase branch1 branch2：将分支2的提交合并到分支1</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180641790.png" alt="image-20210707180641790"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180657215.png" alt="image-20210707180657215"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180715217.png" alt="image-20210707180715217"></p>
<h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="Git-checkout-在提交树上移动"><a href="#Git-checkout-在提交树上移动" class="headerlink" title="Git checkout(在提交树上移动)"></a>Git checkout(在提交树上移动)</h2><p>HEAD:是对当前提交记录的符号引用</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707181102379.png" alt="image-20210707181102379"></p>
<p>通过指定提交记录哈希值（如C1 C2）的方式在 Git 中移动</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182107038.png" alt="image-20210707182107038"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182131190.png" alt="image-20210707182131190"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182148057.png" alt="image-20210707182148057"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182202895.png" alt="image-20210707182202895"></p>
<h2 id="相对引用1（-）"><a href="#相对引用1（-）" class="headerlink" title="相对引用1（^）"></a>相对引用1（^）</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210707182718057.png" alt="image-20210707182718057"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182755760.png" alt="image-20210707182755760"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182857052.png" alt="image-20210707182857052"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182916539.png" alt="image-20210707182916539"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182947454.png" alt="image-20210707182947454"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707183002457.png" alt="image-20210707183002457"></p>
<h2 id="相对引用2（-）"><a href="#相对引用2（-）" class="headerlink" title="相对引用2（~）"></a>相对引用2（~）</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708094914804.png" alt="image-20210708094914804"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708094927037.png" alt="image-20210708094927037"></p>
<p>强制修改分支位置:git branch -f <yourbranch> <yourdestination></yourdestination></yourbranch></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708094944297.png" alt="image-20210708094944297"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708094957557.png" alt="image-20210708094957557"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708095006899.png" alt="image-20210708095006899"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708095740561.png" alt="image-20210708095740561"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708095752419.png" alt="image-20210708095752419"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -f main c6</span><br><span class="line">git checkout HEAD^</span><br><span class="line">git branch -f bugFix HEAD^</span><br></pre></td></tr></table></figure>



<h2 id="Git-reset-Git-revert-撤销变更"><a href="#Git-reset-Git-revert-撤销变更" class="headerlink" title="Git reset|Git revert(撤销变更)"></a>Git reset|Git revert(撤销变更)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708100028520.png" alt="image-20210708100028520"></p>
<ul>
<li>git Reset:用于本地</li>
</ul>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100107026.png" alt="image-20210708100107026"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100127317.png" alt="image-20210708100127317"></p>
<ul>
<li>git revert:用于远程，将记录的撤销（回退）记录加到当前分支记录</li>
</ul>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100137372.png" alt="image-20210708100137372"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100205219.png" alt="image-20210708100205219"></p>
<h1 id="移动提交记录"><a href="#移动提交记录" class="headerlink" title="移动提交记录"></a>移动提交记录</h1><h2 id="Git-cherry-pick-整理提交记录"><a href="#Git-cherry-pick-整理提交记录" class="headerlink" title="Git cherry-pick(整理提交记录)"></a>Git cherry-pick(整理提交记录)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708101132784.png" alt="image-20210708101132784"></p>
<p>把一些提交号复制到当前位置</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101213736.png" alt="image-20210708101213736"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101302552.png" alt="image-20210708101302552"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101313112.png" alt="image-20210708101313112"></p>
<h2 id="Git-rebase-i-交互式的-rebase"><a href="#Git-rebase-i-交互式的-rebase" class="headerlink" title="Git rebase -i (交互式的 rebase)"></a>Git rebase -i (交互式的 rebase)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708101514919.png" alt="image-20210708101514919"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101619930.png" alt="image-20210708101619930"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101644114.png" alt="image-20210708101644114"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101657579.png" alt="image-20210708101657579"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101750066.png" alt="image-20210708101750066"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101847656.png" alt="image-20210708101847656"></p>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708102217807.png" alt="image-20210708102217807"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708102740387.png" alt="image-20210708102740387"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708102759444.png" alt="image-20210708102759444"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708102807847.png" alt="image-20210708102807847"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line"></span><br><span class="line">git cherry-pick c5 或 git cherry-pick bugFix</span><br></pre></td></tr></table></figure>



<h2 id="提交的技巧-1"><a href="#提交的技巧-1" class="headerlink" title="提交的技巧 #1"></a>提交的技巧 #1</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708103425969.png" alt="image-20210708103425969"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708103558144.png" alt="image-20210708103558144"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708104016852.png" alt="image-20210708104016852"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708104024797.png" alt="image-20210708104024797"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br><span class="line">调整C2 C3</span><br><span class="line">//进行一些小修改</span><br><span class="line">git commit --amend</span><br><span class="line">git rebase -i HEAD~2</span><br><span class="line">调整C2&#x27;&#x27; C3</span><br><span class="line">//将main移动到修改的最前端</span><br><span class="line">git rebase caption main</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/10/LearnGitBranch/image-20210708104217724.png" alt="image-20210708104217724"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105041296.png" alt="image-20210708105041296"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105110953.png" alt="image-20210708105110953"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105235499.png" alt="image-20210708105235499"></p>
<h2 id="提交的技巧-2"><a href="#提交的技巧-2" class="headerlink" title="提交的技巧 #2"></a>提交的技巧 #2</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708105329986.png" alt="image-20210708105329986"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105350522.png" alt="image-20210708105350522"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105409069.png" alt="image-20210708105409069"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105427238.png" alt="image-20210708105427238"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git cherry-pick C2</span><br><span class="line">git commit --amend</span><br><span class="line">git cherry-pick C3</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/10/LearnGitBranch/image-20210708110350766.png" alt="image-20210708110350766"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110400360.png" alt="image-20210708110400360"></p>
<h2 id="Git-Tags"><a href="#Git-Tags" class="headerlink" title="Git Tags"></a>Git Tags</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708110500402.png" alt="image-20210708110500402"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110931071.png" alt="image-20210708110931071"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110943859.png" alt="image-20210708110943859"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110956301.png" alt="image-20210708110956301"></p>
<h2 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708111252981.png" alt="image-20210708111252981"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708111345615.png" alt="image-20210708111345615"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708111406212.png" alt="image-20210708111406212"></p>
<h1 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h1><h2 id="多分支-rebase"><a href="#多分支-rebase" class="headerlink" title="多分支 rebase"></a>多分支 rebase</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708113031307.png" alt="image-20210708113031307"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708113047650.png" alt="image-20210708113047650"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708113057624.png" alt="image-20210708113057624"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase main bugFix</span><br><span class="line">git rebase bugFIx side</span><br><span class="line">git rebase side another</span><br><span class="line">git rebase another main</span><br></pre></td></tr></table></figure>



<h2 id="选择父提交记录"><a href="#选择父提交记录" class="headerlink" title="选择父提交记录"></a>选择父提交记录</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708122019936.png" alt="image-20210708122019936"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122034460.png" alt="image-20210708122034460"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122053452.png" alt="image-20210708122053452"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122106658.png" alt="image-20210708122106658"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122508583.png" alt="image-20210708122508583"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122747166.png" alt="image-20210708122747166"></p>
<p>^num是横向移动；~num是纵向移动</p>
<h2 id="纠缠不清的分支"><a href="#纠缠不清的分支" class="headerlink" title="纠缠不清的分支"></a>纠缠不清的分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708124214014.png" alt="image-20210708124214014"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708125303011.png" alt="image-20210708125303011"><img src="/2021/07/10/LearnGitBranch/image-20210708125313507.png" alt="image-20210708125313507"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick C4 C3 C2</span><br><span class="line">git checkout two</span><br><span class="line">git cherry-pick C5 C4 C3 C2</span><br><span class="line">git branch -f three C2</span><br></pre></td></tr></table></figure>



<h1 id="Push-amp-Pull-——-Git-远程仓库！"><a href="#Push-amp-Pull-——-Git-远程仓库！" class="headerlink" title="Push &amp; Pull —— Git 远程仓库！"></a>Push &amp; Pull —— Git 远程仓库！</h1><h2 id="Git-clone"><a href="#Git-clone" class="headerlink" title="Git clone"></a>Git clone</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708131220533.png" alt="image-20210708131220533"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131436712.png" alt="image-20210708131436712"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131503803.png" alt="image-20210708131503803"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131528770.png" alt="image-20210708131528770"></p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708131730919.png" alt="image-20210708131730919"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131814248.png" alt="image-20210708131814248"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131823958.png" alt="image-20210708131823958"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131851696.png" alt="image-20210708131851696"></p>
<h2 id="Git-Fetch-抓取"><a href="#Git-Fetch-抓取" class="headerlink" title="Git Fetch(抓取)"></a>Git Fetch(抓取)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708132039850.png" alt="image-20210708132039850"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132118768.png" alt="image-20210708132118768"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132146200.png" alt="image-20210708132146200"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132156470.png" alt="image-20210708132156470"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132324194.png" alt="image-20210708132324194"></p>
<h2 id="Git-Pull（拉取-抓取-合并）"><a href="#Git-Pull（拉取-抓取-合并）" class="headerlink" title="Git Pull（拉取=抓取+合并）"></a>Git Pull（拉取=抓取+合并）</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708132614877.png" alt="image-20210708132614877"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132632183.png" alt="image-20210708132632183"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132732130.png" alt="image-20210708132732130"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132745265.png" alt="image-20210708132745265"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132847811.png" alt="image-20210708132847811"></p>
<p>git pull=git fetch + git merge</p>
<h2 id="模拟团队合作"><a href="#模拟团队合作" class="headerlink" title="模拟团队合作"></a>模拟团队合作</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708133042614.png" alt="image-20210708133042614"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133055142.png" alt="image-20210708133055142"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133104029.png" alt="image-20210708133104029"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133141450.png" alt="image-20210708133141450"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133506924.png" alt="image-20210708133506924"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133517625.png" alt="image-20210708133517625"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone</span><br><span class="line">git fakeTeamwork 2 </span><br><span class="line">git commit </span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>



<h2 id="Git-Push-推送"><a href="#Git-Push-推送" class="headerlink" title="Git Push(推送)"></a>Git Push(推送)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708133828791.png" alt="image-20210708133828791"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133844106.png" alt="image-20210708133844106"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133914152.png" alt="image-20210708133914152"></p>
<h2 id="偏离的工作"><a href="#偏离的工作" class="headerlink" title="偏离的工作"></a>偏离的工作</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708134026480.png" alt="image-20210708134026480"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134033083.png" alt="image-20210708134033083"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134200396.png" alt="image-20210708134200396"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134240816.png" alt="image-20210708134240816"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134253823.png" alt="image-20210708134253823"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134308393.png" alt="image-20210708134308393"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134516265.png" alt="image-20210708134516265"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134544127.png" alt="image-20210708134544127"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134640963.png" alt="image-20210708134640963"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134741663.png" alt="image-20210708134741663"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134812644.png" alt="image-20210708134812644"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134828932.png" alt="image-20210708134828932"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708135720602.png" alt="image-20210708135720602"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull = git fetch + git merge</span><br><span class="line"></span><br><span class="line">git pull --rebase = git fetch + git rebase</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/10/LearnGitBranch/image-20210708140648399.png" alt="image-20210708140648399"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708140710442.png" alt="image-20210708140710442"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708140725614.png" alt="image-20210708140725614"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141024342.png" alt="image-20210708141024342"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141038183.png" alt="image-20210708141038183"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fake&#x27; Teamwork</span><br><span class="line">objective</span><br><span class="line">git commit</span><br><span class="line">git pull --rebase</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h2 id="远程服务器拒绝-Remote-Rejected"><a href="#远程服务器拒绝-Remote-Rejected" class="headerlink" title="远程服务器拒绝!(Remote Rejected)"></a>远程服务器拒绝!(Remote Rejected)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708141215295.png" alt="image-20210708141215295"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141250110.png" alt="image-20210708141250110"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141325847.png" alt="image-20210708141325847"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142008765.png" alt="image-20210708142008765"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142015998.png" alt="image-20210708142015998"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard o/main</span><br><span class="line">➊在本程序中默认的行为是--hard 硬重置，可</span><br><span class="line">以尽情省略掉那个选项以避免麻烦!但是要记录</span><br><span class="line">Git中默认的是--mixed。</span><br><span class="line">$ git checkout -b feature C2</span><br><span class="line">$ git push origin feature</span><br><span class="line">0 local branch &quot;feature&quot; set to track</span><br><span class="line">remote branch &quot;o/ feature&quot;</span><br></pre></td></tr></table></figure>



<h1 id="关于-origin-和它的周边-——-Git-远程仓库高级操作"><a href="#关于-origin-和它的周边-——-Git-远程仓库高级操作" class="headerlink" title="关于 origin 和它的周边 —— Git 远程仓库高级操作"></a>关于 origin 和它的周边 —— Git 远程仓库高级操作</h1><h2 id="合并特性分支"><a href="#合并特性分支" class="headerlink" title="合并特性分支"></a>合并特性分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708142416567.png" alt="image-20210708142416567"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142507101.png" alt="image-20210708142507101"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142610921.png" alt="image-20210708142610921"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142622769.png" alt="image-20210708142622769"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708143546325.png" alt="image-20210708143546325"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708143555630.png" alt="image-20210708143555630"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git rebase o/main side1</span><br><span class="line">$ git rebase side1 side2</span><br><span class="line">$ git rebase side2 side3</span><br><span class="line">$ git rebase side3 main</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>



<h2 id="合并远程仓库"><a href="#合并远程仓库" class="headerlink" title="合并远程仓库"></a>合并远程仓库</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708144023265.png" alt="image-20210708144023265"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144057908.png" alt="image-20210708144057908"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144131116.png" alt="image-20210708144131116"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144802230.png" alt="image-20210708144802230"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144811391.png" alt="image-20210708144811391"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull</span><br><span class="line">git merge side1</span><br><span class="line">git merge side2</span><br><span class="line">git merge side3</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h2 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708145247050.png" alt="image-20210708145247050"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145254765.png" alt="image-20210708145254765"></p>
<h3 id="1-git-checkout-b-foo-o-main"><a href="#1-git-checkout-b-foo-o-main" class="headerlink" title="1. git checkout -b foo o/main"></a>1. git checkout -b foo o/main</h3><p><img src="/2021/07/10/LearnGitBranch/image-20210708145407891.png" alt="image-20210708145407891"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145459743.png" alt="image-20210708145459743"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145531527.png" alt="image-20210708145531527"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145546365.png" alt="image-20210708145546365"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145612482.png" alt="image-20210708145612482"></p>
<h3 id="2-git-branch-u-o-main-foo"><a href="#2-git-branch-u-o-main-foo" class="headerlink" title="2.git branch -u o/main foo"></a>2.git branch -u o/main foo</h3><p><img src="/2021/07/10/LearnGitBranch/image-20210708145630700.png" alt="image-20210708145630700"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145825968.png" alt="image-20210708145825968"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708150403153.png" alt="image-20210708150403153"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708150412005.png" alt="image-20210708150412005"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b side o/main</span><br><span class="line">git commit</span><br><span class="line">git pull --rebase</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h2 id="Git-Push-的参数"><a href="#Git-Push-的参数" class="headerlink" title="Git Push 的参数"></a>Git Push 的参数</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708150947720.png" alt="image-20210708150947720"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151031205.png" alt="image-20210708151031205"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151130836.png" alt="image-20210708151130836"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151209286.png" alt="image-20210708151209286"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151219562.png" alt="image-20210708151219562"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151234915.png" alt="image-20210708151234915"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151308955.png" alt="image-20210708151308955"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151359962.png" alt="image-20210708151359962"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151407109.png" alt="image-20210708151407109"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin main</span><br><span class="line">git push origin foo</span><br></pre></td></tr></table></figure>



<h2 id="lt-place-gt-参数详解"><a href="#lt-place-gt-参数详解" class="headerlink" title="&lt;place&gt;参数详解"></a><code>&lt;place&gt;</code>参数详解</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708151517814.png" alt="image-20210708151517814"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151558370.png" alt="image-20210708151558370"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151630372.png" alt="image-20210708151630372"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151713402.png" alt="image-20210708151713402"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151724079.png" alt="image-20210708151724079"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152005397.png" alt="image-20210708152005397"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152017612.png" alt="image-20210708152017612"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin main^:foo</span><br><span class="line">git push origin foo:main</span><br></pre></td></tr></table></figure>



<h2 id="Git-fetch-的参数"><a href="#Git-fetch-的参数" class="headerlink" title="Git fetch 的参数"></a>Git fetch 的参数</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708152517963.png" alt="image-20210708152517963"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152526401.png" alt="image-20210708152526401"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152550967.png" alt="image-20210708152550967"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152623538.png" alt="image-20210708152623538"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152648161.png" alt="image-20210708152648161"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152724640.png" alt="image-20210708152724640"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152754538.png" alt="image-20210708152754538"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152807081.png" alt="image-20210708152807081"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152821953.png" alt="image-20210708152821953"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152832652.png" alt="image-20210708152832652"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152844370.png" alt="image-20210708152844370"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152855544.png" alt="image-20210708152855544"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708153609012.png" alt="image-20210708153609012"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708153618871.png" alt="image-20210708153618871"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin main~1:foo</span><br><span class="line">git fetch origin foo:main</span><br><span class="line">git checkout foo</span><br><span class="line">git merge main</span><br></pre></td></tr></table></figure>



<h2 id="古怪的-lt-source-gt"><a href="#古怪的-lt-source-gt" class="headerlink" title="古怪的 &lt;source&gt;"></a>古怪的 <code>&lt;source&gt;</code></h2><p> <img src="/2021/07/10/LearnGitBranch/image-20210708154016519.png" alt="image-20210708154016519"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154055142.png" alt="image-20210708154055142"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154118967.png" alt="image-20210708154118967"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154128060.png" alt="image-20210708154128060"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154143579.png" alt="image-20210708154143579"></p>
<h2 id="Git-pull-参数"><a href="#Git-pull-参数" class="headerlink" title="Git pull 参数"></a>Git pull 参数</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708154252617.png" alt="image-20210708154252617"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154310504.png" alt="image-20210708154310504"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154322563.png" alt="image-20210708154322563"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154340066.png" alt="image-20210708154340066"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154417895.png" alt="image-20210708154417895"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154431000.png" alt="image-20210708154431000"></p>
]]></content>
      <categories>
        <category>《Git》</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>图解</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础篇</title>
    <url>/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​        数据库是一个按<font color="red">数据结构</font>来存储和管理数据的计算机软件系统。数据库的概念实际包括两层意思：</p>
<p>​    （1）数据库是一个实体，它是能够合理保管数据的“仓库”，用户在该“仓库”中存放要管理的事务数据，“数据”和“库”两个概念结合成为数据库。</p>
<p>​    （2）数据库是数据管理的新方法和技术，它能更合适的组织数据、更方便的维护数据、更严密的控制数据和更有效的利用数据。</p>
<h3 id="2-数据库管理系统"><a href="#2-数据库管理系统" class="headerlink" title="2.数据库管理系统"></a>2.数据库管理系统</h3><p>​        数据库管理系统是数据库系统的核心组成部分，主要完成对数据库的操作与管理功能，实现数据库对象的创建、数据库存储数据的<font color="red">（CRUD）查询、添加、修改与删除</font>操作和数据库的用户管理、权限管理等。它的安全直接关系到整个数据库系统的安全。</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210715161617639-1626619077152.png" alt="image-20210715161617639"></p>
<h3 id="3-关系型数据库-VS-非关系型数据库（NoSQL）"><a href="#3-关系型数据库-VS-非关系型数据库（NoSQL）" class="headerlink" title="3.关系型数据库 VS 非关系型数据库（NoSQL）"></a>3.关系型数据库 VS 非关系型数据库（NoSQL）</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">关系型数据库</th>
<th align="center">非关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td align="center">举例</td>
<td align="center">Mysql、SqlServer</td>
<td align="center">Redis、Memcache、MongoDB</td>
</tr>
<tr>
<td align="center">语言</td>
<td align="center">SQL</td>
<td align="center">没有统一标准</td>
</tr>
<tr>
<td align="center">存储方式</td>
<td align="center">行列表</td>
<td align="center">键值对、图、文档等</td>
</tr>
<tr>
<td align="center">存储结构</td>
<td align="center">结构化</td>
<td align="center">动态结构</td>
</tr>
<tr>
<td align="center">扩展方式</td>
<td align="center">纵向扩展能力</td>
<td align="center">横向扩展能力</td>
</tr>
</tbody></table>
<h3 id="4-结构化查询语言SQL"><a href="#4-结构化查询语言SQL" class="headerlink" title="4.结构化查询语言SQL"></a>4.结构化查询语言SQL</h3><ul>
<li><p>专门用来和数据库通信的语言</p>
</li>
<li><p>优点</p>
<ul>
<li>不是特定数据库提供商专有的，几乎所有的DBMS都支持SQL</li>
<li>简单易学</li>
<li>使用灵活</li>
</ul>
</li>
<li><p>类型</p>
<ul>
<li><p>DML（Data Manipulation Language):数据<font color="red">操纵</font>语句，用于CRUD数据库记录，并检查数据完整性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>：	添加数据到数据库中</span><br><span class="line">UPDATE：	修改数据库中的数据</span><br><span class="line"><span class="keyword">DELETE</span>：	删除数据库中的数据</span><br><span class="line"><span class="keyword">SELECT</span>：	选择（查询）数据</span><br></pre></td></tr></table></figure></li>
<li><p>DDL（Data Definition Language):数据<font color="red">定义</font>语句，用于库和表的创建、修改、删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>：创建数据库表</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>：更改表结构、添加、删除、修改列长度</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>：删除表</span><br><span class="line"><span class="keyword">CREATE</span> INDEX：在表上建立索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX：删除索引</span><br></pre></td></tr></table></figure></li>
<li><p>DCL（Data Control Language):数据<font color="red">控制</font>语句，用于定义用户的访问权限和安全级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>：授予访问权限</span><br><span class="line"><span class="keyword">REVOKE</span>：撤销访问权限</span><br><span class="line"><span class="keyword">COMMIT</span>：提交事务处理</span><br><span class="line"><span class="keyword">ROLLBACK</span>：事务处理回退</span><br><span class="line"><span class="keyword">SAVEPOINT</span>：设置保存点</span><br><span class="line">LOCK：对数据库的特定部分进行锁定</span><br></pre></td></tr></table></figure></li>
<li><p>TCL（Transaction Control Language）：<font color="red">事务控制</font>font&gt;语言</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>	事务提交</span><br><span class="line"><span class="keyword">rollback</span> 事务回滚</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716155635092-1626619077153.png" alt="image-20210716155635092"></p>
<h3 id="1-介绍与安装"><a href="#1-介绍与安装" class="headerlink" title="1.介绍与安装"></a>1.介绍与安装</h3><p>MySQL是一款流行的开源数据库。它也是一个关系型数据库管理系统，2008年，mysql被sun公司收购，2009年sun公司被oracle公司收购，自此两个主流的数据库都归Oracle公司收购。</p>
<ul>
<li><p>MySQL的主要优势如下：</p>
<ol>
<li>运行速度快。mysql 体积小，命令执行速度快。</li>
<li>使用成本低。mysql是开源的，且提供免费版本，对大多数用户来说大大降低了使用成本。</li>
<li>容易使用。与其他大型数据库的设置和管理相比，其复杂程度较低，易于使用。</li>
<li>可移植性。MySQL 能够运行于多种系统平台上，如window，linux，unix等。</li>
<li>适用更多用户。mysql支持最常用的数据管理功能，适用于中小型企业甚至大型</li>
</ol>
</li>
<li><p>[安装]: <a href="https://blog.csdn.net/qq_38269362/article/details/107283338">https://blog.csdn.net/qq_38269362/article/details/107283338</a></p>
</li>
</ul>
<h3 id="2-MySQL服务的启动和停止"><a href="#2-MySQL服务的启动和停止" class="headerlink" title="2.MySQL服务的启动和停止"></a>2.MySQL服务的启动和停止</h3><p>所谓MySQL服务是指一系列关于MySQL软件的后台进程，只有启动了MySQL服务才能对mysql软件进行操作。</p>
<ul>
<li><p>方式一：右击计算机图标，在’管理’命令中打开计算机管理,选择服务和应用程序，点击服务节点。选择MySQL。</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716143306352-1626619077153.png" alt="image-20210716143306352"></p>
</li>
<li><p>方式二：通过dos窗口命令行（管理员身份运行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br><span class="line">net stop mysql</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-MySQL服务的登录和退出"><a href="#3-MySQL服务的登录和退出" class="headerlink" title="3.MySQL服务的登录和退出"></a>3.MySQL服务的登录和退出</h3><ul>
<li><p>方式一：通过mysql自带的客户端（MySQL 5.5 Command Line Client 仅限于root用户）</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716144530148-1626619077153.png" alt="image-20210716144530148"></p>
</li>
<li><p>方式二：通过Windows自带的客户端</p>
<ul>
<li><p>登录：<font color="red">mysql 【-h 主机名 -P 端口号 】-u 用户名 -p【密码】</font></p>
</li>
<li><p>退出：<font color="red">exit 或ctrl+C</font></p>
</li>
</ul>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716145007179-1626619077153.png" alt="image-20210716145007179"></p>
</li>
</ul>
<h3 id="4-MySQL常见命令"><a href="#4-MySQL常见命令" class="headerlink" title="4.MySQL常见命令"></a>4.MySQL常见命令</h3><p>​    注：sql命令以分号结尾</p>
<ul>
<li><h4 id="查看当前所有的数据库"><a href="#查看当前所有的数据库" class="headerlink" title="查看当前所有的数据库"></a>查看当前所有的数据库</h4><p><font color="red">show databases;</font></p>
</li>
<li><h4 id="打开指定的库"><a href="#打开指定的库" class="headerlink" title="打开指定的库"></a>打开指定的库</h4><p><font color="red">use 库名;</font></p>
</li>
<li><h4 id="查看当前库的所有表"><a href="#查看当前库的所有表" class="headerlink" title="查看当前库的所有表"></a>查看当前库的所有表</h4><p><font color="red">show tables;</font></p>
</li>
<li><h4 id="查看其它库的所有表"><a href="#查看其它库的所有表" class="headerlink" title="查看其它库的所有表"></a>查看其它库的所有表</h4><p><font color="red">show tables from 库名;</font></p>
</li>
<li><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p><font color="red">create table 表名(</font></p>
<p><font color="red">列名 列类型,</font><br><font color="red">列名 列类型，</font><br><font color="red">…    …);&lt;/</font></p>
</li>
<li><h4 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h4><p><font color="red">desc 表名;</font>font&gt;</p>
</li>
<li><h4 id="查看sql服务器版本"><a href="#查看sql服务器版本" class="headerlink" title="查看sql服务器版本"></a>查看sql服务器版本</h4><ul>
<li>sql命令:select version();</li>
<li>dos命令:mysql –version 或 mysql –V</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看当前所有数据库</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#打开指定数据库</span><br><span class="line">mysql<span class="operator">&gt;</span> use information_schema;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">#查看当前库中所有表</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_information_schema          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> CHARACTER_SETS                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> COLLATIONS                            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> COLLATION_CHARACTER_SET_APPLICABILITY <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> COLUMNS                               <span class="operator">|</span></span><br><span class="line">......</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="number">37</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#查看指定库中所有表</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables <span class="keyword">from</span> mysql;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_mysql           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> columns_priv              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> db                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> event                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> func                      <span class="operator">|</span></span><br><span class="line">......</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">24</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.06</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use test;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#在当前库创建表</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> stu_info(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="type">int</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> name <span class="type">varchar</span>(<span class="number">20</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_test <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> stu_info       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#查看指定表的表结构</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">#查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">#插入</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> stu_info (id,name) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;zlx&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> stu_info (id,name) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;zzx&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> frome stu_info;</span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;frome stu_info&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> zzx  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">mysql<span class="operator">&gt;</span> update stu_info <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;lili&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> lili <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> stu_info <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> version();</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> version() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5.5</span><span class="number">.15</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> exit</span><br><span class="line">Bye</span><br><span class="line"></span><br><span class="line">C:\Windows\system32<span class="operator">&gt;</span>mysql <span class="comment">--version</span></span><br><span class="line">mysql  Ver <span class="number">14.14</span> Distrib <span class="number">5.5</span><span class="number">.15</span>, <span class="keyword">for</span> Win32 (x86)</span><br></pre></td></tr></table></figure>



<h3 id="5-MySQL语法规范"><a href="#5-MySQL语法规范" class="headerlink" title="5.MySQL语法规范"></a>5.MySQL语法规范</h3><ul>
<li>1.不区分大小写,但建议关键字大写，表名、列名小写</li>
<li>2.每条命令最好用分号结尾（\g也可以）<br>3.每条命令根据需要，可以进行缩进 或换行（建议关键字单独一行）</li>
<li>4.注释<pre><code>单行注释：#注释文字
  单行注释：-- 注释文字
  多行注释：/* 注释文字  */
</code></pre>
</li>
</ul>
<h2 id="DQL语言"><a href="#DQL语言" class="headerlink" title="DQL语言"></a>DQL语言</h2><p>数据库结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(myemployees) --&gt;B[departments]</span><br><span class="line">  A --&gt; C[employees]</span><br><span class="line">  A --&gt; D[jobs]</span><br><span class="line">  A --&gt; E[locations]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h3><ul>
<li><font color="red">select  要查询的字段|表达式|常量值|函数  from  表名;</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语法：select 要查询的字段|表达式|常量值|函数 from 表名;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#(<span class="number">1</span>)查询表中单个字段</span><br><span class="line"><span class="keyword">SELECT</span> `last_name` <span class="keyword">FROM</span> employees ;</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)查询表中多个字段</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  `last_name`,</span><br><span class="line">  `salary`,</span><br><span class="line">  `email` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">#(<span class="number">3</span>)查询所有字段 </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#(<span class="number">4</span>)查询常量值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">#(<span class="number">5</span>)查询表达式</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">%</span><span class="number">98</span></span><br><span class="line"></span><br><span class="line">#(<span class="number">6</span>)查询函数</span><br><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"></span><br><span class="line">#(<span class="number">7</span>)为字段起别名</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-便于理解</span></span><br><span class="line"><span class="comment">-如果要查询的字段有重名的情况，使用别名可以区分开来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#方式<span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">%</span><span class="number">98</span> <span class="keyword">AS</span> 结果</span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> 姓,first_name <span class="keyword">AS</span> 名 <span class="keyword">FROM</span> employees</span><br><span class="line">#方式<span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name 姓, first_name 名 <span class="keyword">FROM</span> employees</span><br><span class="line">#别名中含特殊符号(用双引号)</span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">AS</span> &quot;out put&quot; <span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#(<span class="number">8</span>)去重(关键字：<span class="keyword">distinct</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#（<span class="number">9</span>）<span class="operator">+</span>号的作用</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">select 100+90;两个操作数都为数值型，则做加法运算</span></span><br><span class="line"><span class="comment">其中一方为字符型，试图将字符型转换为数值型</span></span><br><span class="line"><span class="comment">select &#x27;100&#x27;+90;	=190</span></span><br><span class="line"><span class="comment">select &#x27;John&#x27;+90;	=0+90=90</span></span><br><span class="line"><span class="comment">select null+90;只要其中一方为null,则结果肯定为null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#(<span class="number">10</span>)拼接(关键字：concat)</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(last_name,first_name) <span class="keyword">AS</span> 姓名 <span class="keyword">FROM</span> employees</span><br></pre></td></tr></table></figure>



<h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h3><ul>
<li><p><font color="red">语法：select  查询字段  from  表名  while 筛选条件;  </font></p>
</li>
<li><p>条件表达式：&gt;  &lt;  &gt;=  &lt;=  =  !=  &lt;&gt;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按条件表达式筛选</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例一：查询工资<span class="operator">&gt;</span><span class="number">12000</span>的员工信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	salary<span class="operator">&gt;</span><span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line">#案例二：查询部门编号不等于<span class="number">90</span>的员工名和部门编号</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	department_id</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	department_id<span class="operator">&lt;&gt;</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>逻辑表达式：</p>
<ul>
<li><p>and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false</p>
</li>
<li><p>or(||)：两个条件只要有一个成立，结果为true，否则为false</p>
</li>
<li><p>not(!)：如果条件成立，则not后为false，否则为true</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按逻辑表达式筛选</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例一：查询工资在<span class="number">10000</span>到<span class="number">20000</span>之间的员工名、工资以及奖金</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span> 	</span><br><span class="line">	salary<span class="operator">&gt;=</span><span class="number">10000</span> <span class="keyword">AND</span> salary<span class="operator">&lt;=</span><span class="number">20000</span>;</span><br><span class="line">	</span><br><span class="line">#案例二：查询部门编号不是在<span class="number">90</span>到<span class="number">110</span>之间，或者工资高于<span class="number">15000</span>的员工信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">NOT</span>(department_id<span class="operator">&gt;=</span><span class="number">90</span> <span class="keyword">AND</span> department_id<span class="operator">&lt;=</span><span class="number">110</span>) <span class="keyword">OR</span> salary<span class="operator">&gt;</span><span class="number">15000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>模糊查询：</p>
<ul>
<li><p>like</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">-------like</span></span><br><span class="line">#案例一：查询员工名字以s开头的员工信息（通配符：<span class="operator">%</span>任意多个字符，_任意单个字符）</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	last_name <span class="keyword">LIKE</span> <span class="string">&#x27;s%&#x27;</span></span><br><span class="line"></span><br><span class="line">#案例二：查询员工名字中第三个字符为i,第四个字符为e的员工名和工资</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	last_name <span class="keyword">LIKE</span> <span class="string">&#x27;__i_e%&#x27;</span> </span><br><span class="line">	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">转义字符 \</span></span><br><span class="line"><span class="comment">自定义转义字符 &#x27;$&#x27; ESCAPE &#x27;$&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>between and</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">--------between and（可以替换 &lt;  and  &gt;）</span></span><br><span class="line">#案例：查询员工号在<span class="number">100</span>到<span class="number">120</span>之间的员工信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	employee_id <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">120</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>in</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">------in（可以替换 = or = or = ……）</span></span><br><span class="line">#案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个的员工名和工种编号</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	job_id<span class="operator">=</span><span class="string">&#x27;IT_PROG&#x27;</span> <span class="keyword">OR</span> job_id<span class="operator">=</span><span class="string">&#x27;AD_VP&#x27;</span> <span class="keyword">OR</span> job_id<span class="operator">=</span><span class="string">&#x27;AD_PRES&#x27;</span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	job_id <span class="keyword">IN</span> (<span class="string">&#x27;IT_PROG&#x27;</span>,<span class="string">&#x27;AD_VP&#x27;</span>,<span class="string">&#x27;AD_PRES&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>is null | is not null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">----is （not）null</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断null值不能用 = 和 &lt;&gt;,而要用 is 和 is not</span></span><br><span class="line"><span class="comment">也可以用安全等于 &lt;=&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例一：查询没有奖金的员工名和奖金率</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span></span><br><span class="line">	</span><br><span class="line">#案例二：查询有奖金的员工名和奖金率</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">	</span><br><span class="line">#案例三：查询员工号为<span class="number">176</span>的姓名、部门号和年薪</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">年薪=salary*12*(1+年薪率)</span></span><br><span class="line"><span class="comment">年薪率可能为NULL，为NULL时当作0</span></span><br><span class="line"><span class="comment">年薪=salary*12*(1+IFNULL(commission_pct,0))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	department_id,</span><br><span class="line">	salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">AS</span> 年薪</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3.排序查询"></a>3.排序查询</h3><ul>
<li><p><font color="red">语法：select  要查询的东西  from  表 【where 条件】 order by 排序的字段|表达式|别名|函数 【asc|desc】</font>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语法:</span></span><br><span class="line"><span class="comment">select 要查询的东西</span></span><br><span class="line"><span class="comment">from 表</span></span><br><span class="line"><span class="comment">【where 条件】</span></span><br><span class="line"><span class="comment">order by 排序的字段|表达式|别名|函数 【asc|desc】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#案例一：查询员工信息，要求按工资从高到低排序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">#案例二：查询部门编号<span class="operator">&gt;=</span><span class="number">90</span>的员工信息，按入职时间的先后排序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&gt;=</span> <span class="number">90</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hiredate <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">#案例三：按年薪高低显示员工的信息和年薪【按表达式<span class="operator">|</span>别名排序】</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#案例四：按姓名的长度显示员工信姓名和工资【按函数排序】</span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(last_name) 姓名长度,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> LENGTH(last_name) <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#案例五：查询员工信息，要求先按工资升序排序，如果工资相同，再按员工编号降序排序【按多个字段排序】</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>,employee_id <span class="keyword">DESC</span>;			</span><br></pre></td></tr></table></figure>

<p>​                       </p>
</li>
</ul>
<h3 id="4-单行函数"><a href="#4-单行函数" class="headerlink" title="4.单行函数"></a>4.单行函数</h3><ul>
<li>字符函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#(<span class="number">1</span>)length()：获取参数值的字节个数(汉字占<span class="number">3</span>个字节)</span><br><span class="line"><span class="keyword">select</span> length(<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> length(<span class="string">&#x27;张三丰&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)concat():拼接字符串</span><br><span class="line"><span class="keyword">select</span> concat(last_name,<span class="string">&#x27;_&#x27;</span>,first_name) <span class="keyword">from</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">3</span>)<span class="built_in">upper</span>()、<span class="built_in">lower</span>():转换为大<span class="operator">/</span>小写</span><br><span class="line"><span class="keyword">select</span> concat(<span class="built_in">upper</span>(last_name),<span class="built_in">lower</span>(first_name)) 姓名 <span class="keyword">from</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">4</span>)substr():截取字符串	注意：索引从<span class="number">1</span>开始</span><br><span class="line">#<span class="comment">--截取从指定索引处开始后面所有字符</span></span><br><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;李莫愁爱上了陆展元&#x27;</span>,<span class="number">7</span>) output;</span><br><span class="line"></span><br><span class="line">#<span class="comment">--截取从指定索引处开始指定长度字符</span></span><br><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;李莫愁爱上了陆展元&#x27;</span>,<span class="number">1</span>,<span class="number">3</span>) output;</span><br><span class="line"></span><br><span class="line">#案例：姓名中首字符大写，其他字符小写，用—连接，显示处理</span><br><span class="line"><span class="keyword">select</span> concat(<span class="built_in">upper</span>(substr(last_name,<span class="number">1</span>,<span class="number">1</span>)),substr(last_name,<span class="number">2</span>),<span class="string">&#x27;-&#x27;</span>,<span class="built_in">lower</span>(first_name))</span><br><span class="line"><span class="keyword">as</span> 姓名 <span class="keyword">from</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">5</span>)instr():返回字串第一次出现的索引，如果找不到则返回<span class="number">0</span></span><br><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;杨不悔爱上了殷六侠&#x27;</span>,<span class="string">&#x27;爱上&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">6</span>)<span class="built_in">trim</span>():去除字符串前后空格或指定字符</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27;     张翠山     &#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;aaaaaaa张aaa翠山aaaaa&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">7</span>)lpad():用指定字符串左填充到指定长度</span><br><span class="line"><span class="keyword">select</span> lpad(<span class="string">&#x27;殷素素&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;&amp;&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">8</span>)rpad():用指定字符串右填充到指定长度</span><br><span class="line"><span class="keyword">select</span> rpad(<span class="string">&#x27;殷素素&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;$&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">9</span>)replace():替换字符串</span><br><span class="line"><span class="keyword">select</span> replace(<span class="string">&#x27;张无忌爱上了周芷若周芷若&#x27;</span>,<span class="string">&#x27;周芷若&#x27;</span>,<span class="string">&#x27;赵敏&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>数学函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#(<span class="number">1</span>)round:四舍五入</span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.55</span>);</span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.235</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)ceil:向上取整,返回<span class="operator">&gt;=</span>该参数的最小整数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">-2.1</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">3</span>)floor:向下取整，返回<span class="operator">&lt;=</span>该参数的最大整</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">-9.99</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">4</span>)<span class="keyword">truncate</span>:截断</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">-1.2234</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">5</span>)mod:取余函数</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">取余原理：</span></span><br><span class="line"><span class="comment">mod(a,b):= a-(a/b)*b</span></span><br><span class="line"><span class="comment">mod(-10,-3)=-10-(-10/-3)*(-3)=-10-(-9)=-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">10</span>,<span class="number">-3</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>日期函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#now 返回当前系统日期<span class="operator">+</span>时间</span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"></span><br><span class="line">#curdate 返回当前日期</span><br><span class="line"><span class="keyword">SELECT</span> CURDATE();</span><br><span class="line"></span><br><span class="line">#curtime 返回当前时间</span><br><span class="line"><span class="keyword">SELECT</span> CURTIME();</span><br><span class="line"></span><br><span class="line">#获取指定部分的年、月、日、小时、分、秒</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW()) 年;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="string">&#x27;1999-10-10&#x27;</span>) 年;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(NOW()) 月;</span><br><span class="line"><span class="keyword">SELECT</span> MONTHNAME(NOW()) 月名;</span><br><span class="line"></span><br><span class="line">#将字符串转换为日期</span><br><span class="line"><span class="keyword">SELECT</span> STR_TO_DATE(<span class="string">&#x27;3-3-1999&#x27;</span>,<span class="string">&#x27;%c-%d-%Y&#x27;</span>) <span class="keyword">AS</span> out_put</span><br><span class="line"></span><br><span class="line">#将日期转换为字符</span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(hiredate,<span class="string">&#x27;%m月/%d日 %y年&#x27;</span>) <span class="keyword">AS</span> out_put</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>流程控制函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#(<span class="number">1</span>)if函数：if <span class="keyword">else</span> 效果</span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">10</span><span class="operator">&lt;</span><span class="number">5</span>,<span class="string">&#x27;小&#x27;</span>,<span class="string">&#x27;大&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct,</span><br><span class="line">	IF(commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span>,<span class="string">&#x27;没有奖金&#x27;</span>,<span class="string">&#x27;有奖金&#x27;</span>) <span class="keyword">AS</span> 备注</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)<span class="keyword">case</span>函数：作为一个新字段，与前面字段用逗号隔开</span><br><span class="line">#<span class="comment">--switch case的效果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">case 要判断的表达式</span></span><br><span class="line"><span class="comment">when 常量1 then 要显示的值1或语句1；</span></span><br><span class="line"><span class="comment">when 常量2 then 要显示的值2或语句2；</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">else 要显示的值n或语句n;</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="comment">部门号=30，显示工资1.1倍</span></span><br><span class="line"><span class="comment">部门号=40，显示工资1.2倍</span></span><br><span class="line"><span class="comment">部门号=50，显示工资1.3倍</span></span><br><span class="line"><span class="comment">其他部门，显示原工资</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">AS</span> 原始工资,department_id,</span><br><span class="line"><span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">30</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">40</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">50</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.3</span></span><br><span class="line"><span class="keyword">ELSE</span> salary</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">AS</span> 新工资</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="comment">--多重if的效果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">case </span></span><br><span class="line"><span class="comment">when 表达式1 then 要显示的值1或语句1；</span></span><br><span class="line"><span class="comment">when 表达式2 then 要显示的值2或语句2；</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">else 要显示的值n或语句n;</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例：查询工资级别，要求</span></span><br><span class="line"><span class="comment">工资&gt;20000,显示A级别</span></span><br><span class="line"><span class="comment">工资&gt;15000，显示B级别</span></span><br><span class="line"><span class="comment">工资&lt;15000,显示C级别</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,</span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">20000</span> <span class="keyword">THEN</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> 工资级别</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br></pre></td></tr></table></figure>



<h3 id="5-分组函数"><a href="#5-分组函数" class="headerlink" title="5.分组函数"></a>5.分组函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：做统计使用，又称为聚合函数、统计函数或组函数</span></span><br><span class="line"><span class="comment">sum 求和、avg 平均值、max 最大值、min 最小值、count 计算个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#<span class="number">1.</span>简单使用</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">AS</span> 工资总和 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> 最高工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) <span class="keyword">AS</span> 最低工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> 平均工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(salary) <span class="keyword">AS</span> 有工资的人数 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary)<span class="operator">/</span><span class="built_in">COUNT</span>(salary) <span class="keyword">AS</span> 平均工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>参数支持那些类型</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sum,avg 一般处理数值型；</span></span><br><span class="line"><span class="comment">max,min,count 可以处理任何类型；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(last_name),<span class="built_in">AVG</span>(last_name) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(last_name),<span class="built_in">MIN</span>(last_name) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>以上分组函数都忽略<span class="keyword">null</span>值；</span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="built_in">COUNT</span>(commission_pct)<span class="operator">-</span><span class="built_in">COUNT</span>(salary)<span class="operator">&lt;&gt;</span><span class="number">0</span>,<span class="string">&#x27;不相等&#x27;</span>,<span class="string">&#x27;相等&#x27;</span>) </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span>和<span class="keyword">distinct</span>搭配</span><br><span class="line">#查看有几种工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> salary) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">5.</span>count函数的详细介绍</span><br><span class="line">#统计表的行数（不忽略<span class="keyword">null</span>值）</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> employees;	#除了<span class="number">1</span>可以是任意常量值</span><br><span class="line"></span><br><span class="line">#<span class="number">6.</span>和分组函数一同查询的字段要求是<span class="keyword">group</span> <span class="keyword">by</span>后的字段</span><br></pre></td></tr></table></figure>

<p>​        </p>
<h3 id="6-分组查询"><a href="#6-分组查询" class="headerlink" title="6.分组查询"></a>6.分组查询</h3><ul>
<li><p>语法：</p>
<p> <font color="red">select column,group_function(column)</font><br> <font color="red">from table</font></p>
<pre><code>       &lt;font color=&#39;red&#39;&gt; [where condition]&lt;/font&gt;
        &lt;font color=&#39;red&#39;&gt;[group by group_by_expression]&lt;/font&gt;
       &lt;font color=&#39;red&#39;&gt;[order by column]&lt;/font&gt;
        &lt;font color=&#39;red&#39;&gt;[having condition]&lt;/font&gt; 
</code></pre>
</li>
<li><p>tip:</p>
<ul>
<li>查询列表比较特殊，要求是分组函数和group by后出现的字段(每个…)；</li>
<li>先按照where筛选条件进行分组，然后根据分组函数查询对应的值,最后进行having筛选</li>
</ul>
</li>
<li><p>简单的分组查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询每个部门的平均工资</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) 平均工资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(salary) <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询每个工种的最高工资</span><br><span class="line"><span class="keyword">SELECT</span> job_id,<span class="built_in">MAX</span>(salary) 最高工资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"></span><br><span class="line">#案例<span class="number">3</span>：查询每个位置上的部门个数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),location_id</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> location_id</span><br></pre></td></tr></table></figure>

<p>​        </p>
</li>
<li><p>where筛选条件：先where筛选再分组，where筛选是在未分组的原始表上进行的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#案例1：查询邮箱中包含a字符，每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE email LIKE &#x27;%a%&#x27;</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">#案例2：查询每个领导手下有奖金的员工的最高工资</span><br><span class="line">SELECT MAX(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager_id;</span><br></pre></td></tr></table></figure></li>
<li><p>having筛选条件：先查询在having筛选，having筛选是在查询结果集上进行的    </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询哪个部门的员工个数大于<span class="number">2</span></span><br><span class="line">#错误写法：<span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span>是筛选的整个原始表</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) 员工个数</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line">#正确写法：（<span class="number">1</span>）先分组查询每个部门的员工个数；（<span class="number">2</span>）根据结果再过滤查询员工个数大于<span class="number">2</span>的部门</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) 员工个数</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>混合筛选条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询每个工种&quot;有奖金的&quot;员工的&quot;最高工资&gt;12000的&quot;工种编号和最高工资</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">筛选条件1：有奖金的</span></span><br><span class="line"><span class="comment">筛选条件2：最高工资&gt;12000</span></span><br><span class="line"><span class="comment">分组条件：每个工种</span></span><br><span class="line"><span class="comment">思路：先筛选出有奖金的项，按照工种分组，查询出每个分组的最高工资和工种编号，最后从结果集筛选出最高工资大于12000的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> job_id,<span class="built_in">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span><span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询“领导编号<span class="operator">&gt;</span><span class="number">102</span>的“每个领导手下的”最低工资<span class="operator">&gt;</span><span class="number">5000</span>的“领导编号以及最低工资</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">筛选条件1：领导编号&gt;102</span></span><br><span class="line"><span class="comment">筛选条件2：最低工资&gt;5000</span></span><br><span class="line"><span class="comment">分组条件：每个领导</span></span><br><span class="line"><span class="comment">思路：先筛选领导编号&gt;102的项，按照领导编号分组，查询出领导编号和最低工资，最后从结果集筛选出最低工资&lt;5000的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> manager_id,<span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id<span class="operator">&gt;</span><span class="number">102</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary)<span class="operator">&gt;</span><span class="number">5000</span>；</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-连接查询"><a href="#7-连接查询" class="headerlink" title="7.连接查询"></a>7.连接查询</h3><h4 id="（1）分类："><a href="#（1）分类：" class="headerlink" title="（1）分类："></a>（1）分类：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按年代分类：</span><br><span class="line">	sq129标准：仅支持内连接（等值、非等值、自连接）</span><br><span class="line">	sql199标准【推荐】支持内连接+外连接（左外连接、右外连接）+交叉连接</span><br><span class="line">	</span><br><span class="line">按功能分：</span><br><span class="line">	内连接：</span><br><span class="line">		等值连接</span><br><span class="line">		非等值连接</span><br><span class="line">		自连接</span><br><span class="line">	外连接：</span><br><span class="line">		左外连接</span><br><span class="line">		右外连接</span><br><span class="line">		全外连接</span><br><span class="line">	交叉连接</span><br></pre></td></tr></table></figure>



<h4 id="（2）SQL192标准"><a href="#（2）SQL192标准" class="headerlink" title="（2）SQL192标准"></a>（2）SQL192标准</h4><ul>
<li>等值连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询女生名对应的男生名</span><br><span class="line"><span class="keyword">SELECT</span> `name`,boyName <span class="keyword">FROM</span> beauty,boys</span><br><span class="line"><span class="keyword">WHERE</span> beauty.boyfriend_id <span class="operator">=</span> boys.id;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询员工名和对应的部门名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.`department_id`<span class="operator">=</span>departments.`department_id`;</span><br><span class="line"></span><br><span class="line">#为表名起别名</span><br><span class="line">#案例<span class="number">1</span>：查询员工号、工种号、工种名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,employees.job_id,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees,jobs</span><br><span class="line"><span class="keyword">WHERE</span> employees.`job_id`<span class="operator">=</span>jobs.`job_id`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,e.job_id,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e,jobs <span class="keyword">AS</span> j</span><br><span class="line"><span class="keyword">WHERE</span> e.`job_id`<span class="operator">=</span>j.`job_id`;</span><br><span class="line"></span><br><span class="line">#加筛选条件</span><br><span class="line">#案例<span class="number">1</span>：查询有奖金的员工们和部门名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`commission_pct` <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; </span><br></pre></td></tr></table></figure>



<ul>
<li>非等值连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询员工的工资和工资级别</span><br><span class="line"><span class="keyword">SELECT</span> salary,grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees,job_grades g</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> g.`lowest_sal` <span class="keyword">AND</span> `highest_salary`;</span><br></pre></td></tr></table></figure>



<ul>
<li>自连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">3.</span>自连接</span><br><span class="line">#案例<span class="number">1</span>：查询员工名和上级的名称</span><br><span class="line"><span class="keyword">SELECT</span> e1.last_name 员工名,e2.last_name 领导名</span><br><span class="line"><span class="keyword">FROM</span> employees e1,employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.manager_id <span class="operator">=</span> e2.employee_id</span><br></pre></td></tr></table></figure>



<h4 id="（3）SQL199标准"><a href="#（3）SQL199标准" class="headerlink" title="（3）SQL199标准"></a>（3）SQL199标准</h4><ul>
<li><p>语法：</p>
<pre><code>select 查询列表
  from 表1 别名 【连接类型】
  join 表2 别名
  on 连接条件
  【where 筛选条件】
  【group by 分组】
  【having 筛选条件】
  【order by 排序列表】
</code></pre>
</li>
<li><p>分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分类：</span><br><span class="line">	内连接：inner</span><br><span class="line">	外连接：</span><br><span class="line">		左外：left 【outer】</span><br><span class="line">		右外：right 【outer】</span><br><span class="line">		全外：full 【outer】</span><br><span class="line">	交叉连接：cross</span><br></pre></td></tr></table></figure></li>
<li><p>内连接</p>
<ul>
<li>语法<pre><code>select 查询列表
  from 表1 别名
  inner join 表2 别名
  On 连接条件
</code></pre>
</li>
<li>等值连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#（<span class="number">1</span>）等值连接</span><br><span class="line">#案例<span class="number">1</span>：查询员工名和对应的部门名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询有奖金的员工们和部门名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`commission_pct` <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>非等值连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#（<span class="number">2</span>）非等值连接</span><br><span class="line">#案例<span class="number">1</span>：查询员工的工资和工资级别</span><br><span class="line"><span class="keyword">SELECT</span> salary,grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> e.salary <span class="keyword">BETWEEN</span> g.`lowest_sal` <span class="keyword">AND</span> `highest_salary`;</span><br></pre></td></tr></table></figure>

<ul>
<li>自连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#（<span class="number">3</span>）自连接</span><br><span class="line">#案例<span class="number">1</span>：查询员工名和上级的名称</span><br><span class="line"><span class="keyword">SELECT</span> e1.last_name 员工名,e2.last_name 领导名</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> employees e2</span><br><span class="line"><span class="keyword">ON</span> e1.manager_id <span class="operator">=</span> e2.employee_id</span><br></pre></td></tr></table></figure></li>
<li><p>外连接</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">应用场景：一个表中有，另外一个表没有的记录</span></span><br><span class="line"><span class="comment">1.外连接查询结果为主表中的所有记录</span></span><br><span class="line"><span class="comment">	如果从表中有和它匹配的，则显示匹配的值</span></span><br><span class="line"><span class="comment">	如果没有和它匹配的，则显示null</span></span><br><span class="line"><span class="comment">	外连接查询结果=内连接结果+主表中有而从表中没有的记录</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">2.left join:左边是主表</span></span><br><span class="line"><span class="comment">right join:右边是主表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例<span class="number">1</span>：查询男朋友不在男生表中女生名</span><br><span class="line"><span class="keyword">select</span> be.name,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> beauty be</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> boys bo</span><br><span class="line"><span class="keyword">on</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"><span class="keyword">where</span> bo.`id` <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询哪个部门没有员工</span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span>,e.employee_id</span><br><span class="line"><span class="keyword">from</span> departments d</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> employees e</span><br><span class="line"><span class="keyword">on</span> d.`department_id` <span class="operator">=</span> e.`department_id`</span><br><span class="line"><span class="keyword">where</span> e.`employee_id` <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>



<ul>
<li>交叉连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#交叉连接（笛卡尔乘积）</span><br><span class="line"><span class="keyword">SELECT</span> be.<span class="operator">*</span>,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> beauty be</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> boys bo;</span><br></pre></td></tr></table></figure>



<h3 id="8-子查询"><a href="#8-子查询" class="headerlink" title="8.子查询"></a>8.子查询</h3><ul>
<li>说明：当一个查询语句中又嵌套了另外一个select语句，则倍嵌套的select语句称为子查询或内查询           </li>
<li>分类：  <ol>
<li>select后面：<pre><code>要求：子查询的结果为单行多列（标量子查询）
</code></pre>
</li>
<li>from后面<pre><code>要求：子查询的结果可以为多行多列
</code></pre>
</li>
<li>where或having后面<pre><code>要求：子查询的结果必须为单列
       单行子查询
       多行子查询
</code></pre>
</li>
<li>exists后面<pre><code>要求：子查询结果必须为单列（相关子查询）
</code></pre>
</li>
</ol>
</li>
<li>特点：<pre><code>子查询要包含在括号中；
  子查询放在比较条件右侧
  子查询的查询优先于主查询
  单行子查询对应了 单行操作符：&gt; &lt; &lt;= &gt;= = &lt;&gt;
  多行子查询对应了 多行操作符：any/some  all in
</code></pre>
</li>
</ul>
<ul>
<li><p>单行子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1.</span>查询和Zlotkey相同部门的员工姓名和工资名</span><br><span class="line">#(<span class="number">1</span>)查询Zlotkey的部门编号</span><br><span class="line"><span class="keyword">SELECT</span> department_id </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Zlotkey&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)查询department_id<span class="operator">=</span>(<span class="number">1</span>)的员工工资和姓名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> department_id </span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Zlotkey&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2.</span>查询工资比公司平均工资高的员工姓名和工资</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;=</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>多行子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">in:判断某字段是否在列表内</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">any/some:判断某字段的值是否满足任意一个</span></span><br><span class="line"><span class="comment">x&gt;any() &lt;=&gt; x&gt;min()</span></span><br><span class="line"><span class="comment">x=any() &lt;=&gt; x in ()</span></span><br><span class="line"><span class="comment">x&lt;any() &lt;=&gt; x&lt;max()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">all:判断某字段的值是否满足所有</span></span><br><span class="line"><span class="comment">x&gt;all() &lt;=&gt; x&gt;max()</span></span><br><span class="line"><span class="comment">x&lt;all() &lt;=&gt; x&lt;max()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例<span class="number">1</span>：返回location_id是<span class="number">1400</span>或<span class="number">1700</span>的部门中的所有员工姓名</span><br><span class="line"><span class="keyword">SELECT</span> last_name	</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> departments</span><br><span class="line">	<span class="keyword">WHERE</span> location_id <span class="keyword">IN</span> (<span class="number">1400</span>,<span class="number">1700</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：返回其他部门中比job_id为IT_PROG部门中任意工资低的员工号、姓名、job_id、salary</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="keyword">ANY</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">) <span class="keyword">AND</span> job_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> (</span><br><span class="line">	<span class="keyword">SELECT</span>  <span class="built_in">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">) <span class="keyword">AND</span> job_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;IT_PROG&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>放在from后面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：查询每个部门的平均工资的工资级别</span><br><span class="line">#（<span class="number">1</span>）每个部门的平均工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)连接：查询平均工资的工资级别</span><br><span class="line"><span class="keyword">SELECT</span> dep_ag.department_id,dep_ag.ag,g.grade</span><br><span class="line"><span class="keyword">FROM</span> sal_grade g</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) ag,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) dep_ag <span class="keyword">ON</span> dep_ag.ag <span class="keyword">BETWEEN</span> g.min_salary <span class="keyword">AND</span> g.max_salary;</span><br></pre></td></tr></table></figure></li>
<li><p>放在exists后面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：查询有无名字叫“张三丰”的员工</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;张三丰&#x27;</span></span><br><span class="line">) 有无;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-分页查询"><a href="#9-分页查询" class="headerlink" title="9.分页查询"></a>9.分页查询</h3><ul>
<li><p>语法：</p>
<p>select 查询列表<br>from 表1 别名<br>join 表2 别名<br>where 筛选条件<br>group by 分组<br>having 分组后筛选<br>order by 排序列表<br>limit 起始条目索引(默认0)，显示的条目数</p>
</li>
<li><p>执行顺序：</p>
<p>1.from<br>2.join<br>3.on<br>4.where<br>5.group by<br>6.having<br>7.select<br>8.order by<br>9.limit</p>
</li>
<li><p>公式：</p>
<p>如果要显示的页数是page,每页显示的条目数是size</p>
<p>*<em>select *<br>from employees<br>limit (page-1)<em>size,size;</em></em></p>
<table>
<thead>
<tr>
<th>page</th>
<th>size=10</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>limit 0,10</td>
</tr>
<tr>
<td>2</td>
<td>limit 10,10</td>
</tr>
<tr>
<td>3</td>
<td>limit 20,10</td>
</tr>
<tr>
<td>4</td>
<td>limit 30,10</td>
</tr>
</tbody></table>
</li>
<li><p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询员工信息的前五条</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">5</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">0</span>,<span class="number">5</span></span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询有奖金的，员工工资较高的第<span class="number">11</span>名到第<span class="number">20</span>名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">10</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-union联合查询"><a href="#10-union联合查询" class="headerlink" title="10.union联合查询"></a>10.union联合查询</h3><ul>
<li><p>说明：查询结果之间没有关联，这个时候往往使用联合查询（union查询）</p>
</li>
<li><p>语法：</p>
<p>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】<br>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】<br>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】<br>…..<br>select 字段|常量|表达式|函数 【from 表】 【where 条件】</p>
</li>
<li><p>注意：</p>
<ul>
<li>要求列数相等</li>
<li>union自动去重/union all 支持重复项</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：</span><br><span class="line"><span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> beauty</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> `boyname` <span class="keyword">FROM</span> boys</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="1-插入insert"><a href="#1-插入insert" class="headerlink" title="1.插入insert"></a>1.插入insert</h3><h4 id="（1）方式一"><a href="#（1）方式一" class="headerlink" title="（1）方式一"></a>（1）方式一</h4><ul>
<li><p>语法：</p>
<p><font color="red">insert into 表名(列名1，…) </font></p>
<p><font color="red">values(值1，…)，values(值1，…)，…</font></p>
</li>
<li><p>插入的值的类型要与列的类型一致,且一一对应</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">&#x27;唐艺昕&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>可以为null的列如何插入值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式一(对应值写<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">&#x27;唐艺昕&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">#方式二（不写列名）</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(id,NAME,sex,borndate,phone,boyfriend_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">14</span>,<span class="string">&#x27;金星&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>列的顺序可以调换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(NAME,sex,phone,id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;蒋欣&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1235677764&#x27;</span>,<span class="number">15</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>可以省略列名，默认所有列，且列的顺序和表中列的顺序一致</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">16</span>,<span class="string">&#x27;张飞&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;119&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）方式二"><a href="#（2）方式二" class="headerlink" title="（2）方式二"></a>（2）方式二</h4><ul>
<li><p>语法：</p>
<p><font color="red">insert into 表名</font></p>
<p><font color="red">set 列名1=值1，列名2=值2，…</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">SET</span> id<span class="operator">=</span><span class="number">17</span>,NAME<span class="operator">=</span><span class="string">&#x27;刘涛&#x27;</span>,phone<span class="operator">=</span><span class="string">&#x27;1928384940984&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）两者对比"><a href="#（3）两者对比" class="headerlink" title="（3）两者对比"></a>（3）两者对比</h4><ul>
<li><p>方式一支持插入多行，方式二不支持</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">18</span>,<span class="string">&#x27;唐艺昕&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">19</span>,<span class="string">&#x27;唐艺昕&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">20</span>,<span class="string">&#x27;唐艺昕&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>方式一支持子查询，方式二不支持</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(id,NAME,phone)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">21</span>,<span class="string">&#x27;宋茜&#x27;</span>,<span class="string">&#x27;123478583493&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-修改update"><a href="#2-修改update" class="headerlink" title="2.修改update"></a>2.修改update</h3><h4 id="（1）修改单表"><a href="#（1）修改单表" class="headerlink" title="（1）修改单表"></a>（1）修改单表</h4><ul>
<li><p>语法：</p>
<p><font color="red">update 表名</font></p>
<p><font color="red">set 列=新值，列=新值</font></p>
<p><font color="red">where 筛选条件;</font></p>
</li>
<li><p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：修改beauty表中姓唐的电话为<span class="number">000000000</span></span><br><span class="line">UPDATE beauty</span><br><span class="line"><span class="keyword">SET</span> phone<span class="operator">=</span><span class="string">&#x27;000000000&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;唐%&#x27;</span></span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：修改boys表中id为<span class="number">2</span>的名称为张飞，魅力值为<span class="number">10</span></span><br><span class="line">UPDATE boys</span><br><span class="line"><span class="keyword">SET</span> boyname<span class="operator">=</span><span class="string">&#x27;张飞&#x27;</span>,userCP<span class="operator">=</span><span class="number">10</span></span><br><span class="line"><span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）修改多表"><a href="#（2）修改多表" class="headerlink" title="（2）修改多表"></a>（2）修改多表</h4><ul>
<li><p>语法：</p>
<ul>
<li><p>SQL192语法：</p>
<p><font color="red">update 表1 别名，表2 别名</font></p>
<p><font color="red">set 列=值，…</font></p>
<p><font color="red">where 连接条件</font></p>
<p><font color="red">and 筛选条件</font></p>
</li>
<li><p>SQL199语法：【推荐】</p>
<p><font color="red">update 表1 别名</font></p>
<p><font color="red">inner|left|right join 表2 别名</font></p>
<p><font color="red">on 连接条件</font></p>
<p><font color="red">set 列=值，…</font></p>
<p><font color="red">where 筛选条件</font></p>
</li>
</ul>
</li>
<li><p>案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：修改张无忌的女朋友的手机号为<span class="number">11111111</span></span><br><span class="line">UPDATE boys bo</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty be </span><br><span class="line"><span class="keyword">ON</span> bo.`id`<span class="operator">=</span>be.`boyfriend_id`</span><br><span class="line"><span class="keyword">SET</span> phone<span class="operator">=</span><span class="string">&#x27;1111111111&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.boyName<span class="operator">=</span><span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：修改没有男朋友的女生的男朋友编号都为<span class="number">2</span></span><br><span class="line">#(<span class="number">1</span>)左外连接</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span></span><br><span class="line">beauty be <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> boys bo</span><br><span class="line"><span class="keyword">ON</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"></span><br><span class="line">UPDATE beauty be</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> boys bo </span><br><span class="line"><span class="keyword">ON</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"><span class="keyword">SET</span> boyfriend_id<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> boyfriend_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)右外连接</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span></span><br><span class="line">boys bo <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> beauty be</span><br><span class="line"><span class="keyword">ON</span> bo.`id`<span class="operator">=</span>be.`boyfriend_id`</span><br><span class="line"></span><br><span class="line">UPDATE boys bo </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> beauty be</span><br><span class="line"><span class="keyword">ON</span> bo.`id`<span class="operator">=</span>be.`boyfriend_id`</span><br><span class="line"><span class="keyword">SET</span> boyfriend_id<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> boyfriend_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-删除delete"><a href="#3-删除delete" class="headerlink" title="3.删除delete"></a>3.删除delete</h3><h4 id="（1）单表的删除"><a href="#（1）单表的删除" class="headerlink" title="（1）单表的删除"></a>（1）单表的删除</h4><ul>
<li><p>语法：<font color="red">delete from 表名 where 筛选条件</font></p>
</li>
<li><p>案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：删除手机号以<span class="number">9</span>结尾的女神信息</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> beauty <span class="keyword">WHERE</span> phone <span class="keyword">LIKE</span> <span class="string">&#x27;%9&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）多表的删除"><a href="#（2）多表的删除" class="headerlink" title="（2）多表的删除"></a>（2）多表的删除</h4><ul>
<li><p>语法：</p>
<ul>
<li><p>SQL192标准</p>
<p>​        delete 表1的别名，表2的别名 （要删除哪个表的记录就写哪个表别名）<br>​        from 表1 别名，表2 别名<br>​        where 连接条件<br>​        and 筛选条件</p>
</li>
<li><p>SQL199标准【推荐】</p>
<p>​        <font color="red">delete 表1的别名，表2的别名</font><br>​        <font color="red">from 表1 别名</font><br>​        <font color="red">inner|left|right| join 表2 别名</font><br>​        <font color="red">on 连接条件</font><br>​        <font color="red">where 筛选条件</font></p>
</li>
</ul>
</li>
<li><p>案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：删除张无忌女朋友的信息</span><br><span class="line"><span class="keyword">DELETE</span> be</span><br><span class="line"><span class="keyword">FROM</span> boys bo </span><br><span class="line"><span class="keyword">JOIN</span> beauty be</span><br><span class="line"><span class="keyword">ON</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"><span class="keyword">WHERE</span> bo.`boyName`<span class="operator">=</span><span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#案例：删除黄晓明及其女朋友的信息</span><br><span class="line"><span class="keyword">DELETE</span> be,bo</span><br><span class="line"><span class="keyword">FROM</span> boys bo </span><br><span class="line"><span class="keyword">JOIN</span> beauty be</span><br><span class="line"><span class="keyword">ON</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"><span class="keyword">WHERE</span> bo.`boyName`<span class="operator">=</span><span class="string">&#x27;黄晓明&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）truncate"><a href="#（3）truncate" class="headerlink" title="（3）truncate"></a>（3）truncate</h4><ul>
<li>语法：<font color="red">truncate table 表名；</font></li>
<li>truncate table boys 与 delete from boys 对比 【<font color="red">面试题</font>】<ul>
<li>1.都能清空表数据</li>
<li>2.truncate删除效率稍微高一点点</li>
<li>3.用delete删除在插入数据，自增长序列的值从断点开始；用truncate删除再插入数据，自增长序列的值从1开始</li>
<li>4.delete删除有返回值；truncate删除没有返回值</li>
<li>5.truncate删除后不能回滚，delete删除可以回滚</li>
</ul>
</li>
</ul>
<h2 id="DDL语言"><a href="#DDL语言" class="headerlink" title="DDL语言"></a>DDL语言</h2><h3 id="1-库的管理"><a href="#1-库的管理" class="headerlink" title="1.库的管理"></a>1.库的管理</h3><h4 id="（1）库的创建"><a href="#（1）库的创建" class="headerlink" title="（1）库的创建"></a>（1）库的创建</h4><ul>
<li><p>语法：<font color="red">create database 库名</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE books;</span><br><span class="line">#如果库不存在则创建</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> books;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）库的修改"><a href="#（2）库的修改" class="headerlink" title="（2）库的修改"></a>（2）库的修改</h4><ul>
<li>语法：rename datebase 库名 to 新库名;【不安全，已废弃】</li>
</ul>
<h4 id="（3）库的删除"><a href="#（3）库的删除" class="headerlink" title="（3）库的删除"></a>（3）库的删除</h4><ul>
<li><p>语法：<font color="red">drop database 库名</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE books;</span><br><span class="line">#如果存在则删除</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> books;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-表的管理"><a href="#2-表的管理" class="headerlink" title="2.表的管理"></a>2.表的管理</h3><h4 id="（1）表的创建"><a href="#（1）表的创建" class="headerlink" title="（1）表的创建"></a>（1）表的创建</h4><ul>
<li><p>语法：</p>
<p><font color="red">create table 表名(</font>    列名 列的类型 [(长度) 约束],<br><font color="red">    列名 列的类型 [(长度) 约束],</font></p>
<p><font color="red">    列名 列的类型 [(长度) 约束],</font></p>
<p>​    <font color="red">…</font><br>​    <font color="red">列名 列的类型 [(长度) 约束],</font></p>
</li>
<li><p>案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：创建表book</span><br><span class="line">USE books;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> book(</span><br><span class="line">	id <span class="type">INT</span>,#编号</span><br><span class="line">	bName <span class="type">VARCHAR</span>(<span class="number">20</span>),#书名</span><br><span class="line">	price <span class="keyword">DOUBLE</span>,#价格</span><br><span class="line">	author <span class="type">VARCHAR</span>(<span class="number">20</span>),#作者编号</span><br><span class="line">	pulishDate DATETIME#出版日期</span><br><span class="line">);</span><br><span class="line"><span class="keyword">DESC</span> book;</span><br><span class="line"></span><br><span class="line">#案例：创建表author</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> author(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	au_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	nation <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">DESC</span> author;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）表的修改"><a href="#（2）表的修改" class="headerlink" title="（2）表的修改"></a>（2）表的修改</h4><ul>
<li><p>语法：<font color="red">alter table 表名 add|drop|modify|change column</font></p>
</li>
<li><p>修改列名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book CHANGE <span class="keyword">COLUMN</span> publishDate pubData DATETIME;</span><br></pre></td></tr></table></figure></li>
<li><p>修改列的类型或约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book MODIFY <span class="keyword">COLUMN</span> pubData <span class="type">TIMESTAMP</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>添加新列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> annual <span class="keyword">DOUBLE</span>; #年薪</span><br></pre></td></tr></table></figure></li>
<li><p>删除列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> annual;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> annual;</span><br></pre></td></tr></table></figure></li>
<li><p>修改表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author RENAME <span class="keyword">TO</span> book_author;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）表的复制"><a href="#（3）表的复制" class="headerlink" title="（3）表的复制"></a>（3）表的复制</h4><ul>
<li><p>仅复制表的结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">copy</span> <span class="keyword">LIKE</span> author;</span><br></pre></td></tr></table></figure></li>
<li><p>复制表的结构+数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy1 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> author;</span><br></pre></td></tr></table></figure></li>
<li><p>仅复制部分数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CRATE <span class="keyword">TABLE</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy2</span><br><span class="line"><span class="keyword">SELECT</span> id,au_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> nation<span class="operator">=</span><span class="string">&#x27;中国&#x27;</span>;copy1 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> author;</span><br></pre></td></tr></table></figure></li>
<li><p>仅复制部分结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy3</span><br><span class="line"><span class="keyword">SELECT</span> id,au_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>; #恒不成立，没有数据</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（4）表的删除"><a href="#（4）表的删除" class="headerlink" title="（4）表的删除"></a>（4）表的删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> book_author;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> book_author;</span><br></pre></td></tr></table></figure>



<h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><h4 id="（1）整型"><a href="#（1）整型" class="headerlink" title="（1）整型"></a>（1）整型</h4><ul>
<li><table>
<thead>
<tr>
<th align="center">整型类型</th>
<th align="center">字节</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tinyint</td>
<td align="center">1</td>
<td align="center">有符号：-128<del>127   无符号：0</del>255</td>
</tr>
<tr>
<td align="center">smallint</td>
<td align="center">2</td>
<td align="center">有符号：-32768<del>32767   无符号：0</del>65535</td>
</tr>
<tr>
<td align="center">mediumint</td>
<td align="center">3</td>
<td align="center">有符号：-8388608<del>8388607    无符号：0</del>1677215</td>
</tr>
<tr>
<td align="center">int\integer</td>
<td align="center">4</td>
<td align="center">有符号：- 2147483648<del>2147483647 无符号：0</del>4294967295</td>
</tr>
<tr>
<td align="center">bigint</td>
<td align="center">8</td>
<td align="center">有符号：-9223372036854775808<del>9223372036854775807 无符号：0</del>9223372036854775807*2+1</td>
</tr>
</tbody></table>
</li>
<li><p>特点：</p>
<ul>
<li>a.默认是有符号，如果要设置无符号，需要添加关键字unsigned</li>
<li>b.如果插入的数值超出了整型的范围，会报out of range异常，并且插入临界值<br>c.如果不设置长度，会有默认长度。</li>
<li>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用</li>
</ul>
</li>
<li><p>如何设置无符号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_int(</span><br><span class="line">	t1 <span class="type">INT</span>,</span><br><span class="line">	t2 <span class="type">INT</span> UNSIGNED,</span><br><span class="line">	t3 <span class="type">INT</span>(<span class="number">8</span>) ZEROFILL</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）小数"><a href="#（2）小数" class="headerlink" title="（2）小数"></a>（2）小数</h4><ul>
<li><table>
<thead>
<tr>
<th align="center">浮点数类型</th>
<th align="center">字节</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">±1.75494351E-38~±3.402823466E+38</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">±2.2250738585072014E-308~±1.7976931348623157E+308</td>
</tr>
<tr>
<td align="center">定点数类型</td>
<td align="center">字节</td>
<td align="center">范围</td>
</tr>
<tr>
<td align="center">dec(M,D)    decimal(M,D)</td>
<td align="center">M+2</td>
<td align="center">最大取值范围与double相同，给定decimal的有效取值范围由M和D</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="（3）字符型"><a href="#（3）字符型" class="headerlink" title="（3）字符型"></a>（3）字符型</h4><ul>
<li>char和varchar</li>
</ul>
<table>
<thead>
<tr>
<th align="center">写法</th>
<th align="center">M的意思</th>
<th align="center">特点</th>
<th align="center">空间消耗</th>
<th align="center">效率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char(M)</td>
<td align="center">最大字符数，可以省略默认为1</td>
<td align="center">固定长度的字符</td>
<td align="center">比较耗费</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">varchar(M)</td>
<td align="center">最大字符数，不可用省略</td>
<td align="center">可变长度的字符</td>
<td align="center">比较节省</td>
<td align="center">低</td>
</tr>
</tbody></table>
<p>​    当存储的字段的字符数固定时用char;当存储的字段的字符数变化时用varchar</p>
<ul>
<li><p>enum 枚举型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_char(</span><br><span class="line">	c1 ENUM(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_char <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>),(<span class="string">&#x27;b&#x27;</span>),(<span class="string">&#x27;c&#x27;</span>),(<span class="string">&#x27;d&#x27;</span>),(<span class="string">&#x27;A&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>set 集合型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_set(</span><br><span class="line">	c1 <span class="keyword">set</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_set <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>),(<span class="string">&#x27;A,b&#x27;</span>),(<span class="string">&#x27;a,c&#x27;</span>),(<span class="string">&#x27;a,b,c&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（4）日期型"><a href="#（4）日期型" class="headerlink" title="（4）日期型"></a>（4）日期型</h4><table>
<thead>
<tr>
<th align="center">日期和时间类型</th>
<th align="center">字节</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">date</td>
<td align="center">4</td>
<td align="center">1000-01-01</td>
<td align="center">9999-12-31</td>
</tr>
<tr>
<td align="center">datetime</td>
<td align="center">8</td>
<td align="center">1000-01-01 00:00:00</td>
<td align="center">9999-12-31 23:59:59</td>
</tr>
<tr>
<td align="center">timestamp</td>
<td align="center">4</td>
<td align="center">19700101080001</td>
<td align="center">2038年的某个时刻</td>
</tr>
<tr>
<td align="center">time</td>
<td align="center">3</td>
<td align="center">-838:59:59</td>
<td align="center">838:59:59</td>
</tr>
<tr>
<td align="center">year</td>
<td align="center">1</td>
<td align="center">1901</td>
<td align="center">2155</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_date(</span><br><span class="line">	t1 DATETIME,</span><br><span class="line">	t2 <span class="type">TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_date <span class="keyword">VALUES</span>(NOW(),NOW());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tab_date;</span><br><span class="line">#改时区</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;time_zone&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> time_zone<span class="operator">=</span><span class="string">&#x27;+9:00&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="4-常见约束"><a href="#4-常见约束" class="headerlink" title="4.常见约束"></a>4.常见约束</h3><h4 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><ul>
<li><p>含义：一种限制，用于限制表中的数据，为了保证表中数据的准确可靠性</p>
</li>
<li><p>分类：六大约束</p>
<ul>
<li>NOT NULL：非空。用于保证该字段非空（如姓名、学号）</li>
<li>DEFAULT：默认。用于保证该字段有默认值（如姓名）</li>
<li>PRIMARY KEY：主键。用于保证该字段唯一且非空（如学号、员工编号）</li>
<li>UNIQUE：唯一。用于保证该字段的值唯一性，可以为空（如座位号）</li>
<li>CHECK：检查【mysql不支持】。（如年龄、性别）</li>
<li>FOREIGIN KEY：外键。用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值。在从表中添加外键约束，用于引用主表中某列的值（比如学生表的专业编号，员工表的部门编号，员工表的工种编号）</li>
</ul>
</li>
<li><p>添加约束的时机：</p>
<pre><code>1.创建表时
  2.修改表时
</code></pre>
</li>
<li><p>约束的添加分类：</p>
<pre><code>列级约束（六大约束都支持，但foreign key没有效果
  表级约束（除了&lt;font color=&#39;red&#39;&gt;非空、默认&lt;/font&gt;，其他都支持）
</code></pre>
</li>
</ul>
<h4 id="（2）创建表时添加约束"><a href="#（2）创建表时添加约束" class="headerlink" title="（2）创建表时添加约束"></a>（2）创建表时添加约束</h4><ul>
<li><p>1.添加列级约束</p>
<ul>
<li><p>语法：</p>
<p><font color="red">create table 表名(</font>    </p>
<p>​    <font color="red">字段名 字段类型 列级约束，</font><br>​    <font color="red">字段名 字段类型 列级约束，</font><br>​    <font color="red">…</font><br><font color="red">)</font></p>
</li>
<li><p>举例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE students;</span><br><span class="line">USE students;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> major(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	marjorName <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, 		  #主键</span><br><span class="line">	stuName <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, #非空</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span>(gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">OR</span> gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),#检查</span><br><span class="line">	seat <span class="type">INT</span> <span class="keyword">UNIQUE</span>, 	#唯一</span><br><span class="line">	age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>, #默认</span><br><span class="line">	marjorId <span class="type">INT</span> <span class="keyword">REFERENCES</span> major(id) #外键：引用marjor表中的id为外键</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查看约束信息</span><br><span class="line"><span class="keyword">DESC</span> stuinfo;</span><br><span class="line">#查看stuinfo表中所有的索引，包括主键、外键、唯一</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> stuinfo;</span><br></pre></td></tr></table></figure></li>
<li><p>2.添加表级约束</p>
<ul>
<li><p>语法：</p>
<p><font color="red">create table 表名(</font>    </p>
<p>​    <font color="red">字段名 字段类型,</font><br>​    <font color="red">字段名 字段类型,</font><br>​    <font color="red">…</font><br>​    <font color="red">constraint [约束名] 约束类型（字段名，</font><br>​    <font color="red">constraint [约束名] 约束类型（字段名）</font><br>​    <font color="red">…</font><br><font color="red">)</font></p>
</li>
<li><p>举例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> stuinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	stuName <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	seat <span class="type">INT</span>,</span><br><span class="line">	majorId <span class="type">INT</span>,</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> pk <span class="keyword">PRIMARY</span> KEY(id), #主键</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> uq <span class="keyword">UNIQUE</span>(seat),	   #唯一</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> ck <span class="keyword">CHECK</span>(gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">OR</span> gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),#检查</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> KEY(majorid) <span class="keyword">REFERENCES</span> major(id)#外键</span><br><span class="line">); </span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>3.通用的写法（表级约束写外键约束）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> studinfo(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	stuName <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span>(gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">OR</span> gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">	age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>,</span><br><span class="line">	seat <span class="type">INT</span> UNICODE,</span><br><span class="line">	marjorId <span class="type">INT</span>,</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> KEY(majorId) <span class="keyword">REFERENCES</span> major(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>4.primary key VS unique</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>保证唯一性</th>
<th>是否允许为空</th>
<th>一个表中可有几个</th>
</tr>
</thead>
<tbody><tr>
<td>PRIMARY KEY</td>
<td>√</td>
<td>×</td>
<td>一个</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>√</td>
<td>√</td>
<td>多个</td>
</tr>
</tbody></table>
<ul>
<li>5.foreign key<br>​    1.要求在从表设置外键关系<br>​    2.从表中外键列的类型和主表的关联列的类型要求一致或兼容，名称可以不一样<br>​    3.要求主表中的关联列必须是一个key(主键或唯一键）<br>​    4.插入数据时，先插入主表，再插入从表；删除数据时，先删除从表，再删除主表</li>
</ul>
<h4 id="3-修改表时添加约束"><a href="#3-修改表时添加约束" class="headerlink" title="(3)修改表时添加约束"></a>(3)修改表时添加约束</h4><ul>
<li><p>语法：</p>
<p>添加列级约束：</p>
<pre><code>&lt;font color=&#39;red&#39;&gt;alter table 表名 modify column 字段名 字段类型 新约束;&lt;/font&gt;
</code></pre>
<p>添加表级约束：</p>
<pre><code>&lt;font color=&#39;red&#39;&gt;alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】 &lt;/font&gt;
</code></pre>
</li>
<li><p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span>添加非空约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFIER <span class="keyword">COLUMN</span> stuName <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>添加默认约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>添加主键</span><br><span class="line">#（<span class="number">1</span>）列级约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFIER <span class="keyword">COLUMN</span> id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line">#（<span class="number">2</span>）表级约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(id);</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span>添加唯一键</span><br><span class="line">#（<span class="number">1</span>）列级约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> id <span class="type">INT</span> <span class="keyword">UNIQUE</span>;</span><br><span class="line">#（<span class="number">2</span>）表级约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(seat);</span><br><span class="line"></span><br><span class="line">#<span class="number">5.</span>添加外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(majorId) <span class="keyword">REFERENCES</span> major(id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_sutinfo_major <span class="keyword">FOREIGN</span> KEY(majorId) <span class="keyword">REFERENCES</span> major(id);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（4）修改表时删除约束"><a href="#（4）修改表时删除约束" class="headerlink" title="（4）修改表时删除约束"></a>（4）修改表时删除约束</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span>删除非空约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> stuName <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>删除默认约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFIER <span class="keyword">COLUMN</span> age <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>删除主键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> id <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span>删除唯一键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> INDEX seat;</span><br><span class="line"></span><br><span class="line">#<span class="number">5.</span>删除外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_stuinfo_major;</span><br></pre></td></tr></table></figure>



<h3 id="5-标识列"><a href="#5-标识列" class="headerlink" title="5.标识列"></a>5.标识列</h3><ul>
<li><p>含义：又称为自增长列。可以不用手动的插入值，系统提供默认的序列值</p>
</li>
<li><p>特点：</p>
<pre><code>1.标识列要求是一个key
  2.一个表中最多有一个标识列
  3.标识列的类型只能是数值型：int float double
  4.表示列可以通过SET auto_increment_increment=3设置步长；通过插入值设置初始值
</code></pre>
</li>
<li><p>创建表时设置标识列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_indentity(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> tab_indentity;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_indentity(NAME) <span class="keyword">VALUES</span>(<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_indentity <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;lucy&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#查看自增长变量</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%auto_increment%&#x27;</span>;</span><br><span class="line">#修改自增长步长</span><br><span class="line"><span class="keyword">SET</span> auto_increment_increment<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>修改表时设置标识列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_indentity MODIFIER <span class="keyword">COLUMN</span> id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT;</span><br><span class="line"></span><br><span class="line">#修改表时删除标识列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_indentity MODIFIER <span class="keyword">COLUMN</span> id <span class="type">INT</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TCL语言"><a href="#TCL语言" class="headerlink" title="TCL语言"></a>TCL语言</h2><p>Transaction Control Language 事务控制语言</p>
<h3 id="1-事务的概念"><a href="#1-事务的概念" class="headerlink" title="1.事务的概念"></a>1.事务的概念</h3><p>事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。</p>
<h3 id="3-事务的ACID属性【面试题】"><a href="#3-事务的ACID属性【面试题】" class="headerlink" title="3.事务的ACID属性【面试题】"></a>3.事务的ACID属性【面试题】</h3><ul>
<li>原子性（Atomicity）</li>
</ul>
<p>事务是一个<font color="orange">不可分割</font>的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<ul>
<li>一致性（Consistency）</li>
</ul>
<p>事务必须使数据库从一个<font color="orange">一致性状态</font>变换到另外一个一致性状态（一致性：可靠+完整）</p>
<ul>
<li>隔离性（Isolation）</li>
</ul>
<p>一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间<font color="orange">不能互相干扰</font>。</p>
<ul>
<li>持久性（Durability）</li>
</ul>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的<font color="orange">改变就是永久性的</font>，接下来的其他操作和数据库故障不应该对其有任何影响</p>
<h3 id="4-编写事务的步骤"><a href="#4-编写事务的步骤" class="headerlink" title="4.编写事务的步骤"></a>4.编写事务的步骤</h3><ul>
<li><p>步骤一：开启事务<br>set autocommit=0;    #设置自动提交功能为禁用<br>start transaction;    [可选]</p>
</li>
<li><p>步骤二：编写事务中的sql语句(select insert update delete)<br>语句1；<br>语句2；<br>…</p>
</li>
<li><p>步骤三：结束事务（提交或回滚）<br>commit；提交事务<br>rollback; 回滚事务</p>
</li>
</ul>
<h3 id="5-事务的隔离级别"><a href="#5-事务的隔离级别" class="headerlink" title="5.事务的隔离级别"></a>5.事务的隔离级别</h3><h4 id="（1）并发带来的问题【面试题】"><a href="#（1）并发带来的问题【面试题】" class="headerlink" title="（1）并发带来的问题【面试题】"></a>（1）并发带来的问题【面试题】</h4><ul>
<li><p><font color="red">脏读</font>：<font color="orange"> 一个事务读取了另一个事务未提交的数据</font>。</p>
<ul>
<li><p>对于两个事务 T1, T2。 T1 读取了已经被 T2 更新但还没有被提交的字段.</p>
<p>之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</p>
</li>
<li><p>解决方法：脏读本质上是读写操作的冲突，解决办法是写完之后再读。</p>
</li>
<li><p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/30adcbef76094b367e38bab5accc7cd98c109dc4" alt="img"></p>
</li>
</ul>
</li>
<li><p><font color="red">不可重复读</font>：<font color="orange">一个事务两次读取同一个数据，两次读取的数据不一致</font>。</p>
<ul>
<li> 对于两个事务T1, T2,。T1 读取了一个字段, 然后 T2 更新了该字段.之后, T1再次读取同一个字段, 值就不同了。</li>
<li> 解决方法：不可重复读本质上是读写操作的冲突，解决办法是读完再写。</li>
<li> <img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/48540923dd54564e92c34561bcde9c82d0584fc7" alt="img"></li>
</ul>
</li>
<li><p><font color="red">幻读</font>：<font color="orange">一个事务两次读取一个范围的记录，两次读取的记录数不一致</font>。</p>
<ul>
<li>对于两个事务T1, T2。T1 从一个表中读取了一个字段, 然后 T2 在该表中插 入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行</li>
<li>解决方法：幻象读本质上是读写操作的冲突，解决办法是读完再写。</li>
<li><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/29381f30e924b899d124d96061061d950a7bf64a" alt="img"></li>
</ul>
</li>
<li><p><font color="red">更新丢失</font>：<font color="orange">一个事务的更新覆盖了另一个事务的更新</font>。</p>
<ul>
<li>对于两个事务T1，T2。T1和T2读取同一个字段后，都进行了修改，但是后面修改的数据结果会覆盖前面修改的数据结果。</li>
<li>更新丢失本质上是写操作的冲突，解决办法是一个一个地写。</li>
<li><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/32fa828ba61ea8d3f299d55c980a304e251f582a" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="（2）事务隔离级别"><a href="#（2）事务隔离级别" class="headerlink" title="（2）事务隔离级别"></a>（2）事务隔离级别</h4><table>
<thead>
<tr>
<th>隔离级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED（读未提交数据）</td>
<td>允许事务读取未被其他事务提交的变更。脏读、不可重复读、幻读</td>
</tr>
<tr>
<td>READ COMMITTED（读已提交数据）</td>
<td>只允许事务读取已经被其他事务提交的变更，可以避免脏读，但不可重复读和幻读的问题任然存在</td>
</tr>
<tr>
<td>REPEATBLE READ（可重复读）</td>
<td>确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复度，但幻读问题依然存在</td>
</tr>
<tr>
<td>SERIALIZABLE（串行化）</td>
<td>确保事务可以从一个表中读取相同的行，再这个事务持续期间，禁止其他事务执行插入、更新、删除操作，所有并发问题都可以避免，但性能十分低下。</td>
</tr>
</tbody></table>
<ul>
<li>Oracle 支持的2 种事务隔离级别：READ COMMITED,  SERIALIZABLE。Oracle 默认的事务隔离级别为: READ  COMMITED  Mysql 支持4 种事务隔离级别. Mysql 默认的事务隔离级别为: <font color="red">REPEATABLE READ</font></li>
<li>Mysql 支持4 种事务隔离级别. Mysql 默认的事务隔离级别为: <font color="red">REPEATABLE READ</font></li>
</ul>
<h4 id="（3）设置事务的隔离级别"><a href="#（3）设置事务的隔离级别" class="headerlink" title="（3）设置事务的隔离级别"></a>（3）设置事务的隔离级别</h4><ul>
<li><p>查看当前的隔离级别：</p>
<p>​    <font color="red">SELECT @@tx_isolation;</font></p>
</li>
<li><p>设置当前MySQL连接会话的隔离级别：</p>
<p>​    <font color="red">set session transaction isolation level 隔离级别类型;</font>该命令只对当前会话生效，不影响其他会话和全局的事务隔离级别配置。</p>
</li>
<li><p>设置下一次事务的事务隔离级别：</p>
<p>​    <font color="red">set transaction isolation level 隔离级别类型；</font>该命令只对下一次事务生效，不会影响会话本身设置的事务隔离级别。</p>
</li>
<li><p>设置数据库系统的全局的隔离级别：</p>
<p>​    <font color="red">set global transaction isolation level 隔离级别类型;</font>该命令不会影响当前已连接的会话的事务隔离级别，对于以后的连接会话生效。</p>
</li>
</ul>
<h4 id="（4）举例"><a href="#（4）举例" class="headerlink" title="（4）举例"></a>（4）举例</h4><ul>
<li><p>read uncommitted (脏读，不可重复读，幻读，更新丢失 都不能解决)</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823152455209.png" alt="image-20210823152455209"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823152945662.png" alt="image-20210823152945662"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823153532343.png" alt="image-20210823153532343"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823154321948.png" alt="image-20210823154321948"></p>
</li>
</ul>
<ul>
<li><p>read committed (解决脏读，不可重复读，幻读，更新丢失仍存在)</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823160252930.png" alt="image-20210823160252930"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823160729970.png" alt="image-20210823160729970"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823161335871.png" alt="image-20210823161335871"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823162011169.png" alt="image-20210823162011169"></p>
</li>
</ul>
<ul>
<li><p>repeatable read （解决脏读、不可重复读，未解决幻读、丢失更新）</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823163921044.png" alt="image-20210823163921044"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210824153058925.png" alt="image-20210824153058925"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210824153530697-1639382732842.png" alt="image-20210824153530697"></p>
</li>
</ul>
<ul>
<li><p>serializable（四种并发问题都能解决）</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210824154220383-1639382732842.png" alt="image-20210824154220383"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210824155313404-1639382732842.png" alt="image-20210824155313404"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210824160049809-1639382732842.png" alt="image-20210824160049809"></p>
</li>
</ul>
<h4 id="（5）设置回滚点"><a href="#（5）设置回滚点" class="headerlink" title="（5）设置回滚点"></a>（5）设置回滚点</h4><p>语法：回滚到point a，操作1仍然会提交，只有操作2会回滚</p>
<p>​        set autocommit=0;</p>
<p>​        start transaction;</p>
<p>​        [操作1]</p>
<p>​        savepoint a;</p>
<p>​        [操作2]</p>
<p>​        rollback to a;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">start</span> transaction;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> balance;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span> money <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> zzx  <span class="operator">|</span>  <span class="number">1100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> ddj  <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> zii  <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> zij  <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> balance <span class="keyword">where</span> id<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">5.62</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">savepoint</span> a;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> balance <span class="keyword">where</span> id<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">rollback</span> <span class="keyword">to</span> a;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> balance;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span> money <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> zzx  <span class="operator">|</span>  <span class="number">1100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> ddj  <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> zij  <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>



<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="1-视图的概念"><a href="#1-视图的概念" class="headerlink" title="1.视图的概念"></a>1.视图的概念</h3><p>（1）MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。</p>
<p>（2）应用场景</p>
<ul>
<li>多个地方用到同样的查询结果</li>
<li>该查询结果使用的sql语句较为复杂</li>
</ul>
<h3 id="2-创建视图"><a href="#2-创建视图" class="headerlink" title="2.创建视图"></a>2.创建视图</h3><p>（1）语法</p>
<p>​    create view 视图名</p>
<p>​    as 查询语句;</p>
<p>（2）举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#案例一：创建视图查询每个部门的平均工资</span><br><span class="line">CREATE VIEW my_view1</span><br><span class="line">AS</span><br><span class="line">SELECT AVG(salary) ag,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br></pre></td></tr></table></figure>



<h3 id="3-删除视图"><a href="#3-删除视图" class="headerlink" title="3.删除视图"></a>3.删除视图</h3><p>drop view 视图名1，视图名2,….；</p>
<h3 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4.查看视图"></a>4.查看视图</h3><p>（1）DESC 视图名；</p>
<p>（2）SHOW CREATE VIEW 视图名\G；</p>
<h3 id="5-视图更新"><a href="#5-视图更新" class="headerlink" title="5.视图更新"></a>5.视图更新</h3><p>​    以下操作会修改原始表</p>
<p>（1）插入数据</p>
<p>​    insert into 视图名 values(…)</p>
<p>（2）更改数据</p>
<p>​    update 视图名 set …</p>
<p>（3）删除数据</p>
<p>​    delete from 视图名 where …</p>
<p>（4）视图的可更新性和视图中查询的定义有关系，以下类型的视图是不能更新的：</p>
<ul>
<li>包含以下关键字的sql语句：分组函数、distinct、group、by、having、union或者union all</li>
<li>常量视图</li>
<li>select中包含子查询</li>
<li>from一个不能更新的视图</li>
<li>where子句的子查询引用了from子句中的表</li>
</ul>
<h3 id="6-视图VS表"><a href="#6-视图VS表" class="headerlink" title="6.视图VS表"></a>6.视图VS表</h3><table>
<thead>
<tr>
<th></th>
<th>创建语法关键字</th>
<th>是否实际占用物理空间</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>create view</td>
<td>只是保存了sql逻辑</td>
<td>增删该查，一般不能</td>
</tr>
<tr>
<td>表</td>
<td>create table</td>
<td>保存了数据</td>
<td>增删改查</td>
</tr>
</tbody></table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>系统变量：全局变量，会话变量</p>
<p>自定义变量：用户变量，局部变量</p>
<h3 id="1-系统变量"><a href="#1-系统变量" class="headerlink" title="1.系统变量"></a>1.系统变量</h3><p>说明：变量由系统提供，不是用户定义，属于服务器层面</p>
<h4 id="（1）相关命令"><a href="#（1）相关命令" class="headerlink" title="（1）相关命令"></a>（1）相关命令</h4><ul>
<li><p>（1）查看所有的系统变量</p>
<p>​    show global| 【session】 variables;</p>
</li>
<li><p>（2）查看满足条件的部分系统变量</p>
<p>​    show global | 【session】 variables like ‘%char%’;</p>
</li>
<li><p>（3）查看指定的某个系统变量的值</p>
<p>​    select @@global|【session】.系统变量名；</p>
</li>
<li><p>（4）为某个系统变量赋值</p>
<p>​    方式一：set global|【session】 系统变量名 = 值；</p>
<p>​    方式二：set @@global|【session】.系统变量名 = 值；</p>
</li>
</ul>
<p>注意：如果是全局级别的系统变量，需要加global；如果是会话级别的系统变量，需要加session；不加默认为会话级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL VARIABLES\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: auto_increment_increment</span><br><span class="line">        Value: 1</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: auto_increment_offset</span><br><span class="line">        Value: 1</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">Variable_name: autocommit</span><br><span class="line">        Value: ON</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">Variable_name: automatic_sp_privileges</span><br><span class="line">        Value: ON</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">Variable_name: back_log</span><br><span class="line">        Value: 50</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">Variable_name: basedir</span><br><span class="line">        Value: C:/Program Files (x86)/MySQL/MySQL Server 5.5/</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">Variable_name: big_tables</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">Variable_name: binlog_cache_size</span><br><span class="line">        Value: 32768</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line">Variable_name: binlog_direct_non_transactional_updates</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 10. row ***************************</span><br><span class="line">Variable_name: binlog_format</span><br></pre></td></tr></table></figure>

<h4 id="（2）全局变量"><a href="#（2）全局变量" class="headerlink" title="（2）全局变量"></a>（2）全局变量</h4><ul>
<li>作用域：服务器每次启动将所有的全局变量赋初始值，针对于所有的会话（连接）有效，但不能跨重启</li>
</ul>
<h4 id="（3）会话变量"><a href="#（3）会话变量" class="headerlink" title="（3）会话变量"></a>（3）会话变量</h4><ul>
<li>作用域：仅仅针对于当前会话（连接）有效</li>
</ul>
<h3 id="2-自定义变量"><a href="#2-自定义变量" class="headerlink" title="2.自定义变量"></a>2.自定义变量</h3><p>说明：变量由用户自定义</p>
<h4 id="（1）用户变量"><a href="#（1）用户变量" class="headerlink" title="（1）用户变量"></a>（1）用户变量</h4><ul>
<li><p>作用域：针对于当前会话（连接）有效，同于会话变量作用域</p>
</li>
<li><p>声明并初始化：</p>
<ul>
<li>方式一：set @用户变量名 = 值；</li>
<li>方式二：set @用户变量名 := 值；</li>
<li>方式三：select @用户变量名 := 值；</li>
</ul>
</li>
<li><p>赋值（更新）</p>
<ul>
<li><p>方式一：(set或select)</p>
<ul>
<li>set @用户变量名 = 值；</li>
<li>set @用户变量名 := 值；</li>
<li>select @用户变量名 := 值；</li>
</ul>
</li>
<li><p>方式二：（select into）</p>
<p>​    select 字段 into @变量名 from 表；</p>
<p>​    要求查询出的是一个值</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @name=&#x27;john&#x27;;</span><br><span class="line">set @age:=32;</span><br><span class="line">select @count=1;</span><br><span class="line"></span><br><span class="line">select count(*) into @count</span><br><span class="line">from employee;</span><br><span class="line"></span><br><span class="line">select @count;</span><br></pre></td></tr></table></figure></li>
<li><p>查看</p>
<p>select @变量名</p>
</li>
</ul>
<h4 id="（2）局部变量"><a href="#（2）局部变量" class="headerlink" title="（2）局部变量"></a>（2）局部变量</h4><ul>
<li><p>作用域：仅仅在定义它的begin end中有效，定义应为begin end中的第一句话</p>
</li>
<li><p>声明（并初始化）</p>
<ul>
<li><font color="red">declare</font> 变量名 <font color="red"> 类型</font>；</li>
<li>declare 变量名 类型 default 值；</li>
</ul>
</li>
<li><p>赋值</p>
<ul>
<li><p>方式一：(set或select)</p>
<ul>
<li>set 局部变量名 = 值；</li>
<li>set 局部变量名 := 值；</li>
<li>select @局部变量名 := 值；</li>
</ul>
</li>
<li><p>方式二：（select into）</p>
<p>​    select 字段 into 变量名 from 表；</p>
</li>
</ul>
</li>
<li><p>查看</p>
<p>select 局部变量名；</p>
</li>
</ul>
<h4 id="（3）对比"><a href="#（3）对比" class="headerlink" title="（3）对比"></a>（3）对比</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">作用域</th>
<th align="center">定义和使用位置</th>
<th align="center">语法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">用户变量</td>
<td align="center">当前会话</td>
<td align="center">会话中任何地方</td>
<td align="center">必须加@符号</td>
</tr>
<tr>
<td align="center">局部变量</td>
<td align="center">begin end中</td>
<td align="center">只能在begin end中，且为第一句话</td>
<td align="center">一般不用加@符号，需要限定类型</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用户变量</span><br><span class="line">mysql&gt; SET @m=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SET @n=2;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SET @sum=@m+@n;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @sum;</span><br><span class="line">+------+</span><br><span class="line">| @sum |</span><br><span class="line">+------+</span><br><span class="line">|    3 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><p>好处：</p>
<p>1.提高代码的重用性</p>
<p>2.简化操作</p>
<h3 id="1-存储过程"><a href="#1-存储过程" class="headerlink" title="1.存储过程"></a>1.存储过程</h3><h4 id="（1）含义"><a href="#（1）含义" class="headerlink" title="（1）含义"></a>（1）含义</h4><p>​    一组预先编译好的SQL语句的集合，可理解成批处理语句</p>
<h4 id="（2）好处"><a href="#（2）好处" class="headerlink" title="（2）好处"></a>（2）好处</h4><p>​    1.提高代码的重用性</p>
<p>​    2.简化操作</p>
<p>​    3.减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>
<h4 id="（3）语法"><a href="#（3）语法" class="headerlink" title="（3）语法"></a>（3）语法</h4><ul>
<li><p>创建</p>
<ul>
<li><p>语法</p>
<p>create <font color="red">procedure</font> 存储过程名(参数列表)</p>
<p>begin</p>
<p>​        方法体</p>
<p>end</p>
</li>
<li><p>参数列表包含三部分：</p>
<p>​    参数模式 参数名 参数类型</p>
<p>​    例如：in stuname varchar(20)</p>
</li>
<li><p>参数模式：</p>
<ul>
<li>in：该参数可以作为输入，也就是说该参数需要调用方传入值</li>
<li>out：该参数可以作为输出，也就是说该参数可以作为返回值</li>
<li>inout：该参数既可以作为输入，又可以作为输出，也就是该参数急需要传入值，有可以返回值</li>
</ul>
</li>
<li><p>如果方法体只有一句话，则begin end可以省略；存储过程中的每条SQL语句的结尾都要求必须加分号；存储过程的结尾可以使用delimiter重新设置</p>
<ul>
<li>delimiter 结束标记    如delimiter $</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>调用<ul>
<li><font color="red">call</font> 存储过程名(实参列表)；</li>
</ul>
</li>
</ul>
<h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h3><h4 id="（1）函数与存储过程区别"><a href="#（1）函数与存储过程区别" class="headerlink" title="（1）函数与存储过程区别"></a>（1）函数与存储过程区别</h4><ul>
<li>存储过程：可以有0个返回，也可以有过个返回；适合做批量插入、批量更新</li>
<li>函数：有且仅有1个返回；适合做处理数据后返回一个结果的情况</li>
</ul>
<h4 id="（2）语法"><a href="#（2）语法" class="headerlink" title="（2）语法"></a>（2）语法</h4><ul>
<li><p>创建</p>
<ul>
<li><p>语法</p>
<p>create function 函数名(参数列表)  returns 返回类型</p>
<p>begin</p>
<p>​        函数体</p>
<p>end</p>
</li>
<li><p>参数列表包含两部分</p>
<ul>
<li>参数名 参数类型</li>
</ul>
</li>
<li><p>函数体</p>
<ul>
<li>肯定有return语句</li>
</ul>
</li>
<li><p>如果函数体只有一句话，则begin end可以省略；存储过程中的每条SQL语句的结尾都要求必须加分号；存储过程的结尾可以使用delimiter重新设置</p>
<ul>
<li>delimiter 结束标记    如delimiter </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>调用</p>
<ul>
<li><font color="red">select</font> 函数名(参数列表)</li>
</ul>
</li>
<li><p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.无参有返回</span><br><span class="line"># 案例：返回公司员工个数</span><br><span class="line">CREATE FUNCTION myf!() RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE c INT DEFAULT 0; #定义变量</span><br><span class="line">	SELECT COUNT(*) INTO c;		#赋值</span><br><span class="line">	RETURN c;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf!()$	#调用</span><br><span class="line"></span><br><span class="line">#2.有参有返回</span><br><span class="line"># 案例：更加员工名返回工资</span><br><span class="line">CREATE FUNCTION myf@(empName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">	SET @sal=0;    #定义用户变量</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name = empName;</span><br><span class="line">	RETURN @sal;</span><br><span class="line">END $</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）查看和删除函数"><a href="#（3）查看和删除函数" class="headerlink" title="（3）查看和删除函数"></a>（3）查看和删除函数</h4><ul>
<li><p>查看函数定义</p>
<ul>
<li>show create function 函数名；</li>
</ul>
</li>
<li><p>删除函数</p>
<ul>
<li>drop function 函数名；</li>
</ul>
</li>
</ul>
<h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1.分支结构"></a>1.分支结构</h3><h4 id="（1）if函数"><a href="#（1）if函数" class="headerlink" title="（1）if函数"></a>（1）if函数</h4><ul>
<li>功能：实现简单的双分支</li>
<li>语法：<ul>
<li>if（表达式1，表达式2，表达式3）</li>
</ul>
</li>
<li>执行顺序：<ul>
<li>如果表达式1成了，返回表达式2的值，否则返回表达式3的值</li>
</ul>
</li>
</ul>
<h4 id="（2）case结构"><a href="#（2）case结构" class="headerlink" title="（2）case结构"></a>（2）case结构</h4><ul>
<li><p>功能：</p>
<ul>
<li>情况1：类似java中的switch语句，一般用于实现等值判断</li>
<li>情况2：类似java中的多重if语句，一般用户实现区间判断</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><p>情况1：</p>
<p>case 变量|表达式|字段</p>
<p>when 要判断的值1 then 返回的值1或语句1；</p>
<p>when 要判断的值1 then 返回的值2或语句2;</p>
<p>…</p>
<p>else 返回的值n或语句n;</p>
<p>end case;</p>
</li>
<li><p>情况2：</p>
<p>case</p>
<p>when 要判断的条件1 then 返回的值1或语句1；</p>
<p>when 要判断的条件2 then 返回的值2或语句2；</p>
<p>…</p>
<p>else 返回的值n或语句n;</p>
<p>end case;</p>
</li>
</ul>
</li>
</ul>
<h4 id="（3）if结构"><a href="#（3）if结构" class="headerlink" title="（3）if结构"></a>（3）if结构</h4><ul>
<li><p>语法：</p>
<ul>
<li><p>if 条件1 then 语句1；</p>
<p>elseif 条件2 then 语句2；</p>
<p>…</p>
<p>else 语句n</p>
<p>end if</p>
</li>
<li><p>应用：只能应用在begin end中</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2.循环结构"></a>2.循环结构</h3><p>（1）循环控制</p>
<ul>
<li>iterate：类似continue</li>
<li>leave：类型break</li>
</ul>
<p>（2）语法</p>
<ul>
<li>while</li>
</ul>
<p>​    【标签：】while 循环条件 do</p>
<p>​                            循环体；</p>
<p>​                        end while 【标签】；</p>
<ul>
<li><p>loop</p>
<p>【标签：】loop</p>
<p>​                    循环体；</p>
<p>​                    end loop 【标签】；</p>
</li>
<li><p>repeat</p>
<p>【标签：】repeat</p>
<p>​                    循环体；</p>
<p>​                    until 结束循环的条件</p>
<p>​                    end repeat 【标签】；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>《MySQL》</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第三章-Linux的目录结构"><a href="#第三章-Linux的目录结构" class="headerlink" title="第三章 Linux的目录结构"></a><strong>第三章 Linux的目录结构</strong></h2><h4 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1 基本介绍"></a><strong>3.1 基本介绍</strong></h4><ul>
<li><strong>在 Linux 世界里，<font color="orange">一切皆文件</font></strong></li>
<li><strong>linux 的文件系统是采用级层式的<font color="orange">树状目录结构</font>，在此结构中的最上层是根目录</strong></li>
</ul>
<p><strong>“/”，然后在此目录下再创建其他的目录。</strong></p>
<ul>
<li><p><strong>结构图：</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="img"></strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210720151643657.png" alt="image-20210720151643657"></strong></p>
</li>
</ul>
<h4 id="3-2-目录介绍"><a href="#3-2-目录介绍" class="headerlink" title="3.2 目录介绍"></a><strong>3.2 目录介绍</strong></h4><ul>
<li><p><strong>/bin：(usr/bin)<font color="red">[重点]</font></strong><br><strong>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最<font color="orange">经常使用的命令</font>。</strong></p>
</li>
<li><p><strong>/boot：</strong><br><strong>这里存放的是启动 Linux 时使用的一些核心文件，包括一些<font color="orange">链接文件</font>以及<a href="https://zhidao.baidu.com/question/383464901.html">镜像文件</a>。</strong></p>
</li>
<li><p><strong>/dev ：</strong><br><strong>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的(一切皆是文件)。</strong></p>
</li>
<li><p><strong>/etc：<font color="red">[重点]</font></strong><br><strong>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的<font color="orange">系统管理</font>所需要的配置文件和子目录。</strong></p>
</li>
<li><p><strong>/home：<font color="red">[重点]</font></strong><br><strong>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</strong></p>
</li>
<li><p><strong>/lib：</strong><br><strong>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的<font color="orange">动态连接共享库</font>，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库</strong></p>
</li>
<li><p><strong>/lost+found：</strong><br><strong>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</strong></p>
</li>
<li><p><strong>/mnt：<font color="red">[重点]</font></strong><br><strong>系统提供该目录是为了让用户<font color="orange">临时挂载别的文件系统</font>的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</strong></p>
</li>
<li><p><strong>/opt：<font color="red">[重点]</font></strong><br><strong>opt 是 optional(可选) 的缩写，这是给主机<font color="orange">额外安装软件</font>所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</strong></p>
</li>
<li><p><strong>/proc：</strong><br><strong>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是<font color="orange">当前内核运行状态</font>的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</strong><br><strong>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all  </span><br></pre></td></tr></table></figure></li>
<li><p><strong>/root：<font color="red">[重点]</font></strong><br><strong>该目录为系统管理员，也称作超级权限者的用户主目录</strong></p>
</li>
<li><p><strong>/run：</strong><br><strong>是一个临时文件系统，<font color="orange">存储系统启动以来的信息</font>。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</strong></p>
</li>
<li><p><strong>/sbin：</strong><br><strong>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的<font color="orange">系统管理程序</font>。</strong></p>
</li>
<li><p><strong>/srv：</strong><br><strong>该目录存放一些服务启动之后需要提取的数据。</strong></p>
</li>
<li><p><strong>/sys：</strong></p>
<p><strong>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</strong></p>
<p><strong>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</strong></p>
<p><strong>该文件系统是内核设备树的一个直观反映。</strong></p>
<p><strong>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</strong></p>
</li>
<li><p><strong>/tmp：</strong><br><strong>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</strong></p>
</li>
<li><p><strong>/usr：</strong><br><strong>usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，<font color="orange">用户的很多应用程序和文件</font>都放在这个目录下，类似于 windows 下的 program files 目录。</strong></p>
<ul>
<li><p><strong>/usr/bin：</strong><br><strong>系统用户使用的应用程序。</strong></p>
</li>
<li><p><strong>/usr/sbin：</strong><br><strong>超级用户使用的比较高级的管理程序和系统守护程序。</strong></p>
</li>
<li><p><strong>/usr/src：</strong><br><strong>内核源代码默认的放置目录。</strong></p>
</li>
<li><p><strong>/usr/local：<font color="red">[重点]</font></strong></p>
<p><strong>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</strong></p>
</li>
</ul>
</li>
<li><p><strong>/var：<font color="red">[重点]</font></strong><br><strong>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</strong></p>
</li>
<li><p><strong>/media：<font color="red">[重点]</font></strong><br><strong>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</strong></p>
</li>
<li><p><strong>/selinux：</strong><br><strong>这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</strong></p>
</li>
</ul>
<h4 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a><strong>3.3 总结</strong></h4><ol>
<li><strong>Linux有且只有一个根目录 /</strong></li>
<li><strong>Linux的各个目录的内容是规划好的，不要乱放文件</strong></li>
<li><strong>Linux以文件形式管理我们的设备，一切皆文件</strong></li>
<li><strong>几个特殊目录的标识：</strong><ul>
<li><strong>根目录：/</strong> </li>
<li><strong>当前目录：. or ./</strong></li>
<li><strong>上一级目录：.. or ../</strong></li>
<li><strong>家目录：~ or ~/</strong></li>
</ul>
</li>
</ol>
<h2 id="第四章-Linux常用命令"><a href="#第四章-Linux常用命令" class="headerlink" title="第四章 Linux常用命令"></a><strong>第四章 Linux常用命令</strong></h2><h3 id="4-1-文件处理命令"><a href="#4-1-文件处理命令" class="headerlink" title="4.1 文件处理命令"></a><strong>4.1 文件处理命令</strong></h3><h4 id="4-1-0-通配符与命令格式"><a href="#4-1-0-通配符与命令格式" class="headerlink" title="4.1.0 通配符与命令格式"></a><strong>4.1.0 通配符与命令格式</strong></h4><h5 id="1-通配符"><a href="#1-通配符" class="headerlink" title="(1)通配符"></a><strong>(1)通配符</strong></h5><ul>
<li>*<strong>：匹配0或多个任意字符</strong></li>
<li><strong>？：匹配单个任意字符</strong></li>
<li><strong>[ ]：匹配一组字符中的单个，如[1-5] [a-f]</strong></li>
</ul>
<h5 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="(2)命令格式"></a><strong>(2)命令格式</strong></h5><p>​    <strong>命令格式 ：命令 [-选项] [参数]</strong> </p>
<p>​    <strong>例 ： ls -la /etc</strong> </p>
<p>​    <strong>说明：1）个别命令使用不遵循此格式</strong></p>
<p>​               <strong>2）当有多个选项时，可以写在一起</strong></p>
<p>​               <strong>3）简化选项与完整选项-a 等于 –all</strong></p>
<h4 id="4-1-1-文件处理命令ls"><a href="#4-1-1-文件处理命令ls" class="headerlink" title="4.1.1 文件处理命令ls"></a><strong>4.1.1 文件处理命令ls</strong></h4><h5 id="1-ls"><a href="#1-ls" class="headerlink" title="(1) ls"></a><strong>(1) <font color="red">ls</font></strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">l</font>i<font color="orange">s</font>t</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/ls</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>功能描述：显示目录文件</strong></p>
</li>
<li><p><strong>语法：<font color="orange">ls 选项[-ald] [文件或目录] </font></strong></p>
<ul>
<li><strong><font color="orange">-a </font>（–all）显示所有文件，包括隐藏文件</strong></li>
<li><strong><font color="orange">-l</font> (–list) 详细信息显示（权限，所有者等）</strong></li>
<li><strong>-m (–format=commas) 用逗号分隔的列表显示</strong></li>
<li><strong>-d 查看目录属性</strong></li>
<li><strong>-1（–format=single-column）用单独一列的方式查看结果</strong></li>
<li><strong>-r (–reverse) 以反序来显示</strong></li>
<li><strong>-X (–sort==extension) 根据文件扩展名进行字母顺序排序</strong></li>
<li><strong><font color="orange">-t</font> (–sort==time) 根据日期和时间排序</strong></li>
<li><strong>-<font color="orange">S</font> (–sort==size) 根据文件大小排序</strong></li>
<li><strong><font color="orange">-h</font> (–human-readable) 用 K M G 显示文件大小</strong></li>
<li><strong>-R （–recursive）递归遍历目录，显示该目录及其子目录的内容</strong></li>
<li><strong>-F (–classify) 显示文件的类型，*代表可执行文件，/代表目录</strong></li>
<li><strong>–color 用不同颜色显示文件类型，绿：可执行文件，蓝：文件夹，黑：普通</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">举例：</span></span><br><span class="line">ls -al		#显示所有文件详细信息</span><br><span class="line">ls -alh		#显示所有文件详细信息（包括文件大小）</span><br><span class="line">ls -alhS	#按文件大小排序显示所有文件详细信息</span><br></pre></td></tr></table></figure>

<p><strong>tip: 显示详细信息第一列字符 -rwxr-xr-x含义，分为四个字段- rwx r-x r-x</strong></p>
<ul>
<li><strong>第一个字段：- 表示二进制文件，d 表示目录，l 表示软链接文件</strong></li>
<li><strong>第二个字段：u所有者权限。r、w、x分别表示读、写、执行，- 表示无对应权限</strong></li>
<li><strong>第三个字段：g所属组权限</strong></li>
<li><strong>第四个字段：o其他人权限</strong></li>
</ul>
</li>
</ul>
<h4 id="4-1-2-目录处理命令"><a href="#4-1-2-目录处理命令" class="headerlink" title="4.1.2 目录处理命令"></a><strong>4.1.2 目录处理命令</strong></h4><h5 id="（1）mkdir"><a href="#（1）mkdir" class="headerlink" title="（1）mkdir"></a><strong>（1）<font color="red">mkdir</font></strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">m</font>a<font color="orange">k</font>e <font color="orange">dir</font>ectories</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/mkdir</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">mkdir -p  [目录名]</font></strong></p>
</li>
<li><p><strong>功能描述：创建新目录    -p 递归创建( -p 可以递归创建 在没有一级目录的情况下新创建二级目录)</strong></p>
</li>
<li><p><strong>tip：创建目录 在/tmp/目录下创建临时文件 只能创建/tmp/……二级目录</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p /tmp/Japan/boduo    <span class="comment">#(不存在Japan目录，所以要用-p递归创建)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir /tmp/Japan/longze /tmp/Japan/cangjing</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）rmdir"><a href="#（2）rmdir" class="headerlink" title="（2）rmdir"></a><strong>（2）<font color="red">rmdir</font></strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">r</font>emove e<font color="orange">m</font>pty <font color="orange">dir</font>ectories</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/rmdir</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">rmdir [目录名] </font>font&gt;</strong></p>
</li>
<li><p><strong>功能描述： 删除空目录，只能删除没有文件的空目录 （不经常使用）</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rmdir /tmp/Japan/boduo</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）cd"><a href="#（3）cd" class="headerlink" title="（3）cd"></a><strong>（3）<font color="red">cd</font></strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">c</font>hange <font color="orange">d</font>irectory</strong> </p>
</li>
<li><p><strong>命令所在路径：shell 内置</strong></p>
</li>
<li><p><strong>命令执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">cd [目录] </font></strong></p>
</li>
<li><p><strong>功能描述：切换目录</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /tmp/Japan/boduo <span class="comment">#切换到指定目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .. <span class="comment">#回到上一级目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> / <span class="comment">#回到根目录</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（4）pwd"><a href="#（4）pwd" class="headerlink" title="（4）pwd "></a><strong>（4）<font color="red">pwd </font></strong></h5><ul>
<li><strong>命令英文原意： <font color="orange">p</font>rint <font color="orange">w</font>orking <font color="orange">d</font>irectory</strong> </li>
<li><strong>命令所在路径：/bin/pwd</strong> </li>
<li><strong>执行权限：所有用户</strong></li>
<li><strong>语法：<font color="orange">pwd </font></strong></li>
<li><strong>功能描述：显示当前目录</strong></li>
<li><strong>范例：$ pwd</strong> </li>
</ul>
<h5 id="（5）cp"><a href="#（5）cp" class="headerlink" title="（5）cp"></a><strong>（5）<font color="red">cp</font></strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">c</font>o<font color="orange">p</font>y</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/cp</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">cp -rp [原文件或目录] [目标目录] </font></strong></p>
<ul>
<li><strong>-r 复制目录</strong></li>
<li><strong>-p 保留文件属性，比如保留创建时间，日志文件的复制需要用到</strong></li>
</ul>
</li>
<li><p><strong>功能描述：复制文件或目录</strong></p>
</li>
<li><p><strong>范例：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp -r /tmp/Japan/cangjing /root</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">将目录/tmp/Japan/cangjing 复制到目录/root 下</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -rp /tmp/Japan/boduo /tmp/Japan/longze /root</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">将/tmp/Japan 目录下的 boduo 和 longze 目录复制到/root 下，保持目录属性</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（6）rm"><a href="#（6）rm" class="headerlink" title="（6）rm"></a><strong>（6）<font color="red">rm</font></strong></h5><ul>
<li><strong>命令英文原意：<font color="orange">r</font>e<font color="orange">m</font>ove</strong> </li>
</ul>
<ul>
<li><strong>命令所在路径：/bin/rm</strong> </li>
</ul>
<ul>
<li><strong>执行权限：所有用户</strong></li>
</ul>
<ul>
<li><p><strong>语法：<font color="orange">rm -rf [文件或目录] </font>font&gt;</strong></p>
<ul>
<li><strong>-r 删除目录，一般是rm -rf 连着用</strong></li>
<li><strong>-f 强制执行，不在询问</strong></li>
</ul>
</li>
<li><p><strong>功能描述：删除文件或目录（-r）</strong></p>
</li>
</ul>
<ul>
<li><p><strong>范例：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm /tmp/yum.log</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">删除文件/tmp/yum.log</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf /tmp/Japan/longze</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">删除目录/tmp/Japan/longze</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-1-3-文件处理命令"><a href="#4-1-3-文件处理命令" class="headerlink" title="4.1.3 文件处理命令"></a><strong>4.1.3 文件处理命令</strong></h4><h5 id="1-touch"><a href="#1-touch" class="headerlink" title="(1) touch"></a><strong>(1) <font color="red">touch</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/touch</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">touch [文件名] 或 touch[绝对路径+文件名]</font></strong></p>
</li>
<li><p><strong>功能描述：创建空文件</strong></p>
</li>
<li><p><strong>范例： $ touch Japanlovestory.list</strong></p>
</li>
</ul>
<h5 id="2-cat"><a href="#2-cat" class="headerlink" title="(2) cat"></a><strong>(2) <font color="red">cat</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/cat</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">cat [文件名] </font></strong></p>
</li>
<li><p><strong>功能描述：显示文件内容</strong> </p>
<ul>
<li> <strong>-n 显示行号</strong></li>
<li> <strong>-A 显示隐藏字符</strong></li>
</ul>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><strong>$ cat /etc/issue</strong> </li>
<li><strong>$ cat -n /etc/services</strong></li>
</ul>
</li>
</ul>
<h5 id="3-more"><a href="#3-more" class="headerlink" title="(3) more"></a><strong>(3) <font color="red">more</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/more</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">more [文件名] </font></strong></p>
<ul>
<li> <strong>(空格) 或 f 翻页</strong> </li>
<li> <strong>(Enter) 换行</strong> </li>
<li> <strong>q 或 Q 退出</strong></li>
</ul>
</li>
<li><p><strong>功能描述：分页显示文件内容,合长的文件内容</strong></p>
</li>
<li><p><strong>范例： $ more /etc/services</strong></p>
</li>
</ul>
<h5 id="4-less"><a href="#4-less" class="headerlink" title="(4) less"></a><strong>(4) <font color="red">less</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/less 执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">less [文件名] </font></strong></p>
</li>
<li><p><strong>功能描述：分页显示文件内容（可向上翻页）</strong></p>
</li>
<li><p><strong>范例： $ less /etc/services</strong></p>
</li>
<li><p><strong>tips: 按下 / 后可以搜索,会反显高亮 按 q 退出（more 也可以）</strong></p>
</li>
</ul>
<h5 id="5-head"><a href="#5-head" class="headerlink" title="(5) head"></a><strong>(5) <font color="red">head</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/head</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">head [文件名] </font></strong></p>
</li>
<li><p><strong>功能描述：显示文件前面几行</strong> </p>
<ul>
<li><strong>-n 指定行数</strong></li>
</ul>
</li>
<li><p><strong>范例： $ head -n 20 /etc/services</strong></p>
</li>
</ul>
<h5 id="6-tail"><a href="#6-tail" class="headerlink" title="(6) tail"></a><strong>(6) <font color="red">tail</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/tail</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">tail [文件名] </font></strong></p>
</li>
<li><p><strong>功能描述：显示文件后面几行</strong> </p>
<ul>
<li> <strong>-n 指定行数</strong> </li>
<li> <strong>-f 动态显示文件末尾内容</strong></li>
</ul>
</li>
<li><p><strong>范例： $ tail -n 18 /etc/services</strong></p>
</li>
</ul>
<h4 id="4-1-4-文件链接命令"><a href="#4-1-4-文件链接命令" class="headerlink" title="4.1.4 文件链接命令"></a><strong>4.1.4 文件链接命令</strong></h4><h5 id="（5）ln"><a href="#（5）ln" class="headerlink" title="（5）ln"></a><strong>（5）<font color="red">ln</font></strong></h5><ul>
<li><p><strong>命令英文原意：link</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/ln</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">ln -s [原文件] [目标文件] </font></strong></p>
<ul>
<li><strong>-s 创建软链接</strong></li>
</ul>
</li>
<li><p><strong>功能描述：生成链接文件</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ln -s /etc/issue /tmp/issue.soft</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建文件/etc/issue 的软链接/tmp/issue.soft</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln /etc/issue /tmp/issue.hard</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建文件/etc/issue 的硬链接/tmp/issue.hard</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>软链接</strong></p>
<ul>
<li><strong>软链接的作用和Windows中的快捷方式是差不多的。他只不过是指向源文件安装路径的符号链接，所以大小也很小</strong></li>
<li><strong>而且它的文件类型是lrwxrwxrwx 看似三种用户都可以拥有所有权限。其实，真正拥有的权限是源文件所决定的权限 ，所以这种显示也是软链接的一大特征之一。</strong></li>
</ul>
</li>
<li><p><strong>硬链接</strong></p>
<ul>
<li><strong>硬链接就是把源文件拷贝到目标位置，而他与cp -p 最大的一点区别就是他可以同步更新，源文件有变化硬链接文件也会同时发生变化，但是如果源文件丢失或者被删除，硬链接也并不会消失</strong></li>
<li><strong>可以通过i节点来区分，源文件和硬链接文件的<font color="orange">i节点是一样的</font>，所以他们会同步更新</strong></li>
<li><strong>但是他不能跨分区放置硬链接比如：/分区 硬链接 不能放到/boot 分区</strong> </li>
<li><strong>而且不能对目录使用</strong></li>
</ul>
</li>
</ul>
<h3 id="4-2-权限管理命令"><a href="#4-2-权限管理命令" class="headerlink" title="4.2 权限管理命令"></a><strong>4.2 权限管理命令</strong></h3><h4 id="4-2-1-权限管理命令-chmod"><a href="#4-2-1-权限管理命令-chmod" class="headerlink" title="4.2.1 权限管理命令 chmod"></a><strong>4.2.1 权限管理命令 <font color="red">chmod</font></strong></h4><h5 id="（1）chmod"><a href="#（1）chmod" class="headerlink" title="（1）chmod"></a><strong>（1）chmod</strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">ch</font>ange the permissions <font color="orange">mod</font>e of a file</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/chmod</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">chmod [{ugoa}{+-=}{rwx}] [文件或目录] </font></strong></p>
<ul>
<li><p> <strong>-R 递归修改</strong></p>
</li>
<li><p><strong>u ：所有者    g ：所属组</strong><br><strong>o ：其他人    a ：所有用户</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod g+x,o+r /tmp/testfile</span><br><span class="line"><span class="meta">#</span><span class="bash">就是把testfile文件的所属组增加执行权限，其他人增加读权限</span></span><br><span class="line">chmod a=rwx /tmp/testfile</span><br><span class="line"><span class="meta">#</span><span class="bash">就是testfile文件的所有用户增加读写执行权限</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>功能描述：改变文件或目录的权限</strong></p>
</li>
<li><p><strong>权限的数字表示 ：chmod [rwx的和,rwx的和,rwx的和]] [文件或者目录]</strong></p>
<ul>
<li><p><strong>r —- 4  w —- 2  x —- 1</strong></p>
<p><strong>例如：rwxrw-r- - 它的权限位数字表示就是 764</strong><br><strong>具体算法：</strong><br><strong>r+w+x=4+2+1=7<br>r+w=4+2+0=6<br>r=4+0+0=4</strong></p>
</li>
</ul>
</li>
<li><p><strong>chmod -R [rwx的和,rwx的和,rwx的和] [文件或目录]</strong><br><strong>这条命令与mkdir -p递归创建目录一样 这个命令把一个目录下的所有子目录的操作权限全部修改为同样的</strong></p>
</li>
</ul>
<h5 id="（2）创建用户命令"><a href="#（2）创建用户命令" class="headerlink" title="（2）创建用户命令"></a><strong>（2）创建用户命令</strong></h5><ul>
<li><strong>useradd [用户名]     创建普通用户</strong></li>
<li><strong>passwd [用户名]      用户密码</strong></li>
<li><strong>su - [用户名]             切换普通用户</strong></li>
</ul>
<h5 id="（3）权限对文件和目录的含义"><a href="#（3）权限对文件和目录的含义" class="headerlink" title="（3）权限对文件和目录的含义"></a><strong>（3）权限对文件和目录的含义</strong></h5><table>
<thead>
<tr>
<th><strong>代表字符</strong></th>
<th><strong>权限</strong></th>
<th><strong>对文件的含义</strong></th>
<th><strong>对目录的含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>r</strong></td>
<td><strong>读权限</strong></td>
<td><strong>可以查看文件内容</strong></td>
<td><strong>可以cat/more/head/tail/less</strong></td>
</tr>
<tr>
<td><strong>w</strong></td>
<td><strong>写权限</strong></td>
<td><strong>可以修改文件内容 可以vim</strong></td>
<td><strong>可以在目录中创建，删除文件，可以touch/mkdir/rmdir/rm</strong></td>
</tr>
<tr>
<td><strong>x</strong></td>
<td><strong>执行权限</strong></td>
<td><strong>可以执行文件 可以script(脚本) command(命令)</strong></td>
<td><strong>可以进入目录 可以cd</strong></td>
</tr>
</tbody></table>
<h4 id="4-2-2-其他权限管理命令"><a href="#4-2-2-其他权限管理命令" class="headerlink" title="4.2.2 其他权限管理命令"></a><strong>4.2.2 其他权限管理命令</strong></h4><h5 id="（1）chown"><a href="#（1）chown" class="headerlink" title="（1）chown"></a><strong>（1）<font color="red">chown</font></strong></h5><ul>
<li><strong>命令英文原意：<font color="orange">ch</font>ange file <font color="orange">own</font>ership</strong></li>
</ul>
<ul>
<li><strong>命令所在路径：/bin/chown</strong> </li>
</ul>
<ul>
<li><strong>执行权限：所有用户</strong></li>
</ul>
<ul>
<li><strong>语法：<font color="orange">chown [用户] [文件或目录] </font></strong></li>
</ul>
<ul>
<li><strong>功能描述：改变文件或目录的所有者 范例：$ chown shenchao fengjie</strong> </li>
</ul>
<ul>
<li><strong>改变文件 fengjie 的所有者为 shenchao</strong></li>
</ul>
<h5 id="（2）chgrp"><a href="#（2）chgrp" class="headerlink" title="（2）chgrp "></a><strong>（2）<font color="red">chgrp </font></strong></h5><ul>
<li><strong>命令英文原意：change file group ownership</strong> </li>
</ul>
<ul>
<li><strong>命令所在路径：/bin/chgrp</strong></li>
</ul>
<ul>
<li><strong>执行权限：所有用户</strong></li>
</ul>
<ul>
<li><strong>语法：<font color="orange">chgrp [用户组] [文件或目录] </font></strong></li>
</ul>
<ul>
<li><strong>功能描述：改变文件或目录的所属组</strong></li>
</ul>
<ul>
<li><strong>范例：$ chgrp lampbrother fengjie</strong> </li>
</ul>
<p> <strong>改变文件 fengjie 的所属组为 lampbrother</strong></p>
<h5 id="（3）umask"><a href="#（3）umask" class="headerlink" title="（3）umask"></a><strong>（3）<font color="red">umask</font></strong></h5><ul>
<li><strong>命令英文原意：the user file-creation mask</strong> </li>
</ul>
<ul>
<li><strong>命令所在路径：Shell 内置命令</strong></li>
</ul>
<ul>
<li><strong>执行权限：所有用户</strong></li>
</ul>
<ul>
<li><strong>语法：<font color="orange">umask [-S] </font></strong></li>
</ul>
<ul>
<li><p><strong>-S 以 rwx 形式显示新建文件缺省权限</strong></p>
</li>
<li><p><strong>功能描述：显示、设置文件的缺省权限</strong></p>
</li>
</ul>
<ul>
<li><strong>范例： $ umask -S</strong></li>
</ul>
<p><strong>tips: 新建文件是默认没有 x 权限（比如：防止木马病毒攻击）</strong></p>
<h3 id="4-3-文件搜索命令"><a href="#4-3-文件搜索命令" class="headerlink" title="4.3 文件搜索命令"></a><strong>4.3 文件搜索命令</strong></h3><h4 id="4-3-1-文件搜索命令find"><a href="#4-3-1-文件搜索命令find" class="headerlink" title="4.3.1 文件搜索命令find"></a><strong>4.3.1 文件搜索命令<font color="red">find</font></strong></h4><h5 id="（0）find-搜索范围-匹配条件"><a href="#（0）find-搜索范围-匹配条件" class="headerlink" title="（0）find [搜索范围] [匹配条件]"></a><strong>（0）find [搜索范围] [匹配条件]</strong></h5><h5 id="（1）按关键字-name-iname"><a href="#（1）按关键字-name-iname" class="headerlink" title="（1）按关键字 -name | -iname"></a><strong>（1）按关键字 -name | -iname</strong></h5><ul>
<li><p><strong><font color="orange">find [搜索范围] -name [关键字]</font> 在特定路径下搜索文件名作为关键字的文件或者目录</strong></p>
</li>
<li><p><em><em>find [搜索范围] -name [关键字]</em> 这样为带有关键字开头的任何文件都可以被搜索出来</em>*</p>
</li>
<li><p><strong>find [搜索范围] -name * [关键字] * 这样为带有关键字的任何文件都可以被搜索出来</strong></p>
</li>
<li><p><strong>find [搜索范围] -name [关键字]??? 这样搜索的是关键字后带三个字符的 几个问号为几个字符</strong></p>
</li>
<li><p><strong>find [搜索范围] -iname [关键字] 不区分大小写搜索</strong></p>
</li>
<li><p>```shell<br>$ find /etc -name init<br>#在目录/etc 中查找文件 init<br>#-iname 不区分大小写<br>$ find /etc -name <em>init</em><br>#在目录/etc 中查找文件名包含 init<br>$ find /etc -name init??？<br>#在目录/etc 中查找文件名 init 开头并有 3 个字符的<br>$ find /etc -name init*<br>#在目录/etc 中查找文件名 init 开头的<br>#tips:* 匹配任意字符，?匹配单个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">##### **（2）按文件大小 -size**</span><br><span class="line"></span><br><span class="line">- **&lt;font color=&#x27;orange&#x27;&gt;find [搜索范围] -size [数据块] &lt;/font&gt;**</span><br><span class="line"></span><br><span class="line">- **数据块前面加+表示查找大于这个大小的文件，-表示查找小于这个大小的文件，不加表示查找等于这个大小的文件(一般不常用)**</span><br><span class="line"></span><br><span class="line">- **1个数据块=512字节=0.5KB （1KB=2个数据块）**</span><br><span class="line">  **size后接的数据只能为数据块需要换算，比如需要查找大于100MB的文件**</span><br><span class="line">  **100MB=102400KB=204800个数据块**</span><br><span class="line">  **find /etc -size +204800**</span><br><span class="line">  **数据块为Linux存储文件最小单位**</span><br><span class="line"></span><br><span class="line">- ```shell</span><br><span class="line">  $ find / -size +204800 </span><br><span class="line">  #在根目录下查找大于 100MB 的文件</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）按所有者-user"><a href="#（3）按所有者-user" class="headerlink" title="（3）按所有者 -user"></a><strong>（3）按所有者 -user</strong></h5><ul>
<li><strong>find [搜索范围] -user [所有者名]</strong></li>
</ul>
<h5 id="（4）按所属组-group"><a href="#（4）按所属组-group" class="headerlink" title="（4）按所属组 -group"></a><strong>（4）按所属组 -group</strong></h5><ul>
<li><strong>find [搜索范围] -group [所属组名]</strong> </li>
</ul>
<h5 id="（5）按时间-amin-cmin-mmin"><a href="#（5）按时间-amin-cmin-mmin" class="headerlink" title="（5）按时间 -amin|-cmin|-mmin"></a><strong>（5）按时间 -amin|-cmin|-mmin</strong></h5><ul>
<li><p><strong>按访问的时间：find [搜索范围] -amin [时间]    a:access</strong></p>
</li>
<li><p><strong>按修改属性的时间：find [搜索范围] -cmin [时间]    c:change</strong></p>
</li>
<li><p><strong>按修改内容的时间find [搜索范围] -mmin [时间]    m:modify</strong></p>
</li>
<li><p><strong>+：超过多长时间     -：多长时间以内</strong></p>
</li>
</ul>
<h5 id="（6）其他"><a href="#（6）其他" class="headerlink" title="（6）其他"></a><strong>（6）其他</strong></h5><ul>
<li><p><strong>find [搜索范围] -size [数据块] -a -size [数据块]</strong><br><strong>-a：两个条件同时满足</strong><br><strong>-o：两个条件满足任意一个即可</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /etc -size +163840 -a -size -204800</span><br><span class="line"><span class="meta">#</span><span class="bash">在/etc下查找大于80MB小于100MB的文件</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>find [搜索范围] -name [关键字] -a -type f</strong><br><strong>在特定路径下搜索文件名作为关键字的文件</strong><br><strong>-type 根据不同类型查找</strong><br><strong>f：文件</strong><br><strong>d：目录</strong><br><strong>l：软链接</strong></p>
</li>
<li><p><strong>-exec：查找到文件之后并且对其进行各种操作 {} \ ;不能丢</strong></p>
<p><strong>find [搜索范围] -name [关键字] -exec ls -l {} \ ;</strong><br><strong>查找到文件之后并且对其进行查看ls操作。</strong></p>
</li>
<li><p><strong>-ok：用于询问确认 一般在删除操作的时候使用，比如：</strong><br><strong>find -user yangyang -ok rm {} \ ;</strong><br><strong>删除yangyang用户的文件 他会挨个询问你是不是确定删除</strong></p>
</li>
<li><p><strong>find [搜索范围] -inum [i节点值] 根据i节点查询</strong><br><strong>find /etc -inum 12345 -exec rm {} \ ;</strong><br><strong>删除这个i节点文件 非常方便</strong><br><strong>也可以用来查询一个文件的硬链接</strong><br><strong>find /etc inum 12345 -exec ls -l {} \ ;</strong><br><strong>因为硬链接和文件肯定在同一个分区，并且i节点一样</strong></p>
</li>
</ul>
<h4 id="4-3-2-其他文件搜索命令"><a href="#4-3-2-其他文件搜索命令" class="headerlink" title="4.3.2 其他文件搜索命令"></a><strong>4.3.2 其他文件搜索命令</strong></h4><h5 id="（1）locate"><a href="#（1）locate" class="headerlink" title="（1）locate"></a><strong>（1）<font color="red">locate</font></strong></h5><ul>
<li><strong>命令名称：locate</strong><ul>
<li><strong>命令所在路径：/usr/bin/locate</strong> </li>
<li><strong>执行权限：所有用户</strong></li>
<li><strong>语法：<font color="orange">locate 文件名</font></strong></li>
<li><strong>参数：-i 不区分大小写</strong></li>
<li><strong>功能描述：在文件资料库中查找文件，速度更快。</strong></li>
<li><strong>范例：$ locate inittab</strong></li>
<li><strong>tips:</strong><ul>
<li><strong>新建文件 locate 不到，可以 updatedb,更新文件资料库后查找</strong></li>
<li><strong>/tmp 临时文件不在文件资料库内</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="（2）which"><a href="#（2）which" class="headerlink" title="（2）which"></a><strong>（2）<font color="red">which</font></strong></h5><ul>
<li><p><strong>命令名称：which</strong></p>
</li>
<li><p><strong>命令所在路径：/usr/bin/which</strong></p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">which 命令</font></strong></p>
</li>
<li><p><strong>功能描述：搜索命令所在目录及别名信息</strong></p>
</li>
<li><p><strong>范例：$ which ls</strong></p>
</li>
</ul>
<h5 id="（3）whereis"><a href="#（3）whereis" class="headerlink" title="（3）whereis"></a><strong>（3）<font color="red">whereis</font></strong></h5><ul>
<li><p><strong>命令名称：whereis</strong></p>
</li>
<li><p><strong>命令所在路径：/usr/bin/whereis</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">whereis [命令名称] </font></strong></p>
</li>
<li><p><strong>功能描述：搜索命令所在目录及帮助文档路径</strong></p>
</li>
<li><p><strong>范例：$ whereis ls</strong></p>
</li>
</ul>
<h5 id="（4）grep"><a href="#（4）grep" class="headerlink" title="（4）grep"></a><strong>（4）<font color="red">grep</font></strong></h5><ul>
<li><p><strong>命令名称：grep</strong></p>
</li>
<li><p><strong>命令所在路径：/bin/grep</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">grep -iv [指定字串] [文件] </font></strong></p>
</li>
<li><p><strong>功能描述：在文件中搜寻字串匹配的行并输出</strong> </p>
<ul>
<li><strong>-i 不区分大小写</strong></li>
<li><strong>-v 排除指定字串</strong></li>
</ul>
</li>
<li><p><strong>范例：</strong></p>
<ul>
<li> <strong>grep mysql /root/install.log</strong></li>
<li> <strong># grep -v ^# /etc/inittab 去除以#开头的所有行信息,^表示以 XXX 开头</strong></li>
</ul>
</li>
</ul>
<h3 id="4-4-帮助命令"><a href="#4-4-帮助命令" class="headerlink" title="4.4 帮助命令"></a><strong>4.4 帮助命令</strong></h3><h5 id="（1）man"><a href="#（1）man" class="headerlink" title="（1）man"></a><strong>（1）<font color="red">man</font></strong></h5><ul>
<li><p><strong>命令英文原意：manual</strong> </p>
</li>
<li><p><strong>命令所在路径：/usr/bin/man</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">man [命令或配置文件] </font></strong></p>
<ul>
<li> <strong>(空格) 或 f 翻页</strong> </li>
<li> <strong>(Enter) 换行</strong> </li>
<li> <strong>q 或 Q 退出</strong></li>
</ul>
</li>
<li><p><strong>功能描述：获得帮助信息</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><p><strong>$ man ls</strong> </p>
<p><strong>查看 ls 命令的帮助信息</strong> </p>
</li>
<li><p><strong>$ man services</strong> </p>
<p><strong>查看配置文件 services 的帮助信息</strong></p>
</li>
<li><p><strong>1 命令的帮助   5 配置文件的帮助</strong></p>
</li>
<li><p><strong>man 5 passwd -&gt; 查看配置文件的帮助</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（2）whatis"><a href="#（2）whatis" class="headerlink" title="（2）whatis"></a><strong>（2）<font color="red">whatis</font></strong></h5><ul>
<li><p><strong>语法：<font color="orange">whatis 命令</font></strong></p>
</li>
<li><p><strong>功能描述：获得命令的简单介绍信息</strong></p>
</li>
<li><p><strong>范例：whatis ls</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ whatis ls</span><br><span class="line">ls (1)               - list directory contents</span><br><span class="line">ls (1p)              - list directory contents</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）apropos"><a href="#（3）apropos" class="headerlink" title="（3）apropos"></a><strong>（3）<font color="red">apropos</font></strong></h5><ul>
<li><strong>语法：<font color="orange">apropos 配置文件名称</font></strong></li>
<li><strong>whatis 类似于精确查找</strong></li>
<li><strong>apropos 模糊查找关键字 [功能等于 man -k ] [可以 tab 快速补全]</strong></li>
</ul>
<h5 id="（3）help"><a href="#（3）help" class="headerlink" title="（3）help"></a><strong>（3）<font color="red">help</font></strong></h5><ul>
<li><p><strong>命令所在路径：Shell 内置命令</strong></p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>功能描述：获得 Shell 内置命令的帮助信息</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><p><strong>$ help umask</strong> </p>
<p><strong>查看 umask 命令的帮助信息</strong></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ help umask</span><br><span class="line">umask: umask [-p] [-S] [模式]</span><br><span class="line">    显示或设定文件模式掩码。</span><br><span class="line">    </span><br><span class="line">    设定用户文件创建掩码为 MODE 模式。如果省略了 MODE，则</span><br><span class="line">    打印当前掩码的值。</span><br><span class="line">    </span><br><span class="line">    如果 MODE 模式以数字开头，则被当作八进制数解析；否则是一个</span><br><span class="line">    chmod(1) 可接收的符号模式串。</span><br><span class="line">    </span><br><span class="line">    选项：</span><br><span class="line">      -p	如果省略 MODE 模式，以可重用为输入的格式输入</span><br><span class="line">      -S	以符号形式输出，否则以八进制数格式输出</span><br><span class="line">    </span><br><span class="line">    退出状态：</span><br><span class="line">    返回成功，除非使用了无效的 MODE 模式或者选项。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-4-帮助命令-1"><a href="#4-4-帮助命令-1" class="headerlink" title="4.4 帮助命令"></a><strong>4.4 帮助命令</strong></h3><h5 id="（1）man-1"><a href="#（1）man-1" class="headerlink" title="（1）man"></a><strong>（1）<font color="red">man</font></strong></h5><ul>
<li><p><strong>命令英文原意：manual</strong> </p>
</li>
<li><p><strong>命令所在路径：/usr/bin/man</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">man [命令或配置文件] </font></strong></p>
<ul>
<li> <strong>(空格) 或 f 翻页</strong> </li>
<li> <strong>(Enter) 换行</strong> </li>
<li> <strong>q 或 Q 退出</strong></li>
</ul>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">获得帮助信息</font></strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><p><strong>$ man ls</strong> </p>
<p><strong>查看 ls 命令的帮助信息</strong> </p>
</li>
<li><p><strong>$ man services</strong> </p>
<p><strong>查看配置文件 services 的帮助信息</strong></p>
</li>
<li><p><strong>1 命令的帮助   5 配置文件的帮助</strong></p>
</li>
<li><p><strong>man 5 passwd -&gt; 查看配置文件的帮助</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（2）whatis-1"><a href="#（2）whatis-1" class="headerlink" title="（2）whatis"></a><strong>（2）<font color="red">whatis</font></strong></h5><ul>
<li><p><strong>语法：<font color="orange">whatis 命令</font></strong></p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">获得命令的简单介绍信息</font></strong></p>
</li>
<li><p><strong>范例：whatis ls</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ whatis ls</span><br><span class="line">ls (1)               - list directory contents</span><br><span class="line">ls (1p)              - list directory contents</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）apropos-1"><a href="#（3）apropos-1" class="headerlink" title="（3）apropos"></a><strong>（3）<font color="red">apropos</font></strong></h5><ul>
<li><strong>语法：<font color="orange">apropos 配置文件名称</font></strong></li>
<li><strong>whatis 类似于精确查找</strong></li>
<li><strong>apropos 模糊查找关键字 [功能等于 man -k ] [可以 tab 快速补全]</strong></li>
</ul>
<h5 id="（3）help-1"><a href="#（3）help-1" class="headerlink" title="（3）help"></a><strong>（3）<font color="red">help</font></strong></h5><ul>
<li><p><strong>命令所在路径：Shell 内置命令</strong></p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">获得 Shell 内置命令的帮助信息</font></strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><p><strong>$ help umask</strong> </p>
<p><strong>查看 umask 命令的帮助信息</strong></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ help umask</span><br><span class="line">umask: umask [-p] [-S] [模式]</span><br><span class="line">    显示或设定文件模式掩码。</span><br><span class="line">    </span><br><span class="line">    设定用户文件创建掩码为 MODE 模式。如果省略了 MODE，则</span><br><span class="line">    打印当前掩码的值。</span><br><span class="line">    </span><br><span class="line">    如果 MODE 模式以数字开头，则被当作八进制数解析；否则是一个</span><br><span class="line">    chmod(1) 可接收的符号模式串。</span><br><span class="line">    </span><br><span class="line">    选项：</span><br><span class="line">      -p	如果省略 MODE 模式，以可重用为输入的格式输入</span><br><span class="line">      -S	以符号形式输出，否则以八进制数格式输出</span><br><span class="line">    </span><br><span class="line">    退出状态：</span><br><span class="line">    返回成功，除非使用了无效的 MODE 模式或者选项。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-5-用户管理命令"><a href="#4-5-用户管理命令" class="headerlink" title="4.5 用户管理命令"></a><strong>4.5 用户管理命令</strong></h3><h5 id="（1）useradd"><a href="#（1）useradd" class="headerlink" title="（1）useradd"></a><strong>（1）<font color="red">useradd</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/sbin/useradd</strong> </p>
</li>
<li><p><strong>执行权限：root</strong> </p>
</li>
<li><p><strong>语法：<font color="orange">useradd 用户名</font></strong></p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">添加新用户</font></strong></p>
</li>
<li><p><strong>范例： $ useradd zlx</strong></p>
</li>
</ul>
<h5 id="（2）passwd"><a href="#（2）passwd" class="headerlink" title="（2）passwd"></a><strong>（2）<font color="red">passwd</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/passwd</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">passwd 用户名</font></strong></p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">设置用户密码</font></strong></p>
</li>
<li><p><strong>范例：$ passwd zlx</strong></p>
</li>
<li><p><strong>tips：普通用户只能更改自己密码，root 用户可以更好所有人密码</strong></p>
</li>
</ul>
<h5 id="（3）who"><a href="#（3）who" class="headerlink" title="（3）who"></a><strong>（3）<font color="red">who</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/who</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">who</font></strong> </p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">查看登录用户信息</font></strong></p>
</li>
<li><p><strong>范例： $ who</strong></p>
</li>
<li><p><strong>tips</strong></p>
<ul>
<li><strong>第一列 登陆用户名</strong></li>
<li><strong>第二列 登陆终端 【tty表示本地终端 pts表示远程登陆终端】</strong></li>
<li><strong>第三列 登陆时间</strong></li>
<li><strong>第四列 登陆主机的IP地址 【如果没有写表示本机登陆】</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost ~]$ who</span><br><span class="line">zlx      tty2         2021-08-15 15:07 (tty2)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（4）w"><a href="#（4）w" class="headerlink" title="（4）w"></a><strong>（4）<font color="red">w</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/w</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">w </font></strong></p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">查看登录用户详细信息</font></strong></p>
</li>
<li><p><strong>范例： $ w</strong></p>
</li>
<li><p><strong>第一行显示 “16:02:04 up 56 min,  1 user,  load average: 0.03, 0.05, 0.01”</strong>  </p>
<ul>
<li><strong>第一个 表示当前时间</strong></li>
<li><strong>第二个 表示服务区系统连续运行时间，没有重启或者关机，衡量服务区稳定性</strong></li>
<li><strong>第三个 表示当前总共有多少个用户登陆</strong></li>
<li><strong>第四个 表示负载均衡指数，分别记录了过去一分钟，五分钟，十五分钟系统的负载情况，加起来除以三就是平均负载指数，系统的负载情况主要是指 CPU和内存的负载情况，数字大表示负载严重</strong></li>
<li><strong>uptime命令也可以显示此项数据</strong></li>
</ul>
</li>
<li><p><strong>第二行显示 “USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT”</strong></p>
<ul>
<li><strong>IDLE：表示用户登录过来后空闲多久</strong></li>
<li><strong>JCPU：表示累计占用CPU时间</strong></li>
<li><strong>PCPU：表示用户登录后执行的操作占用的CPU时间</strong></li>
<li><strong>WHAT：表示执行的操作</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16:02:04 up 56 min,  1 user,  load average: 0.03, 0.05, 0.01</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">zlx      tty2     tty2             15:07   56:16  59.42s  0.15s /usr/libexec/gsd-disk-</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-6-压缩解压命令"><a href="#4-6-压缩解压命令" class="headerlink" title="4.6 压缩解压命令"></a><strong>4.6 压缩解压命令</strong></h3><h5 id="（1）gzip-和-gunzip"><a href="#（1）gzip-和-gunzip" class="headerlink" title="（1）gzip 和 gunzip"></a><strong>（1）<font color="red">gzip 和 gunzip</font></strong></h5><ul>
<li><strong>gzip [文件名] ： 压缩文件，只能压缩文件不能压缩目录，而且不保留原文件压缩后格式为：.gz</strong></li>
<li><strong>gunzip [压缩包名] ：解压缩.gz文件</strong></li>
<li><strong>gzip -d [压缩包名] ：解压缩.gz文件</strong></li>
</ul>
<h5 id="（2）tar"><a href="#（2）tar" class="headerlink" title="（2）tar"></a><strong>（2）<font color="red">tar</font></strong></h5><ul>
<li><strong>压缩 c：</strong><ul>
<li><strong><font color="orange">tar [选项] [压缩后文件名] [目录]</font></strong><ul>
<li><strong>-c 打包</strong></li>
<li><strong>-v 显示详细信息</strong></li>
<li><strong>-f 指定文件名</strong></li>
<li><strong>-z 打包同时压缩</strong></li>
</ul>
</li>
<li><strong>例子：</strong><ul>
<li><strong>tar -cfv Japan.tar Japan</strong><br><strong>打包目录Japan 并且以Japan.tar命名</strong></li>
<li><strong><font color="cornflowerblue">tar -zcfv Japan.tar.gz Japan</font></strong><br><strong>打包并且压缩 目录Japan 以Japan.tar.gz命名</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>解压缩 x：</strong><ul>
<li><strong>tar [选项] [压缩文件名] [目录]</strong><ul>
<li><strong>-x 解包</strong></li>
<li><strong>-v 显示详细信息</strong></li>
<li><strong>-f 指定解压文件名</strong></li>
<li><strong>-z 解压缩</strong></li>
</ul>
</li>
<li><strong>例子：</strong><ul>
<li><strong>tar -xfv Japan.tar Japan</strong><br><strong>解包目录Japan.tar并且以Japan命名</strong></li>
<li><strong><font color="cornflowerblue">tar -zxfv Japan.tar.gz</font></strong><br><strong>解压缩并且解包目录Japan.tar.gz以Japan命名</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="（3）zip-和-unzip"><a href="#（3）zip-和-unzip" class="headerlink" title="（3）zip 和 unzip"></a><strong>（3）<font color="red">zip 和 unzip</font></strong></h5><ul>
<li><strong>zip [选项] [压缩后文件或目录名] [文件或目录]：原文件会保留 而且提示压缩比 deflated</strong><br><strong>没有gzip压缩比大，不常用。</strong></li>
<li><strong>压缩后格式为：.zip    zip -r：压缩目录</strong></li>
<li><strong>unzip [压缩文件] ：解压zip文件</strong></li>
</ul>
<p><strong>#####</strong> </p>
<h5 id="（4）bzip2-和-bunzip2"><a href="#（4）bzip2-和-bunzip2" class="headerlink" title="（4）bzip2 和 bunzip2"></a><strong>（4）<font color="red">bzip2 和 bunzip2</font></strong></h5><ul>
<li><strong>bzip2 [选项] [文件名] ：压缩文件，大型文件一般用这个压缩</strong></li>
<li><strong>例子：</strong><ul>
<li><strong>bzip2 -k Japan</strong><br><strong>-k：保留原文件 如果不需保留可去掉。生成Japan.bz2压缩文件</strong></li>
<li><strong>他还可以与tar结合使用</strong><br><strong>tar -cjfv Japan.tar.bz2 Japan</strong></li>
</ul>
</li>
<li><strong>bunzip2 [选项] [压缩文件名]： 解压文件</strong><ul>
<li><strong>-k：保留压缩包</strong></li>
<li><strong>与tar结合使用</strong><br><strong>tar -xjfv Japan.tar.bz2 Japan</strong></li>
</ul>
</li>
</ul>
<h3 id="4-7-网络命令"><a href="#4-7-网络命令" class="headerlink" title="4.7 网络命令"></a><strong>4.7 网络命令</strong></h3><h5 id="（1）write"><a href="#（1）write" class="headerlink" title="（1）write"></a><strong>（1）<font color="red">write</font></strong></h5><ul>
<li><p><strong>指令所在路径：/usr/bin/write</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：write &lt;用户名&gt;</strong> </p>
</li>
<li><p><strong>功能描述：给用户发信息，以 Ctrl+D 保存结束</strong></p>
</li>
<li><p><strong>范例： # write linzhiling</strong></p>
</li>
<li><p><strong>tips:输入错误，control+delete 删除</strong> </p>
</li>
</ul>
<h5 id="（2）wall"><a href="#（2）wall" class="headerlink" title="（2）wall"></a><strong>（2）<font color="red">wall</font></strong></h5><ul>
<li><p><strong>命令英文原意：write all</strong> </p>
</li>
<li><p><strong>指令所在路径：/usr/bin/wall</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：wall [message]</strong> </p>
</li>
<li><p><strong>功能描述：发广播信息</strong></p>
</li>
<li><p><strong>范例： # wall ShenChao is a honest man!</strong></p>
</li>
</ul>
<h5 id="（3）ping"><a href="#（3）ping" class="headerlink" title="（3）ping"></a><strong>（3）<font color="red">ping</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/ping</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：ping 选项 IP 地址</strong> </p>
</li>
<li><p><strong>-c 指定发送次数</strong></p>
</li>
<li><p><strong>功能描述：测试网络连通性</strong></p>
</li>
<li><p><strong>范例： # ping 192.168.1.156</strong></p>
</li>
</ul>
<h5 id="（4）ifconfig"><a href="#（4）ifconfig" class="headerlink" title="（4）ifconfig"></a><strong>（4）<font color="red">ifconfig</font></strong></h5><ul>
<li><p><strong>命令所在路径：/sbin/ifconfig</strong> </p>
</li>
<li><p><strong>执行权限：root</strong> </p>
</li>
<li><p><strong>语法：ifconfig 网卡名称 IP 地址</strong></p>
</li>
<li><p><strong>功能描述：查看和设置网卡信息</strong></p>
</li>
<li><p><strong>范例：# ifconfig eth0 192.168.8.250</strong></p>
</li>
</ul>
<h5 id="（5）mail"><a href="#（5）mail" class="headerlink" title="（5）mail"></a><strong>（5）<font color="red">mail</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/mail 执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：mail [用户名]</strong> </p>
</li>
<li><p><strong>功能描述：查看发送电子邮件</strong></p>
</li>
<li><p><strong>范例：# mail root</strong></p>
</li>
</ul>
<h5 id="（6）last"><a href="#（6）last" class="headerlink" title="（6）last"></a><strong>（6）<font color="red">last</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/last</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：last</strong> </p>
</li>
<li><p><strong>功能描述：列出目前与过去登入系统的用户信息</strong></p>
</li>
<li><p><strong>范例：# last</strong></p>
</li>
</ul>
<h5 id="（7）lastlog"><a href="#（7）lastlog" class="headerlink" title="（7）lastlog"></a><strong>（7）<font color="red">lastlog</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/lastlog</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：lastlog</strong> </p>
</li>
<li><p><strong>功能描述：检查某特定用户上次登录的时间</strong></p>
</li>
<li><p><strong>范例：</strong></p>
<ul>
<li><strong>#lastlog</strong> </li>
<li><strong>#lastlog -u 502</strong></li>
</ul>
</li>
</ul>
<h5 id="（8）traceroute"><a href="#（8）traceroute" class="headerlink" title="（8）traceroute"></a><strong>（8）<font color="red">traceroute</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/traceroute 执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：traceroute</strong> </p>
</li>
<li><p><strong>功能描述：显示数据包到主机间的路径</strong></p>
</li>
<li><p><strong>范例：# traceroute <a href="http://www.lampbrother.net/">www.lampbrother.net</a></strong></p>
</li>
</ul>
<h5 id="（9）netstat"><a href="#（9）netstat" class="headerlink" title="（9）netstat"></a><strong>（9）<font color="red">netstat</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/netstat</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：netstat [选项]</strong> </p>
</li>
<li><p><strong>功能描述：显示网络相关信息</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-t ： TCP 协议</strong> </li>
<li><strong>-u ： UDP 协议</strong> </li>
<li><strong>-l ： 监听</strong> </li>
<li><strong>-r ： 路由</strong> </li>
<li><strong>-n ： 显示 IP 地址和端口号</strong></li>
</ul>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><strong># netstat -tlun 查看本机监听的端口</strong></li>
<li><strong># netstat -an 查看本机所有的网络连接</strong> </li>
<li><strong># netstat -rn 查看本机路由表</strong></li>
<li><strong>查看某一端口是否被占用：netstat -tunlp |grep 2181</strong></li>
</ul>
</li>
</ul>
<h5 id="（10）setup"><a href="#（10）setup" class="headerlink" title="（10）setup"></a><strong>（10）<font color="red">setup</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/setup</strong> </p>
</li>
<li><p><strong>执行权限：root</strong> </p>
</li>
<li><p><strong>语法：setup</strong> </p>
</li>
<li><p><strong>功能描述：配置网络</strong></p>
</li>
<li><p><strong>范例：# setup</strong></p>
</li>
</ul>
<h3 id="4-8-挂载命令"><a href="#4-8-挂载命令" class="headerlink" title="4.8 挂载命令"></a><strong>4.8 挂载命令</strong></h3><h5 id="（1）mount"><a href="#（1）mount" class="headerlink" title="（1）mount"></a><strong>（1）<font color="red">mount</font></strong></h5><ul>
<li><strong>命令位置：/bin/mount</strong> </li>
<li><strong>执行权限：所有用户</strong></li>
<li><strong>命令语法：mount [-t 文件系统] 设备文件名 挂载点</strong></li>
<li><strong>范例：# mount -t iso9660 /dev/sr0 /mnt/cdrom</strong></li>
</ul>
<h5 id="（2）步骤分析"><a href="#（2）步骤分析" class="headerlink" title="（2）步骤分析"></a><strong>（2）步骤分析</strong></h5><ul>
<li><p><strong>第一步</strong></p>
<p><strong>放入光盘，虚拟机中放入，或者服务器下载ios文件</strong></p>
</li>
<li><p><strong>第二步</strong></p>
<p><strong>创建一个空目录，设为挂载点    mkdir /media/cdrom</strong> </p>
<p><strong>/media用来做光盘挂载的，/mnt 也可以</strong></p>
</li>
<li><p><strong>第三步</strong></p>
<p><strong>输入命令    mount -t iso9660 /dev/sr0 /media/cdrom</strong></p>
<p><strong>设备文件名默认就是/dev/sr0，文件系统为iso9660 它是国际标准的cd文件格式，它告诉mount命令，我要挂载的是一个标准的cd。</strong></p>
<p><strong>/dev/cdrom也可以写 /dev/sr0，/dev/cdrom是sr0的软链接</strong></p>
</li>
<li><p><strong>第四步</strong></p>
<p><strong>进入挂载后的盘符    cd /media/cdrom</strong></p>
</li>
<li><p><strong>第五步</strong></p>
<p><strong>卸载光盘</strong></p>
<p><strong>先退出/media/cdrom，输入命令：cd；然后再输入命令：umount /dev/sr0</strong></p>
<p><strong>注意：如果之前挂载过其他盘，需要卸载之后才能挂载，输入命令：<br>umount /dev/sr0</strong></p>
</li>
</ul>
<h3 id="4-9-关机重启命令"><a href="#4-9-关机重启命令" class="headerlink" title="4.9 关机重启命令"></a><strong>4.9 关机重启命令</strong></h3><h5 id="（1）shutdown"><a href="#（1）shutdown" class="headerlink" title="（1）shutdown"></a><strong>（1）<font color="red">shutdown</font></strong></h5><ul>
<li><p><strong>语法：shutdown [选项] 时间</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><p><strong>-c：取消前一个关机命令</strong><br><strong>-h：关机</strong><br><strong>-r：重启</strong></p>
</li>
<li><p><strong>时间选项</strong></p>
<p><strong>now 现在关机</strong><br><strong>20:30 八点半关机</strong></p>
</li>
</ul>
</li>
<li><p><strong>范例：</strong></p>
<ul>
<li><strong>shutdown -h now 关机</strong></li>
<li><strong>shutdown -c 取消上一次设定的关机时间</strong></li>
<li><strong>在服务器上重启需要谨慎，需要先停掉服务，否则物理内存会坏</strong><br><strong>而且远程服务器只能重启，关机后需要管理员手动开机</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）其他关机命令"><a href="#（2）其他关机命令" class="headerlink" title="（2）其他关机命令"></a><strong>（2）其他关机命令</strong></h5><ul>
<li><strong>halt</strong></li>
<li><strong>poweroff 相当于直接断电</strong></li>
<li><strong>init 0</strong></li>
<li><strong>推荐使用shutdown关机，会保存正在运行的服务</strong></li>
</ul>
<h5 id="（3）其他重启命令"><a href="#（3）其他重启命令" class="headerlink" title="（3）其他重启命令"></a><strong>（3）其他重启命令</strong></h5><ul>
<li><strong>reboot</strong></li>
<li><strong>init 6</strong></li>
</ul>
<h5 id="（3）系统的运行级别"><a href="#（3）系统的运行级别" class="headerlink" title="（3）系统的运行级别"></a><strong>（3）系统的运行级别</strong></h5><ul>
<li><p><strong>init 0-6</strong></p>
<ul>
<li><strong>0：关机</strong></li>
<li><strong>1：单用户 进入选项菜单 只有root用户登陆进去 相当于Windows安全模式F8，只不过没有图形界面</strong></li>
<li><strong>2：不完全多用户，不含NFS服务，没有图形界面 NFS网络文件系统，Linux之间文件传输共享方式，除了NFS服务，和3一样。</strong></li>
<li><strong>3：完全多用户，没有图形界面</strong></li>
<li><strong>4：未分配，没有图形界面</strong></li>
<li><strong>5：图形界面</strong></li>
<li><strong>6：重启</strong></li>
</ul>
</li>
<li><p><strong>查询系统运行级别：runlevel</strong></p>
</li>
<li><p><strong>退出登录命令：logout</strong></p>
<p><strong>注意：在服务器中一定要在操作完成之后退出登陆，否则其他人会直接进入你的服务器，造成非常大的损失。最基本的安全意识一定要有！！！</strong></p>
</li>
</ul>
<h2 id="第五章-文本编辑器vim"><a href="#第五章-文本编辑器vim" class="headerlink" title="第五章 文本编辑器vim"></a><strong>第五章 文本编辑器vim</strong></h2><h3 id="5-1-vim常用操作"><a href="#5-1-vim常用操作" class="headerlink" title="5.1 vim常用操作"></a><strong>5.1 vim常用操作</strong></h3><h4 id="5-1-1-vim简介"><a href="#5-1-1-vim简介" class="headerlink" title="5.1.1 vim简介"></a><strong>5.1.1 vim简介</strong></h4><ul>
<li><p><strong>Vim 是一个功能强大的全屏幕文本编辑器， 是 Linux/UNIX 上最常用的文本编辑器， 它的作用是建立、编辑、显示文本文件。</strong></p>
</li>
<li><p><strong>Vim 没有菜单，只有命令。</strong></p>
</li>
</ul>
<h4 id="5-1-2-vim工作模式"><a href="#5-1-2-vim工作模式" class="headerlink" title="5.1.2 vim工作模式"></a><strong>5.1.2 vim工作模式</strong></h4><p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210817092541707.png" alt="image-20210817092541707"></strong></p>
<h5 id="（1）三种模式"><a href="#（1）三种模式" class="headerlink" title="（1）三种模式"></a><strong>（1）三种模式</strong></h5><ul>
<li><p><strong>命令模式：vi/vim+文件名进入命令模式，不可以输入文字，只能识别命令</strong></p>
</li>
<li><p><strong>插入模式：按i/a/o命令进入，可继续输入文字，按Esc退出</strong></p>
</li>
<li><p><strong>编辑模式：在命令模式下按“：”，即可进入编辑模式，可以输入编辑命令，比如保持并退出。</strong></p>
</li>
</ul>
<h5 id="（2）插入命令"><a href="#（2）插入命令" class="headerlink" title="（2）插入命令"></a><strong>（2）插入命令</strong></h5><p>​    <strong>a i o</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>a</strong></td>
<td align="center"><strong>在光标所在<font color="cornflowerblue">字符后</font>插入</strong></td>
</tr>
<tr>
<td align="center"><strong>A</strong></td>
<td align="center"><strong>在光标所在行<font color="cornflowerblue">行尾</font>插入</strong></td>
</tr>
<tr>
<td align="center"><strong>i</strong></td>
<td align="center"><strong>在光标所在<font color="cornflowerblue">字符前</font>插入</strong></td>
</tr>
<tr>
<td align="center"><strong>I</strong></td>
<td align="center"><strong>在光标所在行<font color="cornflowerblue">行首</font>插入</strong></td>
</tr>
<tr>
<td align="center"><strong>o</strong></td>
<td align="center"><strong>在光标下插入新行</strong></td>
</tr>
<tr>
<td align="center"><strong>O</strong></td>
<td align="center"><strong>在光标上插入新行</strong></td>
</tr>
</tbody></table>
<h5 id="（3）定位命令"><a href="#（3）定位命令" class="headerlink" title="（3）定位命令"></a><strong>（3）定位命令</strong></h5><p>​    <strong>G</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>:set nu</strong></td>
<td align="center"><strong>设置行号</strong></td>
</tr>
<tr>
<td align="center"><strong>:set nonu</strong></td>
<td align="center"><strong>取消行号</strong></td>
</tr>
<tr>
<td align="center"><strong>gg</strong></td>
<td align="center"><strong>到第一行</strong></td>
</tr>
<tr>
<td align="center"><strong>G</strong></td>
<td align="center"><strong>到最后一行</strong></td>
</tr>
<tr>
<td align="center"><strong>nG</strong></td>
<td align="center"><strong>到第n行</strong></td>
</tr>
<tr>
<td align="center"><strong>: n</strong></td>
<td align="center"><strong>到第n行 和上面一样的格式</strong></td>
</tr>
<tr>
<td align="center"><strong>$</strong></td>
<td align="center"><strong>移动到行尾</strong></td>
</tr>
<tr>
<td align="center"><strong>0</strong></td>
<td align="center"><strong>移动到行首</strong></td>
</tr>
</tbody></table>
<h5 id="（4）删除命令"><a href="#（4）删除命令" class="headerlink" title="（4）删除命令"></a><strong>（4）删除命令</strong></h5><p>​    <strong>x d</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>x</strong></td>
<td align="center"><strong>删除光标所在处的字符</strong></td>
</tr>
<tr>
<td align="center"><strong>nx</strong></td>
<td align="center"><strong>删除光标所在处后n个字符</strong></td>
</tr>
<tr>
<td align="center"><strong>dd</strong></td>
<td align="center"><strong>删除光标所在行</strong></td>
</tr>
<tr>
<td align="center"><strong>ndd</strong></td>
<td align="center"><strong>删除下面n行</strong></td>
</tr>
<tr>
<td align="center"><strong>dG</strong></td>
<td align="center"><strong>删除光标所在行到文件末尾的内容</strong></td>
</tr>
<tr>
<td align="center"><strong>D</strong></td>
<td align="center"><strong>删除光标所在处到行尾内容</strong></td>
</tr>
<tr>
<td align="center"><strong>:m,nd</strong></td>
<td align="center"><strong>删除指定范围的行 m-n的行全部被删除</strong></td>
</tr>
</tbody></table>
<h5 id="（5）复制和剪切命令"><a href="#（5）复制和剪切命令" class="headerlink" title="（5）复制和剪切命令"></a><strong>（5）复制和剪切命令</strong></h5><p>​    <strong>yy dd p</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>yy</strong></td>
<td align="center"><strong>复制当前行</strong></td>
</tr>
<tr>
<td align="center"><strong>nyy</strong></td>
<td align="center"><strong>复制当前行以下n行</strong></td>
</tr>
<tr>
<td align="center"><strong>dd</strong></td>
<td align="center"><strong>剪切当前行</strong></td>
</tr>
<tr>
<td align="center"><strong>ndd</strong></td>
<td align="center"><strong>剪切当前行以下n行</strong></td>
</tr>
<tr>
<td align="center"><strong>p</strong></td>
<td align="center"><strong>粘贴在当前光标所在行下</strong></td>
</tr>
<tr>
<td align="center"><strong>P</strong></td>
<td align="center"><strong>粘贴在当前光标所在行上</strong></td>
</tr>
</tbody></table>
<h5 id="（6）替换和取消命令"><a href="#（6）替换和取消命令" class="headerlink" title="（6）替换和取消命令"></a><strong>（6）替换和取消命令</strong></h5><p>​    <strong>r R</strong></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>r</strong></td>
<td><strong>替换光标所在处字符</strong></td>
</tr>
<tr>
<td><strong>R</strong></td>
<td><strong>从光标所在处开始替换字符，按Esc结束</strong></td>
</tr>
<tr>
<td><strong>u</strong></td>
<td><strong>撤消上一操作</strong></td>
</tr>
</tbody></table>
<h5 id="（7）搜索和替换命令"><a href="#（7）搜索和替换命令" class="headerlink" title="（7）搜索和替换命令"></a><strong>（7）搜索和替换命令</strong></h5><ul>
<li><p><strong>/string 搜索指定字符串string，与less命令操作类似</strong></p>
<ul>
<li><strong>搜索时忽略大小写:set ic</strong></li>
<li><strong>搜索时不忽略大小写:set noic</strong></li>
<li><strong>n 搜索指定字符串的下一个出现位置</strong></li>
</ul>
</li>
<li><p><strong>:%s/oldString/newString/g   不询问,全文替换指定字符串</strong></p>
</li>
<li><p><strong>:%s/oldString/newString/c   询问确认，全文替换指定字符串</strong></p>
</li>
<li><p><strong>:m,ns/oldString/newString/g 在一定范围内替换指定字符串</strong></p>
</li>
</ul>
<h5 id="（8）保持和退出命令"><a href="#（8）保持和退出命令" class="headerlink" title="（8）保持和退出命令"></a><strong>（8）保持和退出命令</strong></h5><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>:w</strong></td>
<td><strong>保存修改</strong></td>
</tr>
<tr>
<td><strong>:w new_filename</strong></td>
<td><strong>另存为指定文件</strong></td>
</tr>
<tr>
<td><strong>:wq</strong></td>
<td><strong>保存修改并退出</strong></td>
</tr>
<tr>
<td><strong>ZZ</strong></td>
<td><strong>快捷键，保存修改退出</strong></td>
</tr>
<tr>
<td><strong>:q!</strong></td>
<td><strong>不保存修改退出</strong></td>
</tr>
<tr>
<td><strong>:wq!</strong></td>
<td><strong>保存修改并退出（所有者或root可用）</strong></td>
</tr>
</tbody></table>
<h3 id="5-2-vim使用技巧"><a href="#5-2-vim使用技巧" class="headerlink" title="5.2 vim使用技巧"></a><strong>5.2 vim使用技巧</strong></h3><ol>
<li><strong><font color="red">：r  !命令</font></strong><ul>
<li><strong>描述：在当前vim文档中，导入命令执行结果</strong></li>
<li><strong>例子：r !date 直接把当前时间导入当前的Vim文档</strong></li>
</ul>
</li>
<li><strong><font color="red">：map [快捷键] [触发命令] </font></strong><ul>
<li><strong>描述：定义快捷键</strong></li>
<li><strong>注意：其中快捷键需要按ctrl+v+需要设定的键位，设定好之后颜色会变，比如想设定ctrl p为快捷键那么就按ctrl+v+p 会出现^P ，不能按shift+6出现的^,这两个虽然看起来一样但是颜色不一样。触发命令按需要执行的命令的先后顺序来排列，比如给脚本加注释#键就可以把[触发命令]设为I#</strong></li>
<li><strong>例子：map ^P I#  给脚本行首加#注释</strong></li>
</ul>
</li>
<li><strong><font color="red">：m,ns/^/#/g </font></strong><ul>
<li><strong>描述：指定连续行注释</strong></li>
</ul>
</li>
<li><strong><font color="red">：m,ns/^#//g </font></strong><ul>
<li><strong>描述：取消连续行注释</strong></li>
</ul>
</li>
<li><strong><font color="red">：m,ns/^/ \ / \ //g </font></strong><ul>
<li><strong>描述：给连续行首加//</strong> </li>
<li><strong>注意//是//的转义</strong></li>
</ul>
</li>
<li><strong><font color="red">：ab [a内容][b内容]</font></strong><ul>
<li><strong>描述：替换，会自动把b内容替换成a</strong></li>
<li><strong>例子：ab mymail <a href="mailto:&#49;&#53;&#51;&#48;&#x32;&#x36;&#56;&#x37;&#56;&#x31;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;">&#49;&#53;&#51;&#48;&#x32;&#x36;&#56;&#x37;&#56;&#x31;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;</a>  当你在vim文档中输入mymail时按回车或者空格会自动变成<a href="mailto:&#x31;&#53;&#51;&#48;&#50;&#x36;&#x38;&#x37;&#56;&#49;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;">&#x31;&#53;&#51;&#48;&#50;&#x36;&#x38;&#x37;&#56;&#49;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;</a></strong></li>
</ul>
</li>
<li><strong>注意：定义的快捷键或ab的内容重启后会消失，这时需要我们在用户的家目录下写配置文件.vimrc，保持快捷键</strong><ul>
<li><strong>root用户在/root/.vimrc</strong></li>
<li><strong>其他用户在/home/username/.vimrc中编辑</strong></li>
</ul>
</li>
</ol>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vim%E9%94%AE%E7%9B%98%E5%9B%BE.gif" alt="vim键盘图"></strong></p>
<h2 id="第六章-软件包管理"><a href="#第六章-软件包管理" class="headerlink" title="第六章 软件包管理"></a><strong>第六章 软件包管理</strong></h2><h3 id="6-1-软件包管理简介"><a href="#6-1-软件包管理简介" class="headerlink" title="6.1 软件包管理简介"></a><strong>6.1 软件包管理简介</strong></h3><h4 id="6-1-1-源码包"><a href="#6-1-1-源码包" class="headerlink" title="6.1.1 源码包"></a><strong>6.1.1 源码包</strong></h4><p><strong>可以看到源代码，但是安装时间较慢；脚本安装包 类似Windows安装软件， 他是写了安装界面的源码包</strong></p>
<ul>
<li><strong>优点：</strong><ul>
<li><strong>1.开源，如果有足够的能力，可以修改源代码</strong></li>
<li><strong>2.可以自由选择所需的功能</strong></li>
<li><strong>3.软件是编译安装，所以更适合自己的系统，使用更加稳定也效率更高</strong></li>
<li><strong>4.卸载方便，直接删除安装目录</strong></li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>1.安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误</strong></li>
<li><strong>2.编译过程时间较长，安装比二进制安装时间长</strong></li>
<li><strong>3.因为是编译安装，安装过程中一旦报错新手很难解决</strong></li>
</ul>
</li>
</ul>
<h4 id="6-1-2-二进制包"><a href="#6-1-2-二进制包" class="headerlink" title="6.1.2 二进制包"></a><strong>6.1.2 二进制包</strong></h4><p><strong><font color="red">RPM包</font>，系统默认包，厂商已经进行了编译，看不到源代码，但是安装时间较快</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><strong>1.包管理系统简单，只通过几个命令就可以实现包的安装，升级，查询和卸载</strong></li>
<li><strong>2.安装速度比源码包安装快得多</strong></li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li><strong>1.经过编译，不再可以看到源代码</strong></li>
<li><strong>2.功能选择不如源码包灵活</strong></li>
<li><strong>3.<font color="orange">依赖性</font> ：依赖性指的是要想安装A包就得先安装B包，要想安装B包又得先安装C包，所以只能以CBA的顺序安装RPM包，删除的时候得按ABC顺序删除安装包，基本上所有的RPM包全有依赖性</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm 是由红帽公司开发的软件包管理方式，使用 rpm 我们可以方便的进行软件的安装、查询、卸载、升</span><br><span class="line">级等工作。但是 rpm 软件包之间的依赖性问题往往会很繁琐,尤其是软件由多个 rpm 包组成时。</span><br><span class="line">yum（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包</span><br><span class="line">管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关</span><br><span class="line">系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-2-rpm命令管理"><a href="#6-2-rpm命令管理" class="headerlink" title="6.2 rpm命令管理"></a><strong>6.2 rpm命令管理</strong></h3><h4 id="6-2-1-包命名与依赖性"><a href="#6-2-1-包命名与依赖性" class="headerlink" title="6.2.1 包命名与依赖性"></a><strong>6.2.1 包命名与依赖性</strong></h4><h5 id="（1）rpm包命名规则"><a href="#（1）rpm包命名规则" class="headerlink" title="（1）rpm包命名规则"></a><strong>（1）rpm包命名规则</strong></h5><p>​    <strong>Httpd-2.2.15.el6.centos.1.i686.rpm</strong></p>
<ul>
<li><strong>Httpd 软件包包名</strong></li>
<li><strong>2.2.15 软件版本</strong><br><strong>15 软件发布的次数</strong></li>
<li><strong>el6.centos 适合的Linux平台</strong></li>
<li><strong>i686 适合的硬件平台 noarch 表示任何硬件平台都可以安装</strong></li>
<li><strong>rpm rpm包扩展名</strong><br><strong>如果自己组建rpm包，都以rpm结尾，这样更加清晰，其他管理员可以明白</strong></li>
<li><strong>注意：Httpd-2.2.15.el6.centos.1.i686.rpm为包全名，Httpd 为包名是有区别的，Linux系统命令严格区分两者</strong></li>
</ul>
<h5 id="（2）依赖性"><a href="#（2）依赖性" class="headerlink" title="（2）依赖性"></a><strong>（2）依赖性</strong></h5><ul>
<li><strong>树形依赖：a→b→c</strong></li>
<li><strong>环形依赖：a→b→c→a</strong><br><strong>环形依赖需要把a,b,c三个同时安装</strong></li>
<li><strong>模块依赖：模块依赖查询网站：<a href="http://www.rpmfind.net/">www.rpmfind.net</a></strong><br><strong>如果安装时遇到问题，出现依赖性错误</strong><br><strong>被依赖文件以.so.[数字]结尾的为库依赖，需要直接安装这个软件，错误会自动解决</strong><br><strong>安装这个包时需要进入网站 <a href="http://www.rpmfind.net.查询被依赖文件/">www.rpmfind.net.查询被依赖文件</a></strong></li>
</ul>
<h4 id="6-2-2-安装、升级与卸载"><a href="#6-2-2-安装、升级与卸载" class="headerlink" title="6.2.2 安装、升级与卸载"></a><strong>6.2.2 安装、升级与卸载</strong></h4><h5 id="（1）包全名与包名"><a href="#（1）包全名与包名" class="headerlink" title="（1）包全名与包名"></a><strong>（1）包全名与包名</strong></h5><ul>
<li><strong>包全名：操作的包是没有安装的软件包时， 使用包全名。而且要注意路径</strong></li>
<li><strong>包名：：操作已经安装的软件包时，使用包名。是默认在搜索/var/lib/rpm中的数据库</strong></li>
</ul>
<h5 id="（2）rpm安装"><a href="#（2）rpm安装" class="headerlink" title="（2）rpm安装"></a><strong>（2）rpm安装</strong></h5><ul>
<li><p><strong>rpm –ivh 包全名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-i（install） 安装</strong> </li>
<li><strong>-v（verbose） 显示详细信息</strong> </li>
<li><strong>-h（hash） 显示进度</strong> </li>
<li><strong>–nodeps 不检测依赖性。 一般不用，安装时都得显示依赖性</strong></li>
</ul>
</li>
</ul>
<h5 id="（3）rpm包升级"><a href="#（3）rpm包升级" class="headerlink" title="（3）rpm包升级"></a><strong>（3）rpm包升级</strong></h5><ul>
<li><p><strong>rpm -Uvh 包全名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-U（upgrade） 升级</strong></li>
</ul>
</li>
</ul>
<h5 id="（4）rpm卸载"><a href="#（4）rpm卸载" class="headerlink" title="（4）rpm卸载"></a><strong>（4）rpm卸载</strong></h5><ul>
<li><p><strong>rpm -e 包名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-e（erase） 卸载</strong> </li>
<li><strong>–nodeps 不检查依赖性</strong></li>
</ul>
</li>
</ul>
<h4 id="6-2-3-查询"><a href="#6-2-3-查询" class="headerlink" title="6.2.3 查询"></a><strong>6.2.3 查询</strong></h4><h5 id="（1）查询是否安装"><a href="#（1）查询是否安装" class="headerlink" title="（1）查询是否安装"></a><strong>（1）查询是否安装</strong></h5><ul>
<li><p><strong>rpm -q 包名</strong></p>
<ul>
<li><strong>查询包是否安装</strong></li>
<li><strong>选项： -q 查询（query）</strong></li>
</ul>
</li>
<li><p><strong>rpm –qa</strong> </p>
<ul>
<li><strong>查询所有已经安装的 RPM <em>包</em></strong></li>
<li><strong>选项：-a 所有（all）</strong></li>
</ul>
</li>
<li><p><strong>rpm -qa | grep [关键字]</strong></p>
<ul>
<li><strong>查询所有含义关键字的包，| 为管道符 。作用是管道符左边命令的输出就会作为管道符右边命令的输入</strong></li>
<li><strong>注意：</strong><br><strong>1、管道命令只处理前一个命令正确输出，不处理错误输出。</strong><br><strong>2、管道命令右边命令，必须能够接收标准输入流命令才行。</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）查询软件包详细信息"><a href="#（2）查询软件包详细信息" class="headerlink" title="（2）查询软件包详细信息"></a><strong>（2）查询软件包详细信息</strong></h5><ul>
<li><p><strong>rpm –qi 包名</strong></p>
</li>
<li><p><strong>查询安装过的软件包的详细信息</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-i 查询软件信息（information）</strong> </li>
<li><strong>-p 查询未安装包信息（package）</strong></li>
</ul>
</li>
</ul>
<h5 id="（3）查询包中文件安装位置"><a href="#（3）查询包中文件安装位置" class="headerlink" title="（3）查询包中文件安装位置"></a><strong>（3）查询包中文件安装位置</strong></h5><ul>
<li><p><strong>rpm –ql 包名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-l 列表（list）</strong> </li>
<li><strong>-p 查询未安装包信息（package）</strong></li>
</ul>
</li>
</ul>
<h5 id="（4）查询系统文件属于哪个rpm包"><a href="#（4）查询系统文件属于哪个rpm包" class="headerlink" title="（4）查询系统文件属于哪个rpm包"></a><strong>（4）查询系统文件属于哪个rpm包</strong></h5><ul>
<li><p> <strong>rpm –qf 系统文件名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-f 查询系统文件属于哪个软件包（file）</strong></li>
</ul>
</li>
</ul>
<h5 id="（5）查询软件包的依赖性"><a href="#（5）查询软件包的依赖性" class="headerlink" title="（5）查询软件包的依赖性"></a><strong>（5）查询软件包的依赖性</strong></h5><ul>
<li><p><strong>rpm –qR 包名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-R 查询软件包的依赖性（requires）</strong> </li>
<li><strong>-p 查询未安装包信息（package）</strong></li>
</ul>
</li>
</ul>
<h4 id="6-2-4-校验和文件提取"><a href="#6-2-4-校验和文件提取" class="headerlink" title="6.2.4 校验和文件提取"></a><strong>6.2.4 校验和文件提取</strong></h4><h5 id="（1）rpm包校验"><a href="#（1）rpm包校验" class="headerlink" title="（1）rpm包校验"></a><strong>（1）rpm包校验</strong></h5><ul>
<li><p> <strong>rpm –V 已安装的包名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-V 校验指定 RPM 包中的文件（verify）</strong></li>
</ul>
</li>
<li><p><strong>验证内容中的 8 个信息的具体内容如下：</strong></p>
<ul>
<li><strong>S 文件大小是否改变</strong></li>
<li><strong>M 文件的类型或文件的权限（rwx）是否被改变</strong></li>
<li><strong>5 文件 MD5 校验和是否改变（可以看成文件内容是否改变）</strong></li>
<li><strong>D 设备的中，从代码是否改变</strong></li>
<li><strong>L 文件路径是否改变</strong></li>
<li><strong>U 文件的属主（所有者）是否改变</strong></li>
<li><strong>G 文件的属组是否改变</strong></li>
<li><strong>T 文件的修改时间是否改变</strong></li>
</ul>
</li>
<li><p><strong>文件类型</strong></p>
<ul>
<li><p><strong>c 配置文件（config file）</strong> </p>
</li>
<li><p><strong>d 普通文档（documentation）</strong> </p>
</li>
<li><p><strong>g “鬼”文件（ghost file），很少见，就是该文件不应该被这个RPM包包含</strong></p>
</li>
<li><p><strong>l 授权文件（license file）</strong> </p>
</li>
<li><p><strong>r 描述文件（read me）</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（2）rpm包中文件提取"><a href="#（2）rpm包中文件提取" class="headerlink" title="（2）rpm包中文件提取"></a><strong>（2）rpm包中文件提取</strong></h5><ul>
<li><strong>rpm2cpio 包全名 | cpio -idv .文件绝对路径</strong> <ul>
<li><strong>rpm2cpio ：将 rpm 包转换为 cpio 格式的命令</strong></li>
<li><strong>cpio ：是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件</strong></li>
</ul>
</li>
<li><strong>cpio 选项 &lt; [文件|设备]</strong> <ul>
<li><strong>选项：</strong> <ul>
<li><strong>-i：copy-in 模式，还原</strong> </li>
<li><strong>-d：还原时自动新建目录</strong> </li>
<li><strong>-v：显示还原过程</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-3-rpm包管理"><a href="#6-3-rpm包管理" class="headerlink" title="6.3 rpm包管理"></a><strong>6.3 rpm包管理</strong></h3><h4 id="6-3-1-IP地址配置和网络yum源"><a href="#6-3-1-IP地址配置和网络yum源" class="headerlink" title="6.3.1 IP地址配置和网络yum源"></a><strong>6.3.1 IP地址配置和网络yum源</strong></h4><h5 id="（1）IP地址配置"><a href="#（1）IP地址配置" class="headerlink" title="（1）IP地址配置"></a><strong>（1）IP地址配置</strong></h5><ul>
<li><p><strong>红帽使用<font color="orange">setup </font>命令配置IP，子网掩码，网关，DNS</strong><br><strong>然后<font color="orange">service network restart </font>重启网络服务</strong></p>
</li>
<li><p><strong>CentOS7使用<font color="orange">nmtui</font>命令配置IP，子网掩码，网关，DNS</strong><br><strong>然后service network restart 重启网络服务</strong></p>
</li>
<li><p><strong>启动网卡</strong></p>
<p> <strong>vi /etc/sysconfig/network-scripts/ifcfg-eth0</strong> </p>
<p><strong>把 ONBOOT=“no” 改为 ONBOOT=“yes“</strong> </p>
</li>
<li><p><strong>重启网络服务</strong></p>
<p><strong>service network restart</strong> </p>
</li>
</ul>
<h5 id="（2）网络yum源"><a href="#（2）网络yum源" class="headerlink" title="（2）网络yum源"></a><strong>（2）网络yum源</strong></h5><ul>
<li><p><strong><font color="red">vi /etc/yum.repos.d/CentOS-Base.repo</font></strong><br><strong>其中：</strong></p>
<ul>
<li><strong>CentOS-Base.repo为网络yum源</strong></li>
<li><strong>CentOS-Media.repo为本地磁盘yum源</strong></li>
</ul>
</li>
<li><p> <strong>进入yum内部配置文件中可以看到以下内容：</strong></p>
</li>
<li><p><strong>[base]：容器名称，一定要放在[]中</strong></p>
</li>
<li><p><strong>name：容器说明，可以自己随便写</strong></p>
</li>
<li><p><strong>mirrorlist：镜像站点，这个可以注释掉</strong></p>
</li>
<li><p><strong>baseurl：我们的yum源服务器的地址。默认是CentOS的官方的yum源服务器，是可以使用的，如果觉得慢可以改成你喜欢的yum镜像源地址</strong></p>
</li>
<li><p><strong>enabled：此容器是否生效</strong><br><strong>如果不写或者写成enable=1都是生效的，写成enable=0就是不生效</strong></p>
</li>
<li><p><strong>gpgcheck：如果1是指RPM的数字证书生效，如果是0则不生效</strong></p>
</li>
<li><p><strong>gpgkey：数字证书的公钥文件保存位置。不用修改</strong></p>
</li>
</ul>
<p>  <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211215145608598.png" alt="image-20211215145608598"></strong></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">镜像列表系统使用客户机的连接IP地址和每个镜像的更新状态来选择地理位置上的当前镜像接近客户。</span><br><span class="line">你应该在CentOS更新中使用这个，除非你手动选择其他镜像。</span><br><span class="line">如果镜像列表不适合您，您可以尝试注释掉的baseurl行。</span><br></pre></td></tr></table></figure>



<h4 id="6-3-2-yum命令"><a href="#6-3-2-yum命令" class="headerlink" title="6.3.2 yum命令"></a><strong>6.3.2 yum命令</strong></h4><h5 id="（1）常用yum命令"><a href="#（1）常用yum命令" class="headerlink" title="（1）常用yum命令"></a><strong>（1）常用yum命令</strong></h5><ul>
<li><p><strong>查询</strong></p>
<ul>
<li><strong>yum list      #查询所有可用软件包列表</strong> </li>
<li><strong>yum search 关键字     #搜索服务器上所有和关键字相关的包</strong></li>
</ul>
</li>
<li><p><strong>安装</strong></p>
<ul>
<li> <strong>yum –y install 包名</strong></li>
<li><strong>install 安装</strong></li>
<li><strong>-y 自动回答 yes</strong></li>
</ul>
</li>
<li><p><strong>升级</strong></p>
<ul>
<li><strong>yum -y update 包名、</strong></li>
<li><strong>update 升级</strong> </li>
<li><strong>-y 自动回答 yes</strong></li>
</ul>
<p><strong>==注意：yum -y update 后必须加包名，否则就是全盘更新，包括Linux内核也会更新，Linux内核在更新完成之后需要在本地进行配置，内核才可以启动，如果你是在服务器上跑这条命令，服务器直接崩溃，永远无法连接，再也不能启动！！！==</strong></p>
</li>
<li><p><strong>卸载</strong></p>
<ul>
<li> <strong>yum -y remove 包名</strong></li>
<li> <strong>remove 卸载</strong> </li>
<li><strong>-y 自动回答 yes</strong></li>
</ul>
<p><strong>==注意：yum -y remove卸载会把包所有的依赖包都会卸载，有时候会把系统文件也同时卸载，小心使用，尽量不要多用！==</strong></p>
</li>
<li><p><strong>Linux服务器安装软件包原则：</strong></p>
<p><strong>最小化安装，不安装多余软件，使用什么软件安装什么软件，手工装，尽量不卸载，尤其yum卸载尽量不要用！！！</strong></p>
</li>
</ul>
<h5 id="（2）yum软件组管理命令"><a href="#（2）yum软件组管理命令" class="headerlink" title="（2）yum软件组管理命令"></a><strong>（2）yum软件组管理命令</strong></h5><ul>
<li><p><strong>yum grouplist</strong></p>
<p><strong>#列出所有可用的软件组列表</strong> </p>
</li>
<li><p> <strong>yum groupinstall 软件组名</strong></p>
</li>
</ul>
<p>  <strong>#安装指定软件组，组名可以由 grouplist 查询出来</strong></p>
<ul>
<li><p><strong>yum groupremove 软件组名</strong></p>
<p><strong>#卸载指定软件组</strong></p>
</li>
<li><p><strong>tips:安装软件包组 有空格 用””括起来</strong></p>
</li>
</ul>
<h4 id="6-3-3-光盘yum源搭建"><a href="#6-3-3-光盘yum源搭建" class="headerlink" title="6.3.3 光盘yum源搭建"></a><strong>6.3.3 光盘yum源搭建</strong></h4><h5 id="（1）光盘yum源搭建"><a href="#（1）光盘yum源搭建" class="headerlink" title="（1）光盘yum源搭建"></a><strong>（1）光盘yum源搭建</strong></h5><ul>
<li><p><strong>第一步：挂载光盘</strong></p>
<pre><code> **mount /dev/cdrom /mnt/cdrom/** 
</code></pre>
</li>
<li><p><strong>第二步：让网络yum源失效</strong></p>
<p>​    <strong>把/etc/yum.repos.d/文件里除了CentOS-Media.repo文件的其他文件全部改名，把repo后缀改了，随便改一个，比如.bak</strong><br><strong>​    还可以让每个文件里面的enabled=0</strong></p>
</li>
</ul>
<p>​    <strong>改名具体命令： mv CentOS-Base.repo \ CentOS-Base.repo.bak</strong> </p>
<ul>
<li><p><strong>第三步：修改光盘yum源文件</strong></p>
<p>​     <strong>vim CentOS-Media.repo</strong> </p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[c6-media] 	#叫什么都可以</span><br><span class="line">name=CentOS-$releasever - Media 	# 名称叫什么都可以</span><br><span class="line">baseurl=file:///mnt/cdrom </span><br><span class="line"><span class="meta">#</span><span class="bash">地址为你自己的光盘挂载地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file:///media/cdrom/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file:///media/cdrecorder/</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">注释这两个不存在的地址 （ 不注释也没事，但是会显示报错）</span></span><br><span class="line">gpgcheck=1 </span><br><span class="line">enabled=1 </span><br><span class="line"><span class="meta">#</span><span class="bash">把 enabled=0 改为 enabled=1，让这个 yum 源配置文件生效</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure>



<h5 id="（2）Linux系统中挂载和使用光盘基本步骤"><a href="#（2）Linux系统中挂载和使用光盘基本步骤" class="headerlink" title="（2）Linux系统中挂载和使用光盘基本步骤"></a><strong>（2）Linux系统中挂载和使用光盘基本步骤</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建挂载点 </span><br><span class="line">mkdir /mnt/cdrom</span><br><span class="line">在 /mnt 目录下创建一个空文件夹 cdrom 作为光盘的挂载点（任何一个空目录都可以作为挂载点）。</span><br><span class="line"></span><br><span class="line">2. 打开光驱，放入光盘 </span><br><span class="line">如果用的是 VMware 中的虚拟机，进入虚拟机设置，选择“CD/DVD”硬件，勾选“已连接”和“启动时连接”，在连接处，选择“使用 ISO 映像文件”，浏览选择本地电脑中下载好的 ISO 光盘镜像文件，确定即可。</span><br><span class="line"></span><br><span class="line">3. 执行挂载命令</span><br><span class="line">mount -t iso9660 /dev/sr0 /mnt/cdrom</span><br><span class="line">或者</span><br><span class="line">mount /dev/sr0 /mnt/cdrom</span><br><span class="line">iso9660 是光盘的默认文件系统。</span><br><span class="line">由于 linux 系统可以自动识别光盘的文件系统，故“-t iso9660”也可以省略不写。</span><br><span class="line">光盘的设备文件名是固定的，一般为/dev/cdrom 或/dev/sr0。</span><br><span class="line">挂载成功后，就可以通过挂载点读取光盘里面的数据。</span><br><span class="line"></span><br><span class="line">4. 查看光盘中的数据</span><br><span class="line">cd /mnt/cdrom</span><br><span class="line">ls -l</span><br><span class="line">注意：操作完成之后，如果要取出光盘，必须解除挂载。</span><br><span class="line"></span><br><span class="line">5. 解除挂载</span><br><span class="line">不能在挂载点目录下解除挂载，必须先切换到其他目录（如用户家目录）。</span><br><span class="line">切换到用户家目录</span><br><span class="line">umount /dev/sr0</span><br><span class="line">或者</span><br><span class="line">umount /mnt/cdrom</span><br></pre></td></tr></table></figure>





<h3 id="6-4-源码包管理"><a href="#6-4-源码包管理" class="headerlink" title="6.4 源码包管理"></a><strong>6.4 源码包管理</strong></h3><h4 id="6-4-1-源码包和rpm包的区别"><a href="#6-4-1-源码包和rpm包的区别" class="headerlink" title="6.4.1 源码包和rpm包的区别"></a><strong>6.4.1 源码包和rpm包的区别</strong></h4><h5 id="（1）区别"><a href="#（1）区别" class="headerlink" title="（1）区别"></a><strong>（1）区别</strong></h5><p>​        <strong>安装之前的区别：概念上的区别</strong></p>
<p>​        <strong>安装之后的区别：安装位置不同</strong></p>
<h5 id="（2）rpm包安装位置"><a href="#（2）rpm包安装位置" class="headerlink" title="（2）rpm包安装位置"></a><strong>（2）rpm包安装位置</strong></h5><p>​    <strong>安装在默认位置中</strong></p>
<table>
<thead>
<tr>
<th><strong>默认安装路径</strong></th>
<th><strong>类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>/etc/</strong></td>
<td><strong>配置文件安装目录</strong></td>
</tr>
<tr>
<td><strong>/usr/bin/</strong></td>
<td><strong>可执行的命令安装目录</strong></td>
</tr>
<tr>
<td><strong>/usr/lib/</strong></td>
<td><strong>程序所使用的函数库保存位置</strong></td>
</tr>
<tr>
<td><strong>/usr/share/doc/</strong></td>
<td><strong>基本的软件使用手册保存位置</strong></td>
</tr>
<tr>
<td><strong>/usr/share/man/</strong></td>
<td><strong>帮助文件保存位置</strong></td>
</tr>
</tbody></table>
<h5 id="（3）源码包安装路径"><a href="#（3）源码包安装路径" class="headerlink" title="（3）源码包安装路径"></a><strong>（3）源码包安装路径</strong></h5><p>​    <strong>安装在指定位置中，一般是    /usr/local/软件名/</strong></p>
<h5 id="（4）安装位置不同带来的影响"><a href="#（4）安装位置不同带来的影响" class="headerlink" title="（4）安装位置不同带来的影响"></a><strong>（4）安装位置不同带来的影响</strong></h5><ul>
<li><p><strong>RPM 包安装的服务可以使用系统服务管理命令（service）来管理，例如 RPM 包安装的 apache 的启动方法是：</strong></p>
<ul>
<li><p><strong>/etc/rc.d/init.d/httpd start</strong> </p>
</li>
<li><p><strong>service httpd start</strong></p>
</li>
<li><p><strong>RPM包的启动文件全在/etc/rc.d/init.d/里，servic会搜索RPM包所有的安装路径，所以service才能启动RPM包软件，但是启动不了源码包软件，因为源码包在/usr/local里，和RPM包不一样</strong></p>
</li>
</ul>
</li>
<li><p><strong>而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如：</strong></p>
<ul>
<li><strong>/usr/local/apache2/bin/apachectl start</strong></li>
</ul>
</li>
</ul>
<h4 id="6-4-2-源码包安装过程"><a href="#6-4-2-源码包安装过程" class="headerlink" title="6.4.2 源码包安装过程"></a><strong>6.4.2 源码包安装过程</strong></h4><p><strong>以“安装Apache”为例说明</strong></p>
<h5 id="（1）安装准备"><a href="#（1）安装准备" class="headerlink" title="（1）安装准备"></a><strong>（1）安装准备</strong></h5><ul>
<li><p><strong>安装C语言编译器</strong></p>
<p><strong>yum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake</strong></p>
</li>
<li><p><strong>下载源码包</strong></p>
<p><strong><a href="http://mirror.bit.edu.cn/apache/httpd/">http://mirror.bit.edu.cn/apache/httpd/</a></strong></p>
<p><strong>选择任何版本，比如：httpd-2.4.43.tar.bz2 版本</strong></p>
</li>
</ul>
<h5 id="（2）注意事项"><a href="#（2）注意事项" class="headerlink" title="（2）注意事项"></a><strong>（2）注意事项</strong></h5><ul>
<li><p><strong>源码包保存位置：/usr/local/src</strong></p>
</li>
<li><p><strong>软件安装位置：/usr/local</strong></p>
</li>
<li><p><strong>如何确定安装过程报错：</strong></p>
<p><strong>安装过程停止，并出现error，warning或者no提示，即发生错误</strong></p>
</li>
<li><p><strong>把电脑下载好的源码包传输到Linux系统或者服务器上</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows下载WinSCP软件进行本机与虚拟机或者远程传输</span><br><span class="line"></span><br><span class="line">Mac连接远程阿里云服务器，终端使用命令 scp进行传输：</span><br><span class="line">scp -r localfile.txt username@192.168.0.1:/home/username/</span><br><span class="line">其中，</span><br><span class="line">１）scp是命令，-r是参数</span><br><span class="line">２）localfile.txt 是文件的路径和文件名</span><br><span class="line">３）username是服务器账号，一般为root</span><br><span class="line">４）192.168.0.1是要上传的服务器ip地址</span><br><span class="line">５）/home/username/是要拷入的文件夹路径，一般为/root 家目录</span><br><span class="line">例子：</span><br><span class="line">scp -r /Users/yangyangyang/Desktop/httpd-2.4.43.tar.bz2 root@47.95.5.171:/root</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）解压下载的源码包"><a href="#（3）解压下载的源码包" class="headerlink" title="（3）解压下载的源码包"></a><strong>（3）解压下载的源码包</strong></h5><ul>
<li><strong>bar.bz2压缩包：使用命令 tar -jxvf httpd-2.4.43.tar.bz2</strong></li>
<li><strong>tar.gz压缩包：使用命令tar -zxvf</strong> </li>
</ul>
<h5 id="（4）进入压缩目录"><a href="#（4）进入压缩目录" class="headerlink" title="（4）进入压缩目录"></a><strong>（4）进入压缩目录</strong></h5><ul>
<li><strong>输入命令：cd httpd-2.4.43</strong><ul>
<li><strong>INSTALL：安装说明</strong></li>
<li><strong>README：使用说明</strong></li>
</ul>
</li>
<li><strong>进入安装说明：vi INSTALL</strong><br><strong>$ ./configure –prefix=PREFIX 编译前准备</strong><br><strong>$ make 进行编译</strong><br><strong>$ make install 编译安装</strong><br><strong>$ PREFIX/bin/apachectl star 启动命令</strong></li>
<li><strong>这些为详细的安装步骤，其中：</strong><br><strong>./configure为软件配置与检查 我们也称编译前准备</strong><br><strong>1.定义需要的功能选项。</strong><br><strong>2.检测系统环境是否符合安装要求</strong><br><strong>3.把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。</strong></li>
</ul>
<h5 id="（5）定义安装路径"><a href="#（5）定义安装路径" class="headerlink" title="（5）定义安装路径"></a><strong>（5）定义安装路径</strong></h5><p>​    <strong>退出之后</strong><br><strong>​    输入命令：./configure –prefix=/usr/local/apache2</strong><br><strong>​    如果报错显示：</strong><br><strong>​    进以下网址寻求解决办法</strong><br><strong>​    <a href="http://www.cnblogs.com/yuzhaokai0523/p/4382974.html">http://www.cnblogs.com/yuzhaokai0523/p/4382974.html</a></strong></p>
<h5 id="（6）进行编译"><a href="#（6）进行编译" class="headerlink" title="（6）进行编译"></a><strong>（6）进行编译</strong></h5><p>​    <strong>输入命令：make 进行编译</strong></p>
<h5 id="（7）进行安装"><a href="#（7）进行安装" class="headerlink" title="（7）进行安装"></a><strong>（7）进行安装</strong></h5><p>​    <strong>输入命令：make install 编译安装</strong></p>
<h5 id="（8）启动"><a href="#（8）启动" class="headerlink" title="（8）启动"></a><strong>（8）启动</strong></h5><p>​    <strong>输入命令：/usr/local/apache2/bin/apachectl start</strong></p>
<p>​    <strong>$ PREFIX/bin/apachectl star中 $ PREFIX为软件安装路径</strong></p>
<h5 id="（9）启动apach遇到错误"><a href="#（9）启动apach遇到错误" class="headerlink" title="（9）启动apach遇到错误"></a><strong>（9）启动apach遇到错误</strong></h5><p>​    <strong>httpd: Could not reliably determine the server’s fully qualified domain name</strong></p>
<p>​    <strong>解决办法：</strong></p>
<p>​    <strong>1.cd /usr/local/apache2/conf</strong><br><strong>​    2.vi httpd.conf</strong><br><strong>​    找到#ServerName <a href="http://www.example.com/">www.example.com:80</a></strong><br><strong>​    并且在下面一行添加</strong><br><strong>​    ServerName localhost:80     # localhost可以换成阿里云的IP</strong><br><strong>​    3.保存并退出</strong><br><strong>​    4.再重新启动apache</strong><br><strong>​    /usr/local/apache2/bin/apachectl start</strong></p>
<h3 id="6-5-脚本包安装"><a href="#6-5-脚本包安装" class="headerlink" title="6.5 脚本包安装"></a><strong>6.5 脚本包安装</strong></h3><h4 id="6-5-1-脚本安装包"><a href="#6-5-1-脚本安装包" class="headerlink" title="6.5.1 脚本安装包"></a><strong>6.5.1 脚本安装包</strong></h4><ul>
<li><p><strong>脚本安装包并不是独立的软件包类型，常见安装的是源码包。</strong></p>
</li>
<li><p><strong>是人为把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装。</strong></p>
</li>
<li><p><strong>非常类似于 Windows 下软件的安装方式。</strong></p>
</li>
</ul>
<h4 id="6-5-2-Wemin"><a href="#6-5-2-Wemin" class="headerlink" title="6.5.2 Wemin"></a><strong>6.5.2 Wemin</strong></h4><h5 id="（1）Wemin的作用"><a href="#（1）Wemin的作用" class="headerlink" title="（1）Wemin的作用"></a><strong>（1）Wemin的作用</strong></h5><p>​    <strong>Webmin 是一个基于 Web 的 Linux 系统管理界面。您就可以通过图形化的方式设置用户帐号、Apache、DNS、文件共享等服务。</strong></p>
<h5 id="（2）安装过程"><a href="#（2）安装过程" class="headerlink" title="（2）安装过程"></a><strong>（2）安装过程</strong></h5><ul>
<li><p><strong>下载软件<a href="http://sourceforge.net/projects/webadmin/files/webmin/">http://sourceforge.net/projects/webadmin/files/webmin/</a></strong></p>
</li>
<li><p><strong>解压缩，并进入加压缩目录</strong></p>
</li>
<li><p><strong>执行安装脚本</strong></p>
</li>
</ul>
<h2 id="第七章-用户和用户组管理"><a href="#第七章-用户和用户组管理" class="headerlink" title="第七章 用户和用户组管理"></a><strong>第七章 用户和用户组管理</strong></h2><h3 id="7-1-用户配置文件"><a href="#7-1-用户配置文件" class="headerlink" title="7.1 用户配置文件"></a><strong>7.1 用户配置文件</strong></h3><h4 id="7-1-1-用户信息文件-etc-passwd"><a href="#7-1-1-用户信息文件-etc-passwd" class="headerlink" title="7.1.1 用户信息文件 /etc/passwd"></a><strong>7.1.1 用户信息文件 /etc/passwd</strong></h4><h5 id="（1）用户管理简介"><a href="#（1）用户管理简介" class="headerlink" title="（1）用户管理简介"></a><strong>（1）用户管理简介</strong></h5><ul>
<li><p><strong>越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范。</strong></p>
</li>
<li><p><strong>在 Linux 中主要是通过用户配置文件来查看和修改用户信息</strong></p>
</li>
<li><p><strong>通过命令：man 5 passwd 来查看passwd配置文件帮助信息 5代表配置文件</strong></p>
</li>
</ul>
<h5 id="（2）-etc-passwd-配置文件"><a href="#（2）-etc-passwd-配置文件" class="headerlink" title="（2）/etc/passwd 配置文件"></a><strong>（2）/etc/passwd 配置文件</strong></h5><ul>
<li><p><strong>第 1 字段：用户名称</strong></p>
</li>
<li><p><strong>第 2 字段：密码标志</strong></p>
</li>
<li><p><strong>第 3 字段：UID（用户 ID）</strong> </p>
<ul>
<li><strong>0： 超级用户</strong></li>
<li><strong>1-499： 系统用户（伪用户）</strong></li>
<li><strong>500-65535： 普通用户(centos7 从 1000 开始计算)</strong> </li>
</ul>
</li>
<li><p><strong>第 4 字段：GID（用户初始组 ID）[不推荐修改初始组]</strong> </p>
</li>
<li><p><strong>第 5 字段：用户说明</strong></p>
</li>
<li><p><strong>第 6 字段：家目录</strong></p>
<ul>
<li><strong>普通用户：/home/用户名/</strong> </li>
<li><strong>超级用户：/root/</strong> </li>
</ul>
</li>
<li><p><strong>第 7 字段：登录之后的 Shell</strong></p>
</li>
<li><p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211217154607305.png" alt="image-20211217154607305"></strong></p>
</li>
</ul>
<h5 id="（3）初始组和附加组"><a href="#（3）初始组和附加组" class="headerlink" title="（3）初始组和附加组"></a><strong>（3）初始组和附加组</strong></h5><ul>
<li><p> <strong>初始组：就是指用户一登录就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用户名相同的组名作为这个用户的初始组。</strong></p>
</li>
<li><p><strong>附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。</strong></p>
</li>
</ul>
<h5 id="（2）Shell是什么"><a href="#（2）Shell是什么" class="headerlink" title="（2）Shell是什么"></a><strong>（2）Shell是什么</strong></h5><ul>
<li><p><strong>Shell 就是 Linux 的命令解释器。</strong></p>
</li>
<li><p><strong>在/etc/passwd 当中，除了标准 Shell 是/bin/bash 之外，还可以是/sbin/nologin，/usr/bin/passwd 等。</strong></p>
</li>
<li><p><strong>tips:暂时禁用用户，可以把/bin/bash -&gt; /bin/nologin</strong></p>
</li>
</ul>
<h4 id="7-1-2-影子文件-etc-shadow"><a href="#7-1-2-影子文件-etc-shadow" class="headerlink" title="7.1.2 影子文件/etc/shadow"></a><strong>7.1.2 影子文件/etc/shadow</strong></h4><h5 id="（1）影子文件-etc-shadow"><a href="#（1）影子文件-etc-shadow" class="headerlink" title="（1）影子文件/etc/shadow"></a><strong>（1）影子文件/etc/shadow</strong></h5><ul>
<li><p><strong>第 1 字段：用户名</strong></p>
</li>
<li><p><strong>第 2 字段：加密密码</strong></p>
<ul>
<li><strong>加密算法升级为 SHA512 散列加密算法</strong></li>
<li><strong>如果密码位是“!!”或“*”代表没有密码，不能登录</strong></li>
</ul>
</li>
<li><p><strong>第 3 字段：密码最后一次修改日期</strong></p>
<ul>
<li><strong>使用 1970 年 1 月 1 日作为标准时间，每过一天时间戳加 1</strong> </li>
</ul>
</li>
<li><p><strong>第 4 字段：两次密码的修改间隔时间（和第 3 字段相比）</strong></p>
</li>
<li><p><strong>第 5 字段：密码有效期（和第 3 字段相比）</strong></p>
</li>
<li><p><strong>第 6 字段：密码修改到期前的警告天数（和第 5 字段相比）</strong></p>
</li>
<li><p><strong>第 7 字段：密码过期后的宽限天数（和第 5 字段相比）</strong></p>
<ul>
<li><strong>0：代表密码过期后立即失效</strong></li>
<li><strong>-1：则代表密码永远不会失效。</strong></li>
</ul>
</li>
<li><p> <strong>第 8 字段：账号失效时间</strong></p>
</li>
<li><p><strong>要用时间戳表示</strong></p>
</li>
<li><p><strong>第 9 字段：保留</strong></p>
</li>
</ul>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211217155913026.png" alt="image-20211217155913026"></strong></p>
<h5 id="（2）时间戳换算"><a href="#（2）时间戳换算" class="headerlink" title="（2）时间戳换算"></a><strong>（2）时间戳换算</strong></h5><ul>
<li><strong>把时间戳换算为日期</strong><ul>
<li><strong>date -d “1970-01-01 16066 days”</strong> </li>
</ul>
</li>
<li><strong>把日期换算为时间戳</strong><ul>
<li><strong>echo $(($(date –date=”2014/01/06” +%s)/86400+1))</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZwz9evxymdqdx2e88fv2sZ ~]# date -d &quot;1970-01-01 16066 days&quot;</span><br><span class="line">Fri Dec 27 00:00:00 CST 2013</span><br><span class="line">[root@iZwz9evxymdqdx2e88fv2sZ ~]# echo $(($(date --date=&quot;2014/01/06&quot; +%s)/86400+1))</span><br><span class="line">16076</span><br></pre></td></tr></table></figure>



<h4 id="7-1-3-组信息文件"><a href="#7-1-3-组信息文件" class="headerlink" title="7.1.3 组信息文件"></a><strong>7.1.3 组信息文件</strong></h4><h5 id="（1）组信息文件-etc-group"><a href="#（1）组信息文件-etc-group" class="headerlink" title="（1）组信息文件/etc/group"></a><strong>（1）组信息文件/etc/group</strong></h5><ul>
<li>​    <strong>第一字段：组名</strong></li>
<li>​    <strong>第二字段：组密码标志</strong></li>
<li>​    <strong>第三字段：GID</strong> </li>
<li>​    <strong>第四字段：组中附加用户</strong></li>
</ul>
<h4 id="7-1-4-组密码文件"><a href="#7-1-4-组密码文件" class="headerlink" title="7.1.4 组密码文件"></a><strong>7.1.4 组密码文件</strong></h4><h5 id="（1）组密码文件-etc-gshadow"><a href="#（1）组密码文件-etc-gshadow" class="headerlink" title="（1）组密码文件/etc/gshadow"></a><strong>（1）组密码文件/etc/gshadow</strong></h5><ul>
<li><strong>第一字段：组名</strong></li>
<li><strong>第二字段：组密码 (不推荐使用，可以理解为给组设置个小组长)</strong> </li>
<li><strong>第三字段：组管理员用户名</strong></li>
<li><strong>第四字段：组中附加用户</strong></li>
</ul>
<h3 id="7-2-用户管理相关文件"><a href="#7-2-用户管理相关文件" class="headerlink" title="7.2 用户管理相关文件"></a><strong>7.2 用户管理相关文件</strong></h3><h5 id="（1）-用户的家目录"><a href="#（1）-用户的家目录" class="headerlink" title="（1） 用户的家目录"></a><strong>（1） 用户的家目录</strong></h5><ul>
<li><p><strong>普通用户：/home/用户名/，所有者和所属组都是此用户，权限是 700</strong> </p>
</li>
<li><p><strong>超级用户：/root/，所有者和所属组都是 root 用户，权限是 550</strong> </p>
</li>
</ul>
<h5 id="（2）用户的邮箱"><a href="#（2）用户的邮箱" class="headerlink" title="（2）用户的邮箱"></a><strong>（2）用户的邮箱</strong></h5><ul>
<li><strong>/var/spool/mail/用户名/</strong> </li>
</ul>
<h5 id="（3）用户模板目录"><a href="#（3）用户模板目录" class="headerlink" title="（3）用户模板目录"></a><strong>（3）用户模板目录</strong></h5><ul>
<li><strong>/etc/skel/</strong></li>
</ul>
<h3 id="7-3-用户管理命令"><a href="#7-3-用户管理命令" class="headerlink" title="7.3 用户管理命令"></a><strong>7.3 用户管理命令</strong></h3><h4 id="7-3-1-用户添加命令-useradd"><a href="#7-3-1-用户添加命令-useradd" class="headerlink" title="7.3.1 用户添加命令 useradd"></a><strong>7.3.1 用户添加命令 useradd</strong></h4><h5 id="（1）useradd命令格式"><a href="#（1）useradd命令格式" class="headerlink" title="（1）useradd命令格式"></a><strong>（1）useradd命令格式</strong></h5><ul>
<li><p><strong>useradd [选项] 用户名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-u UID： 手工指定用户的 UID 号</strong> </li>
<li><strong>-d 家目录： 手工指定用户的家目录</strong> </li>
<li><strong>-c 用户说明： 手工指定用户的说明</strong> </li>
<li><strong>-g 组名： 手工指定用户的初始组</strong> </li>
<li><strong>-G 组名： 指定用户的附加组</strong> </li>
<li><strong>-s shell： 手工指定用户的登录 shell。默认是/bin/bash</strong> </li>
</ul>
</li>
</ul>
<h5 id="（2）添加默认用户"><a href="#（2）添加默认用户" class="headerlink" title="（2）添加默认用户"></a><strong>（2）添加默认用户</strong></h5><ul>
<li><p><strong>[root@localhost ~]# useradd lamp</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# grep “lamp” /etc/passwd l</strong></p>
</li>
<li><p><strong>[root@localhost ~]# grep “lamp” /etc/shadow</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# grep “lamp” /etc/group</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# grep “lamp” /etc/gshadow</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# ll -d /home/lamp/</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# ll /var/spool/mail/lamp</strong></p>
</li>
</ul>
<h5 id="（3）指定选项添加用户"><a href="#（3）指定选项添加用户" class="headerlink" title="（3）指定选项添加用户"></a><strong>（3）指定选项添加用户</strong></h5><ul>
<li><p><strong>groupadd lamp1</strong> </p>
</li>
<li><p><strong>useradd -u 550 -g lamp1 -G root -d /home/lamp1 \ -c “test user” -s /bin/bash lamp1、</strong></p>
</li>
</ul>
<h5 id="（4）用户默认值文件"><a href="#（4）用户默认值文件" class="headerlink" title="（4）用户默认值文件"></a><strong>（4）用户默认值文件</strong></h5><p>​    <strong>里面定义了建立用户的默认信息</strong></p>
<ul>
<li><p><strong>/etc/default/useradd</strong> </p>
<ul>
<li><p><strong>GROUP=100 #用户默认组</strong> </p>
</li>
<li><p><strong>HOME=/home #用户家目录</strong> </p>
</li>
<li><p><strong>INACTIVE=-1 #密码过期宽限天数（7）</strong> </p>
</li>
<li><p><strong>EXPIRE= #密码失效时间（8）</strong> </p>
</li>
<li><p><strong>SHELL=/bin/bash #默认 shell</strong> </p>
</li>
<li><p><strong>SKEL=/etc/skel #模板目录</strong></p>
</li>
<li><p><strong>CREATE_MAIL_SPOOL=yes #是否建立邮箱</strong></p>
</li>
</ul>
</li>
<li><p><strong>/etc/login.defs</strong> </p>
<ul>
<li><p><strong>PASS_MAX_DAYS 99999 #密码有效期（5）</strong> </p>
</li>
<li><p><strong>PASS_MIN_DAYS 0 #密码修改间隔（4）</strong> </p>
</li>
<li><p><strong>PASS_MIN_LEN 5 #密码最小 5 位（PAM）</strong> </p>
</li>
<li><p><strong>PASS_WARN_AGE 7 #密码到期警告（6）</strong> </p>
</li>
<li><p><strong>UID_MIN 500 #最小和最大 UID 范围</strong></p>
</li>
<li><p><strong>GID_MAX 60000</strong> </p>
</li>
<li><p><strong>ENCRYPT_METHOD SHA512 #加密模式</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="7-3-2-修改用户密码-passwd"><a href="#7-3-2-修改用户密码-passwd" class="headerlink" title="7.3.2 修改用户密码 passwd"></a><strong>7.3.2 修改用户密码 passwd</strong></h4><h5 id="（1）passwd-命令格式"><a href="#（1）passwd-命令格式" class="headerlink" title="（1）passwd 命令格式"></a><strong>（1）passwd 命令格式</strong></h5><ul>
<li><p><strong>passwd [选项] 用户名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-S 查询用户密码的密码状态。仅 root 用户可用。</strong></li>
<li><strong>-l 暂时锁定用户。仅 root 用户可用</strong> </li>
<li><strong>-u 解锁用户。仅 root 用户可用</strong> </li>
<li><strong>–stdin 可以通过管道符输出的数据作为用户的密码。</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）查看密码状态"><a href="#（2）查看密码状态" class="headerlink" title="（2）查看密码状态"></a><strong>（2）查看密码状态</strong></h5><ul>
<li><p><strong>passwd -S lamp</strong> </p>
</li>
<li><p><strong>lamp PS 2013-01-06 0 99999 7 -1</strong> </p>
<ul>
<li><p><strong>用户名 密码设定时间（2013-01-06） 密码修改间隔时间（0） 密码有效期（99999 ） 警告</strong></p>
<p><strong>时间（7） 密码不失效（-1）</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（3）锁定用户和解锁用户"><a href="#（3）锁定用户和解锁用户" class="headerlink" title="（3）锁定用户和解锁用户"></a><strong>（3）锁定用户和解锁用户</strong></h5><ul>
<li><p><strong>passwd -l lamp</strong> </p>
</li>
<li><p><strong>passwd -u lamp</strong> </p>
</li>
</ul>
<h5 id="（4）-使用字符串作为用户的密码"><a href="#（4）-使用字符串作为用户的密码" class="headerlink" title="（4） 使用字符串作为用户的密码"></a><strong>（4） 使用字符串作为用户的密码</strong></h5><ul>
<li><strong>echo “123” | passwd –stdin lamp（shell 脚本可能会用到）</strong></li>
</ul>
<h4 id="7-3-3-修改用户信息-usermod"><a href="#7-3-3-修改用户信息-usermod" class="headerlink" title="7.3.3 修改用户信息 usermod"></a><strong>7.3.3 修改用户信息 usermod</strong></h4><h5 id="（1）命令"><a href="#（1）命令" class="headerlink" title="（1）命令"></a><strong>（1）命令</strong></h5><ul>
<li><p><strong>usermod [选项] 用户名</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-u UID： 修改用户的 UID 号</strong> </li>
<li><strong>-c 用户说明： 修改用户的说明信息</strong></li>
<li><strong>-G 组名： 修改用户的附加组</strong></li>
<li><strong>-L： 临时锁定用户（Lock）</strong> </li>
<li><strong>-U： 解锁用户锁定（Unlock）</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）举例"><a href="#（2）举例" class="headerlink" title="（2）举例"></a><strong>（2）举例</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# usermod -c &quot;test user&quot; lamp</span><br><span class="line">修改用户的说明</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# usermod -G root lamp</span><br><span class="line">把 lamp 用户加入 root 组 </span><br><span class="line"></span><br><span class="line">[root@localhost ~]# usermod -L lamp</span><br><span class="line">锁定用户</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# usermod -U lamp</span><br><span class="line">解锁用户</span><br></pre></td></tr></table></figure>



<h4 id="7-3-4-修改用户密码状态-chage"><a href="#7-3-4-修改用户密码状态-chage" class="headerlink" title="7.3.4 修改用户密码状态 chage"></a><strong>7.3.4 修改用户密码状态 chage</strong></h4><h5 id="（1）命令-1"><a href="#（1）命令-1" class="headerlink" title="（1）命令"></a><strong>（1）命令</strong></h5><ul>
<li><p><strong>chage [选项] 用户名</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-l： 列出用户的详细密码状态</strong></li>
<li><strong>-d 日期： 修改密码最后一次更改日期（shadow3 字段）</strong></li>
<li> <strong>-m 天数： 两次密码修改间隔（4 字段）</strong></li>
<li><strong>-M 天数： 密码有效期（5 字段）</strong></li>
<li><strong>-W 天数： 密码过期前警告天数（6 字段）</strong></li>
<li><strong>-I 天数： 密码过后宽限天数（7 字段）</strong></li>
<li><strong>-E 日期： 账号失效时间（8 字段）</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）举例-1"><a href="#（2）举例-1" class="headerlink" title="（2）举例"></a><strong>（2）举例</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chage -d 0 lamp </span><br><span class="line">这个命令其实是把密码修改日期归 0 了（shadow 第 3 字段）#这样用户一登陆就要修改</span><br><span class="line">密码</span><br></pre></td></tr></table></figure>



<h4 id="7-3-4-删除用户-userdel"><a href="#7-3-4-删除用户-userdel" class="headerlink" title="7.3.4 删除用户 userdel"></a><strong>7.3.4 删除用户 userdel</strong></h4><h5 id="（1）删除用户-userdel"><a href="#（1）删除用户-userdel" class="headerlink" title="（1）删除用户 userdel"></a><strong>（1）删除用户 userdel</strong></h5><ul>
<li><p> <strong>userdel [-r] 用户名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-r 删除用户的同时删除用户家目录</strong> </li>
</ul>
</li>
</ul>
<h5 id="（2）查看用户ID"><a href="#（2）查看用户ID" class="headerlink" title="（2）查看用户ID"></a><strong>（2）查看用户ID</strong></h5><ul>
<li><strong>id 用户名</strong></li>
</ul>
<h4 id="7-3-5-切换用户-su"><a href="#7-3-5-切换用户-su" class="headerlink" title="7.3.5 切换用户 su"></a><strong>7.3.5 切换用户 su</strong></h4><ul>
<li><p> <strong>su [选项] 用户名</strong></p>
</li>
<li><p><strong>选项</strong></p>
<ul>
<li><p><strong>- ： 选项只使用“-”代表连带用户的环境变量一起切换 (env 命令查看当前环</strong></p>
<p><strong>境变量)</strong> </p>
</li>
<li><p><strong>-c  命令： 仅执行一次命令，而不切换用户身份</strong> </p>
</li>
<li><p><strong>例子</strong></p>
<ul>
<li><p><strong>$ su – root</strong> </p>
<p><strong>#切换成 root</strong> </p>
</li>
<li><p><strong>su - root -c “useradd user3”</strong> </p>
<p><strong>#不切换成 root，但是执行 useradd 命令添加 user1 用户</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-4-用户组管理命令"><a href="#7-4-用户组管理命令" class="headerlink" title="7.4 用户组管理命令"></a><strong>7.4 用户组管理命令</strong></h3><h5 id="（1）添加用户组"><a href="#（1）添加用户组" class="headerlink" title="（1）添加用户组"></a><strong>（1）添加用户组</strong></h5><ul>
<li><p><strong>groupadd [选项] 组名</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-g GID #指定组 ID</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）修改用户组"><a href="#（2）修改用户组" class="headerlink" title="（2）修改用户组"></a><strong>（2）修改用户组</strong></h5><ul>
<li><p><strong>groupmod [选项] 组名</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><p><strong>-g GID     #修改组 ID</strong></p>
</li>
<li><p><strong>-n 新组名     #修改组名</strong></p>
</li>
<li><p><strong>例：[root@localhost ~]# groupmod -n yxlm lol</strong></p>
<p><strong>#把组名 lol 修改为 yxlm</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（3）删除用户组"><a href="#（3）删除用户组" class="headerlink" title="（3）删除用户组"></a><strong>（3）删除用户组</strong></h5><ul>
<li><p><strong>groupdel [选项] 组名</strong></p>
</li>
<li><p><strong>tips:删除组的时候，组内不允许有初始用户存在。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> groupadd lol</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> useradd -g lol timo</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> useradd -G lol yasuo</span></span><br><span class="line"></span><br><span class="line">因为 timo 是初始组是 lol。删除 lol 会导致 timo 没有初始组。所以不可删。需要先删除用户。</span><br><span class="line">而 yasuo 是附加组。可删。</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（4）-把用户添加入组或从组中删除"><a href="#（4）-把用户添加入组或从组中删除" class="headerlink" title="（4） 把用户添加入组或从组中删除"></a><strong>（4） 把用户添加入组或从组中删除</strong></h5><ul>
<li><p><strong>groupdel [选项] 组名</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-a 用户名： 把用户加入组</strong></li>
<li><strong>-d 用户名： 把用户从组中删除</strong></li>
</ul>
</li>
</ul>
<h2 id="第八章-权限管理"><a href="#第八章-权限管理" class="headerlink" title="第八章 权限管理"></a><strong>第八章 权限管理</strong></h2><h3 id="8-1-ACL权限"><a href="#8-1-ACL权限" class="headerlink" title="8.1 ACL权限"></a><strong>8.1 ACL权限</strong></h3><h4 id="8-1-1-ACL权限简介与开启"><a href="#8-1-1-ACL权限简介与开启" class="headerlink" title="8.1.1 ACL权限简介与开启"></a><strong>8.1.1 ACL权限简介与开启</strong></h4><h5 id="（1）ACL权限简介"><a href="#（1）ACL权限简介" class="headerlink" title="（1）ACL权限简介"></a><strong>（1）ACL权限简介</strong></h5><p>​        <strong>ACL 是 Access Control List 的缩写，主要的目的是在提供传统的 owner,group,others 的</strong></p>
<p>​    <strong>read,write,execute 权限之外的细部权限设定。ACL 可以针对单一使用者，单一文件或目录来进行</strong></p>
<p>​    <strong>r,w,x 的权限规范，对于需要特殊权限的使用状况非常有帮助。</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211221150819748.png" alt="image-20211221150819748"></strong></p>
<h5 id="（2）查看分区ACL权限是否开启"><a href="#（2）查看分区ACL权限是否开启" class="headerlink" title="（2）查看分区ACL权限是否开启"></a><strong>（2）查看分区ACL权限是否开启</strong></h5><ul>
<li><p><strong>dumpe2fs -h /dev/sda3</strong> </p>
<p><strong>#dumpe2fs 命令是查询指定分区详细文件系统信息的命令</strong></p>
</li>
<li><p><strong>选项： -h 仅显示超级块中信息，而不显示磁盘块组的详细信息</strong></p>
</li>
</ul>
<h5 id="（3）临时开启分区ACL权限"><a href="#（3）临时开启分区ACL权限" class="headerlink" title="（3）临时开启分区ACL权限"></a><strong>（3）临时开启分区ACL权限</strong></h5><ul>
<li><p><strong>mount -o remount,acl /</strong></p>
<p><strong>#重新挂载根分区，并挂载加入 acl 权限</strong> </p>
</li>
</ul>
<h5 id="（4）永久开启ACL权限"><a href="#（4）永久开启ACL权限" class="headerlink" title="（4）永久开启ACL权限"></a><strong>（4）永久开启ACL权限</strong></h5><ul>
<li><strong>vim /etc/fstab</strong><br><strong>显示：UUID=59d9ca7b-4f39-4c0c-9334-c56c182076b5 / ext4 defaults 1 1</strong></li>
<li><strong>在ext4后面的 defaults加,acl 成为</strong><br><strong>UUID=59d9ca7b-4f39-4c0c-9334-c56c182076b5 / ext4 defaults,acl 1 1</strong></li>
<li><strong>然后输入：mount -o remount /</strong><br><strong>重新挂载文件系统或重启系统，使修改生效</strong></li>
<li><strong>Linux现在一般所有分区全部默认开启ACL，不用修改配置</strong></li>
</ul>
<h4 id="8-1-2-ACL权限查看与设定"><a href="#8-1-2-ACL权限查看与设定" class="headerlink" title="8.1.2 ACL权限查看与设定"></a><strong>8.1.2 ACL权限查看与设定</strong></h4><h5 id="（1）查看ACL权限"><a href="#（1）查看ACL权限" class="headerlink" title="（1）查看ACL权限"></a><strong>（1）查看ACL权限</strong></h5><ul>
<li><p><strong>getfacl 文件名</strong> </p>
<p><strong>查看ACL命令 查看ACL权限</strong></p>
</li>
</ul>
<h5 id="（2）设定ACL权限"><a href="#（2）设定ACL权限" class="headerlink" title="（2）设定ACL权限"></a><strong>（2）设定ACL权限</strong></h5><ul>
<li><p><strong>setfacl [选项] 文件名</strong></p>
</li>
<li><p><strong>选型：</strong></p>
<ul>
<li><strong>-m：设定ACL权限</strong><br><strong>例子：</strong><ul>
<li><strong>setfacl -m u:st:rx /tmp/project 给用户st设定ACL权限读和操作</strong></li>
<li><strong>setfacl -m g:tg1:rwx /tmp/project 给用户组tg1设定ACL权限读，写和操作</strong><br><strong>-x：删除指定的ACL权限</strong></li>
</ul>
</li>
<li><strong>-b：删除所有的ACL权限</strong></li>
<li><strong>-d：设定默认的ACL权限</strong></li>
<li><strong>-k：删除默认ACL权限</strong></li>
<li><strong>-R：递归设定ACL权限</strong></li>
</ul>
</li>
<li><p><strong>举例</strong></p>
<ul>
<li><strong>给用户设定ACL权限</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# useradd zhangsan </span><br><span class="line">[root@localhost ~]# useradd lisi </span><br><span class="line">[root@localhost ~]# useradd st </span><br><span class="line">[root@localhost ~]# groupadd tgroup</span><br><span class="line">[root@localhost ~]# mkdir /project </span><br><span class="line">[root@localhost ~]# chown root:tgroup /project/ </span><br><span class="line">[root@localhost ~]# chmod 770 /project/ </span><br><span class="line">[root@localhost ~]# setfacl -m u:st:rx /project/ </span><br><span class="line"><span class="meta">#</span><span class="bash">给用户 st 赋予 r-x 权限，使用“u:用户名:权限”格式</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>给用户组设定ACL权限</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# groupadd tgroup2 </span><br><span class="line">[root@localhost /]# setfacl -m g:tgroup2:rwx project/ </span><br><span class="line"><span class="meta">#</span><span class="bash">为组 tgroup2 分配 ACl 权限。使用“g:组名:权限”格式</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-1-3-最大有效权限与删除ACL权限"><a href="#8-1-3-最大有效权限与删除ACL权限" class="headerlink" title="8.1.3 最大有效权限与删除ACL权限"></a><strong>8.1.3 最大有效权限与删除ACL权限</strong></h4><h5 id="（1）最大有效权限mask"><a href="#（1）最大有效权限mask" class="headerlink" title="（1）最大有效权限mask"></a><strong>（1）最大有效权限mask</strong></h5><ul>
<li><strong>mask是用来指导最大有效权限的。如果给用户赋予了ACL权限，是需要和mask 的权限“相与”才能得到用户的真正权限</strong></li>
<li><strong>setfscl -m m:rx 文件名</strong><br><strong>设定mask权限为r-x。使用“m:权限”格式</strong></li>
<li><strong>为了防止用户或者用户组给的权限过高，提前设定</strong></li>
</ul>
<h5 id="（2）权限删除"><a href="#（2）权限删除" class="headerlink" title="（2）权限删除"></a><strong>（2）权限删除</strong></h5><ul>
<li><strong>setfacl -x u:用户名 文件名    #删除指定用户的ACL权限</strong></li>
<li><strong>setfacl -x g:组名 文件名    #删除指定用户组的ACL权限</strong></li>
<li><strong>setfacl -b 文件名    #删除文件的所有ACL权限</strong></li>
</ul>
<h4 id="8-1-4-ACL权限递归与默认"><a href="#8-1-4-ACL权限递归与默认" class="headerlink" title="8.1.4 ACL权限递归与默认"></a><strong>8.1.4 ACL权限递归与默认</strong></h4><h5 id="（1）递归ACL权限"><a href="#（1）递归ACL权限" class="headerlink" title="（1）递归ACL权限"></a><strong>（1）递归ACL权限</strong></h5><ul>
<li><strong>递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限</strong></li>
<li><strong>命令：</strong><ul>
<li><strong>setfacl -m u:用户名:权限 -R 目录名</strong> </li>
<li><strong>-R必须在这个位置</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）默认ACL权限"><a href="#（2）默认ACL权限" class="headerlink" title="（2）默认ACL权限"></a><strong>（2）默认ACL权限</strong></h5><ul>
<li><strong>默认ACL权限的作用是，如果给父目录设定默认ACL权限，那么父目录中所有新建的子文件和子目录都会继承父目录的ACL权限</strong></li>
<li><strong>命令：</strong><ul>
<li><strong>Setfacl -m d:u:用户名:权限 目录名</strong> </li>
<li><strong>可以在权限后面加-R来进行递归</strong></li>
</ul>
</li>
</ul>
<p><strong>、</strong></p>
<h3 id="8-2-文件特殊权限"><a href="#8-2-文件特殊权限" class="headerlink" title="8.2 文件特殊权限"></a><strong>8.2 文件特殊权限</strong></h3><h4 id="8-2-1-SetUID"><a href="#8-2-1-SetUID" class="headerlink" title="8.2.1 SetUID"></a><strong>8.2.1 SetUID</strong></h4><h5 id="（1）SetUID的功能"><a href="#（1）SetUID的功能" class="headerlink" title="（1）SetUID的功能"></a><strong>（1）SetUID的功能</strong></h5><ul>
<li><p><strong>只有可以执行的<font color="red">二进制程序</font>才能设定 SUID 权限</strong></p>
</li>
<li><p><strong>命令执行者要对该程序拥有 x（执行）权限</strong></p>
</li>
<li><p><strong><font color="orange">命令执行者在执行该程序时获得该程序文件属主的身份</font>（在执行程序的过程中灵魂附体为文件的属主）</strong></p>
</li>
<li><p><strong>SetUID 权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效</strong> </p>
</li>
<li><p><strong>passwd 命令拥有 SetUID 权限，所以普通可以修改自己的密码</strong></p>
<ul>
<li><p><strong>[root@localhost ~]# ll /usr/bin/passwd</strong> </p>
<p><strong>-rw<font color="red">s</font>r-xr-x. 1 root root 25980 2 月 22 2012 /usr/bin/passwd</strong> </p>
</li>
</ul>
</li>
<li><p><strong>cat 命令没有 SetUID 权限，所以普通用户不能查看/etc/shadow 文件内容</strong></p>
<ul>
<li><strong>[root@localhost ~]# ll /bin/cat -rwxr-xr-x 1 root root 47976 6 月 22 2012 /bin/cat</strong></li>
</ul>
</li>
</ul>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211222132551724.png" alt="image-20211222132551724"></strong></p>
<h5 id="（2）设定SetUID的方法"><a href="#（2）设定SetUID的方法" class="headerlink" title="（2）设定SetUID的方法"></a><strong>（2）设定SetUID的方法</strong></h5><ul>
<li><strong>chmod 4755 文件名    # 4代表SUID</strong></li>
<li><strong>chmod u+s 文件名</strong></li>
</ul>
<h5 id="（3）取消SetUID的方法"><a href="#（3）取消SetUID的方法" class="headerlink" title="（3）取消SetUID的方法"></a><strong>（3）取消SetUID的方法</strong></h5><ul>
<li><strong>chmod 755 文件名</strong></li>
<li><strong>chmod u-s 文件名</strong></li>
</ul>
<h5 id="（4）危险的SetUID"><a href="#（4）危险的SetUID" class="headerlink" title="（4）危险的SetUID"></a><strong>（4）危险的SetUID</strong></h5><ul>
<li><strong>关键目录应严格控制写权限。比如“/”、“/usr”等</strong> </li>
<li><strong>用户的密码设置要严格遵守密码三原则</strong></li>
<li><strong>对系统中默认应该具有 SetUID 权限的文件作一列表，定时检查有没有这之外的文件被设置了 SetUID 权限</strong></li>
</ul>
<h4 id="8-2-2-SetGID"><a href="#8-2-2-SetGID" class="headerlink" title="8.2.2  SetGID"></a><strong>8.2.2  SetGID</strong></h4><h5 id="（1）SetGID-针对文件的作用"><a href="#（1）SetGID-针对文件的作用" class="headerlink" title="（1）SetGID 针对文件的作用"></a><strong>（1）SetGID 针对文件的作用</strong></h5><ul>
<li><p><strong>只有可执行的二进制程序才能设置 SGID 权限</strong></p>
</li>
<li><p><strong>命令执行者要对该程序拥有 x（执行）权限</strong> </p>
</li>
<li><p><strong>命令执行在执行程序的时候，组身份升级为该程序文件的属组</strong></p>
</li>
<li><p><strong>SetGID 权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效</strong></p>
<ul>
<li><p><strong>[root@localhost ~]# ll /usr/bin/locate</strong> </p>
<p><strong>-rwx–s–x 1 root slocate 35612 8 月 24 2010 /usr/bin/locate</strong> </p>
<p><strong>[root@localhost ~]# ll /var/lib/mlocate/mlocate.db</strong> </p>
<p><strong>-rw-r—– 1 root slocate 1838850 1 月 20 04:29 /var/lib/mlocate/mlocate.db</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（2）SetGID-针对目录的作用"><a href="#（2）SetGID-针对目录的作用" class="headerlink" title="（2）SetGID 针对目录的作用"></a><strong>（2）SetGID 针对目录的作用</strong></h5><ul>
<li><p><strong>普通用户必须对此目录拥有 r 和 x 权限，才能进入此目录</strong></p>
</li>
<li><p><strong>普通用户在此目录中的有效组会变成此目录的属组</strong></p>
</li>
<li><p><strong>若普通用户对此目录拥有 w 权限时，新建的文件的默认属组是这个目录</strong></p>
</li>
</ul>
<h5 id="（3）设定-SetGID"><a href="#（3）设定-SetGID" class="headerlink" title="（3）设定 SetGID"></a><strong>（3）设定 SetGID</strong></h5><ul>
<li><p><strong>chmod 2755 文件名    # 2 代表 SGID</strong></p>
</li>
<li><p><strong>chmod g+s 文件名</strong> </p>
</li>
</ul>
<h5 id="（4）-取消-SetGID"><a href="#（4）-取消-SetGID" class="headerlink" title="（4） 取消 SetGID"></a><strong>（4） 取消 SetGID</strong></h5><ul>
<li><p><strong>chmod 755 文件名</strong></p>
</li>
<li><p><strong>chmod g-s 文件名</strong></p>
</li>
</ul>
<h4 id="8-3-3-Sticky-BIT"><a href="#8-3-3-Sticky-BIT" class="headerlink" title="8.3.3 Sticky BIT"></a><strong>8.3.3 Sticky BIT</strong></h4><h5 id="（1）SBIT-粘着位作用"><a href="#（1）SBIT-粘着位作用" class="headerlink" title="（1）SBIT 粘着位作用"></a><strong>（1）SBIT 粘着位作用</strong></h5><ul>
<li><p><strong>粘着位目前只对目录有效</strong></p>
</li>
<li><p><strong>普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录拥有写入权限</strong> </p>
</li>
<li><p><strong>如果没有粘着位，因为普通用户拥有 w 权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。</strong></p>
</li>
<li><p><strong>一但赋予了粘着位，除了 root 可以删除所有文件，普通用户就算拥有 w 权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件 。</strong></p>
</li>
</ul>
<h5 id="（2）设置与取消粘着位"><a href="#（2）设置与取消粘着位" class="headerlink" title="（2）设置与取消粘着位"></a><strong>（2）设置与取消粘着位</strong></h5><ul>
<li><p><strong>设置粘着位</strong></p>
<ul>
<li><strong>chmod 1755 目录名    #1代表粘着位</strong></li>
<li><strong>chmod o+t 目录名</strong></li>
</ul>
</li>
<li><p><strong>取消粘着位</strong></p>
<ul>
<li><strong>chmod 777 目录名</strong></li>
<li><strong>chmod o-t 目录名</strong></li>
</ul>
</li>
</ul>
<h3 id="8-3-文件系统属性chattr权限"><a href="#8-3-文件系统属性chattr权限" class="headerlink" title="8.3 文件系统属性chattr权限"></a><strong>8.3 文件系统属性chattr权限</strong></h3><h5 id="（1）chattr命令格式"><a href="#（1）chattr命令格式" class="headerlink" title="（1）chattr命令格式"></a><strong>（1）chattr命令格式</strong></h5><ul>
<li><strong>chattr [+ - =] [选项] 文件名或者目录名</strong><br><strong>+：增加权限</strong><br><strong>-：删除权限</strong><br><strong>=：等于某权限</strong></li>
<li><strong>选项：</strong><ul>
<li><strong>i：如果对文件设置i属性，那么不允许对文件进行删除，改名，也不能添加和修改数据；如果对目录设置i属性,那么只能修改目录下文件的数据，但是不允许建立和删除文件</strong></li>
<li><strong>a：如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除或者修改数据；如果对目录设置a属性,那么只允许在目录中建立和修改文件，但是不允许删除文件</strong></li>
<li></li>
</ul>
</li>
</ul>
<h5 id="（2）查看文件系统属性"><a href="#（2）查看文件系统属性" class="headerlink" title="（2）查看文件系统属性"></a><strong>（2）查看文件系统属性</strong></h5><ul>
<li><strong>lsattr [选项] 文件名</strong><ul>
<li><strong>-a：显示所有文件和目录</strong></li>
<li><strong>-d：若目标是目录，仅列出目录本身的属性，而不是子文件的</strong></li>
</ul>
</li>
</ul>
<h3 id="8-4-系统命令sudo权限"><a href="#8-4-系统命令sudo权限" class="headerlink" title="8.4 系统命令sudo权限"></a><strong>8.4 系统命令sudo权限</strong></h3><h5 id="（1）sudo-权限"><a href="#（1）sudo-权限" class="headerlink" title="（1）sudo 权限"></a><strong>（1）sudo 权限</strong></h5><ul>
<li><strong>root 把本来只能超级用户执行的命令赋予普通用户执行。</strong></li>
<li><strong>sudo 的操作对象是系统命令</strong></li>
</ul>
<h5 id="（2）sudo-使用"><a href="#（2）sudo-使用" class="headerlink" title="（2）sudo 使用"></a><strong>（2）sudo 使用</strong></h5><ul>
<li><p><strong>visudo     #实际修改的是/etc/sudoers 文件</strong> </p>
</li>
<li><p>```shell<br>root ALL=(ALL) ALL<br>#用户名 被管理主机的地址=（可使用的身份） 授权命令（绝对路径）</p>
<p>%wheel ALL=(ALL) ALL<br>#%组名 被管理主机的地址=（可使用的身份） 授权命令（绝对路径）<br>#被管理主机的地址：本机IP或者ALL，限制的不是来源IP，而是访问IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **授权 sc 用户可以重启服务器**</span><br><span class="line"></span><br><span class="line">  ```shell</span><br><span class="line">  [root@localhost ~]# visudo </span><br><span class="line">  sc ALL= /sbin/shutdown –r now</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）其他"><a href="#（3）其他" class="headerlink" title="（3）其他"></a><strong>（3）其他</strong></h5><ul>
<li><p><strong>普通用户执行 sudo 赋予的命令</strong>    </p>
<p><strong>sudo [授权命令的绝对路径]</strong><br><strong>例子：</strong><br><strong>sudo /sbin/shutdown -r now</strong></p>
</li>
<li><p><strong>查看可用的sudo命令</strong></p>
<p><strong>sudo -l</strong> </p>
</li>
</ul>
<h2 id="第九章-文件系统管理"><a href="#第九章-文件系统管理" class="headerlink" title="第九章 文件系统管理"></a><strong>第九章 文件系统管理</strong></h2><h3 id="9-1-分区和文件系统"><a href="#9-1-分区和文件系统" class="headerlink" title="9.1 分区和文件系统"></a><strong>9.1 分区和文件系统</strong></h3><h5 id="（1）分区类型"><a href="#（1）分区类型" class="headerlink" title="（1）分区类型"></a><strong>（1）分区类型</strong></h5><ul>
<li><strong>主分区：总共最多只能分四个</strong></li>
<li><strong>扩展分区：只能有一个，也算作主分区的一种，也就是说主分区加扩展分区最多有四个。但是扩展分区不能存储数据和格式化，必须再划分成逻辑分区才能使用。</strong></li>
<li><strong>逻辑分区：逻辑分区是在扩展分区中划分的，如果是 IDE 硬盘，Linux 最多支持59 个逻辑分区，如果是 SCSI 硬盘 Linux 最多支持 11 个逻辑分区</strong></li>
</ul>
<h5 id="（2）分区的表示方法"><a href="#（2）分区的表示方法" class="headerlink" title="（2）分区的表示方法"></a><strong>（2）分区的表示方法</strong></h5><p>​    <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211223121525506.png" alt="image-20211223121525506"></strong></p>
<p>​    <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211223121533212.png" alt="image-20211223121533212"></strong></p>
<p>​    <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211223121538848.png" alt="image-20211223121538848"></strong></p>
<p>​    <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211223121543169.png" alt="image-20211223121543169"></strong></p>
<h5 id="（3）文件系统"><a href="#（3）文件系统" class="headerlink" title="（3）文件系统"></a><strong>（3）文件系统</strong></h5><ul>
<li><strong>ext2：是 ext 文件系统的升级版本，Red Hat Linux7.2 版本以前的系统默认都是ext2 文件系统。1993 年发布，最大支持 16TB 的分区和最大 2TB 的文件（1TB=1024GB=1024*1024KB）</strong></li>
<li><strong>ext3： ext3 文件系统是 ext2 文件系统的升级版本，最大的区别就是带日志功能，以在系统突然停止时提高文件系统的可靠性。支持最大 16TB 的分区和最大2TB 的文件</strong></li>
<li><strong>ext4：它是 ext3 文件系统的升级版。ext4 在性能、伸缩性和可靠性方面进行了大量改进。EXT4 的变化可以说是翻天覆地的，比如向下兼容 EXT3、最大 1EB 文件系统和 16TB 文件、无限数量子目录、Extents 连续数据块概念、多块分配、延迟分配、持久预分配、快速 FSCK、日志校验、无日志模式、在线碎片整理、inode 增强、默认启用 barrier 等。是 CentOS 6.3 的默认文件系统 （1EB=1024PB=1024*1024TB）</strong></li>
</ul>
<h3 id="9-2-文件系统常用命令"><a href="#9-2-文件系统常用命令" class="headerlink" title="9.2 文件系统常用命令"></a><strong>9.2 文件系统常用命令</strong></h3><h4 id="9-2-1-df-命令、du-命令、fsck-命令和-dump2fs-命令"><a href="#9-2-1-df-命令、du-命令、fsck-命令和-dump2fs-命令" class="headerlink" title="9.2.1 df 命令、du 命令、fsck 命令和 dump2fs 命令"></a><strong>9.2.1 df 命令、du 命令、fsck 命令和 dump2fs 命令</strong></h4><h5 id="（1）文件系统查看命令-df"><a href="#（1）文件系统查看命令-df" class="headerlink" title="（1）文件系统查看命令 df"></a><strong>（1）文件系统查看命令 df</strong></h5><ul>
<li><p> <strong>df [选项] [挂载点]</strong> </p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><p><strong>-a 显示所有的文件系统信息，包括特殊文件系统，如 /proc、/sysfs</strong> </p>
</li>
<li><p><strong>-h 使用习惯单位显示容量，如 KB，MB 或 GB 等</strong> </p>
</li>
<li><p><strong>-T 显示文件系统类型</strong> </p>
</li>
<li><p><strong>-m 以 MB 为单位显示容量</strong> </p>
</li>
<li><p><strong>-k 以 KB 为单位显示容量。默认就是以 KB 为单位</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（2）统计目录或文件大小-du"><a href="#（2）统计目录或文件大小-du" class="headerlink" title="（2）统计目录或文件大小 du"></a><strong>（2）统计目录或文件大小 du</strong></h5><ul>
<li><p><strong>du [选项] [目录或文件名]</strong> </p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><p><strong>-a 显示每个子文件的磁盘占用量。默认只统计 子目录的磁盘占用量</strong> </p>
</li>
<li><p><strong>-h 使用习惯单位显示磁盘占用量，如 KB，MB 或 GB 等</strong> </p>
</li>
<li><p><strong>-s 统计总占用量，而不列出子目录和子文件的 占用量</strong></p>
</li>
</ul>
</li>
<li><p><strong>du 命令和 df 命令的区别</strong></p>
<ul>
<li><p><strong>df 命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）</strong></p>
</li>
<li><p><strong>du 命令是面向文件的，只会计算文件或目录占用的空间</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（3）文件系统修复命令-fsck"><a href="#（3）文件系统修复命令-fsck" class="headerlink" title="（3）文件系统修复命令 fsck"></a><strong>（3）文件系统修复命令 fsck</strong></h5><ul>
<li><p> <strong>fsck [选项] 分区设备文件名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><p><strong>-a： 不用显示用户提示，自动修复文件系统</strong> </p>
</li>
<li><p><strong>-y： 自动修复。和-a 作用一致，不过有些文件系统只支 持-y</strong> </p>
</li>
</ul>
</li>
<li><p><strong>注意：知道就行，不必操作，有可能弄崩溃系统</strong></p>
</li>
</ul>
<h5 id="（4）显示磁盘状态命令-dumpe2fs"><a href="#（4）显示磁盘状态命令-dumpe2fs" class="headerlink" title="（4）显示磁盘状态命令 dumpe2fs"></a><strong>（4）显示磁盘状态命令 dumpe2fs</strong></h5><ul>
<li> <strong>dumpe2fs 分区设备文件名</strong></li>
</ul>
<h4 id="9-2-2-挂载命令"><a href="#9-2-2-挂载命令" class="headerlink" title="9.2.2 挂载命令"></a><strong>9.2.2 挂载命令</strong></h4><h5 id="（1）查询与自动挂载"><a href="#（1）查询与自动挂载" class="headerlink" title="（1）查询与自动挂载"></a><strong>（1）查询与自动挂载</strong></h5><ul>
<li><p><strong>mount [-l]</strong> </p>
<p><strong>#查询系统中已经挂载的设备，-l 会显示卷标名称</strong> </p>
</li>
<li><p><strong>mount –a</strong> </p>
<p><strong>#依据配置文件/etc/fstab 的内容，自动挂载</strong> </p>
</li>
</ul>
<h5 id="（2）挂载命令格式"><a href="#（2）挂载命令格式" class="headerlink" title="（2）挂载命令格式"></a><strong>（2）挂载命令格式</strong></h5><ul>
<li><strong>mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</strong></li>
<li><strong>-t 文件系统:加入文件系统类型来指定挂载的类型，如果文件系统是硬盘，分区就写ext3、ext4 ，如果是光盘，就写iso9660</strong></li>
<li><strong>-L 卷标名: 挂载指定卷标的分区，而不是按照设备文件名挂载</strong></li>
<li><strong>-o 特殊选项:可以指定挂载的额外选项</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>atime/noatime</strong></td>
<td><strong>更新访问时间/不更新访问时间。访问分区文件时，是否更新文件 的访问时间，默认为更新</strong></td>
</tr>
<tr>
<td><strong>async/sync</strong></td>
<td><strong>异步/同步，默认为异步</strong></td>
</tr>
<tr>
<td><strong>auto/noauto</strong></td>
<td><strong>自动/手动，mount –a命令执行时，是否会自动安装/etc/fstab文件内容挂载，默认为自动</strong></td>
</tr>
<tr>
<td><strong>defaults</strong></td>
<td><strong>定义默认值，相当于rw,suid,dev,exec,auto,nouser,async这七个选项</strong></td>
</tr>
<tr>
<td><strong>exec/noexec</strong></td>
<td><strong>执行/不执行，设定是否允许在文件系统中执行可执行文件，默认 是exec允许</strong></td>
</tr>
<tr>
<td><strong>remount</strong></td>
<td><strong>重新挂载已经挂载的文件系统，一般用于指定修改特殊权限</strong></td>
</tr>
<tr>
<td><strong>rw/ro</strong></td>
<td><strong>读写/只读，文件系统挂载时，是否具有读写权限，默认是rw</strong></td>
</tr>
<tr>
<td><strong>suid/nosuid</strong></td>
<td><strong>具有/不具有SUID权限，设定文件系统是否具有SUID和SGID的权限，默认是具有</strong></td>
</tr>
<tr>
<td><strong>user/nouser</strong></td>
<td><strong>允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载 默认是不允许，只有root可以挂载分区</strong></td>
</tr>
<tr>
<td><strong>usrquota</strong></td>
<td><strong>写入代表文件系统支持用户磁盘配额，默认不支持</strong></td>
</tr>
<tr>
<td><strong>grpquota</strong></td>
<td><strong>写入代表文件系统支持组磁盘配额，默认不支持</strong></td>
</tr>
</tbody></table>
<p><strong>注意：针对的都是分区</strong></p>
<h4 id="9-2-3-挂载光盘与U盘"><a href="#9-2-3-挂载光盘与U盘" class="headerlink" title="9.2.3 挂载光盘与U盘"></a><strong>9.2.3 挂载光盘与U盘</strong></h4><h5 id="（1）挂载光盘"><a href="#（1）挂载光盘" class="headerlink" title="（1）挂载光盘"></a><strong>（1）挂载光盘</strong></h5><ul>
<li><p><strong>建立挂载点</strong></p>
<p><strong>mkdir /mnt/cdrom/</strong><br><strong>mount -t iso9660 /dev/cdrom /mnt/cdrom/</strong></p>
</li>
<li><p><strong>挂载光盘</strong></p>
<p><strong>mount /dev/sr0 /mnt/cdrom/</strong></p>
</li>
<li><p><strong>卸载命令</strong></p>
<p><strong>umount 设备文件名或挂载点</strong></p>
<p><strong>umount /mnt/cdrom</strong></p>
</li>
</ul>
<h5 id="（2）挂载U盘"><a href="#（2）挂载U盘" class="headerlink" title="（2）挂载U盘"></a><strong>（2）挂载U盘</strong></h5><ul>
<li><strong>fdisk –l    #查看U盘设备文件名</strong></li>
<li><strong>mount -t vfat /dev/sdb1 /mnt/usb/</strong></li>
<li><strong>卸载命令</strong><br><strong>umount 设备文件名或挂载点</strong></li>
</ul>
<h4 id="9-2-4-支持NTFS文件系统"><a href="#9-2-4-支持NTFS文件系统" class="headerlink" title="9.2.4 支持NTFS文件系统"></a><strong>9.2.4 支持NTFS文件系统</strong></h4><h5 id="（1）下载-NTFS-3G-插件"><a href="#（1）下载-NTFS-3G-插件" class="headerlink" title="（1）下载 NTFS-3G 插件"></a><strong>（1）下载 NTFS-3G 插件</strong></h5><p>​    <strong><a href="http://www.tuxera.com/community/ntfs-3g-">http://www.tuxera.com/community/ntfs-3g-</a> download/</strong> </p>
<h5 id="（2）安装-NTFS-3G"><a href="#（2）安装-NTFS-3G" class="headerlink" title="（2）安装 NTFS-3G"></a><strong>（2）安装 NTFS-3G</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -zxvf ntfs-3g_ntfsprogs-2013.1.13.tgz </span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cd ntfs-3g_ntfsprogs-2013.1.13 </span><br><span class="line"><span class="meta">#</span><span class="bash">进入解压目录</span></span><br><span class="line"></span><br><span class="line">[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# ./configure </span><br><span class="line"><span class="meta">#</span><span class="bash">编译器准备。没有指定安装目录，安装到默认位置中</span></span><br><span class="line"></span><br><span class="line">[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# make </span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line"></span><br><span class="line">[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# make install </span><br><span class="line"><span class="meta">#</span><span class="bash">编译安装</span></span><br></pre></td></tr></table></figure>



<h5 id="（3）-使用"><a href="#（3）-使用" class="headerlink" title="（3） 使用"></a><strong>（3） 使用</strong></h5><p>​    <strong>mount -t ntfs-3g 分区设备文件名 挂载点</strong></p>
<h3 id="9-3-fdisk分区"><a href="#9-3-fdisk分区" class="headerlink" title="9.3 fdisk分区"></a><strong>9.3 fdisk分区</strong></h3><h4 id="9-3-1-fdisk命令分区过程"><a href="#9-3-1-fdisk命令分区过程" class="headerlink" title="9.3.1 fdisk命令分区过程"></a><strong>9.3.1 fdisk命令分区过程</strong></h4><ul>
<li><p><strong>通过虚拟机加入新硬盘</strong></p>
<ul>
<li><strong>查看新硬盘</strong><br><strong>fdisk -l</strong></li>
</ul>
</li>
<li><p><strong>使用fdisk命令分区</strong><br><strong>fdisk /dev/sdb 后面不能加数字 因为此时硬盘还没有分区</strong><br><strong>通过交互进行分区，交互指令如下：</strong></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>a</strong></td>
<td><strong>设置可引导标记</strong></td>
</tr>
<tr>
<td><strong>b</strong></td>
<td><strong>编辑bsd磁盘标签</strong></td>
</tr>
<tr>
<td><strong>c</strong></td>
<td><strong>设置DOS操作系统兼容标记</strong></td>
</tr>
<tr>
<td><strong>d</strong></td>
<td><strong>删除一个分区</strong></td>
</tr>
<tr>
<td><strong>l</strong></td>
<td><strong>显示已知的文件系统类型。82为Linux swap分区，83为Linux分区</strong></td>
</tr>
<tr>
<td><strong>m</strong></td>
<td><strong>显示帮助菜单</strong></td>
</tr>
<tr>
<td><strong>n</strong></td>
<td><strong>新建分区</strong></td>
</tr>
<tr>
<td><strong>o</strong></td>
<td><strong>建立空白DOS分区表</strong></td>
</tr>
<tr>
<td><strong>p</strong></td>
<td><strong>显示分区列表</strong></td>
</tr>
<tr>
<td><strong>q</strong></td>
<td><strong>不保存退出</strong></td>
</tr>
<tr>
<td><strong>s</strong></td>
<td><strong>新建空白SUN磁盘标签</strong></td>
</tr>
<tr>
<td><strong>t</strong></td>
<td><strong>改变一个分区的系统ID</strong></td>
</tr>
<tr>
<td><strong>u</strong></td>
<td><strong>改变显示记录单位</strong></td>
</tr>
<tr>
<td><strong>v</strong></td>
<td><strong>验证分区表</strong></td>
</tr>
<tr>
<td><strong>w</strong></td>
<td><strong>保存退出</strong></td>
</tr>
<tr>
<td><strong>x</strong></td>
<td><strong>附加功能(仅专家)</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>重新读取分区表信息</strong></p>
<ul>
<li><strong>partprobe</strong></li>
</ul>
</li>
<li><p><strong>格式化分区</strong></p>
<ul>
<li><strong>mkfs -t ext4 /dev/sdb1</strong></li>
</ul>
</li>
<li><p><strong>建立挂载点并挂载</strong></p>
<ul>
<li><strong>mkdir /disk1</strong></li>
<li><strong>mkdir /disk5</strong></li>
<li><strong>mount /dev/sdb1 /disk1/</strong></li>
<li><strong>mount /dev/sdb5 /disk5/</strong></li>
</ul>
</li>
</ul>
<h4 id="9-3-2-分区自动挂载与fstab文件修复"><a href="#9-3-2-分区自动挂载与fstab文件修复" class="headerlink" title="9.3.2 分区自动挂载与fstab文件修复"></a><strong>9.3.2 分区自动挂载与fstab文件修复</strong></h4><ul>
<li><strong>上一节说的挂载操作在重启之后便会消失，每次重启都得重新挂载，使用我们需要把它写入系统挂载命令文件中，每次开机都会自动扫描挂载，使用/etc/fstab文件，将挂载信息写入文件</strong></li>
</ul>
<ul>
<li><p><strong>/etc/fstab文件</strong><br><strong>第一字段：分区设备文件名或UUID(硬盘通用唯一识别码)</strong><br><strong>第二字段：挂载点</strong><br><strong>第三字段:文件系统名称</strong><br><strong>第四字段:挂载参数</strong><br><strong>第五字段:指定分区是否被dump备份，0代表不备份，1 代表每天备份，2代表不定期备份</strong><br><strong>第六字段:指定分区是否被fsck检测，0代表不检测，其 他数字代表检测的优先级，那么当然1的优先级比2高</strong><br><strong>注意：在写入文件之后先不要着急重启，我们可以先用mount -a命令来实现系统自动重新挂载，如果出现错误会提示，不至于系统崩溃</strong></p>
</li>
<li><p><strong>/etc/fstab文件修复</strong><br><strong>如果一旦写错了，出现了报错，可以在开机显示之后出现一个让你输入root用户密码的界面，再输入密码之后，可以使用vim /etc/fstab进入fstab文件修改错误，如果出现文件只有只读权限，不能修改，强制保存也不行，退出文件输入命令：mount -o remount,rw / ，重新把根分区挂载读写权限，就可以保存了，而且只能在根分区没有错误，在本机登陆，不能使用服务器或者远程连接的情况下才能修复。</strong></p>
</li>
</ul>
<h3 id="9-4-新建swap分区"><a href="#9-4-新建swap分区" class="headerlink" title="9.4 新建swap分区"></a><strong>9.4 新建swap分区</strong></h3><ul>
<li><strong>swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。也就是说，当内存不够用时，我们使用 swap 分区来临时顶替。这种“拆东墙，补西墙”的方式应用于几乎所有的操作系统中。</strong></li>
</ul>
<ul>
<li><p><strong>free命令</strong></p>
<ul>
<li><strong>free 查看内存与swap分区使用状况</strong></li>
<li><strong>-m：按MB字节显示</strong></li>
</ul>
</li>
<li><p><strong>缓存与缓冲：</strong></p>
<ul>
<li><strong>cached(缓存):是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程</strong></li>
<li><strong>buffer(缓冲):是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘， 减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程</strong></li>
</ul>
</li>
<li><p><strong>新建swap分区</strong></p>
<p><strong>fdisk /dev/sdb</strong><br><strong>进行交互式操作</strong><br><strong>别忘记把分区ID改为82 ，记得保存，然后重启</strong></p>
</li>
<li><p><strong>格式化</strong><br><strong>分区完之后需要格式化</strong><br><strong>mkswap /dev/sdb1 这里不能使用mkfs进行格式化</strong></p>
</li>
</ul>
<ul>
<li><strong>加入swap分区</strong><br><strong>swapon /dev/sdb1 加入swap分区</strong></li>
</ul>
<ul>
<li><strong>如果不想用了使用以下命令取消：</strong><br><strong>swapoff /dev/sdb1 取消swap分区</strong></li>
</ul>
<ul>
<li><strong>swap分区开机自动挂载</strong><br><strong>vi /etc/fstab</strong><br><strong>/dev/sdb1 swap swap defaults 0 0</strong><br><strong>注意：swap前面没有/，他不是根分区下的</strong><br><strong>修改之后使用mount -a 命令来检测错误</strong></li>
</ul>
<h2 id="第十章-Shell基础"><a href="#第十章-Shell基础" class="headerlink" title="第十章 Shell基础"></a><strong>第十章 Shell基础</strong></h2><h3 id="10-1-Shell概述"><a href="#10-1-Shell概述" class="headerlink" title="10.1 Shell概述"></a><strong>10.1 Shell概述</strong></h3><h4 id="10-1-1-Shell是什么"><a href="#10-1-1-Shell是什么" class="headerlink" title="10.1.1 Shell是什么"></a><strong>10.1.1 Shell是什么</strong></h4><ul>
<li><p><strong>Shell是一个<font color="orange">命令行解释器</font>，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来 启动、挂起、停止甚至是编写一些程序。</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210721142803916.png" alt="image-20210721142803916" style="zoom:50%;"></strong></p>
</li>
<li><p><strong>Shell还是一个功能相当强大的<font color="orange">编程语言</font>， 易编写，易调试，灵活性较强。Shell是解释执行的<font color="orange">脚本语言</font>，在Shell中可以直接调用Linux系统命令。</strong></p>
</li>
</ul>
<h4 id="10-1-2-Shell的分类"><a href="#10-1-2-Shell的分类" class="headerlink" title="10.1.2 Shell的分类"></a><strong>10.1.2 Shell的分类</strong></h4><ul>
<li><p><strong><font color="orange">Bourne Shell</font>:从1979起Unix就开始使用 Bourne Shell，Bourne Shell的主文件名为 sh。</strong></p>
</li>
<li><p><strong><font color="orange">C Shell</font>: C Shell主要在BSD版的Unix系 统中使用，其语法和C语言相类似而得名</strong></p>
<p><strong>Shell的两种主要语法类型有Bourne和C， 这两种语法彼此不兼容。</strong></p>
<p><strong>Bourne家族主要 包括sh、ksh、Bash、psh、zsh;</strong></p>
<p><strong>C家族主 要包括:csh、tcsh</strong></p>
<p><strong>Bash: Bash与sh兼容，现在使用的Linux 就是使用Bash作为<font color="orange">用户的基本Shell</font>。</strong></p>
</li>
</ul>
<h4 id="10-1-3-Linux支持的Shell"><a href="#10-1-3-Linux支持的Shell" class="headerlink" title="10.1.3 Linux支持的Shell"></a><strong>10.1.3 Linux支持的Shell</strong></h4><p>  <strong>/etc/shells</strong><br>  <strong>会显示：/bin/sh、/bin/bash、/sbin/nologin、/bin/tcsh、/bin/csh</strong><br>  <strong>都是Linux支持的Shell</strong></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ cat /etc/shells</span><br><span class="line"><span class="meta">#</span><span class="bash"> Pathnames of valid login shells.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See shells(5) <span class="keyword">for</span> details.</span></span><br><span class="line"></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/bin/zsh</span><br><span class="line">/usr/bin/git-shell</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-2-Shell脚本的执行方式"><a href="#10-2-Shell脚本的执行方式" class="headerlink" title="10.2 Shell脚本的执行方式"></a><strong>10.2 Shell脚本的执行方式</strong></h3><h4 id="10-2-1-echo-输出命令"><a href="#10-2-1-echo-输出命令" class="headerlink" title="10.2.1 echo 输出命令"></a><strong>10.2.1 <font color="red">echo </font>输出命令</strong></h4><ul>
<li><p><strong>#echo [选项] [输出内容]</strong> </p>
</li>
<li><p><strong><font color="orange">-e</font>: 支持反斜线控制的转义字符</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>控制字符</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">*<em><strong>*</strong></em></td>
<td align="center"><strong>输出\本身</strong></td>
</tr>
<tr>
<td align="center"><strong>\a</strong></td>
<td align="center"><strong>输出警告音</strong></td>
</tr>
<tr>
<td align="center"><strong>\b</strong></td>
<td align="center"><strong>退格键，也就是向左删除键</strong></td>
</tr>
<tr>
<td align="center"><strong>\c</strong></td>
<td align="center"><strong>取消输出行末的换行符。和“-n”选项一致</strong></td>
</tr>
<tr>
<td align="center"><strong>\e</strong></td>
<td align="center"><strong>ESCAPE键</strong></td>
</tr>
<tr>
<td align="center"><strong>\f</strong></td>
<td align="center"><strong>换页符</strong></td>
</tr>
<tr>
<td align="center"><strong>\n</strong></td>
<td align="center"><strong>换行符</strong></td>
</tr>
<tr>
<td align="center"><strong>\r</strong></td>
<td align="center"><strong>回车键</strong></td>
</tr>
<tr>
<td align="center"><strong>\t</strong></td>
<td align="center"><strong>制表符，也就是Tab键</strong></td>
</tr>
<tr>
<td align="center"><strong>\v</strong></td>
<td align="center"><strong>垂直制表符</strong></td>
</tr>
<tr>
<td align="center"><strong>\0nnn</strong></td>
<td align="center"><strong>按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数</strong></td>
</tr>
<tr>
<td align="center"><strong>\xhh</strong></td>
<td align="center"><strong>按照十六进制ASCII码表输出字符。其中hh是两位十六进制数</strong></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>例子</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">\b退格删除左侧字符$ <span class="built_in">echo</span> -e <span class="string">&#x27;ab\bc&#x27;</span>ac<span class="comment">#\t制表符 \n换行符$ echo -e &#x27;a\tb\tc\nd\te\tf&#x27;a	b	cd	e	f#\x按照十六进制ASCII码表输出字符$ echo -e &#x27;\x61\t\x62\t\x63&#x27;a	b	c$ echo -e &#x27;\e[1;31m abcd \e[0m&#x27; abcd #因为\e[1; 表示开启颜色区别 \e[0m 表示结束颜色区别 31m表示红色 还有其他：#30m=黑色，31m=红色，32m=绿色，33m=黄色，34m=蓝色，35m=洋红，36m=青色，#37m=白色</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="10-2-2-第一个脚本"><a href="#10-2-2-第一个脚本" class="headerlink" title="10.2.2 第一个脚本"></a><strong>10.2.2 第一个脚本</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~$ ls公共  模板  视频  图片  文档  下载  音乐  桌面$ <span class="built_in">cd</span> 文档$ mkdir 脚本练习$ <span class="built_in">cd</span> 脚本练习$ vim hello.sh$ sh hello.shWelcome to linux world!hhh</span></span><br></pre></td></tr></table></figure>


<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash#This is my first program#Author:zlxecho -e &#x27;Welcome to linux world!\nhhh&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：在这一段脚本中，#!/bin/Bash这一句是个例外，他并不是注释，是标识，说明以下语句是Shell脚本，解释器是/bin/bash</strong></p>
<h4 id="10-2-3-执行脚本"><a href="#10-2-3-执行脚本" class="headerlink" title="10.2.3 执行脚本"></a><strong>10.2.3 执行脚本</strong></h4><ul>
<li><p><strong>赋予执行权限，直接运行</strong></p>
<ul>
<li><strong>chmod 755 hello.sh</strong></li>
<li><strong>./hello.sh</strong></li>
</ul>
</li>
<li><p><strong>通过Bash调用执行脚本</strong></p>
<ul>
<li><strong>bash hello.sh</strong></li>
<li><strong>或 sh hello.sh  (不需要执行权限就可以执行)</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ ./hello.shbash: ./hello.sh: 权限不够[zlx@zlx-vmwarevirtualplatform 脚本练习]$ chmod 755 hello.sh[zlx@zlx-vmwarevirtualplatform 脚本练习]$ ./hello.shWelcome to linux world!hh[zlx@zlx-vmwarevirtualplatform 脚本练习]$ sh hello.shWelcome to linux world!hh</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-3-Bash的基本功能"><a href="#10-3-Bash的基本功能" class="headerlink" title="10.3 Bash的基本功能"></a><strong>10.3 Bash的基本功能</strong></h3><h4 id="10-3-1-历史命令history与命令补全"><a href="#10-3-1-历史命令history与命令补全" class="headerlink" title="10.3.1 历史命令history与命令补全"></a><strong>10.3.1 历史命令<font color="red">history</font>与命令补全</strong></h4><ul>
<li><p><strong>历史命令</strong></p>
<ul>
<li><p><strong>history [选项] [历史命令保存文件]</strong> </p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><p><strong>-c： 清空历史命令</strong> </p>
</li>
<li><p><strong>-w： 把缓存中的历史命令写入历史命令保存文件 <font color="orange">~/.bash_history </font></strong></p>
<p><strong>历史命令默认会保存 1000 条,可以在环境变量配置文件/etc/profile 中进行修改</strong></p>
</li>
</ul>
</li>
<li><p><strong>历史命令的调用</strong></p>
<ul>
<li><p><strong>使用<font color="orange">上、下箭头</font>调用以前的历史命令</strong></p>
</li>
<li><p><strong>使用“<font color="orange">!n</font>”重复执行第 n 条历史命令</strong></p>
</li>
<li><p><strong>使用“<font color="orange">!!</font>”重复执行上一条命令</strong></p>
</li>
<li><p><strong>使用“<font color="orange">!字串</font>”重复执行最后一条以该字串开头的命令</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ ls公共  模板  视频  图片  文档  下载  音乐  桌面[zlx@zlx-vmwarevirtualplatform ~]$ !!ls公共  模板  视频  图片  文档  下载  音乐  桌面[zlx@zlx-vmwarevirtualplatform ~]$ !lls公共  模板  视频  图片  文档  下载  音乐  桌面</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>命令与文件补全</strong><ul>
<li> <strong>在 Bash 中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或文件时，按“Tab”键就会自动进行补全</strong></li>
</ul>
</li>
</ul>
<h4 id="10-3-2-命令别名alias与常用快捷键"><a href="#10-3-2-命令别名alias与常用快捷键" class="headerlink" title="10.3.2 命令别名alias与常用快捷键"></a><strong>10.3.2 命令别名<font color="red">alias</font>与常用快捷键</strong></h4><ul>
<li><p><strong>命令别名</strong></p>
<ul>
<li><strong>alias 别名=’原命令’         #设定命令别名</strong> </li>
<li><strong>alias        #查询命令别名</strong> </li>
</ul>
</li>
<li><p><strong>命令执行时顺序</strong></p>
<ul>
<li><strong>1 第一顺位执行用<font color="orange">绝对路径或相对路径</font>执行的命令。</strong></li>
<li><strong>2 第二顺位执行<font color="orange">别名</font>。</strong></li>
<li><strong>3 第三顺位执行 <font color="orange">Bash</font>font&gt; 的内部命令。</strong></li>
<li><strong>4 第四顺位执行按照<font color="orange">$PATH 环境变量定义的目录查找顺序</font>找到的第一个命令。</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ alias vi=&#x27;vim&#x27;[zlx@zlx-vmwarevirtualplatform ~]$ aliasalias cp=&#x27;cp -i&#x27;alias df=&#x27;df -h&#x27;alias egrep=&#x27;egrep --colour=auto&#x27;alias fgrep=&#x27;fgrep --colour=auto&#x27;alias free=&#x27;free -m&#x27;alias grep=&#x27;grep --colour=auto&#x27;alias home=&#x27;cd ~&#x27;alias ls=&#x27;ls --color=auto&#x27;alias more=&#x27;less&#x27;alias np=&#x27;nano -w PKGBUILD&#x27;alias vi=&#x27;vim&#x27;#再执行vi时不会调用PATH目录中命令，因为别名的优先级比PATH高#输出系统环境变量定义的目录[zlx@zlx-vmwarevirtualplatform ~]$ echo $PATH/home/zlx/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/var/lib/snapd/snap/bin#查询某条命令所在目录[zlx@zlx-vmwarevirtualplatform ~]$ whereis lsls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz[zlx@zlx-vmwarevirtualplatform ~]$ whereis vivi: /usr/bin/vi /usr/share/man/man1/vi.1.gz /usr/share/man/man1p/vi.1p.gz[zlx@zlx-vmwarevirtualplatform ~]$ whereis vimvim: /usr/bin/vim /usr/share/vim /usr/share/man/man1/vim.1.gz</span><br></pre></td></tr></table></figure></li>
<li><p><strong>让别名永久生效</strong></p>
<ul>
<li><strong>vim /root/.bashrc</strong></li>
</ul>
</li>
<li><p><strong>删除别名</strong></p>
<ul>
<li><strong>unalias 别名</strong></li>
</ul>
</li>
<li><p><strong>Bash 常用快捷键</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>快捷键</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+a</font></strong></td>
<td align="center"><strong>把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移 动到命令行开头时使用。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+e</font></strong></td>
<td align="center"><strong>把光标移动到命令行结尾。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+c</font></strong></td>
<td align="center"><strong>强制终止当前的命令。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+l</font></strong></td>
<td align="center"><strong>清屏，相当于clear命令。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+u</font></strong></td>
<td align="center"><strong>删除或<font color="red">剪切</font>光标之<font color="red">前</font>的命令。我输入了一行很长的命令，不用使用退 格键一个一个字符的删除，使用这个快捷键会更加方便</strong></td>
</tr>
<tr>
<td align="center"><strong>ctrl+k</strong></td>
<td align="center"><strong>删除或剪切光标之<font color="red">后</font>的内容。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+y</font></strong></td>
<td align="center"><strong><font color="red">粘贴</font> ctrl+U或ctrl+K剪切的内容。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+r</font></strong></td>
<td align="center"><strong>在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入 搜索内容，就会从历史命令中搜索。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+d</font></strong></td>
<td align="center"><strong>退出当前终端。</strong></td>
</tr>
<tr>
<td align="center"><strong>ctrl+z</strong></td>
<td align="center"><strong>暂停，并放入后台。这个快捷键牵扯工作管理的内容，我们在系统管 理章节详细介绍。</strong></td>
</tr>
<tr>
<td align="center"><strong>ctrl+s</strong></td>
<td align="center"><strong>暂停屏幕输出。</strong></td>
</tr>
<tr>
<td align="center"><strong>ctrl+q</strong></td>
<td align="center"><strong>恢复屏幕输出。</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="10-3-3-输入输出重定向"><a href="#10-3-3-输入输出重定向" class="headerlink" title="10.3.3 输入输出重定向"></a><strong>10.3.3 输入输出重定向</strong></h4><ul>
<li><p><strong>标准输入输出</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210722132956166.png" alt="image-20210722132956166"></strong></p>
</li>
<li><p><strong><font color="red">输出重定向&gt;&gt;</font></strong></p>
<p><strong>就是改变输出方向，比如由屏幕输出到文件，非常有用</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>符号</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>标准输出重定向</strong></td>
<td><strong>命令 &gt; 文件</strong></td>
<td><strong>以<font color="red">覆盖</font>的方式，把命令的正确输出输出到指定的文件或设备当中。</strong></td>
</tr>
<tr>
<td><strong>标准输出重定向</strong></td>
<td><strong>命令 &gt;&gt; 文件</strong></td>
<td><strong>以<font color="red">追加</font>的方式，把命令的正确输出输出到指定的文 件或设备当中。</strong></td>
</tr>
<tr>
<td><strong>标准错误输出重定向</strong></td>
<td><strong>错误命令 2&gt;文件</strong></td>
<td><strong>以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。</strong></td>
</tr>
<tr>
<td><strong>标准错误输出重定向</strong></td>
<td><strong>错误命令 2&gt;&gt;文件</strong></td>
<td><strong>以追加的方式，把命令的错误输出输出到指定的文件或设备当中。</strong></td>
</tr>
</tbody></table>
<p><strong>tip:在输入报错文件中 2和&gt;&gt;必选<font color="red">连着写</font>,标准错误输出不常用</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>符号</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>正确输出和错误输出同时保存</strong></td>
<td><strong>命令 &gt; 文件 2&gt;&amp;1</strong></td>
<td><strong>以覆盖的方式，把正确输出和错误输出都保存到同 一个文件当中。</strong></td>
</tr>
<tr>
<td><strong>正确输出和错误输出同时保存</strong></td>
<td><strong>命令 &gt;&gt; 文件 2&gt;&amp;1</strong></td>
<td><strong>以追加的方式，把正确输出和错误输出都保存到同 一个文件当中。</strong></td>
</tr>
<tr>
<td><strong>正确输出和错误输出同时保存</strong></td>
<td><strong>命令 &amp;&gt; 文件</strong></td>
<td><strong>以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中</strong></td>
</tr>
<tr>
<td><strong>正确输出和错误输出同时保存</strong></td>
<td><strong>命令 &amp;&gt;&gt; 文件</strong></td>
<td><strong>以追加的方式，把正确输出和错误输出都保存到同一个文件当中。</strong></td>
</tr>
<tr>
<td><strong>正确输出和错误输出同时保存</strong></td>
<td><strong>命令 &gt;&gt; 文件1 2&gt;&gt;文件2</strong></td>
<td><strong>把正确的输出追加到文件1中，把错误的输出追加到文件2中。</strong></td>
</tr>
</tbody></table>
<p><strong>tip:命令 &gt;&gt; 文件 2&gt;&amp;1 ，命令 &amp;&gt;&gt;文件 两种保存都一样，只不过是格式不同</strong><br><strong>有一个用法：</strong><br><strong>命令 &amp;&gt;/dev/unll 不管命令是否正确，直接丢人这个文件夹，不保存任何数据，在写shell脚本时有用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ ls &gt;&gt; ./文档/cdx[zlx@zlx-vmwarevirtualplatform ~]$ cat ./文档/cdx公共模板视频图片文档下载音乐桌面[zlx@zlx-vmwarevirtualplatform ~]$ lstbash: lst：未找到命令[zlx@zlx-vmwarevirtualplatform ~]$ lst 2&gt;&gt; ./文档/cdx[zlx@zlx-vmwarevirtualplatform ~]$ cat ./文档/cdx公共模板视频图片文档下载音乐桌面bash: lst：未找到命令[zlx@zlx-vmwarevirtualplatform ~]$ ls &amp;&gt;&gt; ./文档/cdx1[zlx@zlx-vmwarevirtualplatform ~]$ lst &amp;&gt;&gt; ./文档/cdx1[zlx@zlx-vmwarevirtualplatform ~]$ cat ./文档/cdx1公共模板视频图片文档下载音乐桌面bash: lst：未找到命令</span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="red">输入重定向WC</font></strong></p>
<p><strong>不通过键盘输入，通过文件输入，在实际中用的不多，用在给源码包打补丁</strong></p>
<ul>
<li><p><strong>wc [选项] [文件名] :统计某个文件输入的行数、单词数、字节数</strong></p>
</li>
<li><p><strong>选项</strong></p>
<ul>
<li><strong>-c 统计字节数</strong></li>
<li><strong>-w 统计单词数</strong></li>
<li><strong>-l 统计行数</strong></li>
</ul>
</li>
<li><p><strong>用法：</strong><br><strong>命令 <font color="red">&lt; 文件</font> ：把文件作为命令的输入</strong><br><strong>命令<font color="red"> &lt;&lt; 标识符 内容  标识符</font>：把标识符之间内容作为命令的输入</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">统计行数、单词数、字符数[zlx@zlx-vmwarevirtualplatform ~]$ wcjdign ingjgidn ingd jiijijis9e      3       6      33<span class="comment">#统计输入文件[zlx@zlx-vmwarevirtualplatform ~]$ wc &lt; ./文档/cdx 9 10 84#统计输入文件行数[zlx@zlx-vmwarevirtualplatform ~]$ wc -l &lt; ./文档/cdx9#以quit为标识符，统计内容[zlx@zlx-vmwarevirtualplatform ~]$ wc &lt;&lt; quit&gt; jdig&gt; jidigj jidg&gt; jig&gt; quit      3       4      21</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="10-3-4-多命令顺序执行与管道符"><a href="#10-3-4-多命令顺序执行与管道符" class="headerlink" title="10.3.4 多命令顺序执行与管道符"></a><strong>10.3.4 多命令顺序执行与管道符</strong></h4><ul>
<li><strong>多命令顺序执行</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>多命令执行符</strong></th>
<th align="center"><strong>格式</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>；</strong></td>
<td align="center"><strong>命令1 ; 命令2</strong></td>
<td align="center"><strong>多个命令顺序执行，命令之间没有任何逻辑联系，就算第一条报错，第二条也会执行</strong></td>
</tr>
<tr>
<td align="center"><strong>&amp;&amp;</strong></td>
<td align="center"><strong>命令1 &amp;&amp; 命令2</strong></td>
<td align="center"><strong>逻辑与当命令1正确执行，则命令2才会执行 当命令1执行不正确，则命令2不会执行</strong></td>
</tr>
<tr>
<td align="center"><strong>||</strong></td>
<td align="center"><strong>命令1 || 命令2</strong></td>
<td align="center"><strong>逻辑或当命令1 执行不正确，则命令2才会执行 当命令1正确执行，则命令2不会执行</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>例子： [root@localhost ~]# ls ; date ; cd /user ; pwd</strong></li>
</ul>
<ul>
<li><p><strong>磁盘文件复制：</strong></p>
<ul>
<li><strong>dd if=输入文件 of=输出文件 bs=字节数 count=个数</strong> </li>
<li><strong>选项：</strong><ul>
<li><strong>if=输入文件  指定源文件或源设备</strong> </li>
<li><strong>of=输出文件  指定目标文件或目标设备</strong> </li>
<li><strong>bs=字节数  指定一次输入/输出多少字节，即把这些字节看做一个数据块</strong></li>
<li><strong>count=个数  指定输入/输出多少个数据块</strong> </li>
</ul>
</li>
<li><strong>例子：</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000 ; date</span><br></pre></td></tr></table></figure>

<p><strong>[root@localhost ~]# ls anaconda-ks.cfg &amp;&amp; echo yes</strong> </p>
<p><strong>[root@localhost ~]# ls /root/test || echo “no</strong> </p>
<p><strong>[root@localhost ~]# 命令 &amp;&amp; echo yes || echo no</strong></p>
</li>
</ul>
<ul>
<li><p><strong>管道符</strong></p>
<ul>
<li><strong>命令格式：命令 1 | 命令 2</strong> </li>
<li><strong>命令 1 的正确输出作为命令 2 的操作对象</strong></li>
<li><strong>例子：</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll -a /etc/ | more [root@localhost ~]# netstat -an | grep &quot;ESTABLISHED&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>[root@localhost ~]# grep [选项] “搜索内容” 文件名</strong></li>
<li><strong>选项：</strong> <ul>
<li><strong>-i： 忽略大小写</strong> </li>
<li><strong>-n： 输出行号</strong> </li>
<li><strong>-v： 反向查找</strong> </li>
<li><strong>–color=auto 搜索出的关键字用颜色显示</strong></li>
</ul>
</li>
</ul>
<h4 id="10-3-5-通配符与其他特殊符号"><a href="#10-3-5-通配符与其他特殊符号" class="headerlink" title="10.3.5 通配符与其他特殊符号"></a><strong>10.3.5 通配符与其他特殊符号</strong></h4><ul>
<li><p><strong>通配符</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210802142430007.png" alt="image-20210802142430007"></strong></p>
</li>
<li><p><strong>Bash中其他特殊符号</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210802142441259.png" alt="image-20210802142441259"></strong></p>
</li>
</ul>
<h3 id="10-4-Bash的变量"><a href="#10-4-Bash的变量" class="headerlink" title="10.4 Bash的变量"></a><strong>10.4 Bash的变量</strong></h3><h4 id="10-4-1-用户自定义的变量"><a href="#10-4-1-用户自定义的变量" class="headerlink" title="10.4.1 用户自定义的变量"></a><strong>10.4.1 用户自定义的变量</strong></h4><h5 id="（1）什么是变量："><a href="#（1）什么是变量：" class="headerlink" title="（1）什么是变量："></a><strong>（1）什么是变量：</strong></h5><p>​        <strong>变量是计算机内存的单元，其中存放的值可以改变。当Shell脚本需要保存一些信息 时，如一个文件名或是一个数字，就把它 存放在一个变量中。每个变量有一个名字 ，所以很容易引用它。使用变量可以保存 有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息。</strong></p>
<h5 id="（2）变量设置规则："><a href="#（2）变量设置规则：" class="headerlink" title="（2）变量设置规则："></a><strong>（2）变量设置规则：</strong></h5><ul>
<li><p><strong>变量名称可以由字母、数字和下划线组成 ，但是不能以数字开头。如果变量名是 “2name”则是错误的。</strong></p>
</li>
<li><p><strong>在Bash中，变量的默认类型都是字符串型 ，如果要进行数值运算，则必需指定变量类型为数值型。</strong></p>
</li>
<li><p><strong>默认变量类型全都是字符串型，和其他语言不太一样</strong></p>
</li>
<li><p><strong>变量用等号连接值，等号左右两侧不能有空格。变量的值如果有空格，需要使用单引号或双引号包括。</strong></p>
</li>
<li><p><strong>在变量的值中，可以使用“\”转义符。</strong></p>
</li>
<li><p><strong>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 “$变量名”或用${变量名}包含。</strong></p>
</li>
<li><p><strong>如果是把命令的结果作为变量值赋予变量 ，则需要使用反引号或$()包含命令。</strong><br><strong>环境变量名建议大写，便于区分。</strong></p>
</li>
</ul>
<h5 id="（3）变量的分类："><a href="#（3）变量的分类：" class="headerlink" title="（3）变量的分类："></a><strong>（3）变量的分类：</strong></h5><ul>
<li><p><strong>用户自定义变量（本地变量）</strong></p>
</li>
<li><p><strong>环境变量:这种变量中主要保存的是和系统操作环境相关的数据。</strong></p>
</li>
<li><p><strong>位置参数变量:这种变量主要是用来向脚本当 中传递参数或数据的，变量名不能自定义，变量作用是固定的。</strong></p>
</li>
<li><p><strong>预定义变量:是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</strong></p>
</li>
</ul>
<h5 id="（4）用户自定义变量"><a href="#（4）用户自定义变量" class="headerlink" title="（4）用户自定义变量"></a><strong>（4）用户自定义变量</strong></h5><ul>
<li><p>​    <strong>变量定义</strong><br><strong>​    例子：</strong><br><strong>​    name=“yang yang”</strong></p>
</li>
<li><p><strong>变量叠加</strong><br><strong>aa=123</strong><br><strong>aa=”$aa”456<br>aa=${aa}789</strong></p>
</li>
<li><p><strong>变量调用</strong><br><strong><font color="red">echo </font>$变量名</strong></p>
</li>
<li><p><strong>变量查看</strong><br><strong><font color="red">set    </font>查看当前系统全部变量</strong></p>
</li>
<li><p><strong>变量删除</strong><br><strong><font color="red">unset </font>变量名</strong></p>
</li>
<li><p>```shell<br>[zlx@zlx-vmwarevirtualplatform 桌面]$ name=’zlx’[zlx@zlx-vmwarevirtualplatform 桌面]$ name=”$name”666[zlx@zlx-vmwarevirtualplatform 桌面]$ name=${name}777[zlx@zlx-vmwarevirtualplatform 桌面]$ echo namename[zlx@zlx-vmwarevirtualplatform 桌面]$ echo $namezlx666777[zlx@zlx-vmwarevirtualplatform 桌面]$ unset name</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### **10.4.2 环境变量 PATH PS1**</span><br><span class="line"></span><br><span class="line">##### **（1）环境变量：**</span><br><span class="line"></span><br><span class="line">​	**用户自定义变量只在当前的Shell中生效， 而环境变量会在当前Shell和这个Shell的所 有子Shell当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的Shell中生效**</span><br><span class="line"></span><br><span class="line">​	**&lt;font color=&#x27;red&#x27;&gt;pstree&lt;/font&gt;:以树结构显示进程**</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ pstreesystemd─┬─ModemManager───2*[&#123;ModemManager&#125;]        ├─NetworkManager───2*[&#123;NetworkManager&#125;]        ├─accounts-daemon───2*[&#123;accounts-daemon&#125;]        ├─avahi-daemon───avahi-daemon        ├─blueman-tray───2*[&#123;blueman-tray&#125;]        ├─bluetoothd		……</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）设置环境变量："><a href="#（2）设置环境变量：" class="headerlink" title="（2）设置环境变量："></a><strong>（2）设置环境变量：</strong></h5><ul>
<li><p><strong><font color="orange">申明变量</font>：export 变量名=变量值</strong> </p>
</li>
<li><p><strong><font color="orange">查询变量</font>：env</strong></p>
</li>
<li><p><strong><font color="orange">变量调用</font>：echo $变量名</strong> </p>
</li>
<li><p><strong><font color="orange">删除变量</font>：unset 变量名</strong></p>
</li>
<li><p><strong>pstree 树形显示进程数</strong><br><strong>没有这条命令可以执行以下命令下载：</strong><br><strong>yum -y install psmisc</strong><br><strong>yum provides /命令 查看没有的命令的安装包 配合yum -y install使用</strong></p>
</li>
</ul>
<h5 id="（3）系统常见环境变量"><a href="#（3）系统常见环境变量" class="headerlink" title="（3）系统常见环境变量"></a><strong>（3）系统常见环境变量</strong></h5><ul>
<li><p><strong><font color="red">PATH</font>:系统查找命令的路径</strong><br><strong>这便是输入命令之前不用输入绝对路径的根本原因，系统会提前在PATH环境变量里的所有路径中查询一遍有没有你输入的命令，找到之后直接执行；</strong></p>
</li>
<li><p><strong>如果你想直接执行shell脚本，不加绝对路径，直接写入PATH环境变量，使用叠加</strong><br><strong>例子：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PATH#PATH变量叠加PATH=&quot;$PATH&quot;:/root/sh #此后，/root/sh路径里面的执行文件都可以在任意目录下直接执行，不过是临时生效</span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="red">PS1</font>：定义<font color="orange">系统提示符</font>的变量 用来改[root@localhost ~]# 这个显示</strong></p>
<ul>
<li><p><strong>\d:显示日期，格式为“星期 月 日”</strong></p>
</li>
<li><p><strong>\h:显示简写主机名。如默认主机名“localhost”</strong></p>
</li>
<li><p><strong>\t:显示24小时制时间，格式为“HH:MM:SS”</strong></p>
</li>
<li><p><strong>\T:显示12小时制时间，格式为“HH:MM:SS”</strong></p>
</li>
<li><p><strong>\A:显示24小时制时间，格式为“HH:MM”</strong></p>
</li>
<li><p><strong>\u:显示当前用户名</strong></p>
</li>
<li><p><strong>\w:显示当前所在目录的完整名称</strong></p>
</li>
<li><p><strong>\W:显示当前所在目录的最后一个目录</strong></p>
</li>
<li><p><strong>#:执行的第几个命令</strong></p>
</li>
<li><p><strong>$:提示符。如果是root用户会显示提示符为“#”，如果是普通用户 会显示提示符为“$”</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ echo $PS1\[\033[01;32m\][\u@\h\[\033[01;37m\] \W\[\033[01;32m\]]\$\[\033[00m\][zlx@zlx-vmwarevirtualplatform 桌面]$ PS1=&#x27;[\u@\t\w]\$&#x27;[zlx@00:16:25~/桌面]$PS1=&#x27;[\u@\@ \h \# \W]\$&#x27;[zlx@12:16 上午 zlx-vmwarevirtualplatform 4 桌面]$PS1=&#x27;[\u@\h \W]$&#x27;[zlx@zlx-vmwarevirtualplatform 桌面]$</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="10-4-3-位置参数变量-n"><a href="#10-4-3-位置参数变量-n" class="headerlink" title="10.4.3 位置参数变量 $n $ $@ $#*"></a><em><em>10.4.3 位置参数变量 $n $</em> $@ $#</em>*</h4><ul>
<li><strong>位置参数变量</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>变量</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>$n</strong></td>
<td><strong>n为数字，$0代表命令本身，$1-9 代 表 第 一 到 第 九 个 参 数 ， 十 以 上 的 参 数 需 要 用 大 括 号 包 含 ，如{10}.</strong></td>
</tr>
<tr>
<td align="center"><strong>$</strong>*</td>
<td>*<em>这个变量代表命令行中所有的参数，$<em>把所有的参数看成一个整体</em></em></td>
</tr>
<tr>
<td align="center"><strong>$@</strong></td>
<td><strong>这个变量也代表命令行中所有的参数，不过 $@把每个参数区分对待</strong></td>
</tr>
<tr>
<td align="center"><strong>$#</strong></td>
<td><strong>这个变量代表命令行中所有参数的个数</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong><font color="red">$n</font> 的例子</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ cat sum.sh#!/bin/bashnum1=$1num2=$2sum=$(($num1+$num2))#变量sum的和是num1+num2echo $sum#打印变量sum的值[zlx@zlx-vmwarevirtualplatform 脚本练习]$ bash sum.sh 2 35</span><br></pre></td></tr></table></figure>



<ul>
<li><em><em><font color="red">S# S</font></em> S@ 的例子</em>*</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ cat showParam.sh #!/bin/bashecho &quot;A total of $# parameters&quot;#使用$#代表所有参数的个数echo &quot;The parameters is:$*&quot;#使用$*代表所有参数echo &quot;The parameters is:$@&quot;#使用$@也代表所有参数[zlx@zlx-vmwarevirtualplatform 脚本练习]$ bash showParam.sh 11 23 45 66A total of 4 parametersThe parameters is:11 23 45 66The parameters is:11 23 45 66</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>S*和S@ 的区别</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ cat diffParam.sh #!/bin/bash#$*中所有的参数看成一个整体，所以这个for循环只会循环一次for i in &quot;$*&quot; do	echo &quot;The parameter is:$i&quot;done#$@中所有的参数都看成是独立的，所以”$@“中有几个参数，就会循环几次x=1for i in &quot;$@&quot;do	echo &quot;The parameter$x is:$i&quot;	x=$(($x+1))done[zlx@zlx-vmwarevirtualplatform 脚本练习]$ bash diffParam.sh 12 34 56 The parameter is:12 34 56The parameter1 is:12The parameter2 is:34The parameter3 is:56</span><br></pre></td></tr></table></figure>



<h4 id="10-4-4-预定义的变量"><a href="#10-4-4-预定义的变量" class="headerlink" title="10.4.4 预定义的变量 $? $$ $!"></a><strong>10.4.4 预定义的变量 $? $$ $!</strong></h4><ul>
<li><strong>预定义变量</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>变量</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>$?</strong></td>
<td><strong>最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行;如果 这个变量的值为非0(具体是哪个数，由命令自己来决定)，则证明上一个命令执行不正确 了。</strong></td>
</tr>
<tr>
<td><strong>$$</strong></td>
<td><strong>当前进程的进程号(PID)</strong></td>
</tr>
<tr>
<td><strong>$!</strong></td>
<td><strong>后台运行的最后一个进程的进程号(PID)</strong></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>例子：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ cat showPID.sh#!/bin/bashecho “The current process is $$”#输出当前进程的PID。#这个PID就是showPID.sh这个脚本执行时，生成的进程的PIDfind ./ -name hello.sh &amp;#使用find命令在root目录下查找hello.sh文件#符号&amp;的意思是把命令放入后台执行，工作管理在系统管理章节会详细介绍echo &quot;The last one Daemon process is $!&quot;[zlx@zlx-vmwarevirtualplatform 脚本练习]$ bash showPID.sh“The current process is 2798”The last one Daemon process is 2799[zlx@zlx-vmwarevirtualplatform 脚本练习]$ ./hello.sh[zlx@zlx-vmwarevirtualplatform 脚本练习]$ echo $?0</span><br></pre></td></tr></table></figure></li>
<li><p><strong>接受键盘输入</strong><br><strong>read [选项] [变量名]</strong></p>
<ul>
<li><strong>-p “提示信息”：在等待read输入时，输出提示信息</strong></li>
<li><strong>-t 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间</strong></li>
<li><strong>-n 字符数：read命令只接受指定的字符数，就会执行</strong></li>
<li><strong>-s: 隐藏输入的数据，适用于机密信息的输入</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ cat keyboard.sh #!/bin/bash #Author: shenchao （E-mail: shenchao@lampbrother.net）read -t 30 -p &quot;Please input your name: &quot; name #提示“请输入姓名”并等待 30 秒，把用户的输入保存入变量 name 中echo &quot;Name is $name &quot; read -s -t 30 -p &quot;Please enter your age: &quot; age #年龄是隐私，所以我们用“-s”选项隐藏输入echo -e &quot;\n&quot; echo &quot;Age is $age &quot; read -n 1 -t 30 -p &quot;Please select your gender[M/F]: &quot; gender#使用“-n 1”选项只接收一个输入字符就会执行（都不用输入回车）echo -e &quot;\n&quot; echo &quot;Sex is $gender&quot;[zlx@zlx-vmwarevirtualplatform 脚本练习]$ bash keyboard.sh Please input your name: zlxName is zlx Please enter your age: Age is 18 Please select your gender[M/F]: MSex is M</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-5-Bash的运算符"><a href="#10-5-Bash的运算符" class="headerlink" title="10.5 Bash的运算符"></a><strong>10.5 Bash的运算符</strong></h3><h4 id="10-5-1-数值运算与运算符"><a href="#10-5-1-数值运算与运算符" class="headerlink" title="10.5.1 数值运算与运算符"></a><strong>10.5.1 数值运算与运算符</strong></h4><h5 id="（1）declare-声明变量类型"><a href="#（1）declare-声明变量类型" class="headerlink" title="（1）declare 声明变量类型"></a><strong>（1）<font color="red">declare </font>声明变量类型</strong></h5><ul>
<li><p><strong><font color="orange">declare [+/-] [选项] 变量名</font></strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-： 给变量设定类型属性</strong> </li>
<li><strong>+：取消变量的类型属性</strong> </li>
<li><strong>-i：将变量声明为整数型（integer）</strong> </li>
<li><strong>-x：将变量声明为环境变量</strong> </li>
<li><strong>-p：显示指定变量的被声明的类型</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）数值运算"><a href="#（2）数值运算" class="headerlink" title="（2）数值运算"></a><strong>（2）数值运算</strong></h5><ul>
<li><p><strong>方法1：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> aa=11$ bb=22$ <span class="built_in">declare</span> -i cc=<span class="variable">$aa</span>+$bb$ <span class="built_in">echo</span> <span class="variable">$cc33</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>方法2：<font color="orange">expr </font>或 let 数值运算工具</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> aa=11$ bb=10$ dd=$(expr <span class="variable">$aa</span> + <span class="variable">$bb</span>)<span class="comment"># dd的值是aa和bb的和。注意“+”号左右两侧必须有空格。let和expr一样$ echo $dd21</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>方法3：<font color="orange">$((运算式)) 或 $[运算式]</font>（<font color="red">推荐</font>）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> aa=10$ bb=12$ ee=$((<span class="variable">$aa</span>+<span class="variable">$bb</span>))$ <span class="built_in">echo</span> $ee22$ ff=$[<span class="variable">$aa</span>+<span class="variable">$bb</span>+<span class="variable">$ee</span>]$ <span class="built_in">echo</span> <span class="variable">$ff44</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）运算符优先级"><a href="#（3）运算符优先级" class="headerlink" title="（3）运算符优先级"></a><strong>（3）运算符优先级</strong></h5><table>
<thead>
<tr>
<th align="center"><strong>优先级</strong></th>
<th align="center"><strong>运算符</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>13</strong></td>
<td align="center"><strong>-, +</strong></td>
<td align="center"><strong>单目负、单目正</strong></td>
</tr>
<tr>
<td align="center"><strong>12</strong></td>
<td align="center"><strong>!, ~</strong></td>
<td align="center"><strong>逻辑非、按位取反或补码</strong></td>
</tr>
<tr>
<td align="center"><strong>11</strong></td>
<td align="center">***,/, %    乘、除、取模**</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>+, -</strong></td>
<td align="center"><strong>加、减</strong></td>
</tr>
<tr>
<td align="center"><strong>9</strong></td>
<td align="center"><strong>&lt;&lt; , &gt;&gt;</strong></td>
<td align="center"><strong>按位左移、按位右移</strong></td>
</tr>
<tr>
<td align="center"><strong>8</strong></td>
<td align="center"><strong>&lt; =, &gt; =, &lt; , &gt;</strong></td>
<td align="center"><strong>小于或等于、大于或等于、小于、大于</strong></td>
</tr>
<tr>
<td align="center"><strong>7</strong></td>
<td align="center"><strong>== , !=</strong></td>
<td align="center"><strong>等于、不等于</strong></td>
</tr>
<tr>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>&amp;</strong></td>
<td align="center"><strong>按位与</strong></td>
</tr>
<tr>
<td align="center"><strong>5</strong></td>
<td align="center"><strong>^</strong></td>
<td align="center"><strong>按位异或</strong></td>
</tr>
<tr>
<td align="center"><strong>4</strong></td>
<td align="center"><strong>|</strong></td>
<td align="center"><strong>按位或</strong></td>
</tr>
<tr>
<td align="center"><strong>3</strong></td>
<td align="center"><strong>&amp;&amp;</strong></td>
<td align="center"><strong>逻辑与</strong></td>
</tr>
<tr>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>||</strong></td>
<td align="center"><strong>逻辑或</strong></td>
</tr>
<tr>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>=,+=,-=,*=,/=,%=,&amp;=, ^=,赋值、运算且赋值</strong></td>
<td align="center"><strong>=, &lt;&lt;=, &gt;&gt;=</strong></td>
</tr>
</tbody></table>
<h4 id="10-5-2-变量测试与内容替换"><a href="#10-5-2-变量测试与内容替换" class="headerlink" title="10.5.2 变量测试与内容替换"></a><strong>10.5.2 变量测试与内容替换</strong></h4><ul>
<li><strong>测试表</strong></li>
</ul>
<p>​        <strong>用来测试一个变量到底有没有设置</strong><br><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210803155541740.png" alt="image-20210803155541740"></strong></p>
<ul>
<li><p><strong>例子：</strong></p>
<ul>
<li><p><strong>测试x=${y-新值} 测试y变量存不存在</strong></p>
<p><strong>unset y 删除变量y</strong><br><strong>x=${y-new} 进行测试<br>echo $x</strong><br><strong>显示new，y变量不存在</strong><br><strong>因为变量y不存在，所以x=new</strong></p>
</li>
<li><p><strong>y=”” 给变量y赋值为空</strong><br><strong>x=${y-new} 进行测试<br>echo $x</strong><br><strong>显示空，y为空值</strong></p>
</li>
<li><p><strong>y=old 给变量y赋值</strong><br><strong>x=${y-new} 进行测试<br>echo $x</strong><br><strong>显示old ，y变量存在且有值</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="10-6-环境变量配置文件"><a href="#10-6-环境变量配置文件" class="headerlink" title="10.6 环境变量配置文件"></a><strong>10.6 环境变量配置文件</strong></h3><h4 id="10-6-1-环境变量配置文件简介"><a href="#10-6-1-环境变量配置文件简介" class="headerlink" title="10.6.1 环境变量配置文件简介"></a><strong>10.6.1 环境变量配置文件简介</strong></h4><h5 id="（1）source命令"><a href="#（1）source命令" class="headerlink" title="（1）source命令"></a><strong>（1）<font color="red">source</font>命令</strong></h5><ul>
<li> <strong>命令格式：source 配置文件  或  . 配置文件</strong> </li>
<li> <strong>功能描述：强制使配置文件在修改之后生效，不需要重启</strong></li>
</ul>
<h5 id="（2）简介"><a href="#（2）简介" class="headerlink" title="（2）简介"></a><strong>（2）简介</strong></h5><ul>
<li><p><strong>环境变量配置文件中主要是定义<font color="orange">对系统的操作环境生效的系统默认环境变量</font>，比如 PATH、HISTSIZE、PS1、HOSTNAME等 默认环境变量。</strong></p>
</li>
<li><p><strong>配置文件保持位置</strong></p>
<ul>
<li><p><strong>/etc/profile</strong> </p>
</li>
<li><p><strong>/etc/profile.d/*.sh</strong> </p>
</li>
<li><p><strong>~/.bash_profile</strong> </p>
</li>
<li><p><strong>~/.bashrc</strong> </p>
</li>
<li><p><strong>/etc/bashrc</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="10-6-2-环境变量配置文件作用"><a href="#10-6-2-环境变量配置文件作用" class="headerlink" title="10.6.2 环境变量配置文件作用"></a><strong>10.6.2 环境变量配置文件作用</strong></h4><h5 id="（1）主要的环境变量配置文件"><a href="#（1）主要的环境变量配置文件" class="headerlink" title="（1）主要的环境变量配置文件"></a><strong>（1）主要的环境变量配置文件</strong></h5><ul>
<li><strong>/etc/profile</strong></li>
<li><strong>/etc/profile.d/*.sh    指/etc/profile.d/下所有的.sh结尾的文件</strong></li>
<li><strong>~/.bash_profile</strong></li>
<li><strong>~/.bashrc</strong></li>
<li><strong>/etc/bashrc</strong></li>
<li><strong>tips:</strong><ul>
<li><strong>/etc 目录下的对所有用户都生效</strong></li>
<li><strong>~/.bash_profile 和 ~/.bashrc -&gt; 每个用户自己的配置文件，只对用户生效。</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）环境变量配置文件调用顺序流程图"><a href="#（2）环境变量配置文件调用顺序流程图" class="headerlink" title="（2）环境变量配置文件调用顺序流程图"></a><strong>（2）环境变量配置文件调用顺序流程图</strong></h5><p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210806105220081.png" alt="image-20210806105220081"></strong></p>
<ul>
<li><p><strong>上图从左到右如果没有叠加。后面的命令会覆盖前面的命令。 这些是在登陆的时候挨个调用，所以在这里面设置环境变量，登陆之后就会自动设置好</strong></p>
</li>
<li><p><strong>/etc/profile的作用：</strong></p>
<ul>
<li><strong>里面有USER变量、LOGNAME变量、MAIL变量、PATH变量HOSTNAME变量、HISTSIZE变量、umask等环境变量的配置；</strong></li>
<li><strong>调用/etc/profile.d/*.sh 文件</strong></li>
</ul>
</li>
<li><p><strong>~/.bash_profile的作用:</strong></p>
<ul>
<li><strong>调用了~/.bashrc文件。</strong></li>
<li><strong>在PATH变量后面加入了“:$HOME/bin” 这个目录</strong></li>
</ul>
</li>
<li><p><strong>~/.bashrc的作用:</strong></p>
<ul>
<li><strong>定义默认别名</strong></li>
<li><strong>调用/etc/bashrc</strong></li>
</ul>
</li>
<li><p><strong>/etc/bashrc的作用:</strong></p>
<ul>
<li><strong>PS1变量</strong></li>
<li><strong>umask</strong></li>
<li><strong>PATH变量</strong></li>
<li><strong>调用/etc/profile.d/*.sh文件</strong><br><strong>这一块就是进入界面以内，切换shell登陆方式，这种不需要密码，所以和前面的/etc/profile的作用不冲突</strong></li>
</ul>
</li>
</ul>
<h4 id="10-6-3-其他配置文件和登录信息"><a href="#10-6-3-其他配置文件和登录信息" class="headerlink" title="10.6.3 其他配置文件和登录信息"></a><strong>10.6.3 其他配置文件和登录信息</strong></h4><ul>
<li><p><strong>注销时生效的环境变量配置文件</strong></p>
<p><strong>~/.bash_logout ：注销登录时写入</strong></p>
</li>
<li><p><strong>其他配置文件</strong></p>
<p> <strong>~/bash_history：历史命令文件</strong></p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>Shell 登录信息</strong></p>
<ul>
<li><strong>本地终端欢迎信息： /etc/issue</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>转义符</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>\d</strong></td>
<td align="center"><strong>显示当前系统日期</strong></td>
</tr>
<tr>
<td align="center"><strong>\s</strong></td>
<td align="center"><strong>显示操作系统名称</strong></td>
</tr>
<tr>
<td align="center"><strong>\l</strong></td>
<td align="center"><strong>显示登录的终端号，这个比较常用。</strong></td>
</tr>
<tr>
<td align="center"><strong>\m</strong></td>
<td align="center"><strong>显示硬件体系结构，如i386、i686等</strong></td>
</tr>
<tr>
<td align="center"><strong>\n</strong></td>
<td align="center"><strong>显示主机名</strong></td>
</tr>
<tr>
<td align="center"><strong>\o</strong></td>
<td align="center"><strong>显示域名</strong></td>
</tr>
<tr>
<td align="center"><strong>\r</strong></td>
<td align="center"><strong>显示内核版本</strong></td>
</tr>
<tr>
<td align="center"><strong>\t</strong></td>
<td align="center"><strong>显示当前系统时间</strong></td>
</tr>
<tr>
<td align="center"><strong>\u</strong></td>
<td align="center"><strong>显示当前登录用户的序列号</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>远程终端欢迎信息： /etc/issue.net</strong> <ul>
<li><strong>转义符在/etc/issue.net 文件中不能使用</strong></li>
<li><strong>是否显示此欢迎信息，由 ssh 的配置文件/etc/ssh/sshd_config 决定，加入“Banner/etc/issue.net”行才能显示（记得重启 SSH 服务）</strong> </li>
</ul>
</li>
<li><strong>登陆后欢迎信息：/etc/motd , 不管是本地登录，还是远程登录，都可以显示此欢迎信息</strong></li>
</ul>
</li>
</ul>
<h2 id="第十一章-Shell编程"><a href="#第十一章-Shell编程" class="headerlink" title="第十一章 Shell编程"></a><strong>第十一章 Shell编程</strong></h2><h3 id="11-1-基础正则表达式"><a href="#11-1-基础正则表达式" class="headerlink" title="11.1 基础正则表达式"></a><strong>11.1 基础正则表达式</strong></h3><h4 id="11-1-1-正则表达式与通配符"><a href="#11-1-1-正则表达式与通配符" class="headerlink" title="11.1.1 正则表达式与通配符"></a><strong>11.1.1 正则表达式与通配符</strong></h4><ul>
<li><p><strong>正则表达式用来在文件中<font color="orange">匹配符合条件的字符串</font>，正则是<font color="red">包含匹配</font>。<font color="orange">grep、awk、sed </font>等命令可以支持正则表达式。</strong></p>
</li>
<li><p><strong>通配符用来<font color="orange">匹配符合条件的文件名</font>，通配符是<font color="red">完全匹配</font>。<font color="orange">ls、find、cp </font>这些命令不支持正则表达式，所以只能使用 shell 自己的通配符来进行匹配了。</strong></p>
</li>
</ul>
<h4 id="11-1-2-基础正则表达式"><a href="#11-1-2-基础正则表达式" class="headerlink" title="11.1.2 基础正则表达式"></a><strong>11.1.2 基础正则表达式</strong></h4><h5 id="（1）元字符及其作用"><a href="#（1）元字符及其作用" class="headerlink" title="（1）元字符及其作用"></a><strong>（1）<font color="red">元字符及其作用</font></strong></h5><table>
<thead>
<tr>
<th align="center"><strong>元字符</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">*****</td>
<td><strong>匹配前一个字符0次或任意多次。</strong></td>
</tr>
<tr>
<td align="center"><strong>.</strong></td>
<td><strong>匹配除了换行符外任意一个字符。</strong></td>
</tr>
<tr>
<td align="center"><strong>^</strong></td>
<td><strong>匹配行首。例如:^hello会匹配以hello开头的行。</strong></td>
</tr>
<tr>
<td align="center"><strong>$</strong></td>
<td><strong>匹配行尾。例如:hello&amp;会匹配以hello结尾的行。</strong></td>
</tr>
<tr>
<td align="center"><strong>[]</strong></td>
<td><strong>匹配中括号中指定的任意一个字符，只匹配一个字符。 例如:[aoeiu] 匹配任意一个元音字母，[0-9] 匹配任意一位 数字， [a-z] [0-9]匹配小写字和一位数字构成的两位字符。</strong></td>
</tr>
<tr>
<td align="center"><strong>[^]</strong></td>
<td><strong>匹配除中括号的字符以外的任意一个字符。例如:[^0-9] 匹配 任意一位非数字字符，[^a-z] 表示任意一位非小写字母。</strong></td>
</tr>
<tr>
<td align="center">*<em><strong>*</strong></em></td>
<td><strong>转义符。用于取消特殊符号的含义。</strong></td>
</tr>
<tr>
<td align="center"><strong>\{n\}</strong></td>
<td><strong>表示其前面的字符<font color="red">恰好出现</font>n次。例如:[0-9]{4} 匹配4位数字，[1] [3-8] [0-9]{9} 匹配手机号码</strong></td>
</tr>
<tr>
<td align="center"><strong>\{n,\}</strong></td>
<td><strong>表示其前面的字符<font color="red">至少出现</font>n次。例如: [0-9]{2,} 表示两位及以上的数字。</strong></td>
</tr>
<tr>
<td align="center"><strong>\{n,m\}</strong></td>
<td><strong>表示其前面的字符至少出现n次，最多出现m次。例如: [a- z]{6,8} 匹配6到8位的小写字母</strong></td>
</tr>
</tbody></table>
<h5 id="（2）举例【以下匹配均指包含匹配】"><a href="#（2）举例【以下匹配均指包含匹配】" class="headerlink" title="（2）举例【以下匹配均指包含匹配】"></a><strong>（2）举例【以下匹配均指<font color="red">包含匹配</font>】</strong></h5><ul>
<li><p><strong>“*”前一个字符匹配0次，或任意多次</strong></p>
<ul>
<li><p><strong>grep “a*” test_rule.txt</strong><br><strong>#匹配所有内容，包括空白行(匹配包含0个或任意多个a的行，包含0个a&lt;=&gt;所有内容)</strong></p>
</li>
<li><p><strong>grep “aa*” test_rule.txt</strong><br><strong>#匹配至少包含有一个a的行</strong></p>
</li>
<li><p><strong>grep “aaa*” test_rule.txt</strong><br><strong>#匹配最少包含两个连续a的字符串</strong></p>
</li>
</ul>
</li>
<li><p><strong>“.” 匹配除了换行符外任意一个字符</strong></p>
<ul>
<li><strong>grep “s..d” test_rule.txt</strong><br><strong>#“s..d”会匹配在s和d这两个字母之间有两个字符的单词</strong></li>
<li><strong>grep “s.*d” test_rule.txt</strong><br><strong>#匹配在s和d字母之间有任意(个数&gt;=0)字符 (.*等价于任意个数 .)</strong></li>
<li>*<em>grep “.<em>” test_rule.txt</em></em><br><strong>#匹配所有内容，包括空白行（匹配包含0个或任意多个任意字符的行&lt;=&gt;所有内容）</strong></li>
</ul>
</li>
<li><p><strong>“^”匹配行首，“$”匹配行尾</strong></p>
<ul>
<li><strong>grep “^M” test_rule.txt</strong><br><strong>#匹配以大写“M”开头的行</strong></li>
<li><strong>grep “n​$” test_rule.txt</strong><br><strong>#匹配以小写“n”结尾的行</strong></li>
<li><strong>grep -n “^$” test_rule.txt</strong><br><strong>#会匹配空白行</strong></li>
</ul>
</li>
<li><p><strong>“[]” 匹配中括号中指定的任意一个字符，只匹配一个字符</strong></p>
<ul>
<li><strong>grep “s[ao]id” test_rule.txt</strong><br><strong>#匹配s和i字母中，要不是a、要不是o的行</strong></li>
<li><strong>grep “[0-9]” test_rule.txt</strong><br><strong>#匹配任意一个数字</strong></li>
<li><strong>grep “^[a-z]” test_rule.txt</strong><br><strong>#匹配用小写字母开头的行</strong></li>
</ul>
</li>
<li><p><strong>“[^]” 匹配除中括号的字符以外的任意一个字符</strong></p>
<ul>
<li><strong>grep “^[^a-z]” test_rule.txt</strong><br><strong>#匹配不以小写字母开头的行</strong></li>
<li><strong>grep “^[^a-z A-Z]” test_rule.txt</strong><br><strong>#匹配不用字母开头的行</strong></li>
</ul>
</li>
<li><p><strong>“\” 转义符,用于取消特殊符号的含义</strong></p>
<ul>
<li><strong>grep “\.$” test_rule.txt</strong><br><strong>#匹配使用“.”结尾的行</strong></li>
</ul>
</li>
<li><p><strong>“\{n\}”表示其前面的字符恰好出现n次</strong></p>
<ul>
<li><strong>grep “a\{3\}” test_rule.txt</strong><br><strong>#匹配a字母连续出现三次的字符串,即包含aaa的字符串</strong></li>
<li><strong>grep “[0-9]\{3\}” test_rule.txt</strong><br><strong>#匹配包含连续的三个数字的字符串</strong></li>
</ul>
</li>
<li><p><strong>“\{n,\}”表示其前面的字符出现不小于n次</strong></p>
<ul>
<li><p><strong>grep “^[0-9]\{3,\}[a-z]” test_rule.txt</strong></p>
<p><strong>#匹配最少用连续三个数字开头且后跟一个字符的行</strong></p>
</li>
</ul>
</li>
<li><p><strong>“{n,m}”匹配其前面的字符至少出现n次， 最多出现m次</strong></p>
<ul>
<li><strong>grep “sa\{1,3\}i” test_rule.txt</strong><br><strong>#匹配在字母s和字母i之间有最少一个a，最多三个a</strong></li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost test]$ cat test_rule.txt </span><br><span class="line">18286486521</span><br><span class="line">18384681568</span><br><span class="line">18414568468</span><br><span class="line">1530268781@qq.com</span><br><span class="line">1530268781@gmail.com</span><br><span class="line">1530268781@163.com</span><br><span class="line">@qq.com</span><br><span class="line">a@163.com</span><br><span class="line">153@.com</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配包含以181、182、183、184开头的电话号码的行</span></span><br><span class="line">[zlx@localhost test]$ grep &quot;18[1-4][0-9]\&#123;8\&#125;&quot; test_rule.txt </span><br><span class="line">18286486521</span><br><span class="line">18384681568</span><br><span class="line">18414568468</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配包含qq邮箱xxx.qq.com的行</span></span><br><span class="line">[zlx@localhost test]$ grep &quot;.*@qq.com&quot; test_rule.txt 	#错误，.*匹配所有内容包含“空”</span><br><span class="line">1530268781@qq.com</span><br><span class="line">@qq.com</span><br><span class="line">[zlx@localhost test]$ grep &quot;..*@qq.com&quot; test_rule.txt #正确，..*匹配所有内容，且至少有一个字符</span><br><span class="line">1530268781@qq.com</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配包含邮箱 xxx.@xxx.com的行</span></span><br><span class="line">[zlx@localhost test]$ grep &quot;..*@..*\.com&quot; test_rule.txt </span><br><span class="line">1530268781@qq.com</span><br><span class="line">1530268781@gmail.com</span><br><span class="line">1530268781@163.com</span><br><span class="line">a@163.com</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配只有电话号码的行（以电话号码开头和结尾）</span></span><br><span class="line">[zlx@localhost test]$ grep &quot;^18[1-4][1-9]\&#123;8\&#125;&quot; test_rule.txt 	#错误</span><br><span class="line">18286486521jidng</span><br><span class="line">18384681568dg</span><br><span class="line">18414568468</span><br><span class="line">[zlx@localhost test]$ grep &quot;^18[1-4][1-9]\&#123;8\&#125;$&quot; test_rule.txt </span><br><span class="line">18414568468</span><br></pre></td></tr></table></figure>



<h3 id="11-2-字符截取命令"><a href="#11-2-字符截取命令" class="headerlink" title="11.2 字符截取命令"></a><strong>11.2 字符截取命令</strong></h3><h4 id="11-2-1-cut命令"><a href="#11-2-1-cut命令" class="headerlink" title="11.2.1 cut命令"></a><strong>11.2.1 <font color="red">cut</font>命令</strong></h4><ul>
<li><p><strong>命令格式：<font color="red">cut [选项] 文件名</font></strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong><font color="orange">-f</font> 列号： 提取第几列</strong> </li>
<li><strong><font color="orange">-d</font> 分隔符： 按照指定分隔符分割列</strong></li>
</ul>
</li>
<li><p><strong>tips:</strong></p>
<ul>
<li><strong>一般在使用cut命令的时候和管道符“|”连着使用</strong></li>
<li><strong>grep为提取行，cut提取列，而且cut提取的表格中，只能用制表符隔开不能用空格</strong></li>
</ul>
</li>
<li><p><strong>举例：</strong></p>
<ul>
<li><p><strong>[root@localhost ~]# cut -f 2 student.txt</strong> </p>
<p><strong>#提取第二列</strong></p>
</li>
<li><p><strong>[root@localhost ~]# cut -f 2,3 student.txt</strong> </p>
<p><strong>#提取第二第三列</strong></p>
</li>
<li><p><strong>[root@localhost ~]# cut -d “:” -f 1,3 /etc/passwd</strong></p>
<p><strong>#以：为分隔符提取第一第三列</strong></p>
</li>
</ul>
</li>
<li><p><strong>cut 命令的局限：</strong></p>
<p><strong>[root@localhost ~]# df -h | cut -d “ “ -f 1,3</strong></p>
<p><strong>#有空格时提取会出问题</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost 桌面]$ cat student.txt </span><br><span class="line">id	name	gender	mark</span><br><span class="line">1	Li		M		86</span><br><span class="line">2	Shen	M		90</span><br><span class="line">3	Gao		M		83</span><br><span class="line">[zlx@localhost 桌面]$ cut -f 2 student.txt</span><br><span class="line">name</span><br><span class="line">Li</span><br><span class="line">Shen</span><br><span class="line">Gao</span><br><span class="line">[zlx@localhost 桌面]$ cut -f 2,4 student.txt</span><br><span class="line">name	mark</span><br><span class="line">Li		86</span><br><span class="line">Shen	90</span><br><span class="line">Gao		83</span><br><span class="line"></span><br><span class="line">[zlx@localhost 桌面]$ cat student1.txt </span><br><span class="line">id:name:gender:mark</span><br><span class="line">1:Shen:M:90</span><br><span class="line">2:Li:M:86</span><br><span class="line">3:Gao:M:83</span><br><span class="line">[zlx@localhost 桌面]$ cut -d &quot;:&quot; -f 1,3 student1.txt</span><br><span class="line">id:gender</span><br><span class="line">1:M</span><br><span class="line">2:M</span><br><span class="line">3:M</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-2-2-printf命令"><a href="#11-2-2-printf命令" class="headerlink" title="11.2.2 printf命令"></a><strong>11.2.2 <font color="red">printf</font>命令</strong></h4><ul>
<li><p><strong>命令格式：<font color="red">printf  ‘输出类型|输出格式’  输出内容</font></strong></p>
</li>
<li><p><strong>输出类型：</strong> </p>
<ul>
<li><strong>%ns ： 输出字符串。n 是数字指代输出几个字符</strong> </li>
<li><strong>%ni ： 输出整数。n 是数字指代输出几个数字</strong> </li>
<li><strong>%m.nf ： 输出浮点数。m 和 n 是数字，指代输出整数的位数和小数位数。如%8.2f 代表共输出 8 位数， 其中 2 位是小数，6 位是整数。</strong></li>
</ul>
</li>
<li><p><strong>输出格式：</strong> </p>
<ul>
<li><strong>\a : 输出警告声音</strong> </li>
<li><strong>\b : 输出退格键，也就是 Backspace 键</strong> </li>
<li><strong>\f : 清除屏幕</strong> </li>
<li><strong>\n : 换行</strong> </li>
<li><strong>\r : 回车，也就是 Enter 键</strong> </li>
<li><strong>\t : 水平输出退格键，也就是 Tab 键</strong> </li>
<li><strong>\v : 垂直输出退格键，也就是 Tab 键</strong></li>
</ul>
</li>
<li><p><strong>tips：</strong></p>
<ul>
<li><strong>因为每有几个%s代表每几个字符输出一次</strong></li>
<li><strong>在与cat命令结合使用的时候，需要用<font color="orange">$()把cat命令扩起来</font>，使用这种命令赋予变量的方式，才能正确输出文件内容，但是具体格式还得用%s\t 或者%s\n控制</strong></li>
<li><strong>在awk命令的输出中支持print和printf命令,printf主要在awk命令编程中使用</strong><ul>
<li><strong>print:print会在每个输出之后自动加入一 个换行符(Linux默认没有print命令)</strong></li>
<li><strong>printf:printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>举例：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost 桌面]$ printf %s 1 2 3 4 5 6</span><br><span class="line">123456[zlx@localhost 桌面]$ printf %s %s %s 1 2 3 4 5 6</span><br><span class="line"><span class="meta">%</span><span class="bash">s%s123456[zlx@localhost 桌面]$ <span class="built_in">printf</span> <span class="string">&#x27;%s %s %s&#x27;</span> 1 2 3 4 5 6</span></span><br><span class="line">1 2 34 5 6[zlx@localhost 桌面]$ printf &#x27;%s%s%s&#x27; 1 2 3 4 5 6</span><br><span class="line">123456[zlx@localhost 桌面]$ printf &#x27;%s %s %s\n&#x27; 1 2 3 4 5 6</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">不调整格式输出</span></span><br><span class="line">[zlx@localhost 桌面]$ printf &#x27;%s&#x27; $(cat student.txt)</span><br><span class="line">idnamegendermark1LiM862ShenM903GaoM83</span><br><span class="line"><span class="meta">#</span><span class="bash">调整格式输出</span></span><br><span class="line">[zlx@localhost 桌面]$ printf &#x27;%s\t %s\t %s\t %s\t \n&#x27; $(cat student.txt)</span><br><span class="line">id	 name	 gender	 mark	 </span><br><span class="line">1	 Li	 	 M	 	86	 </span><br><span class="line">2	 Shen	 M	 	90	 </span><br><span class="line">3	 Gao	 M	 	83	</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-2-3-awk命令"><a href="#11-2-3-awk命令" class="headerlink" title="11.2.3 awk命令"></a><strong>11.2.3 awk命令</strong></h4><ul>
<li><p><strong>介绍：</strong></p>
<p><strong>awk命令也叫awk编程，可以<font color="orange">识别非制表符的空格</font>，用来解决cut命令解决不了的提取列工作，他是把需要提取的原文件一行一行扫描，扫描每一行中所需要点列，然后把它记录下来，在全部扫描完之后全部打印出来。</strong></p>
</li>
<li><p><strong>命令格式：<font color="red"> awk ‘条件1{动作 1} 条件2{动作 2}…’ 文件名</font></strong></p>
</li>
<li><p><strong>条件(pattern)：一般使用关系表达式作为条件。如x&gt;10</strong></p>
</li>
<li><p><strong>动作(action)：</strong></p>
<ul>
<li><strong>格式化输出</strong></li>
<li><strong>流程控制语句</strong></li>
</ul>
</li>
<li><p><strong>举例：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost 桌面]$ awk &#x27;&#123;printf $2 &quot;\t&quot; $3 &quot;\n&quot;&#125;&#x27; student.txt</span><br><span class="line">name	gender</span><br><span class="line">Li		M</span><br><span class="line">Shen	M</span><br><span class="line">Gao		M</span><br><span class="line">[zlx@localhost 桌面]$ </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost 桌面]$ df -h</span><br><span class="line">文件系统             容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs             872M     0  872M    0% /dev</span><br><span class="line">tmpfs                901M     0  901M    0% /dev/shm</span><br><span class="line">tmpfs                901M   18M  883M    2% /run</span><br><span class="line">tmpfs                901M     0  901M    0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/cl-root   17G  4.3G   13G   26% /</span><br><span class="line">/dev/sda1            976M  193M  716M   22% /boot</span><br><span class="line">tmpfs                181M  1.2M  179M    1% /run/user/42</span><br><span class="line">tmpfs                181M  4.6M  176M    3% /run/user/1000</span><br><span class="line"><span class="meta">#</span><span class="bash">查看第一列与第5列</span></span><br><span class="line">[zlx@localhost 桌面]$ df -h | awk &#x27;&#123;printf $1 &quot;\t&quot; $5 &quot;\n&quot;&#125;&#x27; </span><br><span class="line">文件系统	已用%</span><br><span class="line">devtmpfs	0%</span><br><span class="line">tmpfs	0%</span><br><span class="line">tmpfs	2%</span><br><span class="line">tmpfs	0%</span><br><span class="line">/dev/mapper/cl-root	26%</span><br><span class="line">/dev/sda1	22%</span><br><span class="line">tmpfs	1%</span><br><span class="line">tmpfs	3%</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看cl-root文件系统的已用百分比（grep提取行，awk提取列）</span></span><br><span class="line">[zlx@localhost 桌面]$ df -h | grep cl-root | awk &#x27;&#123;printf $5 &quot;\n&quot;&#125;&#x27;</span><br><span class="line"><span class="meta">26%</span><span class="bash"></span></span><br><span class="line"><span class="bash"></span><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看cl-root文件系统已用百分比数值（grep提取行，awk提取列，cut进一步提取列</span></span><br><span class="line">[zlx@localhost 桌面]$ df -h | grep cl-root | awk &#x27;&#123;printf $5 &quot;\n&quot;&#125;&#x27; | cut -d &#x27;%&#x27; -f 1</span><br><span class="line">26</span><br><span class="line"><span class="meta">#</span><span class="bash">查看cl-root文件系统已用百分比数值（grep提取行，awk提取列后进一步提取列</span></span><br><span class="line">[zlx@localhost 桌面]$ df -h | grep cl-root | awk &#x27;&#123;printf $5 &quot;\n&quot;&#125;&#x27; | awk -F &quot;%&quot; &#x27;&#123;printf $1 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">26</span><br><span class="line">[zlx@localhost 桌面]$ </span><br></pre></td></tr></table></figure></li>
<li><p><strong>BEGION:</strong></p>
<p><strong>#awk ‘BEGIN{printf “This is a transcript \n” } {printf $2 “\t” $6 “\n”}’ student.txt</strong></p>
</li>
<li><p><strong>END:</strong> </p>
<p><strong>#awk ‘END{printf “The End \n” } {printf $2 “\t” $6 “\n”}’ student.txt</strong> </p>
</li>
<li><p><strong>FS:用来指定字段分隔符，写在BEGIN中</strong></p>
<p><strong>#cat /etc/passwd | grep “/bin/bash” | awk ‘BEGIN {FS=”:”} {printf $1 “\t” $3 “\n”}’</strong></p>
</li>
</ul>
<h4 id="10-2-4-sed命令"><a href="#10-2-4-sed命令" class="headerlink" title="10.2.4 sed命令"></a><strong>10.2.4 <font color="red">sed</font>命令</strong></h4><h5 id="（1）sed命令"><a href="#（1）sed命令" class="headerlink" title="（1）sed命令"></a><strong>（1）sed命令</strong></h5><ul>
<li><p><strong>sed 是一种几乎包括在所有 UNIX 平台（包括 Linux）的轻量级流编辑器。sed 主要是用来将数据进行<font color="orange">选取、替换、删除、新增</font>的命令。</strong></p>
</li>
<li><p><strong>命令格式：<font color="red">sed [选项] ‘[动作]’ 文件名</font></strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><p><strong>-n： 一般 sed 命令会把所有数据都输出到屏幕 ， 如果加入此选择，则只会把经过 sed 命令处理的行输出到屏幕。</strong></p>
</li>
<li><p><strong>-e： 允许对输入数据应用多条 sed 命令编辑</strong></p>
</li>
<li><p><strong>-i： 用 sed 的修改结果直接修改读取数据的文件，而不是由屏幕输出</strong></p>
</li>
</ul>
</li>
<li><p><strong>动作: 范围行+参数</strong></p>
<ul>
<li><strong>a : 追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用“\”代表数据未完结。</strong></li>
<li><strong>c : 行替换，用c后面的字符串替换原数据行。替换多行时，除最后一行外，每行末尾需用“\”代表数据未完结。</strong></li>
<li><strong>i : 插入，在当期行前插入一行或多行。插入多行时，除最后 一行外，每行末尾需要用“\”代表数据未完结。</strong></li>
<li><strong>d : 删除，删除指定的行。</strong></li>
<li><strong>p : 打印，输出指定的行。</strong></li>
<li><strong>s : 字串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字串/新字串/g”(和vim中的替换格式类似)。</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）数据选取"><a href="#（2）数据选取" class="headerlink" title="（2）数据选取"></a><strong>（2）数据选取</strong></h5><ul>
<li><p><strong>sed ‘2p’ student.txt</strong> </p>
<p><strong>#打印第二行后打印全部数据。一般sed命令会把所有数据都输出到屏幕 ，只不过会先输出你想要的，这时候就需要-n配合</strong></p>
</li>
<li><p><strong>sed -n ‘2p’ student.txt</strong></p>
<p><strong>#打印第二行</strong></p>
</li>
<li><p><strong>sed -n ‘1,3p’ student.txt</strong></p>
<p><strong>#打印1-3行</strong></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ cat student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">2 	Sc		74	96		87		85.66</span><br><span class="line">3	Gao		99	83		93		91.66</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2p&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">2 	Sc		74	96		87		85.66</span><br><span class="line">3	Gao		99	83		93		91.66</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed -n &#x27;2p&#x27; student.txt </span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed -n &#x27;1,3p&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">2 	Sc		74	96		87		85.66</span><br></pre></td></tr></table></figure>



<h5 id="（3）数据追加"><a href="#（3）数据追加" class="headerlink" title="（3）数据追加"></a><strong>（3）数据追加</strong></h5><ul>
<li><p><strong>sed ‘2a hello’ student.txt</strong><br><strong>#在第二行后追加hello</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2a hello&#x27; student.txt </span><br><span class="line">ID	Name	PHP		Linux	MySQL	Average</span><br><span class="line">1	Liming	82		95		86		87.66</span><br><span class="line">hello</span><br><span class="line">2 	Sc		74		96		87		85.66  </span><br><span class="line">3	Gao		99		83		93		91.66</span><br><span class="line"></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2a hello \ world&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">hello  world</span><br><span class="line">2 	Sc		74	96		87		85.66</span><br><span class="line">3	Gao		99	83		93		91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（4）数据插入"><a href="#（4）数据插入" class="headerlink" title="（4）数据插入"></a><strong>（4）数据插入</strong></h5><ul>
<li><p><strong>sed ‘2i hello \ world’ student.txt</strong><br><strong>在第二行前插入两行数据</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2i hello&#x27; student.txt </span><br><span class="line">ID	Name	PHP		Linux	MySQL	Average</span><br><span class="line">hello</span><br><span class="line">1	Liming	82		95		86		87.66</span><br><span class="line">2 	Sc		74		96		87		85.66</span><br><span class="line">3	Gao		99		83		93		91.66</span><br><span class="line"></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2i hello \ world&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">hello  world</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">2 	Sc	74	96	87	85.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（5）数据删除"><a href="#（5）数据删除" class="headerlink" title="（5）数据删除"></a><strong>（5）数据删除</strong></h5><ul>
<li><p><strong>sed ‘1,3d’ student.txt</strong></p>
<p><strong>#删除1-3行数据后输出</strong></p>
</li>
<li><p><strong>sed -i ‘1,3d’student.txt</strong></p>
<p><strong>#删除1-3行数据（-i 修改数据文件）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;1,3d&#x27; student.txt </span><br><span class="line">3	Gao	99	83	93	91.66</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed -i &#x27;3d&#x27; student.txt </span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ cat student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（6）数据替换"><a href="#（6）数据替换" class="headerlink" title="（6）数据替换"></a><strong>（6）数据替换</strong></h5><ul>
<li><p><strong>行替换：sed ‘2c No such person’ student.txt</strong></p>
<p><strong>#将第二行替换为指定字符串</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2c No such person&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">No such person</span><br><span class="line">2 	Sc	74	96	87	85.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>字符串替换</strong></p>
<p><strong>sed ‘行范围s/旧字符串/新字符串/g’ 文件名</strong></p>
<ul>
<li><strong>sed ‘3s/74/99/g’ student.txt</strong><br><strong>在第三行中，把74换成99</strong></li>
<li><strong>sed -i ‘3s/74/99/g’ student.txt</strong><br><strong>sed操作的数据直接写入文件</strong></li>
<li><strong>sed -e ‘s/Liming//g ; s/Gao//g’ student.txt</strong><br><strong>同时把“Liming”和“Gao”替换为空（-e 多条sed命令编辑）</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将第三行的99替换为95</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;3s/99/95/g&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">3	Gao	95	83	93	91.66</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed -i &#x27;3s/99/95/g&#x27; student.txt </span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ cat student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">3	Gao		95	83	93	91.66</span><br><span class="line"><span class="meta">#</span><span class="bash">将Liming和Gao的成绩替换</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed -e &#x27;2s/Liming/Gao/g;3s/Gao/Liming/g&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Gao	82	95	86	87.66</span><br><span class="line">3	Liming	95	83	93	91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-3-字符处理命令"><a href="#11-3-字符处理命令" class="headerlink" title="11.3 字符处理命令"></a><strong>11.3 字符处理命令</strong></h3><h4 id="11-3-1-sort排序命令"><a href="#11-3-1-sort排序命令" class="headerlink" title="11.3.1 sort排序命令"></a><strong>11.3.1 sort排序命令</strong></h4><ul>
<li><p><strong>命令格式： <font color="red">sort [选项] 文件名</font></strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-f： 忽略大小写</strong> </li>
<li><strong>-n： 以数值型进行排序，默认使用字符串型排序</strong> </li>
<li><strong>-r： 反向排序</strong> </li>
<li><strong>-t： 指定分隔符，默认分隔符是制表符</strong> </li>
<li><strong>-k n[,m]： 按照指定的字段范围排序。从第 n 字段开始， m 字段结束（默认到行尾） （注意：-k 3表示用第3到最后的字段范围排序，-k 3,3 才表示用第三个字段排序）</strong></li>
</ul>
</li>
<li><p><strong>举列</strong></p>
<ul>
<li><p><strong>[root@localhost ~]# sort /etc/passwd</strong> </p>
<p><strong>#排序用户信息文件</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# sort -r /etc/passwd</strong> </p>
<p><strong>#反向排序</strong></p>
</li>
<li><p><strong>[root@localhost ~]# sort -t “:” -k 3,3 /etc/passwd</strong> </p>
<p><strong>#指定分隔符是“：”，用第三字段开头，第三字段结尾排序，就是只用第三字段排序</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# sort -n -t “:” -k 3,3 /etc/passwd</strong> </p>
<p><strong>#指定分隔符是“：”，用第三个字段且以数值型进行排序</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ cat student.txt</span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">2	Sc		98	99		100		99</span><br><span class="line">3	Gao		95	83		93		91.66</span><br><span class="line"><span class="meta">#</span><span class="bash">按平均分从低到高排序</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sort -n -k 6,6 student.txt </span><br><span class="line">ID	Name	PHP		Linux	MySQL	Average</span><br><span class="line">1	Liming	82		95		86		87.66</span><br><span class="line">3	Gao		95		83		93		91.66</span><br><span class="line">2	Sc		98		99		100		99</span><br><span class="line"><span class="meta">#</span><span class="bash">按平均分从高到低排序</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sort -r -n -k 6,6 student.txt </span><br><span class="line">2	Sc		98	99		100		99</span><br><span class="line">3	Gao		95	83		93		91.66</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="11-3-2-wc统计命令"><a href="#11-3-2-wc统计命令" class="headerlink" title="11.3.2 wc统计命令"></a><strong>11.3.2 wc统计命令</strong></h4><ul>
<li><p><strong>命令格式：<font color="red"> wc [选项] 文件名</font></strong></p>
</li>
<li><p><strong>选项：</strong> </p>
</li>
<li><ul>
<li><strong>-l： 只统计行数</strong></li>
<li><strong>-w： 只统计单词数</strong> </li>
<li><strong>-m： 只统计字符数</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ wc student.txt </span><br><span class="line"> 4 24 95 student.txt</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ wc -l student.txt </span><br><span class="line">4 student.txt</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ wc -w student.txt </span><br><span class="line">24 student.txt</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ wc -m student.txt </span><br><span class="line">95 student.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-4-条件判断"><a href="#11-4-条件判断" class="headerlink" title="11.4 条件判断"></a><strong>11.4 条件判断</strong></h3><h4 id="11-4-1-按照文件类型判断"><a href="#11-4-1-按照文件类型判断" class="headerlink" title="11.4.1 按照文件类型判断"></a><strong>11.4.1 按照文件类型判断</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>-b 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为 块设备文件(是块设备文件 为真) block</strong></td>
</tr>
<tr>
<td><strong>-c 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为字符设备文件(是字符设备 文件为真) char</strong></td>
</tr>
<tr>
<td><strong><font color="cornflowerblue">-d 文件</font></strong></td>
<td><strong>判断该文件是否存在，并且是否为目录文件(是目录为真) <font color="red">directory</font></strong></td>
</tr>
<tr>
<td><strong><font color="cornflowerblue">-e 文件</font></strong></td>
<td><strong>判断该文件是否存在(存在为真) <font color="red">exist</font></strong></td>
</tr>
<tr>
<td><strong><font color="cornflowerblue">-f 文件</font></strong></td>
<td><strong>判断该文件是否存在，并且是否为普通文件(是普通文件为真) <font color="red">file</font></strong></td>
</tr>
<tr>
<td><strong>-L 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为符号链接文件(是符号链接 文件为真) link</strong></td>
</tr>
<tr>
<td><strong>-p 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为管道文件(是管道文件为真)  pipe</strong></td>
</tr>
<tr>
<td><strong>-s 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为非空(非空为真)</strong></td>
</tr>
<tr>
<td><strong>-S 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为套接字文件(是套接字文件 为真) Socket</strong></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>两种判断格式：</strong></p>
<ul>
<li><p><strong><font color="red">test 参数 文件路径/文件名</font></strong></p>
<p><strong>#test -e /root/install.log    判断/root/install.log是否存在</strong></p>
</li>
<li><p><strong><font color="red">[ 参数 文件路径/文件名 ]</font>（括号内部左右有空格）</strong></p>
<ul>
<li><p><strong>#[ -e /root/install.log ]</strong></p>
</li>
<li><p><strong>#[ -d /root ] &amp;&amp; echo “yes” || echo “no”</strong> </p>
<p><strong>第一个判断命令如果正确执行，则打印“yes”，否则打印“no”</strong></p>
<p><strong>逻辑与：[ -d /root ]执行为true，echo “yes”才会执行</strong></p>
<p><strong>逻辑或：echo “yes”执行为false，echo “no” 才会执行</strong></p>
</li>
</ul>
</li>
<li><p><strong>举例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">判断是否存在</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> <span class="built_in">test</span> -e student.txt</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> <span class="built_in">test</span> -e student.txt &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> [ -e student.txt ]</span> </span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> [ -e student.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">判断是否存在，且是否为文件|文件夹</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> [ -f student.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> [ -d student.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">no</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="11-4-2-按照文件权限判断"><a href="#11-4-2-按照文件权限判断" class="headerlink" title="11.4.2 按照文件权限判断"></a><strong>11.4.2 按照文件权限判断</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><font color="blue">-r 文件</font></strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有读权限(有读 权限为真) <font color="red">read</font></strong></td>
</tr>
<tr>
<td><strong><font color="cornflowerblue">-w文件</font></strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有写权限(有写 权限为真) <font color="red">write</font></strong></td>
</tr>
<tr>
<td><strong><font color="cornflowerblue">-x 文件</font></strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有执行权限(有执行权限为真) <font color="red">execute</font></strong></td>
</tr>
<tr>
<td><strong>-u 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有SUID权限(有 SUID权限为真)</strong></td>
</tr>
<tr>
<td><strong>-g 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有SGID权限(有 SGID权限为真)</strong></td>
</tr>
<tr>
<td><strong>-k 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有SBit权限(有 SBit权限为真)</strong></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[zlx]$</span><span class="bash"> <span class="built_in">test</span> -r student.txt &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ [ -w sdudent.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ [ -x sdudent.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> sudo su</span></span><br><span class="line">[sudo] zlx 的密码：</span><br><span class="line"><span class="meta">[zlx]#</span><span class="bash"> [ -w student.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"><span class="meta">[zlx]#</span><span class="bash"> [ -x student.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">no</span><br></pre></td></tr></table></figure>



<h4 id="11-4-3-两个文件之间进行比较"><a href="#11-4-3-两个文件之间进行比较" class="headerlink" title="11.4.3 两个文件之间进行比较"></a><strong>11.4.3 两个文件之间进行比较</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>文件1 -nt 文件2</strong></td>
<td><strong>判断文件1的修改时间是否比文件2的新(如果新则为真) <font color="red">new than</font></strong></td>
</tr>
<tr>
<td><strong>文件1 -ot 文件2</strong></td>
<td><strong>判断文件1的修改时间是否比文件2的旧(如果旧则为真) <font color="red">old than</font></strong></td>
</tr>
<tr>
<td><strong>文件1 -ef 文件2</strong></td>
<td><strong>判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法 <font color="red">equal than</font></strong></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ test1.sh -nt test.sh ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">no</span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ test1.sh -ot test.sh ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="11-4-4-两个整数之间进行比较"><a href="#11-4-4-两个整数之间进行比较" class="headerlink" title="11.4.4 两个整数之间进行比较"></a><strong>11.4.4 两个整数之间进行比较</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>整数1 <font color="cornflowerblue">-eq</font> 整数2</strong></td>
<td><strong>判断整数1是否和整数2相等(相等为真) equal</strong></td>
</tr>
<tr>
<td><strong>整数1 <font color="cornflowerblue">-ne</font> 整数2</strong></td>
<td><strong>判断整数1是否和整数2不相等(不相等位置)  not equal</strong></td>
</tr>
<tr>
<td><strong>整数1<font color="cornflowerblue"> -gt </font>整数2</strong></td>
<td><strong>判断整数1是否大于整数2(大于为真) greater than</strong></td>
</tr>
<tr>
<td><strong>整数1 <font color="cornflowerblue">-lt</font>  整数2</strong></td>
<td><strong>判断整数1是否小于整数2(小于位置) lower than</strong></td>
</tr>
<tr>
<td><strong>整数1 <font color="cornflowerblue">-ge</font> 整数2</strong></td>
<td><strong>判断整数1是否大于等于整数2(大于等于为真) greater  equal</strong></td>
</tr>
<tr>
<td><strong>整数1 <font color="cornflowerblue">-le</font> 整数2</strong></td>
<td><strong>判断整数1是否小于等于整数2(小于等于为真) low equal</strong></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">判断11是否大于等于12</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ 11 -ge 12 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">no</span><br><span class="line"><span class="meta">#</span><span class="bash">判断11是否小于等于12</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ 11 -le 12 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="11-4-5-字符串的判断"><a href="#11-4-5-字符串的判断" class="headerlink" title="11.4.5 字符串的判断"></a><strong>11.4.5 字符串的判断</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>-z 字符串</strong></td>
<td><strong>判断字符串是否为空(为空返回真) zero</strong></td>
</tr>
<tr>
<td><strong>-n 字符串</strong></td>
<td><strong>判断字符串是否为非空(非空返回真) not zero</strong></td>
</tr>
<tr>
<td><strong>字串1 == 字串2</strong></td>
<td><strong>判断字符串1是否和字符串2相等(相等返回真)  注意：==左右有空格</strong></td>
</tr>
<tr>
<td><strong>字串1 != 字串2</strong></td>
<td><strong>判断字符串1是否和字符串2不相等(不相等返回真) 注意：!=左右有空格</strong></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zlx]$name=&quot;balabala&quot;</span><br><span class="line">[zlx]$name1=&quot;labalaba&quot;</span><br><span class="line">[zlx]$[ $name == $name1 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line">[zlx]$[ $name != $name1 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="11-4-6-多重体条件判断"><a href="#11-4-6-多重体条件判断" class="headerlink" title="11.4.6 多重体条件判断"></a><strong>11.4.6 多重体条件判断</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>判断1 -a 判断2</strong></td>
<td><strong>逻辑与，判断1和判断2都成立，最终的结果才为真 and</strong></td>
</tr>
<tr>
<td><strong>判断1 -o 判断2</strong></td>
<td><strong>逻辑或，判断1和判断2有一个成立，最终的结果就为真 or</strong></td>
</tr>
<tr>
<td><strong>!判断</strong></td>
<td><strong>逻辑非，使原始的判断式取反</strong></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[zlx]$</span><span class="bash">aa=11</span></span><br><span class="line"><span class="meta">#</span><span class="bash">判断变量aa是否为非空，且是否大于等于13</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ -n <span class="variable">$aa</span> -a <span class="variable">$aa</span> -gt 12 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">no</span><br><span class="line"><span class="meta">#</span><span class="bash">判断变量aa是否为非空，且是否小于等于13</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ -n <span class="variable">$aa</span> -a <span class="variable">$aa</span> -lt 12 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"><span class="meta">#</span><span class="bash">判断变量aa是否为非空，或是否大于等于13</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ -n <span class="variable">$aa</span> -o <span class="variable">$aa</span> -gt 12 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br></pre></td></tr></table></figure>





<h3 id="11-5-流程控制"><a href="#11-5-流程控制" class="headerlink" title="11.5 流程控制"></a><strong>11.5 流程控制</strong></h3><h4 id="11-5-1-if语句"><a href="#11-5-1-if语句" class="headerlink" title="11.5.1 if语句"></a><strong>11.5.1 if语句</strong></h4><h5 id="（1）单分支if条件语句"><a href="#（1）单分支if条件语句" class="headerlink" title="（1）单分支if条件语句"></a><strong>（1）单分支if条件语句</strong></h5><ul>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">	程序</span><br><span class="line">fi </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">	then </span><br><span class="line">		程序 </span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li><p><strong>注意：</strong></p>
<ul>
<li><strong>fi：if语句使用fi结尾，和一般语言使用大括号{…}结尾不同</strong></li>
<li><strong>[ 条件判断式 ]：就是使用test命令判断，所以中括号和条件判断式之间必须有空格</strong></li>
<li><strong>then：后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割。也可以换行写入，就不需要“;”了</strong></li>
</ul>
</li>
<li><p><strong>例子：<font color="cornflowerblue">判断分区使用率</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash <span class="comment">#统计根分区使用率</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx</span></span><br><span class="line">rate=$(df -h | grep &quot;/dev/sda1&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f 1)</span><br><span class="line"><span class="meta">#</span><span class="bash">把根分区使用率作为变量值赋给变量rate</span></span><br><span class="line">if [ $rate -ge 80 ]</span><br><span class="line">	then</span><br><span class="line">		echo &quot;Warning! /dev/sda1 is full!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash <span class="comment">#统计根分区使用率</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx</span></span><br><span class="line">rate=$(df -h | grep &quot;/dev/sda1&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f 1)</span><br><span class="line"><span class="meta">#</span><span class="bash">把根分区使用率作为变量值赋给变量rate</span></span><br><span class="line">if [ $rate -ge 80 ];then</span><br><span class="line">	echo &quot;Warning! /dev/sda1 is full!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）双分支if条件语句"><a href="#（2）双分支if条件语句" class="headerlink" title="（2）双分支if条件语句"></a><strong>（2）双分支if条件语句</strong></h5><ul>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式];then </span><br><span class="line">	条件成立时，执行的程序 </span><br><span class="line">else </span><br><span class="line">	条件不成立时，执行的另一个程序</span><br><span class="line">fi </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式] </span><br><span class="line">	then </span><br><span class="line">		条件成立时，执行的程序 </span><br><span class="line">	else </span><br><span class="line">		条件不成立时，执行的另一个程序</span><br><span class="line">fi </span><br></pre></td></tr></table></figure></li>
<li><p><strong>举例</strong></p>
<ul>
<li><p><strong><font color="cornflowerblue">备份文件信息及文件  </font>(注：du -sh 文件 :获取文件夹大小)</strong></p>
<p><strong>备份文件：tar -zcf xxx.tar.gz 目标文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx</span></span><br><span class="line"><span class="meta">#</span><span class="bash">备份/home/zlx/桌面/shellPractice</span></span><br><span class="line">ntpdate asia.pool.ntp.org &amp;&gt; /dev/null #同步系统时间</span><br><span class="line">date=$(date +%y%m%d) #把当前系统时间按照“年月日”格式赋予变量date</span><br><span class="line">size=$(du -sh /home/zlx/桌面/shellPractice) #统计文件夹大小</span><br><span class="line">if [ -d /tmp/backup ] #如果目标存在且是文件夹</span><br><span class="line">	then	</span><br><span class="line">        #将文件夹大小以及备份时间存储到临时文件中</span><br><span class="line">        echo &quot;Date:$date&quot; &gt; /tmp/backup/shellinfo.txt #标准输出重定向（覆盖）</span><br><span class="line">        echo &quot;Size:$size&quot; &gt;&gt; /tmp/backup/shellinfo.txt  #标准输出重定向（追加）</span><br><span class="line">        cd /tmp/backup</span><br><span class="line">        tar -zcf /home/zlx/桌面/shellprac-$date.tar.gz /home/zlx/桌面/shellPractice shellinfo.txt &amp;&gt; /dev/null#打包压缩</span><br><span class="line">        rm -rf /tmp/backup/shellinfo.txt</span><br><span class="line">    else	</span><br><span class="line">        mkdir /tmp/backup</span><br><span class="line">        echo &quot;Data:$date&quot; &gt; /tmp/backup/shellinfo.txt</span><br><span class="line">        echo &quot;Size:$size&quot; &gt;&gt; /tmp/backup/shellinfo.txt</span><br><span class="line">        cd /tmp/backup</span><br><span class="line">        tar -zcf /home/zlx/桌面/shellprac-$date.tar.gz /home/zlx/桌面/shellPractice shellinfo.txt &amp;&gt; /dev/null</span><br><span class="line">        rm -rf /tmp/backup/shellinfo.txt</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="cornflowerblue">判断apache是否启动</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx 2021-08-11</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">apache所在机器ip地址（默认80端口）</span></span><br><span class="line">ipport=127.0.0.1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">获取apache是否是启动状态（通过-w全量匹配tcp的80端口）</span></span><br><span class="line">isopen=$(nmap -sT $ipport | grep -w 80/tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">if [ &quot;$isopen&quot; == &quot;open&quot; ]</span><br><span class="line">   then</span><br><span class="line">        echo &quot;$(date) httpd is ok!&quot; &gt;&gt; /tmp/apache.log</span><br><span class="line">   else</span><br><span class="line">        # 启动apache</span><br><span class="line">        /etc/rc.d/init.d/httpd start &amp;&gt;/dev/null</span><br><span class="line">        echo &quot;$(date) restart httpd!&quot; &gt;&gt; /tmp/apache-err.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><strong>tips：nmap 远程扫描，检查服务是否启动</strong></p>
<pre><code>    **nmap -sT 扫描指定服务器上开启的TCP端口**
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="（3）多分支if条件语句"><a href="#（3）多分支if条件语句" class="headerlink" title="（3）多分支if条件语句"></a><strong>（3）多分支if条件语句</strong></h5><ul>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式1 ];then </span><br><span class="line">	当条件判断式1成立时，执行程序1 </span><br><span class="line">elif [ 条件判断式2 ];then</span><br><span class="line">	当条件判断式2成立时，执行程序2</span><br><span class="line">...省略更多条件... </span><br><span class="line">else </span><br><span class="line">	当所有条件都不成立时，最后执行此程序</span><br><span class="line">fi </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式1 ] </span><br><span class="line">	then </span><br><span class="line">		当条件判断式1成立时，执行程序1 </span><br><span class="line">elif [ 条件判断式2 ] </span><br><span class="line">	then</span><br><span class="line">		当条件判断式2成立时，执行程序2</span><br><span class="line">...省略更多条件... </span><br><span class="line">else </span><br><span class="line">	当所有条件都不成立时，最后执行此程序</span><br><span class="line">fi </span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="cornflowerblue">判断输入的文件类型</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx 2021-08-14</span></span><br><span class="line"><span class="meta">#</span><span class="bash">description:judge file <span class="built_in">type</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">读取键盘输入，并赋给变量file</span></span><br><span class="line">read -p &quot;Please input a filename:&quot; file</span><br><span class="line">if [ -z &quot;$file&quot; ]	#判断输入是否为空</span><br><span class="line">    then</span><br><span class="line">	echo &quot;Error,please input a filename&quot;</span><br><span class="line">	exit 1</span><br><span class="line">elif [ ! -e &quot;$file&quot; ]	#判断输入文件是否存在</span><br><span class="line">    then </span><br><span class="line">	echo &quot;Your input is not a file&quot;</span><br><span class="line">	exit 2</span><br><span class="line">elif [ -f &quot;$file&quot; ]</span><br><span class="line">    then</span><br><span class="line">	echo &quot;$file is a regulare file!&quot;</span><br><span class="line">elif [ -d &quot;$file&quot; ]</span><br><span class="line">    then</span><br><span class="line">	echo &quot;$file is a directory!&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;$file is an other file!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-5-2-case语句"><a href="#11-5-2-case语句" class="headerlink" title="11.5.2 case语句"></a><strong>11.5.2 case语句</strong></h4><ul>
<li><p><strong>多分支case条件语句：case语句和if…elif…else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系（等于关系），而if语句可以判断多种条件关系。</strong></p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量名 in </span><br><span class="line">	&quot;值1&quot;)</span><br><span class="line">		如果变量的值等于值1，则执行程序1 </span><br><span class="line">	;; </span><br><span class="line">	&quot;值2&quot;) </span><br><span class="line">		如果变量的值等于值2，则执行程序2 </span><br><span class="line">	;; </span><br><span class="line">	...省略其他分支... </span><br><span class="line">		*) </span><br><span class="line">   		如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">	;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="cornflowerblue">判断用户输入</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx 2021-08-14</span></span><br><span class="line"><span class="meta">#</span><span class="bash">description:judge the input</span></span><br><span class="line">read -p &quot;Please choose yes/no:&quot; -t 10 choose</span><br><span class="line">case $choose in</span><br><span class="line">	&quot;yes&quot;)</span><br><span class="line">		echo &quot;Your choose is yes!&quot;</span><br><span class="line">	;;</span><br><span class="line">        &quot;no&quot;)</span><br><span class="line">		echo &quot;your choose is no!&quot;</span><br><span class="line">	;;</span><br><span class="line">        *)</span><br><span class="line">		echo &quot;Your choose is error!&quot;</span><br><span class="line">	;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-5-3-for循环"><a href="#11-5-3-for循环" class="headerlink" title="11.5.3 for循环"></a><strong>11.5.3 for循环</strong></h4><h5 id="（1）语法一"><a href="#（1）语法一" class="headerlink" title="（1）语法一"></a><strong>（1）语法一</strong></h5><ul>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3</span><br><span class="line">	do </span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure></li>
<li><p><strong>例子：输出时间</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx 2021-08-14</span></span><br><span class="line"></span><br><span class="line">for time in morning noon afternoon evening</span><br><span class="line">    do</span><br><span class="line">		echo &quot;This time is $time!&quot;</span><br><span class="line">    done</span><br></pre></td></tr></table></figure></li>
<li><p><strong>优点：这种方法看起来很笨，需要把循环次数写入for，但是在系统管理的时候，当我们不确定循环次数的时候，比如解压缩一个文件里所有的压缩包，他会自动加入新的压缩包，这个时候我就需要用这种笨办法，这种后面加次数的也有一个好处，就是循环变量只要是由空格，或者回车，或者tab键隔开的，都可以算在内，所以才<font color="orange">能和cat，ls等命令结合使用</font>，cat命令执行之后显示的结果就是由回车隔开的，都可以算成是循环变量。在加入或者减少压缩包的时候，不需要修改脚本。</strong></p>
</li>
<li><p><strong>例子：<font color="cornflowerblue">批量解压缩</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx 2021-08-14</span></span><br><span class="line"></span><br><span class="line">cd /lamp</span><br><span class="line">ls *.tar.gz &gt; ls.log	#列出所有压缩文件，覆盖重定向到ls.log</span><br><span class="line">for i in $(cat ls.log)	#循环遍历ls.log中每一个压缩文件的记录</span><br><span class="line">    do</span><br><span class="line">        tar -zxf $i &amp;&gt; /dev/null	#解压缩</span><br><span class="line">    done</span><br><span class="line">rm -rf /lamp/ls.log</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）语法二"><a href="#（2）语法二" class="headerlink" title="（2）语法二"></a><strong>（2）语法二</strong></h5><ul>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((初始值;循环控制调节;变量变化))</span><br><span class="line">   do</span><br><span class="line">   	程序</span><br><span class="line">   done</span><br></pre></td></tr></table></figure></li>
<li><p><strong>例子：计算1加到100</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#Author:zlx 2021-08-14</span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for ((i=1;i&lt;=100;i++))</span><br><span class="line">    do</span><br><span class="line">	#s=$(($s+$i))			#数值运算，详见10.5.1</span><br><span class="line">	#s=$[$s+$i]</span><br><span class="line">	#s=$(expr $s + $i)</span><br><span class="line">	let s=s+i</span><br><span class="line">    done</span><br><span class="line">echo &quot;The sum of 1+2+3+...+100 is $s!&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="cornflowerblue">批量创建用户</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">批量添加新用户</span></span><br><span class="line">read -p &quot;Please input the number of users: &quot; -t 30 num  #输入创建用户个数</span><br><span class="line">read -p &quot;Please input user name: &quot; -t 30 name   #输入用户名</span><br><span class="line">read -p &quot;Please input the password of users: &quot; -t 30 pass   #输入用户密码</span><br><span class="line"></span><br><span class="line">if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot; -a ! -z &quot;$pass&quot; ]    #判断输入信息是否为空 </span><br><span class="line">    then</span><br><span class="line">    	y=$(echo $num | sed s/&#x27;^[0-9]*$&#x27;//g)    #这里是判断输入的用户个数是否为数字，sed后也可以把^[0-9]*$换为&#x27;s/[0-9]//g&#x27;</span><br><span class="line">        if [ -z &quot;$y&quot; ]  #如果上一条语句输出为空，就是输入的用户个数为数字</span><br><span class="line">            then</span><br><span class="line">                for ((i=1;i&lt;=$num;i++)) #开始循环</span><br><span class="line">                    do</span><br><span class="line">                    	/usr/sbin/useradd &quot;$name$i&quot; &amp;&gt;/dev/null #建立用户</span><br><span class="line">                        echo $pass | /usr/bin/passwd --stdin &quot;$name$i&quot; &amp;&gt;/dev/null      #设置用户密码，与用户名相同</span><br><span class="line">                    done</span><br><span class="line">                    echo &quot;Build seccees!&quot;</span><br><span class="line">        fi</span><br><span class="line">fi </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-5-4-while循环和until循环"><a href="#11-5-4-while循环和until循环" class="headerlink" title="11.5.4 while循环和until循环"></a><strong>11.5.4 while循环和until循环</strong></h4><h5 id="（1）while-循环"><a href="#（1）while-循环" class="headerlink" title="（1）while 循环"></a><strong>（1）while 循环</strong></h5><ul>
<li><p><strong>while循环是不定循环，也称作条件循环 。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。</strong></p>
</li>
<li><p><strong>语法</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ] </span><br><span class="line">	do </span><br><span class="line">		程序 </span><br><span class="line">	done </span><br></pre></td></tr></table></figure></li>
<li><p><strong>从1加到100</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash  </span><br><span class="line">#Author: zlx</span><br><span class="line">#从1加到100</span><br><span class="line"></span><br><span class="line">i=1 </span><br><span class="line">s=0 </span><br><span class="line">while [ $i -le 100 ] #如果变量i的值小于等于100，则执行循环 </span><br><span class="line">	do </span><br><span class="line">        s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+1 )) </span><br><span class="line">	done </span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）until循环"><a href="#（2）until循环" class="headerlink" title="（2）until循环"></a><strong>（2）until循环</strong></h5><ul>
<li><p><strong>until循环，和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。</strong></p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until [ 条件判断式 ] </span><br><span class="line">	do </span><br><span class="line">		程序 </span><br><span class="line">	done </span><br></pre></td></tr></table></figure></li>
<li><p><strong>从1加到100</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">Author: zlx</span></span><br><span class="line"><span class="meta">#</span><span class="bash">从1加到100</span></span><br><span class="line"></span><br><span class="line">i=1 </span><br><span class="line">s=0 </span><br><span class="line">until [ $i -gt 100 ] #循环直到变量i的值大于100，就停止循环 </span><br><span class="line">	do </span><br><span class="line">        s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+1 )) </span><br><span class="line">	done </span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第十二章-服务管理"><a href="#第十二章-服务管理" class="headerlink" title="第十二章 服务管理"></a><strong>第十二章 服务管理</strong></h2><h3 id="12-1服务简介与分类"><a href="#12-1服务简介与分类" class="headerlink" title="12.1服务简介与分类"></a><strong>12.1服务简介与分类</strong></h3><h5 id="（1）服务的分类"><a href="#（1）服务的分类" class="headerlink" title="（1）服务的分类"></a><strong>（1）服务的分类</strong></h5><p>​    <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20200529121600849.png" alt="服务的分类"></strong></p>
<h5 id="（2）启动与自启动"><a href="#（2）启动与自启动" class="headerlink" title="（2）启动与自启动"></a><strong>（2）启动与自启动</strong></h5><ul>
<li><strong>服务启动：就是在当前系统中让服务运行，并提供功能。</strong></li>
<li><strong>服务自启动：自启动是指让服务在系统开机或重启动之后，随着系统的启动而自动启动服务。</strong></li>
</ul>
<h5 id="（3）查询已安装的服务"><a href="#（3）查询已安装的服务" class="headerlink" title="（3）查询已安装的服务"></a><strong>（3）查询已安装的服务</strong></h5><ul>
<li><p><strong>RPM包安装的服务</strong></p>
<ul>
<li><p><strong><font color="red">chkconfig –list</font></strong></p>
<p><strong>查看服务自启动状态，可以看到所有RPM包安装的服务</strong></p>
</li>
<li><p><strong><font color="red">ps aux</font></strong></p>
<p><strong>查看启动服务的进程</strong></p>
</li>
</ul>
</li>
<li><p><strong>源码包安装的服务</strong></p>
<ul>
<li><strong>查看服务安装位置，一般是/usr/local/下</strong></li>
</ul>
</li>
<li><p><strong>RPM 安装服务和源码包安装服务的区别</strong></p>
<ul>
<li><strong>RPM 安装服务和源码包安装服务的区别就是安装位置的不同</strong></li>
<li><strong>源码包安装在指定位置，一般是/usr/local/</strong> </li>
<li><strong>RPM 包安装在默认位置中</strong></li>
</ul>
</li>
</ul>
<h3 id="12-2-rpm包安装服务的管理"><a href="#12-2-rpm包安装服务的管理" class="headerlink" title="12.2 rpm包安装服务的管理"></a><strong>12.2 rpm包安装服务的管理</strong></h3><h4 id="12-2-1-独立的服务管理"><a href="#12-2-1-独立的服务管理" class="headerlink" title="12.2.1 独立的服务管理"></a><strong>12.2.1 独立的服务管理</strong></h4><h5 id="（1）rpm包安装服务的位置"><a href="#（1）rpm包安装服务的位置" class="headerlink" title="（1）rpm包安装服务的位置"></a><strong>（1）rpm包安装服务的位置</strong></h5><ul>
<li><strong>RPM 安装服务和源码包安装服务的区别就是安装位置的不同</strong><ul>
<li><strong>源码包安装在指定位置，一般是/usr/local/</strong> </li>
<li><strong>RPM 包安装在默认位置中</strong></li>
</ul>
</li>
<li><strong>/etc/init.d/    #启动脚本位置</strong></li>
<li><strong>/etc/sysconfig/    #初始化环境配置文件位置</strong></li>
<li><strong>/etc/    #配置文件位置</strong></li>
<li><strong>/etc/xinetd.conf    #xinetd配置文件</strong></li>
<li><strong>/etc/xinetd.d/    #基于xinetd服务的启动脚本</strong></li>
<li><strong>/var/lib/    #服务产生的数据放在这里</strong></li>
<li><strong>/var/log/    #日志</strong></li>
</ul>
<h5 id="（2）独立服务的启动"><a href="#（2）独立服务的启动" class="headerlink" title="（2）独立服务的启动"></a><strong>（2）独立服务的启动</strong></h5><ul>
<li><strong>/etc/rc.d/init.d/独立服务名 start|stop|status|restart</strong></li>
<li><strong>service 独立服务名 start|stop|restart|status</strong></li>
<li><strong>service –status-all</strong> <ul>
<li><strong>查询服务器全部已经安装的RPM包的服务的运行状态</strong></li>
<li><strong>CentOS7为systemctl list-unit-files</strong></li>
</ul>
</li>
</ul>
<h5 id="（3）独立的服务自启动"><a href="#（3）独立的服务自启动" class="headerlink" title="（3）独立的服务自启动"></a><strong>（3）独立的服务自启动</strong></h5><ul>
<li><p><strong>chkconfig [–level 运行级别] [独立服务名] [on|off]</strong></p>
<ul>
<li><strong>chkconfig –level 2345 htttpd on  #下次开机自启动apache</strong></li>
<li><strong>chkconfig –level 2345 htttpd off  #下次开机不自启动apache</strong></li>
</ul>
</li>
<li><p><strong>修改/etc/rc.d/rc.local文件</strong></p>
<p><strong>把“/etc/rc.d/init.d/ 独立服务名 start ”写入文件</strong></p>
</li>
<li><p><strong>使用ntsysv命令管理自启动</strong></p>
<p><strong>如果没有ntsysv命令，yum -y install ntsysv下载即可，不过这个也是红帽专有的</strong></p>
</li>
<li><p><strong><font color="red">tips:service 和 chkconfig 命令的功能在 Centos7 中好像都被抛弃了。被 systemctl 取代。</font></strong></p>
<p><strong><a href="https://blog.csdn.net/cds86333774/article/details/51165361">参考博文：Centos7 下的 systemctl 命令与 service 和 chkconfig</a></strong></p>
</li>
</ul>
<h4 id="12-2-2-基于xinetd服务的管理"><a href="#12-2-2-基于xinetd服务的管理" class="headerlink" title="12.2.2 基于xinetd服务的管理"></a><strong>12.2.2 基于xinetd服务的管理</strong></h4><p>​    <strong>Xinetd：即 extended internet daemon，是新一代的网络守护进程服务程序，又叫超级 Internet 服</strong></p>
<p><strong>务器，常用来管理多种轻量级 Internet 服务。Xinetd 提供类似于 inetd+tcp_wrapper 的功能，但是更</strong></p>
<p><strong>加强大和安全</strong></p>
<p>​    <strong>Telnet协议是TCP/IP协议族中的一员，是Internet远程 登录服务的标准协议和主要方式。不过现在已经被ssh替代。</strong></p>
<h5 id="（1）安装-xinetd-与-telnet"><a href="#（1）安装-xinetd-与-telnet" class="headerlink" title="（1）安装 xinetd 与 telnet"></a><strong>（1）安装 xinetd 与 telnet</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# yum -y install xinetd </span><br><span class="line">[root@localhost ~]# yum -y install telnet-server</span><br></pre></td></tr></table></figure>



<h5 id="（2）xinetd服务的启动"><a href="#（2）xinetd服务的启动" class="headerlink" title="（2）xinetd服务的启动"></a><strong>（2）xinetd服务的启动</strong></h5><ul>
<li><strong>进入配置文件，把disable=yes改为no</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service telnet 	# 服务的名称为 telnet</span><br><span class="line">&#123; </span><br><span class="line">flags = REUSE 	# 标志为 REUSE，设定 TCP/IP socket 可重用</span><br><span class="line">socket_type = stream 	# 使用 TCP 协议数据包 </span><br><span class="line">wait = no 	# 允许多个连接同时连接 </span><br><span class="line">user = root	# 启动服务的用户为 root </span><br><span class="line">server = /usr/sbin/in.telnetd 	# 服务的启动程序 </span><br><span class="line">log_on_failure += USERID 	# 登陆失败后，记录用户的 ID </span><br><span class="line">disable = no 	# 服务不启动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>重启xinetd服务</strong></p>
<p><strong>service xinetd restart</strong></p>
</li>
</ul>
<h5 id="（3）xinetd服务的自启动"><a href="#（3）xinetd服务的自启动" class="headerlink" title="（3）xinetd服务的自启动"></a><strong>（3）xinetd服务的自启动</strong></h5><ul>
<li><p><strong>chkconfig telnet on</strong></p>
</li>
<li><p><strong>ntsysv</strong></p>
<p><strong>基于xinetd的服务自启动和启动是相通的，非常不适合做服务器管理，开启自启动，服务自动启动。关闭自启动，服务也关闭 。</strong></p>
</li>
</ul>
<h3 id="12-3-源码安装服务的管理"><a href="#12-3-源码安装服务的管理" class="headerlink" title="12.3 源码安装服务的管理"></a><strong>12.3 源码安装服务的管理</strong></h3><ul>
<li><p><strong>源码包安装服务的启动</strong><br><strong>使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法。</strong><br><strong>/usr/local/apache2/bin/apachectl start|stop</strong></p>
</li>
<li><p><strong>源码包服务的自启动</strong><br><strong>vi /etc/rc.d/rc.local</strong><br><strong>加入</strong><br><strong>/usr/local/apache2/bin/apachectl start</strong></p>
</li>
<li><p><strong>让源码包服务被服务管理命令识别</strong><br><strong>让源码包的apache服务能被service命令管理启动</strong><br><strong>ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache</strong></p>
</li>
<li><p><strong>让源码包的apache服务能被chkconfig与 ntsysv命令管理自启动</strong></p>
<ul>
<li><strong>在创建好软链接后，修改servic可以扫描的Apache文件</strong><br><strong>vi /etc/init.d/apache</strong><br><strong>#chkconfig: 35 86 76</strong><br><strong>#指定httpd脚本可以被chkconfig命令管理。格式是: chkconfig: 运行级别 启动顺序 关闭顺序</strong><br><strong>启动级别在/etc/rc.d/ 里面查看，rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d这六个就是0-6运行级别中文件的启动以及关闭顺序，启动顺序以S打头，关闭顺序以K打头，只需要找一个没有被占用的数字即可，不能和现有的顺序重叠。</strong><br><strong>#description: source package apache</strong><br><strong>#说明，内容随意</strong><br><strong>只需要写两句英文即可，两句都是注释，都得有#号，写在文件开始。</strong><br><strong>不太推荐修改，使用标准的启动方式就比较好</strong></li>
</ul>
</li>
</ul>
<h3 id="12-4-总结"><a href="#12-4-总结" class="headerlink" title="12.4 总结"></a><strong>12.4 总结</strong></h3><p> <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20200529123748236.png" alt="img"></strong> </p>
<h2 id="第十三章-Linux系统管理"><a href="#第十三章-Linux系统管理" class="headerlink" title="第十三章 Linux系统管理"></a><strong>第十三章 Linux系统管理</strong></h2><h3 id="13-1-进程管理"><a href="#13-1-进程管理" class="headerlink" title="13.1 进程管理"></a><strong>13.1 进程管理</strong></h3><h4 id="13-1-1-进程查看"><a href="#13-1-1-进程查看" class="headerlink" title="13.1.1 进程查看"></a><strong>13.1.1 进程查看</strong></h4><h5 id="（1）进程简介"><a href="#（1）进程简介" class="headerlink" title="（1）进程简介"></a><strong>（1）进程简介</strong></h5><p>​    <strong>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。</strong></p>
<h5 id="（2）进程管理的作用"><a href="#（2）进程管理的作用" class="headerlink" title="（2）进程管理的作用"></a><strong>（2）进程管理的作用</strong></h5><ul>
<li><p><strong>判断服务器健康状态</strong></p>
</li>
<li><p><strong>查看系统中所有进程</strong></p>
</li>
<li><p><strong>杀死进程</strong></p>
</li>
</ul>
<h5 id="（3）查看系统中所有进程"><a href="#（3）查看系统中所有进程" class="headerlink" title="（3）查看系统中所有进程"></a><strong>（3）查看系统中所有进程</strong></h5><ul>
<li><p><strong>ps aux</strong><br><strong>查看系统中所有进程，使用BSD操作系统格式。(Unix)</strong></p>
</li>
<li><p><strong>ps -le</strong><br><strong>查看系统中所有进程，使用Linux标准命令格式。</strong></p>
</li>
<li><p><strong>ps aux 输出信息</strong></p>
<ul>
<li><strong>USER:该进程是由哪个用户产生的;</strong></li>
<li><strong>PID:进程的ID号;</strong></li>
<li><strong>%CPU:该进程占用CPU资源的百分比，占用越高，进程 越耗费资源;</strong></li>
<li><strong>%MEM:该进程占用物理内存的百分比，占用越高，进程 越耗费资源;</strong></li>
<li><strong>VSZ:该进程占用虚拟内存的大小，单位KB;</strong></li>
<li><strong>RSS:该进程占用实际物理内存的大小，单位KB;</strong></li>
<li><strong>TTY:该进程是在哪个终端中运行的。其中tty1-tty7代表 本地控制台终端，tty1-tty6是本地的字符界面终端，tty7是图形终端。pts/0-255代表虚拟终端。</strong></li>
<li><strong>STAT:进程状态。常见的状态有:R:运行、S:睡眠 、T:停止状态、s:包含子进程、+:位于后台</strong></li>
<li><strong>START:该进程的启动时间</strong></li>
<li><strong>TIME:该进程占用CPU的运算时间，注意不是系统时间</strong></li>
<li><strong>COMMAND:产生此进程的命令名</strong></li>
</ul>
</li>
<li><p><strong>查看系统健康状态</strong><br><strong>top [选项]</strong></p>
<ul>
<li><strong>-d 秒数: 指定top命令每隔几秒更新。默认是3秒 在top命令的交互模式当中可以执行的命令</strong></li>
<li><strong>?或h: 显示交互模式的帮助</strong></li>
<li><strong>P: 以CPU使用率排序，默认就是此项</strong></li>
<li><strong>M: 以内存的使用率排序</strong></li>
<li><strong>N: 以PID排序</strong></li>
<li><strong>q: 退出top</strong></li>
</ul>
</li>
</ul>
<p><strong>第一行信息为任务队列信息</strong> </p>
<table>
<thead>
<tr>
<th><strong>内容</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>12:26:46</strong></td>
<td><strong>系统当前时间</strong></td>
</tr>
<tr>
<td><strong>up 1 day, 13:32</strong></td>
<td><strong>系统的运行时间，本机已经运行1天 13小时32分钟</strong></td>
</tr>
<tr>
<td><strong>2 users</strong></td>
<td><strong>当前登录了两个用户</strong></td>
</tr>
<tr>
<td><strong>load average: 0.00, 0.00, 0.00</strong></td>
<td><strong>系统在之前1分钟，5分钟，15分钟 的平均负载。一般认为小于1时，负 载较小。如果大于1，系统已经超出 负荷。</strong></td>
</tr>
</tbody></table>
<p><strong>第二行为进程信息</strong></p>
<table>
<thead>
<tr>
<th><strong>内容</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Tasks: 95 total</strong></td>
<td><strong>系统中的进程总数</strong></td>
</tr>
<tr>
<td><strong>1 running</strong></td>
<td><strong>正在运行的进程数</strong></td>
</tr>
<tr>
<td><strong>94 sleeping</strong></td>
<td><strong>睡眠的进程</strong></td>
</tr>
<tr>
<td><strong>0 stopped</strong></td>
<td><strong>正在停止的进程</strong></td>
</tr>
<tr>
<td><strong>0 zombie</strong></td>
<td><strong>僵尸进程。如果不是0，需要手工检查僵尸进程</strong></td>
</tr>
</tbody></table>
<p><strong>第三行为CPU信息</strong></p>
<table>
<thead>
<tr>
<th><strong>内容</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cpu(s): 0.1%us</strong></td>
<td><strong>用户模式占用的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.1%sy</strong></td>
<td><strong>系统模式占用的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.0%ni</strong></td>
<td><strong>改变过优先级的用户进程占用的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>99.7%id</strong></td>
<td><strong>空闲CPU的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.1%wa</strong></td>
<td><strong>等待输入/输出的进程的占用CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.0%hi</strong></td>
<td><strong>硬中断请求服务占用的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.1%si</strong></td>
<td><strong>软中断请求服务占用的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.0%st</strong></td>
<td><strong>st(Steal time)虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比。</strong></td>
</tr>
</tbody></table>
<p><strong>第四行为物理内存信息</strong></p>
<table>
<thead>
<tr>
<th><strong>内容</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mem: 625344k total</strong></td>
<td><strong>物理内存的总量，单位KB</strong></td>
</tr>
<tr>
<td><strong>571504k used</strong></td>
<td><strong>已经使用的物理内存数量</strong></td>
</tr>
<tr>
<td><strong>53840k free</strong></td>
<td><strong>空闲的物理内存数量，我们使用的是虚 拟机，总共只分配了628MB内存，所以 只有53MB的空闲内存了</strong></td>
</tr>
<tr>
<td><strong>65800k buffers</strong></td>
<td><strong>作为缓冲的内存数量</strong></td>
</tr>
</tbody></table>
<p><strong>第五行为交换分区(swap)信息</strong></p>
<table>
<thead>
<tr>
<th><strong>内容</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Swap: 524280k total</strong></td>
<td><strong>交换分区(虚拟内存)的总大小</strong></td>
</tr>
<tr>
<td><strong>0k used</strong></td>
<td><strong>已经使用的交互分区的大小</strong></td>
</tr>
<tr>
<td><strong>524280k free</strong></td>
<td><strong>空闲交换分区的大小</strong></td>
</tr>
<tr>
<td><strong>409280k cached</strong></td>
<td><strong>作为缓存的交互分区的大小</strong></td>
</tr>
</tbody></table>
<h5 id="（4）查看进程树"><a href="#（4）查看进程树" class="headerlink" title="（4）查看进程树"></a><strong>（4）查看进程树</strong></h5><ul>
<li><strong>pstree [选项]</strong><ul>
<li><strong>-p: 显示进程的PID</strong></li>
<li><strong>-u: 显示进程的所属用户</strong></li>
</ul>
</li>
</ul>
<h4 id="13-1-2-终止进程"><a href="#13-1-2-终止进程" class="headerlink" title="13.1.2 终止进程"></a><strong>13.1.2 终止进程</strong></h4><h5 id="（1）kill命令"><a href="#（1）kill命令" class="headerlink" title="（1）kill命令"></a><strong>（1）kill命令</strong></h5><ul>
<li><p><strong>kill [信号代号] PID</strong> </p>
</li>
<li><p> <strong>kill –l    # 查看可用的进程信号</strong> </p>
</li>
<li><p> <strong>常用进程信号表</strong> </p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>信号代号</strong></th>
<th><strong>信号名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><strong>SIGHUP</strong></td>
<td><strong>该信号让进程立即关闭，然后重新读取配置文件之后重启。</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>SIGINT</strong></td>
<td><strong>程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷 键。</strong></td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><strong>SIGFPE</strong></td>
<td><strong>在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。</strong></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td><strong>SIGKILL</strong></td>
<td><strong>用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。 一般用于强制终止进程。</strong></td>
</tr>
<tr>
<td><strong>14</strong></td>
<td><strong>SIGALRM</strong></td>
<td><strong>时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数 使用该信号。</strong></td>
</tr>
<tr>
<td><strong>15</strong></td>
<td><strong>SIGTERM</strong></td>
<td><strong>正常结束进程的信号，kill命令的默认信号。有时如果进程已 经发生问题，这个信号是无法正常终止进程的，我们才会尝 试SIGKILL信号，也就是信号9。</strong></td>
</tr>
<tr>
<td><strong>18</strong></td>
<td><strong>SIGCONT</strong></td>
<td><strong>该信号可以让暂停的进程恢复执行，本信号不能被阻断。</strong></td>
</tr>
<tr>
<td><strong>19</strong></td>
<td><strong>SIGSTOP</strong></td>
<td><strong>该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号 不能被阻断。</strong></td>
</tr>
</tbody></table>
<h5 id="（2）-killall命令"><a href="#（2）-killall命令" class="headerlink" title="（2） killall命令"></a><strong>（2） killall命令</strong></h5><ul>
<li><strong>killall [选项][信号代号] 进程名</strong><ul>
<li><strong>按照进程名杀死进程</strong></li>
<li><strong>-i: 交互式，询问是否要杀死某个进程</strong></li>
<li><strong>-I: 忽略进程名的大小写</strong><br><strong>和kill不一样，他加进程名</strong></li>
</ul>
</li>
</ul>
<h5 id="（3）-pkill命令"><a href="#（3）-pkill命令" class="headerlink" title="（3） pkill命令"></a><strong>（3） pkill命令</strong></h5><ul>
<li><p><strong>pkill [选项] [信号] 进程名</strong></p>
<ul>
<li><p><strong>按照进程名终止进程</strong></p>
</li>
<li><p><strong>-t 终端号: 按照终端号踢出用户</strong></p>
<p><strong>按照终端号踢出用户</strong></p>
<ul>
<li><strong>w</strong><br><strong>使用w命令查询本机已经登录的用户</strong></li>
<li><strong>pkill -t -9 pts/1</strong><br><strong>强制杀死从pts/1虚拟终端登录的进程</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-2-工作管理"><a href="#13-2-工作管理" class="headerlink" title="13.2 工作管理"></a><strong>13.2 工作管理</strong></h3><h4 id="13-2-1-把进程放入后台"><a href="#13-2-1-把进程放入后台" class="headerlink" title="13.2.1 把进程放入后台"></a><strong>13.2.1 把进程放入后台</strong></h4><ul>
<li><p> <strong>命令后面加&amp;</strong> </p>
</li>
<li><p><strong>例子：</strong><br><strong>tar -zcf etc.tar.gz /etc &amp; （后台运行）</strong><br><strong>但是像top，vim和用户交互的命令放在后台自动停止，不再运行</strong></p>
</li>
<li><p><strong>运行界面按按ctrl+z</strong></p>
<ul>
<li><strong>例子：</strong><br><strong>top</strong><br><strong>在top命令执行的过程中，按ctrl+z快捷键放入后台（后台暂停）</strong></li>
</ul>
</li>
</ul>
<h4 id="13-2-2-查看后台的工作"><a href="#13-2-2-查看后台的工作" class="headerlink" title="13.2.2 查看后台的工作"></a><strong>13.2.2 查看后台的工作</strong></h4><ul>
<li><strong>jobs [-l]</strong><ul>
<li><strong>-l 显示工作的PID</strong><br><strong>注意：“+”号代表最近一个放入后台的工作，也是工作恢复时，默认恢复的工作。“-”号代表倒数第二个放入后台的工作</strong></li>
</ul>
</li>
</ul>
<h4 id="13-2-3-将后台暂停的工作恢复到前台执行"><a href="#13-2-3-将后台暂停的工作恢复到前台执行" class="headerlink" title="13.2.3 将后台暂停的工作恢复到前台执行"></a><strong>13.2.3 将后台暂停的工作恢复到前台执行</strong></h4><ul>
<li><strong>fg %工作号</strong><br><strong>%工作号：%号可以省略，但是注意工作号和PID到区别</strong></li>
</ul>
<h4 id="13-2-4-把后台暂停的工作恢复到后台执行"><a href="#13-2-4-把后台暂停的工作恢复到后台执行" class="headerlink" title="13.2.4  把后台暂停的工作恢复到后台执行"></a><strong>13.2.4  把后台暂停的工作恢复到后台执行</strong></h4><ul>
<li><strong>bg %工作号</strong><br><strong>注意：后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行</strong></li>
</ul>
<h3 id="13-3-系统资源查看"><a href="#13-3-系统资源查看" class="headerlink" title="13.3 系统资源查看"></a><strong>13.3 系统资源查看</strong></h3><ul>
<li><p><strong>vmstat命令监控系统资源</strong><br><strong>vmstat [刷新延时 刷新次数]</strong><br><strong>例子：</strong><br><strong>vmstat 1 3</strong></p>
</li>
<li><p><strong>dmesg开机时内核检测信息</strong><br><strong>dmesg</strong><br><strong>例子：</strong></p>
<p><strong>dmesg | grep CPU</strong></p>
</li>
<li><p><strong>free命令查看内存使用状态</strong><br><strong>free [-b|-k|-m|-g]</strong></p>
<ul>
<li><strong>-b: 以字节为单位显示</strong><br><strong>-k: 以KB为单位显示，默认就是以KB为单位显示</strong><br><strong>-m: 以MB为单位显示</strong><br><strong>-g: 以GB为单位显示</strong></li>
</ul>
</li>
<li><p><strong>缓存和缓冲的区别</strong><br><strong>简单来说缓存(cache)是用来加速数据 从硬盘中“读取”的，而缓冲(buffer) 是用来加速数据“写入”硬盘的。</strong></p>
</li>
</ul>
<ul>
<li><strong>查看CPU信息</strong><br><strong>cat /proc/cpuinfo</strong></li>
</ul>
<ul>
<li><strong>uptime命令</strong><br><strong>uptime</strong><br><strong>显示系统的启动时间和平均负载，也就是top命令的第一行。w命令也可以看到这个数据。</strong></li>
</ul>
<ul>
<li><strong>查看系统与内核相关信息</strong><br><strong>uname [选项]</strong></li>
</ul>
<ul>
<li><strong>-a: 查看系统所有相关信息;</strong><br><strong>-r: 查看内核版本;</strong><br><strong>-s: 查看内核名称。</strong></li>
</ul>
<ul>
<li><strong>判断当前系统的位数</strong><br><strong>没有直接的命令可以查看</strong><br><strong>只能通过查看系统外部命令的文件类型，顺带写出位数</strong><br><strong>file /bin/ls</strong></li>
</ul>
<ul>
<li><strong>查询当前Linux系统的发行版本</strong><br><strong>lsb_release -a</strong></li>
</ul>
<ul>
<li><strong>列出进程打开或使用的文件信息</strong><br><strong>lsof [选项]</strong><br><strong>列出进程调用或打开的文件的信息</strong><ul>
<li><strong>-c 字符串: 只列出以字符串开头的进程打开的文件</strong></li>
<li><strong>-u 用户名: 只列出某个用户的进程打开的文件</strong></li>
<li><strong>-p pid: 列出某个PID进程打开的文件</strong></li>
</ul>
</li>
</ul>
<h3 id="13-4-系统定时任务"><a href="#13-4-系统定时任务" class="headerlink" title="13.4 系统定时任务"></a><strong>13.4 系统定时任务</strong></h3><ul>
<li><p>crond服务管理与访问控制</p>
<ul>
<li>service crond restart 启动</li>
<li>chkconfig crond on 自启动</li>
</ul>
</li>
<li><p>用户的crontab设置<br>crontab [选项]</p>
<ul>
<li><p>-e: 编辑crontab定时任务<br>-l: 查询crontab任务<br>-r: 删除当前用户所有的crontab 任务 ，如果想删一个，-e进去之后删除</p>
</li>
<li><p>crontab -e 标准格式<br>进入crontab编辑界面。会打开vim编辑你的工作。</p>
<p>*****执行的任务<br>其中*号代表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个“*”</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个“*”</td>
<td>一天当中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个“*”</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个“*”</td>
<td>一年当中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个“*”</td>
<td>一周当中的星期几</td>
<td>0-7(0和7都代表星期日)</td>
</tr>
</tbody></table>
<p> <strong>这个表可以配合特殊符号使用：</strong> </p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间。比如第一个“*”就代表一小时中 每分钟都执行一次的意思。</td>
</tr>
<tr>
<td>，</td>
<td>代表不连续的时间。比如“0 8,12,16 * * * 命令”， 就代表在每天的8点0分，12点0分，16点0分都执 行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间范围。比如“0 5 * * 1-6命令”， 代表在周一到周六的凌晨5点0分执行命令</td>
</tr>
<tr>
<td>*/n</td>
<td>代表每隔多久执行一次。比如“*/10 * * * * 命 令”，代表每隔10分钟就执行一遍命令</td>
</tr>
</tbody></table>
<p><strong>例子：</strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>45 22 * * *</td>
<td>命令 在22点45分执行命令</td>
</tr>
<tr>
<td>0 17 * * 1</td>
<td>命令 每周1 的17点0分执行命令</td>
</tr>
<tr>
<td>0 5 1,15 * *</td>
<td>命令 每月1号和15号的凌晨5点0分执行命 令</td>
</tr>
<tr>
<td>40 4 * * 1-5</td>
<td>命令 每周一到周五的凌晨4点40分执行命 令</td>
</tr>
<tr>
<td>*/10 4 * * *</td>
<td>命令 每天的凌晨4点，每隔10分钟执行一 次命令</td>
</tr>
<tr>
<td>0 0 1,15 * 1</td>
<td>命令 每月1号和15号，每周1的0点0分都会 执行命令。注意:星期几和几号最好 不要同时出现，因为他们定义的都是 天。非常容易让管理员混乱。</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="第十四章-日志管理"><a href="#第十四章-日志管理" class="headerlink" title="第十四章 日志管理"></a>第十四章 日志管理</h2><h3 id="14-1-日志管理简介"><a href="#14-1-日志管理简介" class="headerlink" title="14.1 日志管理简介"></a>14.1 日志管理简介</h3><h4 id="14-1-1-日志服务"><a href="#14-1-1-日志服务" class="headerlink" title="14.1.1 日志服务"></a>14.1.1 日志服务</h4><ul>
<li><p>在CentOS 6.x中日志服务已经由rsyslogd取代了原先的syslogd服务。rsyslogd日志服务更加先进，功能更多。但是不论该服务的使用，还是日志文件的格式其实都是和syslogd服务相兼容的，所以学习起来基本和syslogd服务一致。</p>
</li>
<li><p>rsyslogd的新特点:</p>
<ul>
<li>基于TCP网络协议传输日志信息;</li>
<li>更安全的网络传输方式;</li>
<li>有日志消息的及时分析框架;</li>
<li>后台数据库;</li>
<li>配置文件中可以写简单的逻辑判断;</li>
<li>与syslog配置文件相兼容。</li>
</ul>
</li>
<li><p>确定服务启动</p>
<ul>
<li>ps aux | grep rsyslogd<br>查看服务是否启动</li>
<li>chkconfig –list | grep rsyslog<br>查看服务是否自启动</li>
<li>CentOS 7 变为 systrmctl list-unit-files | grep rsyslog</li>
</ul>
</li>
</ul>
<h4 id="14-1-2常见日志的作用"><a href="#14-1-2常见日志的作用" class="headerlink" title="14.1.2常见日志的作用"></a>14.1.2常见日志的作用</h4><table>
<thead>
<tr>
<th>日志文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/var/log/cron</td>
<td>记录了系统定时任务相关的日志。</td>
</tr>
<tr>
<td>/var/log/cups/</td>
<td>记录打印信息的日志</td>
</tr>
<tr>
<td>/var/log/dmesg</td>
<td>记录了系统在开机时内核自检的信息。也可以使用 dmesg命令直接查看内核自检信息。</td>
</tr>
<tr>
<td>/var/log/btmp</td>
<td>记录错误登录的日志。这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看，命令如下: lastbroot tty1 Tue Jun 4 22:38 - 22:38 (00:00) 有人在6月4日22:38使用root用户，在本地终端1登录错误</td>
</tr>
<tr>
<td>/var/log/lastlog</td>
<td>记录系统中所有用户最后一次的登录时间的日志。这个文件也是二进制文件，不能直接vi，而要使用lastlog命令查看。</td>
</tr>
<tr>
<td>/var/log/mailog</td>
<td>记录邮件信息。</td>
</tr>
<tr>
<td>/var/log/message</td>
<td>记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件</td>
</tr>
<tr>
<td>/var/log/secure</td>
<td>记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录。 比如说系统的登录，ssh的登录，su切换用户，sudo授权，甚至添加 用户和修改用户密码都会记录在这个日志文件中。</td>
</tr>
<tr>
<td>/var/log/wtmp</td>
<td>永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、 关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需 要使用last命令来查看。</td>
</tr>
<tr>
<td>/var/run/utmp</td>
<td>记录当前已经登录的用户的信息。这个文件会随着用户的登录和注 销而不断变化，只记录当前登录用户的信息。同样这个文件不能直 接vi，而要使用w，who，users等命令来查询。</td>
</tr>
</tbody></table>
<p> <strong>除了系统默认的日志之外，采用RPM方 式安装的系统服务也会默认把日志记录在/var/log/目录中(源码包安装的服务日志 是在源码包指定目录中)。不过这些日志不是由rsyslogd服务来记录和管理的，而 是各个服务使用自己的日志管理文档来记录自身日志。</strong> </p>
<table>
<thead>
<tr>
<th>日志文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/var/log/httpd/</td>
<td>RPM包安装的apache服务的默认日志目录</td>
</tr>
<tr>
<td>/var/log/mail/</td>
<td>RPM包安装的邮件服务的额外日志目录</td>
</tr>
<tr>
<td>/var/log/samba/</td>
<td>RPM包安装的samba服务的日志目录</td>
</tr>
<tr>
<td>/var/log/sssd/</td>
<td>守护进程安全服务目录</td>
</tr>
</tbody></table>
<h3 id="14-2-rsyslogd-日志服务"><a href="#14-2-rsyslogd-日志服务" class="headerlink" title="14.2 rsyslogd 日志服务"></a>14.2 rsyslogd 日志服务</h3><h4 id="14-2-1-日志文件格式"><a href="#14-2-1-日志文件格式" class="headerlink" title="14.2.1 日志文件格式"></a>14.2.1 日志文件格式</h4><ul>
<li><p>基本日志格式包含以下四列:</p>
<ul>
<li>事件产生的时间;</li>
<li>发生事件的服务器的主机名;</li>
<li>产生事件的服务名或程序名;</li>
<li>事件的具体信息。</li>
</ul>
</li>
<li><p>/etc/rsyslog.conf配置文件<br>写入这个文件可以自定义需要记录日志的程序</p>
<ul>
<li>authpriv.* /var/log/secure</li>
<li>服务名称[连接符号]日志等级 日志记录位置<br>认证相关服务.所有日志等级记录在/var/log/secure日志中</li>
</ul>
</li>
<li><p>服务名称</p>
<table>
<thead>
<tr>
<th>服务名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>auth</td>
<td>安全和认证相关消息(不推荐使用authpriv替代)</td>
</tr>
<tr>
<td>authpriv</td>
<td>安全和认证相关消息(私有的)</td>
</tr>
<tr>
<td>cron</td>
<td>系统定时任务cront和at产生的日志</td>
</tr>
<tr>
<td>daemon</td>
<td>和各个守护进程相关的日志</td>
</tr>
<tr>
<td>ftp</td>
<td>ftp守护进程产生的日志</td>
</tr>
<tr>
<td>kern</td>
<td>内核产生的日志(不是用户进程产生的)</td>
</tr>
<tr>
<td>local0-local7</td>
<td>为本地使用预留的服务</td>
</tr>
<tr>
<td>lpr</td>
<td>打印产生的日志</td>
</tr>
<tr>
<td>mail</td>
<td>邮件收发信息</td>
</tr>
<tr>
<td>news</td>
<td>与新闻服务器相关的日志</td>
</tr>
<tr>
<td>syslog</td>
<td>有syslogd服务产生的日志信息(虽然服务名 称已经改为rsyslogd，但是很多配置都还是沿 用了syslogd的，这里并没有修改服务名)。</td>
</tr>
<tr>
<td>user</td>
<td>用户等级类别的日志信息</td>
</tr>
<tr>
<td>uucp</td>
<td>uucp子系统的日志信息，uucp是早期linux系</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>连接符号</p>
<ul>
<li>连接符号可以识别为:<ul>
<li>“*”代表所有日志等级，比如:“authpriv.*”代表authpriv认证信息服务产生的日志，所有的日志等级都记录</li>
<li>“.”代表只要比后面的等级高的(包含该等级)日志都记录下来。比如:“cron.info”代表cron服务产生的日志，只要日 志等级大于等于info级别，就记录</li>
<li>“.=”代表只记录所需等级的日志，其他等级的都不记录。比 如:“*.=emerg”代表人和日志服务产生的日志，只要等级是 emerg等级就记录。这种用法及少见，了解就好</li>
<li>“.!”代表不等于，也就是除了该等级的日志外，其他等级的 日志都记录。</li>
</ul>
</li>
</ul>
</li>
<li><p>日志等级</p>
<table>
<thead>
<tr>
<th>等级名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>debug</td>
<td>一般的调试信息说明</td>
</tr>
<tr>
<td>info</td>
<td>基本的通知信息</td>
</tr>
<tr>
<td>notice</td>
<td>普通信息，但是有一定的重要性</td>
</tr>
<tr>
<td>warning</td>
<td>警告信息，但是还不回影响到服务或系统的运行</td>
</tr>
<tr>
<td>err</td>
<td>错误信息，一般达到err等级的信息以及可以影响到服务或系统的运行了。</td>
</tr>
<tr>
<td>crit</td>
<td>临界状况信息，比err等级还要严重</td>
</tr>
<tr>
<td>alert</td>
<td>警告状态信息，比crit还要严重。必须立即采取行动</td>
</tr>
<tr>
<td>emerg</td>
<td>疼痛等级信息，系统已经无法使用了</td>
</tr>
</tbody></table>
</li>
<li><p>日志记录位置</p>
<ul>
<li>日志文件的绝对路径，如“/var/log/secure”</li>
<li>系统设备文件，如“/dev/lp0”</li>
<li>转发给远程主机，如“@192.168.0.210:514”<br>用户名，如“root”</li>
<li>忽略或丢弃日志，如“~”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="14-3-日志轮替"><a href="#14-3-日志轮替" class="headerlink" title="14.3 日志轮替"></a>14.3 日志轮替</h3><h4 id="14-3-1-日志文件的命名规则"><a href="#14-3-1-日志文件的命名规则" class="headerlink" title="14.3.1 日志文件的命名规则"></a>14.3.1 日志文件的命名规则</h4><ul>
<li><p>如果配置文件中拥有“dateext”参数，那么日志会用日期来作为日志文件的后缀， 例如“secure-20130605”。这样的话日志文件名不会重叠，所以也就不需要日志文 件的改名，只需要保存指定的日志个数， 删除多余的日志文件即可。</p>
</li>
<li><p>如果配置文件中没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日志 轮替时，当前的“secure”日志会自动改名为 “secure.1”，然后新建“secure”日志，用来 保存新的日志。当第二次进行日志轮替时， “secure.1”会自动改名为“secure.2”，当前的 “secure”日志会自动改名为“secure.1”，然 后也会新建“secure”日志，用来保存新的日志 ，以此类推。</p>
</li>
</ul>
<h4 id="14-3-2-logrotate配置文件"><a href="#14-3-2-logrotate配置文件" class="headerlink" title="14.3.2  logrotate配置文件"></a>14.3.2  logrotate配置文件</h4><table>
<thead>
<tr>
<th>参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>daily</td>
<td>日志的轮替周期是每天</td>
</tr>
<tr>
<td>weekly</td>
<td>日志的轮替周期是每周</td>
</tr>
<tr>
<td>monthly</td>
<td>日志的轮替周期是每月</td>
</tr>
<tr>
<td>rotate 数字</td>
<td>保留的日志文件的个数。0指没有备份</td>
</tr>
<tr>
<td>compress</td>
<td>日志轮替时，旧的日志进行压缩</td>
</tr>
<tr>
<td>create mode owner group</td>
<td>建立新日志，同时指定新日志的权限与所有者和 所属组。如create 0600 root utmp</td>
</tr>
<tr>
<td>mail address</td>
<td>当日志轮替时，输出内容通过邮件发送到指定的 邮件地址。如mail <a href="mailto:&#49;&#x37;&#55;&#49;&#53;&#54;&#54;&#54;&#55;&#57;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#109;">&#49;&#x37;&#55;&#49;&#53;&#54;&#54;&#54;&#55;&#57;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>missingok</td>
<td>如果日志不存在，则忽略该日志的警告信息</td>
</tr>
<tr>
<td>notifempty</td>
<td>如果日志为空文件，则不进行日志轮替</td>
</tr>
<tr>
<td>minsize 大小</td>
<td>日志轮替的最小值。也就是日志一定要达到这个 最小值才会轮替，否则就算时间达到也不轮替size 大小 日志只有大于指定大小才进行日志轮替，而不是 按照时间轮替。如size 100k</td>
</tr>
<tr>
<td>dateext</td>
<td>使用日期作为日志轮替文件的后缀。如secure- 20130605</td>
</tr>
</tbody></table>
<p> 在/etc/logrotate.conf 配置文件里修改轮替规则，下面大括号外面的变量相当于局部变量，而大括号里面的相当于全局变量，只有大括号里面没有声明，外面的才生效，一旦大括号声明了，大括号里面的优先级高于外面，优先生效 </p>
<h4 id="14-3-3-把apache日志加入轮替"><a href="#14-3-3-把apache日志加入轮替" class="headerlink" title="14.3.3  把apache日志加入轮替"></a>14.3.3  把apache日志加入轮替</h4><p>vi /etc/logrotate.conf /usr/local/apache2/logs/access_log<br>{<br>daily<br>create<br>rotate 30<br>}<br>一般只有源码包安装才需要这样加入，RPM包在安装时候会自动做日志</p>
<p>logrotate命令<br>logrotate [选项] 配置文件名<br>如果此命令没有选项，则会按照配置文件中的条件进行</p>
<h4 id="14-3-4-logrotate-命令"><a href="#14-3-4-logrotate-命令" class="headerlink" title="14.3.4  logrotate 命令"></a>14.3.4  logrotate 命令</h4><ul>
<li>logrotate [选项] 配置文件名<ul>
<li>-v:显示日志轮替过程。加了-v选项，会显示日志的轮 替的过程</li>
<li>-f: 强制进行日志轮替。不管日志轮替的条件是否已经 符合，强制配置文件中所有的日志进行轮替</li>
</ul>
</li>
</ul>
<h2 id="第十五章-启动管理"><a href="#第十五章-启动管理" class="headerlink" title="第十五章 启动管理"></a>第十五章 启动管理</h2><h3 id="15-1-CentOS-6-x启动管理"><a href="#15-1-CentOS-6-x启动管理" class="headerlink" title="15.1 CentOS 6.x启动管理"></a>15.1 CentOS 6.x启动管理</h3><h4 id="15-1-1-系统运行级别"><a href="#15-1-1-系统运行级别" class="headerlink" title="15.1.1 系统运行级别"></a>15.1.1 系统运行级别</h4><ul>
<li><p>运行级别</p>
<table>
<thead>
<tr>
<th>运行级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>单用户模式，可以想象为windows的安全模式，主要用 于系统修复</td>
</tr>
<tr>
<td>2</td>
<td>不完全的命令行模式，不含NFS服务</td>
</tr>
<tr>
<td>3</td>
<td>完全的命令行模式，就是标准字符界面</td>
</tr>
<tr>
<td>4</td>
<td>系统保留</td>
</tr>
<tr>
<td>5</td>
<td>图形模式</td>
</tr>
<tr>
<td>6</td>
<td>重启动</td>
</tr>
</tbody></table>
</li>
<li><p>运行级别命令</p>
<ul>
<li>runlevel<br>查看运行级别命令</li>
<li>init 运行级别<br>改变运行级别命令</li>
</ul>
</li>
<li><p>修改系统默认运行级别<br>vim /etc/inittab<br>id:3:initdefault:<br>系统开机后直接进入哪个运行级别，就把数字改为对应的数字 </p>
</li>
</ul>
<h4 id="15-1-2-系统启动过程"><a href="#15-1-2-系统启动过程" class="headerlink" title="15.1.2  系统启动过程"></a>15.1.2  系统启动过程</h4><p> <img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020053015380272.png" alt="系统启动流程"> </p>
<ul>
<li><p>initramfs内存文件系统<br>CentOS 6.x中使用initramfs内存文件系统 取代了CentOS 5.x中的initrd RAM Disk。 他们的作用类似，可以通过启动引导程序加载到内存中，然后加载启动过程中所需要的内核模块，比如USB、SATA、SCSI 硬盘的驱动和LVM、RAID文件系统的驱动</p>
</li>
<li><p>一个实验看initramfs文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  mkdir /tmp/initramfs</span><br><span class="line">  # 建立测试目录</span><br><span class="line">  cp /boot/initramfs-2.6.32-279.el6.i686.img /tmp/initramfs/ </span><br><span class="line">  # 复制initramfs文件</span><br><span class="line">  cd /tmp/initramfs/</span><br><span class="line">  file initramfs-2.6.32-279.el6.i686.img</span><br><span class="line">  mv initramfs-2.6.32-279.el6.i686.img initramfs-2.6.32-279.el6.i686.img.gz</span><br><span class="line">  # 修改文件的后缀名为.gz</span><br><span class="line">  gunzip initramfs-2.6.32-279.el6.i686.img.gz</span><br><span class="line">  # 解压缩</span><br><span class="line">file initramfs-2.6.32-279.el6.i686.img</span><br><span class="line">  cpio -ivcdu &lt; initramfs-2.6.32-279.el6.i686.img</span><br><span class="line">  # 解读cpio文件</span><br></pre></td></tr></table></figure></li>
<li><p>调用/etc/init/rcS.conf配置文件<br>主要功能是两个:</p>
<ul>
<li>先调用/etc/rc.d/rc.sysinit，然后由 /etc/rc.d/rc.sysinit配置文件进行Linux系统初始化。</li>
<li>然后再调用/etc/inittab，然后由/etc/inittab配 置文件确定系统的默认运行级别。</li>
</ul>
</li>
<li><p>由/etc/rc.d/rc.sysinit初始化</p>
<p>1、获得网络环境<br>2、挂载设备<br>3、开机启动画面Plymouth(取替了过往的 RHGB)<br>4、判断是否启用SELinux<br>5、显示于开机过程中的欢迎画面<br>6、初始化硬件<br>7、用户自定义模块的加载<br>8、配置内核的参数<br>9、设置主机名<br>10、同步存储器<br>11、设备映射器及相关的初始化<br>12、初始化软件磁盘阵列(RAID)<br>13、初始化 LVM 的文件系统功能<br>14、检验磁盘文件系统(fsck)<br>15、设置磁盘配额(quota)<br>16、重新以可读写模式挂载系统磁盘<br>17、更新quota(非必要)<br>18、启动系统虚拟随机数生成器<br>19、配置机器(非必要)<br>20、清除开机过程当中的临时文件<br>21、创建ICE目录<br>22、启动交换分区(swap)<br>23、将开机信息写入/var/log/dmesg文件中</p>
</li>
<li><p>调用/etc/rc.d/rc文件<br>运行级别参数传入/etc/rc.d/rc这个脚本之 后，由这个脚本文件按照不同的运行级别启动/etc/rc[0-6].d/目录中的相应的程序</p>
<ul>
<li>/etc/rc3.d/K??开头的文件(??是数字)，会按照数字顺序依次关闭</li>
<li>/etc/rc3.d/S??开头的文件(??是数字)，会 按照数字顺序依次启动</li>
</ul>
</li>
</ul>
<h3 id="15-2-启动引导程序grub"><a href="#15-2-启动引导程序grub" class="headerlink" title="15.2 启动引导程序grub"></a>15.2 启动引导程序grub</h3><h4 id="15-2-1-Grub配置文件"><a href="#15-2-1-Grub配置文件" class="headerlink" title="15.2.1 Grub配置文件"></a>15.2.1 Grub配置文件</h4><ul>
<li> <strong>grub中分区表示</strong> </li>
</ul>
<table>
<thead>
<tr>
<th>硬盘</th>
<th>分区</th>
<th>Linux中设备文件 名</th>
<th>Grub中设备文件名</th>
</tr>
</thead>
<tbody><tr>
<td>第一块SCSI硬盘</td>
<td>第一个主分区</td>
<td>/dev/sda1</td>
<td>hd(0,0)</td>
</tr>
<tr>
<td>第一块SCSI硬盘</td>
<td>第二个主分区</td>
<td>/dev/sda2</td>
<td>hd(0,1)</td>
</tr>
<tr>
<td>第一块SCSI硬盘</td>
<td>扩展分区</td>
<td>/dev/sda3</td>
<td>hd(0,2)</td>
</tr>
<tr>
<td>第一块SCSI硬盘</td>
<td>第一个逻辑分区</td>
<td>/dev/sda5</td>
<td>hd(0,4)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>第一个主分区</td>
<td>/dev/sdb1</td>
<td>hd(1,0)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>第二个主分区</td>
<td>/dev/sdb2</td>
<td>hd(1,1)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>扩展分区</td>
<td>/dev/sdb3</td>
<td>hd(1,2)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>第一个逻辑</td>
<td>/dev/sdb5</td>
<td>hd(1,4)</td>
</tr>
</tbody></table>
<ul>
<li>grub配置文件 vi /boot/grub/grub.conf<ul>
<li>default=0 默认启动第一个系统</li>
<li>timeout=5 等待时间，默认是5秒</li>
<li>splashimage=(hd0,0)/grub/splash.xpm.gz<br>这里是指定grub启动时的背景图像文件的保存位置的</li>
<li>hiddenmenu 隐藏菜单</li>
<li>在CentOS7中为vim /etc/default/grub</li>
<li>title CentOS (2.6.32-279.el6.i686) t itle就是标题的意思</li>
<li>root (hd0,0) 是指启动程序的保存分区</li>
<li>kernel /vmlinuz-2.6.32-279.el6.i686 ro root=UUID=b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet<br>定义内核加载时的选项</li>
<li>initrd /initramfs-2.6.32-279.el6.i686.img 指定了initramfs内存文件系统镜像文件的所在位置</li>
</ul>
</li>
</ul>
<h4 id="15-2-2-Grub加密与字符界面分辨率调整"><a href="#15-2-2-Grub加密与字符界面分辨率调整" class="headerlink" title="15.2.2 Grub加密与字符界面分辨率调整"></a>15.2.2 Grub加密与字符界面分辨率调整</h4><ul>
<li><p>在开机选择内核界面可以按e进入里面破解root密码，这个时候为了安全，便需要给grub加密才能进入按e界面</p>
</li>
<li><p>grub加密<br>命令：<br>grub-md5-crypt<br>生成加密密码串<br>vi /boot/grub/grub.conf<br>在splashimage=（hd0，0）这一行前面写入<br>password –md5 刚刚生产的密码串<br>Password选项放在整体设置处<br>重启就可以了<br>CentOS 7.2以后使用 grub2-setpassword 直接设置密码</p>
</li>
<li><p>纯字符界面的分辨率调整<br>查询内核是否支持分辨率调整<br>grep “CONFIG_FRAMEBUFFER_CONSOLE” /boot/config-3.10.0-1127.el7.x86_64<br>显示 CONFIG_FRAMEBUFFER_CONSOLE=y<br>就为可以调整</p>
</li>
<li><p>再输入命令：<br>vim /boot/grub/grub.conf<br>内核的选项文件中<br>Kernel /vmlinuz- ******<em>这句话后面加入 vga=791，便是调整1024</em>768 16位的分辨率，具体数字对应分辨率见下表：</p>
<table>
<thead>
<tr>
<th>色深</th>
<th>640*480</th>
<th>800*600</th>
<th>1024*768</th>
<th>1280*1024</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>769</td>
<td>771</td>
<td>773</td>
<td>775</td>
</tr>
<tr>
<td>15位</td>
<td>784</td>
<td>787</td>
<td>790</td>
<td>793</td>
</tr>
<tr>
<td>16位</td>
<td>785</td>
<td>788</td>
<td>791</td>
<td>794</td>
</tr>
<tr>
<td>32位</td>
<td>786</td>
<td>789</td>
<td>792</td>
<td>795</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="15-3-系统修复模式"><a href="#15-3-系统修复模式" class="headerlink" title="15.3 系统修复模式"></a>15.3 系统修复模式</h3><ul>
<li><p>单用户模式<br>在登陆选择内核界面，按e键进入内核选项</p>
</li>
<li><p>单用户模式常见的错误修复</p>
<ul>
<li>遗忘root密码</li>
<li>修改系统默认运行级别</li>
</ul>
</li>
<li><p>修改密码：<br>CentOS7<br>找到linux16 这一行 在CN.UTF-8 后面加入<br>rd.break console=tty0<br>然后按ctrl+x<br>然后依次输入：<br>mount -o remount,rw /sysroot<br>chroot /sysroot/<br>passwd root 或者 echo 密码 | passwd –stdin root<br>在这之后会出现很多小方块 这行小方块是中文编码问题，不用管它。输一次密码回车，再输一次确认密码，回车。<br>接着输入：<br>touch /.autorelabel<br>sync<br>exit<br>exit<br>重启就OK了，使用新密码登陆</p>
</li>
<li><p>光盘修复模式<br>在忘记了grub密码的时候可以使用这个模式<br>在虚拟机中放入光盘iso文件，在虚拟机VMware界面读条的时候，快速按F2键，苹果系统可按fn+F2，进入刚开始学习安装的界面之后，选择上面第四栏BOOT，调到光盘启动CR-Drive为首选(按+号调节)，F10保存。在安装节目选第三项Troublesooting 回车，选择第二项Rescue a CentOS system 回车，选择2 Shell模式 回车 回车 ，此时根目录已经被挂载到光盘下 /mnt/sysimage目录下<br>chroot /mnt/sysimage #改变主目录<br>grub2-setpassword<br>输入新密码即可</p>
</li>
<li><p>重要系统文件丢失，导致系统无法启动<br>假设丢了etc/inittab 文件，你可以在其他同版本的Linux查询到这个文件所在的包<br>chroot /mnt/sysimage #改变主目录<br>cd /root<br>rpm -qf /etc/inittab #查询下/etc/inittab文件属于哪个包。<br>mkdir /mnt/cdrom #建立挂载点<br>mount /dev/sr0 /mnt/cdrom #挂载光盘<br>rpm2cpio /mnt/cdrom/Packages/initscripts-8.45.3-1.i386.rpm | cpio -idv ./etc/inittab<br>#提取inittab文件到当前目录<br>cp etc/inittab /etc/inittab #复制inittab文件到指定位置</p>
<p>在光盘修复模式下可以修改大部分问题。</p>
</li>
<li><p>Linux的安全性</p>
<p> <img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20200530155429286.png" alt="Linux的安全性"> ￼<br>所以安全性是相对的，这是给我们留的退路</p>
</li>
</ul>
<h2 id="第十六章-备份与恢复"><a href="#第十六章-备份与恢复" class="headerlink" title="第十六章 备份与恢复"></a>第十六章 备份与恢复</h2><h3 id="16-1-备份概述"><a href="#16-1-备份概述" class="headerlink" title="16.1 备份概述"></a>16.1 备份概述</h3><ul>
<li><p>Linux系统需要备份的数据</p>
<ul>
<li>/root/目录:</li>
<li>/home/目录:</li>
<li>/var/spool/mail/目录:</li>
<li>/etc/目录:</li>
<li>其他目录:</li>
</ul>
</li>
<li><p>安装服务的数据</p>
<ul>
<li><p>apache需要备份的数据</p>
<ul>
<li><p>配置文件</p>
</li>
<li><p>网页主目录</p>
</li>
<li><p>日志文件</p>
</li>
<li><p>mysql需要备份的数据</p>
</li>
<li><p>源码包安装的mysql:/usr/local/mysql/data/</p>
</li>
<li><p>RPM包安装的mysql:/var/lib/mysql/</p>
</li>
<li><p>】备份策略</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>备份策略</p>
<ul>
<li><p>完全备份:完全备份就是指把所有需要备 份的数据全部备份，当然完全备份可以备份整块硬盘，整个分区或某个具体的目录</p>
<p> <img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20200530160146194.png" alt="差异备份"> </p>
</li>
<li><p>增量备份</p>
</li>
<li><p>差异备份<br>￼</p>
</li>
</ul>
</li>
</ul>
<h3 id="16-2-dump和restore命令"><a href="#16-2-dump和restore命令" class="headerlink" title="16.2 dump和restore命令"></a>16.2 dump和restore命令</h3><h4 id="16-2-1-dump命令"><a href="#16-2-1-dump命令" class="headerlink" title="16.2.1 dump命令"></a>16.2.1 dump命令</h4><ul>
<li><p>dump [选项] 备份之后的文件名 原文件或目录</p>
<ul>
<li>-level:就是我们说的0-9十个备份级别</li>
<li>-f 文件名: 指定备份之后的文件名</li>
<li>-u: 备份成功之后，把备份时间记录在/etc/dumpdates文件</li>
<li>-v:显示备份过程中更多的输出信息</li>
<li>-j: 调用bzlib库压缩备份文件，其实就是把备份文件压缩 为.bz2格式，默认压缩等级是2</li>
<li>-W: 显示允许被dump的分区的备份等级及备份时间</li>
<li>CentOS 7以前版本需要安装dump yum -y install dump下载</li>
</ul>
</li>
<li><p>CentOS 7 以后版本使用xfsdump备份xfs文件系统</p>
<ul>
<li>XFS提供了 xfsdump 和 xfsrestore 工具协助备份XFS文件系统中的数据。xfsdump 按inode顺序备份一个XFS文件系统。</li>
<li>centos7选择xfs格式作为默认文件系统，而且不再使用以前的ext，仍然支持ext4，xfs专为大数据产生，每个单个文件系统最大可以支持8eb，单个文件可以支持16tb，不仅数据量大，而且扩展性高。还可以通过xfsdump，xfsrestore来备份和恢复。</li>
<li>与传统的UNIX文件系统不同，XFS不需要在备份前被卸载；对使用中的XFS文件系统做备份就可以保证镜像的一致性。XFS的备份和恢复的过程是可以被中断然后继续的，无须冻结文件系统。xfsdump 甚至提供了高性能的多线程备份操作——它把一次dump拆分成多个数据流，每个数据流可以被发往不同的目的地。</li>
<li>使用yum -y install xfsdump下载</li>
</ul>
</li>
<li><p>只有在备份文件系统才能执行增量备份，执行1-9级别，文件和目录只能执行0级别</p>
</li>
<li><p>备份分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dump -0uj -f /root/boot.bak.bz2 /boot/</span><br><span class="line"># 备份命令。先执行一次完全备份，并压缩和更新备份时间 </span><br><span class="line">cat /etc/dumpdates</span><br><span class="line"># 查看备份时间文件</span><br><span class="line">cp install.log /boot/</span><br><span class="line"># 复制日志文件到/boot分区</span><br><span class="line">dump -1uj -f /root/boot.bak1.bz2 /boot/</span><br><span class="line"># 增量备份/boot分区，并压缩</span><br><span class="line">dump –W</span><br><span class="line"># 查询分区的备份时间及备份级别的</span><br></pre></td></tr></table></figure></li>
<li><p>备份文件或目录<br>dump -0j -f /root/etc.dump.bz2 /etc/<br>完全备份/etc/目录，只能使用0级别进行完全备份 ，而不再支持增量备份</p>
</li>
</ul>
<h4 id="16-2-1-restore命令"><a href="#16-2-1-restore命令" class="headerlink" title="16.2.1 restore命令"></a>16.2.1 restore命令</h4><ul>
<li>estore [模式选项] [选项]<ul>
<li>模式选项:restore命令常用的模式有以下四种，这四个模式不能混用。<ul>
<li>-C:比较备份数据和实际数据的变化。</li>
<li>-i: 进入交互模式，手工选择需要恢复的文件。</li>
<li>-t: 查看模式，用于查看备份文件中拥有哪些数据。</li>
<li>-r: 还原模式，用于数据还原。</li>
</ul>
</li>
<li>选项:<br>-f: 指定备份文件的文件名<br>比较备份数据和实际数据的变化<br>mv /boot/vmlinuz-2.6.32-279.el6.i686 /boot/vmlinuz-2.6.32- 279.el6.i686.bak<br>#把/boot目录中内核镜像文件改个名字 restore -C -f /root/boot.bak.bz2 #restore发现内核镜像文件丢失</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>《Linux》</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习笔记</title>
    <url>/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="Go语言概述"><a href="#Go语言概述" class="headerlink" title="Go语言概述"></a>Go语言概述</h3><h4 id="1-Go语言简介"><a href="#1-Go语言简介" class="headerlink" title="1.Go语言简介"></a>1.Go语言简介</h4><ul>
<li><p>Go 是一个开源的编程语言，它能让<font color="cornflowerblue">构造简单、可靠且高效的软件</font>变得容易。</p>
</li>
<li><p>Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。</p>
</li>
</ul>
<h4 id="2-Go语言特色"><a href="#2-Go语言特色" class="headerlink" title="2.Go语言特色"></a>2.Go语言特色</h4><ul>
<li>简洁、快速、安全</li>
<li>并行、有趣、开源</li>
<li>内存管理、v数组安全、编译迅速</li>
</ul>
<h4 id="3-Go-语言用途"><a href="#3-Go-语言用途" class="headerlink" title="3.Go 语言用途"></a>3.Go 语言用途</h4><ul>
<li><p>Go 语言被设计成一门应用于搭载 <font color="cornflowerblue">Web 服务器</font>，<font color="cornflowerblue">存储集群</font>或类似用途的<font color="cornflowerblue">巨型中央服务器</font>的系统编程语言。</p>
</li>
<li><p>对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了<font color="cornflowerblue">海量并行的支持</font>，这对于游戏服务端的开发而言是再好不过了。</p>
</li>
</ul>
<h3 id="Go语言结构"><a href="#Go语言结构" class="headerlink" title="Go语言结构"></a>Go语言结构</h3><h4 id="1-Hello-World-实例"><a href="#1-Hello-World-实例" class="headerlink" title="1.Hello World 实例"></a>1.Hello World 实例</h4><p>（1）Go 语言的基础组成有以下几个部分：</p>
<ul>
<li>包声明</li>
<li>引入包</li>
<li>函数</li>
<li>变量</li>
<li>语句 &amp; 表达式</li>
<li>注释</li>
</ul>
<p>（2）接下来让我们来看下简单的代码，该代码输出了”Hello World!”:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 这是我的第一个简单的程序 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）让我们来看下以上程序的各个部分：</p>
<ol>
<li><em>package main</em> 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</li>
<li><em>import “fmt”</em> 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），<font color="red">fmt 包实现了格式化 IO（输入/输出）的函数</font>。</li>
<li>下一行 <em>func main()</em> 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</li>
<li>/<em>…</em>/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li>
<li><em>fmt.Println(…)</em> 可以将字符串输出到控制台，并在最后自动增加换行字符 \n。<br>使用 fmt.Print(“hello, world\n”) 可以得到相同的结果。<br>Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</li>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个<font color="red">大写字母开头</font>，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 <font color="red">public</font>）；标识符如果<font color="red">以小写字母开头</font>，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 <font color="red">private</font> ）。</li>
</ol>
<h4 id="2-执行-Go-程序"><a href="#2-执行-Go-程序" class="headerlink" title="2.执行 Go 程序"></a>2.执行 Go 程序</h4><p>（1）让我们来看下如何编写 Go 代码并执行它。步骤如下：</p>
<ul>
<li>打开编辑器如Sublime2，将以上代码添加到编辑器中。</li>
<li>将以上代码保存为 <em>hello.go</em></li>
<li>打开命令行，并进入程序文件保存的目录中。</li>
<li>输入命令 <em>go run hello.go</em> 并按回车执行代码。</li>
</ul>
<p>（2）如果操作正确你将在屏幕上看到 <em>“Hello World!”</em> 字样的输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run hello.<span class="keyword">go</span></span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>



<h3 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h3><h4 id="1-行分隔符"><a href="#1-行分隔符" class="headerlink" title="1.行分隔符"></a>1.行分隔符</h4><ul>
<li><p>在 Go 程序中，<font color="red">一行代表一个语句结束</font>。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。</p>
</li>
<li><p>如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。</p>
</li>
</ul>
<h4 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h4><ul>
<li><p>注释不会被编译，每一个包应该有相关注释。</p>
</li>
<li><p>单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。如：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Author by w3cschoolW3Cschool教程</span></span><br><span class="line"><span class="comment"> 我是多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h4 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3.关键字"></a>3.关键字</h4><p>（1）下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p>
<table>
<thead>
<tr>
<th>break</th>
<th>default</th>
<th>func</th>
<th>interface</th>
<th>select</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td>defer</td>
<td>go</td>
<td>map</td>
<td>struct</td>
</tr>
<tr>
<td>chan</td>
<td>else</td>
<td>goto</td>
<td>package</td>
<td>switch</td>
</tr>
<tr>
<td>const</td>
<td>fallthrough</td>
<td>if</td>
<td>range</td>
<td>type</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>import</td>
<td>return</td>
<td>var</td>
</tr>
</tbody></table>
<p>（2）除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：</p>
<table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody><tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody></table>
<h3 id="Go语言数据类型"><a href="#Go语言数据类型" class="headerlink" title="Go语言数据类型"></a>Go语言数据类型</h3><h4 id="1-Go-语言数据类型"><a href="#1-Go-语言数据类型" class="headerlink" title="1.Go 语言数据类型"></a>1.Go 语言数据类型</h4><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>数字类型</strong> 整型 int 和浮点型 float，Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) 联合体类型 (union)(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型(i) Channel 类型</td>
</tr>
</tbody></table>
<h4 id="2-数字类型"><a href="#2-数字类型" class="headerlink" title="2.数字类型"></a>2.数字类型</h4><ul>
<li>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<ul>
<li>浮点型：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>float32</strong> IEEE-754 32位浮点型数</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>float64</strong> IEEE-754 64位浮点型数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>complex64</strong> 32 位实数和虚数</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>complex128</strong> 64 位实数和虚数</td>
</tr>
</tbody></table>
<h4 id="3-其他数字类型"><a href="#3-其他数字类型" class="headerlink" title="3.其他数字类型"></a>3.其他数字类型</h4><p>以下列出了其他更多的数字类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>byte</strong> 类似 uint8</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>rune</strong> 类似 int32</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>uint</strong> 32 或 64 位</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>int</strong> 与 uint 一样大小</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>uintptr</strong> 无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<h3 id="Go语言变量"><a href="#Go语言变量" class="headerlink" title="Go语言变量"></a>Go语言变量</h3><h4 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1.变量声明"></a>1.变量声明</h4><p>（1）第一种，指定变量类型，先声明后赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var v_name v_type</span></span><br><span class="line"><span class="comment">//v_name = value</span></span><br></pre></td></tr></table></figure>

<p>（2）第二种，根据值自行判定变量类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var v_name = value</span></span><br></pre></td></tr></table></figure>

<p>（3）第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v_name := value</span></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">c : = <span class="number">10</span></span><br></pre></td></tr></table></figure>



<h4 id="2-多变量声明"><a href="#2-多变量声明" class="headerlink" title="2.多变量声明"></a>2.多变量声明</h4><p>（1）类型相同多个变量, 非全局变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">//和python很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">//出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）类型不同的多个变量，全局变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>（3）实例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">b = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">c := <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d, e, f <span class="keyword">int</span></span><br><span class="line">d, e, f = <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span></span><br><span class="line"></span><br><span class="line">g, h, i := <span class="number">18</span>, <span class="number">19</span>, “work”</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    j <span class="keyword">int</span></span><br><span class="line">    k <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">j = <span class="number">21</span></span><br><span class="line">k = <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="3-值类型和引用类型"><a href="#3-值类型和引用类型" class="headerlink" title="3.值类型和引用类型"></a>3.值类型和引用类型</h4><p>（1）所有像 int、float、bool 和 string 这些基本类型都属于<font color="red">值类型</font>，使用这些类型的变量直接指向存在内存中的值：</p>
<p><img src="/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/201611202341534498.png" alt="img"></p>
<p>当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，如：<code>j = i</code>，实际上是在内存中将 i 的值进行了拷贝：</p>
<p><img src="/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/201611202342229643.png" alt="img"></p>
<p>你可以通过 &amp;i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。</p>
<p>内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。</p>
<p>（2）更复杂的数据通常会需要使用多个字，这些数据一般使用<font color="red">引用类型</font>保存。</p>
<p>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</p>
<p><img src="/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/201611202342474583.png" alt="img"></p>
<p>这个内存地址为称之为指针，这个指针实际上也被存在另外的某一个字中。</p>
<p>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。</p>
<p>当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。</p>
<p>如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</p>
<h3 id="Go语言常量"><a href="#Go语言常量" class="headerlink" title="Go语言常量"></a>Go语言常量</h3><h4 id="1-常量的定义格式"><a href="#1-常量的定义格式" class="headerlink" title="1.常量的定义格式"></a>1.常量的定义格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const identifier [type] = value</span><br></pre></td></tr></table></figure>

<p>（1）你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p>
<ul>
<li>显式类型定义： <code>const b string = &quot;abc&quot;</code></li>
<li>隐式类型定义： <code>const b = &quot;abc&quot;</code></li>
</ul>
<p>（2）多个相同类型的声明可以简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const c_name1, c_name2 = value1, value2</span><br></pre></td></tr></table></figure>



<h4 id="2-iota"><a href="#2-iota" class="headerlink" title="2.iota"></a>2.iota</h4><p>（1）iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p>
<p>（2）在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。</p>
<p>（4）iota 可以被用作枚举值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>（5）iota 用法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> ha ha <span class="number">100</span> <span class="number">100</span> <span class="number">7</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言运算符"><a href="#Go语言运算符" class="headerlink" title="Go语言运算符"></a>Go语言运算符</h3><p>略</p>
<h3 id="Go语言条件语句"><a href="#Go语言条件语句" class="headerlink" title="Go语言条件语句"></a>Go语言条件语句</h3><p>Go 语言提供了以下几种条件判断语句：</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-if-statement.html">if 语句</a></td>
<td align="left"><strong>if 语句</strong> 由一个布尔表达式后紧跟一个或多个语句组成。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-if-else-statement.html">if…else 语句</a></td>
<td align="left"><strong>if 语句</strong> 后可以使用可选的 <strong>else 语句</strong>, else 语句中的表达式在布尔表达式为 false 时执行。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-nested-if-statements.html">if 嵌套语句</a></td>
<td align="left">你可以在 <strong>if</strong> 或 <strong>else if</strong> 语句中嵌入一个或多个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-switch-statement.html">switch 语句</a></td>
<td align="left"><strong>switch</strong> 语句用于基于不同条件执行不同动作。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-select-statement.html">select 语句</a></td>
<td align="left"><strong>select</strong> 语句类似于 <strong>switch</strong> 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</td>
</tr>
</tbody></table>
<h4 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;   </span><br><span class="line">    <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-if…else语句"><a href="#2-if…else语句" class="headerlink" title="2.if…else语句"></a>2.if…else语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;   </span><br><span class="line">    <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-if嵌套语句"><a href="#3-if嵌套语句" class="headerlink" title="3.if嵌套语句"></a>3.if嵌套语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 <span class="number">1</span> &#123;   </span><br><span class="line">    <span class="comment">/* 在布尔表达式 1 为 true 时执行 */</span>   </span><br><span class="line">    <span class="keyword">if</span> 布尔表达式 <span class="number">2</span> &#123;      </span><br><span class="line">        <span class="comment">/* 在布尔表达式 2 为 true 时执行 */</span>   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4.switch语句"></a>4.switch语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;    </span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-select语句"><a href="#5-select语句" class="headerlink" title="5.select语句"></a>5.select语句</h4><p><a href="https://blog.csdn.net/zhonglinzhang/article/details/45913443">参考：select用法</a></p>
<p>（1）select是Go中的一个控制结构，类似于用于通信的switch语句。<font color="red">每个case必须是一个通信操作</font>，要么是发送要么是接收。</p>
<p><strong>select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。</strong></p>
<p>（2）语法</p>
<p>Go 编程语言中 select 语句的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;    </span><br><span class="line">	<span class="keyword">case</span> communication clause  :</span><br><span class="line">    	statement(s);          </span><br><span class="line">    <span class="keyword">case</span> communication clause  :       </span><br><span class="line">    	statement(s);     </span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span>    </span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span>       </span><br><span class="line">    	statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下描述了 select 语句的语法：</p>
<ul>
<li><p>每个case都必须是一个通信</p>
</li>
<li><p>所有channel表达式都会被求值</p>
</li>
<li><p>所有被发送的表达式都会被求值</p>
</li>
<li><p>如果任意某个通信可以进行，它就执行；其他被忽略。</p>
</li>
<li><p>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。</p>
<p>否则：</p>
<ol>
<li>如果有default子句，则执行该语句。</li>
<li>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</li>
</ol>
</li>
</ul>
<p>（3）实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3\n&quot;</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;c3 is closed\n&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;no communication\n&quot;</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no communication</span><br></pre></td></tr></table></figure>



<h3 id="GO语言循环语句"><a href="#GO语言循环语句" class="headerlink" title="GO语言循环语句"></a>GO语言循环语句</h3><h4 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1.for循环"></a>1.for循环</h4><p>（1）和 C 语言的 for 一样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>（2）和 C 的 while 一样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>（3）和 C 的 for(;;) 一样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>init： 一般为赋值表达式，给控制变量赋初值；</li>
<li>condition： 关系表达式或逻辑表达式，循环控制条件；</li>
<li>post： 一般为赋值表达式，给控制变量增量或减量。</li>
</ul>
<p>（3）for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;    </span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">15</span>   </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span>   </span><br><span class="line">    numbers := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;    </span><br><span class="line">    <span class="comment">/* for 循环 */</span>   </span><br><span class="line">    <span class="keyword">for</span> a := <span class="number">0</span>; a &lt; <span class="number">10</span>; a++ &#123;      </span><br><span class="line">        fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> a &lt; b &#123;      </span><br><span class="line">        a++      </span><br><span class="line">        fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)      </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> i,x:= <span class="keyword">range</span> numbers &#123;      </span><br><span class="line">        fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i,x)   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-循环嵌套"><a href="#2-循环嵌套" class="headerlink" title="2.循环嵌套"></a>2.循环嵌套</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">   &#123;</span><br><span class="line">      statement(s);</span><br><span class="line">   &#125;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例:</p>
<p>以下实例使用循环嵌套来输出 2 到 100 间的素数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> i, j <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i=<span class="number">2</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j=<span class="number">2</span>; j &lt;= (i/j); j++ &#123;</span><br><span class="line">         <span class="keyword">if</span>(i%j==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果发现因子，则不是素数</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j &gt; (i/j)) &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;%d  是素数\n&quot;</span>, i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-循环控制语句"><a href="#3-循环控制语句" class="headerlink" title="3.循环控制语句"></a>3.循环控制语句</h4><p>GO 语言支持以下几种循环控制语句：</p>
<table>
<thead>
<tr>
<th align="left">控制语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-break-statement.html">break 语句</a></td>
<td align="left">经常用于中断当前 for 循环或跳出 switch 语句</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-continue-statement.html">continue 语句</a></td>
<td align="left">跳过当前循环的剩余语句，然后继续进行下一轮循环。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-goto-statement.html">goto 语句</a></td>
<td align="left">将控制转移到被标记的语句。</td>
</tr>
</tbody></table>
<h4 id="Go语言函数"><a href="#Go语言函数" class="headerlink" title="Go语言函数"></a>Go语言函数</h4><h4 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1.函数定义"></a>1.函数定义</h4><p>（1）Go 语言函数定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func function_name( [parameter list] ) [return_types]&#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）函数定义解析：</p>
<ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parameter list]：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<p>（3）实例</p>
<p>以下实例为 max() 函数的代码，该函数传入两个整型参数 num1 和 num2，并返回这两个参数的最大值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2.函数调用"></a>2.函数调用</h4><p>当创建函数时，你定义了函数需要做什么，通过调用改函数来执行指定任务。</p>
<p>调用函数，向函数传递参数，并返回值，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line">   <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用函数并返回最大值 */</span></span><br><span class="line">   ret = max(a, b)</span><br><span class="line"></span><br><span class="line">   fmt.Printf( <span class="string">&quot;最大值是 : %d\n&quot;</span>, ret )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例在 main() 函数中调用 max（）函数，执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最大值是 : 200</span><br></pre></td></tr></table></figure>



<h4 id="3-函数返回多个值"><a href="#3-函数返回多个值" class="headerlink" title="3.函数返回多个值"></a>3.函数返回多个值</h4><p>Go 函数可以返回多个值，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Mahesh&quot;</span>, <span class="string">&quot;Kumar&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kumar Mahesh</span><br></pre></td></tr></table></figure>



<h4 id="4-函数参数"><a href="#4-函数参数" class="headerlink" title="4.函数参数"></a>4.函数参数</h4><p>函数如果使用参数，该变量可称为函数的形参。</p>
<p>形参就像定义在函数体内的局部变量。</p>
<p>调用函数，可以通过两种方式来传递参数：</p>
<table>
<thead>
<tr>
<th align="left">传递类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-call-by-value.html">值传递</a></td>
<td align="left">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-call-by-reference.html">引用传递</a></td>
<td align="left">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td>
</tr>
</tbody></table>
<p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p>
<h4 id="5-函数用法"><a href="#5-函数用法" class="headerlink" title="5.函数用法"></a>5.函数用法</h4><table>
<thead>
<tr>
<th align="left">函数用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-as-values.html">函数作为值</a></td>
<td align="left">函数定义后可作为值来使用</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-closures.html">闭包</a></td>
<td align="left">闭包是匿名函数，可在动态编程中使用</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-method.html">方法</a></td>
<td align="left">方法就是一个包含了接受者的函数</td>
</tr>
</tbody></table>
<p>（1）函数作为值</p>
<p>Go 语言可以很灵活的创建函数，并作为值使用。以下实例中我们在定义的函数中初始化一个变量，该函数仅仅是为了使用内置函数 math.sqrt() ，实例为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明函数变量 */</span></span><br><span class="line">   getSquareRoot := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用函数 */</span></span><br><span class="line">   fmt.Println(getSquareRoot(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>（2）闭包</p>
<p>Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<p>以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>（3）方法</p>
<h3 id="Go语言变量作用域"><a href="#Go语言变量作用域" class="headerlink" title="Go语言变量作用域"></a>Go语言变量作用域</h3><p>略</p>
<h3 id="Go语言数组"><a href="#Go语言数组" class="headerlink" title="Go语言数组"></a>Go语言数组</h3><h4 id="1-声明数组"><a href="#1-声明数组" class="headerlink" title="1.声明数组"></a>1.声明数组</h4><p>Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure>

<p>以上为一维数组的定义方式。数组长度必须是整数且大于 0。例如以下定义了数组 balance 长度为 10 类型为 float32：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var balance [10] float32</span><br></pre></td></tr></table></figure>



<h4 id="2-初始化数组"><a href="#2-初始化数组" class="headerlink" title="2.初始化数组"></a>2.初始化数组</h4><ul>
<li><p>方式一</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   <span class="comment">//不允许写成 var arr [3]int = &#123;1,2,3&#125;</span></span><br><span class="line">   fmt.Println(arr) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">   arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">   arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">   arr[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">   fmt.Println(arr) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式三<br>这是方式一的一种简化形式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(arr) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>方式四<br>方式一的简化形式，也是用得最多的一种方式。</p>
<p>注意：:=符号只允许在函数中使用，即只能在声明局部变量的时候使用，而var没有这个限制。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;	arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;	fmt.Println(arr) <span class="comment">//[1 2 3]&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>方式五<br>让编译器根据初始值的个数自行推断数组的长度。以…来代替[]中的数字，注意若[]中为空则表示为切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(arr) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式六<br>利用指定索引值的方式来初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">4</span>:<span class="number">3</span>&#125; <span class="comment">//例如 0:1 表示数组下标0对应的值为1</span></span><br><span class="line">	fmt.Println(arr) <span class="comment">// [1 0 0 0 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr[<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1[<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr1[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">arr3 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr4 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">arr5 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Go语言指针"><a href="#Go语言指针" class="headerlink" title="Go语言指针"></a>Go语言指针</h3><h4 id="1-什么是指针"><a href="#1-什么是指针" class="headerlink" title="1.什么是指针"></a>1.什么是指针</h4><p>（1）一个指针变量可以指向任何一个值的内存地址。</p>
<p>（2）类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。（3）以下是有效的指针声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 指向整型*/</span><span class="keyword">var</span> fp *<span class="keyword">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure>

<p>本例中这是一个指向 int 和 float32 的指针。</p>
<h4 id="2-如何使用指针"><a href="#2-如何使用指针" class="headerlink" title="2.如何使用指针"></a>2.如何使用指针</h4><p>（1）指针使用流程：</p>
<ul>
<li>定义指针变量。</li>
<li>为指针变量赋值。</li>
<li>访问指针变量中指向地址的值。</li>
</ul>
<p>（2）在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;a 变量的地址是: %x\n&quot;</span>, &amp;a  )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;ip 变量的存储地址: %x\n&quot;</span>, ip )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a 变量的地址是: <span class="number">20818</span>a220ip 变量的存储地址: <span class="number">20818</span>a220*ip 变量的值: <span class="number">20</span></span><br></pre></td></tr></table></figure>



<h4 id="3-Go-空指针"><a href="#3-Go-空指针" class="headerlink" title="3.Go 空指针"></a>3.Go 空指针</h4><p>（1）当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p>
<p>​        nil 指针也称为空指针。</p>
<p>​        nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p>
<p>（2）一个指针变量通常缩写为 ptr。</p>
<p>​    查看以下实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span>  ptr *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;ptr 的值为 : %x\n&quot;</span>, ptr  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ptr 的值为 : 0</span><br></pre></td></tr></table></figure>

<p>（3）空指针判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(ptr != nil)     /* ptr 不是空指针 */</span><br><span class="line">if(ptr == nil)    /* ptr 是空指针 */</span><br></pre></td></tr></table></figure>



<h4 id="4-Go指针更多内容"><a href="#4-Go指针更多内容" class="headerlink" title="4.Go指针更多内容"></a>4.Go指针更多内容</h4><p>接下来我们将为大家介绍Go语言中更多的指针应用：</p>
<table>
<thead>
<tr>
<th align="left">内容</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-array-of-pointers.html">Go 指针数组</a></td>
<td align="left">你可以定义一个指针数组来存储地址</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-pointer-to-pointer.html">Go 指向指针的指针</a></td>
<td align="left">Go 支持指向指针的指针</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-passing-pointers-to-functions.html">Go 像函数传递指针参数</a></td>
<td align="left">通过引用或地址传参，在函数调用时可以改变其值</td>
</tr>
</tbody></table>
<h3 id="Go语言结构体"><a href="#Go语言结构体" class="headerlink" title="Go语言结构体"></a>Go语言结构体</h3><h4 id="1-定义结构体"><a href="#1-定义结构体" class="headerlink" title="1.定义结构体"></a>1.定义结构体</h4><p>（1）结构体定义需要使用<font color="red"> type</font> 和 <font color="red">struct </font>语句。struct 语句定义一个新的数据类型，结构体有中一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-访问结构体成员"><a href="#2-访问结构体成员" class="headerlink" title="2.访问结构体成员"></a>2.访问结构体成员</h4><p>（1）如果要访问结构体成员，需要使用点号 (.) 操作符，格式为：<font color="red">“结构体.成员名”</font>。</p>
<p>结构体类型变量使用struct关键字定义，实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* 声明 Book2 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 title : %s\n&quot;</span>, Book1.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 author : %s\n&quot;</span>, Book1.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 subject : %s\n&quot;</span>, Book1.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 book_id : %d\n&quot;</span>, Book1.book_id)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 title : %s\n&quot;</span>, Book2.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 author : %s\n&quot;</span>, Book2.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 subject : %s\n&quot;</span>, Book2.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 book_id : %d\n&quot;</span>, Book2.book_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Book <span class="number">1</span> title : Go 语言</span><br><span class="line">Book <span class="number">1</span> author : www.w3cschool.cn</span><br><span class="line">Book <span class="number">1</span> subject : Go 语言教程</span><br><span class="line">Book <span class="number">1</span> book_id : <span class="number">6495407</span></span><br><span class="line">Book <span class="number">2</span> title : Python 教程</span><br><span class="line">Book <span class="number">2</span> author : www.w3cschool.cn</span><br><span class="line">Book <span class="number">2</span> subject : Python 语言教程</span><br><span class="line">Book <span class="number">2</span> book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>



<h4 id="3-结构体作为函数参数"><a href="#3-结构体作为函数参数" class="headerlink" title="3.结构体作为函数参数"></a>3.结构体作为函数参数</h4><p>（1）你可以向其他数据类型一样将结构体类型作为参数传递给函数。并以以上实例的方式访问结构体变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* 声明 Book2 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   printBook(Book1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   printBook(Book2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Book title : Go 语言</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Go 语言教程</span><br><span class="line">Book book_id : <span class="number">6495407</span></span><br><span class="line">Book title : Python 教程</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Python 语言教程</span><br><span class="line">Book book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>



<h4 id="4-结构体指针"><a href="#4-结构体指针" class="headerlink" title="4.结构体指针"></a>4.结构体指针</h4><p>（1）你可以定义指向结构体的指针类似于其他指针变量，格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br></pre></td></tr></table></figure>

<p>（2）以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>

<p>（3）使用结构体指针访问结构体成员，使用 “.” 操作符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer.title;</span><br></pre></td></tr></table></figure>

<p>（4）接下来让我们使用结构体指针重写以上实例，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* Declare Book1 of type Book */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* Declare Book2 of type Book */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   printBook(&amp;Book1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   printBook(&amp;Book2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book *Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Book title : Go 语言</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Go 语言教程</span><br><span class="line">Book book_id : <span class="number">6495407</span></span><br><span class="line">Book title : Python 教程</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Python 语言教程</span><br><span class="line">Book book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言切片（Slice）"><a href="#Go语言切片（Slice）" class="headerlink" title="Go语言切片（Slice）"></a>Go语言切片（Slice）</h3><h4 id="1-定义切片"><a href="#1-定义切片" class="headerlink" title="1.定义切片"></a>1.定义切片</h4><p>（1）你可以声明一个未指定大小的数组来定义切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>（2）或使用<font color="red">make()函数</font>来创建切片:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">也可以简写为</span><br><span class="line"></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>

<p>（3）也可以指定容量，其中capacity为可选参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">type</span>, length, capacity)</span><br></pre></td></tr></table></figure>

<p>这里 len 是数组的长度并且也是切片的初始长度。</p>
<h4 id="2-切片初始化"><a href="#2-切片初始化" class="headerlink" title="2.切片初始化"></a>2.切片初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s :=[] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125; </span><br></pre></td></tr></table></figure>

<p>（1）直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[:] </span><br></pre></td></tr></table></figure>

<p>（2）初始化切片s,是数组arr的引用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:endIndex] </span><br></pre></td></tr></table></figure>

<p>（3）将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:] </span><br></pre></td></tr></table></figure>

<p>（4）缺省endIndex时将表示一直到arr的最后一个元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[:endIndex] </span><br></pre></td></tr></table></figure>

<p>（5）缺省startIndex时将表示从arr的第一个元素开始</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := s[startIndex:endIndex] </span><br></pre></td></tr></table></figure>

<p>（6）通过切片s初始化切片s1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>) </span><br></pre></td></tr></table></figure>

<p>（7）通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</p>
<h4 id="3-len-和-cap-函数"><a href="#3-len-和-cap-函数" class="headerlink" title="3.len() 和 cap() 函数"></a>3.len() 和 cap() 函数</h4><p>（1）切片是可索引的，并且可以由 len() 方法获取长度。</p>
<p>（2）切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>
<p>（3）以下为具体实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">3</span> <span class="built_in">cap</span>=<span class="number">5</span> slice=[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<h4 id="4-空-nil-切片"><a href="#4-空-nil-切片" class="headerlink" title="4.空(nil)切片"></a>4.空(nil)切片</h4><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> slice=[]</span><br><span class="line">切片是空的</span><br></pre></td></tr></table></figure>



<h4 id="5-切片截取"><a href="#5-切片截取" class="headerlink" title="5.切片截取"></a>5.切片截取</h4><p>可以通过设置下限及上限来设置截取切片 **[lower-bound:upper-bound]**，实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;   </span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers ==&quot;</span>, numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[1:4] ==&quot;</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[:3] ==&quot;</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[4:] ==&quot;</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]</span><br><span class="line">numbers == [0 1 2 3 4 5 6 7 8]</span><br><span class="line">numbers[1:4] == [1 2 3]</span><br><span class="line">numbers[:3] == [0 1 2]</span><br><span class="line">numbers[4:] == [4 5 6 7 8]</span><br><span class="line">len=0 cap=5 slice=[]</span><br><span class="line">len=2 cap=9 slice=[0 1]</span><br><span class="line">len=3 cap=7 slice=[2 3 4]</span><br></pre></td></tr></table></figure>



<h4 id="6-append-和-copy-函数"><a href="#6-append-和-copy-函数" class="headerlink" title="6.append() 和 copy() 函数"></a>6.append() 和 copy() 函数</h4><p>（1）如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p>
<p>（2）下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> slice=[]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">1</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">8</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">16</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<h3 id="Go语言范围（Range"><a href="#Go语言范围（Range" class="headerlink" title="Go语言范围（Range)"></a>Go语言范围（Range)</h3><h4 id="1-Go-语言范围"><a href="#1-Go-语言范围" class="headerlink" title="1.Go 语言范围"></a>1.Go 语言范围</h4><p>（1）Go 语言中 range 关键字用于for循环中迭代数组(array)、切片(slice)、链表(channel)或集合(map)的元素。</p>
<p>（2）在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值，对于映射，它返回下一个键值对的键。</p>
<p>（2）Range返回一个值或两个值。如果在Range表达式的左侧只使用了一个值，则该值是下表中的第一个值。</p>
<table>
<thead>
<tr>
<th>Range表达式</th>
<th>第一个值</th>
<th>第二个值[可选的]</th>
</tr>
</thead>
<tbody><tr>
<td>Array 或者 slice a [n]E</td>
<td>索引 i int</td>
<td>a[i] E</td>
</tr>
<tr>
<td>String s string type</td>
<td>索引 i int</td>
<td>rune int</td>
</tr>
<tr>
<td>map m map[K]V</td>
<td>键 k K</td>
<td>值 m[k] V</td>
</tr>
<tr>
<td>channel c chan E</td>
<td>元素 e E</td>
<td>none</td>
</tr>
</tbody></table>
<p>（4）实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//(1)这是我们使用range去求一个slice的和。使用数组跟这个很类似</span></span><br><span class="line">    nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum:&quot;</span>, sum)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(2)在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;index:&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(3)range也可以用在map的键值对上。</span></span><br><span class="line">    kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(4)range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;go&quot;</span> &#123;</span><br><span class="line">        fmt.Println(i, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum: <span class="number">9</span></span><br><span class="line">index: <span class="number">1</span></span><br><span class="line">a -&gt; apple</span><br><span class="line">b -&gt; banana</span><br><span class="line"><span class="number">0</span> <span class="number">103</span></span><br><span class="line"><span class="number">1</span> <span class="number">111</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言Map（集合）"><a href="#Go语言Map（集合）" class="headerlink" title="Go语言Map（集合）"></a>Go语言Map（集合）</h3><h4 id="1-定义-Map"><a href="#1-定义-Map" class="headerlink" title="1.定义 Map"></a>1.定义 Map</h4><p>（1）可以使用<font color="red">内建函数 make </font>也可以使用 <font color="red">map 关键字</font>来定义 Map:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable = <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure>

<p>（2）如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p>
<p>（3）实例</p>
<p>下面实例演示了创建和使用map:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">   <span class="comment">/* 创建集合 */</span></span><br><span class="line">   countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* map 插入 key-value 对，各个国家对应的首都 */</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;France&quot;</span>] = <span class="string">&quot;Paris&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Italy&quot;</span>] = <span class="string">&quot;Rome&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Japan&quot;</span>] = <span class="string">&quot;Tokyo&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;India&quot;</span>] = <span class="string">&quot;New Delhi&quot;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 使用 key 输出 map 值 */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 查看元素在集合中是否存在 */</span></span><br><span class="line">   captial, ok := countryCapitalMap[<span class="string">&quot;United States&quot;</span>]</span><br><span class="line">   <span class="comment">/* 如果 ok 是 true, 则存在，否则不存在 */</span></span><br><span class="line">   <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is&quot;</span>, captial)  </span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is not present&quot;</span>) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Capital of France is Paris</span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br><span class="line">Capital of United States is not present</span><br></pre></td></tr></table></figure>



<h4 id="2-delete-函数"><a href="#2-delete-函数" class="headerlink" title="2.delete() 函数"></a>2.delete() 函数</h4><p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key。实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">   <span class="comment">/* 创建 map */</span></span><br><span class="line">   countryCapitalMap := <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">string</span> &#123;<span class="string">&quot;France&quot;</span>:<span class="string">&quot;Paris&quot;</span>,<span class="string">&quot;Italy&quot;</span>:<span class="string">&quot;Rome&quot;</span>,<span class="string">&quot;Japan&quot;</span>:<span class="string">&quot;Tokyo&quot;</span>,<span class="string">&quot;India&quot;</span>:<span class="string">&quot;New Delhi&quot;</span>&#125;</span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">&quot;原始 map&quot;</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 删除元素 */</span></span><br><span class="line">   <span class="built_in">delete</span>(countryCapitalMap,<span class="string">&quot;France&quot;</span>);</span><br><span class="line">   fmt.Println(<span class="string">&quot;Entry for France is deleted&quot;</span>)  </span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">&quot;删除元素后 map&quot;</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">原始 mapCapital of France is ParisCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New DelhiEntry <span class="keyword">for</span> France is deleted删除元素后 mapCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New Delhi</span><br></pre></td></tr></table></figure>



<h3 id="Go语言递归函数"><a href="#Go语言递归函数" class="headerlink" title="Go语言递归函数"></a>Go语言递归函数</h3><h4 id="1-Go-语言递归函数"><a href="#1-Go-语言递归函数" class="headerlink" title="1.Go 语言递归函数"></a>1.Go 语言递归函数</h4><p>递归，就是在运行的过程中调用自己。</p>
<p>语法格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> &#123;   recursion() <span class="comment">/* 函数调用自身 */</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   recursion()&#125;</span><br></pre></td></tr></table></figure>

<p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。</p>
<p>递归函数对于解决数学上的问题是非常有用的，就像计算阶乘，生成斐波那契数列等。</p>
<h4 id="2-阶乘"><a href="#2-阶乘" class="headerlink" title="2.阶乘"></a>2.阶乘</h4><p>以下实例通过 Go 语言的递归函数实例阶乘：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">    result = <span class="number">1</span>;   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = x * Factorial(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">15</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d 的阶乘是 %d\n&quot;</span>, i, Factorial(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span> 的阶乘是 <span class="number">1307674368000</span></span><br></pre></td></tr></table></figure>



<h4 id="3-斐波那契数列"><a href="#3-斐波那契数列" class="headerlink" title="3.斐波那契数列"></a>3.斐波那契数列</h4><p>以下实例通过 Go 语言的递归函数实现斐波那契数列：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n<span class="number">-2</span>) + fibonacci(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">       fmt.Printf(<span class="string">&quot;%d\t&quot;</span>, fibonacci(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">5</span>   <span class="number">8</span>   <span class="number">13</span>  <span class="number">21</span>  <span class="number">34</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言类型转换"><a href="#Go语言类型转换" class="headerlink" title="Go语言类型转换"></a>Go语言类型转换</h3><h4 id="1-Go-语言类型转换"><a href="#1-Go-语言类型转换" class="headerlink" title="1.Go 语言类型转换"></a>1.Go 语言类型转换</h4><p>（1）类型转换用于将一种数据类型的变量转换为另外一种类型的变量。Go 语言类型转换基本格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure>

<p>type_name 为类型，expression 为表达式。</p>
<p>（2）实例</p>
<p>以下实例中将整型转化为浮点型，并计算结果，将结果赋值给浮点型变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">17</span></span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">   <span class="keyword">var</span> mean <span class="keyword">float32</span></span><br><span class="line">   </span><br><span class="line">   mean = <span class="keyword">float32</span>(sum)/<span class="keyword">float32</span>(count)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;mean 的值为: %f\n&quot;</span>,mean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mean 的值为: <span class="number">3.400000</span></span><br></pre></td></tr></table></figure>



<h4 id="2-go-不支持隐式转换类型"><a href="#2-go-不支持隐式转换类型" class="headerlink" title="2.go 不支持隐式转换类型"></a>2.go 不支持隐式转换类型</h4><p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int32</span></span><br><span class="line">    b = a</span><br><span class="line">    fmt.Printf(<span class="string">&quot;b 为 : %d&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cannot use a (<span class="keyword">type</span> <span class="keyword">int64</span>) as <span class="keyword">type</span> <span class="keyword">int32</span> in assignment</span><br><span class="line">cannot use b (<span class="keyword">type</span> <span class="keyword">int32</span>) as <span class="keyword">type</span> <span class="keyword">string</span> in argument to fmt.Printf</span><br></pre></td></tr></table></figure>

<p>但是如果改成 <code>b = int32(a) </code>就不会报错了:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int32</span></span><br><span class="line">    b = <span class="keyword">int32</span>(a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;b 为 : %d&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="GO语言接口"><a href="#GO语言接口" class="headerlink" title="GO语言接口"></a>GO语言接口</h3><h4 id="1-Go-语言接口"><a href="#1-Go-语言接口" class="headerlink" title="1.Go 语言接口"></a>1.Go 语言接口</h4><p>（1）Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p>
<p>实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_name1</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_namen</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个接口Phone，接口里面有一个方法call()。然后我们在main函数里面定义了一个Phone类型变量，并分别为之赋值为NokiaPhone和IPhone。然后调用call()方法，输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">I am Nokia, I can call you!</span><br><span class="line">I am iPhone, I can call you!</span><br></pre></td></tr></table></figure>

<p>（2）</p>
<ul>
<li><a href="https://www.cnblogs.com/itogo/p/8645486.html">参考1</a></li>
<li><a href="https://blog.csdn.net/lipenghandsome/article/details/105916687">参考2</a></li>
</ul>
<h3 id="GO语言错误处理"><a href="#GO语言错误处理" class="headerlink" title="GO语言错误处理"></a>GO语言错误处理</h3><h4 id="1-Go-错误处理"><a href="#1-Go-错误处理" class="headerlink" title="1.Go 错误处理"></a>1.Go 错误处理</h4><p>（1）Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p>
<p>error类型是一个接口类型，这是它的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）我们可以在编码中通过实现 error 接口类型来生成错误信息。</p>
<p>函数通常在最后的返回值中返回错误信息。使用<font color="red">errors.New </font>可返回一个错误信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）在下面的例子中，我们在调用Sqrt的时候传递的一个负数，然后就得到了non-nil的error对象，将此对象与nil比较，结果为true，所以fmt.Println(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err:= Sqrt(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 DivideError 结构</span></span><br><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">    dividee <span class="keyword">int</span></span><br><span class="line">    divider <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `error` 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(de *DivideError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    strFormat := <span class="string">`</span></span><br><span class="line"><span class="string">    Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="string">    dividee: %d</span></span><br><span class="line"><span class="string">    divider: 0</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(strFormat, de.dividee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 `int` 类型除法运算的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(varDividee <span class="keyword">int</span>, varDivider <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>, errorMsg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> varDivider == <span class="number">0</span> &#123;</span><br><span class="line">            dData := DivideError&#123;</span><br><span class="line">                    dividee: varDividee,</span><br><span class="line">                    divider: varDivider,</span><br><span class="line">            &#125;</span><br><span class="line">            errorMsg = dData.Error()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> varDividee / varDivider, <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况</span></span><br><span class="line">    <span class="keyword">if</span> result, errorMsg := Divide(<span class="number">100</span>, <span class="number">10</span>); errorMsg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;100/10 = &quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当被除数为零的时候会返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span> _, errorMsg := Divide(<span class="number">100</span>, <span class="number">0</span>); errorMsg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;errorMsg is: &quot;</span>, errorMsg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>/<span class="number">10</span> =  <span class="number">10</span></span><br><span class="line">errorMsg is:  </span><br><span class="line">   Cannot proceed, the divider is zero.</span><br><span class="line">  dividee: <span class="number">100</span></span><br><span class="line">  divider: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>（4）</p>
<ul>
<li><a href="https://blog.csdn.net/m0_38004619/article/details/98968097">Go语言中的异常处理</a></li>
<li><a href="https://www.jianshu.com/p/f30da01eea97">Golang错误和异常处理的正确姿势</a></li>
</ul>
]]></content>
      <categories>
        <category>《Golang》</category>
      </categories>
      <tags>
        <tag>Go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-collections模块</title>
    <url>/2022/01/07/Python-collections%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<ul>
<li><p>collections模块实现一些特定的数据类型，可以替代Python中常用的内置数据类型如dict, list, set,tuple，简单说就是对基本数据类型做了更上一层的处理。</p>
</li>
<li><p>collections是日常工作中的重点、高频模块，常用类型有：</p>
<ul>
<li><p>计数器（Counter）</p>
</li>
<li><p>双向队列（deque）</p>
</li>
<li><p>默认字典（defaultdict）</p>
</li>
<li><p>有序字典（OrderedDict）</p>
</li>
<li><p>具名元组（namedtuple）　</p>
</li>
</ul>
</li>
</ul>
<h1 id="1-计数器Counter"><a href="#1-计数器Counter" class="headerlink" title="1. 计数器Counter"></a>1. 计数器Counter</h1><ul>
<li>Counter作为字典dict的一个子类， 可以支持方便、快速的计数 ，将元素进行数量统计，计数后返回一个字典，键值为元素，值为元素个数</li>
</ul>
<ul>
<li><p>常用方法</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">most_common(int)</td>
<td align="center">按照元素出现的次数进行从高到低的排序，返回前int个元素的字典</td>
</tr>
<tr>
<td align="center">elements</td>
<td align="center">返回经过计算器Counter后的元素，返回的是一个迭代器</td>
</tr>
<tr>
<td align="center">update</td>
<td align="center">和set集合的update一样，对集合进行并集更新</td>
</tr>
<tr>
<td align="center">subtract</td>
<td align="center">和update类似，只是update是做加法，subtract做减法,从另一个集合中减去本集合的元素</td>
</tr>
<tr>
<td align="center">items</td>
<td align="center">返回由Counter生成的字典的所有item</td>
</tr>
<tr>
<td align="center">keys</td>
<td align="center">返回由Counter生成的字典的所有key</td>
</tr>
<tr>
<td align="center">values</td>
<td align="center">返回由Counter生成的字典的所有value</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;abcabccabde&quot;</span></span><br><span class="line">li = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">dic = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span> : <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span> : <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Counter对象获取各个元素的个数，返回字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Counter(str):&quot;</span>, Counter(<span class="built_in">str</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Counter(li):&quot;</span>, Counter(li))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Counter(dic):&quot;</span>, Counter(dic))</span><br><span class="line"></span><br><span class="line"><span class="comment"># most_common(int)按照元素出现的次数进行从高到低的排序，返回前int个元素的元组（键，值）</span></span><br><span class="line">d1 = Counter(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.most_common(2):&quot;</span>,d1.most_common(<span class="number">2</span>))</span><br><span class="line">d1 = Counter(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.most_common():&quot;</span>,d1.most_common())    <span class="comment"># 不加参数返回所有</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># elements返回经过计算器Counter后的元素，返回的是一个迭代器</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;sorted(d1.elements()):&quot;</span>, <span class="built_in">sorted</span>(d1.elements()))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list(d1.elements()):&quot;</span>, <span class="built_in">list</span>(d1.elements()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># update和set集合的update一样，对集合进行并集更新</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.update(&#x27;aaa&#x27;):&quot;</span>, d1.update(<span class="string">&quot;aaa&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(d1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># subtract 和update类似，只是update是做加法，subtract做减法,从另一个集合中减去本集合的元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.substract(&#x27;aab&#x27;):&quot;</span>, d1.subtract(<span class="string">&quot;aab&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(d1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># items 返回由Counter生成的字典的所有item</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.items():&quot;</span>, d1.items())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回由Counter生成的字典的所有key</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.keys():&quot;</span>, d1.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回由Counter生成的字典的所有value</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.values():&quot;</span>, d1.values())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-&gt;Counter(<span class="built_in">str</span>): Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">-&gt;Counter(li): Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">-&gt;Counter(dic): Counter(&#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line">    </span><br><span class="line">-&gt;d1.most_common(<span class="number">2</span>): [(<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line">-&gt;d1.most_common(): [(<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">-&gt;<span class="built_in">sorted</span>(d1.elements()): [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">-&gt;<span class="built_in">list</span>(d1.elements()): [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">-&gt;d1.update(<span class="string">&#x27;aaa&#x27;</span>): <span class="literal">None</span></span><br><span class="line">-&gt;Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">-&gt;d1.substract(<span class="string">&#x27;aab&#x27;</span>): <span class="literal">None</span></span><br><span class="line">-&gt;Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">-&gt;d1.items(): dict_items([(<span class="string">&#x27;a&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">1</span>)])</span><br><span class="line">    </span><br><span class="line">-&gt;d1.keys(): dict_keys([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">-&gt;d1.values(): dict_values([<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2-双向队列deque"><a href="#2-双向队列deque" class="headerlink" title="2.双向队列deque"></a>2.双向队列deque</h1><ul>
<li>deque是栈和队列的一种广义实现，deque是”double-end queue”的简称；deque支持线程安全、有效内存地以近似O(1)的性能在deque的两端插入和删除元素，尽管list也支持相似的操作，但是它主要在固定长度操作上的优化，从而在pop(0)和insert(0,v)（会改变数据的位置和大小）上有O(n)的时间复杂度。</li>
</ul>
<ul>
<li><p>常用方法</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">append</td>
<td align="center">队列右边添加元素</td>
</tr>
<tr>
<td align="center">appendleft</td>
<td align="center">队列左边添加元素</td>
</tr>
<tr>
<td align="center">clear</td>
<td align="center">清空队列中的所有元素</td>
</tr>
<tr>
<td align="center">count(value)</td>
<td align="center">返回队列中包含value的个数</td>
</tr>
<tr>
<td align="center">extend</td>
<td align="center">队列右边扩展，可以是列表、元组或字典，如果是字典则将字典的key加入到deque</td>
</tr>
<tr>
<td align="center">extendleft</td>
<td align="center">同extend，在左边扩展</td>
</tr>
<tr>
<td align="center">pop</td>
<td align="center">移除并返回队列右边的元素</td>
</tr>
<tr>
<td align="center">popleft</td>
<td align="center">移除并返回队列左边的元素</td>
</tr>
<tr>
<td align="center">remove（value）</td>
<td align="center">移除队列第一个出现的元素</td>
</tr>
<tr>
<td align="center">reverse</td>
<td align="center">队列的所有元素进行反转</td>
</tr>
<tr>
<td align="center">rotate（n）</td>
<td align="center">对队列数进行移动</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">dst = deque(list1)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt; deque([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># append appendleft</span></span><br><span class="line">dst.append(<span class="number">4</span>)</span><br><span class="line">dst.appendleft(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># extend extendleft</span></span><br><span class="line">ex = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">st = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">dst.extend(ex)</span><br><span class="line">dst.extendleft(st)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop popleft</span></span><br><span class="line">dst.pop()</span><br><span class="line">dst.popleft()</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># count</span></span><br><span class="line"><span class="built_in">print</span>(dst.count(<span class="number">2</span>))</span><br><span class="line">-&gt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># insert</span></span><br><span class="line">dst.insert(<span class="number">0</span>, <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># rotate</span></span><br><span class="line">dst = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], maxlen = <span class="number">9</span>)</span><br><span class="line">dst.rotate(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], maxlen=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove</span></span><br><span class="line">dst.remove(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>], maxlen=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># maxlen</span></span><br><span class="line"><span class="built_in">print</span>(dst.maxlen)</span><br><span class="line">-&gt;<span class="number">9</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-默认字典defaultdict"><a href="#3-默认字典defaultdict" class="headerlink" title="3. 默认字典defaultdict"></a>3. 默认字典defaultdict</h1><ul>
<li> Python中通过Key访问字典，当Key不存在时，会引发<code>‘KeyError’</code>异常。为了避免这种情况的发生，可以使用collections类中的defaultdict()方法来为字典提供默认值 </li>
</ul>
<ul>
<li><p> defaultdict是内置数据类型dict的一个子类，基本功能与dict一样，只是重写了一个<code>missing(key)</code>和增加了一个可写的对象变量<font color="cornflowerblue"> default_factory </font> </p>
</li>
<li><p>如果default_factory属性为None，就报出以key作为遍历的KeyError异常；</p>
</li>
<li><p>如果default_factory不为None，就会向给定的key提供一个默认值，这个值插入到词典中，并返回； 如 d = defaultdict(list) ，默认值是一个空的列表</p>
</li>
<li><p>举例</p>
<ul>
<li><p>default_factory属性为None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># default_factory属性为None</span></span><br><span class="line">d = defaultdict()</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="comment"># 报错:KeyError: &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>default_factory属性为list（列表字典）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># default_factory属性为list</span></span><br><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;a&#x27;</span>])	<span class="comment"># 不存在键&#x27;a&#x27;时，返回默认值一个空的列表</span></span><br><span class="line"><span class="built_in">print</span>(d)		<span class="comment"># 此时d中增加了一个有默认值的键了</span></span><br><span class="line"><span class="comment"># -&gt;[]</span></span><br><span class="line"><span class="comment"># -&gt;defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;a&#x27;: []&#125;)</span></span><br><span class="line"></span><br><span class="line">s = [(<span class="string">&#x27;y&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;y&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;r&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">    d[k].append(v)	<span class="comment"># 如果不存在键K,则返回一个默认值[]给d[k]</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># -&gt;defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;y&#x27;: [1, 3], &#x27;b&#x27;: [2, 4], &#x27;r&#x27;: [1]&#125;)	</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dict.setdefault()也可以实现相同的功能</span></span><br><span class="line">e = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">    e.setdefault(k, []).append(v)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment"># -&gt;&#123;&#x27;y&#x27;: [1, 3], &#x27;b&#x27;: [2, 4], &#x27;r&#x27;: [1]&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>default_factory属性为set（集合字典）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将default_factory设置为set，使得defaultdict可以建立一个集合字典</span></span><br><span class="line">s = [(<span class="string">&#x27;r&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;r&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;r&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line">d = defaultdict(<span class="built_in">set</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">    d[k].add(v)     <span class="comment"># 键k不存在则返回一个默认的空set，set类似list,但set中元素不能重复</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># -&gt;defaultdict(&lt;class &#x27;set&#x27;&gt;, &#123;&#x27;r&#x27;: &#123;1, 3&#125;, &#x27;b&#x27;: &#123;2, 4&#125;&#125;)</span></span><br></pre></td></tr></table></figure></li>
<li><p>default_factory属性为int（计数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置default_factory为int，使得defaultdict可以用于计数</span></span><br><span class="line"><span class="comment"># 字符串中的字母第一次出现时，字典中没有该字母，default_factory函数调用int()为其提供一个默认值0,加法操作将计算出每个字母出现的次数。</span></span><br><span class="line">s = <span class="string">&#x27;abidajiadgaji&#x27;</span></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> s:</span><br><span class="line">    d[k] += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># -&gt;defaultdict(&lt;class &#x27;int&#x27;&gt;, &#123;&#x27;a&#x27;: 4, &#x27;b&#x27;: 1, &#x27;i&#x27;: 3, &#x27;d&#x27;: 2, &#x27;j&#x27;: 2, &#x27;g&#x27;: 1&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="4-具名元组namedtuple"><a href="#4-具名元组namedtuple" class="headerlink" title="4. 具名元组namedtuple"></a>4. 具名元组namedtuple</h1><ul>
<li><p>普通元组的局限性： 不能为元组内部的数据进行命名，所以往往我们并不知道一个元组所要表达的意义 </p>
</li>
<li><p> <strong>namedtuple</strong>： 引入了 <strong>collections.namedtuple</strong> 这个工厂函数，来构造一个带字段名的元组。具名元组的实例和普通元组消耗的内存一样多，因为字段名都被存在对应的类里面。这个类跟普通的对象实例比起来也要小一些，因为 Python 不会用 <strong>dict</strong> 来存放这些实例的属性。</p>
</li>
<li><p>定义格式：<font color="cornflowerblue">collections.namedtuple(typename, field_names, verbose=False, rename=False) </font></p>
<ul>
<li> <strong>typename</strong>：元组名称</li>
<li> <strong>field_names</strong>: 元组中元素的名称</li>
<li> <strong>rename</strong>: 如果元素名称中含有 python 的关键字，则必须设置为 rename=True</li>
<li> <strong>verbose</strong>: 默认就好</li>
</ul>
</li>
<li><p>创建命名元组并实例化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个具名元组，需要两个参数，一个是元组名，另一个是元组的各个字段名。</span></span><br><span class="line"><span class="comment"># 后者可以是有多个字符串组成的可迭代对象，或者是有空格分隔开的字段名组成的字符串</span></span><br><span class="line">User = namedtuple(<span class="string">&#x27;User&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">User = namedtuple(<span class="string">&#x27;User&#x27;</span>, <span class="string">&#x27;name age id&#x27;</span>)</span><br><span class="line"><span class="comment"># User是具名元组的变量名，&#x27;User&#x27;是具名元组的名称,一般相同</span></span><br><span class="line"></span><br><span class="line">zlx = User(<span class="string">&#x27;zlx&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(zlx)</span><br></pre></td></tr></table></figure></li>
<li><p>具名元组的特有属性</p>
<ul>
<li>类属性**_fields**： 包含这个类所有字段名的元组 </li>
<li>类方法 **_make(iterable)**：接受一个可迭代对象来生产这个类的实例 </li>
<li>实例方法 **_asdict()**：把具名元组以 collections.OrderedDict 的形式返回，可以利用它来把元组里的信息友好的展示出来 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取所有字段名</span></span><br><span class="line"><span class="built_in">print</span>(zlx._fields)</span><br><span class="line"><span class="comment"># -&gt; (&#x27;name&#x27;, &#x27;age&#x27;, &#x27;id&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取各个字段的值</span></span><br><span class="line"><span class="built_in">print</span>(zlx.name)</span><br><span class="line"><span class="built_in">print</span>(zlx.age)</span><br><span class="line"><span class="built_in">print</span>(zlx.<span class="built_in">id</span>)</span><br><span class="line"><span class="comment"># -&gt; zlx</span></span><br><span class="line"><span class="comment"># -&gt; 22</span></span><br><span class="line"><span class="comment"># -&gt; 123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改对象属性，注意要使用&quot;_replace&quot;方法</span></span><br><span class="line">zlx = zlx._replace(age=<span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(zlx)</span><br><span class="line"><span class="comment"># -&gt; User(name=&#x27;zlx&#x27;, age=18, id=&#x27;123456&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将User对象转换成字典，注意要使用&quot;_asdict&quot;</span></span><br><span class="line"><span class="built_in">print</span>(zlx._asdict())</span><br><span class="line"><span class="comment"># -&gt; &#123;&#x27;name&#x27;: &#x27;zlx&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: &#x27;123456&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-有序字典-OrderedDict"><a href="#5-有序字典-OrderedDict" class="headerlink" title="5. 有序字典 OrderedDict"></a>5. 有序字典 OrderedDict</h1><ul>
<li><p>python中的字典dict是无序的，即迭代遍历（键，值）的顺序可能和插入的顺序不一致，因为它是按照hash来存储的。 常规dict并不跟踪插入顺序，迭代处理会根据键在散列表中存储的顺序来生成值。在OrderDict中则相反，它会记住元素插入的顺序，并在创建迭代器时使用这个顺序。 </p>
</li>
<li><p>OrderedDict提供了一个有序的字典结构，内部维护这一个根据键插入顺序排序的双向链表，在迭代操作的时候保持了元素插入时的顺序。需要注意的是，一个OrderedDic的大小是一个普通字典的两倍，因为内部维护了另外一个链表，所有在数据量大的时候，如果不要求保持插入顺序，最好用普通字典。</p>
</li>
<li><p>有序字典和普通字典的相等测试：有序字典是对顺序敏感的，即元素插入顺序不同，两个有序字典就不同；普通字典对顺序是不敏感的，即元素插入顺序不同，两个普通字典仍相同。</p>
</li>
<li><p>有序字典除具有普通字典的原始方法外，还提供了和顺序相关的操作，popitem(last=True)以LIFO方式弹出元素（last=False则以FIFO方式）；reversed(dict)返回一个逆序的orderedDict对象</p>
</li>
<li><pre><code class="python">from collections import OrderedDict
d = &#123;&#125;
d[&#39;a&#39;] = &#39;A&#39;
d[&#39;b&#39;] = &#39;B&#39;
d[&#39;c&#39;] = &#39;C&#39;
for k, v in d.items():
    print(k, v)
b = &#123;&#125;
b[&#39;a&#39;] = &#39;A&#39;
b[&#39;c&#39;] = &#39;C&#39;
b[&#39;b&#39;] = &#39;B&#39;
for k, v in d.items():
    print(k, v)
print(d == b)   # True

d = OrderedDict()
d[&#39;a&#39;] = &#39;A&#39;
d[&#39;b&#39;] = &#39;B&#39;
d[&#39;c&#39;] = &#39;C&#39;
for k, v in d.items():
    print(k, v)
b = OrderedDict()
b[&#39;a&#39;] = &#39;A&#39;
b[&#39;c&#39;] = &#39;C&#39;
b[&#39;b&#39;] = &#39;B&#39;
for k, v in d.items():
    print(k, v)
print(d == b)   # False

print(d.popitem(last=True))
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-lambda表达式</title>
    <url>/2022/02/19/Python-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Python-lambda表达式"><a href="#Python-lambda表达式" class="headerlink" title="Python lambda表达式"></a>Python lambda表达式</h2><h3 id="一、语法和介绍"><a href="#一、语法和介绍" class="headerlink" title="一、语法和介绍"></a>一、语法和介绍</h3><ul>
<li>语法：<font color="red">lambda argument_list: expression</font><ul>
<li>lambda函数：又称“匿名函数”</li>
<li>argument_list：参数列表，作为函数的输入</li>
<li>expression：表达式，只能用到参数列表中出现的参数，根据表达式计算得到的值作为函数的输出</li>
</ul>
</li>
<li>介绍：<ul>
<li>lambda的函数体只有一个表达式，而非代码块，代码简洁</li>
<li>lambda函数无需命名即可快速调用</li>
<li>简单单行函数或一次性函数可以用lambda表达式来书写</li>
</ul>
</li>
</ul>
<h3 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h3><ol>
<li><p>匿名调用和命名调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># def函数写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># lambada表达式既可以匿名直接调用，也可以赋值给某个变量再调用</span></span><br><span class="line"><span class="comment"># 匿名调用</span></span><br><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> x, y: x + y)(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名调用</span></span><br><span class="line">a = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"><span class="built_in">print</span>(a(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>作为函数法返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x, y: x + y</span><br></pre></td></tr></table></figure></li>
<li><p>与其他函数配合使用</p>
<ul>
<li><p>filter(function, iterable)函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 过滤掉某些不符合条件的元素</span></span><br><span class="line"><span class="comment"># 其中iterable可以为列表、字符串或元组，逐一对元素通过function的条件进行筛选，然后保留下满足条件的数据。python3返回的是一个迭代器，可以用list进行转换得到输出结果</span></span><br><span class="line"><span class="comment"># 此时lambda函数用于指定过滤列表元素的条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留奇数</span></span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span>, nums))</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure></li>
<li><p>map(function, iterable)函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 会根据提供的function函数对指定序列做映射</span></span><br><span class="line"><span class="comment"># 逐一对元素通过function操作,返回的是一个迭代器，可以用list进行转换</span></span><br><span class="line"><span class="comment"># 此时lambda函数用于指定映射规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出平方</span></span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, nums))</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure></li>
<li><p>reduce(function, iterable)函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对参数序列中的元素进行累计</span></span><br><span class="line"><span class="comment"># 函数先将iterable中的第1和第2个元素进行function操作，将得到的结果与第3个数进行function操作，如此累积</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求和</span></span><br><span class="line">nums = reduce(<span class="keyword">lambda</span> x, y: x + y, nums)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure></li>
<li><p>sorted(iterable, key = function) 和 iterable.sort(key = function)函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时lambda函数用于指定对列表中所有元素进行排序的准则</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字符串长度排序</span></span><br><span class="line">s = [<span class="string">&quot;abdc&quot;</span>, <span class="string">&quot;djind&quot;</span>, <span class="string">&quot;in&quot;</span>, <span class="string">&quot;a&quot;</span>]</span><br><span class="line">s.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x))</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字典的键排序</span></span><br><span class="line">d = &#123;<span class="number">4</span>: <span class="string">&quot;hhh&quot;</span>, <span class="number">3</span>: <span class="string">&quot;jidn&quot;</span>, <span class="number">5</span>: <span class="string">&quot;djien&quot;</span>&#125;</span><br><span class="line">d = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按元组的某一位排序</span></span><br><span class="line">d = [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">0</span>)]</span><br><span class="line">d = <span class="built_in">list</span>(<span class="built_in">sorted</span>(d, key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="三、举例"><a href="#三、举例" class="headerlink" title="三、举例"></a>三、举例</h3><p>​    将字符串按照字母顺序排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python中的字符串类型是不允许直接修改元素的。必须先把要排序的字符串放在容器里，如list。然后在通过sort函数排序，最后还原成字符串</span></span><br><span class="line">s=<span class="string">&quot;string&quot;</span></span><br><span class="line">l=<span class="built_in">list</span>(s)</span><br><span class="line">l.sort()</span><br><span class="line">s=<span class="string">&quot;&quot;</span>.join(l)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="comment"># 通过lambda表达式一行搞定</span></span><br><span class="line"><span class="comment"># 表达式为 （x.sort(), x）[1] 去元组中的第二个数,即已经排好序的参数x,而传入的参数是list(s)</span></span><br><span class="line">s=<span class="string">&quot;&quot;</span>.join((<span class="keyword">lambda</span> x:(x.sort(),x)[<span class="number">1</span>])(<span class="built_in">list</span>(s)))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>匿名函数</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>获取前k大的索引</title>
    <url>/2022/03/11/%E8%8E%B7%E5%8F%96%E5%89%8Dk%E5%A4%A7%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<ul>
<li>获取前n大的元素索引</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMaxNumIndex</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    max_num_index = <span class="built_in">list</span>(<span class="built_in">map</span>(nums.index, heapq.nlargest(k, nums)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;max_num_index:&#x27;</span>, max_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMaxNumIndex2</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    copy_nums = copy.deepcopy(nums)</span><br><span class="line">    copy_nums.sort()</span><br><span class="line">    max_num_index = [nums.index(one) <span class="keyword">for</span> one <span class="keyword">in</span> copy_nums[-k:]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;max_num_index:&#x27;</span>, max_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMaxNumIndex3</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    num_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        num_dict[i] = nums[i]</span><br><span class="line">    <span class="comment"># 先按x[1]值大小排序，值相同的按x[0]索引排序</span></span><br><span class="line">    sort_list = <span class="built_in">sorted</span>(num_dict.items(), key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], -x[<span class="number">0</span>]))</span><br><span class="line">    max_num_index = [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> sort_list[-k:]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;max_num_index:&#x27;</span>, max_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMaxNumIndex4</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    copy_list = copy.deepcopy(nums)</span><br><span class="line">    min_num = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    max_num_index = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        one_max_index = copy_list.index(<span class="built_in">max</span>(copy_list))</span><br><span class="line">        max_num_index.append(one_max_index)</span><br><span class="line">        copy_list[one_max_index] = min_num</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;max_num_index:&#x27;</span>, max_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMaxNumIndex5</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    nums = np.array(nums)</span><br><span class="line">    <span class="built_in">print</span>(nums.argsort())</span><br><span class="line">    <span class="comment"># argsort将nums从小到达排序，并提取在原数组中的索引</span></span><br><span class="line">    <span class="comment"># 排序前   [12, 3, 4, 18, 20, 1, 34, 2, 0]</span></span><br><span class="line">    <span class="comment"># 排序后   [0, 1, 2, 3, 4, 12, 18, 20, 34]</span></span><br><span class="line">    <span class="comment"># 提取索引后[8, 5, 7, 1, 2, 0, 3, 4, 6]</span></span><br><span class="line">    max_num_index = nums.argsort()[-k:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;max_num_index:&#x27;</span>, max_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">    k = <span class="number">3</span></span><br><span class="line">    getListMaxNumIndex(nums, k)</span><br><span class="line">    getListMaxNumIndex2(nums, k)</span><br><span class="line">    getListMaxNumIndex3(nums, k)</span><br><span class="line">    getListMaxNumIndex4(nums, k)</span><br><span class="line">    getListMaxNumIndex5(nums, k)</span><br></pre></td></tr></table></figure>



<ul>
<li>获取前n小的元素索引</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMinNumIndex</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    min_num_index = <span class="built_in">list</span>(<span class="built_in">map</span>(nums.index, heapq.nsmallest(k, nums)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;min_num_index:&#x27;</span>, min_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMinNumIndex2</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    copy_nums = copy.deepcopy(nums)</span><br><span class="line">    copy_nums.sort()</span><br><span class="line">    min_num_index = [nums.index(one) <span class="keyword">for</span> one <span class="keyword">in</span> copy_nums[:k]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;min_num_index:&#x27;</span>, min_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMinNumIndex3</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    num_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        num_dict[i] = nums[i]</span><br><span class="line">    <span class="comment"># 先按x[1]值大小排序，值相同的按x[0]索引排序</span></span><br><span class="line">    sort_list = <span class="built_in">sorted</span>(num_dict.items(), key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], -x[<span class="number">0</span>]))</span><br><span class="line">    min_num_index = [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> sort_list[:k]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;min_num_index:&#x27;</span>, min_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMinNumIndex4</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    copy_list = copy.deepcopy(nums)</span><br><span class="line">    max_num = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    min_num_index = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        one_min_index = copy_list.index(<span class="built_in">min</span>(copy_list))</span><br><span class="line">        min_num_index.append(one_min_index)</span><br><span class="line">        copy_list[one_min_index] = max_num</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;min_num_index:&#x27;</span>, min_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMinNumIndex5</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    nums = np.array(nums)</span><br><span class="line">    <span class="built_in">print</span>(nums.argsort())</span><br><span class="line">    <span class="comment"># argsort将nums从小到达排序，并提取在原数组中的索引</span></span><br><span class="line">    <span class="comment"># 排序前   [12, 3, 4, 18, 20, 1, 34, 2, 0]</span></span><br><span class="line">    <span class="comment"># 排序后   [0, 1, 2, 3, 4, 12, 18, 20, 34]</span></span><br><span class="line">    <span class="comment"># 提取索引后[8, 5, 7, 1, 2, 0, 3, 4, 6]</span></span><br><span class="line">    min_num_index = nums.argsort()[:k]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;min_num_index:&#x27;</span>, min_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">    k = <span class="number">3</span></span><br><span class="line">    getListMinNumIndex(nums, k)</span><br><span class="line">    getListMinNumIndex2(nums, k)</span><br><span class="line">    getListMinNumIndex3(nums, k)</span><br><span class="line">    getListMinNumIndex4(nums, k)</span><br><span class="line">    getListMinNumIndex5(nums, k)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础容器</title>
    <url>/2021/12/24/Python%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一、列表"><a href="#一、列表" class="headerlink" title="一、列表"></a>一、列表</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li><p>L.<strong>index</strong>(v)</p>
</li>
<li><p>L.index(v  , begin) </p>
</li>
<li><p>L.index(v  , begin, end) </p>
<p>返回对应元素的索引下标, begin为开始索引，end为结束索引,当 value 不存在时触发ValueError错误 </p>
</li>
</ul>
<ul>
<li><p>L.<strong>count</strong>(x)</p>
<p>用于统计某个元素在列表中出现的次数 </p>
</li>
</ul>
<ul>
<li><p>L.<strong>pop</strong>([index])</p>
<p>删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系</p>
</li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li><p>L.<strong>insert</strong>(index,  obj)</p>
<p>将某个元素插放到列表中指定的位置 </p>
<p><strong>有序列表的查找和插入</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python内置bisect(对分)模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bisect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>]  // 这是一个有序序列</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.bisect(list1, <span class="number">5</span>)  // 返回<span class="number">5</span>应该在list1中的索引</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1  // 但list1没变</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.insort(list1, <span class="number">5</span>)   // 这里是insort， 不是insert, </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>]    // list1 结果变了</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1.insert(<span class="number">0</span>, <span class="number">8</span>)     // <span class="built_in">list</span>的insert操作不要求列表有序</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1</span><br><span class="line">[<span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1.insert(<span class="number">8</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1</span><br><span class="line">[<span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>L.<strong>extend</strong>(lst)</p>
<p>向列表追加另一个列表</p>
</li>
<li><p>L.<strong>remove</strong>(x)</p>
<p> 从列表中删除第一次出现在列表中的值 x</p>
</li>
<li><p>L.<strong>clear</strong>()</p>
<p>清空列表,等同于 L[:] = [] </p>
</li>
<li><p>L.<strong>sort</strong>(reverse=False)</p>
<p>将列表中的元素进行排序，默认顺序按值的小到大的顺序排列 </p>
</li>
<li><p>L.<strong>reverse</strong>() </p>
</li>
<li><p>列表的反转，用来改变原列表的先后顺序 </p>
</li>
</ul>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><ul>
<li><p>L.<strong>copy</strong>()</p>
<p>复制此列表（只复制一层，不会复制深层对象) </p>
</li>
</ul>
<h2 id="获取前k大的索引"><a href="#获取前k大的索引" class="headerlink" title="获取前k大的索引"></a>获取前k大的索引</h2><ul>
<li><a href="/2022/03/11/%E8%8E%B7%E5%8F%96%E5%89%8Dk%E5%A4%A7%E7%9A%84%E7%B4%A2%E5%BC%95/" title="获取前k大的索引">获取前k大的索引</a></li>
</ul>
<h2 id="通过累加函数构建前缀和列表"><a href="#通过累加函数构建前缀和列表" class="headerlink" title="通过累加函数构建前缀和列表"></a>通过累加函数构建前缀和列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="built_in">list</span>(accumulate(nums, initial=<span class="number">0</span>))</span><br><span class="line"><span class="comment"># S[Right] - S[Left] 表示区间[Left, Right)的元素和 </span></span><br></pre></td></tr></table></figure>





<h1 id="二、字典"><a href="#二、字典" class="headerlink" title="二、字典"></a>二、字典</h1><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><ul>
<li><strong>get</strong>(key,  default=None)<br>返回指定键的值，如果值不在字典中返回default值</li>
</ul>
<ul>
<li><strong>setdefault</strong>(key,  default=None)<br>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</li>
</ul>
<ul>
<li><strong>popitem</strong>()<br>随机返回并删除字典中的一对键和值(一般删除末尾对)。</li>
</ul>
<ul>
<li><strong>items</strong>()<br>以列表返回可遍历的(键, 值)  元组数组</li>
</ul>
<ul>
<li><strong>keys</strong>()<br>返回一个迭代器，可以使用 list() 来转换为列表</li>
</ul>
<ul>
<li><strong>values</strong>()<br>返回一个迭代器，可以使用 list() 来转换为列表</li>
</ul>
<h2 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h2><ul>
<li><strong>update</strong>(dict2)<br>字典记录累加，把字典参数 dict2 的 key/value(键/值) 对更新到字典 dict 里。</li>
</ul>
<ul>
<li><p><strong>clear</strong>()</p>
<p>删除字典内所有元素</p>
</li>
</ul>
<ul>
<li><p><strong>del</strong> dic[key]</p>
<p>删除字典内单个元素</p>
</li>
</ul>
<h2 id="获取最大值的索引"><a href="#获取最大值的索引" class="headerlink" title="获取最大值的索引"></a>获取最大值的索引</h2><ul>
<li><p>获取最大值/最小值的键</p>
<ul>
<li>max_key = max(my_dic, key=my_dic.get)</li>
<li>min_key = min(my_dic, key=my_dic.get)</li>
</ul>
</li>
<li><p>获取最大值/最小值及其键</p>
<ul>
<li>max_item = max(zip(my_dic.values(), my_dic,keys()))</li>
<li>min_item = min(zip(my_dic.values(), my_dic.keys()))</li>
<li>zip():将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。</li>
</ul>
</li>
</ul>
<h2 id="键相同值相加的几种方法"><a href="#键相同值相加的几种方法" class="headerlink" title="键相同值相加的几种方法"></a>键相同值相加的几种方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">dict1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict2 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line">x, y = Counter(dict1), Counter(dict2)</span><br><span class="line">result = <span class="built_in">dict</span>(x+y)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">输出：</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line">A = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">B = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> B.items():</span><br><span class="line">	<span class="keyword">if</span> key <span class="keyword">in</span> A:</span><br><span class="line">		A[key] += value</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		A[key] = value</span><br><span class="line"><span class="built_in">dict</span>(<span class="built_in">sorted</span>(A.items(), key=<span class="keyword">lambda</span> d:d[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3</span></span><br><span class="line">A = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">B = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line">C = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">set</span>(A) | <span class="built_in">set</span>(B)):</span><br><span class="line">	<span class="keyword">if</span> A.get(key) <span class="keyword">and</span> B.get(key):</span><br><span class="line">		C.update(&#123;key: A.get(key) + B.get(key)&#125;)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		C.update(&#123;key: A.get(key) <span class="keyword">or</span> B.get(key)&#125;)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法4</span></span><br><span class="line">A = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">B = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict_union</span>(<span class="params">d1, d2</span>):</span></span><br><span class="line">	keys = d1.keys() | d2.keys()</span><br><span class="line">	temp = &#123;&#125;</span><br><span class="line"> 	<span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">	temp[key] = <span class="built_in">sum</span>([d.get(key,<span class="number">0</span>) <span class="keyword">for</span> d <span class="keyword">in</span> (d1, d2)])</span><br><span class="line">	<span class="keyword">return</span> temp</span><br><span class="line">C = dict_union(A, B)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法5</span></span><br><span class="line">A = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">B = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line">C = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key1 <span class="keyword">in</span> A:</span><br><span class="line">	<span class="keyword">for</span> key2 <span class="keyword">in</span> B:</span><br><span class="line">		<span class="keyword">if</span> key1 <span class="keyword">in</span> B:</span><br><span class="line">			C[key1] = A[key1] + B[key1]</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			C[key1] = A[key1]</span><br><span class="line">		<span class="keyword">if</span> key2 <span class="keyword">not</span> <span class="keyword">in</span> A:</span><br><span class="line">			C[key2] = B[key2]</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法6</span></span><br><span class="line">A = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">B = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line">C = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> A:</span><br><span class="line">	<span class="keyword">if</span> B.get(key):</span><br><span class="line">		C[key] = A[key] + B[key]</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		C[key] = A[key]</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> B:</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> A.get(key):</span><br><span class="line">		C[key] = B[key]</span><br><span class="line"><span class="built_in">print</span>(C)</span><br></pre></td></tr></table></figure>



<h1 id="三、集合"><a href="#三、集合" class="headerlink" title="三、集合"></a>三、集合</h1><ul>
<li><p><strong>update</strong>() </p>
<p>给集合添加元素</p>
</li>
<li><p><strong>clear</strong>() </p>
<p>移除集合中的所有元素</p>
</li>
<li><p><strong>copy</strong>() </p>
<p>拷贝一个集合</p>
</li>
<li><p><strong>pop</strong>() </p>
<p>随机移除元素</p>
</li>
</ul>
<h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ul>
<li><p><strong>isspace</strong>()</p>
<p>如果字符串中只包含空白，则返回 True，否则返回  False.</p>
</li>
</ul>
<ul>
<li><p><strong>startswith</strong>(substr,  beg=0, end=len(string))</p>
<p>检查字符串是否是以指定子字符串  substr 开头，是则返回 True，否则返回 False。如果beg 和 end  指定值，则在指定范围内检查。</p>
</li>
</ul>
<ul>
<li><p><strong>endswith</strong>(suffix,  beg=0, end=len(string))</p>
<p>检查字符串是否以 obj 结束，如果beg 或者 end  指定则检查指定的范围内是否以 obj 结束，如果是，返回  True,否则返回 False.</p>
</li>
</ul>
<h2 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h2><ul>
<li><p><strong>find</strong>(str,  beg=0 end=len(string))</p>
<p>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</p>
</li>
<li><p><strong>rfind</strong>(str,  beg=0,end=len(string))</p>
<p>类似于 find()函数，不过是从右边开始查找.</p>
</li>
</ul>
<ul>
<li><p><strong>count</strong>(str,  beg= 0,end=len(string))</p>
<p>里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</p>
</li>
</ul>
<h2 id="修改-2"><a href="#修改-2" class="headerlink" title="修改"></a>修改</h2><ul>
<li><p><strong>replace</strong>(old,  new [, max])</p>
<p>把  将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。</p>
</li>
<li><p><strong>lstrip</strong>()</p>
<p>截掉字符串左边的空格或指定字符。</p>
</li>
</ul>
<ul>
<li><p><strong>rstrip</strong>()</p>
<p>删除字符串字符串末尾的空格.</p>
</li>
<li><p><strong>strip</strong>([chars])</p>
<p>在字符串上执行 lstrip()和  rstrip()</p>
</li>
</ul>
<ul>
<li><p><strong>lower</strong>()</p>
<p>转换字符串中所有大写字符为小写.</p>
</li>
</ul>
<ul>
<li><p><strong>upper</strong>()</p>
<p>转换字符串中的小写字母为大写</p>
</li>
</ul>
<ul>
<li><p><strong>swapcase</strong>()</p>
<p>将字符串中大写转换为小写，小写转换为大写</p>
</li>
</ul>
<h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><ul>
<li><p><strong>center</strong>(width,  fillchar)</p>
<p>返回一个指定的宽度 width 居中的字符串，fillchar  为填充的字符，默认为空格。</p>
</li>
</ul>
<ul>
<li><p><strong>zfill</strong> (width)</p>
<p>返回长度为 width 的字符串，原字符串右对齐，前面填充0</p>
</li>
<li><p><strong>ljust</strong>(width[,  fillchar])</p>
<p>返回一个原字符串左对齐,并使用 fillchar 填充至长度  width 的新字符串，fillchar 默认为空格。</p>
</li>
</ul>
<h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><ul>
<li><p>str.<strong>split</strong>(‘分割符’)</p>
<p>将str按指定的一个分隔符进行分割</p>
</li>
<li><p><strong>re.split</strong>(‘分割符1|分割符2|…’, str)    或    <strong>re.split</strong>(r’[分割符1, 分割符2, …]’, str) </p>
<p>​    将str按指定的一些分隔符进行分割，不保留分隔符</p>
</li>
<li><p><strong>re.split</strong>(‘(分割符1|分割符2|…)’, str)    或    <strong>re.split</strong>(r’([分割符1, 分割符2, …])’, str) </p>
<p>​    将str按指定的一些分隔符进行分割，保留分隔符</p>
</li>
</ul>
<h2 id="数组转化为字符串，再还原为数组"><a href="#数组转化为字符串，再还原为数组" class="headerlink" title="数组转化为字符串，再还原为数组"></a>数组转化为字符串，再还原为数组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如：[1, 12, 3, 4] =&gt; &#x27;1,12,3,4&#x27; =&gt; [1, 12, 3, 4]</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">b = <span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, a))</span><br><span class="line">c = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, b.split(<span class="string">&#x27;,&#x27;</span>)))</span><br></pre></td></tr></table></figure>



<h1 id="五、二分查找标准库bisect"><a href="#五、二分查找标准库bisect" class="headerlink" title="五、二分查找标准库bisect"></a>五、二分查找标准库bisect</h1><p>Python的标准库<strong>bisect</strong>支持了二分查找算法，可以使用二分查找在<strong>有序</strong>列表中查询或插入元素。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><strong>bisect_left</strong>(a, x, lo=0, hi=len(a))：寻找目标元素出现的最左侧位置的索引</li>
<li><strong>bisect_right</strong>(a, x, lo=0, hi=len(a))：寻找目标元素出现的最右侧位置的索引**+1**（注意当目标位置为列表末尾时，返回的索引在列表中不存在）</li>
<li><strong>insort_left</strong>(a, x, lo=0, hi=len(a))：将新元素插入到目标元素出现的最左侧位置的左侧</li>
<li><strong>insort_right</strong>(a, x, lo=0, hi=len(a))：将新元素插入到目标元素出现的最右侧位置的右侧</li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>a : 允许存在重复值的递增列表（参数类型：需要支持<code>insert</code>、<code>__len__</code>、<code>__item__</code>方法）</li>
<li>x : 需要查找的目标元素或需要插入的新元素（参数类型：需要支持<code>__lt__</code>方法）</li>
<li>lo : 二分查找范围的左侧边界（包含边界元素）</li>
<li>hi : 二分查找范围的右侧边界（不包含边界元素）</li>
</ul>
<p><strong>1. bisect_left和bisect_right的用法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bisect_left:&quot;</span>, bisect.bisect_left(array, <span class="number">2</span>))  <span class="comment"># 1 (结果为第1个出现的“2”的索引)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bisect_right:&quot;</span>, bisect.bisect_right(array, <span class="number">2</span>))  <span class="comment"># 4 (结果为最后1个出现的“2”的索引+1)</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>2. lo参数和hi参数的用法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bisect_left:&quot;</span>, bisect.bisect_left(array, <span class="number">0</span>, lo=<span class="number">2</span>))  <span class="comment"># 2 (查找范围为第2个到最后1个，因此没有0出现，结果为最左侧的位置)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bisect_right:&quot;</span>, bisect.bisect_left(array, <span class="number">6</span>, hi=<span class="number">5</span>))  <span class="comment"># 5 (查找范围为第1个到第5个，因此6没有出现，结果为最右侧的位置)</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 当查找的元素不存在于列表中时</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bisect_left:&quot;</span>, bisect.bisect_left(array, <span class="number">5</span>))  <span class="comment"># 3 (结果为大于目标元素的第1个元素的索引)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bisect_right:&quot;</span>, bisect.bisect_right(array, <span class="number">5</span>))  <span class="comment"># 3 (结果为大于目标元素的第1个元素的索引)</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>



<p><strong>4. insort_left和insort_right的用法</strong></p>
<blockquote>
<p>我们用支持大小比较的整数和浮点数来区别列表中的数和新插入的数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">bisect.insort_left(array, <span class="number">2.00</span>)</span><br><span class="line"><span class="built_in">print</span>(array)  <span class="comment"># [0, 2.0, 2, 2, 2, 5] (将2.00插入到了第1个出现的“2”的左侧)</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">array = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">bisect.insort_right(array, <span class="number">2.00</span>)</span><br><span class="line"><span class="built_in">print</span>(array)  <span class="comment"># [0, 2, 2, 2, 2.0, 5] (将2.00插入到了最后1个出现的“2”的右侧)</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 当插入的元素不存在于列表中时</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>]</span><br><span class="line">bisect.insort_left(array, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(array)  <span class="comment"># [1, 2, 4, 5, 8, 16] (将5插入到了4和8之间)</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>]</span><br><span class="line">bisect.insort_right(array, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(array)  <span class="comment"># [1, 2, 4, 5, 8, 16] (将5插入到了4和8之间)</span></span><br></pre></td></tr></table></figure>



<p>综上，我们可以对调用方法作出如下总结：</p>
<ul>
<li>当需要查找或插入的元素不存在时，<code>bisect_left</code>和<code>bisect_right</code>、<code>insort_left</code>和<code>insort_right</code>没有区别；</li>
<li><code>bisect_right</code>返回的索引是最后1个出现元素的索引+1</li>
</ul>
<hr>
<p>下面我们来看性能。因为<code>bisect_left</code>和<code>bisect_right</code>、<code>insort_left</code>和<code>insort_right</code>在时间、空间的利用上没有区别，因此可以合并处理。</p>
<p>依据函数源代码，我们可以计算出两个函数的渐进性能如下表。其中N表示元素的长度，K表示目标元素的索引。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>运行时间</th>
</tr>
</thead>
<tbody><tr>
<td>bisect</td>
<td>O ( l o g N ) O(logN)<em>O</em>(<em>l<strong>o</strong>g**N</em>)</td>
</tr>
<tr>
<td>insort</td>
<td>O ( l o g N + ( N − K ) ) O(logN+(N-K))<em>O</em>(<em>l<strong>o</strong>g**N</em>+(<em>N</em>−<em>K</em>)) : 其中L o g N LogN<em>L<strong>o</strong>g**N</em>为找到插入位置的时间，N − K N-K<em>N</em>−<em>K</em>为插入元素的时间</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>从性能上来说，insort函数并不适合频繁使用</strong></p>
<p>有时，我们可能需要在向列表中插入元素的同时，计算当前列表中小于（或大于）插入元素的元素数量。这种情况下如果使用二分查找依次插入每一个元素，那么每次使用insort函数插入元素都需要O ( N ) O(N)<em>O</em>(<em>N</em>)的时间复杂度，总计需要O ( N 2 ) O(N^2)<em>O</em>(<em>N</em>2)的时间复杂度，这样的效率是比较低的。这时我们需要考虑使用树状数组或线段树，在O ( N l o g N ) O(NlogN)<em>O</em>(<em>Nl<strong>o</strong>g**N</em>)的时间复杂度内解决这个问题。</p>
</blockquote>
<p>最后，我们看一下实际运行的效率。因为bisect模块中的方法在cpython中是直接由C语言实现的（bisect模块的函数在实现上引用自_bisect模块，引用的函数将会覆盖引用前的同名函数），因此其运行效率明显高于由Python原生代码实现的运行效率。具体运行效率差异可以参考下表中的几个测试（timeit模块计算）。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>循环次数</th>
<th>cpython</th>
<th>Python</th>
</tr>
</thead>
<tbody><tr>
<td>bisect_left([i for i in range(10000)], 1234)</td>
<td>1000000</td>
<td>0.3297</td>
<td>1.9943</td>
</tr>
<tr>
<td>bisect_left([i for i in range(100000)], 12345)</td>
<td>1000000</td>
<td>0.3127</td>
<td>2.5913</td>
</tr>
<tr>
<td>insort_left([i for i in range(10000)], 1234)</td>
<td>100000</td>
<td>2.3006</td>
<td>2.4779</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab学习笔记</title>
    <url>/2022/04/15/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一、命名规则"><a href="#一、命名规则" class="headerlink" title="一、命名规则"></a>一、命名规则</h2><ul>
<li>变量名区分大小写</li>
<li>变量名长度不超过63位 (MATLAB R2012a 32bit和64bit计算机上测试结果)</li>
<li>变量名以字母开头，可以由字母、数字和下划线组成,但不能使用标点</li>
<li>变量名应简洁明了，通过变量名可以直观看出变量所表示的物理意义</li>
</ul>
<ul>
<li>clear all：除Workspace中所有的变量</li>
<li>clc ：清除Command Window中的所有命令</li>
<li>注释：%%或%</li>
</ul>
<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><h3 id="1-数字"><a href="#1-数字" class="headerlink" title="1. 数字"></a>1. 数字</h3><ul>
<li>rand：生成均匀分布的伪随机数，分布在（0~1）之间<ul>
<li>rand(m, n)：生成m行n列的均匀分布的伪随机数</li>
<li>rand(m, n, ‘double’)：生成指定精度的均匀分布的伪随机数，参数还可以是’single’</li>
<li>rand(RandStream, m, n)利用指定的RandStream（随机种子）生成为随机数</li>
</ul>
</li>
<li>randn：生成标准正态分布的伪随机数（均值为0，方差为1，语法同上）</li>
<li>randi：生成均匀分布的伪随机数<ul>
<li>randi(iMax)：在开区间(0，iMax)生成均匀分布的为随机整数</li>
<li>randi(iMax)：在开区间(0, iMax)生成m*n型随机矩阵</li>
<li>randi([iMin, iMax], m, n)：在开区间(iMin, iMax)生成m*n型随机矩阵</li>
</ul>
</li>
</ul>
<h3 id="2-字符与字符串"><a href="#2-字符与字符串" class="headerlink" title="2. 字符与字符串"></a>2. 字符与字符串</h3><h3 id="3-矩阵"><a href="#3-矩阵" class="headerlink" title="3. 矩阵"></a>3. 矩阵</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]	<span class="comment">% 定义矩阵</span></span><br><span class="line">B = A&#x27;		<span class="comment">% 求矩阵的转置</span></span><br><span class="line">C = A(:)	<span class="comment">% 矩阵向量化（竖直方向）</span></span><br><span class="line">D = inv(A)	<span class="comment">% 求矩阵的逆矩阵</span></span><br><span class="line"></span><br><span class="line">E = <span class="built_in">zeros</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">3</span>)	<span class="comment">% 创建10行5列全是0的3维矩阵</span></span><br><span class="line">E(:, :, <span class="number">1</span>) = <span class="built_in">rand</span>(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">E(:, :, <span class="number">2</span>) = randi([<span class="number">3</span>, <span class="number">8</span>], <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">E(:, :, <span class="number">3</span>) = <span class="built_in">randn</span>(<span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<h3 id="4-元胞数组ceil"><a href="#4-元胞数组ceil" class="headerlink" title="4. 元胞数组ceil"></a>4. 元胞数组ceil</h3><ul>
<li>元胞数组是MATLAB中特有的一种数据类型，是数组的一种，其内部元素可以是属于不同的数据类型，概念理解上，可以认为它和c语言里面的结构体、C++里面的对象很类似。元胞数组是matlab中的特色数据类型，它不同于其它数据类型(如字符型，字符数组或者叫字符串，以及一般的算术数据和数组)。它特有的存取数据方法决定了它的特点，它有给人一种查询信息的感觉，可以逐渐追踪一直到所有的变量全部翻译成基本的数据信息。它的class函数输出就是cell(细胞之意)。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">ceil</span>(<span class="number">1</span>, <span class="number">6</span>)	<span class="comment">% 生成一个1行5列的元胞数组</span></span><br><span class="line">A[<span class="number">2</span>] = <span class="built_in">eye</span>(<span class="number">3</span>)	<span class="comment">% 将一个3*3的单位矩阵赋值给元胞数组第2个盒子（注意：索引从1开始）</span></span><br><span class="line">A[<span class="number">5</span>] = <span class="built_in">magic</span>(<span class="number">5</span>)	<span class="comment">% 将一个5*5幻方矩阵赋值给元胞数组第5个盒子</span></span><br><span class="line">B = A[<span class="number">2</span>]		<span class="comment">% 将元胞数组第5个盒子取出</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="5-结构体struct"><a href="#5-结构体struct" class="headerlink" title="5. 结构体struct"></a>5. 结构体struct</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">books = struct(<span class="string">&#x27;name&#x27;</span>, &#123;&#123;<span class="string">&#x27;Math&#x27;</span>, <span class="string">&#x27;English&#x27;</span>&#125;&#125;, <span class="string">&#x27;price&#x27;</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line">books.name	<span class="comment">% 属性</span></span><br><span class="line">books.name(<span class="number">1</span>)	<span class="comment">% 取出的是ceil</span></span><br><span class="line">books.name&#123;<span class="number">1</span>&#125;	<span class="comment">% 取出的是字符串</span></span><br></pre></td></tr></table></figure>



<h2 id="三、矩阵操作"><a href="#三、矩阵操作" class="headerlink" title="三、矩阵操作"></a>三、矩阵操作</h2><h3 id="1-矩阵定义与构造"><a href="#1-矩阵定义与构造" class="headerlink" title="1. 矩阵定义与构造"></a>1. 矩阵定义与构造</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">B = <span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>			<span class="comment">% 生成从1到9步长为2的一行多列矩阵</span></span><br><span class="line">C = <span class="built_in">repmat</span>(B, <span class="number">3</span>, <span class="number">2</span>)	<span class="comment">% 将矩阵B按照3行2列复制生成矩阵</span></span><br><span class="line">D = <span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">4</span>)		<span class="comment">% 创建2行4列全是1的矩阵</span></span><br><span class="line">E = <span class="built_in">zeros</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">3</span>)	<span class="comment">% 创建10行5列全是0的3维矩阵</span></span><br></pre></td></tr></table></figure>



<h3 id="2-矩阵的四则运算"><a href="#2-矩阵的四则运算" class="headerlink" title="2. 矩阵的四则运算"></a>2. 矩阵的四则运算</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">C = A + B</span><br><span class="line">D = A - B</span><br><span class="line">E = A * B</span><br><span class="line">F = A .* B	<span class="comment">% 对应项相乘</span></span><br><span class="line">G = A / B	<span class="comment">% 等价于A*inv(B)</span></span><br><span class="line">H = A ./ B	<span class="comment">% 对应项相除</span></span><br></pre></td></tr></table></figure>



<h3 id="3-矩阵下标"><a href="#3-矩阵下标" class="headerlink" title="3. 矩阵下标"></a>3. 矩阵下标</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">B = A(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">C = A(<span class="number">2</span>, :)</span><br><span class="line">D = A(:, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">find</span>(A &gt; <span class="number">20</span>)	<span class="comment">% 找到A中值大于20的索引值，m表示行索引，n表示列索引</span></span><br></pre></td></tr></table></figure>



<h2 id="四、程序结构"><a href="#四、程序结构" class="headerlink" title="四、程序结构"></a>四、程序结构</h2><h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1. for循环"></a>1. for循环</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量 = 初值:步长:中值			<span class="comment">% 步长默认值为1</span></span><br><span class="line">	执行语句<span class="number">1</span></span><br><span class="line">	、、、</span><br><span class="line">	执行语句n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2. while循环"></a>2. while循环</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式</span><br><span class="line">	执行语句<span class="number">1</span></span><br><span class="line">	、、、</span><br><span class="line">	执行语句<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="3-if分支结构"><a href="#3-if分支结构" class="headerlink" title="3. if分支结构"></a>3. if分支结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 条件表达式</span><br><span class="line">	语句体</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if 条件表达式</span><br><span class="line">	语句体1</span><br><span class="line">else</span><br><span class="line">	语句体2</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="五、基本绘图操作"><a href="#五、基本绘图操作" class="headerlink" title="五、基本绘图操作"></a>五、基本绘图操作</h2><h3 id="1-二维平面绘图"><a href="#1-二维平面绘图" class="headerlink" title="1. 二维平面绘图"></a>1. 二维平面绘图</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">figure</span>  <span class="comment">% 建立一个幕布</span></span><br><span class="line"><span class="built_in">plot</span>(x,y)   <span class="comment">% 绘图</span></span><br><span class="line">title(<span class="string">&#x27;y=sin(x)&#x27;</span>)   <span class="comment">% 标题</span></span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>) <span class="comment">% x轴标签</span></span><br><span class="line">ylabel(<span class="string">&#x27;sin(x)&#x27;</span>)    <span class="comment">% y轴标签</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">2</span>*<span class="built_in">pi</span>])  <span class="comment">% x轴取值范围</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1650249994373.png" alt="1650249994373"></p>
<h3 id="2-绘制双Y曲线"><a href="#2-绘制双Y曲线" class="headerlink" title="2. 绘制双Y曲线"></a>2. 绘制双Y曲线</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 绘制双y曲线</span></span><br><span class="line">x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span>;</span><br><span class="line">y1 = <span class="number">200</span>*<span class="built_in">exp</span>(<span class="number">-0.05</span>*x).*<span class="built_in">sin</span>(x);   <span class="comment">% *是矩阵相乘，.*是矩阵对应项相乘</span></span><br><span class="line">y2 = <span class="number">0.8</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">10</span>*x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">title(<span class="string">&#x27;Mutiple Decay Rates&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time (\musec)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">yyaxis left</span><br><span class="line"><span class="built_in">plot</span>(x,y1)</span><br><span class="line">ylabel(<span class="string">&#x27;Slow Decay&#x27;</span>)</span><br><span class="line"></span><br><span class="line">yyaxis right</span><br><span class="line"><span class="built_in">plot</span>(x,y2)</span><br><span class="line">ylabel(<span class="string">&#x27;Fast Decay&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1650250039875.png" alt="1650250039875"></p>
<h3 id="3-三维绘图"><a href="#3-三维绘图" class="headerlink" title="3. 三维绘图"></a>3. 三维绘图</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">10</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="built_in">plot3</span>(<span class="built_in">sin</span>(t),<span class="built_in">cos</span>(t),t)</span><br><span class="line">xlabel(<span class="string">&#x27;sin(t)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;cos(t)&#x27;</span>)</span><br><span class="line">zlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">grid on     <span class="comment">% 打开网格</span></span><br><span class="line">axis square</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1650250188559.png" alt="1650250188559"></p>
<h3 id="4-双峰函数"><a href="#4-双峰函数" class="headerlink" title="4. 双峰函数"></a>4. 双峰函数</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[x,y,z] = peaks(<span class="number">30</span>);</span><br><span class="line">mesh(x,y,z)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1650250259611.png" alt="1650250259611"></p>
]]></content>
      <categories>
        <category>《Matlab》</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记</title>
    <url>/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-Python简介"><a href="#1-Python简介" class="headerlink" title="1. Python简介"></a>1. Python简介</h2><h3 id="1-1-Python-定义"><a href="#1-1-Python-定义" class="headerlink" title="1.1 Python 定义"></a>1.1 Python 定义</h3><p>是一个免费、开源、跨平台、动态、面向对象的编程语言。</p>
<h3 id="1-2-Python程序的执行方式"><a href="#1-2-Python程序的执行方式" class="headerlink" title="1.2 Python程序的执行方式"></a>1.2 Python程序的执行方式</h3><h4 id="（1）交互式"><a href="#（1）交互式" class="headerlink" title="（1）交互式"></a>（1）交互式</h4><p>在命令行输入指令，回车即可得到结果。</p>
<p>(1) 打开终端</p>
<p>(2) 进入交互式：python3</p>
<p>(3) 编写代码：print(“hello world”) </p>
<p>(4) 离开交互式：exit()</p>
<h4 id="（2）文件式"><a href="#（2）文件式" class="headerlink" title="（2）文件式"></a>（2）文件式</h4><p>将指令编写到.py文件，可以重复运行程序。</p>
<p>(1)  编写文件</p>
<p>(2)  打开终端</p>
<p>(3)   进入程序所在目录：cd 目录</p>
<p>(4)  执行程序： python3 文件名</p>
<h3 id="1-3-执行过程"><a href="#1-3-执行过程" class="headerlink" title="1.3 执行过程"></a>1.3 执行过程</h3><p>计算机只能识别机器码(1010)，不能识别源代码(python)。由源代码转变成机器码的过程分成两类：编译和解释。</p>
<h4 id="（1）编译"><a href="#（1）编译" class="headerlink" title="（1）编译"></a>（1）编译</h4><p>在程序运行之前，通过编译器将源代码变成机器码，例如：C语言。</p>
<ul>
<li>优点：运行速度快</li>
</ul>
<ul>
<li>缺点：开发效率低，不能跨平台。</li>
</ul>
<h4 id="（2）解释"><a href="#（2）解释" class="headerlink" title="（2）解释"></a>（2）解释</h4><p>在程序运行之时，通过解释器对程序逐行翻译，然后执行，例如Javascript。</p>
<ul>
<li>优点：开发效率高，可以跨平台；</li>
</ul>
<ul>
<li>缺点：运行速度慢。</li>
</ul>
<h4 id="（3）Python是解释型语言"><a href="#（3）Python是解释型语言" class="headerlink" title="（3）Python是解释型语言"></a>（3）Python是解释型语言</h4><p>Python是解释型语言，但为了提高运行速度，使用了一种编译的方法。编译之后得到pyc文件，存储了字节码（特定于Python的表现形式，不是机器码）。</p>
<p>源代码 – 编译 –&gt; 字节码 – 解释 –&gt; 机器码</p>
<h3 id="1-4-解释器类型"><a href="#1-4-解释器类型" class="headerlink" title="1.4 解释器类型"></a>1.4 解释器类型</h3><p>(1) CPython（C语言开发)</p>
<p>(2)  Jython (java开发)</p>
<p>(3) IronPython (.net开发)</p>
<h2 id="2-数据基本运算"><a href="#2-数据基本运算" class="headerlink" title="2. 数据基本运算"></a>2. 数据基本运算</h2><h3 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h3><h4 id="（1）-pycharm常用快捷键"><a href="#（1）-pycharm常用快捷键" class="headerlink" title="（1） pycharm常用快捷键"></a>（1） pycharm常用快捷键</h4><ul>
<li><p>移动到本行开头：home键</p>
</li>
<li><p>移动到本行末尾：end键盘</p>
</li>
<li><p> 注释代码：ctrl + /</p>
</li>
</ul>
<ul>
<li> 复制行：<font color="red">ctrl +d</font></li>
</ul>
<ul>
<li>删除行：<font color="red">shift + delete</font></li>
</ul>
<ul>
<li> 选择列：shift + alt +鼠标左键</li>
</ul>
<ul>
<li>移动行：ctrl  + shift + 上下箭头</li>
</ul>
<ul>
<li>代码格式化：<font color="red"> ctrl+alt+l </font></li>
<li>查看函数参数：<font color="red">ctrl+P</font></li>
<li>重构成员：shift+F6</li>
</ul>
<h4 id="（2）注释"><a href="#（2）注释" class="headerlink" title="（2）注释"></a>（2）注释</h4><p>​    给人看的，通常是对代码的描述信息。</p>
<ul>
<li>单行注释：以#号开头。</li>
</ul>
<ul>
<li>多行注释：三引号开头，三引号结尾。</li>
</ul>
<h3 id="2-2-数据"><a href="#2-2-数据" class="headerlink" title="2.2 数据"></a>2.2 数据</h3><ul>
<li><p>整形int</p>
</li>
<li><p>浮点型float </p>
</li>
<li><p>字符串str</p>
</li>
<li><p>布尔bool</p>
</li>
</ul>
<h3 id="2-3-运算"><a href="#2-3-运算" class="headerlink" title="2.3 运算"></a>2.3 运算</h3><h4 id="（1）-类型转换"><a href="#（1）-类型转换" class="headerlink" title="（1） 类型转换"></a>（1） 类型转换</h4><ul>
<li>转换为整形: int(数据)</li>
</ul>
<ul>
<li>转换为浮点型:float(数据)</li>
</ul>
<ul>
<li>转换为字符串:str(数据)</li>
</ul>
<ul>
<li>转换为布尔:bool(数据)</li>
</ul>
<h4 id="（2）运算符"><a href="#（2）运算符" class="headerlink" title="（2）运算符"></a>（2）运算符</h4><h5 id="（1）算术运算符"><a href="#（1）算术运算符" class="headerlink" title="（1）算术运算符"></a>（1）算术运算符</h5><ul>
<li>+   加法</li>
</ul>
<ul>
<li>-   减法</li>
</ul>
<ul>
<li>*   乘法</li>
</ul>
<ul>
<li>/   除法：结果为浮点数</li>
</ul>
<ul>
<li>//  整除：除的结果去掉小数部分</li>
</ul>
<ul>
<li>%  求余</li>
</ul>
<ul>
<li>**  幂运算</li>
</ul>
<h5 id="（2）-增强运算符"><a href="#（2）-增强运算符" class="headerlink" title="（2） 增强运算符"></a>（2） 增强运算符</h5><ul>
<li>y += x     相当于 y = y + x</li>
</ul>
<ul>
<li>y -= x      相当于 y = y - x</li>
</ul>
<ul>
<li>y *= x      相当于 y = y * x</li>
</ul>
<ul>
<li>y /= x      相当于 y = y / x</li>
</ul>
<ul>
<li>y //= x     相当于 y = y // x</li>
</ul>
<ul>
<li>y %= x     相当于 y = y % x</li>
</ul>
<ul>
<li>y **= x     相当于 y = y ** x</li>
</ul>
<h5 id="（3）-比较运算符"><a href="#（3）-比较运算符" class="headerlink" title="（3） 比较运算符"></a>（3） 比较运算符</h5><ul>
<li> &lt;     小于</li>
</ul>
<ul>
<li> &lt;=    小于等于</li>
</ul>
<ul>
<li><p>&gt;     大于</p>
</li>
<li><p> &gt;=    大于等于</p>
</li>
</ul>
<ul>
<li> ==    等于</li>
</ul>
<ul>
<li> !=     不等于</li>
</ul>
<h5 id="（4）-逻辑运算符"><a href="#（4）-逻辑运算符" class="headerlink" title="（4） 逻辑运算符"></a>（4） 逻辑运算符</h5><ul>
<li>与and     </li>
</ul>
<ul>
<li>或or</li>
</ul>
<ul>
<li>非 not </li>
</ul>
<h5 id="（5）身份运算符"><a href="#（5）身份运算符" class="headerlink" title="（5）身份运算符"></a>（5）身份运算符</h5><ul>
<li><p>语法:</p>
<p>x is y</p>
<p>x is not y</p>
</li>
<li><p>作用：</p>
<p>is 用于判断两个对象是否是同一个对象,是时返回True,否则返回False。</p>
</li>
</ul>
<h5 id="（6）优先级"><a href="#（6）优先级" class="headerlink" title="（6）优先级"></a>（6）优先级</h5><p>​    高到低：</p>
<p>​        算数运算符</p>
<p>​        比较运算符</p>
<p>​        增强运算符</p>
<p>​        身份运算符</p>
<p>​        逻辑运算符</p>
<h2 id="3-语句"><a href="#3-语句" class="headerlink" title="3. 语句"></a>3. 语句</h2><h3 id="3-1-条件语句"><a href="#3-1-条件语句" class="headerlink" title="3.1 条件语句"></a>3.1 条件语句</h3><h4 id="（1）if-elif-语句"><a href="#（1）if-elif-语句" class="headerlink" title="（1）if elif 语句"></a>（1）if elif 语句</h4><ul>
<li> 作用:</li>
</ul>
<p>  让程序根据条件选择性的执行语句。</p>
<ul>
<li>语法:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">   语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">   语句块<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   语句块<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）真值表达式"><a href="#（2）真值表达式" class="headerlink" title="（2）真值表达式"></a>（2）真值表达式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">100</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;真值&quot;</span>)</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">bool</span>(<span class="number">100</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;真值&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="（3）条件表达式"><a href="#（3）条件表达式" class="headerlink" title="（3）条件表达式"></a>（3）条件表达式</h4><ul>
<li>  语法：变量 = 结果1 if 条件 else 结果2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">input</span>(<span class="string">&quot;请输入性别:&quot;</span>) == <span class="string">&quot;男&quot;</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li> 作用：根据条件(True/False) 来决定返回结果1还是结果2。</li>
</ul>
<h3 id="3-2-循环语句"><a href="#3-2-循环语句" class="headerlink" title="3.2 循环语句"></a>3.2 循环语句</h3><h4 id="（1）while语句"><a href="#（1）while语句" class="headerlink" title="（1）while语句"></a>（1）while语句</h4><h4 id="（2）for-语句"><a href="#（2）for-语句" class="headerlink" title="（2）for 语句"></a>（2）for 语句</h4><ul>
<li>作用:用来遍历可迭代对象的数据元素。可迭代对象是指能依次获取数据元素的对象，例如：容器类型。</li>
</ul>
<ul>
<li> 语法:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量列表 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">    <span class="comment"># 语句块</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）range-函数"><a href="#（3）range-函数" class="headerlink" title="（3）range 函数"></a>（3）range 函数</h4><ul>
<li>作用:</li>
</ul>
<p>​      用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器)。</p>
<ul>
<li>语法:</li>
</ul>
<p>​       <font color="red">range(开始点，结束点，间隔)</font></p>
<ul>
<li><p>说明:</p>
<p>函数返回的可迭代对象可以用for取出其中的元素</p>
<p>返回的数字不包含结束点</p>
<p>开始点默认为0</p>
<p>间隔默认值为1 </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写法1:range(开始,结束,间隔)</span></span><br><span class="line"><span class="comment"># 注意:不包含结束值</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法2:range(开始,结束)</span></span><br><span class="line"><span class="comment"># 注意:间隔默认为1</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):	</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法3:range(结束)</span></span><br><span class="line"><span class="comment"># 注意:开始默认为0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>



<h3 id="3-3-跳转语句"><a href="#3-3-跳转语句" class="headerlink" title="3.3 跳转语句"></a>3.3 跳转语句</h3><h4 id="（1）break-语句"><a href="#（1）break-语句" class="headerlink" title="（1）break 语句"></a>（1）break 语句</h4><p>​    跳出循环体，后面的代码不再执行。</p>
<h4 id="（2）continue-语句"><a href="#（2）continue-语句" class="headerlink" title="（2）continue 语句"></a>（2）continue 语句</h4><p>​    跳过本次，继续下次循环。</p>
<h2 id="4-Python基础容器"><a href="#4-Python基础容器" class="headerlink" title="4. Python基础容器"></a>4. Python基础容器</h2><a href="/2021/12/24/Python%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8/" title="Python基础容器">Python基础容器</a>



<h2 id="5-函数-function"><a href="#5-函数-function" class="headerlink" title="5. 函数 function"></a>5. 函数 function</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><ul>
<li>用于封装一个特定的功能，表示一个功能或者行为。</li>
<li> 函数是可以重复执行的语句块, 可以重复调用。</li>
<li>提高代码的可重用性和可维护性（代码层次结构更清晰）。</li>
</ul>
<h3 id="5-2-基础语法"><a href="#5-2-基础语法" class="headerlink" title="5.2 基础语法"></a>5.2 基础语法</h3><h4 id="（1）定义函数"><a href="#（1）定义函数" class="headerlink" title="（1）定义函数"></a>（1）定义函数</h4><ul>
<li><p>语法：</p>
<p>def 函数名(形式参数):</p>
<pre><code>   函数体
</code></pre>
</li>
<li><p> 说明：</p>
</li>
</ul>
<p>  def 关键字：全称是define，意为”定义”。</p>
<p>  函数名：对函数体中语句的描述，规则与变量名相同。</p>
<p>  形式参数：函数定义者要求调用者提供的信息。</p>
<p>  函数体：完成该功能的语句。</p>
<ul>
<li>函数的第一行语句建议使用文档字符串描述函数的功能与参数。</li>
</ul>
<h4 id="（2）调用函数"><a href="#（2）调用函数" class="headerlink" title="（2）调用函数"></a>（2）调用函数</h4><ul>
<li>语法：函数名(实际参数) </li>
</ul>
<ul>
<li>说明：根据形参传递内容。</li>
</ul>
<h4 id="（3）返回值"><a href="#（3）返回值" class="headerlink" title="（3）返回值"></a>（3）返回值</h4><ul>
<li><p>定义：</p>
<p>函数定义者告诉调用者的结果。</p>
</li>
<li><p>语法：</p>
<p>return 数据 </p>
</li>
<li><p>说明：</p>
<p>return后没有语句，相当于返回 None。</p>
<p>函数体没有return，相当于返回None。</p>
</li>
</ul>
<h3 id="5-3-可变／不可变类型"><a href="#5-3-可变／不可变类型" class="headerlink" title="5.3 可变／不可变类型"></a>5.3 可变／不可变类型</h3><h4 id="1-不可变类型参数"><a href="#1-不可变类型参数" class="headerlink" title="(1) 不可变类型参数:"></a>(1) 不可变类型参数:</h4><ul>
<li>数值型(整数，浮点数)</li>
</ul>
<ul>
<li>布尔值bool</li>
</ul>
<ul>
<li>None 空值</li>
</ul>
<ul>
<li>字符串str</li>
</ul>
<ul>
<li>元组tuple</li>
</ul>
<h4 id="2-可变类型参数"><a href="#2-可变类型参数" class="headerlink" title="(2) 可变类型参数:"></a>(2) 可变类型参数:</h4><ul>
<li>列表 list</li>
</ul>
<ul>
<li>字典 dict</li>
</ul>
<ul>
<li>集合 set</li>
</ul>
<h4 id="3-传参说明："><a href="#3-传参说明：" class="headerlink" title="(3) 传参说明："></a>(3) 传参说明：</h4><ul>
<li>不可变类型的数据传参时，函数内部不会改变原数据的值。</li>
</ul>
<ul>
<li>可变类型的数据传参时，函数内部可以改变原数据。 </li>
</ul>
<h3 id="5-4-函数参数"><a href="#5-4-函数参数" class="headerlink" title="5.4 函数参数"></a>5.4 函数参数</h3><h4 id="（1）实参传递方式"><a href="#（1）实参传递方式" class="headerlink" title="（1）实参传递方式"></a>（1）实参传递方式</h4><h5 id="①位置传参"><a href="#①位置传参" class="headerlink" title="①位置传参"></a>①<strong>位置传参</strong></h5><p>​    定义：实参与形参的位置依次对应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun01</span>(<span class="params">p1, p2, p3</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1)</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br><span class="line">    <span class="built_in">print</span>(p3)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 位置实参:根据顺序与形参进行对应</span></span><br><span class="line">fun01(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h5 id="②序列传参"><a href="#②序列传参" class="headerlink" title="②序列传参"></a>②<font color="red"><strong>序列传参</strong></font></h5><p>​    定义：<font color="red">实参用*将序列拆解后与形参的位置依次对应。</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">p1, p2, p3</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1, p2, p3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列实参:拆,按照顺序与形参对应</span></span><br><span class="line">list01 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">name = <span class="string">&quot;孙悟空&quot;</span></span><br><span class="line">tuple01 = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># func01(list01)</span></span><br><span class="line">func01(*list01)  <span class="comment"># 拆  1, 2, 3</span></span><br><span class="line">func01(*name)  <span class="comment"># 拆  孙 悟 空</span></span><br><span class="line">func01(*tuple01)  <span class="comment"># 拆  4, 5, 6</span></span><br></pre></td></tr></table></figure>

<h5 id="③关键字传参"><a href="#③关键字传参" class="headerlink" title="③关键字传参"></a>③<font color="red"><strong>关键字传参</strong></font></h5><p>​    定义：实参根据形参的名字进行对应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun01</span>(<span class="params">p1, p2, p3</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1)</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br><span class="line">    <span class="built_in">print</span>(p3)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 关键字实参:根据名字与形参进行对应</span></span><br><span class="line">fun01(p1=<span class="number">1</span>, p2=<span class="number">2</span>, p3=<span class="number">3</span>)</span><br><span class="line">fun01(p2=<span class="number">2</span>, p1=<span class="number">1</span>, p3=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h5 id="④字典关键字传参"><a href="#④字典关键字传参" class="headerlink" title="④字典关键字传参"></a>④<font color="red"><strong>字典关键字传参</strong></font></h5><p>​    定义：实参用**将字典拆解后与形参的名字进行对应。</p>
<p>​    作用：配合形参的缺省参数，可以使调用者随意传参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">p1, p2, p3</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1, p2, p3)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 字典实参:拆,按照名称与形参对应</span></span><br><span class="line">dict01 = &#123;<span class="string">&quot;p2&quot;</span>:<span class="string">&quot;B&quot;</span>,<span class="string">&quot;p1&quot;</span>:<span class="string">&quot;A&quot;</span>,<span class="string">&quot;p3&quot;</span>:<span class="string">&quot;C&quot;</span>&#125;</span><br><span class="line">func01(**dict01)</span><br></pre></td></tr></table></figure>



<h4 id="（2）形参定义方式"><a href="#（2）形参定义方式" class="headerlink" title="（2）形参定义方式"></a>（2）形参定义方式</h4><h5 id="①缺省形参"><a href="#①缺省形参" class="headerlink" title="①缺省形参"></a>①<strong>缺省形参</strong></h5><ul>
<li><p>语法：</p>
<p>def 函数名(形参名1=默认实参1, 形参名2=默认实参2, …):</p>
<p>​       函数体</p>
</li>
<li><p>说明：</p>
<p>缺省参数必须<font color="red">自右至左依次存在</font>，如果一个参数有缺省参数，则其右侧的所有参数都必须有缺省参数。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">p1=<span class="number">0</span>, p2=<span class="string">&quot;&quot;</span>, p3=<span class="number">100</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1)</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br><span class="line">    <span class="built_in">print</span>(p3) </span><br><span class="line">    </span><br><span class="line">func01(p2=<span class="number">2</span>)</span><br><span class="line">func01(p2=<span class="number">2</span>,p3=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 支持同时使用位置实参与关键字实参</span></span><br><span class="line">func01(<span class="number">1</span>,p3=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 注意1:先位置实参,后关键字实参</span></span><br><span class="line"><span class="comment"># func01(p1=1,2,3) # 错误</span></span><br></pre></td></tr></table></figure>

<h5 id="②位置形参"><a href="#②位置形参" class="headerlink" title="②位置形参"></a>②<strong>位置形参</strong></h5><ul>
<li><p>语法：</p>
<p>​    def 函数名(形参名1, 形参名2, …):</p>
<p>​           函数体</p>
</li>
</ul>
<h5 id="③命名关键字形参"><a href="#③命名关键字形参" class="headerlink" title="③命名关键字形参"></a>③<font color="red"><strong>命名关键字形参</strong></font></h5><ul>
<li><p>语法：</p>
<p>def 函数名(*args, 命名关键字形参1, 命名关键字形参2, …):</p>
<pre><code>   函数体
</code></pre>
<p>def 函数名(*, 命名关键字形参1, 命名关键字形参2, …):</p>
<p>​      函数体</p>
</li>
<li><p>作用：</p>
<p><font color="orange">强制实参使用关键字传参</font> </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命名关键字形参:</span></span><br><span class="line"><span class="comment"># 星号元组形参后面的位置形参</span></span><br><span class="line"><span class="comment"># 限制实参必须是关键字实参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">*args, p1, p2</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(p1)</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func01(p1=<span class="number">1</span>, p2=<span class="number">2</span>)</span><br><span class="line">func01(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, p1=<span class="number">1</span>, p2=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func02</span>(<span class="params">p1, *, p2=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1)</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通常星号后面的命名关键字形参属于辅助参数,可选.</span></span><br><span class="line">func02(<span class="number">1</span>)</span><br><span class="line">func02(<span class="number">1</span>, p2=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h5 id="④星号元组形参"><a href="#④星号元组形参" class="headerlink" title="④星号元组形参"></a>④<font color="red">星号元组形参</font></h5><ul>
<li><p>语法：</p>
<p>def 函数名(*元组形参名):</p>
<p>​     函数体</p>
</li>
<li><p>作用：</p>
<p><font color="orange">可以将多个位置实参合并为一个元组</font></p>
</li>
<li><p>说明：</p>
<p>一般命名为’<font color="orange">args</font>，形参列表中最多只能有一个</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 位置实参数量可以无限</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">func01()  <span class="comment"># 空元组</span></span><br><span class="line">func01(<span class="number">1</span>, <span class="number">2</span>, <span class="number">34</span>)  <span class="comment"># (1, 2, 34)</span></span><br><span class="line"><span class="comment"># 不支持关键字实参</span></span><br><span class="line"><span class="comment"># func01(args=1,a=1)</span></span><br></pre></td></tr></table></figure>

<h5 id="⑤双星号字典形参"><a href="#⑤双星号字典形参" class="headerlink" title="⑤双星号字典形参"></a>⑤<font color="red"><strong>双星号字典形参</strong></font></h5><ul>
<li><p>语法：</p>
<p>def 函数名(**字典形参名):</p>
<p>​       函数体</p>
</li>
<li><p>作用：</p>
<p><font color="orange">可以将多个关键字实参合并为一个字典</font></p>
</li>
<li><p>说明:</p>
<p>一般命名为<font color="orange">‘kwargs</font></p>
<p>形参列表中最多只能有一个</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关键字实参数量无限</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(kwargs) <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line">func01(a=<span class="number">1</span>,b=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># func01(1,2,3) # 报错</span></span><br></pre></td></tr></table></figure>

<h5 id="⑥参数自左至右的顺序"><a href="#⑥参数自左至右的顺序" class="headerlink" title="⑥参数自左至右的顺序"></a>⑥参数自左至右的顺序</h5><p>位置形参 –&gt; 星号元组形参 –&gt; 命名关键字形参 –&gt; 双星号字典形参</p>
<p>练习：说出程序执行结果.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">list_target</span>):</span></span><br><span class="line">  <span class="built_in">print</span>(list_target)<span class="comment"># ?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func02</span>(<span class="params">*args</span>):</span></span><br><span class="line">  <span class="built_in">print</span>(args)<span class="comment"># ?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func03</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">  <span class="built_in">print</span>(args)<span class="comment"># ?</span></span><br><span class="line">  <span class="built_in">print</span>(kwargs)<span class="comment"># ?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func04</span>(<span class="params">p1,p2,*,p4,**kwargs</span>):</span></span><br><span class="line">  <span class="built_in">print</span>(p1)<span class="comment"># ?</span></span><br><span class="line">  <span class="built_in">print</span>(p2)<span class="comment"># ?</span></span><br><span class="line">  <span class="built_in">print</span>(p4)<span class="comment"># ?</span></span><br><span class="line">  <span class="built_in">print</span>(kwargs)<span class="comment"># ?</span></span><br><span class="line"></span><br><span class="line">func01([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">func02(*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">func03(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,a=<span class="number">4</span>,b=<span class="number">5</span>,c=<span class="number">6</span>) </span><br><span class="line">func04(<span class="number">10</span>,<span class="number">20</span>,p4=<span class="number">30</span>,p5=<span class="number">40</span>)</span><br></pre></td></tr></table></figure>



<h2 id="6-作用域"><a href="#6-作用域" class="headerlink" title="6. 作用域"></a>6. 作用域</h2><h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><p>变量起作用的范围。</p>
<h3 id="6-2-分类"><a href="#6-2-分类" class="headerlink" title="6.2 分类"></a>6.2 分类</h3><p>(1)  Local 局部作用域：函数内部。</p>
<p>(2)  Enclosing  外部嵌套作用域 ：函数嵌套。</p>
<p>(3)  Global 全局作用域：模块(.py文件)内部。 </p>
<p>(4)  Builtin 内置模块作用域：builtins.py文件。</p>
<h3 id="6-3-变量名的查找规则"><a href="#6-3-变量名的查找规则" class="headerlink" title="6.3 变量名的查找规则"></a>6.3 变量名的查找规则</h3><p>(1) 由内到外：L -&gt; E -&gt; G -&gt; B</p>
<p>(2) 在访问变量时，先查找本地变量，然后是包裹此函数外部的函数内部的变量，之后是全局变量，最后是内置变量。</p>
<h3 id="6-4-局部变量"><a href="#6-4-局部变量" class="headerlink" title="6.4 局部变量"></a>6.4 局部变量</h3><p>(1) 定义在函数内部的变量(形参也是局部变量)</p>
<p>(2) 只能在函数内部使用</p>
<p>(3) 调用函数时才被创建，函数结束后自动销毁</p>
<h3 id="6-5-全局变量"><a href="#6-5-全局变量" class="headerlink" title="6.5 全局变量"></a>6.5 全局变量</h3><p>(1) 定义在函数外部,模块内部的变量。</p>
<p>(2) 在整个模块(py文件)范围内访问（但函数内不能将其直接赋值）。</p>
<h3 id="6-6-global-语句"><a href="#6-6-global-语句" class="headerlink" title="6.6 global 语句"></a>6.6 global 语句</h3><p>(1) 作用：</p>
<p>​    在函数内部修改或定义全局变量(全局声明)。</p>
<p>(2) 语法：</p>
<p>​    global 变量1, 变量2, …</p>
<p>(3) 说明</p>
<p>​    在函数内直接为全局变量赋值，视为创建新的局部变量。</p>
<p>​    不能先声明局部的变量，再用global声明为全局变量。</p>
<h3 id="6-7-nonlocal-语句"><a href="#6-7-nonlocal-语句" class="headerlink" title="6.7 nonlocal 语句"></a>6.7 nonlocal 语句</h3><p>(1) 作用：</p>
<p>​    在内层函数修改外层嵌套函数内的变量</p>
<p>(2) 语法</p>
<p>​    nonlocal 变量名1,变量名2, …</p>
<p>(3) 说明</p>
<p>​    在被嵌套的内函数中进行使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 全局作用域:文件内部</span></span><br><span class="line"><span class="comment">#   全局变量:在全部作用域内创建的变量</span></span><br><span class="line"><span class="comment">#   适用范围:整个文件</span></span><br><span class="line">data02 = <span class="number">20</span></span><br><span class="line">data03 = [<span class="number">30</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>():</span></span><br><span class="line">    <span class="comment"># 1. 局部作用域:函数内部</span></span><br><span class="line">    <span class="comment"># 局部变量:在局部作用域内创建的变量</span></span><br><span class="line">    <span class="comment"># 适用范围:一个函数</span></span><br><span class="line">    data01 = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(data01)</span><br><span class="line">    <span class="built_in">print</span>(data02)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func02</span>():</span></span><br><span class="line">    <span class="comment"># print(data01) # 不能访问其他函数局部变量</span></span><br><span class="line">    <span class="built_in">print</span>(data02) <span class="comment"># 读取全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func03</span>():</span></span><br><span class="line">    <span class="comment"># 在局部作用域中不能修改全局变量</span></span><br><span class="line">    <span class="comment"># data02 = 200</span></span><br><span class="line">    <span class="comment"># 必须通过global语句声明</span></span><br><span class="line">    <span class="keyword">global</span> data02</span><br><span class="line">    data02 = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func04</span>():</span></span><br><span class="line">    <span class="comment"># 没有修改全局变量</span></span><br><span class="line">    <span class="comment"># 在修改全局变量指向的列表</span></span><br><span class="line">    <span class="comment"># 所以不需要通过global语句声明</span></span><br><span class="line">    data03[<span class="number">0</span>] = <span class="number">300</span></span><br><span class="line"></span><br><span class="line">func01()</span><br><span class="line">func02()</span><br><span class="line">func03()</span><br><span class="line">func04()</span><br><span class="line"><span class="built_in">print</span>(data02) <span class="comment"># 200</span></span><br><span class="line"><span class="built_in">print</span>(data03) <span class="comment"># [300]</span></span><br></pre></td></tr></table></figure>

<p>练习：画出下列代码内存图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data01 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">global</span> data01</span><br><span class="line">    data01 += <span class="number">1</span></span><br><span class="line">    p += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">data02 = <span class="number">10</span></span><br><span class="line">func01(data02)</span><br><span class="line">func01(data02)</span><br><span class="line"><span class="built_in">print</span>(data01)  <span class="comment"># ?</span></span><br><span class="line"><span class="built_in">print</span>(data02)  <span class="comment"># ?</span></span><br></pre></td></tr></table></figure>



<h2 id="7-面向对象简介"><a href="#7-面向对象简介" class="headerlink" title="7. 面向对象简介"></a>7. 面向对象简介</h2><h3 id="7-1-面向过程"><a href="#7-1-面向过程" class="headerlink" title="7.1 面向过程"></a>7.1 面向过程</h3><p>(1) <strong>定义</strong>：分析出解决问题的步骤，然后逐步实现。</p>
<p>​    例如：婚礼筹办</p>
<p>​    – 请柬（选照片、措词、制作）</p>
<p>​    – 宴席（场地、找厨师、准备桌椅餐具、计划菜品、购买食材）</p>
<p>​    – 仪式（定婚礼仪式流程、请主持人）</p>
<p>(2) <strong>公式</strong>：<font color="red">程序 = 算法 + 数据结构</font></p>
<p>(3) <strong>优点</strong>：所有环节、细节自己掌控。</p>
<p>(4) <strong>缺点</strong>：考虑所有细节，工作量大。 </p>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210311120846382.png" alt="image-20210311120846382"></p>
<h3 id="7-2-面向对象"><a href="#7-2-面向对象" class="headerlink" title="7.2 面向对象"></a>7.2 面向对象</h3><p>(1) <strong>定义</strong>：找出解决问题的人，然后分配职责。</p>
<p>​    例如：婚礼筹办</p>
<p>​    – 发请柬：找摄影公司（拍照片、制作请柬）</p>
<p>​    – 宴席：找酒店（告诉对方标准、数量、挑选菜品） </p>
<p>​    – 婚礼仪式：找婚庆公司（对方提供司仪、制定流程、提供设备、帮助执行）</p>
<p>(2) <strong>公式</strong>：<font color="red">程序 = 对象 + 交互</font></p>
<p>(3) <strong>优点</strong></p>
<p>​    a. 思想层面：</p>
<p>​        – 可模拟现实情景，更接近于人类思维。</p>
<p>​        – 有利于梳理归纳、分析解决问题。</p>
<p>​    b. 技术层面：</p>
<p>​        – <font color="orange">高复用</font>：对重复的代码进行封装，提高开发效率。</p>
<p>​        – <font color="orange">高扩展</font>：增加新的功能，不修改以前的代码。</p>
<p>​        – <font color="orange">高维护</font>：代码可读性好，逻辑清晰，结构规整。</p>
<p>(4) <strong>缺点</strong>：学习曲线陡峭。</p>
<h2 id="8-类和对象"><a href="#8-类和对象" class="headerlink" title="8. 类和对象"></a>8. 类和对象</h2><h3 id="8-1-语法"><a href="#8-1-语法" class="headerlink" title="8.1 语法"></a>8.1 语法</h3><h4 id="（1）定义类"><a href="#（1）定义类" class="headerlink" title="（1）定义类"></a>（1）定义类</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">		文档说明</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,参数</span>):</span></span><br><span class="line">		self.实例变量 = 参数</span><br><span class="line"></span><br><span class="line">	 方法成员</span><br></pre></td></tr></table></figure>

<ul>
<li>说明<ul>
<li> 类名所有单词首字母大写.</li>
<li>init 也叫构造函数，创建对象时被调用，也可以省略。</li>
<li>self 变量 绑定的是被创建的对象，名称可以随意。</li>
</ul>
</li>
</ul>
<h4 id="（2）实例化对象"><a href="#（2）实例化对象" class="headerlink" title="（2）实例化对象"></a>（2）实例化对象</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量 = 类名(参数)</span><br></pre></td></tr></table></figure>

<ul>
<li> 说明</li>
<li>变量存储的是实例化后的对象地址</li>
<li>类名后面的参数按照构造函数的形参传递</li>
</ul>
<h3 id="2-2-实例成员"><a href="#2-2-实例成员" class="headerlink" title="2.2 实例成员"></a>2.2 实例成员</h3><h4 id="（1）-实例变量"><a href="#（1）-实例变量" class="headerlink" title="（1） 实例变量"></a>（1） 实例变量</h4><ul>
<li><p>定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象.变量名</span><br></pre></td></tr></table></figure></li>
<li><p>调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象.变量名 </span><br></pre></td></tr></table></figure></li>
<li><p> 说明</p>
</li>
<li><p>首次通过对象赋值为创建，再次赋值为修改.</p>
</li>
<li><p>通常在构造函数(__init_)中创建</p>
</li>
<li><p>每个对象存储一份，通过对象地址访问</p>
</li>
</ul>
<ul>
<li>作用：描述某个对象的数据。</li>
</ul>
<ul>
<li><font color="red">_<em>dict</em>_</font>：对象的属性，用于存储自身实例变量的字典。</li>
</ul>
<h4 id="（2）实例方法"><a href="#（2）实例方法" class="headerlink" title="（2）实例方法"></a>（2）实例方法</h4><ul>
<li>定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 方法名称(<span class="params">self, 参数</span>):</span></span><br><span class="line">        方法体</span><br></pre></td></tr></table></figure>

<ul>
<li>调用： </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象.方法名称(参数)</span><br><span class="line">   <span class="comment"># 不建议通过类名访问实例方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>说明</p>
<ul>
<li>至少有一个形参，第一个参数绑定调用这个方法的对象,一般命名为self。</li>
<li>无论创建多少对象，方法只有一份，并且被所有对象共享。</li>
</ul>
</li>
<li><p>作用：表示对象行为。</p>
</li>
</ul>
<h3 id="2-3-类成员"><a href="#2-3-类成员" class="headerlink" title="2.3 类成员"></a>2.3 类成员</h3><h4 id="（1）类变量"><a href="#（1）类变量" class="headerlink" title="（1）类变量"></a>（1）类变量</h4><ul>
<li> 定义：在类中，方法外。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">     变量名 = 数据</span><br></pre></td></tr></table></figure>

<ul>
<li>调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">类名.变量名</span><br><span class="line"><span class="comment"># 不建议通过对象访问类变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>特点：</p>
<ul>
<li><p>随类的加载而加载</p>
</li>
<li><p>存在优先于对象</p>
</li>
<li><p>只有一份，被所有对象共享。</p>
</li>
</ul>
</li>
<li><p>作用：描述所有对象的共有数据。</p>
</li>
</ul>
<h4 id="（2）-类方法"><a href="#（2）-类方法" class="headerlink" title="（2） 类方法"></a>（2） <font color="red">类方法</font></h4><ul>
<li>定义：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 方法名称(<span class="params">cls,参数</span>):</span></span><br><span class="line">    方法体</span><br></pre></td></tr></table></figure>

<ul>
<li>调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">类名.方法名(参数) </span><br><span class="line"><span class="comment"># 不建议通过对象访问类方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>说明</p>
<ul>
<li>至少有一个形参，第一个形参用于绑定类，一般命名为’cls’</li>
<li>使用@classmethod修饰的目的是调用类方法时可以隐式传递类。</li>
</ul>
</li>
<li><p>类方法中不能访问实例成员，实例方法中可以访问类成员。</p>
</li>
</ul>
<ul>
<li>作用：操作类变量。</li>
</ul>
<h3 id="2-4-静态方法"><a href="#2-4-静态方法" class="headerlink" title="2.4 静态方法"></a>2.4 静态方法</h3><ul>
<li>定义：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 方法名称(<span class="params">参数</span>):</span></span><br><span class="line">    方法体</span><br></pre></td></tr></table></figure>

<ul>
<li>调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">类名.方法名称(参数) </span><br><span class="line"><span class="comment"># 不建议通过对象访问静态方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>说明<ul>
<li>使用@ staticmethod修饰的目的是该方法不需要隐式传参数。</li>
<li>静态方法不能访问实例成员和类成员</li>
</ul>
</li>
<li>作用：定义常用的工具函数。</li>
</ul>
<h2 id="9-面向对象三大特征"><a href="#9-面向对象三大特征" class="headerlink" title="9. 面向对象三大特征"></a>9. 面向对象三大特征</h2><h3 id="9-1-封装"><a href="#9-1-封装" class="headerlink" title="9.1 封装"></a>9.1 封装</h3><h4 id="（1）数据角度"><a href="#（1）数据角度" class="headerlink" title="（1）数据角度"></a>（1）数据角度</h4><ul>
<li> 定义：将一些基本数据类型复合成一个自定义类型。</li>
</ul>
<ul>
<li><p>优势：</p>
<ul>
<li><p>将数据（变量）与对数据的操作（方法）相关联。</p>
</li>
<li><p>代码可读性更高（类是对象的模板）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="（2）行为角度"><a href="#（2）行为角度" class="headerlink" title="（2）行为角度"></a>（2）行为角度</h4><ul>
<li><p>定义：</p>
<p>向类外提供必要的功能，隐藏实现的细节。</p>
</li>
<li><p>优势：</p>
<p>简化编程，使用者不必了解具体的实现细节，只需要调用对外提供的功能。</p>
</li>
</ul>
<h4 id="（3）设计角度"><a href="#（3）设计角度" class="headerlink" title="（3）设计角度"></a>（3）<font color="red">设计角度</font></h4><ul>
<li>分而治之<ul>
<li>将一个大的需求分解为许多类，每个类处理一个独立的功能</li>
<li>拆分好处：便于分工，便于复用，可扩展性强</li>
</ul>
</li>
<li>变则疏之<ul>
<li>变化的地方独立封装，避免影响其他类</li>
</ul>
</li>
<li>高内聚<ul>
<li>类中各个方法都在完成一项任务（单一职责的类）</li>
</ul>
</li>
<li>低耦合<ul>
<li>类与类的关联性与依赖度较低（每个类独立），让一个类改变尽量不影响其他类。</li>
</ul>
</li>
</ul>
<h4 id="（4）私有成员："><a href="#（4）私有成员：" class="headerlink" title="（4）私有成员："></a>（4）<font color="red">私有成员</font>：</h4><ul>
<li>作用：无需向类外提供的成员，可以通过私有化进行屏蔽。</li>
</ul>
<ul>
<li>做法：命名使用<font color="orange">双下划线开头</font>。</li>
</ul>
<ul>
<li>本质：障眼法，实际也可以访问。</li>
</ul>
<p>​              私有成员的名称被修改为：<strong>_类名__成员名</strong>，可以通过___dict__属性查看。</p>
<p>– 演示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.__data = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func01</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func01执行了&quot;</span>)</span><br><span class="line"></span><br><span class="line">m01 = MyClass(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># print(m01.__data) # 无法访问</span></span><br><span class="line"><span class="built_in">print</span>(m01._MyClass__data)</span><br><span class="line"><span class="built_in">print</span>(m01.__dict__)  <span class="comment"># &#123;&#x27;_MyClass__data&#x27;: 10&#125;</span></span><br><span class="line"><span class="comment"># m01.__func01() # 无法访问</span></span><br><span class="line">m01._MyClass__func01()</span><br></pre></td></tr></table></figure>

<h4 id="（5）属性-property"><a href="#（5）属性-property" class="headerlink" title="（5）属性@property"></a>（5）<font color="red">属性@property</font></h4><ul>
<li>作用：保护实例变量（读取、只读、只写）</li>
</ul>
<ul>
<li>定义：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 属性名(<span class="params">self</span>):</span></span><br><span class="line">  <span class="keyword">return</span> self.__属性名</span><br><span class="line"></span><br><span class="line"><span class="meta">@属性名.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 属性名(<span class="params">self, value</span>):</span></span><br><span class="line">  self.__属性名= value</span><br></pre></td></tr></table></figure>

<ul>
<li>调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象.属性名 = 数据</span><br><span class="line">变量 = 对象.属性名</span><br></pre></td></tr></table></figure>

<ul>
<li>三种形式：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 读写属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__data</span><br><span class="line"></span><br><span class="line"><span class="meta">    @data.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__data = value</span><br><span class="line"></span><br><span class="line">m01 = MyClass(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(m01.data)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 只读属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__data = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m01 = MyClass()</span><br><span class="line"><span class="comment"># m01.data = 20# AttributeError: can&#x27;t set attribute</span></span><br><span class="line"><span class="built_in">print</span>(m01.data)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3. 只写属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data = property()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># @data.setter</span></span><br><span class="line">    <span class="comment"># def data(self, value):</span></span><br><span class="line">    <span class="comment">#     self.__data = value</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__data = value</span><br><span class="line"></span><br><span class="line">    data = <span class="built_in">property</span>(fset=data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m01 = MyClass(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(m01.data)  <span class="comment"># AttributeError: unreadable attribute</span></span><br><span class="line">m01.data = <span class="number">20</span></span><br></pre></td></tr></table></figure>



<h3 id="9-2-继承"><a href="#9-2-继承" class="headerlink" title="9.2 继承"></a>9.2 继承</h3><h4 id="（1）继承方法"><a href="#（1）继承方法" class="headerlink" title="（1）继承方法"></a>（1）继承方法</h4><ul>
<li>语法:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> 父类方法(<span class="params">self</span>):</span></span><br><span class="line">     方法体</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类(<span class="params">父类</span>)：</span></span><br><span class="line"><span class="class">   <span class="title">def</span> 子类方法(<span class="params">self</span>):</span></span><br><span class="line">     方法体</span><br><span class="line"></span><br><span class="line">儿子 = 子类()</span><br><span class="line">儿子.子类方法()</span><br><span class="line">儿子.父类方法()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>说明：</p>
<p>子类直接拥有父类的方法.</p>
</li>
<li><p>演示：</p>
</li>
</ul>
<h4 id="（2）内置函数"><a href="#（2）内置函数" class="headerlink" title="（2）内置函数"></a>（2）内置函数</h4><ul>
<li><p><font color="orange">isinstance(对象, 类型) </font></p>
<p>​    返回指定对象是否是某个类的对象。</p>
</li>
<li><p><font color="orange">issubclass(类型，类型)</font></p>
<p>​    返回指定类型是否属于某个类型。</p>
</li>
</ul>
<h4 id="（3）继承数据"><a href="#（3）继承数据" class="headerlink" title="（3）继承数据"></a>（3）继承数据</h4><ul>
<li>语法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类(<span class="params">父类</span>):</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,父类参数,子类参数</span>):</span></span><br><span class="line">   <span class="built_in">super</span>().__init__(参数) <span class="comment"># 调用父类构造函数</span></span><br><span class="line">   self.实例变量 = 参数</span><br></pre></td></tr></table></figure>

<ul>
<li> 说明</li>
</ul>
<p>  子类如果没有构造函数，将自动执行父类的，但如果有构造函数将覆盖父类的。此时必须通过super()函数调用父类的构造函数，以确保父类实例变量被正常创建。</p>
<ul>
<li>演示</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="string">&quot;&quot;</span>, age=<span class="number">0</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 子类有构造函数,不会使用继承而来的父类构造函数[子覆盖了父方法,好像它不存在]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="comment"># 子类构造函数：父类构造函数参数,子类构造函数参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, score</span>):</span></span><br><span class="line">        <span class="comment"># 调用父类构造函数</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line"></span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">ts = Person(<span class="string">&quot;唐僧&quot;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="built_in">print</span>(ts.name)</span><br><span class="line">kw = Student(<span class="string">&quot;悟空&quot;</span>, <span class="number">23</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(wk.name)</span><br><span class="line"><span class="built_in">print</span>(wk.score)</span><br></pre></td></tr></table></figure>

<p>(4) 练习：</p>
<p>创建父类：车(品牌，速度)</p>
<p>创建子类：电动车(电池容量,充电功率)</p>
<p>创建子类对象并画出内存图。</p>
<h4 id="（4）-定义"><a href="#（4）-定义" class="headerlink" title="（4） 定义"></a>（4） 定义</h4><ul>
<li> 概念： 重用现有类的功能，并在此基础上进行扩展。</li>
</ul>
<ul>
<li> 说明：子类直接具有父类的成员（共性），还可以扩展新功能。</li>
</ul>
<ul>
<li><p>相关知识</p>
<ul>
<li><p>父类（基类、超类）、子类（派生类）。</p>
</li>
<li><p>父类相对于子类更抽象，范围更宽泛；子类相对于父类更具体，范围更狭小。</p>
</li>
<li><p>单继承：父类只有一个（例如 Java，C#）。</p>
</li>
<li><p> 多继承：父类有多个（例如C++，Python）。</p>
</li>
<li><p>Object类：任何类都直接或间接继承自 Object 类。</p>
</li>
</ul>
</li>
</ul>
<h4 id="（5）多继承"><a href="#（5）多继承" class="headerlink" title="（5）多继承"></a>（5）多继承</h4><ul>
<li>定义：一个子类继承两个或两个以上的基类，父类中的属性和方法同时被子类继承下来。</li>
</ul>
<ul>
<li><p>同名方法解析顺序（MRO， Method Resolution Order）:</p>
<p>类自身 –&gt; 父类继承列表（由左至右）–&gt; 再上层父类</p>
</li>
</ul>
<p>​          A</p>
<p>​       /       \</p>
<p>   /               \</p>
<p>  B                C</p>
<p>   \                 /</p>
<p>​       \          /</p>
<p>​           D </p>
<p>(3) 练习：写出下列代码在终端中执行效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">	    <span class="built_in">super</span>().func01()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A,B</span>):</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">self</span>):</span></span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">	    <span class="built_in">super</span>().func01()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">    	<span class="built_in">super</span>().func01()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>(<span class="params">C,D</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">	    <span class="built_in">super</span>().func01()</span><br><span class="line"></span><br><span class="line">e = E()</span><br><span class="line">e.func01()</span><br></pre></td></tr></table></figure>



<h3 id="9-3-多态"><a href="#9-3-多态" class="headerlink" title="9.3 多态"></a>9.3 多态</h3><h4 id="（1）重写内置函数"><a href="#（1）重写内置函数" class="headerlink" title="（1）重写内置函数"></a>（1）重写内置函数</h4><ul>
<li>定义：Python中，以双下划线开头、双下划线结尾的是系统定义的成员。我们可以在自定义类中进行重写，从而改变其行为。</li>
</ul>
<ul>
<li> __str__ 函数：将对象转换为字符串(对人友好的)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="string">&quot;&quot;</span>, age=<span class="number">0</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>的年龄是<span class="subst">&#123;self.age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">wk = Person(<span class="string">&quot;悟空&quot;</span>, <span class="number">26</span>)</span><br><span class="line"><span class="comment"># &lt;__main__.Person object at 0x7fbabfbc3e48&gt;</span></span><br><span class="line"><span class="comment"># 悟空的年龄是26</span></span><br><span class="line"><span class="built_in">print</span>(wk) </span><br><span class="line"><span class="comment"># message = wk.__str__()</span></span><br><span class="line"><span class="comment"># print(message)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>算数运算符重载</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210305133828932.png" alt="image-20210305133828932"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        二维向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x是:%d,y是:%d&quot;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector2(self.x + other.x, self.y + other.y)</span><br><span class="line"></span><br><span class="line">v01 = Vector2(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">v02 = Vector2(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(v01 + v02)  <span class="comment"># v01.__add__(v02)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>复合运算符重载</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210305133752412.png" alt="image-20210305133752412"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        二维向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x是:%d,y是:%d&quot;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># + 创建新</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector2(self.x + other.x, self.y + other.y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># += 在原有基础上修改(自定义类属于可变对象)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iadd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        self.x += other.x</span><br><span class="line">        self.y += other.y</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">v01 = Vector2(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">v02 = Vector2(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(v01))</span><br><span class="line">v01 += v02</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(v01))</span><br><span class="line"><span class="built_in">print</span>(v01)</span><br></pre></td></tr></table></figure>

<ul>
<li>比较运算重载</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210305133720536.png" alt="image-20210305133720536"></p>
<p>– 演示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        二维向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 决定相同的依据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x == other.x <span class="keyword">and</span> self.y == other.y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 决定大小的依据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x &lt; other.x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v01 = Vector2(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">v02 = Vector2(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(v01 == v02)  <span class="comment"># True 比较两个对象内容(__eq__决定)</span></span><br><span class="line"><span class="built_in">print</span>(v01 <span class="keyword">is</span> v02)  <span class="comment"># False 比较两个对象地址</span></span><br><span class="line"></span><br><span class="line">list01 = [</span><br><span class="line">    Vector2(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">    Vector2(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">    Vector2(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    Vector2(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    Vector2(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    Vector2(<span class="number">4</span>, <span class="number">4</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须重写 eq</span></span><br><span class="line"><span class="built_in">print</span>(Vector2(<span class="number">5</span>, <span class="number">5</span>) <span class="keyword">in</span> list01)</span><br><span class="line"><span class="built_in">print</span>(list01.count(Vector2(<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须重写 lt</span></span><br><span class="line">list01.sort()</span><br><span class="line"><span class="built_in">print</span>(list01)</span><br></pre></td></tr></table></figure>

<h4 id="（2）重写自定义函数"><a href="#（2）重写自定义函数" class="headerlink" title="（2）重写自定义函数"></a>（2）重写自定义函数</h4><ul>
<li>子类实现了父类中相同的方法（方法名、参数），在调用该方法时，实际执行的是子类的方法。</li>
</ul>
<ul>
<li> 快捷键：ctrl + O</li>
</ul>
<ul>
<li> 作用</li>
<li>在继承的基础上，体现类型的个性（一个行为有不同的实现）。</li>
<li>增强程序灵活性。</li>
</ul>
<h2 id="10-程序结构"><a href="#10-程序结构" class="headerlink" title="10. 程序结构"></a>10. 程序结构</h2><h3 id="10-1-模块-Module"><a href="#10-1-模块-Module" class="headerlink" title="10.1 模块 Module"></a>10.1 模块 Module</h3><h4 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​    包含一系列<strong>数据、函数、类</strong>的文件，通常以**.py**结尾。</p>
<h4 id="（2）作用"><a href="#（2）作用" class="headerlink" title="（2）作用"></a>（2）作用</h4><p>​    让一些相关的数据，函数，类有逻辑的组织在一起，使逻辑结构更加清晰。有利于多人合作开发。</p>
<h4 id="（3）导入"><a href="#（3）导入" class="headerlink" title="（3）导入"></a>（3）导入</h4><ul>
<li><p>import </p>
<ul>
<li><p>语法：</p>
<p>import 模块名</p>
<p>import 模块名 as 别名</p>
</li>
<li><p>作用：将模块整体导入到当前模块中</p>
</li>
<li><p>使用：</p>
<p>模块名.成员</p>
<p>别名.成员</p>
</li>
</ul>
</li>
<li><p>from import </p>
<ul>
<li><p>语法：</p>
<p>from 模块名 import 成员名</p>
<p>from 模块名 import 成员名  as 别名</p>
<p>from 模块名 import *</p>
</li>
<li><p>作用：将模块内的成员导入到当前模块作用域中</p>
</li>
<li><p>使用：直接使用成员名</p>
</li>
</ul>
</li>
</ul>
<h4 id="（4）模块变量"><a href="#（4）模块变量" class="headerlink" title="（4）模块变量"></a>（4）模块变量</h4><ul>
<li>__doc__变量：文档字符串。</li>
</ul>
<ul>
<li><p>__name__变量：模块自身名字，可以判断是否为主模块。</p>
<p>当此模块作为主模块(第一个运行的模块)运行时，__name__绑定’__main__‘，不是主模块，而是被其它模块导入时,存储模块名。</p>
</li>
</ul>
<h4 id="（5）-加载过程"><a href="#（5）-加载过程" class="headerlink" title="（5） 加载过程"></a>（5） 加载过程</h4><ul>
<li>在模块导入时，模块的所有语句会执行。</li>
</ul>
<ul>
<li>如果一个模块已经导入，则再次导入时不会重新执行模块内的语句。</li>
</ul>
<h4 id="（6）分类"><a href="#（6）分类" class="headerlink" title="（6）分类"></a>（6）分类</h4><ul>
<li>内置模块(builtins)，在解析器的内部可以直接使用。</li>
</ul>
<ul>
<li>标准库模块，安装Python时已安装且可直接使用。</li>
</ul>
<ul>
<li> 第三方模块（通常为开源），需要自己安装。</li>
</ul>
<ul>
<li> 用户自己编写的模块（可以作为其他人的第三方模块）</li>
</ul>
<h3 id="10-2-包package"><a href="#10-2-包package" class="headerlink" title="10.2 包package"></a>10.2 <font color="red">包package</font></h3><h4 id="（1）定义-1"><a href="#（1）定义-1" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​    将模块以<strong>文件夹的形式</strong>进行分组管理。让一些相关的模块组织在一起，使逻辑结构更加清晰。</p>
<h4 id="（2）-init-py的作用"><a href="#（2）-init-py的作用" class="headerlink" title="（2）__init.py的作用"></a>（2）__init.py的作用</h4><ul>
<li><p> _<em>init</em>_.py 在包被导入时会被执行</p>
</li>
<li><p>表示（标识）一个Python Package</p>
</li>
<li><p>对于自己写的模块，想要一键导入，单单这样写：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> package <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>​    是不够的，要在_<em>init</em>_.py中加入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [‘module1’,‘module2’,.]</span><br></pre></td></tr></table></figure>

<h4 id="（3）导入-1"><a href="#（3）导入-1" class="headerlink" title="（3）导入"></a>（3）导入</h4><ul>
<li><p>import </p>
<ul>
<li><p>语法：</p>
<p>import 包</p>
<p>import 包 as 别名</p>
</li>
<li><p>作用：将包中<strong>__init__模块内整体</strong>导入到当前模块中</p>
</li>
<li><p>使用：<strong>包.成员</strong></p>
</li>
</ul>
</li>
<li><p>from import </p>
<ul>
<li><p>语法：</p>
<p>from 包 import 成员</p>
<p>from 包  import 成员 as 别名</p>
</li>
<li><p>作用：将包中<strong>__init__模块内的成员</strong>导入到当前模块作用域中</p>
</li>
<li><p>使用：<strong>直接使用成员名</strong></p>
</li>
</ul>
</li>
<li><p>演示：</p>
<p>目录结构：</p>
<p>​        main.py</p>
<p>​        package01/</p>
<p>​            __init__.py</p>
<p>​            module01.py</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	package01/</span></span><br><span class="line"><span class="string">	    module01.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func01执行了&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func02</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func02执行了&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    main.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 方式1:import 包 as 别名</span></span><br><span class="line"><span class="keyword">import</span> package01 <span class="keyword">as</span> p</span><br><span class="line"></span><br><span class="line">p.module01.func01()</span><br><span class="line">p.func02()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2:from 包 import 成员</span></span><br><span class="line"><span class="keyword">from</span> package01 <span class="keyword">import</span> module01,func02</span><br><span class="line"></span><br><span class="line">module01.func01()</span><br><span class="line">func02()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	package01/</span></span><br><span class="line"><span class="string">	    __init__.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> package01.module01</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> package01.module01 <span class="keyword">import</span> func02</span><br></pre></td></tr></table></figure>



<h2 id="11-异常处理"><a href="#11-异常处理" class="headerlink" title="11. 异常处理"></a>11. 异常处理</h2><h3 id="11-1-异常"><a href="#11-1-异常" class="headerlink" title="11.1 异常"></a>11.1 异常</h3><h4 id="（1）定义-2"><a href="#（1）定义-2" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​        运行时检测到的错误。</p>
<h4 id="（2）现象"><a href="#（2）现象" class="headerlink" title="（2）现象"></a>（2）现象</h4><p>​        当异常发生时，程序不会再向下执行，而转到函数的调用语句。</p>
<h4 id="（3）常见异常类型"><a href="#（3）常见异常类型" class="headerlink" title="（3）常见异常类型"></a>（3）常见异常类型</h4><ul>
<li>名称异常(<font color="orange">NameError</font>)：变量未定义。</li>
</ul>
<ul>
<li><p>类型异常(<font color="orange">TypeError)</font>：不同类型数据进行运算。</p>
</li>
<li><p>索引异常(<font color="orange">IndexError</font>)：超出索引范围。</p>
</li>
<li><p>属性异常(<font color="orange">AttributeError</font>)：对象没有对应名称的属性。</p>
</li>
<li><p>键异常(<font color="orange">KeyError</font>)：没有对应名称的键。</p>
</li>
<li><p>异常基类<font color="orange">Exception</font>。</p>
</li>
<li></li>
</ul>
<h3 id="11-2-处理"><a href="#11-2-处理" class="headerlink" title="11.2 处理"></a>11.2 <font color="red">处理</font></h3><h4 id="（1）语法："><a href="#（1）语法：" class="headerlink" title="（1）语法："></a>（1）语法：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	可能触发异常的语句</span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span> [<span class="keyword">as</span> 变量<span class="number">1</span>]：</span><br><span class="line">	处理语句<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">2</span> [<span class="keyword">as</span> 变量<span class="number">2</span>]：</span><br><span class="line">	处理语句<span class="number">2</span></span><br><span class="line"><span class="keyword">except</span> Exception [<span class="keyword">as</span> 变量<span class="number">3</span>]：</span><br><span class="line">	不是以上错误类型的处理语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	未发生异常的语句</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	无论是否发生异常的语句</span><br></pre></td></tr></table></figure>

<h4 id="（2）作用-1"><a href="#（2）作用-1" class="headerlink" title="（2）作用"></a>（2）作用</h4><p>​    将程序由异常状态转为正常流程。</p>
<h4 id="（3）说明"><a href="#（3）说明" class="headerlink" title="（3）说明"></a>（3）说明</h4><ul>
<li>as 子句是用于绑定错误对象的变量，可以省略</li>
</ul>
<ul>
<li>except子句可以有一个或多个，用来捕获某种类型的错误。</li>
</ul>
<ul>
<li>else子句最多只能有一个。</li>
</ul>
<ul>
<li>finally子句最多只能有一个，如果没有except子句，必须存在。</li>
</ul>
<ul>
<li>如果异常没有被捕获到，会向上层(调用处)继续传递，直到程序终止运行。</li>
</ul>
<h3 id="11-3-raise-语句"><a href="#11-3-raise-语句" class="headerlink" title="11.3 raise 语句"></a>11.3 raise 语句</h3><h4 id="（1）-作用"><a href="#（1）-作用" class="headerlink" title="（1） 作用"></a>（1） 作用</h4><p>​    抛出一个错误，让程序进入异常状态。</p>
<h4 id="（2）目的"><a href="#（2）目的" class="headerlink" title="（2）目的"></a>（2）目的</h4><p>​    在程序调用层数较深时，向主调函数传递错误信息要层层return比较麻烦，所以人为抛出异常，可以直接传递错误信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wife</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">20</span> &lt;= value &lt;= <span class="number">60</span>:</span><br><span class="line">            self.__age = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 创建异常  -- 抛出 错误信息</span></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;我不要&quot;</span>,<span class="string">&quot;if 20 &lt;= value &lt;= 60&quot;</span>,<span class="number">1001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- 接收 错误信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你老婆年龄：&quot;</span>))</span><br><span class="line">        w01 = Wife(age)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e.args) <span class="comment"># (&#x27;我不要&#x27;, &#x27;if 30 &lt;= value &lt;= 60&#x27;, 1001)</span></span><br></pre></td></tr></table></figure>



<h2 id="12-迭代器iterator"><a href="#12-迭代器iterator" class="headerlink" title="12. 迭代器iterator"></a>12. 迭代器iterator</h2><p>​    每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。例如：循环获取容器中的元素。</p>
<h3 id="12-1-可迭代对象iterabale"><a href="#12-1-可迭代对象iterabale" class="headerlink" title="12.1 可迭代对象iterabale"></a>12.1 可迭代对象iterabale</h3><h4 id="（1）定义-3"><a href="#（1）定义-3" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​        可迭代对象：具有<font color="orange">__iter__</font>函数的对象，可以返回迭代器对象。如字符串，列表等。</p>
<h4 id="（2）语法"><a href="#（2）语法" class="headerlink" title="（2）语法"></a>（2）语法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 可迭代对象名称:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">   		<span class="keyword">return</span> 迭代器</span><br><span class="line"><span class="comment"># 使用：</span></span><br><span class="line">	<span class="keyword">for</span> 变量名 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">		语句</span><br></pre></td></tr></table></figure>

<h4 id="（3）原理"><a href="#（3）原理" class="headerlink" title="（3）原理"></a>（3）原理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">迭代器 = 可迭代对象.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        <span class="built_in">print</span>(迭代器.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h4 id="（4）演示"><a href="#（4）演示" class="headerlink" title="（4）演示"></a>（4）演示</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">&quot;我是花果山水帘洞孙悟空&quot;</span></span><br><span class="line"><span class="comment"># for item in message:</span></span><br><span class="line"><span class="comment">#     print(item)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 获取迭代器对象</span></span><br><span class="line">iterator = message.__iter__()</span><br><span class="line"><span class="comment"># 2. 获取下一个元素</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        item = iterator.__next__()</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">        <span class="comment"># 3. 如果停止迭代则跳出循环</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<h3 id="12-2-迭代器对象iterator"><a href="#12-2-迭代器对象iterator" class="headerlink" title="12.2 迭代器对象iterator"></a>12.2 迭代器对象iterator</h3><h4 id="（1）定义-4"><a href="#（1）定义-4" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​        可以被next()函数调用并返回下一个值的对象。</p>
<h4 id="（2）语法-1"><a href="#（2）语法-1" class="headerlink" title="（2）语法"></a>（2）语法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 迭代器类名:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, 聚合对象</span>):</span></span><br><span class="line">        self.聚合对象= 聚合对象 </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="keyword">if</span> 没有元素:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">            <span class="keyword">return</span> 聚合对象元素</span><br></pre></td></tr></table></figure>

<h4 id="（3）说明-1"><a href="#（3）说明-1" class="headerlink" title="（3）说明"></a>（3）说明</h4><p>​    聚合对象通常是容器对象。</p>
<h4 id="（4）作用"><a href="#（4）作用" class="headerlink" title="（4）作用"></a>（4）作用</h4><p>​    使用者只需通过一种方式，便可简洁明了的获取聚合对象中各个元素，而又无需了解其内部结构。</p>
<h4 id="（5）演示："><a href="#（5）演示：" class="headerlink" title="（5）演示："></a>（5）演示：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentIterator</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.__data = data</span><br><span class="line">        self.__index = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__index == <span class="built_in">len</span>(self.__data) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.__index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.__data[self.__index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentController</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__students = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_student</span>(<span class="params">self, stu</span>):</span></span><br><span class="line">        self.__students.append(stu)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> StudentIterator(self.__students)</span><br><span class="line"> </span><br><span class="line">controller = StudentController()</span><br><span class="line">controller.add_student(<span class="string">&quot;悟空&quot;</span>)</span><br><span class="line">controller.add_student(<span class="string">&quot;八戒&quot;</span>)</span><br><span class="line">controller.add_student(<span class="string">&quot;唐僧&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for item in controller:</span></span><br><span class="line"><span class="comment">#     print(item) #</span></span><br><span class="line">iterator = controller.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        item = iterator.__next__()</span><br><span class="line">        <span class="built_in">print</span>(item)  <span class="comment">#</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<h2 id="13-生成器generator"><a href="#13-生成器generator" class="headerlink" title="13. 生成器generator"></a>13. 生成器generator</h2><ul>
<li>定义：能够动态(循环一次计算一次返回一次)提供数据的可迭代对象。</li>
</ul>
<ul>
<li>作用：在循环过程中，按照某种算法推算数据，不必创建容器存储完整的结果，从而节省内存空间。数据量越大，优势越明显。以上作用也称之为<strong>延迟操作或惰性操作</strong>，通俗的讲就是在需要的时候才计算结果，而不是一次构建出所有结果。</li>
</ul>
<h3 id="13-1-生成器函数"><a href="#13-1-生成器函数" class="headerlink" title="13.1 生成器函数"></a>13.1 生成器函数</h3><h4 id="（1）定义-5"><a href="#（1）定义-5" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​    含有<font color="orange">yield</font>语句的函数，返回值为生成器对象。</p>
<h4 id="（2）语法-2"><a href="#（2）语法-2" class="headerlink" title="（2）语法"></a>（2）语法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 函数名():</span></span><br><span class="line">	…</span><br><span class="line">	<span class="keyword">yield</span> 数据</span><br><span class="line">	…</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用：</span></span><br><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 函数名():</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>

<h4 id="（3）说明-2"><a href="#（3）说明-2" class="headerlink" title="（3）说明"></a>（3）说明</h4><ul>
<li>调用生成器函数将返回一个生成器对象，不执行函数体。</li>
</ul>
<ul>
<li>yield翻译为”产生”或”生成”</li>
</ul>
<h4 id="（4）执行过程："><a href="#（4）执行过程：" class="headerlink" title="（4）执行过程："></a>（4）执行过程：</h4><p>​        a. 调用生成器函数会<strong>自动创建迭代器对象</strong>。</p>
<p>​        b. 调用迭代器对象的__next__()方法时才执行生成器函数。</p>
<p>​        c. 每次执行到yield语句时返回数据，暂时离开。</p>
<p>​        d. 待下次调用__next__()方法时继续从离开处继续执行。</p>
<h4 id="（5）原理"><a href="#（5）原理" class="headerlink" title="（5）原理"></a>（5）原理</h4><p>​        生成迭代器对象的大致规则如下</p>
<p>​            a. 将yield关键字以前的代码放在next方法中。</p>
<p>​            b. 将yield关键字后面的数据作为next方法的返回值。</p>
<p>(6) 演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_range</span>(<span class="params">stop</span>):</span></span><br><span class="line">    number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> number &lt; stop:</span><br><span class="line">        <span class="keyword">yield</span> number</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> my_range(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(number)  <span class="comment"># 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>



<h3 id="13-2-内置生成器"><a href="#13-2-内置生成器" class="headerlink" title="13.2 内置生成器"></a>13.2 <font color="red">内置生成器</font></h3><h4 id="（1）枚举函数enumerate"><a href="#（1）枚举函数enumerate" class="headerlink" title="（1）枚举函数enumerate"></a>（1）枚举函数enumerate</h4><ul>
<li>语法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> <span class="built_in">enumerate</span>(可迭代对象):</span><br><span class="line">    语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 索引, 元素<span class="keyword">in</span> <span class="built_in">enumerate</span>(可迭代对象):</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>

<ul>
<li> 作用：遍历可迭代对象时，可以<strong>将索引与元素组合为一个元组</strong>。</li>
</ul>
<ul>
<li>演示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list01 = [<span class="number">43</span>, <span class="number">43</span>, <span class="number">54</span>, <span class="number">56</span>, <span class="number">76</span>]</span><br><span class="line"><span class="comment"># 从头到尾读          -- 读取数据</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list01:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非从头到尾读        -- 修改数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list01)):</span><br><span class="line">    <span class="keyword">if</span> list01[i] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        list01[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(list01):  <span class="comment"># -- 读写数据</span></span><br><span class="line">    <span class="keyword">if</span> item % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        list01[i] += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）zip"><a href="#（2）zip" class="headerlink" title="（2）zip"></a>（2）zip</h4><ul>
<li>语法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(可迭代对象<span class="number">1</span>, 可迭代对象<span class="number">2</span>):</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：将<strong>多个可迭代对象中对应的元素组合成一个个元组</strong>，生成的元组个数由最小的可迭代对象决定。</li>
</ul>
<ul>
<li>演示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_name = [<span class="string">&quot;悟空&quot;</span>, <span class="string">&quot;八戒&quot;</span>, <span class="string">&quot;沙僧&quot;</span>]</span><br><span class="line">list_age = [<span class="number">22</span>, <span class="number">26</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># for 变量 in zip(可迭代对象1,可迭代对象2)</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(list_name, list_age):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># (&#x27;悟空&#x27;, 22)</span></span><br><span class="line"><span class="comment"># (&#x27;八戒&#x27;, 26)</span></span><br><span class="line"><span class="comment"># (&#x27;沙僧&#x27;, 25)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用:矩阵转置</span></span><br><span class="line"><span class="built_in">map</span> = [</span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment"># new_map = []</span></span><br><span class="line"><span class="comment"># for item in zip(map[0],map[1],map[2],map[3]):</span></span><br><span class="line"><span class="comment">#     new_map.append(list(item))</span></span><br><span class="line"><span class="comment"># print(new_map)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># new_map = []</span></span><br><span class="line"><span class="comment"># for item in zip(*map):</span></span><br><span class="line"><span class="comment">#     new_map.append(list(item))</span></span><br><span class="line"></span><br><span class="line">new_map = [<span class="built_in">list</span>(item) <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(*<span class="built_in">map</span>)]</span><br><span class="line"><span class="built_in">print</span>(new_map)</span><br><span class="line"><span class="comment"># [[2, 4, 2, 0], [0, 2, 4, 4], [0, 0, 2, 0], [2, 2, 4, 4]]</span></span><br></pre></td></tr></table></figure>



<h3 id="13-3-生成器表达式"><a href="#13-3-生成器表达式" class="headerlink" title="13.3 生成器表达式"></a>13.3 生成器表达式</h3><ul>
<li>定义：用推导式形式创建生成器对象。</li>
</ul>
<ul>
<li>语法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量 = (表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 可迭代对象 <span class="keyword">if</span> 条件)</span><br></pre></td></tr></table></figure>



<h2 id="14-函数式编程"><a href="#14-函数式编程" class="headerlink" title="14. 函数式编程"></a>14. 函数式编程</h2><ul>
<li><p>定义：用一系列函数解决问题。</p>
<ul>
<li>函数可以<strong>赋值给变量</strong>，赋值后变量绑定函数。</li>
<li>允许将函数<strong>作为参数</strong>传入另一个函数。</li>
<li>允许函数<strong>返回一个函数</strong>。</li>
</ul>
</li>
<li><p>高阶函数：将函数作为参数或返回值的函数。</p>
</li>
</ul>
<h3 id="14-1-函数作为参数"><a href="#14-1-函数作为参数" class="headerlink" title="14.1 函数作为参数"></a>14.1 函数作为参数</h3><p>​    将核心逻辑传入方法体，使该方法的适用性更广，体现了面向对象的开闭原则。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list01 = [<span class="number">342</span>, <span class="number">4</span>, <span class="number">54</span>, <span class="number">56</span>, <span class="number">6776</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数,在列表中查找所有大于100的数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number_gt_100</span>():</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="keyword">if</span> number &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">yield</span> number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数,在列表中查找所有偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number_by_even</span>():</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> number</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：得到的是列表中的元素</span></span><br><span class="line"><span class="comment"># 返回值：对列表元素判断后的结果(True False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition01</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">return</span> number &gt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition02</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">return</span> number % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition03</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通用函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_all</span>(<span class="params">condition</span>):</span> <span class="comment"># 抽象</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="comment"># if number &gt; 100:</span></span><br><span class="line">        <span class="comment"># if condition01(item):</span></span><br><span class="line">        <span class="comment"># if condition02(item):</span></span><br><span class="line">        <span class="keyword">if</span> condition(item):<span class="comment"># 统一</span></span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> find_all(condition03):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>



<h4 id="（1）lambda-表达式"><a href="#（1）lambda-表达式" class="headerlink" title="（1）lambda 表达式"></a>（1）lambda 表达式</h4><p>​    <a href="/2022/02/19/Python-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="Python-lambda表达式">Python-lambda表达式</a></p>
<ul>
<li>定义：是一种匿名方法</li>
</ul>
<ul>
<li><p>作用：</p>
<ul>
<li>作为参数传递时语法简洁，优雅，代码可读性强。</li>
<li>随时创建和销毁，减少程序耦合度。</li>
</ul>
</li>
<li><p>语法</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义：</span></span><br><span class="line">变量 = <span class="keyword">lambda</span> 形参: 方法体</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用：</span></span><br><span class="line">变量(实参)</span><br></pre></td></tr></table></figure>

<ul>
<li>说明：<ul>
<li>形参没有可以不填</li>
<li>方法体只能有一条语句，且不支持赋值语句。</li>
</ul>
</li>
</ul>
<p>(5) 演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> common.iterable_tools <span class="keyword">import</span> IterableHelper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数,在列表中查找所有大于100的数</span></span><br><span class="line"><span class="comment"># def condition01(number):</span></span><br><span class="line"><span class="comment">#     return number &gt; 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数,在列表中查找所有偶数</span></span><br><span class="line"><span class="comment"># def condition02(number):</span></span><br><span class="line"><span class="comment">#     return number % 2 == 0</span></span><br><span class="line"></span><br><span class="line">list01 = [<span class="number">342</span>, <span class="number">4</span>, <span class="number">54</span>, <span class="number">56</span>, <span class="number">6776</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> IterableHelper.find_all(list01,<span class="keyword">lambda</span> number: number &gt; <span class="number">100</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> IterableHelper.find_all(list01,<span class="keyword">lambda</span> number: number % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>



<h4 id="（2）内置高阶函数"><a href="#（2）内置高阶函数" class="headerlink" title="（2）内置高阶函数"></a>（2）内置高阶函数</h4><ul>
<li>map（函数，可迭代对象）：使用可迭代对象中的每个元素调用函数，将返回值作为新可迭代对象元素；返回值为新可迭代对象。</li>
</ul>
<ul>
<li>filter(函数，可迭代对象)：根据条件筛选可迭代对象中的元素，返回值为新可迭代对象。</li>
</ul>
<ul>
<li>sorted(可迭代对象，key = 函数, reverse = bool值)：排序，返回值为排序结果。</li>
</ul>
<ul>
<li>max(可迭代对象，key = 函数)：根据函数获取可迭代对象的最大值。</li>
</ul>
<ul>
<li>min(可迭代对象，key = 函数)：根据函数获取可迭代对象的最小值。</li>
</ul>
<ul>
<li>演示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, eid, did, name, money</span>):</span></span><br><span class="line">        self.eid = eid  <span class="comment"># 员工编号</span></span><br><span class="line">        self.did = did  <span class="comment"># 部门编号</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.money = money</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 员工列表</span></span><br><span class="line">list_employees = [</span><br><span class="line">    Employee(<span class="number">1001</span>, <span class="number">9002</span>, <span class="string">&quot;师父&quot;</span>, <span class="number">60000</span>),</span><br><span class="line">    Employee(<span class="number">1002</span>, <span class="number">9001</span>, <span class="string">&quot;孙悟空&quot;</span>, <span class="number">50000</span>),</span><br><span class="line">    Employee(<span class="number">1003</span>, <span class="number">9002</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="number">20000</span>),</span><br><span class="line">    Employee(<span class="number">1004</span>, <span class="number">9001</span>, <span class="string">&quot;沙僧&quot;</span>, <span class="number">30000</span>),</span><br><span class="line">    Employee(<span class="number">1005</span>, <span class="number">9001</span>, <span class="string">&quot;小白龙&quot;</span>, <span class="number">15000</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. map 映射</span></span><br><span class="line"><span class="comment"># 需求:获取所有员工姓名</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> item: item.name, list_employees):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. filter 过滤器</span></span><br><span class="line"><span class="comment"># 需求：查找所有部门是9002的员工</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="keyword">lambda</span> item: item.did == <span class="number">9002</span>, list_employees):</span><br><span class="line">    <span class="built_in">print</span>(item.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. max min 最值</span></span><br><span class="line">emp = <span class="built_in">max</span>(list_employees, key=<span class="keyword">lambda</span> emp: emp.money)</span><br><span class="line"><span class="built_in">print</span>(emp.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. sorted</span></span><br><span class="line"><span class="comment"># 升序排列</span></span><br><span class="line">new_list = <span class="built_in">sorted</span>(list_employees, key=<span class="keyword">lambda</span> emp: emp.money)</span><br><span class="line"><span class="built_in">print</span>(new_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 降序排列</span></span><br><span class="line">new_list = <span class="built_in">sorted</span>(list_employees, key=<span class="keyword">lambda</span> emp: emp.money, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(new_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="14-2-函数作为返回值"><a href="#14-2-函数作为返回值" class="headerlink" title="14.2 函数作为返回值"></a>14.2 函数作为返回值</h3><p>逻辑连续，当内部函数被调用时，不脱离当前的逻辑。</p>
<h4 id="（1）闭包"><a href="#（1）闭包" class="headerlink" title="（1）闭包"></a>（1）<font color="red">闭包</font></h4><ul>
<li><p>三要素：</p>
<ul>
<li>必须有一个内嵌函数。</li>
<li>内嵌函数必须引用外部函数中变量。</li>
<li>外部函数返回值必须是内嵌函数。</li>
</ul>
</li>
<li><p>语法</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 外部函数名(<span class="params">参数</span>):</span></span><br><span class="line">    外部变量</span><br><span class="line">    <span class="function"><span class="keyword">def</span> 内部函数名(<span class="params">参数</span>):</span></span><br><span class="line">        使用外部变量</span><br><span class="line">    <span class="keyword">return</span> 内部函数名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用：</span></span><br><span class="line">变量 = 外部函数名(参数)</span><br><span class="line">变量(参数)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义：是由函数及其相关的引用环境组合而成的实体。 </p>
</li>
<li><p>优点：内部函数可以使用外部变量。</p>
</li>
</ul>
<ul>
<li>缺点：外部变量一直存在于内存中，不会在调用结束后释放，占用内存。</li>
</ul>
<ul>
<li><p>作用：实现python装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="comment"># 定义：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 函数装饰器名称(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> 内部函数名(<span class="params">*args, **kwarg</span>):</span></span><br><span class="line">        需要添加的新功能</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> 内部函数名</span><br><span class="line"></span><br><span class="line"><span class="meta">@ 函数装饰器名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 被装饰函数名():</span></span><br><span class="line">	原来的功能</span><br></pre></td></tr></table></figure></li>
</ul>
<p>(7) 演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">give_gife_money</span>(<span class="params">money</span>):</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;获得&quot;</span>, money, <span class="string">&quot;元压岁钱&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">child_buy</span>(<span class="params">commodity, price</span>):</span> </span><br><span class="line">        <span class="keyword">nonlocal</span> money		<span class="comment"># 在内层函数修改外层嵌套函数内的变量</span></span><br><span class="line">        money -= price</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;购买了&quot;</span>, commodity, <span class="string">&quot;花了&quot;</span>, price, <span class="string">&quot;元,还剩下&quot;</span>, money)</span><br><span class="line">    <span class="keyword">return</span> child_buy</span><br><span class="line"></span><br><span class="line">action = give_gife_money(<span class="number">500</span>)	<span class="comment"># 返回值是一个函数child_buy</span></span><br><span class="line">action(<span class="string">&quot;变形金刚&quot;</span>, <span class="number">200</span>)</span><br><span class="line">action(<span class="string">&quot;芭比娃娃&quot;</span>, <span class="number">300</span>)</span><br></pre></td></tr></table></figure>



<h4 id="（2）函数装饰器decorator"><a href="#（2）函数装饰器decorator" class="headerlink" title="（2）函数装饰器decorator"></a>（2）<font color="red">函数装饰器decorator</font></h4><ul>
<li> 定义：在不改变原函数的调用以及内部代码情况下，为其添加新功能的函数。</li>
</ul>
<ul>
<li>语法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数装饰器名称(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span>	<span class="comment">#星号元组形参，双星号字典形参</span></span><br><span class="line">        需要添加的新功能</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@ 函数装饰器名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 原函数名称(<span class="params">参数</span>):</span></span><br><span class="line">    函数体</span><br><span class="line"></span><br><span class="line">原函数(参数)</span><br></pre></td></tr></table></figure>

<ul>
<li>本质：使用“<font color="orange">@函数装饰器名称</font>”修饰原函数，<font color="orange">等同于创建与原函数名称相同的变量，关联内嵌函数</font>；故调用原函数时执行内嵌函数。</li>
</ul>
<p>​        <font color="red">原函数名称 = 函数装饰器名称（原函数名称）</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;旧功能&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_func</span>(<span class="params">func</span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;新功能&quot;</span>)</span><br><span class="line">        func() <span class="comment"># 执行旧功能</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新功能覆盖了旧功能（没有将func01作为参数传入new_func）</span></span><br><span class="line"><span class="comment"># func01 = new_func</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用一次外部函数(装饰器本质)</span></span><br><span class="line">func01 = new_func(func01)</span><br><span class="line"><span class="comment"># 调用多次内部函数</span></span><br><span class="line">func01()</span><br><span class="line">func01()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>装饰器链：</p>
<p>一个函数可以被多个装饰器修饰，执行顺序为从近到远。</p>
</li>
</ul>
<h2 id="15-文件操作"><a href="#15-文件操作" class="headerlink" title="15. 文件操作"></a>15. 文件操作</h2><h3 id="15-1-文件与字节串"><a href="#15-1-文件与字节串" class="headerlink" title="15.1 文件与字节串"></a>15.1 文件与字节串</h3><h4 id="（1）文件"><a href="#（1）文件" class="headerlink" title="（1）文件"></a>（1）文件</h4><p>​    文件是保存在持久化存储设备(硬盘、U盘、光盘..)上的一段数据。从格式编码角度分为文本文件（打开后会自动解码为字符）、二进制文件(视频、音频等)。在Python里把文件视作一种类型的对象，类似之前学习过的其它类型。</p>
<h4 id="（2）字节串（bytes）"><a href="#（2）字节串（bytes）" class="headerlink" title="（2）字节串（bytes）"></a>（2）字节串（bytes）</h4><p>​    在python3中引入了字节串的概念，与str不同，字节串以字节序列值表达数据，更方便用来处理二进程数据。因此在python3中字节串是常见的二进制数据展现方式。</p>
<ul>
<li>普通的ascii编码字符串可以在前面加b转换为字节串，例如：b’hello’</li>
<li>字符串转换为字节串方法 ：str.encode()</li>
<li>字节串转换为字符串方法 : bytes.decode() </li>
</ul>
<h3 id="15-2-文件读写"><a href="#15-2-文件读写" class="headerlink" title="15.2 文件读写"></a>15.2 文件读写</h3><h4 id="（1）打开文件"><a href="#（1）打开文件" class="headerlink" title="（1）打开文件"></a>（1）打开文件</h4><ul>
<li><p><font color="red">file_object = open(file_name, access_mode=’r’, buffering=-1)</font></p>
</li>
<li><p>功能：打开一个文件，返回一个文件对象。</p>
</li>
<li><p>参数：</p>
<ul>
<li><p>file_name  文件名；</p>
</li>
<li><p>access_mode  打开文件的方式,如果不写默认为‘r’ </p>
<table>
<thead>
<tr>
<th align="center">文件模式</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">以读方式打开，文件必须存在</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">以写方式打开，文件不存在则会创建，存在则清空原有内容</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">以追加模式打开</td>
</tr>
<tr>
<td align="center">r+</td>
<td align="center">以读写模式打开，文件必须存在</td>
</tr>
<tr>
<td align="center">w+</td>
<td align="center">以读写模式打开，不存在则会创建，存在则清空原有内容</td>
</tr>
<tr>
<td align="center">a+</td>
<td align="center">以读写模式打开，追加模式</td>
</tr>
<tr>
<td align="center">rb</td>
<td align="center">以二进制读模式打开，同r</td>
</tr>
<tr>
<td align="center">wb</td>
<td align="center">以二进制写模式打开，同w</td>
</tr>
<tr>
<td align="center">ab</td>
<td align="center">以二进制追加模式打开，同a</td>
</tr>
<tr>
<td align="center">rb+</td>
<td align="center">以二进制读写模式打开，同r+</td>
</tr>
<tr>
<td align="center">wb+</td>
<td align="center">以二进制读写模式打开，同w+</td>
</tr>
<tr>
<td align="center">ab+</td>
<td align="center">以二进制读写模式打开，同a+</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li>buffering  1表示有行缓冲，默认则表示使用系统默认提供的缓冲机制。</li>
<li>返回值：成功返回文件操作对象。</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>加b的打开方式读写要求必须都是字节串</li>
<li>无论什么文件都可以使用二进制方式打开，但是二进制文件使用文本方式打开读写会出错</li>
</ul>
</li>
</ul>
<h4 id="（2）读取文件"><a href="#（2）读取文件" class="headerlink" title="（2）读取文件"></a>（2）读取文件</h4><ul>
<li><p>read([size])</p>
<ul>
<li>功能： 来直接读取文件中字符。</li>
<li>参数： 如果没有给定size参数（默认值为-1）或者size值为负，文件将被读取直至末尾，给定size最多读取给定数目个字符（字节）。</li>
<li>返回值： 返回读取到的内容</li>
<li>注意：文件过大时候不建议直接读取到文件结尾，读到文件结尾会返回空字符串。</li>
</ul>
</li>
<li><p>readline([size])</p>
<ul>
<li>功能： 指定的用来读取文件中一行</li>
<li>参数： 如果没有给定size参数（默认值为-1）或者size值为负，表示读取一行，给定size表示最多读取指定的字符（字节）。</li>
<li>返回值： 返回读取到的内容</li>
</ul>
</li>
<li><p>readlines([sizeint])</p>
<ul>
<li><p>功能： 读取文件中的每一行作为列表中的一项</p>
</li>
<li><p>参数： 如果没有给定size参数（默认值为-1）或者size值为负，文件将被读取直至末尾，给定size表示读取到size字符所在行为止。</p>
</li>
<li><p>返回值： 返回读取到的内容列表</p>
</li>
<li><p>文件对象本身也是一个可迭代对象，在for循环中可以迭代文件的每一行。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">     <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>

<h4 id="（3）写入文件"><a href="#（3）写入文件" class="headerlink" title="（3）写入文件"></a>（3）写入文件</h4><ul>
<li>write(string)<ul>
<li>功能: 把文本数据或二进制数据块的字符串写入到文件中去</li>
<li>参数：要写入的内容</li>
<li>如果需要换行要自己在写入内容中添加\n</li>
</ul>
</li>
<li>writelines(str_list)<ul>
<li>功能：接受一个字符串列表作为参数，将它们写入文件。</li>
<li>参数: 要写入的内容列表</li>
</ul>
</li>
</ul>
<h4 id="（4）关闭文件"><a href="#（4）关闭文件" class="headerlink" title="（4）关闭文件"></a>（4）关闭文件</h4><p>​    打开一个文件后我们就可以通过文件对象对文件进行操作了，当操作结束后使用close（）关闭这个对象可以防止一些误操作，也可以节省资源。</p>
<p>​    file_object.close()</p>
<h4 id="（5）with操作"><a href="#（5）with操作" class="headerlink" title="（5）with操作"></a>（5）with操作</h4><ul>
<li><p>Python中with语句使用于<font color="orange">对资源进行访问</font>的场合，保证不管处理过程中是否发生错误或者异常都会</p>
<p>执行规定的”清理“操作，释放被访问的资源，比如有文件读写后自动关闭、线程中锁自动获取和释放。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]:</span><br><span class="line">	<span class="keyword">with</span>-body</span><br></pre></td></tr></table></figure>
<ul>
<li>通过with方法可以不用close(),因为with生成的对象在语句块结束后会自动处理，所以也就不需要close了，但是这个文件对象只能在with语句块内使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file&#x27;</span>,<span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read()</span><br></pre></td></tr></table></figure>



<h3 id="15-2-其他操作"><a href="#15-2-其他操作" class="headerlink" title="15.2 其他操作"></a>15.2 其他操作</h3><h4 id="（1）刷新缓冲区"><a href="#（1）刷新缓冲区" class="headerlink" title="（1）刷新缓冲区"></a>（1）刷新缓冲区</h4><ul>
<li>缓冲:系统自动的在内存中为每一个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，再由缓冲区送到磁盘中去。从磁盘中读数据，则一次从磁盘文件将一批数据读入到内存缓冲区中，然后再从缓冲区将数据送到程序的数据区。</li>
</ul>
<ul>
<li><p>刷新缓冲区条件：</p>
<ul>
<li><p>缓冲区被写满</p>
</li>
<li><p>程序执行结束或者文件对象被关闭</p>
</li>
<li><p>行缓冲遇到换行</p>
</li>
<li><p>程序中调用flush()函数</p>
<ul>
<li>flush()<br>该函数调用后会进行一次磁盘交互，将缓冲区中的内容写入到磁盘。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（2）文件偏移量"><a href="#（2）文件偏移量" class="headerlink" title="（2）文件偏移量"></a>（2）文件偏移量</h4><ul>
<li><p>定义：打开一个文件进行操作时系统会自动生成一个记录，记录中描述了我们对文件的一系列操作。其中包括每次操作到的文件位置。文件的读写操作都是从这个位置开始进行的。</p>
</li>
<li><p>基本操作</p>
</li>
<li><p>tell()</p>
<ul>
<li>功能：获取文件偏移量大小</li>
</ul>
</li>
<li><p>seek(offset[,whence])</p>
<ul>
<li>功能:移动文件偏移量位置</li>
<li>参数：<ul>
<li>offset 代表相对于某个位置移动的字节数。负数表示向前移动，正数表示向后移动。</li>
<li>whence是基准位置的默认值为 0，代表从文件开头算起，1代表从当前位置算起，2 代表从文件末尾算起。</li>
<li>必须以二进制方式打开文件时基准位置才能是1或者2</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（3）文件描述符"><a href="#（3）文件描述符" class="headerlink" title="（3）文件描述符"></a>（3）文件描述符</h4><ul>
<li><p>定义：系统中每一个IO操作都会分配一个整数作为编号，该整数即这个IO操作的文件描述符。</p>
</li>
<li><p>获取文件描述符</p>
<ul>
<li>fileno()<br>通过IO对象获取对应的文件描述符</li>
</ul>
</li>
</ul>
<h3 id="15-3-文件管理函数"><a href="#15-3-文件管理函数" class="headerlink" title="15.3 文件管理函数"></a>15.3 文件管理函数</h3><ul>
<li><p>获取文件大小  </p>
<p>os.path.getsize(file)</p>
</li>
<li><p>查看文件列表  </p>
<p>os.listdir(dir)</p>
</li>
<li><p>查看文件是否存在</p>
<p>os.path.exists(file)</p>
</li>
<li><p>判断文件类型</p>
<p>os.path.isfile(file)</p>
</li>
<li><p>删除文件</p>
<p>os.remove(file)</p>
</li>
</ul>
<h2 id="16-网络编程"><a href="#16-网络编程" class="headerlink" title="16. 网络编程"></a>16. 网络编程</h2><p>计算机网络功能主要包括实现资源共享，实现数据信息的快速传递。</p>
<h3 id="16-1-网络编程基础"><a href="#16-1-网络编程基础" class="headerlink" title="16.1 网络编程基础"></a>16.1 网络编程基础</h3><h4 id="（1）OSI七层模型"><a href="#（1）OSI七层模型" class="headerlink" title="（1）OSI七层模型"></a>（1）OSI七层模型</h4><blockquote>
<p>制定组织： ISO（国际标准化组织）</p>
</blockquote>
<blockquote>
<p>作用：使网络通信工作流程标准化</p>
</blockquote>
<blockquote>
<p>应用层 ： 提供用户服务，具体功能由应用程序实现<br>表示层 ： 数据的压缩优化加密<br>会话层 ： 建立用户级的连接，选择适当的传输服务<br>传输层 ： 提供传输服务<br>网络层 ： 路由选择，网络互联<br>链路层 ： 进行数据交换，控制具体数据的发送<br>物理层 ： 提供数据传输的硬件保证，网卡接口，传输介质</p>
</blockquote>
<blockquote>
<p>优点 </p>
<ol>
<li>建立了统一的工作流程</li>
<li>分部清晰，各司其职，每个步骤分工明确</li>
<li>降低了各个模块之间的耦合度，便于开发</li>
</ol>
</blockquote>
<h4 id="（2）四层模型（TCP-IP模型）"><a href="#（2）四层模型（TCP-IP模型）" class="headerlink" title="（2）四层模型（TCP/IP模型）"></a>（2）四层模型（TCP/IP模型）</h4><p>背景 ： 实际工作中工程师无法完全按照七层模型要求操作，逐渐演化为更符合实际情况的四层</p>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_tcpip%E6%A8%A1%E5%9E%8B.png" alt="TCP/IP模型"></p>
<h5 id="1-gt-数据传输过程"><a href="#1-gt-数据传输过程" class="headerlink" title="1&gt; 数据传输过程"></a>1&gt; 数据传输过程</h5><ol>
<li>发送端由应用程序发送消息，逐层添加首部信息，最终在物理层发送消息包。</li>
<li>发送的消息经过多个节点（交换机，路由器）传输，最终到达目标主机。</li>
<li>目标主机由物理层逐层解析首部消息包，最终到应用程序呈现消息。</li>
</ol>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_TCP.png" alt="TCP/IP模型"></p>
<h5 id="2-gt-网络协议"><a href="#2-gt-网络协议" class="headerlink" title="2&gt; 网络协议"></a>2&gt; 网络协议</h5><blockquote>
<p>在网络数据传输中，都遵循的规定，包括建立什么样的数据结构，什么样的特殊标志等。</p>
</blockquote>
<h5 id="3-gt-网络基础概念"><a href="#3-gt-网络基础概念" class="headerlink" title="3&gt; 网络基础概念"></a>3&gt; 网络基础概念</h5><ul>
<li>IP地址</li>
</ul>
<blockquote>
<p>功能：确定一台主机的网络路由位置</p>
</blockquote>
<blockquote>
<p>查看本机网络地址命令： ifconfig</p>
</blockquote>
<blockquote>
<p>结构</p>
<blockquote>
<p>IPv4  点分十进制表示 172.40.91.185 每部分取值范围0–255<br>IPv6  128位 扩大了地址范围</p>
</blockquote>
</blockquote>
<ul>
<li>域名</li>
</ul>
<blockquote>
<p>定义： 给网络服务器地址起的名字</p>
</blockquote>
<blockquote>
<p>作用： 方便记忆，表达一定的含义</p>
</blockquote>
<blockquote>
<p>ping [ip] : 测试和某个主机是否联通</p>
</blockquote>
<ul>
<li>端口号（port）</li>
</ul>
<blockquote>
<p>作用：端口是网络地址的一部分，用于区分主机上不同的网络应用程序。</p>
</blockquote>
<blockquote>
<p>特点：一个系统中的应用监听端口不能重复</p>
</blockquote>
<blockquote>
<p>取值范围： 1 – 65535</p>
<blockquote>
<p>1–1023  系统应用或者大众程序监听端口<br>1024–65535 自用端口</p>
</blockquote>
</blockquote>
<h4 id="（3）传输层服务"><a href="#（3）传输层服务" class="headerlink" title="（3）传输层服务"></a>（3）传输层服务</h4><h5 id="1-gt-基于TCP协议的数据传输"><a href="#1-gt-基于TCP协议的数据传输" class="headerlink" title="1&gt;  基于TCP协议的数据传输"></a>1&gt;  基于TCP协议的数据传输</h5><ol>
<li>传输特征 ： 提供了可靠的数据传输，可靠性指数据传输过程中无丢失，无失序，无差错，无重复。</li>
<li>实现手段 ： 在通信前需要建立数据连接，通信结束要正常断开连接。</li>
<li>适用情况 ： 对数据传输准确性有明确要求，传数文件较大，需要确保可靠性的情况。比如：网页获取，文件下载，邮件收发。</li>
</ol>
<blockquote>
<p>三次握手（建立连接）</p>
<blockquote>
<p>客户端向服务器发送消息报文请求连接<br>服务器收到请求后，回复报文确定可以连接<br>客户端收到回复，发送最终报文连接建立</p>
</blockquote>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p>
<blockquote>
<p>四次挥手（断开连接）</p>
<blockquote>
<p>主动方发送报文请求断开连接<br>被动方收到请求后，立即回复，表示准备断开<br>被动方准备就绪，再次发送报文表示可以断开<br>主动方收到确定，发送最终报文完成断开</p>
</blockquote>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p>
<h5 id="2-gt-基于UDP协议的数据传输"><a href="#2-gt-基于UDP协议的数据传输" class="headerlink" title="2 &gt; 基于UDP协议的数据传输"></a>2 &gt; 基于UDP协议的数据传输</h5><ol>
<li>传输特点 ： 不保证传输的可靠性，传输过程没有连接和断开，数据收发自由随意。</li>
<li>适用情况 ： 网络较差，对传输可靠性要求不高。比如：网络视频，群聊，广播</li>
</ol>
<h3 id="16-2-socket套接字编程"><a href="#16-2-socket套接字编程" class="headerlink" title="16.2 socket套接字编程"></a>16.2 socket套接字编程</h3><h4 id="（1）套接字介绍"><a href="#（1）套接字介绍" class="headerlink" title="（1）套接字介绍"></a>（1）套接字介绍</h4><ol>
<li><p>套接字 ： 实现网络编程进行数据传输的一种技术手段</p>
</li>
<li><p>Python实现套接字编程：import  socket</p>
</li>
<li><p>套接字分类</p>
</li>
</ol>
<ul>
<li>流式套接字(<font color="red">SOCK_STREAM</font>): 以<strong>字节流</strong>方式传输数据，实现<strong>TCP</strong>网络传输方案。(面向连接–tcp协议–可靠的–流式套接字)</li>
</ul>
<ul>
<li>数据报套接字(<font color="red">SOCK_DGRAM</font>): 以<strong>数据报</strong>形式传输数据，实现<strong>UDP</strong>网络传输方案。(无连接–udp协议–不可靠–数据报套接字)</li>
</ul>
<h4 id="（2）tcp套接字编程"><a href="#（2）tcp套接字编程" class="headerlink" title="（2）tcp套接字编程"></a>（2）tcp套接字编程</h4><h5 id="1-gt-服务端流程"><a href="#1-gt-服务端流程" class="headerlink" title="1&gt; 服务端流程"></a>1&gt; 服务端流程</h5><p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_TCP_Server.png"></p>
<ol>
<li><strong>创建套接字</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd=socket.socket(socket_family=AF_INET,socket_type=SOCK_STREAM,proto=<span class="number">0</span>)</span><br><span class="line">功能：创建套接字</span><br><span class="line">参数：  </span><br><span class="line">	socket_family  网络地址类型 AF_INET表示ipv4</span><br><span class="line">	socket_type  套接字类型 SOCK_STREAM(流式)  SOCK_DGRAM(数据报式)</span><br><span class="line">	proto  通常为<span class="number">0</span>  选择子协议</span><br><span class="line">返回值： 套接字对象</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>绑定地址</strong></li>
</ol>
<blockquote>
<p>本地地址 ： ‘localhost’ , ‘127.0.0.1’<br>网络地址 ： ‘172.40.91.185’<br>自动获取地址： ‘0.0.0.0’</p>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/address.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.bind(addr)</span><br><span class="line">功能： 绑定本机网络地址</span><br><span class="line">参数： 二元元组 (ip,port)  (<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">8888</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>设置监听</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.listen(n)</span><br><span class="line">功能 ： 将套接字设置为监听套接字，确定监听队列大小</span><br><span class="line">参数 ： 监听队列大小</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>等待处理客户端连接请求</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">connfd,addr = sockfd.accept()</span><br><span class="line">功能： 阻塞等待处理客户端请求</span><br><span class="line">返回值： connfd  客户端连接套接字</span><br><span class="line">         addr  连接的客户端地址</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>消息收发</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = connfd.recv(buffersize)</span><br><span class="line">功能 : 接受客户端消息</span><br><span class="line">参数 ：每次最多接收消息的大小</span><br><span class="line">返回值： 接收到的内容</span><br><span class="line"></span><br><span class="line">n = connfd.send(data)</span><br><span class="line">功能 : 发送消息</span><br><span class="line">参数 ：要发送的内容  <span class="built_in">bytes</span>格式</span><br><span class="line">返回值： 发送的字节数</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>关闭套接字</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.close()</span><br><span class="line">功能：关闭套接字</span><br></pre></td></tr></table></figure>



<h5 id="2-gt-客户端流程"><a href="#2-gt-客户端流程" class="headerlink" title="2&gt; 客户端流程"></a>2&gt; 客户端流程</h5><p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_TCP_Client.png"></p>
<ol>
<li><strong>创建套接字</strong></li>
</ol>
<blockquote>
<p>注意:只有相同类型的套接字才能进行通信</p>
</blockquote>
<ol start="2">
<li><strong>请求连接</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.connect(server_addr)</span><br><span class="line">功能：连接服务器</span><br><span class="line">参数：元组  服务器地址</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>收发消息</strong></li>
</ol>
<blockquote>
<p>注意： 防止两端都阻塞，recv send要配合</p>
</blockquote>
<ol start="4">
<li><strong>关闭套接字</strong></li>
</ol>
<h5 id="3-gt-tcp-套接字数据传输特点"><a href="#3-gt-tcp-套接字数据传输特点" class="headerlink" title="3&gt; tcp 套接字数据传输特点"></a>3&gt; tcp 套接字数据传输特点</h5><ul>
<li><p>tcp连接中当一端退出，另一端如果阻塞在recv，此时recv会立即返回一个空字串。</p>
</li>
<li><p>tcp连接中如果一端已经不存在，仍然试图通过send发送则会产生BrokenPipeError</p>
</li>
<li><p>一个监听套接字可以同时连接多个客户端，也能够重复被连接</p>
</li>
</ul>
<h5 id="4-gt-网络收发缓冲区"><a href="#4-gt-网络收发缓冲区" class="headerlink" title="4&gt; 网络收发缓冲区"></a>4&gt; 网络收发缓冲区</h5><ol>
<li>网络缓冲区有效的协调了消息的收发速度</li>
<li>send和recv实际是向缓冲区发送接收消息，当缓冲区不为空recv就不会阻塞。</li>
</ol>
<h5 id="5-gt-tcp粘包"><a href="#5-gt-tcp粘包" class="headerlink" title="5&gt; tcp粘包"></a>5&gt; tcp粘包</h5><blockquote>
<p>原因：tcp以字节流方式传输，没有消息边界。多次发送的消息被一次接收，此时就会形成粘包。</p>
</blockquote>
<blockquote>
<p>影响：如果每次发送内容是一个独立的含义，需要接收端独立解析此时粘包会有影响。</p>
</blockquote>
<blockquote>
<p>处理方法</p>
<blockquote>
<ol>
<li>人为的添加消息边界</li>
<li>控制发送速度</li>
</ol>
</blockquote>
</blockquote>
<h4 id="（3）UDP套接字编程"><a href="#（3）UDP套接字编程" class="headerlink" title="（3）UDP套接字编程"></a>（3）UDP套接字编程</h4><h5 id="1-gt-服务端流程-1"><a href="#1-gt-服务端流程-1" class="headerlink" title="1&gt; 服务端流程"></a>1&gt; 服务端流程</h5><p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_UDP_Server.png"></p>
<ol>
<li>创建数据报套接字</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd = socket(AF_INET,SOCK_DGRAM)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>绑定地址</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.bind(addr)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>消息收发</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data,addr = sockfd.recvfrom(buffersize)</span><br><span class="line">功能： 接收UDP消息</span><br><span class="line">参数： 每次最多接收多少字节</span><br><span class="line">返回值： data  接收到的内容</span><br><span class="line">	addr  消息发送方地址</span><br><span class="line"></span><br><span class="line">n = sockfd.sendto(data,addr)</span><br><span class="line">功能： 发送UDP消息</span><br><span class="line">参数： data  发送的内容 <span class="built_in">bytes</span>格式</span><br><span class="line">	addr  目标地址</span><br><span class="line">返回值：发送的字节数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>关闭套接字</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure>



<h5 id="2-gt-客户端流程-1"><a href="#2-gt-客户端流程-1" class="headerlink" title="2&gt; 客户端流程"></a>2&gt; 客户端流程</h5><p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_UDP_Client.png"></p>
<ol>
<li>创建套接字</li>
<li>收发消息</li>
<li>关闭套接字</li>
</ol>
<hr>
<blockquote>
<p>总结 ：tcp套接字和udp套接字编程区别</p>
<blockquote>
<ol>
<li>流式套接字是以字节流方式传输数据，数据报套接字以数据报形式传输</li>
<li>tcp套接字会有粘包，udp套接字有消息边界不会粘包</li>
<li>tcp套接字保证消息的完整性，udp套接字则不能</li>
<li>tcp套接字依赖listen accept建立连接才能收发消息，udp套接字则不需要</li>
<li>tcp套接字使用send，recv收发消息，udp套接字使用sendto，recvfrom</li>
</ol>
</blockquote>
</blockquote>
<hr>
<h4 id="（4）socket套接字属性"><a href="#（4）socket套接字属性" class="headerlink" title="（4）socket套接字属性"></a>（4）socket套接字属性</h4><ul>
<li><p>sockfd.type  套接字类型</p>
</li>
<li><p> sockfd.family 套接字地址类型</p>
</li>
<li><p> sockfd.getsockname() 获取套接字绑定地址</p>
</li>
</ul>
<ul>
<li>sockfd.fileno() 获取套接字的文件描述符</li>
</ul>
<ul>
<li>sockfd.getpeername() 获取连接套接字客户端地址</li>
</ul>
<ul>
<li> sockfd.setsockopt(level,option,value)</li>
<li>功能：设置套接字选项</li>
<li>参数： level  选项类别   SOL_SOCKET<pre><code>        option 具体选项内容
              value  选项值
</code></pre>
</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_setsockopt.png"></p>
<h3 id="16-3-struct模块进行数据打包"><a href="#16-3-struct模块进行数据打包" class="headerlink" title="16.3 struct模块进行数据打包"></a>16.3 struct模块进行数据打包</h3><ol>
<li>原理： 将一组简单数据进行打包，转换为bytes格式发送。或者将一组bytes格式数据，进行解析。</li>
<li>接口使用</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Struct(fmt)</span><br><span class="line">功能: 生成结构化对象</span><br><span class="line">参数：fmt  定制的数据结构</span><br><span class="line"></span><br><span class="line">st.pack(v1,v2,v3....)</span><br><span class="line">功能: 将一组数据按照指定格式打包转换为<span class="built_in">bytes</span></span><br><span class="line">参数：要打包的数据</span><br><span class="line">返回值： <span class="built_in">bytes</span>字节串</span><br><span class="line"></span><br><span class="line">st.unpack(bytes_data)</span><br><span class="line">功能： 将<span class="built_in">bytes</span>字节串按照指定的格式解析</span><br><span class="line">参数： 要解析的 <span class="built_in">bytes</span>字节串</span><br><span class="line">返回值： 解析后的内容</span><br><span class="line"></span><br><span class="line">struct.pack(fmt,v1,v2,v3...)</span><br><span class="line">struct.unpack(fmt,bytes_data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明： 可以使用struct模块直接调用pack unpack。此时这两函数第一个参数传入fmt。其他用法功能相同</p>
</blockquote>
<h3 id="16-4-HTTP传输"><a href="#16-4-HTTP传输" class="headerlink" title="16.4 HTTP传输"></a>16.4 HTTP传输</h3><h4 id="（1）HTTP协议-（超文本传输协议）"><a href="#（1）HTTP协议-（超文本传输协议）" class="headerlink" title="（1）HTTP协议 （超文本传输协议）"></a>（1）HTTP协议 （超文本传输协议）</h4><ol>
<li><p>用途 ： 网页获取，数据的传输</p>
</li>
<li><p>特点</p>
</li>
</ol>
<blockquote>
<ul>
<li>应用层协议，传输层使用<strong>tcp</strong>传输</li>
<li>简单，灵活，很多语言都有HTTP专门接口</li>
<li>无状态，协议不记录传输内容</li>
<li>http1.1 支持持久连接，丰富了请求类型</li>
</ul>
</blockquote>
<ol start="3">
<li>网页请求过程</li>
</ol>
<blockquote>
<p>1.客户端（浏览器）通过tcp传输，发送http请求给服务端<br>2.服务端接收到http请求后进行解析<br>3.服务端处理请求内容，组织响应内容<br>4.服务端将响应内容以http响应格式发送给浏览器<br>5.浏览器接收到响应内容，解析展示</p>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE.png"></p>
<h4 id="（2）HTTP请求（request）"><a href="#（2）HTTP请求（request）" class="headerlink" title="（2）HTTP请求（request）"></a>（2）HTTP请求（request）</h4><ul>
<li>请求行 ： 具体的请求类别和请求内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET         /        HTTP/1.1</span><br><span class="line">请求类别   请求内容     协议版本</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求类别：每个请求类别表示要做不同的事情 </span><br><span class="line">		GET : 获取网络资源</span><br><span class="line">		POST ：提交一定的信息，得到反馈</span><br><span class="line">		HEAD ： 只获取网络资源的响应头</span><br><span class="line">		PUT ： 更新服务器资源</span><br><span class="line">		DELETE ： 删除服务器资源</span><br><span class="line">		CONNECT</span><br><span class="line">		TRACE ： 测试</span><br><span class="line">		OPTIONS ： 获取服务器性能信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>请求头：对请求的进一步解释和描述</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip</span><br></pre></td></tr></table></figure>

<ul>
<li>空行</li>
<li>请求体: 请求参数或者提交内容</li>
</ul>
<h4 id="（3）http响应（response）"><a href="#（3）http响应（response）" class="headerlink" title="（3）http响应（response）"></a>（3）http响应（response）</h4><ol>
<li>响应格式：响应行，响应头，空行，响应体</li>
</ol>
<ul>
<li>响应行 ： 反馈基本的响应情况</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1     200       OK</span><br><span class="line">版本信息    响应码   附加信息</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">响应码 ： </span><br><span class="line">	1xx  提示信息，表示请求被接收</span><br><span class="line">	2xx  响应成功</span><br><span class="line">	3xx  响应需要进一步操作，重定向</span><br><span class="line">	4xx  客户端错误</span><br><span class="line">	5xx  服务器错误</span><br></pre></td></tr></table></figure>

<ul>
<li>响应头：对响应内容的描述</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>

<ul>
<li>响应体：响应的主体内容信息</li>
</ul>
<h2 id="17-并发编程"><a href="#17-并发编程" class="headerlink" title="17. 并发编程"></a>17. 并发编程</h2><h3 id="17-1-多任务编程"><a href="#17-1-多任务编程" class="headerlink" title="17.1 多任务编程"></a>17.1 多任务编程</h3><ol>
<li>意义： 充分利用计算机CPU的多核资源，同时处理多个应用程序任务，以此提高程序的运行效率。</li>
<li>实现方案 ：多进程 ， 多线程</li>
</ol>
<h3 id="17-2-进程（process）"><a href="#17-2-进程（process）" class="headerlink" title="17.2 进程（process）"></a>17.2 进程（process）</h3><h4 id="（1）进程理论基础"><a href="#（1）进程理论基础" class="headerlink" title="（1）进程理论基础"></a>（1）进程理论基础</h4><ol>
<li><h5 id="定义-：-程序在计算机中的一次运行。"><a href="#定义-：-程序在计算机中的一次运行。" class="headerlink" title="定义 ： 程序在计算机中的一次运行。"></a>定义 ： 程序在计算机中的一次运行。</h5><ul>
<li>程序是一个可执行的文件，是静态的占有磁盘。</li>
<li>进程是一个动态的过程描述，占有计算机运行资源，有一定的生命周期。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><h5 id="系统中如何产生一个进程"><a href="#系统中如何产生一个进程" class="headerlink" title="系统中如何产生一个进程"></a>系统中如何产生一个进程</h5><p>【1】 用户空间通过调用程序接口或者命令发起请求<br>【2】 操作系统接收用户请求，开始创建进程<br>【3】 操作系统调配计算机资源，确定进程状态等<br>【4】 操作系统将创建的进程提供给用户使用</p>
</li>
</ol>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux.png"></p>
<ol start="3">
<li><h5 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h5></li>
</ol>
<ul>
<li><p>cpu时间片：如果一个进程占有<strong>cpu内核</strong>则称这个进程在cpu时间片上。</p>
</li>
<li><p>PCB(进程控制块)：在内存中开辟的一块空间，用于存放<strong>进程的基本信息</strong>，也用于系统查找识别进程。</p>
</li>
<li><p>进程ID（PID）： 系统为每个进程分配的一个大于0的整数，作为进程ID。每个进程ID不重复。</p>
<blockquote>
<p>Linux查看进程ID ： ps -aux</p>
</blockquote>
</li>
<li><p>父子进程 ： 系统中每一个进程(除了系统初始化进程)都有唯一的父进程，可以有0个或多个子进程。父子进程关系便于进程管理。</p>
<blockquote>
<p>查看进程树： pstree</p>
</blockquote>
</li>
<li><p>进程状态</p>
<ul>
<li>三态<br>就绪态 ： 进程具备执行条件，等待分配cpu资源<br>运行态 ： 进程占有cpu时间片正在运行<br>等待态 ： 进程暂时停止运行，让出cpu</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4_3%E6%80%81.png"></p>
<ul>
<li>五态 (在三态基础上增加新建和终止)<br>新建 ： 创建一个进程，获取资源的过程<br>终止 ： 进程结束，释放资源的过程</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4_5%E6%80%81.png"></p>
<ul>
<li>状态查看命令 ： ps -aux  –&gt; STAT列</li>
</ul>
<blockquote>
<pre><code>           S 等待态
           R 执行态
           Z 僵尸

           \+ 前台进程
           l   有多线程的
</code></pre>
</blockquote>
<ul>
<li>进程的运行特征<br>【1】 多进程可以更充分使用计算机多核资源<br>【2】 进程之间的运行互不影响，各自独立<br>【3】 每个进程拥有独立的空间，各自使用自己空间资源</li>
</ul>
<h3 id="17-3-基于fork的多进程编程"><a href="#17-3-基于fork的多进程编程" class="headerlink" title="17.3 基于fork的多进程编程"></a>17.3 基于fork的多进程编程</h3><h4 id="（1）fork使用"><a href="#（1）fork使用" class="headerlink" title="（1）fork使用"></a>（1）fork使用</h4><blockquote>
<p>pid = os.fork()<br>    功能： 创建新的进程<br>    返回值：整数，如果创建进程失败返回一个负数，如果成功则在原有进程中返回新进程的PID，在新进程中返回0</p>
</blockquote>
<blockquote>
<p>注意</p>
<blockquote>
<ul>
<li>子进程会复制父进程全部内存空间，从fork下一句开始执行。</li>
<li>父子进程各自独立运行，运行顺序不一定。</li>
<li>利用父子进程fork返回值的区别，配合if结构让父子进程执行不同的内容几乎是固定搭配。</li>
<li>父子进程有各自特有特征比如PID PCB 命令集等。</li>
<li>父进程fork之前开辟的空间子进程同样拥有，父子进程对各自空间的操作不会相互影响。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="（2）进程相关函数"><a href="#（2）进程相关函数" class="headerlink" title="（2）进程相关函数"></a>（2）进程相关函数</h4><blockquote>
<p>os.getpid()<br>       功能： 获取一个进程的PID值<br>       返回值： 返回当前进程的PID </p>
</blockquote>
<blockquote>
<p>os.getppid()<br>       功能： 获取父进程的PID号<br>       返回值： 返回父进程PID</p>
</blockquote>
<blockquote>
<p>os._exit(status)<br>       功能: 结束一个进程<br>       参数：进程的终止状态</p>
</blockquote>
<blockquote>
<p>sys.exit([status])<br>       功能：退出进程<br>       参数：整数 表示退出状态<br>                   字符串 表示退出时打印内容</p>
</blockquote>
<h4 id="（3）孤儿和僵尸"><a href="#（3）孤儿和僵尸" class="headerlink" title="（3）孤儿和僵尸"></a>（3）孤儿和僵尸</h4><ol>
<li>孤儿进程 ： 父进程先于子进程退出，此时子进程成为孤儿进程。</li>
</ol>
<blockquote>
<p>特点： 孤儿进程会被系统进程收养，此时系统进程就会成为孤儿进程新的父进程，孤儿进程退出该进程会自动处理。</p>
</blockquote>
<ol start="2">
<li>僵尸进程 ： 子进程先于父进程退出，父进程又没有处理子进程的退出状态，此时子进程就会称为僵尸进程。</li>
</ol>
<blockquote>
<p>特点： 僵尸进程虽然结束，但是会存留部分PCB在内存中，大量的僵尸进程会浪费系统的内存资源。</p>
</blockquote>
<ol start="3">
<li>如何避免僵尸进程产生</li>
</ol>
<ul>
<li>使用wait函数处理子进程退出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pid,status = os.wait()</span><br><span class="line">功能：在父进程中阻塞等待处理子进程退出</span><br><span class="line">返回值： pid  退出的子进程的PID</span><br><span class="line">		status  子进程退出状态</span><br></pre></td></tr></table></figure>


<ul>
<li><p>创建二级子进程处理僵尸</p>
<p>【1】 父进程创建子进程，等待回收子进程<br>【2】 子进程创建二级子进程然后退出<br>【3】 二级子进程称为孤儿，和原来父进程一同执行事件</p>
</li>
</ul>
<ul>
<li><p>通过信号处理子进程退出</p>
<blockquote>
<p>原理： 子进程退出时会发送信号给父进程，如果父进程忽略子进程信号，则系统就会自动处理子进程退出。</p>
</blockquote>
<blockquote>
<p>方法： 使用signal模块在父进程创建子进程前写如下语句 ：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> signal</span><br><span class="line">signal.signal(signal.SIGCHLD,signal.SIG_IGN)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点 ： 非阻塞，不会影响父进程运行。可以处理所有子进程退出</p>
</blockquote>
</li>
</ul>
<h4 id="（4）群聊聊天室"><a href="#（4）群聊聊天室" class="headerlink" title="（4）群聊聊天室"></a>（4）群聊聊天室</h4><blockquote>
<p>功能 ： 类似qq群功能<br>【1】 有人进入聊天室需要输入姓名，姓名不能重复<br>【2】 有人进入聊天室时，其他人会收到通知：xxx 进入了聊天室<br>【3】 一个人发消息，其他人会收到：xxx ： xxxxxxxxxxx<br>【4】 有人退出聊天室，则其他人也会收到通知:xxx退出了聊天室<br>【5】 扩展功能：服务器可以向所有用户发送公告:管理员消息： xxxxxxxxx</p>
</blockquote>
<h3 id="17-4-multiprocessing-模块创建进程"><a href="#17-4-multiprocessing-模块创建进程" class="headerlink" title="17.4 multiprocessing 模块创建进程"></a>17.4 multiprocessing 模块创建进程</h3><h4 id="（1）进程创建方法"><a href="#（1）进程创建方法" class="headerlink" title="（1）进程创建方法"></a>（1）进程创建方法</h4><ol>
<li><h5 id="流程特点"><a href="#流程特点" class="headerlink" title="流程特点"></a>流程特点</h5><p> 【1】 将需要子进程执行的事件封装为函数<br> 【2】 通过模块的Process类创建进程对象，关联函数<br> 【3】 可以通过进程对象设置进程信息及属性<br> 【4】 通过进程对象调用start启动进程<br> 【5】 通过进程对象调用join回收进程</p>
</li>
<li><h5 id="基本接口使用"><a href="#基本接口使用" class="headerlink" title="基本接口使用"></a>基本接口使用</h5></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Process()</span><br><span class="line">功能 ： 创建进程对象</span><br><span class="line">参数 ： target 绑定要执行的目标函数 </span><br><span class="line">	args 元组，用于给target函数位置传参</span><br><span class="line">	kwargs 字典，给target函数键值传参</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.start()</span><br><span class="line">功能 ： 启动进程</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:启动进程此时target绑定函数开始执行，该函数作为子进程执行内容，此时进程真正被创建</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.join([timeout])</span><br><span class="line">功能：阻塞等待回收进程</span><br><span class="line">参数：超时时间</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<blockquote>
<ul>
<li>使用multiprocessing创建进程同样是子进程复制父进程空间代码段，父子进程运行互不影响。</li>
<li>子进程只运行target绑定的函数部分，其余内容均是父进程执行内容。</li>
<li>multiprocessing中父进程往往只用来创建子进程、回收子进程，具体事件由子进程完成。</li>
<li>multiprocessing创建的子进程中无法使用标准输入</li>
</ul>
</blockquote>
</blockquote>
<ol start="3">
<li><h5 id="进程对象属性"><a href="#进程对象属性" class="headerlink" title="进程对象属性"></a>进程对象属性</h5></li>
</ol>
<blockquote>
<p>p.name  进程名称</p>
</blockquote>
<blockquote>
<p>p.pid   对应子进程的PID号</p>
</blockquote>
<blockquote>
<p>p.is_alive() 查看子进程是否在生命周期</p>
</blockquote>
<blockquote>
<p>p.daemon  设置父子进程的退出关系  </p>
<blockquote>
<ul>
<li>如果设置为True则子进程会随父进程的退出而结束</li>
<li>要求必须在start()前设置</li>
<li>如果daemon设置成True 通常就不会使用 join()</li>
</ul>
</blockquote>
</blockquote>
<h4 id="（2）自定义进程类"><a href="#（2）自定义进程类" class="headerlink" title="（2）自定义进程类"></a>（2）自定义进程类</h4><ol>
<li><h5 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h5><p>【1】 继承Process类<br>【2】 重写<code>__init__</code>方法添加自己的属性，使用super()加载父类属性<br>【3】 重写run()方法</p>
</li>
<li><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>【1】 实例化对象<br>【2】 调用start自动执行run方法<br>【3】 调用join回收进程</p>
</li>
</ol>
<h4 id="（3）进程池实现"><a href="#（3）进程池实现" class="headerlink" title="（3）进程池实现"></a>（3）进程池实现</h4><ol>
<li><h5 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h5><p>   【1】 进程的创建和销毁过程消耗的资源较多<br>   【2】 当任务量众多，每个任务在很短时间内完成时，需要频繁的创建和销毁进程。此时对计算机压力较大<br>   【3】 进程池技术很好的解决了以上问题。</p>
</li>
<li><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5></li>
</ol>
<blockquote>
<p>创建一定数量的进程来处理事件，事件处理完进程不退出而是继续处理其他事件，直到所有事件全都处理完毕统一销毁。增加进程的重复利用，降低资源消耗。</p>
</blockquote>
<ol start="3">
<li><h5 id="进程池实现过程"><a href="#进程池实现过程" class="headerlink" title="进程池实现过程"></a>进程池实现过程</h5></li>
</ol>
<p>【1】 创建进程池对象，放入适当的进程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line">Pool(processes)</span><br><span class="line">功能： 创建进程池对象</span><br><span class="line">参数： 指定进程数量，默认根据系统自动判定</span><br></pre></td></tr></table></figure>

<p>【2】 将事件加入进程池队列执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool.apply_async(func,args,kwds)</span><br><span class="line">功能: 使用进程池执行func事件</span><br><span class="line">参数： func 事件函数</span><br><span class="line">      args 元组  给func按位置传参</span><br><span class="line">      kwds 字典  给func按照键值传参</span><br><span class="line">返回值： 返回函数事件对象</span><br></pre></td></tr></table></figure>

<p>【3】 关闭进程池</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool.close()</span><br><span class="line">功能： 关闭进程池</span><br></pre></td></tr></table></figure>

<p>【4】 回收进程池中进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pool.join()</span><br><span class="line">功能： 回收进程池中进程</span><br></pre></td></tr></table></figure>



<h3 id="17-5-进程间通信（IPC）"><a href="#17-5-进程间通信（IPC）" class="headerlink" title="17.5 进程间通信（IPC）"></a>17.5 进程间通信（IPC）</h3><ol>
<li>必要性： 进程间<strong>空间独立，资源不共享</strong>，此时在需要进程间数据传输时就需要特定的手段进行数据通信。</li>
</ol>
<ol start="2">
<li>常用进程间通信方法</li>
</ol>
<blockquote>
<p>管道  消息队列  共享内存  信号  信号量  套接字 </p>
</blockquote>
<h4 id="（1）管道通信-Pipe"><a href="#（1）管道通信-Pipe" class="headerlink" title="（1）管道通信(Pipe)"></a>（1）管道通信(Pipe)</h4><ol>
<li><h5 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h5></li>
</ol>
<blockquote>
<p>在内存中开辟管道空间，生成管道操作对象，多个进程使用同一个管道对象进行读写即可实现通信</p>
</blockquote>
<ol start="2">
<li><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  multiprocessing <span class="keyword">import</span> Pipe</span><br><span class="line"></span><br><span class="line">fd1,fd2 = Pipe(duplex = <span class="literal">True</span>)</span><br><span class="line">功能: 创建管道</span><br><span class="line">参数：默认表示双向管道</span><br><span class="line">如果为<span class="literal">False</span> 表示单向管道</span><br><span class="line">返回值：表示管道两端的读写对象</span><br><span class="line">	  如果是双向管道均可读写</span><br><span class="line">	  如果是单向管道fd1只读  fd2只写</span><br><span class="line"></span><br><span class="line">fd.recv()</span><br><span class="line">功能 ： 从管道获取内容</span><br><span class="line">返回值：获取到的数据</span><br><span class="line"></span><br><span class="line">fd.send(data)</span><br><span class="line">功能： 向管道写入内容</span><br><span class="line">参数： 要写入的数据</span><br></pre></td></tr></table></figure>



<h4 id="（2）消息队列"><a href="#（2）消息队列" class="headerlink" title="（2）消息队列"></a>（2）消息队列</h4><ol>
<li>通信原理</li>
</ol>
<blockquote>
<p>在内存中建立队列模型，进程通过队列将消息存入，或者从队列取出完成进程间通信。</p>
</blockquote>
<ol start="2">
<li>实现方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = Queue(maxsize=<span class="number">0</span>)</span><br><span class="line">功能: 创建队列对象</span><br><span class="line">参数：最多存放消息个数</span><br><span class="line">返回值：队列对象</span><br><span class="line"></span><br><span class="line">q.put(data,[block,timeout])</span><br><span class="line">功能：向队列存入消息</span><br><span class="line">参数：data  要存入的内容</span><br><span class="line">block  设置是否阻塞 <span class="literal">False</span>为非阻塞</span><br><span class="line">timeout  超时检测</span><br><span class="line"></span><br><span class="line">q.get([block,timeout])</span><br><span class="line">功能：从队列取出消息</span><br><span class="line">参数：block  设置是否阻塞 <span class="literal">False</span>为非阻塞</span><br><span class="line">timeout  超时检测</span><br><span class="line">返回值： 返回获取到的内容</span><br><span class="line"></span><br><span class="line">q.full()   判断队列是否为满</span><br><span class="line">q.empty()  判断队列是否为空</span><br><span class="line">q.qsize()  获取队列中消息个数</span><br><span class="line">q.close()  关闭队列</span><br></pre></td></tr></table></figure>



<h4 id="（3）共享内存"><a href="#（3）共享内存" class="headerlink" title="（3）共享内存"></a>（3）共享内存</h4><ol>
<li><h5 id="通信原理："><a href="#通信原理：" class="headerlink" title="通信原理："></a>通信原理：</h5><p>在内中开辟一块空间，进程可以写入内容和读取内容完成通信，但是每次写入内容会覆盖之前内容。</p>
</li>
<li><h5 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h5></li>
</ol>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6_ctype.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Value,Array</span><br><span class="line"></span><br><span class="line">obj = Value(ctype,data)</span><br><span class="line">功能 ： 开辟共享内存</span><br><span class="line">参数 ： ctype  表示共享内存空间类型 <span class="string">&#x27;i&#x27;</span>  <span class="string">&#x27;f&#x27;</span>  <span class="string">&#x27;c&#x27;</span></span><br><span class="line">       data   共享内存空间初始数据</span><br><span class="line">返回值：共享内存对象</span><br><span class="line"></span><br><span class="line">obj.value  对该属性的修改查看即对共享内存读写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Array(ctype,data)</span><br><span class="line">功能： 开辟共享内存空间</span><br><span class="line">参数： ctype  表示共享内存数据类型</span><br><span class="line">      data   整数则表示开辟空间的大小，其他数据类型表示开辟空间存放的初始化数据</span><br><span class="line">返回值：共享内存对象</span><br><span class="line"></span><br><span class="line">Array共享内存读写： 通过遍历obj可以得到每个值，直接可以通过索引序号修改任意值。</span><br><span class="line"></span><br><span class="line">* 可以使用obj.value直接打印共享内存中的字节串</span><br></pre></td></tr></table></figure>



<h4 id="（4）信号量（信号灯集）"><a href="#（4）信号量（信号灯集）" class="headerlink" title="（4）信号量（信号灯集）"></a>（4）信号量（信号灯集）</h4><ol>
<li>通信原理</li>
</ol>
<blockquote>
<p>给定一个数量对多个进程可见。多个进程都可以操作该数量增减，并根据数量值决定自己的行为。</p>
</blockquote>
<ol start="2">
<li>实现方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Semaphore</span><br><span class="line"></span><br><span class="line">sem = Semaphore(num)</span><br><span class="line">功能 ： 创建信号量对象</span><br><span class="line">参数 ： 信号量的初始值</span><br><span class="line">返回值 ： 信号量对象</span><br><span class="line"></span><br><span class="line">sem.acquire()  将信号量减<span class="number">1</span> 当信号量为<span class="number">0</span>时阻塞</span><br><span class="line">sem.release()  将信号量加<span class="number">1</span></span><br><span class="line">sem.get_value() 获取信号量数量</span><br></pre></td></tr></table></figure>



<h3 id="17-6-线程编程（Thread）"><a href="#17-6-线程编程（Thread）" class="headerlink" title="17.6 线程编程（Thread）"></a>17.6 线程编程（Thread）</h3><h4 id="（1）线程基本概念"><a href="#（1）线程基本概念" class="headerlink" title="（1）线程基本概念"></a>（1）线程基本概念</h4><ol>
<li><p>什么是线程<br>【1】 线程被称为轻量级的进程<br>【2】 线程也可以使用计算机多核资源，是多任务编程方式<br>【3】 线程是系统分配内核的最小单元<br>【4】 线程可以理解为<strong>进程的分支任务</strong></p>
</li>
<li><p>线程特征<br>【1】 一个进程中可以包含多个线程<br>【2】 线程也是一个运行行为，消耗计算机资源<br>【3】 一个进程中的所有线程<strong>共享这个进程的资源</strong><br>【4】 多个线程之间的运行互不影响各自运行<br>【5】 线程的创建和销毁消耗资源远小于进程<br>【6】 各个线程也有自己的ID等特征</p>
</li>
</ol>
<h4 id="（2）threading模块创建线程"><a href="#（2）threading模块创建线程" class="headerlink" title="（2）threading模块创建线程"></a>（2）threading模块创建线程</h4><p>【1】 创建线程对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Thread </span><br><span class="line"></span><br><span class="line">t = Thread()</span><br><span class="line">功能：创建线程对象</span><br><span class="line">参数：target 绑定线程函数</span><br><span class="line">     args   元组 给线程函数位置传参</span><br><span class="line">     kwargs 字典 给线程函数键值传参</span><br></pre></td></tr></table></figure>

<p>【2】 启动线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<p>【3】 回收线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.join([timeout])</span><br></pre></td></tr></table></figure>



<h4 id="（3）线程对象属性"><a href="#（3）线程对象属性" class="headerlink" title="（3）线程对象属性"></a>（3）线程对象属性</h4><blockquote>
<p>t.name 线程名称<br>t.setName()  设置线程名称<br>t.getName()  获取线程名称</p>
</blockquote>
<blockquote>
<p>t.is_alive()  查看线程是否在生命周期</p>
</blockquote>
<blockquote>
<p>t.daemon  设置主线程和分支线程的退出关系<br>t.setDaemon()  设置daemon属性值<br>t.isDaemon()  查看daemon属性值</p>
<blockquote>
<p>daemon为True时主线程退出分支线程也退出。要在start前设置，通常不和join一起使用。</p>
</blockquote>
</blockquote>
<h4 id="（4）自定义线程类"><a href="#（4）自定义线程类" class="headerlink" title="（4）自定义线程类"></a>（4）自定义线程类</h4><ol>
<li><p>创建步骤<br>【1】 继承Thread类<br>【2】 重写<code>__init__</code>方法添加自己的属性，使用super()加载父类属性<br>【3】 重写run()方法</p>
</li>
<li><p>使用方法<br>【1】 实例化对象<br>【2】 调用start自动执行run方法<br>【3】 调用join回收线程</p>
</li>
</ol>
<h3 id="17-7-同步互斥"><a href="#17-7-同步互斥" class="headerlink" title="17.7 同步互斥"></a>17.7 同步互斥</h3><h4 id="（1）线程间通信方法"><a href="#（1）线程间通信方法" class="headerlink" title="（1）线程间通信方法"></a>（1）线程间通信方法</h4><ol>
<li>通信方法</li>
</ol>
<blockquote>
<p>线程间使用全局变量进行通信</p>
</blockquote>
<ol start="2">
<li>共享资源争夺</li>
</ol>
<ul>
<li><p>共享资源：多个进程或者线程都可以操作的资源称为共享资源。对共享资源的操作代码段称为<strong>临界区</strong>。</p>
</li>
<li><p>影响 ： 对共享资源的无序操作可能会带来数据的混乱，或者操作错误。此时往往<strong>需要同步互斥机制协调操作顺序</strong>。</p>
</li>
</ul>
<ol start="3">
<li>同步互斥机制</li>
</ol>
<blockquote>
<p>同步 ： 同步是一种协作关系，为完成操作，多进程或者线程间形成一种协调，<strong>按照必要的步骤有序执行操作</strong>。</p>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7_%E5%90%8C%E6%AD%A5.png"></p>
<blockquote>
<p>互斥 ： 互斥是一种制约关系，当一个进程或者线程<strong>占有资源时会进行加锁处理</strong>，此时其他进程线程就无法操作该资源，直到解锁后才能操作。</p>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7_%E4%BA%92%E6%96%A5.png"></p>
<h4 id="（2）线程同步互斥方法"><a href="#（2）线程同步互斥方法" class="headerlink" title="（2）线程同步互斥方法"></a>（2）线程同步互斥方法</h4><h5 id="1-gt-线程Event"><a href="#1-gt-线程Event" class="headerlink" title="1&gt; 线程Event"></a>1&gt; 线程Event</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event</span><br><span class="line"></span><br><span class="line">e = Event()  创建线程event对象</span><br><span class="line"></span><br><span class="line">e.wait([timeout])  阻塞等待e被<span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">e.<span class="built_in">set</span>()  设置e，使wait结束阻塞</span><br><span class="line"></span><br><span class="line">e.clear() 使e回到未被设置状态</span><br><span class="line"></span><br><span class="line">e.is_set()  查看当前e是否被设置</span><br></pre></td></tr></table></figure>

<h5 id="2-gt-线程锁-Lock"><a href="#2-gt-线程锁-Lock" class="headerlink" title="2&gt; 线程锁 Lock"></a>2&gt; 线程锁 Lock</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line">lock = Lock()  创建锁对象</span><br><span class="line">lock.acquire() 上锁  如果lock已经上锁再调用会阻塞</span><br><span class="line">lock.release() 解锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>  lock:  上锁</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">	 <span class="keyword">with</span>代码块结束自动解锁</span><br></pre></td></tr></table></figure>



<h4 id="（3）死锁及其处理"><a href="#（3）死锁及其处理" class="headerlink" title="（3）死锁及其处理"></a>（3）死锁及其处理</h4><ol>
<li><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5></li>
</ol>
<blockquote>
<p>死锁是指两个或两个以上的线程在执行过程中，由于<strong>竞争资源或者由于彼此通信</strong>而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%AD%BB%E9%94%81.jpg"></p>
<ol start="2">
<li><h5 id="死锁产生条件"><a href="#死锁产生条件" class="headerlink" title="死锁产生条件"></a>死锁产生条件</h5></li>
</ol>
<blockquote>
<p>死锁发生的必要条件</p>
<blockquote>
<ul>
<li><font color="red">互斥条件</font>：指线程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li><font color="red">请求和保持条件</font>：指线程已经保持至少一个资源，但又提出了新的资源<strong>请求</strong>，而该资源已被其它进程占有，此时请求线程阻塞，但又对自己已获得的其它资源<strong>保持不放</strong>。</li>
<li><font color="red">不剥夺条件</font>：指线程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放,通常CPU内存资源是可以被系统强行调配剥夺的。</li>
<li><font color="red">环路等待条件</font>：指在发生死锁时，必然存在一个线程——资源的环形链，即进程集合{T0，T1，T2，···，Tn}中的T0正在等待一个T1占用的资源；T1正在等待T2占用的资源，……，Tn正在等待已被T0占用的资源。</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p>死锁的产生原因</p>
<blockquote>
<p>简单来说造成死锁的原因可以概括成三句话：</p>
<ul>
<li>当前线程拥有其他线程需要的资源</li>
<li>当前线程等待其他线程已拥有的资源</li>
<li>都不放弃自己拥有的资源</li>
</ul>
</blockquote>
</blockquote>
<ol start="3">
<li><p>如何避免死锁</p>
<p>死锁是我们非常不愿意看到的一种现象，我们要尽可能<strong>避免死锁</strong>的情况发生。通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率。</p>
</li>
</ol>
<h3 id="17-8-python线程GIL"><a href="#17-8-python线程GIL" class="headerlink" title="17.8 python线程GIL"></a>17.8 python线程GIL</h3><ol>
<li>python线程的GIL问题 （全局解释器锁）</li>
</ol>
<blockquote>
<p>什么是GIL ：由于python解释器设计中加入了解释器锁，导致python解释器同一时刻只能解释执行一个线程，大大降低了线程的执行效率。</p>
</blockquote>
<blockquote>
<p>导致后果： 因为遇到阻塞时线程会主动让出解释器，去解释其他线程。所以python多线程在执行<strong>多阻塞高延迟IO</strong>时可以提升程序效率，其他情况并不能对效率有所提升。</p>
</blockquote>
<blockquote>
<p>GIL问题建议</p>
<ul>
<li>尽量使用进程完成无阻塞的并发行为</li>
<li>不使用c作为解释器 （Java  C#）</li>
</ul>
</blockquote>
<ol start="2">
<li>结论 ： 在无阻塞状态下，多线程程序和单线程程序执行效率几乎差不多，甚至还不如单线程效率。但是多进程运行相同内容却可以有明显的效率提升。</li>
</ol>
<h3 id="17-9-进程线程的区别联系"><a href="#17-9-进程线程的区别联系" class="headerlink" title="17.9 进程线程的区别联系"></a>17.9 进程线程的区别联系</h3><h4 id="（1）区别联系"><a href="#（1）区别联系" class="headerlink" title="（1）区别联系"></a>（1）区别联系</h4><ol>
<li>两者都是多任务编程方式，都能使用计算机多核资源</li>
<li>进程的创建删除消耗的计算机资源比线程多</li>
<li>进程空间独立，数据互不干扰，有专门通信方法；线程使用全局变量通信</li>
<li>一个进程可以有多个分支线程，两者有包含关系</li>
<li>多个线程共享进程资源，在共享资源操作时往往需要同步互斥处理</li>
<li>进程线程在系统中都有自己的特有属性标志，如ID,代码段，命令集等。</li>
</ol>
<h4 id="（2）使用场景"><a href="#（2）使用场景" class="headerlink" title="（2）使用场景"></a>（2）使用场景</h4><ol>
<li><p>任务场景：如果是相对独立的任务模块，可能使用多进程，如果是多个分支共同形成一个整体任务可能用多线程</p>
</li>
<li><p>项目结构：多种编程语言实现不同任务模块，可能是多进程，或者前后端分离应该各自为一个进程。</p>
</li>
<li><p>难易程度：通信难度，数据处理的复杂度来判断用进程间通信还是同步互斥方法。</p>
</li>
</ol>
<h4 id="（3）要求"><a href="#（3）要求" class="headerlink" title="（3）要求"></a>（3）要求</h4><ol>
<li>对进程线程怎么理解/说说进程线程的差异</li>
<li>进程间通信知道哪些，有什么特点</li>
<li>什么是同步互斥，你什么情况下使用，怎么用</li>
<li>给一个情形，说说用进程还是线程，为什么</li>
<li>问一些概念，僵尸进程的处理，GIL问题，进程状态</li>
</ol>
<h3 id="17-10-并发网络通信模型"><a href="#17-10-并发网络通信模型" class="headerlink" title="17.10 并发网络通信模型"></a>17.10 并发网络通信模型</h3><h4 id="（1）常见网络模型"><a href="#（1）常见网络模型" class="headerlink" title="（1）常见网络模型"></a>（1）常见网络模型</h4><ol>
<li>循环服务器模型 ：循环接收客户端请求，处理请求。同一时刻只能处理一个请求，处理完毕后再处理下一个。</li>
</ol>
<blockquote>
<p>优点：实现简单，占用资源少<br>缺点：无法同时处理多个客户端请求</p>
</blockquote>
<blockquote>
<p>适用情况：处理的任务可以很快完成，客户端无需长期占用服务端程序。udp比tcp更适合循环。</p>
</blockquote>
<ol start="2">
<li>多进程/线程网络并发模型：每当一个客户端连接服务器，就创建一个新的进程/线程为该客户端服务，客户端退出时再销毁该进程/线程。</li>
</ol>
<blockquote>
<p>优点：能同时满足多个客户端长期占有服务端需求，可以处理各种请求。<br>缺点： 资源消耗较大</p>
</blockquote>
<blockquote>
<p>适用情况：客户端同时连接量较少，需要处理行为较复杂情况。</p>
</blockquote>
<ol start="3">
<li><p>IO并发模型：利用IO多路复用,异步IO等技术，同时处理多个客户端IO请求。</p>
<blockquote>
<p>优点 ： 资源消耗少，能同时高效处理多个IO行为<br>缺点 ： 只能处理并发产生的IO事件，无法处理cpu计算</p>
</blockquote>
<blockquote>
<p>适用情况：HTTP请求，网络传输等都是IO行为。</p>
</blockquote>
</li>
</ol>
<h4 id="（2）基于fork的多进程网络并发模型"><a href="#（2）基于fork的多进程网络并发模型" class="headerlink" title="（2）基于fork的多进程网络并发模型"></a>（2）基于fork的多进程网络并发模型</h4><p>​    <strong>实现步骤</strong></p>
<ol>
<li>创建监听套接字</li>
<li>等待接收客户端请求</li>
<li>客户端连接创建新的进程处理客户端请求</li>
<li>原进程继续等待其他客户端连接</li>
<li>如果客户端退出，则销毁对应的进程</li>
</ol>
<h4 id="（3）基于threading的多线程网络并发"><a href="#（3）基于threading的多线程网络并发" class="headerlink" title="（3）基于threading的多线程网络并发"></a>（3）基于threading的多线程网络并发</h4><p>​    <strong>实现步骤</strong></p>
<ol>
<li>创建监听套接字</li>
<li>循环接收客户端连接请求</li>
<li>当有新的客户端连接创建线程处理客户端请求</li>
<li>主线程继续等待其他客户端连接</li>
<li>当客户端退出，则对应分支线程退出</li>
</ol>
<h4 id="（4）ftp-文件服务器"><a href="#（4）ftp-文件服务器" class="headerlink" title="（4）ftp 文件服务器"></a>（4）ftp 文件服务器</h4><ol>
<li>功能<br>【1】 分为服务端和客户端，要求可以有多个客户端同时操作。<br>【2】 客户端可以查看服务器文件库中有什么文件。<br>【3】 客户端可以从文件库中下载文件到本地。<br>【4】 客户端可以上传一个本地文件到文件库。<br>【5】 使用print在客户端打印命令输入提示，引导操作</li>
</ol>
<h3 id="17-11-IO并发"><a href="#17-11-IO并发" class="headerlink" title="17.11 IO并发"></a>17.11 IO并发</h3><h4 id="（1）IO-分类"><a href="#（1）IO-分类" class="headerlink" title="（1）IO 分类"></a>（1）IO 分类</h4><blockquote>
<p>IO分类：阻塞IO ，非阻塞IO，IO多路复用，异步IO等</p>
</blockquote>
<h5 id="1-gt-阻塞IO"><a href="#1-gt-阻塞IO" class="headerlink" title="1&gt; 阻塞IO"></a>1&gt; 阻塞IO</h5><ol>
<li><p>定义：在执行IO操作时如果执行条件不满足则阻塞。阻塞IO是IO的默认形态。</p>
</li>
<li><p>效率：阻塞IO是效率很低的一种IO。但是由于逻辑简单所以是默认IO行为。</p>
</li>
<li><p>阻塞情况：</p>
</li>
</ol>
<ul>
<li><p>因为某种执行条件没有满足造成的函数阻塞<br>e.g.  accept   input   recv</p>
</li>
<li><p>处理IO的时间较长产生的阻塞状态<br>e.g. 网络传输，大文件读写</p>
</li>
</ul>
<h5 id="2-gt-非阻塞IO"><a href="#2-gt-非阻塞IO" class="headerlink" title="2&gt; 非阻塞IO"></a>2&gt; 非阻塞IO</h5><ol>
<li>定义 ：通过修改IO属性行为，使原本阻塞的IO变为非阻塞的状态。</li>
</ol>
<ul>
<li><p>设置套接字为非阻塞IO</p>
<blockquote>
<p>sockfd.setblocking(bool)<br> 功能：设置套接字为非阻塞IO<br> 参数：默认为True，表示套接字IO阻塞；设置为False则套接字IO变为非阻塞</p>
</blockquote>
</li>
<li><p>超时检测 ：设置一个最长阻塞时间，超过该时间后则不再阻塞等待。</p>
<blockquote>
<p>sockfd.settimeout(sec)<br>功能：设置套接字的超时时间<br>参数：设置的时间</p>
</blockquote>
</li>
</ul>
<h4 id="（2）IO多路复用"><a href="#（2）IO多路复用" class="headerlink" title="（2）IO多路复用"></a>（2）IO多路复用</h4><ol>
<li><p>定义</p>
<blockquote>
<p>同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件。以此形成可以同时处理多个IO的行为，避免一个IO阻塞造成其他IO均无法执行，提高了IO执行效率。</p>
</blockquote>
</li>
<li><p>具体方案</p>
<blockquote>
<p>select方法 ： windows  linux  unix<br>poll方法： linux  unix<br>epoll方法： linux</p>
</blockquote>
</li>
</ol>
<h5 id="1-gt-select-方法"><a href="#1-gt-select-方法" class="headerlink" title="1&gt; select 方法"></a>1&gt; select 方法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rs, ws, xs=select(rlist, wlist, xlist[, timeout])</span><br><span class="line">功能: 监控IO事件，阻塞等待IO发生</span><br><span class="line">参数：rlist  列表  存放关注的等待发生的IO事件</span><br><span class="line">      wlist  列表  存放关注的要主动处理的IO事件</span><br><span class="line">      xlist  列表  存放关注的出现异常要处理的IO</span><br><span class="line">      timeout  超时时间</span><br><span class="line"></span><br><span class="line">返回值： rs 列表  rlist中准备就绪的IO</span><br><span class="line">        ws 列表  wlist中准备就绪的IO</span><br><span class="line">	xs 列表  xlist中准备就绪的IO</span><br></pre></td></tr></table></figure>

<p>select 实现tcp服务</p>
<pre><code>【1】 将关注的IO放入对应的监控类别列表
【2】通过select函数进行监控
【3】遍历select返回值列表，确定就绪IO事件
【4】处理发生的IO事件
</code></pre>
<blockquote>
<p>注意</p>
<blockquote>
<p>wlist中如果存在IO事件，则select立即返回给ws<br>处理IO过程中不要出现死循环占有服务端的情况<br>IO多路复用消耗资源较少，效率较高</p>
</blockquote>
</blockquote>
<h5 id="2-gt-poll方法"><a href="#2-gt-poll方法" class="headerlink" title="2&gt; poll方法"></a>2&gt; poll方法</h5><p><em><strong>代码实现: day12/poll_server.py</strong></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = select.poll()</span><br><span class="line">功能 ： 创建poll对象</span><br><span class="line">返回值： poll对象</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.register(fd,event)   </span><br><span class="line">功能: 注册关注的IO事件</span><br><span class="line">参数：fd  要关注的IO</span><br><span class="line">      event  要关注的IO事件类型</span><br><span class="line">  	     常用类型：POLLIN  读IO事件（rlist）</span><br><span class="line">		      POLLOUT 写IO事件 (wlist)</span><br><span class="line">		      POLLERR 异常IO  （xlist）</span><br><span class="line">		      POLLHUP 断开连接 </span><br><span class="line">		  e.g. p.register(sockfd,POLLIN|POLLERR)</span><br><span class="line"></span><br><span class="line">p.unregister(fd)</span><br><span class="line">功能：取消对IO的关注</span><br><span class="line">参数：IO对象或者IO对象的fileno</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">events = p.poll()</span><br><span class="line">功能： 阻塞等待监控的IO事件发生</span><br><span class="line">返回值： 返回发生的IO</span><br><span class="line">        events格式  [(fileno,event),()....]</span><br><span class="line">        每个元组为一个就绪IO，元组第一项是该IO的fileno，第二项为该IO就绪的事件类型</span><br></pre></td></tr></table></figure>

<p>poll_server 步骤</p>
<pre><code>【1】 创建套接字
【2】 将套接字register
【3】 创建查找字典，并维护
【4】 循环监控IO发生
【5】 处理发生的IO
</code></pre>
<h5 id="3-gt-epoll方法"><a href="#3-gt-epoll方法" class="headerlink" title="3&gt; epoll方法"></a>3&gt; epoll方法</h5><ol>
<li><p>使用方法 ： 基本与poll相同</p>
<ul>
<li>生成对象改为 epoll()</li>
<li>将所有事件类型改为EPOLL类型</li>
</ul>
</li>
<li><p>epoll特点</p>
<ul>
<li>epoll 效率比select poll要高</li>
<li>epoll 监控IO数量比select要多</li>
<li>epoll 的触发方式比poll要多 （EPOLLET边缘触发）</li>
</ul>
</li>
</ol>
<h4 id="（3）协程技术"><a href="#（3）协程技术" class="headerlink" title="（3）协程技术"></a>（3）协程技术</h4><h5 id="1-gt-基础概念"><a href="#1-gt-基础概念" class="headerlink" title="1&gt; 基础概念"></a>1&gt; 基础概念</h5><ol>
<li><p>定义：纤程，微线程。是允许在不同入口点不同位置暂停或开始的计算机程序，简单来说，<strong>协程就是可以暂停执行的函数</strong>。</p>
</li>
<li><p>协程原理 ： 记录一个函数的上下文，协程调度切换时会将记录的上下文保存，在切换回来时进行调取，恢复原有的执行内容，以便从上一次执行位置继续执行。</p>
</li>
<li><p>协程优缺点</p>
</li>
</ol>
<blockquote>
<p>优点</p>
<blockquote>
<ol>
<li>协程完成多任务占用计算资源很少</li>
<li>由于协程的多任务切换在应用层完成，因此切换开销少</li>
<li>协程为单线程程序，无需进行共享资源同步互斥处理</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>缺点</p>
<blockquote>
<p>协程的本质是一个单线程，无法利用计算机多核资源</p>
</blockquote>
</blockquote>
<p>python3.5以后，使用标准库asyncio和async/await 语法来编写并发代码。asyncio库通过对异步IO行为的支持完成python的协程。虽然官方说asyncio是未来的开发方向，但是由于其生态不够丰富，大量的客户端不支持awaitable需要自己去封装，所以在使用上存在缺陷。更多时候只能使用已有的异步库（asyncio等），功能有限</p>
<hr>
<h5 id="2-gt-第三方协程模块"><a href="#2-gt-第三方协程模块" class="headerlink" title="2&gt; 第三方协程模块"></a>2&gt; 第三方协程模块</h5><ol>
<li> greenlet模块</li>
</ol>
<ul>
<li><p>安装 ： sudo  pip3 install greenlet</p>
</li>
<li><p>函数 </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">greenlet.greenlet(func)</span><br><span class="line">功能：创建协程对象</span><br><span class="line">参数：协程函数</span><br><span class="line"></span><br><span class="line">g.switch()</span><br><span class="line">功能：选择要执行的协程函数</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>gevent模块                </li>
</ol>
<ul>
<li><p>安装：sudo pip3 install gevent</p>
</li>
<li><p>函数</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gevent.spawn(func,argv)</span><br><span class="line">功能: 生成协程对象</span><br><span class="line">参数：func  协程函数</span><br><span class="line">     argv  给协程函数传参（不定参）</span><br><span class="line">返回值： 协程对象</span><br><span class="line"></span><br><span class="line">gevent.joinall(<span class="built_in">list</span>,[timeout])</span><br><span class="line">功能: 阻塞等待协程执行完毕</span><br><span class="line">参数：<span class="built_in">list</span>  协程对象列表</span><br><span class="line">     timeout 超时时间</span><br><span class="line"></span><br><span class="line">gevent.sleep(sec)</span><br><span class="line">功能: gevent睡眠阻塞</span><br><span class="line">参数：睡眠时间</span><br><span class="line"></span><br><span class="line">* gevent协程只有在遇到gevent指定的阻塞行为时才会自动在协程之间进行跳转</span><br><span class="line">如gevent.joinall(),gevent.sleep()带来的阻塞</span><br></pre></td></tr></table></figure>

<ul>
<li>monkey脚本</li>
</ul>
<blockquote>
<p>作用：在gevent协程中，协程只有遇到gevent指定类型的阻塞才能跳转到其他协程，因此，我们希望将普通的IO阻塞行为转换为可以触发gevent协程跳转的阻塞，以提高执行效率。</p>
</blockquote>
<blockquote>
<p>转换方法：gevent 提供了一个脚本程序monkey,可以修改底层解释IO阻塞的行为，将很多普通阻塞转换为gevent阻塞。</p>
</blockquote>
<blockquote>
<p>使用方法</p>
</blockquote>
<blockquote>
<blockquote>
<p>【1】 导入monkey</p>
</blockquote>
</blockquote>
<pre><code>    from gevent  import monkey
</code></pre>
<blockquote>
<blockquote>
<p>【2】 运行相应的脚本，例如转换socket中所有阻塞</p>
</blockquote>
</blockquote>
<pre><code>    monkey.patch_socket()
</code></pre>
<blockquote>
<blockquote>
<p>【3】 如果将所有可转换的IO阻塞全部转换则运行all</p>
</blockquote>
</blockquote>
<pre><code>    monkey.patch_all()
</code></pre>
<blockquote>
<blockquote>
<p>【4】 注意：脚本运行函数需要在对应模块导入前执行</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面向对象</tag>
        <tag>迭代器</tag>
        <tag>生成器</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy教程</title>
    <url>/2022/08/06/Numpy%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="NumPy-教程"><a href="#NumPy-教程" class="headerlink" title="NumPy 教程"></a>NumPy 教程</h2><ul>
<li>NumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</li>
</ul>
<ul>
<li>NumPy 的前身 Numeric 最早是由 Jim Hugunin 与其它协作者共同开发，2005 年，Travis Oliphant 在 Numeric 中结合了另一个同性质的程序库 Numarray 的特色，并加入了其它扩展而开发了 NumPy。NumPy 为开放源代码并且由许多协作者共同维护开发。</li>
<li>NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含：<ul>
<li>一个强大的N维数组对象 ndarray</li>
<li>广播功能函数</li>
<li>整合 C/C++/Fortran 代码的工具</li>
<li>线性代数、傅里叶变换、随机数生成等功能</li>
</ul>
</li>
</ul>
<h2 id="NumPy-Ndarray-对象"><a href="#NumPy-Ndarray-对象" class="headerlink" title="NumPy Ndarray 对象"></a>NumPy Ndarray 对象</h2><ul>
<li>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。</li>
</ul>
<ul>
<li>ndarray 对象是用于存放同类型元素的多维数组。</li>
</ul>
<ul>
<li>ndarray 中的每个元素在内存中都有相同存储大小的区域。</li>
</ul>
<ul>
<li><p>ndarray 内部由以下内容组成：</p>
<ul>
<li>一个指向数据（内存或内存映射文件中的一块数据）的指针。</li>
<li>数据类型或 dtype，描述在数组中的固定大小值的格子。</li>
<li>一个表示数组形状（shape）的元组，表示各维度大小的元组。</li>
<li>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。</li>
</ul>
</li>
<li><p>ndarray 的内部结构:</p>
<p> <img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/20200327233644385.png" alt="ndarray"> </p>
<p>跨度可以是负数，这样会使数组在内存中后向移动，切片中 obj[::-1] 或 obj[:,::-1] 就是如此。</p>
</li>
<li><p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>| 名称   | 描述                                                      |<br>| —— | ——————————————————— |<br>| object | 数组或嵌套的数列                                          |<br>| dtype  | 数组元素的数据类型，可选                                  |<br>| copy   | 对象是否需要复制，可选                                    |<br>| order  | 创建数组的样式，C为行方向，F为列方向，A为任意方向（默认） |<br>| subok  | 默认返回一个与基类类型一致的数组                          |<br>| ndmin  | 指定生成数组的最小维度                                    |</p>
<ul>
<li>ndarray 对象由计算机内存的连续一维部分组成，并结合索引模式，将每个元素映射到内存块中的一个位置。内存块以行顺序(C样式)或列顺序(FORTRAN或MatLab风格，即前述的F样式)来保存元素 </li>
</ul>
<h2 id="NumPy-数据类型"><a href="#NumPy-数据类型" class="headerlink" title="NumPy 数据类型"></a>NumPy 数据类型</h2><ul>
<li><p>numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。下表列举了常用 NumPy 基本类型。</p>
<p><img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/1659759941145.png" alt="1659759941145"></p>
</li>
<li><p>numpy 的数值类型实际上是 dtype 对象的实例，并对应唯一的字符，包括 np.bool_，np.int32，np.float32，等等。 </p>
</li>
</ul>
<h3 id="数据类型对象-dtype"><a href="#数据类型对象-dtype" class="headerlink" title="数据类型对象 (dtype)"></a>数据类型对象 (dtype)</h3><ul>
<li><p>数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：</p>
<ul>
<li>数据的类型（整数，浮点数或者 Python 对象）</li>
<li>数据的大小（例如， 整数使用多少个字节存储）</li>
<li>数据的字节顺序（小端法或大端法）</li>
<li>在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li>
<li>如果数据类型是子数组，它的形状和数据类型</li>
</ul>
</li>
<li><p>字节顺序是通过对数据类型预先设定”&lt;“或”&gt;“来决定的。”&lt;“意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。”&gt;”意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。</p>
</li>
</ul>
<ul>
<li>dtype 对象是使用以下语法构造的：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.dtype(<span class="built_in">object</span>, align, copy)</span><br><span class="line"><span class="comment"># object - 要转换为的数据类型对象</span></span><br><span class="line"><span class="comment"># align - 如果为 true，填充字段使其类似 C 的结构体。</span></span><br><span class="line"><span class="comment"># copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>每个内建类型都有一个唯一定义它的字符代码，如下：</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">对应类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">b</td>
<td align="center">布尔型</td>
</tr>
<tr>
<td align="center">i</td>
<td align="center">(有符号) 整型</td>
</tr>
<tr>
<td align="center">u</td>
<td align="center">无符号整型 integer</td>
</tr>
<tr>
<td align="center">f</td>
<td align="center">浮点型</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">复数浮点型</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">timedelta（时间间隔）</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">datetime（日期时间）</td>
</tr>
<tr>
<td align="center">O</td>
<td align="center">(Python) 对象</td>
</tr>
<tr>
<td align="center">S, a</td>
<td align="center">(byte-)字符串</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">Unicode</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">原始数据 (void)</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="NumPy-读取数据"><a href="#NumPy-读取数据" class="headerlink" title="NumPy 读取数据"></a>NumPy 读取数据</h2><ul>
<li><p>CSV:Comma-Separated Value,逗号分隔值文件</p>
</li>
<li><p>显示：表格状态</p>
</li>
</ul>
<ul>
<li>源文件：换行和逗号分隔行列的格式化文本,每一行的数据表示一条记录</li>
</ul>
<ul>
<li>由于csv便于展示,读取和写入,所以很多地方也是用csv的格式存储和传输中小型的数据,为了方便教学,我们会经常操作csv格式的文件,但是操作数据库中的数据也是很容易的实现的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.loadtxt(fname,dtype=np.<span class="built_in">float</span>,delimiter=<span class="literal">None</span>,skiprows=<span class="number">0</span>,usecols=<span class="literal">None</span>,unpack=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/1659760531602.png" alt="1659760531602"></p>
<h2 id="NumPy-数组属性"><a href="#NumPy-数组属性" class="headerlink" title="NumPy 数组属性"></a>NumPy 数组属性</h2><ul>
<li><p>NumPy 数组的维数称为秩（rank），秩就是轴的数量，即数组的维度，一维数组的秩为 1，二维数组的秩为 2，以此类推。</p>
</li>
<li><p>在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</p>
</li>
</ul>
<ul>
<li>很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。</li>
</ul>
<ul>
<li><p>NumPy 的数组中比较重要 ndarray 对象属性有：</p>
<p><img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/1659761591454.png" alt="1659761591454"></p>
<ul>
<li><p>ndarray.ndim<br>ndarray.ndim 用于返回数组的维数，等于秩。</p>
</li>
<li><p>ndarray.shape<br>ndarray.shape 表示数组的维度，返回一个元组，这个元组的长度就是维度的数目，即 ndim 属性(秩)。比如，一个二维数组，其维度表示”行数”和”列数”。</p>
</li>
<li><p>ndarray.shape 也可以用于调整数组大小。</p>
<p>NumPy 也提供了 reshape 函数来调整数组大小。</p>
</li>
<li><p>ndarray.itemsize<br>ndarray.itemsize 以字节的形式返回数组中每一个元素的大小。</p>
<p>例如，一个元素类型为 float64 的数组 itemsiz 属性值为 8(float64 占用 64 个 bits，每个字节长度为 8，所以 64/8，占用 8 个字节），又如，一个元素类型为 complex32 的数组 item 属性为 4（32/8）。</p>
</li>
<li><p>ndarray.flags<br>ndarray.flags 返回 ndarray 对象的内存信息，包含以下属性：</p>
<p><img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/1659761773766.png" alt="1659761773766"></p>
</li>
</ul>
</li>
</ul>
<h2 id="NumPy-创建数组"><a href="#NumPy-创建数组" class="headerlink" title="NumPy 创建数组"></a>NumPy 创建数组</h2><p>ndarray 数组除了可以使用底层 ndarray 构造器来创建外，也可以通过以下几种方式来创建。</p>
<h3 id="numpy-empty"><a href="#numpy-empty" class="headerlink" title="numpy.empty"></a>numpy.empty</h3><ul>
<li>numpy.empty 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.empty(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># shape	数组形状</span></span><br><span class="line"><span class="comment"># dtype	数据类型，可选</span></span><br><span class="line"><span class="comment"># order	有&quot;C&quot;和&quot;F&quot;两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</span></span><br></pre></td></tr></table></figure>



<h3 id="numpy-zeros"><a href="#numpy-zeros" class="headerlink" title="numpy.zeros"></a>numpy.zeros</h3><ul>
<li>创建指定大小的数组，数组元素以 0 来填充：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = float, order = &#x27;C&#x27;)</span><br><span class="line"># shape	数组形状</span><br><span class="line"># dtype	数据类型，可选</span><br><span class="line"># order	‘C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组</span><br></pre></td></tr></table></figure>



<h3 id="numpy-ones"><a href="#numpy-ones" class="headerlink" title="numpy.ones"></a>numpy.ones</h3><ul>
<li>创建指定形状的数组，数组元素以 1 来填充：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ones(shape, dtype = <span class="literal">None</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># shape	数组形状</span></span><br><span class="line"><span class="comment"># dtype	数据类型，可选</span></span><br><span class="line"><span class="comment"># order	‘C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组</span></span><br></pre></td></tr></table></figure>



<h2 id="NumPy-从已有的数组创建数组"><a href="#NumPy-从已有的数组创建数组" class="headerlink" title="NumPy 从已有的数组创建数组"></a>NumPy 从已有的数组创建数组</h2><h3 id="numpy-asarray"><a href="#numpy-asarray" class="headerlink" title="numpy.asarray"></a>numpy.asarray</h3><ul>
<li>numpy.asarray 类似 numpy.array，但 numpy.asarray 参数只有三个，比 numpy.array 少两个。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.asarray(a, dtype = <span class="literal">None</span>, order = <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># a	任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组</span></span><br><span class="line"><span class="comment"># dtype	数据类型，可选</span></span><br><span class="line"><span class="comment"># order	可选，有&quot;C&quot;和&quot;F&quot;两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</span></span><br></pre></td></tr></table></figure>



<h3 id="numpy-frombuffer"><a href="#numpy-frombuffer" class="headerlink" title="numpy.frombuffer"></a>numpy.frombuffer</h3><ul>
<li><p>numpy.frombuffer 用于实现动态数组。</p>
</li>
<li><p>numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.frombuffer(buffer, dtype = <span class="built_in">float</span>, count = -<span class="number">1</span>, offset = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># buffer	可以是任意对象，会以流的形式读入。</span></span><br><span class="line"><span class="comment"># dtype	返回数组的数据类型，可选</span></span><br><span class="line"><span class="comment"># count	读取的数据数量，默认为-1，读取所有数据。</span></span><br><span class="line"><span class="comment"># offset	读取的起始位置，默认为0。</span></span><br></pre></td></tr></table></figure>



<h3 id="numpy-fromiter"><a href="#numpy-fromiter" class="headerlink" title="numpy.fromiter"></a>numpy.fromiter</h3><ul>
<li>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.fromiter(iterable, dtype, count=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># iterable	可迭代对象</span></span><br><span class="line"><span class="comment"># dtype	返回数组的数据类型</span></span><br><span class="line"><span class="comment"># count	读取的数据数量，默认为-1，读取所有数据</span></span><br></pre></td></tr></table></figure>



<h2 id="NumPy-从数值范围创建数组"><a href="#NumPy-从数值范围创建数组" class="headerlink" title="NumPy 从数值范围创建数组"></a>NumPy 从数值范围创建数组</h2><h2 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange"></a>numpy.arange</h2><ul>
<li>numpy 包中的使用 arange 函数创建数值范围并返回 ndarray 对象，函数格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype)</span><br><span class="line"><span class="comment">#  start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。</span></span><br><span class="line"><span class="comment">#  start	起始值，默认为0</span></span><br><span class="line"><span class="comment">#  stop	终止值（不包含）</span></span><br><span class="line"><span class="comment">#  step	步长，默认为1</span></span><br><span class="line"><span class="comment">#  dtype	返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。</span></span><br></pre></td></tr></table></figure>



<h2 id="numpy-linspace"><a href="#numpy-linspace" class="headerlink" title="numpy.linspace"></a>numpy.linspace</h2><ul>
<li>numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># start	序列的起始值</span></span><br><span class="line"><span class="comment"># stop	序列的终止值，如果endpoint为true，该值包含于数列中</span></span><br><span class="line"><span class="comment"># num	要生成的等步长的样本数量，默认为50</span></span><br><span class="line"><span class="comment"># endpoint	该值为 true 时，数列中中包含stop值，反之不包含，默认是True。</span></span><br><span class="line"><span class="comment"># retstep	如果为 True 时，生成的数组中会显示间距，反之不显示。</span></span><br><span class="line"><span class="comment"># dtype	ndarray 的数据类型</span></span><br></pre></td></tr></table></figure>



<h2 id="numpy-logspace"><a href="#numpy-logspace" class="headerlink" title="numpy.logspace"></a>numpy.logspace</h2><ul>
<li>numpy.logspace 函数用于创建一个于等比数列。格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># start	序列的起始值为：base ** start</span></span><br><span class="line"><span class="comment"># stop	序列的终止值为：base ** stop。如果endpoint为true，该值包含于数列中</span></span><br><span class="line"><span class="comment"># num	要生成的等步长的样本数量，默认为50</span></span><br><span class="line"><span class="comment"># endpoint	该值为 true 时，数列中中包含stop值，反之不包含，默认是True。</span></span><br><span class="line"><span class="comment"># base	对数 log 的底数。</span></span><br><span class="line"><span class="comment"># dtype	ndarray 的数据类型</span></span><br></pre></td></tr></table></figure>



<h2 id="NumPy-切片和索引"><a href="#NumPy-切片和索引" class="headerlink" title="NumPy 切片和索引"></a>NumPy 切片和索引</h2><ul>
<li><p>ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。</p>
</li>
<li><p>ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。通过冒号分隔切片参数 start:stop:step 来进行切片操作。</p>
</li>
</ul>
<ul>
<li>冒号 : 的解释：如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引(不包括停止索引)之间的项。</li>
</ul>
<ul>
<li>切片还可以包括省略号 …，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</li>
</ul>
<h2 id="NumPy-高级索引"><a href="#NumPy-高级索引" class="headerlink" title="NumPy 高级索引"></a>NumPy 高级索引</h2><ul>
<li>NumPy 比一般的 Python 序列提供更多的索引方式。除了之前看到的用整数和切片的索引外，数组可以由整数数组索引、布尔索引及花式索引。</li>
</ul>
<h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><ul>
<li><p>我们可以通过一个布尔数组来索引目标数组。</p>
</li>
<li><p>布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p>
</li>
</ul>
<ul>
<li>~（取补运算符）来过滤 NaN</li>
</ul>
<h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><ul>
<li><p>花式索引指的是利用整数数组进行索引。</p>
</li>
<li><p>花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。</p>
</li>
</ul>
<ul>
<li><p>花式索引跟切片不一样，它总是将数据复制到新数组中。</p>
<ul>
<li><p>（1）传入顺序索引数组</p>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x=np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> (x[[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>]])</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]]</span><br></pre></td></tr></table></figure></li>
<li><p>（2）传入倒序索引数组</p>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x=np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> (x[[-<span class="number">4</span>,-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">7</span>]])</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [<span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]]</span><br></pre></td></tr></table></figure></li>
<li><p>（3）传入多个索引数组（要使用np.ix_）</p>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x=np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> (x[np.ix_([<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<pre><code>输出结果为：

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[ <span class="number">4</span>  <span class="number">7</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">23</span> <span class="number">21</span> <span class="number">22</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">31</span> <span class="number">29</span> <span class="number">30</span>]</span><br><span class="line"> [ <span class="number">8</span> <span class="number">11</span>  <span class="number">9</span> <span class="number">10</span>]]</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="NumPy-广播-Broadcast"><a href="#NumPy-广播-Broadcast" class="headerlink" title="NumPy 广播(Broadcast)"></a>NumPy 广播(Broadcast)</h2><ul>
<li><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p>
</li>
<li><p>如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p>
</li>
</ul>
<ul>
<li><p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">			[<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">			[<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">			[<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line"> [<span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]]</span><br></pre></td></tr></table></figure></li>
<li><p>下面的图片展示了数组 b 如何通过广播来与数组 a 兼容。</p>
<p> <img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/20200327233751196.gif" alt="在这里插入图片描述"> </p>
</li>
</ul>
<p>​    4x3 的二维数组与长为 3 的一维数组相加，等效于把数组 b 在二维上重复 4 次再运算</p>
<ul>
<li><p>广播的规则:</p>
<ul>
<li><p>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。<br>输出数组的形状是输入数组形状的各个维度上的最大值。</p>
</li>
<li><p>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</p>
</li>
<li><p>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。</p>
</li>
<li><p><strong>简单理解：</strong>对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p>
<ul>
<li><p>数组拥有相同形状。</p>
</li>
<li><p>当前维度的值相等。</p>
</li>
<li><p>当前维度的值有一个是 1。</p>
<p>若条件不满足，抛出 “ValueError: frames are not aligned” 异常。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="NumPy-迭代数组"><a href="#NumPy-迭代数组" class="headerlink" title="NumPy 迭代数组"></a>NumPy 迭代数组</h2><ul>
<li><p>NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式。</p>
</li>
<li><p>迭代器最基本的任务的可以完成对数组元素的访问。</p>
</li>
</ul>
<h3 id="控制遍历顺序"><a href="#控制遍历顺序" class="headerlink" title="控制遍历顺序"></a>控制遍历顺序</h3><ul>
<li>for x in np.nditer(a, order=’F’):Fortran order，即是列序优先；</li>
<li>for x in np.nditer(a.T, order=’C’):C order，即是行序优先；</li>
<li>可以通过显式设置，来强制 nditer 对象使用某种顺序。</li>
</ul>
<h3 id="修改数组中元素的值"><a href="#修改数组中元素的值" class="headerlink" title="修改数组中元素的值"></a>修改数组中元素的值</h3><ul>
<li>nditer 对象有另一个可选参数 op_flags。 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。</li>
</ul>
<h3 id="使用外部循环"><a href="#使用外部循环" class="headerlink" title="使用外部循环"></a>使用外部循环</h3><p>nditer类的构造器拥有flags参数，它可以接受下列值：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>c_index</code></td>
<td>可以跟踪 C 顺序的索引</td>
</tr>
<tr>
<td><code>f_index</code></td>
<td>可以跟踪 Fortran 顺序的索引</td>
</tr>
<tr>
<td><code>multi-index</code></td>
<td>每次迭代可以跟踪一种索引类型</td>
</tr>
<tr>
<td><code>external_loop</code></td>
<td>给出的值是具有多个值的一维数组，而不是零维数组</td>
</tr>
</tbody></table>
<h3 id="广播迭代"><a href="#广播迭代" class="headerlink" title="广播迭代"></a>广播迭代</h3><ul>
<li>如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。</li>
</ul>
<h2 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h2><h3 id="修改数组形状"><a href="#修改数组形状" class="headerlink" title="修改数组形状"></a>修改数组形状</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>reshape</code></td>
<td>不改变数据的条件下修改形状</td>
</tr>
<tr>
<td><code>flat</code></td>
<td>数组元素迭代器</td>
</tr>
<tr>
<td><code>flatten</code></td>
<td>返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td>
</tr>
<tr>
<td><code>ravel</code></td>
<td>返回展开数组</td>
</tr>
</tbody></table>
<h4 id="numpy-reshape"><a href="#numpy-reshape" class="headerlink" title="numpy.reshape"></a>numpy.reshape</h4><ul>
<li>numpy.reshape 函数可以在不改变数据的条件下修改形状，格式如下： numpy.reshape(arr, newshape, order=‘C’)<ul>
<li>arr：要修改形状的数组</li>
<li>newshape：整数或者整数数组，新的形状应当兼容原有形状</li>
<li>order：‘C’ – 按行，‘F’ – 按列，‘A’ – 原顺序，‘k’ – 元素在内存中的出现顺序。</li>
</ul>
</li>
</ul>
<h4 id="numpy-ndarray-flat"><a href="#numpy-ndarray-flat" class="headerlink" title="numpy.ndarray.flat"></a>numpy.ndarray.flat</h4><ul>
<li>numpy.ndarray.flat 是一个数组元素迭代器。</li>
</ul>
<h4 id="numpy-ndarray-flatten"><a href="#numpy-ndarray-flatten" class="headerlink" title="numpy.ndarray.flatten"></a>numpy.ndarray.flatten</h4><ul>
<li><p>numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ndarray.flatten(order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># order：‘C’ – 按行，‘F’ – 按列，‘A’ – 原顺序，‘K’ – 元素在内存中的出现顺序。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>numpy.ravel</p>
<h4 id="numpy-ravel"><a href="#numpy-ravel" class="headerlink" title="numpy.ravel()"></a>numpy.ravel()</h4><ul>
<li><p>展平的数组元素，顺序通常是”C风格”，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ravel(a, order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># order：‘C’ – 按行，‘F’ – 按列，‘A’ – 原顺序，‘K’ – 元素在内存中的出现顺序。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>transpose</code></td>
<td>对换数组的维度</td>
</tr>
<tr>
<td><code>ndarray.T</code></td>
<td>和 <code>self.transpose()</code> 相同</td>
</tr>
<tr>
<td><code>rollaxis</code></td>
<td>向后滚动指定的轴</td>
</tr>
<tr>
<td><code>swapaxes</code></td>
<td>对换数组的两个轴</td>
</tr>
</tbody></table>
<h4 id="numpy-transpose"><a href="#numpy-transpose" class="headerlink" title="numpy.transpose"></a>numpy.transpose</h4><ul>
<li>numpy.transpose 函数用于对换数组的维度，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.transpose(arr, axes)</span><br><span class="line"><span class="comment"># 参数说明:</span></span><br><span class="line"><span class="comment"># arr：要操作的数组</span></span><br><span class="line"><span class="comment"># axes：整数列表，对应维度，通常所有维度都会对换。</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-rollaxis"><a href="#numpy-rollaxis" class="headerlink" title="numpy.rollaxis"></a>numpy.rollaxis</h4><ul>
<li>numpy.rollaxis 函数向后滚动特定的轴到一个特定位置，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.rollaxis(arr, axis, start)</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># arr：数组</span></span><br><span class="line"><span class="comment"># axis：要向后滚动的轴，其它轴的相对位置不会改变</span></span><br><span class="line"><span class="comment"># start：默认为零，表示完整的滚动。会滚动到特定位置。</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-swapaxes"><a href="#numpy-swapaxes" class="headerlink" title="numpy.swapaxes"></a>numpy.swapaxes</h4><ul>
<li>numpy.swapaxes 函数用于交换数组的两个轴，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.swapaxes(arr, axis1, axis2)</span><br><span class="line"><span class="comment"># arr：输入的数组</span></span><br><span class="line"><span class="comment"># axis1：对应第一个轴的整数</span></span><br><span class="line"><span class="comment"># axis2：对应第二个轴的整数</span></span><br></pre></td></tr></table></figure>



<h3 id="修改数组维度"><a href="#修改数组维度" class="headerlink" title="修改数组维度"></a>修改数组维度</h3><table>
<thead>
<tr>
<th>维度</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>broadcast</code></td>
<td>产生模仿广播的对象</td>
</tr>
<tr>
<td><code>broadcast_to</code></td>
<td>将数组广播到新形状</td>
</tr>
<tr>
<td><code>expand_dims</code></td>
<td>扩展数组的形状</td>
</tr>
<tr>
<td><code>squeeze</code></td>
<td>从数组的形状中删除一维条目</td>
</tr>
</tbody></table>
<h4 id="numpy-broadcast"><a href="#numpy-broadcast" class="headerlink" title="numpy.broadcast"></a>numpy.broadcast</h4><ul>
<li>numpy.broadcast 用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。</li>
</ul>
<h4 id="numpy-broadcast-to"><a href="#numpy-broadcast-to" class="headerlink" title="numpy.broadcast_to"></a>numpy.broadcast_to</h4><ul>
<li>numpy.broadcast_to 函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.broadcast_to(array, shape, subok)</span><br></pre></td></tr></table></figure>

<h4 id="numpy-expand-dims"><a href="#numpy-expand-dims" class="headerlink" title="numpy.expand_dims"></a>numpy.expand_dims</h4><ul>
<li>numpy.expand_dims 函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> numpy.expand_dims(arr, axis)</span><br><span class="line"><span class="comment"># arr：输入数组</span></span><br><span class="line"><span class="comment"># axis：新轴插入的位置</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-squeeze"><a href="#numpy-squeeze" class="headerlink" title="numpy.squeeze"></a>numpy.squeeze</h4><ul>
<li>numpy.squeeze 函数从给定数组的形状中删除一维的条目，函数格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># arr：输入数组</span></span><br><span class="line"><span class="comment"># axis：整数或整数元组，用于选择形状中一维条目的子集</span></span><br></pre></td></tr></table></figure>



<h3 id="连接数组"><a href="#连接数组" class="headerlink" title="连接数组"></a>连接数组</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>concatenate</code></td>
<td>连接沿现有轴的数组序列</td>
</tr>
<tr>
<td><code>stack</code></td>
<td>沿着新的轴加入一系列数组。</td>
</tr>
<tr>
<td><code>hstack</code></td>
<td>水平堆叠序列中的数组（列方向）</td>
</tr>
<tr>
<td><code>vstack</code></td>
<td>竖直堆叠序列中的数组（行方向）</td>
</tr>
</tbody></table>
<h4 id="numpy-concatenate"><a href="#numpy-concatenate" class="headerlink" title="numpy.concatenate"></a>numpy.concatenate</h4><ul>
<li>numpy.concatenate 函数用于沿指定轴连接相同形状的两个或多个数组，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.concatenate((a1, a2, ...), axis)</span><br><span class="line"><span class="comment"># a1, a2, ...：相同类型的数组</span></span><br><span class="line"><span class="comment"># axis：沿着它连接数组的轴，默认为 0</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-stack"><a href="#numpy-stack" class="headerlink" title="numpy.stack"></a>numpy.stack</h4><ul>
<li>numpy.stack 函数用于沿新轴连接数组序列，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.stack(arrays, axis)</span><br><span class="line"><span class="comment"># arrays相同形状的数组序列</span></span><br><span class="line"><span class="comment"># axis：返回数组中的轴，输入数组沿着它来堆叠</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-hstack"><a href="#numpy-hstack" class="headerlink" title="numpy.hstack"></a>numpy.hstack</h4><ul>
<li>numpy.hstack 是 numpy.stack 函数的变体，它通过水平堆叠来生成数组。</li>
</ul>
<h4 id="numpy-vstack"><a href="#numpy-vstack" class="headerlink" title="numpy.vstack"></a>numpy.vstack</h4><ul>
<li>numpy.vstack 是 numpy.stack 函数的变体，它通过垂直堆叠来生成数组。</li>
</ul>
<h3 id="分割数组"><a href="#分割数组" class="headerlink" title="分割数组"></a>分割数组</h3><table>
<thead>
<tr>
<th>函数</th>
<th>数组及操作</th>
</tr>
</thead>
<tbody><tr>
<td><code>split</code></td>
<td>将一个数组分割为多个子数组</td>
</tr>
<tr>
<td><code>hsplit</code></td>
<td>将一个数组水平分割为多个子数组（按列）</td>
</tr>
<tr>
<td><code>vsplit</code></td>
<td>将一个数组垂直分割为多个子数组（按行）</td>
</tr>
</tbody></table>
<h4 id="numpy-split"><a href="#numpy-split" class="headerlink" title="numpy.split"></a>numpy.split</h4><ul>
<li>函数沿特定的轴将数组分割为子数组，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.split(ary, indices_or_sections, axis)</span><br><span class="line"><span class="comment"># ary：被分割的数组</span></span><br><span class="line"><span class="comment"># indices_or_sections：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）</span></span><br><span class="line"><span class="comment"># axis：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-hsplit"><a href="#numpy-hsplit" class="headerlink" title="numpy.hsplit"></a>numpy.hsplit</h4><ul>
<li>numpy.hsplit 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。</li>
</ul>
<h4 id="numpy-vsplit"><a href="#numpy-vsplit" class="headerlink" title="numpy.vsplit"></a>numpy.vsplit</h4><ul>
<li>numpy.vsplit 沿着垂直轴分割，其分割方式与hsplit用法相同。</li>
</ul>
<h3 id="数组元素的添加与删除"><a href="#数组元素的添加与删除" class="headerlink" title="数组元素的添加与删除"></a>数组元素的添加与删除</h3><table>
<thead>
<tr>
<th>函数</th>
<th>元素及描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>resize</code></td>
<td>返回指定形状的新数组</td>
</tr>
<tr>
<td><code>append</code></td>
<td>将值添加到数组末尾</td>
</tr>
<tr>
<td><code>insert</code></td>
<td>沿指定轴将值插入到指定下标之前</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>删掉某个轴的子数组，并返回删除后的新数组</td>
</tr>
<tr>
<td><code>unique</code></td>
<td>查找数组内的唯一元素</td>
</tr>
</tbody></table>
<h4 id="numpy-resize"><a href="#numpy-resize" class="headerlink" title="numpy.resize"></a>numpy.resize</h4><ul>
<li><p>numpy.resize 函数返回指定大小的新数组。</p>
</li>
<li><p>如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.resize(arr, shape)</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># arr：要修改大小的数组</span></span><br><span class="line"><span class="comment"># shape：返回数组的新形状</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-append"><a href="#numpy-append" class="headerlink" title="numpy.append"></a>numpy.append</h4><ul>
<li><p>numpy.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。</p>
</li>
<li><p>append 函数返回的始终是一个一维数组。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.append(arr, values, axis=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># arr：输入数组</span></span><br><span class="line"><span class="comment"># values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</span></span><br><span class="line"><span class="comment"># axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-insert"><a href="#numpy-insert" class="headerlink" title="numpy.insert"></a>numpy.insert</h4><ul>
<li><p>numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。</p>
</li>
<li><p>如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.insert(arr, obj, values, axis)</span><br><span class="line"><span class="comment"># arr：输入数组</span></span><br><span class="line"><span class="comment"># obj：在其之前插入值的索引</span></span><br><span class="line"><span class="comment"># values：要插入的值</span></span><br><span class="line"><span class="comment"># axis：沿着它插入的轴，如果未提供，则输入数组会被展开</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-delete"><a href="#numpy-delete" class="headerlink" title="numpy.delete"></a>numpy.delete</h4><ul>
<li>numpy.delete 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Numpy.delete(arr, obj, axis)</span><br><span class="line">arr：输入数组</span><br><span class="line">obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</span><br><span class="line">axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<h4 id="numpy-unique"><a href="#numpy-unique" class="headerlink" title="numpy.unique"></a>numpy.unique</h4><ul>
<li>numpy.unique 函数用于去除数组中的重复元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.unique(arr, return_index, return_inverse, return_counts)</span><br><span class="line"><span class="comment"># arr：输入数组，如果不是一维数组则会展开</span></span><br><span class="line"><span class="comment"># return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</span></span><br><span class="line"><span class="comment"># return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</span></span><br><span class="line"><span class="comment"># return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数</span></span><br></pre></td></tr></table></figure>



<h2 id="NumPy-位运算"><a href="#NumPy-位运算" class="headerlink" title="NumPy 位运算"></a>NumPy 位运算</h2><ul>
<li><p>NumPy <strong>“bitwise_”</strong> 开头的函数是位运算函数。</p>
</li>
<li><p>NumPy 位运算包括以下几个函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>bitwise_and</code></td>
<td>对数组元素执行位与操作</td>
</tr>
<tr>
<td><code>bitwise_or</code></td>
<td>对数组元素执行位或操作</td>
</tr>
<tr>
<td><code>invert</code></td>
<td>按位取反</td>
</tr>
<tr>
<td><code>left_shift</code></td>
<td>向左移动二进制表示的位</td>
</tr>
<tr>
<td><code>right_shift</code></td>
<td>向右移动二进制表示的位</td>
</tr>
</tbody></table>
<p> <strong>注：</strong>也可以使用 “&amp;”、 “~”、 “|” 和 “^” 等操作符进行计算。 </p>
</li>
</ul>
<h3 id="bitwise-and"><a href="#bitwise-and" class="headerlink" title="bitwise_and"></a>bitwise_and</h3><ul>
<li><p>bitwise_and() 函数对数组中整数的二进制形式执行位与运算。</p>
</li>
<li><p>位与操作运算规律如下：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>AND</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="bitwise-or"><a href="#bitwise-or" class="headerlink" title="bitwise_or"></a>bitwise_or</h3><ul>
<li><p>bitwise_or()函数对数组中整数的二进制形式执行位或运算。</p>
</li>
<li><p>位或操作运算规律如下：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>OR</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="invert"><a href="#invert" class="headerlink" title="invert"></a>invert</h3><ul>
<li><p>invert() 函数对数组中整数进行位取反运算，即 0 变成 1，1 变成 0。</p>
</li>
<li><p>对于有符号整数，取该二进制数的补码，然后 +1。二进制数，最高位为0表示正数，最高位为 1 表示负数。</p>
</li>
</ul>
<h3 id="left-shift"><a href="#left-shift" class="headerlink" title="left_shift"></a>left_shift</h3><ul>
<li>left_shift() 函数将数组元素的二进制形式向左移动到指定位置，右侧附加相等数量的 0。</li>
</ul>
<h3 id="right-shift"><a href="#right-shift" class="headerlink" title="right_shift"></a>right_shift</h3><ul>
<li>right_shift() 函数将数组元素的二进制形式向右移动到指定位置，左侧附加相等数量的 0。</li>
</ul>
<h2 id="NumPy-字符串函数"><a href="#NumPy-字符串函数" class="headerlink" title="NumPy 字符串函数"></a>NumPy 字符串函数</h2><ul>
<li><p>以下函数用于对 dtype 为 numpy.string_ 或 numpy.unicode_ 的数组执行向量化字符串操作。 它们基于 Python 内置库中的标准字符串函数。</p>
</li>
<li><p>这些函数在字符数组类（numpy.char）中定义。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>add()</code></td>
<td>对两个数组的逐个字符串元素进行连接</td>
</tr>
<tr>
<td>multiply()</td>
<td>返回按元素多重连接后的字符串</td>
</tr>
<tr>
<td><code>center()</code></td>
<td>居中字符串</td>
</tr>
<tr>
<td><code>capitalize()</code></td>
<td>将字符串第一个字母转换为大写</td>
</tr>
<tr>
<td><code>title()</code></td>
<td>将字符串的每个单词的第一个字母转换为大写</td>
</tr>
<tr>
<td><code>lower()</code></td>
<td>数组元素转换为小写</td>
</tr>
<tr>
<td><code>upper()</code></td>
<td>数组元素转换为大写</td>
</tr>
<tr>
<td><code>split()</code></td>
<td>指定分隔符对字符串进行分割，并返回数组列表</td>
</tr>
<tr>
<td><code>splitlines()</code></td>
<td>返回元素中的行列表，以换行符分割</td>
</tr>
<tr>
<td><code>strip()</code></td>
<td>移除元素开头或者结尾处的特定字符</td>
</tr>
<tr>
<td><code>join()</code></td>
<td>通过指定分隔符来连接数组中的元素</td>
</tr>
<tr>
<td><code>replace()</code></td>
<td>使用新字符串替换字符串中的所有子字符串</td>
</tr>
<tr>
<td><code>decode()</code></td>
<td>数组元素依次调用<code>str.decode</code></td>
</tr>
<tr>
<td><code>encode()</code></td>
<td>数组元素依次调用<code>str.encode</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="numpy-char-add"><a href="#numpy-char-add" class="headerlink" title="numpy.char.add()"></a>numpy.char.add()</h3><ul>
<li>numpy.char.add() 函数依次对两个数组的元素进行字符串连接。</li>
</ul>
<h3 id="numpy-char-multiply"><a href="#numpy-char-multiply" class="headerlink" title="numpy.char.multiply()"></a>numpy.char.multiply()</h3><ul>
<li>numpy.char.multiply() 函数执行多重连接。</li>
</ul>
<h3 id="numpy-char-center"><a href="#numpy-char-center" class="headerlink" title="numpy.char.center()"></a>numpy.char.center()</h3><ul>
<li>numpy.char.center() 函数用于将字符串居中，并使用指定字符在左侧和右侧进行填充。</li>
</ul>
<h3 id="numpy-char-capitalize"><a href="#numpy-char-capitalize" class="headerlink" title="numpy.char.capitalize()"></a>numpy.char.capitalize()</h3><ul>
<li>numpy.char.capitalize() 函数将字符串的第一个字母转换为大写。</li>
</ul>
<h3 id="numpy-char-title"><a href="#numpy-char-title" class="headerlink" title="numpy.char.title()"></a>numpy.char.title()</h3><ul>
<li>numpy.char.title() 函数将字符串的每个单词的第一个字母转换为大写。</li>
</ul>
<h3 id="numpy-char-lower"><a href="#numpy-char-lower" class="headerlink" title="numpy.char.lower()"></a>numpy.char.lower()</h3><ul>
<li>numpy.char.lower() 函数对数组的每个元素转换为小写。它对每个元素调用 str.lower。</li>
</ul>
<h3 id="numpy-char-upper"><a href="#numpy-char-upper" class="headerlink" title="numpy.char.upper()"></a>numpy.char.upper()</h3><ul>
<li>numpy.char.upper() 函数对数组的每个元素转换为大写。它对每个元素调用 str.upper。</li>
</ul>
<h3 id="numpy-char-split"><a href="#numpy-char-split" class="headerlink" title="numpy.char.split()"></a>numpy.char.split()</h3><ul>
<li>numpy.char.split() 通过指定分隔符对字符串进行分割，并返回数组。默认情况下，分隔符为空格。</li>
</ul>
<h3 id="numpy-char-splitlines"><a href="#numpy-char-splitlines" class="headerlink" title="numpy.char.splitlines()"></a>numpy.char.splitlines()</h3><ul>
<li><p>numpy.char.splitlines() 函数以换行符作为分隔符来分割字符串，并返回数组。</p>
</li>
<li><p>\n，\r，\r\n 都可用作换行符。</p>
</li>
</ul>
<h3 id="numpy-char-strip"><a href="#numpy-char-strip" class="headerlink" title="numpy.char.strip()"></a>numpy.char.strip()</h3><ul>
<li>numpy.char.strip() 函数用于移除开头或结尾处的特定字符。</li>
</ul>
<h3 id="numpy-char-join"><a href="#numpy-char-join" class="headerlink" title="numpy.char.join()"></a>numpy.char.join()</h3><ul>
<li>numpy.char.join() 函数通过指定分隔符来连接数组中的元素或字符串。</li>
</ul>
<h3 id="numpy-char-replace"><a href="#numpy-char-replace" class="headerlink" title="numpy.char.replace()"></a>numpy.char.replace()</h3><ul>
<li>numpy.char.replace() 函数使用新字符串替换字符串中的所有子字符串。</li>
</ul>
<h3 id="numpy-char-encode"><a href="#numpy-char-encode" class="headerlink" title="numpy.char.encode()"></a>numpy.char.encode()</h3><ul>
<li>numpy.char.encode() 函数对数组中的每个元素调用 str.encode 函数。 默认编码是 utf-8，可以使用标准 Python 库中的编解码器。</li>
</ul>
<h3 id="numpy-char-decode"><a href="#numpy-char-decode" class="headerlink" title="numpy.char.decode()"></a>numpy.char.decode()</h3><ul>
<li>numpy.char.decode() 函数对编码的元素进行 str.decode() 解码。</li>
</ul>
<h2 id="NumPy-数学函数"><a href="#NumPy-数学函数" class="headerlink" title="NumPy 数学函数"></a>NumPy 数学函数</h2><p>NumPy 包含大量的各种数学运算的函数，包括三角函数，算术运算的函数，复数处理函数等</p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><ul>
<li><p>NumPy 提供了标准的三角函数：sin()、cos()、tan()。</p>
</li>
<li><p>arcsin，arccos，和 arctan 函数返回给定角度的 sin，cos 和 tan 的反三角函数。</p>
</li>
<li><p>这些函数的结果可以通过 numpy.degrees() 函数将弧度转换为角度。</p>
</li>
</ul>
<h3 id="舍入函数"><a href="#舍入函数" class="headerlink" title="舍入函数"></a>舍入函数</h3><h4 id="numpy-around"><a href="#numpy-around" class="headerlink" title="numpy.around()"></a>numpy.around()</h4><p>函数返回指定数字的四舍五入值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.around(a,decimals)</span><br><span class="line"><span class="comment">#  a: 数组</span></span><br><span class="line"><span class="comment"># decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-floor"><a href="#numpy-floor" class="headerlink" title="numpy.floor()"></a>numpy.floor()</h4><p>numpy.floor() 返回小于或者等于指定表达式的最大整数，即向下取整。</p>
<h4 id="numpy-ceil"><a href="#numpy-ceil" class="headerlink" title="numpy.ceil()"></a>numpy.ceil()</h4><p>numpy.ceil() 返回大于或者等于指定表达式的最小整数，即向上取整。</p>
<h2 id="NumPy-算术函数"><a href="#NumPy-算术函数" class="headerlink" title="NumPy 算术函数"></a>NumPy 算术函数</h2><ul>
<li><p>NumPy 算术函数包含简单的加减乘除: add()，subtract()，multiply() 和 divide()。</p>
</li>
<li><p>需要注意的是数组必须具有相同的形状或符合数组广播规则。</p>
</li>
</ul>
<ul>
<li>此外 Numpy 也包含了其他重要的算术函数。</li>
</ul>
<h3 id="numpy-reciprocal"><a href="#numpy-reciprocal" class="headerlink" title="numpy.reciprocal()"></a>numpy.reciprocal()</h3><p>numpy.reciprocal() 函数返回参数逐元素的倒数。如 1/4 倒数为 4/1。</p>
<h4 id="numpy-power"><a href="#numpy-power" class="headerlink" title="numpy.power()"></a>numpy.power()</h4><p>numpy.power() 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p>
<h4 id="numpy-mod"><a href="#numpy-mod" class="headerlink" title="numpy.mod()"></a>numpy.mod()</h4><p>numpy.mod() 计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder() 也产生相同的结果。</p>
<h2 id="NumPy-统计函数"><a href="#NumPy-统计函数" class="headerlink" title="NumPy 统计函数"></a>NumPy 统计函数</h2><p>NumPy 提供了很多统计函数，用于从数组中查找最小元素，最大元素，百分位标准差和方差等。 函数说明如下：</p>
<h3 id="numpy-amin-和-numpy-amax"><a href="#numpy-amin-和-numpy-amax" class="headerlink" title="numpy.amin() 和 numpy.amax()"></a>numpy.amin() 和 numpy.amax()</h3><ul>
<li><p>numpy.amin() 用于计算数组中的元素沿指定轴的最小值。</p>
</li>
<li><p>numpy.amax() 用于计算数组中的元素沿指定轴的最大值。</p>
</li>
</ul>
<h3 id="numpy-ptp"><a href="#numpy-ptp" class="headerlink" title="numpy.ptp()"></a>numpy.ptp()</h3><ul>
<li>numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</li>
</ul>
<h3 id="numpy-percentile"><a href="#numpy-percentile" class="headerlink" title="numpy.percentile()"></a>numpy.percentile()</h3><ul>
<li>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数numpy.percentile()接受以下参数。</li>
</ul>
<h3 id="numpy-percentile-a-q-axis"><a href="#numpy-percentile-a-q-axis" class="headerlink" title="numpy.percentile(a, q, axis)"></a>numpy.percentile(a, q, axis)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> numpy.percentile(a, q, axis) </span><br><span class="line"><span class="comment"># a: 输入数组</span></span><br><span class="line"><span class="comment"># q: 要计算的百分位数，在 0 ~ 100 之间</span></span><br><span class="line"><span class="comment"># axis: 沿着它计算百分位数的轴</span></span><br></pre></td></tr></table></figure>


<p>首先明确百分位数：</p>
<p>​    第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。</p>
<p>​    举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。这里的 p = 70。</p>
<h3 id="numpy-median"><a href="#numpy-median" class="headerlink" title="numpy.median()"></a>numpy.median()</h3><p>numpy.median() 函数用于计算数组 a 中元素的中位数（中值）</p>
<h4 id="numpy-mean"><a href="#numpy-mean" class="headerlink" title="numpy.mean()"></a>numpy.mean()</h4><p>numpy.mean() 函数返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。</p>
<p>算术平均值是沿轴的元素的总和除以元素的数量。</p>
<h4 id="numpy-average"><a href="#numpy-average" class="headerlink" title="numpy.average()"></a>numpy.average()</h4><p>numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。</p>
<h3 id="numpy-std"><a href="#numpy-std" class="headerlink" title="numpy.std()"></a>numpy.std()</h3><p>求标准差</p>
<h3 id="numpy-var"><a href="#numpy-var" class="headerlink" title="numpy.var()"></a>numpy.var()</h3><p>统计中的方差</p>
<h2 id="NumPy-排序、条件刷选函数"><a href="#NumPy-排序、条件刷选函数" class="headerlink" title="NumPy 排序、条件刷选函数"></a>NumPy 排序、条件刷选函数</h2><p>NumPy 提供了多种排序的方法。 这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>速度</th>
<th>最坏情况</th>
<th>工作空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;quicksort&#39;</code>（快速排序）</td>
<td>1</td>
<td><code>O(n^2)</code></td>
<td>0</td>
<td>否</td>
</tr>
<tr>
<td><code>&#39;mergesort&#39;</code>（归并排序）</td>
<td>2</td>
<td><code>O(n*log(n))</code></td>
<td>~n/2</td>
<td>是</td>
</tr>
<tr>
<td><code>&#39;heapsort&#39;</code>（堆排序）</td>
<td>3</td>
<td><code>O(n*log(n))</code></td>
<td>0</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="numpy-sort"><a href="#numpy-sort" class="headerlink" title="numpy.sort()"></a>numpy.sort()</h3><p>numpy.sort() 函数返回输入数组的排序副本。函数格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.sort(a, axis, kind, order)</span><br><span class="line"><span class="comment">#a: 要排序的数组</span></span><br><span class="line"><span class="comment"># axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序</span></span><br><span class="line"><span class="comment"># kind: 默认为’quicksort’（快速排序）</span></span><br><span class="line"><span class="comment"># order: 如果数组包含字段，则是要排序的字段</span></span><br></pre></td></tr></table></figure>

<h3 id="numpy-argsort"><a href="#numpy-argsort" class="headerlink" title="numpy.argsort()"></a>numpy.argsort()</h3><p>numpy.argsort() 函数返回的是数组值从小到大的索引值。</p>
<h3 id="numpy-lexsort"><a href="#numpy-lexsort" class="headerlink" title="numpy.lexsort()"></a>numpy.lexsort()</h3><p>numpy.lexsort() 用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p>
<p>这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p>
<h3 id="msort、sort-complex、partition、argpartition"><a href="#msort、sort-complex、partition、argpartition" class="headerlink" title="msort、sort_complex、partition、argpartition"></a>msort、sort_complex、partition、argpartition</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>msort(a)</td>
<td>数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis=0)。</td>
</tr>
<tr>
<td>sort_complex(a)</td>
<td>对复数按照先实部后虚部的顺序进行排序。</td>
</tr>
<tr>
<td>partition(a, kth[, axis, kind, order])</td>
<td>指定一个数，对数组进行分区</td>
</tr>
<tr>
<td>argpartition(a, kth[, axis, kind, order])</td>
<td>可以通过关键字 kind 指定算法沿着指定轴对数组进行分区</td>
</tr>
</tbody></table>
<h3 id="numpy-argmax-和-numpy-argmin"><a href="#numpy-argmax-和-numpy-argmin" class="headerlink" title="numpy.argmax() 和 numpy.argmin()"></a>numpy.argmax() 和 numpy.argmin()</h3><p>​    numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引。</p>
<h3 id="numpy-nonzero"><a href="#numpy-nonzero" class="headerlink" title="numpy.nonzero()"></a>numpy.nonzero()</h3><p>​    numpy.nonzero() 函数返回输入数组中非零元素的索引。</p>
<h3 id="numpy-where"><a href="#numpy-where" class="headerlink" title="numpy.where()"></a>numpy.where()</h3><p>​    numpy.where() 函数返回输入数组中满足给定条件的元素的索引。</p>
<h3 id="numpy-extract"><a href="#numpy-extract" class="headerlink" title="numpy.extract()"></a>numpy.extract()</h3><p>​    numpy.extract() 函数根据某个条件从数组中抽取元素，返回满条件的元素。</p>
<h2 id="NumPy-字节交换"><a href="#NumPy-字节交换" class="headerlink" title="NumPy 字节交换"></a>NumPy 字节交换</h2><p>​    在几乎所有的机器上，多字节对象都被存储为连续的字节序列。字节顺序，是跨越多字节的程序对象的存储规则。</p>
<p>​    <strong>大端模式：</strong>指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。<br>​    <strong>小端模式：</strong>指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。<br>例如在 C 语言中，一个类型为 int 的变量 x 地址为 0x100，那么其对应地址表达式&amp;x的值为 0x100。且x的四个字节将被存储在存储器的 0x100, 0x101, 0x102, 0x103位置。</p>
<p><strong>numpy.ndarray.byteswap()</strong></p>
<p>​    numpy.ndarray.byteswap() 函数将 ndarray 中每个元素中的字节进行大小端转换。</p>
<h2 id="NumPy-副本和视图"><a href="#NumPy-副本和视图" class="headerlink" title="NumPy 副本和视图"></a>NumPy 副本和视图</h2><ul>
<li><p>副本是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。</p>
</li>
<li><p>视图是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。</p>
</li>
</ul>
<ul>
<li><p>视图一般发生在：</p>
<ul>
<li>numpy 的切片操作返回原数据的视图。</li>
<li>调用 ndarray 的 view() 函数产生一个视图。</li>
</ul>
</li>
<li><p>副本一般发生在：</p>
<ul>
<li><p>Python 序列的切片操作，调用deepCopy()函数。</p>
</li>
<li><p>调用 ndarray 的 copy() 函数产生一个副本。</p>
</li>
</ul>
</li>
</ul>
<h3 id="无复制"><a href="#无复制" class="headerlink" title="无复制"></a>无复制</h3><p>​    简单的赋值不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 id()返回 Python 对象的通用标识符，类似于 C 中的指针。</p>
<p>此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p>
<h4 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h4><p>ndarray.view() 方会创建一个新的数组对象，该方法创建的新数组的维数更改不会更改原始数据的维数。使用切片创建视图修改数据会影响到原始数组。</p>
<h4 id="副本或深拷贝"><a href="#副本或深拷贝" class="headerlink" title="副本或深拷贝"></a>副本或深拷贝</h4><p>ndarray.copy() 函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。</p>
<h3 id="Python-append-与深拷贝、浅拷贝"><a href="#Python-append-与深拷贝、浅拷贝" class="headerlink" title="Python append() 与深拷贝、浅拷贝"></a>Python append() 与深拷贝、浅拷贝</h3><h4 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h4><p>在 Python 中，对象赋值实际上是对象的引用。当创建一个对象，然后把它赋给另一个变量的时候，Python 并没有拷贝这个对象，而只是拷贝了这个对象的引用，我们称之为浅拷贝。</p>
<p>在 Python 中，为了使当进行赋值操作时，两个变量互补影响，可以使用 copy 模块中的 deepcopy 方法，称之为深拷贝。</p>
<h4 id="append-函数"><a href="#append-函数" class="headerlink" title="append() 函数"></a>append() 函数</h4><p>当 list 类型的对象进行 append 操作时，实际上追加的是该对象的引用。</p>
<p>id() 函数：返回对象的唯一标识，可以类比成该对象在内存中的地址。</p>
<h2 id="NumPy-矩阵库-Matrix"><a href="#NumPy-矩阵库-Matrix" class="headerlink" title="NumPy 矩阵库(Matrix)"></a>NumPy 矩阵库(Matrix)</h2><p>NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。</p>
<p>一个m × n  的矩阵是一个由 $ m $ 行（row）列 $ n $（column）元素排列成的矩形阵列。</p>
<p>矩阵里的元素可以是数字、符号或数学式。</p>
<h3 id="matlib-empty"><a href="#matlib-empty" class="headerlink" title="matlib.empty()"></a>matlib.empty()</h3><p>​    matlib.empty() 函数返回一个新的矩阵，语法格式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.matlib.empty(shape, dtype, order)</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># shape: 定义新矩阵形状的整数或整数元组</span></span><br><span class="line"><span class="comment"># Dtype: 可选，数据类型</span></span><br><span class="line"><span class="comment"># order: C（行序优先） 或者 F（列序优先）numpy.matlib.zeros()</span></span><br><span class="line">numpy.matlib.zeros() 函数创建一个以 <span class="number">0</span> 填充的矩阵。</span><br></pre></td></tr></table></figure>

<h3 id="numpy-matlib-ones"><a href="#numpy-matlib-ones" class="headerlink" title="numpy.matlib.ones()"></a>numpy.matlib.ones()</h3><p>​    numpy.matlib.ones()函数创建一个以 1 填充的矩阵。</p>
<h3 id="numpy-matlib-eye"><a href="#numpy-matlib-eye" class="headerlink" title="numpy.matlib.eye()"></a>numpy.matlib.eye()</h3><p>​    numpy.matlib.eye() 函数返回一个矩阵，对角线元素为 1，其他位置为零。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.matlib.eye(n, M,k, dtype)</span><br><span class="line"><span class="comment"># n: 返回矩阵的行数</span></span><br><span class="line"><span class="comment"># M: 返回矩阵的列数，默认为 n</span></span><br><span class="line"><span class="comment"># k: 对角线的索引</span></span><br><span class="line"><span class="comment"># dtype: 数据类型</span></span><br></pre></td></tr></table></figure>

<h3 id="numpy-matlib-identity"><a href="#numpy-matlib-identity" class="headerlink" title="numpy.matlib.identity()"></a>numpy.matlib.identity()</h3><p>​    numpy.matlib.identity() 函数返回给定大小的单位矩阵。</p>
<p>​    单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。</p>
<p>​     <img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/20200327233848845.png" alt="在这里插入图片描述"> </p>
<h3 id="numpy-matlib-rand"><a href="#numpy-matlib-rand" class="headerlink" title="numpy.matlib.rand()"></a>numpy.matlib.rand()</h3><p>​    numpy.matlib.rand() 函数创建一个给定大小的矩阵，数据是随机填充的。</p>
<h2 id="NumPy-线性代数"><a href="#NumPy-线性代数" class="headerlink" title="NumPy 线性代数"></a>NumPy 线性代数</h2><p>NumPy 提供了线性代数函数库 <strong>linalg</strong>，该库包含了线性代数所需的所有功能，可以看看下面的说明：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>dot</code></td>
<td>两个数组的点积，即元素对应相乘。</td>
</tr>
<tr>
<td><code>vdot</code></td>
<td>两个向量的点积</td>
</tr>
<tr>
<td><code>inner</code></td>
<td>两个数组的内积</td>
</tr>
<tr>
<td><code>matmul</code></td>
<td>两个数组的矩阵积</td>
</tr>
<tr>
<td><code>determinant</code></td>
<td>数组的行列式</td>
</tr>
<tr>
<td><code>solve</code></td>
<td>求解线性矩阵方程</td>
</tr>
<tr>
<td><code>inv</code></td>
<td>计算矩阵的乘法逆矩阵</td>
</tr>
</tbody></table>
<h3 id="numpy-dot"><a href="#numpy-dot" class="headerlink" title="numpy.dot()"></a>numpy.dot()</h3><p>​    numpy.dot() 对于两个一维的数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为内积)；对于二维数组，计算的是两个数组的矩阵乘积；对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和： dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.dot(a, b, out=<span class="literal">None</span>) </span><br><span class="line"><span class="comment"># a : ndarray 数组</span></span><br><span class="line"><span class="comment"># b : ndarray 数组</span></span><br><span class="line"><span class="comment"># out : ndarray, 可选，用来保存dot()的计算结果</span></span><br></pre></td></tr></table></figure>

<h3 id="numpy-vdot"><a href="#numpy-vdot" class="headerlink" title="numpy.vdot()"></a>numpy.vdot()</h3><p>​    numpy.vdot() 函数是两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开。</p>
<h3 id="numpy-inner"><a href="#numpy-inner" class="headerlink" title="numpy.inner()"></a>numpy.inner()</h3><p>​    numpy.inner() 函数返回一维数组的向量内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p>
<h3 id="numpy-matmul"><a href="#numpy-matmul" class="headerlink" title="numpy.matmul"></a>numpy.matmul</h3><p>​    numpy.matmul 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。</p>
<p>​    另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。</p>
<h3 id="numpy-linalg-det"><a href="#numpy-linalg-det" class="headerlink" title="numpy.linalg.det()"></a>numpy.linalg.det()</h3><p>​    numpy.linalg.det() 函数计算输入矩阵的行列式。</p>
<p>​    行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。</p>
<p>​    换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为 ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。</p>
<h3 id="numpy-linalg-solve"><a href="#numpy-linalg-solve" class="headerlink" title="numpy.linalg.solve()"></a>numpy.linalg.solve()</h3><p>​    numpy.linalg.solve() 函数给出了矩阵形式的线性方程的解。</p>
<h3 id="numpy-linalg-inv"><a href="#numpy-linalg-inv" class="headerlink" title="numpy.linalg.inv()"></a>numpy.linalg.inv()</h3><p>​    numpy.linalg.inv() 函数计算矩阵的乘法逆矩阵。</p>
<p>​    <strong>逆矩阵（inverse matrix）</strong>：设A是数域上的一个n阶矩阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=E ，则我们称B是A的逆矩阵，而A则被称为可逆矩阵。注：E为单位矩阵。</p>
<h2 id="NumPy-IO"><a href="#NumPy-IO" class="headerlink" title="NumPy IO"></a>NumPy IO</h2><p>Numpy 可以读写磁盘上的文本数据或二进制数据。</p>
<p>NumPy 为 ndarray 对象引入了一个简单的文件格式：npy。</p>
<p>npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。</p>
<p>常用的 IO 函数有：</p>
<ul>
<li>load() 和 save() 函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。</li>
</ul>
<ul>
<li>savze() 函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。</li>
</ul>
<ul>
<li>loadtxt() 和 savetxt() 函数处理正常的文本文件(.txt 等)</li>
</ul>
<h3 id="numpy-save"><a href="#numpy-save" class="headerlink" title="numpy.save()"></a>numpy.save()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.save() 函数将数组保存到以 .npy 为扩展名的文件中。</span><br><span class="line"><span class="comment"># arr: 要保存的数组</span></span><br><span class="line"><span class="comment"># allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。</span></span><br><span class="line"><span class="comment"># fix_imports: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据。</span></span><br><span class="line"><span class="comment"># .npy是 Numpy 专用的二进制格式后的数据，可以使用 load() 函数来读取数据就可以正常显示。</span></span><br></pre></td></tr></table></figure>

<h3 id="numpy-savez"><a href="#numpy-savez" class="headerlink" title="numpy.savez"></a>numpy.savez</h3><p>​    numpy.savez() 函数将多个数组保存到以 npz 为扩展名的文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.savez(file, *args, **kwds)</span><br><span class="line"><span class="comment"># file：要保存的文件，扩展名为 .npz，如果文件路径末尾没有扩展名 .npz，该扩展名会被自动加上。</span></span><br><span class="line"><span class="comment"># args: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为 arr_0, arr_1, …　。</span></span><br><span class="line"><span class="comment"># kwds: 要保存的数组使用关键字名称。</span></span><br></pre></td></tr></table></figure>

<h3 id="numpy-savetxt"><a href="#numpy-savetxt" class="headerlink" title="numpy.savetxt()"></a>numpy.savetxt()</h3><p>​    savetxt() 函数是以简单的文本文件格式存储数据，对应的使用 loadtxt() 函数来获取数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.loadtxt(FILENAME, dtype=<span class="built_in">int</span>, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">np.savetxt(FILENAME, a, fmt=<span class="string">&quot;%d&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="comment"># 参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib笔记</title>
    <url>/2022/08/08/Matplotlib%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="matplotlib函数功能速查"><a href="#matplotlib函数功能速查" class="headerlink" title="matplotlib函数功能速查"></a>matplotlib函数功能速查</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>plt.plot(x,y,fmt,…)</td>
<td>绘制一个坐标图</td>
</tr>
<tr>
<td>plt.boxplot(data,notch,position)</td>
<td>绘制一个箱型图</td>
</tr>
<tr>
<td>plt.bar(left,height,width,bottom)</td>
<td>绘制一个条形图</td>
</tr>
<tr>
<td>plt.barh(width,bottom,left,height)</td>
<td>绘制一个横向条形图</td>
</tr>
<tr>
<td>plt.polar(theta,r)</td>
<td>绘制极坐标图</td>
</tr>
<tr>
<td>plt.pie(data,explode)</td>
<td>绘制饼图(explode接收一个列表,根据列表对应数据突出各部分内容)</td>
</tr>
<tr>
<td>plt.psd(x,NFFT=256,pad_to,Fs)</td>
<td>绘制功率谱密度图</td>
</tr>
<tr>
<td>plt.specgram(x,NFFT=256,pad,F)</td>
<td>绘制谱图</td>
</tr>
<tr>
<td>plt.cohere(x,y,NFFT=256,Fs)</td>
<td>绘制X-Y的相关性函数</td>
</tr>
<tr>
<td>plt.scatter(x,y)</td>
<td>绘制散点图,其中,x和y长度相同</td>
</tr>
<tr>
<td>plt.step(x,y,where)</td>
<td>绘制步阶图</td>
</tr>
<tr>
<td>plt.hist(x,bins,normed)</td>
<td>绘制直方图(bins表示直方图个数,当normed=1时,将数据出现次数转换成频率)</td>
</tr>
<tr>
<td>plt.contour(X,Y,Z,N)</td>
<td>绘制等值图</td>
</tr>
<tr>
<td>plt.vlines</td>
<td>绘制垂直图</td>
</tr>
<tr>
<td>plt.stem(x,y,linefmt,markerfmt)</td>
<td>绘制柴火图</td>
</tr>
<tr>
<td>plt.plot_date</td>
<td>绘制数据日期</td>
</tr>
</tbody></table>
<h3 id="matplotlib基本功能"><a href="#matplotlib基本功能" class="headerlink" title="matplotlib基本功能"></a>matplotlib基本功能</h3><ol>
<li>基本绘图 （在二维平面坐标系中绘制连续的线）<ol>
<li>设置线型、线宽和颜色  </li>
<li>设置坐标轴范围</li>
<li>设置坐标刻度</li>
<li>设置坐标轴</li>
<li>图例</li>
<li>特殊点</li>
<li>备注</li>
</ol>
</li>
<li>图形对象(图形窗口)<ol>
<li>子图</li>
<li>刻度定位器</li>
<li>刻度网格线</li>
<li>半对数坐标</li>
<li>散点图</li>
<li>填充</li>
<li>条形图</li>
<li>饼图</li>
<li>等高线图</li>
<li>热成像图</li>
<li>三维曲面</li>
<li>简单动画</li>
</ol>
</li>
</ol>
<h3 id="基本绘图"><a href="#基本绘图" class="headerlink" title="基本绘图"></a>基本绘图</h3><h4 id="绘图核心API"><a href="#绘图核心API" class="headerlink" title="绘图核心API"></a>绘图核心API</h4><p>案例：绘制一条余弦曲线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="comment"># xarray: &lt;序列&gt; 水平坐标序列</span></span><br><span class="line"><span class="comment"># yarray: &lt;序列&gt; 垂直坐标序列</span></span><br><span class="line">mp.plot(xarray, yarray)</span><br><span class="line"><span class="comment">#显示图表</span></span><br><span class="line">mp.show()</span><br></pre></td></tr></table></figure>

<p>绘制水平线与垂直线：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="comment"># vertical 绘制垂直线</span></span><br><span class="line">mp.vlines(vval, ymin, ymax, ...)</span><br><span class="line"><span class="comment"># horizotal 绘制水平线</span></span><br><span class="line">mp.hlines(xval, xmin, xmax, ...)</span><br><span class="line"><span class="comment">#显示图表</span></span><br><span class="line">mp.show()</span><br></pre></td></tr></table></figure>

<h4 id="线型、线宽和颜色"><a href="#线型、线宽和颜色" class="headerlink" title="线型、线宽和颜色"></a>线型、线宽和颜色</h4><p>案例：绘制一条正弦曲线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">	<span class="comment">#	数字</span></span><br><span class="line"><span class="comment">#color: &lt;关键字参数&gt; 颜色</span></span><br><span class="line">	<span class="comment">#	英文颜色单词 或 常见颜色英文单词首字母 或 #495434 或 (1,1,1) 或 (1,1,1,1)</span></span><br><span class="line"><span class="comment">#alpha: &lt;关键字参数&gt; 透明度</span></span><br><span class="line">	<span class="comment">#	浮点数值</span></span><br><span class="line">mp.plot(xarray, yarray, linestyle=<span class="string">&#x27;&#x27;</span>, linewidth=<span class="number">1</span>, color=<span class="string">&#x27;&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<h4 id="设置坐标轴范围"><a href="#设置坐标轴范围" class="headerlink" title="设置坐标轴范围"></a>设置坐标轴范围</h4><p>案例：把坐标轴范围设置为 -π ~ π</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#x_limt_min:	&lt;float&gt; x轴范围最小值</span></span><br><span class="line"><span class="comment">#x_limit_max:	&lt;float&gt; x轴范围最大值</span></span><br><span class="line">mp.xlim(x_limt_min, x_limit_max)</span><br><span class="line"><span class="comment">#y_limt_min:	&lt;float&gt; y轴范围最小值</span></span><br><span class="line"><span class="comment">#y_limit_max:	&lt;float&gt; y轴范围最大值</span></span><br><span class="line">mp.ylim(y_limt_min, y_limit_max)</span><br></pre></td></tr></table></figure>

<h4 id="设置坐标刻度"><a href="#设置坐标刻度" class="headerlink" title="设置坐标刻度"></a>设置坐标刻度</h4><p>案例：把横坐标的刻度显示为：0, π/2, π, 3π/2, 2π</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#x_val_list: 	x轴刻度值序列</span></span><br><span class="line"><span class="comment">#x_text_list:	x轴刻度标签文本序列 [可选]</span></span><br><span class="line">mp.xticks(x_val_list , x_text_list )</span><br><span class="line"><span class="comment">#y_val_list: 	y轴刻度值序列</span></span><br><span class="line"><span class="comment">#y_text_list:	y轴刻度标签文本序列 [可选]</span></span><br><span class="line">mp.yticks(y_val_list , y_text_list )</span><br></pre></td></tr></table></figure>

<p><em><strong>刻度文本的特殊语法</strong></em> – <em>LaTex排版语法字符串</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">r&#x27;$x^n+y^n=z^n$&#x27;</span>,   <span class="string">r&#x27;$\int\frac&#123;1&#125;&#123;x&#125; dx = \ln |x| + C$&#x27;</span>,     <span class="string">r&#x27;$-\frac&#123;\pi&#125;&#123;2&#125;$&#x27;</span></span><br></pre></td></tr></table></figure>

<p>$$<br>x^n+y^n=z^n,  \int\frac{1}{x} dx = \ln |x| + C, -\frac{\pi}{2}<br>$$</p>
<h4 id="设置坐标轴"><a href="#设置坐标轴" class="headerlink" title="设置坐标轴"></a>设置坐标轴</h4><p>坐标轴名：left / right / bottom / top</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取当前坐标轴字典，&#123;&#x27;left&#x27;:左轴,&#x27;right&#x27;:右轴,&#x27;bottom&#x27;:下轴,&#x27;top&#x27;:上轴 &#125;</span></span><br><span class="line">ax = mp.gca()</span><br><span class="line"><span class="comment"># 获取其中某个坐标轴</span></span><br><span class="line">axis = ax.spines[<span class="string">&#x27;坐标轴名&#x27;</span>]</span><br><span class="line"><span class="comment"># 设置坐标轴的位置。 该方法需要传入2个元素的元组作为参数</span></span><br><span class="line"><span class="comment"># type: &lt;<span class="built_in">str</span>&gt; 移动坐标轴的参照类型  一般为&#x27;data&#x27; (以数据的值作为移动参照值)</span></span><br><span class="line"><span class="comment"># val:  参照值</span></span><br><span class="line">axis.set_position((<span class="built_in">type</span>, val))</span><br><span class="line"><span class="comment"># 设置坐标轴的颜色</span></span><br><span class="line"><span class="comment"># color: &lt;str&gt; 颜色值字符串</span></span><br><span class="line">axis.set_color(color)</span><br></pre></td></tr></table></figure>

<p>案例：设置坐标轴至中心。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置坐标轴</span></span><br><span class="line">ax = mp.gca()</span><br><span class="line">axis_b = ax.spines[<span class="string">&#x27;bottom&#x27;</span>]</span><br><span class="line">axis_b.set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">axis_l = ax.spines[<span class="string">&#x27;left&#x27;</span>]</span><br><span class="line">axis_l.set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p>显示两条曲线的图例，并测试loc属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 再绘制曲线时定义曲线的label</span></span><br><span class="line"><span class="comment"># label: &lt;关键字参数 str&gt; 支持LaTex排版语法字符串</span></span><br><span class="line">mp.plot(xarray, yarray ... label=<span class="string">&#x27;&#x27;</span>, ...)</span><br><span class="line"><span class="comment"># 设置图例的位置</span></span><br><span class="line"><span class="comment"># loc: &lt;关键字参数&gt; 制定图例的显示位置 (若不设置loc，则显示默认位置)</span></span><br><span class="line"><span class="comment">#	 ===============   =============</span></span><br><span class="line"><span class="comment">#    Location String   Location Code</span></span><br><span class="line"><span class="comment">#    ===============   =============</span></span><br><span class="line"><span class="comment">#    &#x27;best&#x27;            0</span></span><br><span class="line"><span class="comment">#    &#x27;upper right&#x27;     1</span></span><br><span class="line"><span class="comment">#    &#x27;upper left&#x27;      2</span></span><br><span class="line"><span class="comment">#    &#x27;lower left&#x27;      3</span></span><br><span class="line"><span class="comment">#    &#x27;lower right&#x27;     4</span></span><br><span class="line"><span class="comment">#    &#x27;right&#x27;           5</span></span><br><span class="line"><span class="comment">#    &#x27;center left&#x27;     6</span></span><br><span class="line"><span class="comment">#    &#x27;center right&#x27;    7</span></span><br><span class="line"><span class="comment">#    &#x27;lower center&#x27;    8</span></span><br><span class="line"><span class="comment">#    &#x27;upper center&#x27;    9</span></span><br><span class="line"><span class="comment">#    &#x27;center&#x27;          10</span></span><br><span class="line"><span class="comment">#    ===============   =============</span></span><br><span class="line">mp.legend(loc=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="特殊点"><a href="#特殊点" class="headerlink" title="特殊点"></a>特殊点</h4><p>案例：绘制当x=3π/4时两条曲线上的特殊点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xarray: &lt;序列&gt; 所有需要标注点的水平坐标组成的序列</span></span><br><span class="line"><span class="comment"># yarray: &lt;序列&gt; 所有需要标注点的垂直坐标组成的序列</span></span><br><span class="line">mp.scatter(xarray, yarray, </span><br><span class="line">           marker=<span class="string">&#x27;&#x27;</span>, 		<span class="comment">#点型 ~ matplotlib.markers</span></span><br><span class="line">           s=<span class="string">&#x27;&#x27;</span>, 			<span class="comment">#大小</span></span><br><span class="line">           edgecolor=<span class="string">&#x27;&#x27;</span>, 	<span class="comment">#边缘色</span></span><br><span class="line">           facecolor=<span class="string">&#x27;&#x27;</span>,	<span class="comment">#填充色</span></span><br><span class="line">           zorder=<span class="number">3</span>			<span class="comment">#绘制图层编号 （编号越大，图层越靠上）</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>marker点型可参照：help(matplotlib.markers)</em></p>
<p><em>也可参照附录： matplotlib point样式</em></p>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>案例：为在某条曲线上的点添加备注，指明函数方程与值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在图表中为某个点添加备注。包含备注文本，备注箭头等图像的设置。</span></span><br><span class="line">mp.annotate(</span><br><span class="line">    <span class="string">r&#x27;$\frac&#123;\pi&#125;&#123;2&#125;$&#x27;</span>,			<span class="comment">#备注中显示的文本内容</span></span><br><span class="line">    xycoords=<span class="string">&#x27;data&#x27;</span>,			<span class="comment">#备注目标点所使用的坐标系（data表示数据坐标系）</span></span><br><span class="line">    xy=(x, y),	 				<span class="comment">#备注目标点的坐标</span></span><br><span class="line">    textcoords=<span class="string">&#x27;offset points&#x27;</span>,	<span class="comment">#备注文本所使用的坐标系（offset points表示参照点的偏移坐标系）</span></span><br><span class="line">    xytext=(x, y),				<span class="comment">#备注文本的坐标</span></span><br><span class="line">    fontsize=<span class="number">14</span>,				<span class="comment">#备注文本的字体大小</span></span><br><span class="line">    arrowprops=<span class="built_in">dict</span>()			<span class="comment">#使用字典定义文本指向目标点的箭头样式</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>arrowprops参数使用字典定义指向目标点的箭头样式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#arrowprops字典参数的常用key</span></span><br><span class="line">arrowprops=<span class="built_in">dict</span>(</span><br><span class="line">	arrowstyle=<span class="string">&#x27;&#x27;</span>,		<span class="comment">#定义箭头样式</span></span><br><span class="line">    connectionstyle=<span class="string">&#x27;&#x27;</span>	<span class="comment">#定义连接线的样式</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>箭头样式（arrowstyle）字符串如下</p>
<pre><code>============   =============================================
Name           Attrs
============   =============================================
  &#39;-&#39;          None
  &#39;-&gt;&#39;         head_length=0.4,head_width=0.2
  &#39;-[&#39;         widthB=1.0,lengthB=0.2,angleB=None
  &#39;|-|&#39;        widthA=1.0,widthB=1.0
  &#39;-|&gt;&#39;        head_length=0.4,head_width=0.2
  &#39;&lt;-&#39;         head_length=0.4,head_width=0.2
  &#39;&lt;-&gt;&#39;        head_length=0.4,head_width=0.2
  &#39;&lt;|-&#39;        head_length=0.4,head_width=0.2
  &#39;&lt;|-|&gt;&#39;      head_length=0.4,head_width=0.2
  &#39;fancy&#39;      head_length=0.4,head_width=0.4,tail_width=0.4
  &#39;simple&#39;     head_length=0.5,head_width=0.5,tail_width=0.2
  &#39;wedge&#39;      tail_width=0.3,shrink_factor=0.5
============   =============================================
</code></pre>
<p>连接线样式（connectionstyle）字符串如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">============   =============================================</span><br><span class="line">Name           Attrs</span><br><span class="line">============   =============================================</span><br><span class="line">  &#x27;angle&#x27; 		angleA=90,angleB=0,rad=0.0</span><br><span class="line">  &#x27;angle3&#x27; 		angleA=90,angleB=0`   </span><br><span class="line">  &#x27;arc&#x27;			angleA=0,angleB=0,armA=None,armB=None,rad=0.0</span><br><span class="line">  &#x27;arc3&#x27; 		rad=0.0</span><br><span class="line">  &#x27;bar&#x27; 		armA=0.0,armB=0.0,fraction=0.3,angle=None</span><br><span class="line">============   =============================================</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="图形对象（图形窗口）"><a href="#图形对象（图形窗口）" class="headerlink" title="图形对象（图形窗口）"></a>图形对象（图形窗口）</h3><p>案例：绘制两个窗口，一起显示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动构建 matplotlib 窗口</span></span><br><span class="line">mp.figure(</span><br><span class="line">    <span class="string">&#x27;&#x27;</span>,					<span class="comment">#窗口标题栏文本 </span></span><br><span class="line">    figsize=(<span class="number">4</span>, <span class="number">3</span>),		<span class="comment">#窗口大小 &lt;元组&gt;</span></span><br><span class="line">    dpi=<span class="number">120</span>,			<span class="comment">#像素密度</span></span><br><span class="line">	facecolor=<span class="string">&#x27;&#x27;</span>		<span class="comment">#图表背景色</span></span><br><span class="line">)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mp.figure方法不仅可以构建一个新窗口，如果已经构建过title=’xxx’的窗口，又使用figure方法构建了title=’xxx’ 的窗口的话，mp将不会创建新的窗口，而是把title=’xxx’的窗口置为当前操作窗口。</p>
<p><strong>设置当前窗口的参数</strong></p>
<p>案例：测试窗口相关参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置图表标题 显示在图表上方</span></span><br><span class="line">mp.title(title, fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 设置水平轴的文本</span></span><br><span class="line">mp.xlabel(x_label_str, fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 设置垂直轴的文本</span></span><br><span class="line">mp.ylabel(y_label_str, fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 设置刻度参数   labelsize设置刻度字体大小</span></span><br><span class="line">mp.tick_params(..., labelsize=<span class="number">8</span>, ...)</span><br><span class="line"><span class="comment"># 设置图表网格线  linestyle设置网格线的样式</span></span><br><span class="line">	<span class="comment">#	-  or solid 粗线</span></span><br><span class="line">	<span class="comment">#   -- or dashed 虚线</span></span><br><span class="line">	<span class="comment">#   -. or dashdot 点虚线</span></span><br><span class="line">	<span class="comment">#   :  or dotted 点线</span></span><br><span class="line">mp.grid(linestyle=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置紧凑布局，把图表相关参数都显示在窗口中</span></span><br><span class="line">mp.tight_layout() </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h4><p><strong>矩阵式布局</strong></p>
<p>绘制矩阵式子图布局相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Subplot Layout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"><span class="comment"># 拆分矩阵</span></span><br><span class="line">	<span class="comment"># rows:	行数</span></span><br><span class="line">    <span class="comment"># cols:	列数</span></span><br><span class="line">    <span class="comment"># num:	编号</span></span><br><span class="line">mp.subplot(rows, cols, num)</span><br><span class="line">	<span class="comment">#	1 2 3</span></span><br><span class="line">	<span class="comment">#	4 5 6</span></span><br><span class="line">	<span class="comment">#	7 8 9 </span></span><br><span class="line">mp.subplot(<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>)		<span class="comment">#操作3*3的矩阵中编号为5的子图</span></span><br><span class="line">mp.subplot(<span class="number">335</span>)			<span class="comment">#简写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制9宫格矩阵式子图，每个子图中写一个数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Subplot Layout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">	mp.subplot(<span class="number">3</span>, <span class="number">3</span>, i+<span class="number">1</span>)</span><br><span class="line">	mp.text(</span><br><span class="line">		<span class="number">0.5</span>, <span class="number">0.5</span>, i+<span class="number">1</span>, </span><br><span class="line">		ha=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">		va=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">		size=<span class="number">36</span>,</span><br><span class="line">		alpha=<span class="number">0.5</span>,</span><br><span class="line">		withdash=<span class="literal">False</span></span><br><span class="line">	)</span><br><span class="line">	mp.xticks([])</span><br><span class="line">	mp.yticks([])</span><br><span class="line"></span><br><span class="line">mp.tight_layout()</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>网格式布局</strong></p>
<p>网格式布局支持单元格的合并。</p>
<p>绘制网格式子图布局相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> mg</span><br><span class="line">mp.figure(<span class="string">&#x27;Grid Layout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"><span class="comment"># 调用GridSpec方法拆分网格式布局</span></span><br><span class="line"><span class="comment"># rows:	行数</span></span><br><span class="line"><span class="comment"># cols:	列数</span></span><br><span class="line"><span class="comment"># gs = mg.GridSpec(rows, cols)	拆分成3行3列</span></span><br><span class="line">gs = mg.GridSpec(<span class="number">3</span>, <span class="number">3</span>)	</span><br><span class="line"><span class="comment"># 合并0行与0、1列为一个子图表</span></span><br><span class="line">mp.subplot(gs[<span class="number">0</span>, :<span class="number">2</span>])</span><br><span class="line">mp.text(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">&#x27;1&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">36</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制一个自定义网格布局。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> mg</span><br><span class="line">mp.figure(<span class="string">&#x27;GridLayout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">gridsubs = mp.GridSpec(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 合并0行、0/1列为一个子图</span></span><br><span class="line">mp.subplot(gridsubs[<span class="number">0</span>, :<span class="number">2</span>])</span><br><span class="line">mp.text(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">36</span>)</span><br><span class="line">mp.tight_layout()</span><br><span class="line">mp.xticks([])</span><br><span class="line">mp.yticks([])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>自由式布局</strong></p>
<p>自由式布局相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Flow Layout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置图标的位置，给出左下角点坐标与宽高即可</span></span><br><span class="line"><span class="comment"># left_bottom_x: 坐下角点x坐标</span></span><br><span class="line"><span class="comment"># left_bottom_x: 坐下角点y坐标</span></span><br><span class="line"><span class="comment"># width:		 宽度</span></span><br><span class="line"><span class="comment"># height:		 高度</span></span><br><span class="line"><span class="comment"># mp.axes([left_bottom_x, left_bottom_y, width, height])</span></span><br><span class="line">mp.axes([<span class="number">0.03</span>, <span class="number">0.03</span>, <span class="number">0.94</span>, <span class="number">0.94</span>])</span><br><span class="line">mp.text(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">&#x27;1&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">36</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：测试自由式布局，定位子图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;FlowLayout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mp.axes([<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">0.3</span>])</span><br><span class="line">mp.text(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">36</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="刻度定位器"><a href="#刻度定位器" class="headerlink" title="刻度定位器"></a>刻度定位器</h4><p>刻度定位器相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取当前坐标轴</span></span><br><span class="line">ax = mp.gca()</span><br><span class="line"><span class="comment"># 设置水平坐标轴的主刻度定位器</span></span><br><span class="line">ax.xaxis.set_major_locator(mp.NullLocator())</span><br><span class="line"><span class="comment"># 设置水平坐标轴的次刻度定位器为多点定位器，间隔0.1</span></span><br><span class="line">ax.xaxis.set_minor_locator(mp.MultipleLocator(<span class="number">0.1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制一个数轴。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Locators&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取当前坐标轴</span></span><br><span class="line">ax = mp.gca()</span><br><span class="line"><span class="comment"># 隐藏除底轴以外的所有坐标轴</span></span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="comment"># 将底坐标轴调整到子图中心位置</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 设置水平坐标轴的主刻度定位器</span></span><br><span class="line">ax.xaxis.set_major_locator(mp.NullLocator())</span><br><span class="line"><span class="comment"># 设置水平坐标轴的次刻度定位器为多点定位器，间隔0.1</span></span><br><span class="line">ax.xaxis.set_minor_locator(mp.MultipleLocator(<span class="number">0.1</span>))</span><br><span class="line"><span class="comment"># 标记所用刻度定位器类名 </span></span><br><span class="line">mp.text(<span class="number">5</span>, <span class="number">0.3</span>, <span class="string">&#x27;NullLocator()&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">12</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：使用for循环测试刻度器样式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">locators = [<span class="string">&#x27;mp.NullLocator()&#x27;</span>, <span class="string">&#x27;mp.MaxNLocator(nbins=4)&#x27;</span>]</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> i, locator <span class="keyword">in</span> <span class="built_in">enumerate</span>(locators):</span><br><span class="line">    mp.subplot(<span class="built_in">len</span>(locators), <span class="number">1</span>, i+<span class="number">1</span>)</span><br><span class="line">	mp.xlim(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">	mp.ylim(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">	mp.yticks([])</span><br><span class="line">	<span class="comment"># 获取当前坐标轴</span></span><br><span class="line">	ax = mp.gca()</span><br><span class="line">	<span class="comment"># 隐藏除底轴以外的所有坐标轴</span></span><br><span class="line">	ax.spines[<span class="string">&#x27;left&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">	ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">	ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">	<span class="comment"># 将底坐标轴调整到子图中心位置</span></span><br><span class="line">	ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">	<span class="comment"># 设置水平坐标轴的主刻度定位器</span></span><br><span class="line">	ax.xaxis.set_major_locator(<span class="built_in">eval</span>( ))</span><br><span class="line">	<span class="comment"># 设置水平坐标轴的次刻度定位器为多点定位器，间隔0.1</span></span><br><span class="line">	ax.xaxis.set_minor_locator(mp.MultipleLocator(<span class="number">0.1</span>))</span><br><span class="line">	mp.plot(np.arange(<span class="number">11</span>), np.zeros(<span class="number">11</span>), c=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">	<span class="comment"># 标记所用刻度定位器类名</span></span><br><span class="line">	mp.text(<span class="number">5</span>, <span class="number">0.3</span>, locator, ha=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">12</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>常用刻度器如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 空定位器：不绘制刻度</span></span><br><span class="line">mp.NullLocator()</span><br><span class="line"><span class="comment"># 最大值定位器：</span></span><br><span class="line"><span class="comment"># 最多绘制nbins+1个刻度</span></span><br><span class="line">mp.MaxNLocator(nbins=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 定点定位器：根据locs参数中的位置绘制刻度</span></span><br><span class="line">mp.FixedLocator(locs=[<span class="number">0</span>, <span class="number">2.5</span>, <span class="number">5</span>, <span class="number">7.5</span>, <span class="number">10</span>])</span><br><span class="line"><span class="comment"># 自动定位器：由系统自动选择刻度的绘制位置</span></span><br><span class="line">mp.AutoLocator()</span><br><span class="line"><span class="comment"># 索引定位器：由offset确定起始刻度，由base确定相邻刻度的间隔</span></span><br><span class="line">mp.IndexLocator(offset=<span class="number">0.5</span>, base=<span class="number">1.5</span>)</span><br><span class="line"><span class="comment"># 多点定位器：从0开始，按照参数指定的间隔(缺省1)绘制刻度</span></span><br><span class="line">mp.MultipleLocator()</span><br><span class="line"><span class="comment"># 线性定位器：等分numticks-1份，绘制numticks个刻度</span></span><br><span class="line">mp.LinearLocator(numticks=<span class="number">21</span>)</span><br><span class="line"><span class="comment"># 对数定位器：以base为底，绘制刻度</span></span><br><span class="line">mp.LogLocator(base=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="刻度网格线"><a href="#刻度网格线" class="headerlink" title="刻度网格线"></a>刻度网格线</h4><p>绘制刻度网格线的相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax = mp.gca()</span><br><span class="line"><span class="comment">#绘制刻度网格线</span></span><br><span class="line">ax.grid(</span><br><span class="line">    which=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># &#x27;major&#x27;/&#x27;minor&#x27; &lt;-&gt; &#x27;主刻度&#x27;/&#x27;次刻度&#x27; </span></span><br><span class="line">    axis=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># &#x27;x&#x27;/&#x27;y&#x27;/&#x27;both&#x27; &lt;-&gt; 绘制x或y轴</span></span><br><span class="line">    linewidth=<span class="number">1</span>, 	<span class="comment"># 线宽</span></span><br><span class="line">    linestyle=<span class="string">&#x27;&#x27;</span>, 	<span class="comment"># 线型</span></span><br><span class="line">    color=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># 颜色</span></span><br><span class="line">	alpha=<span class="number">0.5</span>		<span class="comment"># 透明度</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制曲线 [1, 10, 100, 1000, 100, 10, 1]，然后设置刻度网格线，测试刻度网格线的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = np.array([<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">1</span>])</span><br><span class="line">mp.figure(<span class="string">&#x27;Normal &amp; Log&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.subplot(<span class="number">211</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;Normal&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">mp.ylabel(<span class="string">&#x27;y&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax = mp.gca()</span><br><span class="line">ax.xaxis.set_major_locator(mp.MultipleLocator(<span class="number">1.0</span>))</span><br><span class="line">ax.xaxis.set_minor_locator(mp.MultipleLocator(<span class="number">0.1</span>))</span><br><span class="line">ax.yaxis.set_major_locator(mp.MultipleLocator(<span class="number">250</span>))</span><br><span class="line">ax.yaxis.set_minor_locator(mp.MultipleLocator(<span class="number">50</span>))</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">ax.grid(which=<span class="string">&#x27;major&#x27;</span>, axis=<span class="string">&#x27;both&#x27;</span>, linewidth=<span class="number">0.75</span>,</span><br><span class="line">        linestyle=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">ax.grid(which=<span class="string">&#x27;minor&#x27;</span>, axis=<span class="string">&#x27;both&#x27;</span>, linewidth=<span class="number">0.25</span>,</span><br><span class="line">        linestyle=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">mp.plot(y, <span class="string">&#x27;o-&#x27;</span>, c=<span class="string">&#x27;dodgerblue&#x27;</span>, label=<span class="string">&#x27;plot&#x27;</span>)</span><br><span class="line">mp.legend()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="半对数坐标"><a href="#半对数坐标" class="headerlink" title="半对数坐标"></a>半对数坐标</h4><p>y轴将以指数方式递增。 基于半对数坐标绘制第二个子图，表示曲线：[1, 10, 100, 1000, 100, 10, 1]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Grid&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">1</span>]</span><br><span class="line">mp.semilogy(y)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h4><p>可以通过每个点的坐标、颜色、大小和形状表示不同的特征值。</p>
<table>
<thead>
<tr>
<th>身高</th>
<th>体重</th>
<th>性别</th>
<th>年龄段</th>
<th>种族</th>
</tr>
</thead>
<tbody><tr>
<td>180</td>
<td>80</td>
<td>男</td>
<td>中年</td>
<td>亚洲</td>
</tr>
<tr>
<td>160</td>
<td>50</td>
<td>女</td>
<td>青少</td>
<td>美洲</td>
</tr>
</tbody></table>
<p>绘制散点图的相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.scatter(</span><br><span class="line">    x, 					<span class="comment"># x轴坐标数组</span></span><br><span class="line">    y,					<span class="comment"># y轴坐标数组</span></span><br><span class="line">    marker=<span class="string">&#x27;&#x27;</span>, 			<span class="comment"># 点型</span></span><br><span class="line">    s=<span class="number">10</span>,				<span class="comment"># 大小</span></span><br><span class="line">    color=<span class="string">&#x27;&#x27;</span>,			<span class="comment"># 颜色</span></span><br><span class="line">    edgecolor=<span class="string">&#x27;&#x27;</span>, 		<span class="comment"># 边缘颜色</span></span><br><span class="line">    facecolor=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># 填充色</span></span><br><span class="line">    zorder=<span class="string">&#x27;&#x27;</span>			<span class="comment"># 图层序号</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>numpy.random提供了normal函数用于产生符合 正态分布 的随机数 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line"><span class="comment"># 172:	期望值</span></span><br><span class="line"><span class="comment"># 10:	标准差</span></span><br><span class="line"><span class="comment"># n:	数字生成数量</span></span><br><span class="line">x = np.random.normal(<span class="number">172</span>, <span class="number">20</span>, n)</span><br><span class="line">y = np.random.normal(<span class="number">60</span>, <span class="number">10</span>, n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制平面散点图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;scatter&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;scatter&#x27;</span>)</span><br><span class="line">mp.scatter(x, y)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置点的颜色</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.scatter(x, y, c=<span class="string">&#x27;red&#x27;</span>)			<span class="comment">#直接设置颜色</span></span><br><span class="line">d = (x-<span class="number">172</span>)**<span class="number">2</span> + (y-<span class="number">60</span>)**<span class="number">2</span></span><br><span class="line">mp.scatter(x, y, c=d, cmap=<span class="string">&#x27;jet&#x27;</span>)	<span class="comment">#以c作为参数，取cmap颜色映射表中的颜色值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>cmap颜色映射表参照附件：cmap颜色映射表</em></p>
<h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>以某种颜色自动填充两条曲线的闭合区域。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.fill_between(</span><br><span class="line">	x,				<span class="comment"># x轴的水平坐标</span></span><br><span class="line">    sin_x,			<span class="comment"># 下边界曲线上点的垂直坐标</span></span><br><span class="line">    cos_x,			<span class="comment"># 上边界曲线上点的垂直坐标</span></span><br><span class="line">    sin_x&lt;cos_x, 	<span class="comment"># 填充条件，为True时填充</span></span><br><span class="line">    color=<span class="string">&#x27;&#x27;</span>, 		<span class="comment"># 填充颜色</span></span><br><span class="line">    alpha=<span class="number">0.2</span>		<span class="comment"># 透明度</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制两条曲线： sin_x = sin(x)    cos_x = cos(x / 2) / 2    [0-8π]  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">1000</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">8</span> * np.pi, n)</span><br><span class="line">sin_y = np.sin(x)</span><br><span class="line">cos_y = np.cos(x / <span class="number">2</span>) / <span class="number">2</span></span><br><span class="line">mp.figure(<span class="string">&#x27;Fill&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;Fill&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">mp.xlabel(<span class="string">&#x27;x&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.ylabel(<span class="string">&#x27;y&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">mp.grid(linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">mp.plot(x, sin_y, c=<span class="string">&#x27;dodgerblue&#x27;</span>,</span><br><span class="line">        label=<span class="string">r&#x27;$y=sin(x)$&#x27;</span>)</span><br><span class="line">mp.plot(x, cos_y, c=<span class="string">&#x27;orangered&#x27;</span>,</span><br><span class="line">        label=<span class="string">r&#x27;$y=\frac&#123;1&#125;&#123;2&#125;cos(\frac&#123;x&#125;&#123;2&#125;)$&#x27;</span>)</span><br><span class="line">mp.fill_between(x, cos_y, sin_y, cos_y &lt; sin_y,</span><br><span class="line">                color=<span class="string">&#x27;dodgerblue&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">mp.fill_between(x, cos_y, sin_y, cos_y &gt; sin_y,</span><br><span class="line">                color=<span class="string">&#x27;orangered&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">mp.legend()</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="条形图（柱状图）"><a href="#条形图（柱状图）" class="headerlink" title="条形图（柱状图）"></a>条形图（柱状图）</h4><p>绘制柱状图的相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Bar&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.bar(</span><br><span class="line">	x,				<span class="comment"># 水平坐标数组</span></span><br><span class="line">    y,				<span class="comment"># 柱状图高度数组</span></span><br><span class="line">    width,			<span class="comment"># 柱子的宽度</span></span><br><span class="line">    color=<span class="string">&#x27;&#x27;</span>, 		<span class="comment"># 填充颜色</span></span><br><span class="line">    label=<span class="string">&#x27;&#x27;</span>,		<span class="comment">#</span></span><br><span class="line">    alpha=<span class="number">0.2</span>		<span class="comment">#</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：先以柱状图绘制苹果12个月的销量，然后再绘制橘子的销量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">apples = np.array([<span class="number">30</span>, <span class="number">25</span>, <span class="number">22</span>, <span class="number">36</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">33</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">15</span>])</span><br><span class="line">oranges = np.array([<span class="number">24</span>, <span class="number">33</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">35</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">32</span>, <span class="number">20</span>, <span class="number">22</span>])</span><br><span class="line">mp.figure(<span class="string">&#x27;Bar&#x27;</span>  , facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;Bar&#x27;</span>, font size=<span class="number">20</span>)</span><br><span class="line">mp.xlabel(<span class="string">&#x27;Month&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.ylabel(<span class="string">&#x27;Price&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">mp.grid(axis=<span class="string">&#x27;y&#x27;</span>, linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">mp.ylim((<span class="number">0</span>, <span class="number">40</span>))</span><br><span class="line">x = np.arange(<span class="built_in">len</span>(apples))</span><br><span class="line">mp.bar(x-<span class="number">0.2</span>, apples, <span class="number">0.4</span>, color=<span class="string">&#x27;dodgerblue&#x27;</span>,label=<span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">mp.bar(x + <span class="number">0.2</span>, oranges, <span class="number">0.4</span>, color=<span class="string">&#x27;orangered&#x27;</span>,label=<span class="string">&#x27;Orange&#x27;</span>, alpha=<span class="number">0.75</span>)</span><br><span class="line">mp.xticks(x, [</span><br><span class="line">    <span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>])</span><br><span class="line">mp.legend()</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p>绘制饼状图的基本API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.pie(</span><br><span class="line">    values, 		<span class="comment"># 值列表		</span></span><br><span class="line">    spaces, 		<span class="comment"># 扇形之间的间距列表</span></span><br><span class="line">    labels, 		<span class="comment"># 标签列表</span></span><br><span class="line">    colors, 		<span class="comment"># 颜色列表</span></span><br><span class="line">    <span class="string">&#x27;%d%%&#x27;</span>,			<span class="comment"># 标签所占比例格式</span></span><br><span class="line">	shadow=<span class="literal">True</span>, 	<span class="comment"># 是否显示阴影</span></span><br><span class="line">    startangle=<span class="number">90</span>	<span class="comment"># 逆时针绘制饼状图时的起始角度</span></span><br><span class="line">    radius=<span class="number">1</span>		<span class="comment"># 半径</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制饼状图显示5门语言的流行程度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;pie&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"><span class="comment">#整理数据</span></span><br><span class="line">values = [<span class="number">26</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">11</span>]</span><br><span class="line">spaces = [<span class="number">0.05</span>, <span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>]</span><br><span class="line">labels = [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>]</span><br><span class="line">colors = [<span class="string">&#x27;dodgerblue&#x27;</span>, <span class="string">&#x27;orangered&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;limegreen&#x27;</span>, <span class="string">&#x27;violet&#x27;</span>, <span class="string">&#x27;gold&#x27;</span>]</span><br><span class="line">mp.figure(<span class="string">&#x27;Pie&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;Pie&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 等轴比例</span></span><br><span class="line">mp.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">mp.pie(</span><br><span class="line">    values, 		<span class="comment"># 值列表		</span></span><br><span class="line">    spaces, 		<span class="comment"># 扇形之间的间距列表</span></span><br><span class="line">    labels, 		<span class="comment"># 标签列表</span></span><br><span class="line">    colors, 		<span class="comment"># 颜色列表</span></span><br><span class="line">    <span class="string">&#x27;%d%%&#x27;</span>,			<span class="comment"># 标签所占比例格式</span></span><br><span class="line">	shadow=<span class="literal">True</span>, 	<span class="comment"># 是否显示阴影</span></span><br><span class="line">    startanle=<span class="number">90</span>	<span class="comment"># 逆时针绘制饼状图时的起始角度</span></span><br><span class="line">    radius=<span class="number">1</span>		<span class="comment"># 半径</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="等高线图"><a href="#等高线图" class="headerlink" title="等高线图"></a>等高线图</h4><p>组成等高线需要网格点坐标矩阵，也需要每个点的高度。所以等高线属于3D数学模型范畴。</p>
<p>绘制等高线的相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.contourf(x, y, z, <span class="number">8</span>, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">cntr = mp.contour(</span><br><span class="line">    x, 					<span class="comment"># 网格坐标矩阵的x坐标 （2维数组）</span></span><br><span class="line">    y, 					<span class="comment"># 网格坐标矩阵的y坐标 （2维数组）</span></span><br><span class="line">    z, 					<span class="comment"># 网格坐标矩阵的z坐标 （2维数组）</span></span><br><span class="line">    <span class="number">8</span>, 					<span class="comment"># 把等高线绘制成8部分</span></span><br><span class="line">    colors=<span class="string">&#x27;black&#x27;</span>,		<span class="comment"># 等高线的颜色</span></span><br><span class="line">	linewidths=<span class="number">0.5</span>		<span class="comment"># 线宽</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>案例：生成网格坐标矩阵，并且绘制等高线：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 生成网格化坐标矩阵</span></span><br><span class="line">x, y = np.meshgrid(np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n),</span><br><span class="line">                   np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n))</span><br><span class="line"><span class="comment"># 根据每个网格点坐标，通过某个公式计算z高度坐标</span></span><br><span class="line">z = (<span class="number">1</span> - x/<span class="number">2</span> + x**<span class="number">5</span> + y**<span class="number">3</span>) * np.exp(-x**<span class="number">2</span> - y**<span class="number">2</span>)</span><br><span class="line">mp.figure(<span class="string">&#x27;Contour&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;Contour&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">mp.xlabel(<span class="string">&#x27;x&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.ylabel(<span class="string">&#x27;y&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">mp.grid(linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制等高线图</span></span><br><span class="line">mp.contourf(x, y, z, <span class="number">8</span>, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">cntr = mp.contour(x, y, z, <span class="number">8</span>, colors=<span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">                  linewidths=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 为等高线图添加高度标签</span></span><br><span class="line">mp.clabel(cntr, inline_spacing=<span class="number">1</span>, fmt=<span class="string">&#x27;%.1f&#x27;</span>,</span><br><span class="line">          fontsize=<span class="number">10</span>)</span><br><span class="line">mp.show()</span><br></pre></td></tr></table></figure>

<h4 id="热成像图"><a href="#热成像图" class="headerlink" title="热成像图"></a>热成像图</h4><p>用图形的方式显示矩阵及矩阵中值的大小<br>1 2 3<br>4 5 6<br>7 8 9</p>
<p>绘制热成像图的相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把矩阵z图形化，使用cmap表示矩阵中每个元素值的大小</span></span><br><span class="line"><span class="comment"># origin: 坐标轴方向</span></span><br><span class="line"><span class="comment">#    upper: 缺省值，原点在左上角</span></span><br><span class="line"><span class="comment">#    lower: 原点在左下角</span></span><br><span class="line">mp.imshow(z, cmap=<span class="string">&#x27;jet&#x27;</span>, origin=<span class="string">&#x27;low&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用颜色条显示热度值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.colorbar()</span><br></pre></td></tr></table></figure>

<h4 id="3D图像绘制"><a href="#3D图像绘制" class="headerlink" title="3D图像绘制"></a>3D图像绘制</h4><p> matplotlib支持绘制三维曲面。若希望绘制三维曲面，需要使用axes3d提供的3d坐标系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> axes3d</span><br><span class="line">ax3d = mp.gca(projection=<span class="string">&#x27;3d&#x27;</span>)   <span class="comment"># class axes3d</span></span><br></pre></td></tr></table></figure>

<p>matplotlib支持绘制三维点阵、三维曲面、三维线框图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax3d.scatter(..)		<span class="comment"># 绘制三维点阵</span></span><br><span class="line">ax3d.plot_surface(..)	<span class="comment"># 绘制三维曲面</span></span><br><span class="line">ax3d.plot_wireframe(..)	<span class="comment"># 绘制三维线框图</span></span><br></pre></td></tr></table></figure>

<p>3d散点图的绘制相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax3d.scatter(</span><br><span class="line">    x, 				<span class="comment"># x轴坐标数组</span></span><br><span class="line">    y,				<span class="comment"># y轴坐标数组</span></span><br><span class="line">    marker=<span class="string">&#x27;&#x27;</span>, 		<span class="comment"># 点型</span></span><br><span class="line">    s=<span class="number">10</span>,			<span class="comment"># 大小</span></span><br><span class="line">    zorder=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># 图层序号</span></span><br><span class="line">    color=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># 颜色</span></span><br><span class="line">    edgecolor=<span class="string">&#x27;&#x27;</span>, 	<span class="comment"># 边缘颜色</span></span><br><span class="line">    facecolor=<span class="string">&#x27;&#x27;</span>,	<span class="comment"># 填充色</span></span><br><span class="line">    c=v,			<span class="comment"># 颜色值 根据cmap映射应用相应颜色</span></span><br><span class="line">    cmap=<span class="string">&#x27;&#x27;</span>			<span class="comment"># </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>案例：随机生成3组坐标，程标准正态分布规则，并且绘制它们。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">1000</span></span><br><span class="line">x = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">z = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">d = np.sqrt(x ** <span class="number">2</span> + y ** <span class="number">2</span> + z ** <span class="number">2</span>)</span><br><span class="line">mp.figure(<span class="string">&#x27;3D Scatter&#x27;</span>)</span><br><span class="line">ax = mp.gca(projection=<span class="string">&#x27;3d&#x27;</span>)  <span class="comment"># 创建三维坐标系</span></span><br><span class="line">mp.title(<span class="string">&#x27;3D Scatter&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;z&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">ax.scatter(x, y, z, s=<span class="number">60</span>, c=d, cmap=<span class="string">&#x27;jet_r&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">mp.show()</span><br></pre></td></tr></table></figure>

<p>3d平面图的绘制相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax3d.plot_surface(</span><br><span class="line">    x, 					<span class="comment"># 网格坐标矩阵的x坐标 （2维数组）</span></span><br><span class="line">    y, 					<span class="comment"># 网格坐标矩阵的y坐标 （2维数组）</span></span><br><span class="line">    z, 					<span class="comment"># 网格坐标矩阵的z坐标 （2维数组）</span></span><br><span class="line">    rstride=<span class="number">30</span>,			<span class="comment"># 行跨距</span></span><br><span class="line">    cstride=<span class="number">30</span>, 		<span class="comment"># 列跨距</span></span><br><span class="line">    cmap=<span class="string">&#x27;jet&#x27;</span>			<span class="comment"># 颜色映射</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制3d平面图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 生成网格化坐标矩阵</span></span><br><span class="line">x, y = np.meshgrid(np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n),</span><br><span class="line">                   np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n))</span><br><span class="line"><span class="comment"># 根据每个网格点坐标，通过某个公式计算z高度坐标</span></span><br><span class="line">z = (<span class="number">1</span> - x/<span class="number">2</span> + x**<span class="number">5</span> + y**<span class="number">3</span>) * np.exp(-x**<span class="number">2</span> - y**<span class="number">2</span>)</span><br><span class="line">mp.figure(<span class="string">&#x27;3D&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax3d = mp.gca(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;3D&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">ax3d.set_xlabel(<span class="string">&#x27;x&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax3d.set_ylabel(<span class="string">&#x27;y&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax3d.set_zlabel(<span class="string">&#x27;z&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 绘制3D平面图</span></span><br><span class="line"><span class="comment"># rstride: 行跨距</span></span><br><span class="line"><span class="comment"># cstride: 列跨距 </span></span><br><span class="line">ax3d.plot_surface(x,y,z,rstride=<span class="number">30</span>,cstride=<span class="number">30</span>, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：3d线框图的绘制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制3D平面图 </span></span><br><span class="line"><span class="comment"># rstride: 行跨距</span></span><br><span class="line"><span class="comment"># cstride: 列跨距 </span></span><br><span class="line">ax3d.plot_wireframe(x,y,z,rstride=<span class="number">30</span>,cstride=<span class="number">30</span>, </span><br><span class="line">	linewidth=<span class="number">1</span>, color=<span class="string">&#x27;dodgerblue&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="简单动画"><a href="#简单动画" class="headerlink" title="简单动画"></a>简单动画</h4><p>动画即是在一段时间内快速连续的重新绘制图像的过程。</p>
<p>matplotlib提供了方法用于处理简单动画的绘制。定义update函数用于即时更新图像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.animation <span class="keyword">as</span> ma</span><br><span class="line"><span class="comment">#定义更新函数行为</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 每隔10毫秒执行一次update更新函数，作用于mp.gcf()当前窗口对象</span></span><br><span class="line"><span class="comment"># mp.gcf()：	获取当前窗口</span></span><br><span class="line"><span class="comment"># update：	更新函数</span></span><br><span class="line"><span class="comment"># interval：	间隔时间（单位：毫秒）</span></span><br><span class="line">anim = ma.FuncAnimation(mp.gcf(), update, interval=<span class="number">10</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：随机生成各种颜色的100个气泡。让他们不断的增大。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义一种可以存放在ndarray里的类型，用于保存一个球</span></span><br><span class="line">ball_type = np.dtype([</span><br><span class="line">	(<span class="string">&#x27;position&#x27;</span>, <span class="built_in">float</span>, <span class="number">2</span>),  <span class="comment"># 位置(水平和垂直坐标)</span></span><br><span class="line">    (<span class="string">&#x27;size&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>),      <span class="comment"># 大小</span></span><br><span class="line">    (<span class="string">&#x27;growth&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>),    <span class="comment"># 生长速度</span></span><br><span class="line">    (<span class="string">&#x27;color&#x27;</span>, <span class="built_in">float</span>, <span class="number">4</span>)])    <span class="comment"># 颜色(红、绿、蓝和透明度)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#随机生成100个点对象</span></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line">balls = np.zeros(<span class="number">100</span>, dtype=ball_type)</span><br><span class="line">balls[<span class="string">&#x27;position&#x27;</span>]=np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (n, <span class="number">2</span>))</span><br><span class="line">balls[<span class="string">&#x27;size&#x27;</span>]=np.random.uniform(<span class="number">40</span>, <span class="number">70</span>, n)</span><br><span class="line">balls[<span class="string">&#x27;growth&#x27;</span>]=np.random.uniform(<span class="number">10</span>, <span class="number">20</span>, n)</span><br><span class="line">balls[<span class="string">&#x27;color&#x27;</span>]=np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (n, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">mp.figure(<span class="string">&quot;Animation&quot;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&quot;Animation&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.xticks </span><br><span class="line">mp.yticks(())</span><br><span class="line"></span><br><span class="line">sc = mp.scatter(</span><br><span class="line">	balls[<span class="string">&#x27;position&#x27;</span>][:, <span class="number">0</span>], </span><br><span class="line">	balls[<span class="string">&#x27;position&#x27;</span>][:, <span class="number">1</span>], </span><br><span class="line">	balls[<span class="string">&#x27;size&#x27;</span>], </span><br><span class="line">	color=balls[<span class="string">&#x27;color&#x27;</span>], alpha=<span class="number">0.5</span>)</span><br><span class="line">	</span><br><span class="line"><span class="comment">#定义更新函数行为</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">number</span>):</span></span><br><span class="line">	balls[<span class="string">&#x27;size&#x27;</span>] += balls[<span class="string">&#x27;growth&#x27;</span>]</span><br><span class="line">	<span class="comment">#每次让一个气泡破裂，随机生成一个新的</span></span><br><span class="line">	boom_ind = number % n</span><br><span class="line">	balls[boom_ind][<span class="string">&#x27;size&#x27;</span>]=np.random.uniform(<span class="number">40</span>, <span class="number">70</span>, <span class="number">1</span>)</span><br><span class="line">	balls[boom_ind][<span class="string">&#x27;position&#x27;</span>]=np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">	<span class="comment"># 重新设置属性</span></span><br><span class="line">	sc.set_sizes(balls[<span class="string">&#x27;size&#x27;</span>])</span><br><span class="line">	sc.set_offsets(balls[<span class="string">&#x27;position&#x27;</span>])</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 每隔30毫秒执行一次update更新函数，作用于mp.gcf()当前窗口对象</span></span><br><span class="line"><span class="comment"># mp.gcf()：	获取当前窗口</span></span><br><span class="line"><span class="comment"># update：		更新函数</span></span><br><span class="line"><span class="comment"># interval：	间隔时间（单位：毫秒）</span></span><br><span class="line">anim = ma.FuncAnimation(mp.gcf(), update, interval=<span class="number">30</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用生成器函数提供数据，实现动画绘制</p>
<p>在很多情况下，绘制动画的参数是动态获取的，matplotlib支持定义generator生成器函数，用于生成数据，把生成的数据交给update函数更新图像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.animation <span class="keyword">as</span> ma</span><br><span class="line"><span class="comment">#定义更新函数行为</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">data</span>):</span></span><br><span class="line">    t, v = data</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span>():</span></span><br><span class="line">	<span class="keyword">yield</span> t, v</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 每隔10毫秒将会先调用生成器，获取生成器返回的数据，</span></span><br><span class="line"><span class="comment"># 把生成器返回的数据交给并且调用update函数，执行更新图像函数</span></span><br><span class="line">anim = ma.FuncAnimation(mp.gcf(), update, generator,interval=<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制信号曲线：y=sin(2 * π * t) * exp(sin(0.2 * π * t))，数据通过生成器函数生成，在update函数中绘制曲线。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&quot;Signal&quot;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&quot;Signal&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.xlim(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">mp.ylim(-<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">mp.grid(linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;lightgray&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">pl = mp.plot([], [], color=<span class="string">&#x27;dodgerblue&#x27;</span>, label=<span class="string">&#x27;Signal&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">pl.set_data([],[])</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">data</span>):</span></span><br><span class="line">	t, v = data</span><br><span class="line">	x, y = pl.get_data()</span><br><span class="line">	x.append(t)</span><br><span class="line">	y.append(v)</span><br><span class="line">	<span class="comment">#重新设置数据源</span></span><br><span class="line">	pl.set_data(x, y)</span><br><span class="line">	<span class="comment">#移动坐标轴</span></span><br><span class="line">	<span class="keyword">if</span>(x[-<span class="number">1</span>]&gt;<span class="number">10</span>):</span><br><span class="line">		mp.xlim(x[-<span class="number">1</span>]-<span class="number">10</span>, x[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y_generator</span>():</span></span><br><span class="line">	<span class="keyword">global</span> x</span><br><span class="line">	y = np.sin(<span class="number">2</span> * np.pi * x) * np.exp(np.sin(<span class="number">0.2</span> * np.pi * x))</span><br><span class="line">	<span class="keyword">yield</span> (x, y)</span><br><span class="line">	x += <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">anim = ma.FuncAnimation(mp.gcf(), update, y_generator, interval=<span class="number">20</span>)</span><br><span class="line">mp.tight_layout()</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas教程</title>
    <url>/2022/08/08/Pandas%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="pandas基础"><a href="#pandas基础" class="headerlink" title="pandas基础"></a>pandas基础</h2><h3 id="pandas介绍"><a href="#pandas介绍" class="headerlink" title="pandas介绍"></a>pandas介绍</h3><p>Python Data Analysis Library</p>
<p>pandas是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入 了大量库和一些标准的数据模型，提供了高效地操作大型结构化数据集所需的工具。</p>
<h3 id="pandas核心数据结构"><a href="#pandas核心数据结构" class="headerlink" title="pandas核心数据结构"></a>pandas核心数据结构</h3><p>数据结构是计算机存储、组织数据的方式。 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p>
<h4 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h4><p>Series可以理解为一个一维的数组，只是index名称可以自己改动。类似于定长的有序字典，有Index和 value。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空的系列</span></span><br><span class="line">s = pd.Series()</span><br><span class="line"><span class="comment"># 从ndarray创建一个系列</span></span><br><span class="line">data = np.array([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">s = pd.Series(data)</span><br><span class="line">s = pd.Series(data,index=[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>])</span><br><span class="line"><span class="comment"># 从字典创建一个系列	</span></span><br><span class="line">data = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">0.</span>, <span class="string">&#x27;b&#x27;</span> : <span class="number">1.</span>, <span class="string">&#x27;c&#x27;</span> : <span class="number">2.</span>&#125;</span><br><span class="line">s = pd.Series(data)</span><br><span class="line"><span class="comment"># 从标量创建一个系列</span></span><br><span class="line">s = pd.Series(<span class="number">5</span>, index=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h5 id="访问Series中的数据"><a href="#访问Series中的数据" class="headerlink" title="访问Series中的数据"></a>访问Series中的数据</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用索引检索元素</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>], s[:<span class="number">3</span>], s[-<span class="number">3</span>:])</span><br><span class="line"><span class="comment"># 使用标签检索数据</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;a&#x27;</span>], s[[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]])</span><br></pre></td></tr></table></figure>

<h5 id="pandas日期处理"><a href="#pandas日期处理" class="headerlink" title="pandas日期处理"></a>pandas日期处理</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pandas识别的日期字符串格式</span></span><br><span class="line">dates = pd.Series([<span class="string">&#x27;2011&#x27;</span>, <span class="string">&#x27;2011-02&#x27;</span>, <span class="string">&#x27;2011-03-01&#x27;</span>, <span class="string">&#x27;2011/04/01&#x27;</span>, </span><br><span class="line">                   <span class="string">&#x27;2011/05/01 01:01:01&#x27;</span>, <span class="string">&#x27;01 Jun 2011&#x27;</span>])</span><br><span class="line"><span class="comment"># to_datetime() 转换日期数据类型</span></span><br><span class="line">dates = pd.to_datetime(dates)</span><br><span class="line"><span class="built_in">print</span>(dates, dates.dtype, <span class="built_in">type</span>(dates))</span><br><span class="line"><span class="comment"># datetime类型数据支持日期运算</span></span><br><span class="line">delta = dates - pd.to_datetime(<span class="string">&#x27;1970-01-01&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取天数数值</span></span><br><span class="line"><span class="built_in">print</span>(delta.dt.days)</span><br></pre></td></tr></table></figure>

<p>Series.dt提供了很多日期相关操作，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Series.dt.year	The year of the datetime.</span><br><span class="line">Series.dt.month	The month <span class="keyword">as</span> January=<span class="number">1</span>, December=<span class="number">12.</span></span><br><span class="line">Series.dt.day	The days of the datetime.</span><br><span class="line">Series.dt.hour	The hours of the datetime.</span><br><span class="line">Series.dt.minute	The minutes of the datetime.</span><br><span class="line">Series.dt.second	The seconds of the datetime.</span><br><span class="line">Series.dt.microsecond	The microseconds of the datetime.</span><br><span class="line">Series.dt.week	The week ordinal of the year.</span><br><span class="line">Series.dt.weekofyear	The week ordinal of the year.</span><br><span class="line">Series.dt.dayofweek	The day of the week <span class="keyword">with</span> Monday=<span class="number">0</span>, Sunday=<span class="number">6.</span></span><br><span class="line">Series.dt.weekday	The day of the week <span class="keyword">with</span> Monday=<span class="number">0</span>, Sunday=<span class="number">6.</span></span><br><span class="line">Series.dt.dayofyear	The ordinal day of the year.</span><br><span class="line">Series.dt.quarter	The quarter of the date.</span><br><span class="line">Series.dt.is_month_start	Indicates whether the date <span class="keyword">is</span> the first day of the month.</span><br><span class="line">Series.dt.is_month_end	Indicates whether the date <span class="keyword">is</span> the last day of the month.</span><br><span class="line">Series.dt.is_quarter_start	Indicator <span class="keyword">for</span> whether the date <span class="keyword">is</span> the first day of a quarter.</span><br><span class="line">Series.dt.is_quarter_end	Indicator <span class="keyword">for</span> whether the date <span class="keyword">is</span> the last day of a quarter.</span><br><span class="line">Series.dt.is_year_start	Indicate whether the date <span class="keyword">is</span> the first day of a year.</span><br><span class="line">Series.dt.is_year_end	Indicate whether the date <span class="keyword">is</span> the last day of the year.</span><br><span class="line">Series.dt.is_leap_year	Boolean indicator <span class="keyword">if</span> the date belongs to a leap year.</span><br><span class="line">Series.dt.days_in_month	The number of days <span class="keyword">in</span> the month.</span><br></pre></td></tr></table></figure>



<h4 id="DateTimeIndex"><a href="#DateTimeIndex" class="headerlink" title="DateTimeIndex"></a>DateTimeIndex</h4><p>通过指定周期和频率，使用<code>date_range()</code>函数就可以创建日期序列。 默认情况下，范围的频率是天。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 以日为频率</span></span><br><span class="line">datelist = pd.date_range(<span class="string">&#x27;2019/08/21&#x27;</span>, periods=<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(datelist)</span><br><span class="line"><span class="comment"># 以月为频率</span></span><br><span class="line">datelist = pd.date_range(<span class="string">&#x27;2019/08/21&#x27;</span>, periods=<span class="number">5</span>,freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(datelist)</span><br><span class="line"><span class="comment"># 构建某个区间的时间序列</span></span><br><span class="line">start = pd.datetime(<span class="number">2017</span>, <span class="number">11</span>, <span class="number">1</span>)</span><br><span class="line">end = pd.datetime(<span class="number">2017</span>, <span class="number">11</span>, <span class="number">5</span>)</span><br><span class="line">dates = pd.date_range(start, end)</span><br><span class="line"><span class="built_in">print</span>(dates)</span><br></pre></td></tr></table></figure>

<p><code>bdate_range()</code>用来表示商业日期范围，不同于<code>date_range()</code>，它不包括星期六和星期天。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">datelist = pd.bdate_range(<span class="string">&#x27;2011/11/03&#x27;</span>, periods=<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(datelist)</span><br></pre></td></tr></table></figure>



<h4 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h4><p>DataFrame是一个类似于表格的数据类型，可以理解为一个二维数组，索引有两个维度，可更改。DataFrame具有以下特点：</p>
<ul>
<li>潜在的列是不同的类型</li>
<li>大小可变</li>
<li>标记轴(行和列)</li>
<li>可以对行和列执行算术运算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空的DataFrame</span></span><br><span class="line">df = pd.DataFrame()</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从列表创建DataFrame</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line">data = [[<span class="string">&#x27;Alex&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;Bob&#x27;</span>,<span class="number">12</span>],[<span class="string">&#x27;Clarke&#x27;</span>,<span class="number">13</span>]]</span><br><span class="line">df = pd.DataFrame(data,columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line">data = [[<span class="string">&#x27;Alex&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;Bob&#x27;</span>,<span class="number">12</span>],[<span class="string">&#x27;Clarke&#x27;</span>,<span class="number">13</span>]]</span><br><span class="line">df = pd.DataFrame(data,columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>],dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line">data = [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;,&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从字典来创建DataFrame</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>],<span class="string">&#x27;Age&#x27;</span>:[<span class="number">28</span>,<span class="number">34</span>,<span class="number">29</span>,<span class="number">42</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;s1&#x27;</span>,<span class="string">&#x27;s2&#x27;</span>,<span class="string">&#x27;s3&#x27;</span>,<span class="string">&#x27;s4&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">        <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>



<h3 id="核心数据结构操作"><a href="#核心数据结构操作" class="headerlink" title="核心数据结构操作"></a>核心数据结构操作</h3><h4 id="列访问"><a href="#列访问" class="headerlink" title="列访问"></a><strong>列访问</strong></h4><p>​    DataFrame的单列数据为一个Series。根据DataFrame的定义可以 知晓DataFrame是一个带有标签的二维数组，每个标签相当每一列的列名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;one&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df[[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]])	<span class="comment"># 花式索引</span></span><br></pre></td></tr></table></figure>

<h4 id="列添加"><a href="#列添加" class="headerlink" title="列添加"></a><strong>列添加</strong></h4><p>​    DataFrame添加一列的方法非常简单，只需要新建一个列索引。并对该索引下的数据进行赋值操作即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>],<span class="string">&#x27;Age&#x27;</span>:[<span class="number">28</span>,<span class="number">34</span>,<span class="number">29</span>,<span class="number">42</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;s1&#x27;</span>,<span class="string">&#x27;s2&#x27;</span>,<span class="string">&#x27;s3&#x27;</span>,<span class="string">&#x27;s4&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;score&#x27;</span>]=pd.Series([<span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>], index=[<span class="string">&#x27;s1&#x27;</span>,<span class="string">&#x27;s2&#x27;</span>,<span class="string">&#x27;s3&#x27;</span>,<span class="string">&#x27;s4&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="列删除"><a href="#列删除" class="headerlink" title="列删除"></a><strong>列删除</strong></h4><p>​    删除某列数据需要用到pandas提供的方法pop，pop方法的用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;three&#x27;</span> : pd.Series([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])&#125;</span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dataframe is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一列： one</span></span><br><span class="line"><span class="keyword">del</span>(df[<span class="string">&#x27;one&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用pop方法删除一列</span></span><br><span class="line">df.pop(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="行访问"><a href="#行访问" class="headerlink" title="行访问"></a><strong>行访问</strong></h4><ul>
<li>如果只是需要访问DataFrame某几行数据的实现方式则采用数组的选取方式，使用 “:” 即可：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]), </span><br><span class="line">    <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="number">2</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>loc</strong>方法是针对DataFrame<strong>索引名称</strong>的切片方法。loc方法使用方法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]])</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>iloc</strong>和loc区别是iloc接收的必须是<strong>行索引和列索引的位置</strong>。iloc方法的使用方法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(df.iloc[[<span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>

<h4 id="行添加"><a href="#行添加" class="headerlink" title="行添加"></a><strong>行添加</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="string">&#x27;zs&#x27;</span>, <span class="number">12</span>], [<span class="string">&#x27;ls&#x27;</span>, <span class="number">4</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="string">&#x27;ww&#x27;</span>, <span class="number">16</span>], [<span class="string">&#x27;zl&#x27;</span>, <span class="number">8</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line">df = df.append(df2)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="行删除"><a href="#行删除" class="headerlink" title="行删除"></a><strong>行删除</strong></h4><p>使用索引标签从DataFrame中删除或删除行。 如果标签重复，则会删除多行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="string">&#x27;zs&#x27;</span>, <span class="number">12</span>], [<span class="string">&#x27;ls&#x27;</span>, <span class="number">4</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="string">&#x27;ww&#x27;</span>, <span class="number">16</span>], [<span class="string">&#x27;zl&#x27;</span>, <span class="number">8</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">df = df.append(df2)</span><br><span class="line"><span class="comment"># 删除index为0的行</span></span><br><span class="line">df = df.drop(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="修改DataFrame中的数据"><a href="#修改DataFrame中的数据" class="headerlink" title="修改DataFrame中的数据"></a><strong>修改DataFrame中的数据</strong></h4><p>更改DataFrame中的数据，原理是将这部分数据提取出来，重新赋值为新的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="string">&#x27;zs&#x27;</span>, <span class="number">12</span>], [<span class="string">&#x27;ls&#x27;</span>, <span class="number">4</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="string">&#x27;ww&#x27;</span>, <span class="number">16</span>], [<span class="string">&#x27;zl&#x27;</span>, <span class="number">8</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">df = df.append(df2)</span><br><span class="line">df[<span class="string">&#x27;Name&#x27;</span>][<span class="number">0</span>] = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="DataFrame常用属性"><a href="#DataFrame常用属性" class="headerlink" title="DataFrame常用属性"></a><strong>DataFrame常用属性</strong></h4><table>
<thead>
<tr>
<th>编号</th>
<th>属性或方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>axes</code></td>
<td>返回 行/列 标签（index）列表。</td>
</tr>
<tr>
<td>2</td>
<td><code>dtype</code></td>
<td>返回对象的数据类型(<code>dtype</code>)。</td>
</tr>
<tr>
<td>3</td>
<td><code>empty</code></td>
<td>如果系列为空，则返回<code>True</code>。</td>
</tr>
<tr>
<td>4</td>
<td><code>ndim</code></td>
<td>返回底层数据的维数，默认定义：<code>1</code>。</td>
</tr>
<tr>
<td>5</td>
<td><code>size</code></td>
<td>返回基础数据中的元素数。</td>
</tr>
<tr>
<td>6</td>
<td><code>values</code></td>
<td>将系列作为<code>ndarray</code>返回。</td>
</tr>
<tr>
<td>7</td>
<td><code>head()</code></td>
<td>返回前<code>n</code>行。</td>
</tr>
<tr>
<td>8</td>
<td><code>tail()</code></td>
<td>返回最后<code>n</code>行。</td>
</tr>
</tbody></table>
<p>实例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>],<span class="string">&#x27;Age&#x27;</span>:[<span class="number">28</span>,<span class="number">34</span>,<span class="number">29</span>,<span class="number">42</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;s1&#x27;</span>,<span class="string">&#x27;s2&#x27;</span>,<span class="string">&#x27;s3&#x27;</span>,<span class="string">&#x27;s4&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;score&#x27;</span>]=pd.Series([<span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>], index=[<span class="string">&#x27;s1&#x27;</span>,<span class="string">&#x27;s2&#x27;</span>,<span class="string">&#x27;s3&#x27;</span>,<span class="string">&#x27;s4&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(df.axes)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;Age&#x27;</span>].dtype)</span><br><span class="line"><span class="built_in">print</span>(df.empty)</span><br><span class="line"><span class="built_in">print</span>(df.ndim)</span><br><span class="line"><span class="built_in">print</span>(df.size)</span><br><span class="line"><span class="built_in">print</span>(df.values)</span><br><span class="line"><span class="built_in">print</span>(df.head(<span class="number">3</span>)) <span class="comment"># df的前三行</span></span><br><span class="line"><span class="built_in">print</span>(df.tail(<span class="number">3</span>)) <span class="comment"># df的后三行</span></span><br></pre></td></tr></table></figure>



<h2 id="Jupyter-notebook"><a href="#Jupyter-notebook" class="headerlink" title="Jupyter notebook"></a>Jupyter notebook</h2><ul>
<li>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。使用浏览器作为界面，向后台的IPython服务器发送请求，并显示结果。 Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 </li>
</ul>
<ul>
<li>IPython 是一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。</li>
</ul>
<p><strong>安装ipython</strong></p>
<p><strong>windows：</strong>     前提是有numpy，matplotlib  pandas </p>
<p>​            采用pip安装  <code>pip install ipython</code></p>
<p><strong>OS X：</strong>        AppStore下载安装苹果开发工具Xcode。</p>
<p>​            使用easy_install或pip安装IPython，或者从源文件安装。</p>
<p><strong>安装Jupyter notebook</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install jupyter</span><br></pre></td></tr></table></figure>



<h2 id="pandas核心"><a href="#pandas核心" class="headerlink" title="pandas核心"></a>pandas核心</h2><h3 id="pandas描述性统计"><a href="#pandas描述性统计" class="headerlink" title="pandas描述性统计"></a>pandas描述性统计</h3><p>数值型数据的描述性统计主要包括了计算数值型数据的完整情况、最小值、均值、中位 数、最大值、四分位数、极差、标准差、方差、协方差等。在NumPy库中一些常用的统计学函数也可用于对数据框进行描述性统计。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.<span class="built_in">min</span>	最小值 </span><br><span class="line">np.<span class="built_in">max</span>	最大值 </span><br><span class="line">np.mean	均值 </span><br><span class="line">np.ptp	极差 </span><br><span class="line">np.median	中位数 </span><br><span class="line">np.std	标准差 </span><br><span class="line">np.var	方差 </span><br><span class="line">np.cov	协方差</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DF</span></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 测试描述性统计函数</span></span><br><span class="line"><span class="built_in">print</span>(df.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(df.<span class="built_in">sum</span>(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(df.mean())</span><br><span class="line"><span class="built_in">print</span>(df.mean(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>pandas提供了统计相关函数：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>count()</code></th>
<th>非空观测数量</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>sum()</code></td>
<td>所有值之和</td>
</tr>
<tr>
<td>3</td>
<td><code>mean()</code></td>
<td>所有值的平均值</td>
</tr>
<tr>
<td>4</td>
<td><code>median()</code></td>
<td>所有值的中位数</td>
</tr>
<tr>
<td>5</td>
<td><code>std()</code></td>
<td>值的标准偏差</td>
</tr>
<tr>
<td>6</td>
<td><code>min()</code></td>
<td>所有值中的最小值</td>
</tr>
<tr>
<td>7</td>
<td><code>max()</code></td>
<td>所有值中的最大值</td>
</tr>
<tr>
<td>8</td>
<td><code>abs()</code></td>
<td>绝对值</td>
</tr>
<tr>
<td>9</td>
<td><code>prod()</code></td>
<td>数组元素的乘积</td>
</tr>
<tr>
<td>10</td>
<td><code>cumsum()</code></td>
<td>累计总和</td>
</tr>
<tr>
<td>11</td>
<td><code>cumprod()</code></td>
<td>累计乘积</td>
</tr>
</tbody></table>
<p>pandas还提供了一个方法叫作describe，能够一次性得出数据框所有数值型特征的非空值数目、均值、标准差等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create a Dictionary of series</span></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create a DataFrame</span></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df.describe())</span><br><span class="line"><span class="built_in">print</span>(df.describe(include=[<span class="string">&#x27;object&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(df.describe(include=[<span class="string">&#x27;number&#x27;</span>]))</span><br></pre></td></tr></table></figure>



<h3 id="pandas排序"><a href="#pandas排序" class="headerlink" title="pandas排序"></a>pandas排序</h3><p>​    <em>Pandas</em>有两种排序方式，它们分别是按标签与按实际值排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">unsorted_df=pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">                         index=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>],columns=[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(unsorted_df)</span><br></pre></td></tr></table></figure>

<h4 id="按行标签排序"><a href="#按行标签排序" class="headerlink" title="按行标签排序"></a><strong>按行标签排序</strong></h4><p>​    使<font color="red">sort_index()</font>方法，通过传递<code>axis</code>参数和排序顺序，可以对<code>DataFrame</code>进行排序。 默认情况下，按照升序对行标签进行排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line">unsorted_df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 按照行标进行排序</span></span><br><span class="line">sorted_df=unsorted_df.sort_index()</span><br><span class="line"><span class="built_in">print</span> (sorted_df)</span><br><span class="line"><span class="comment"># 控制排序顺序</span></span><br><span class="line">sorted_df = unsorted_df.sort_index(ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span> (sorted_df)</span><br></pre></td></tr></table></figure>

<h4 id="按列标签排序"><a href="#按列标签排序" class="headerlink" title="按列标签排序"></a><strong>按列标签排序</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line">unsorted_df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 按照列标签进行排序</span></span><br><span class="line">sorted_df=unsorted_df.sort_index(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> (sorted_df)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="按某列值排序"><a href="#按某列值排序" class="headerlink" title="按某列值排序"></a><strong>按某列值排序</strong></h4><p>​    像索引排序一样，<font color="red">sort_values()</font>是按值排序的方法。它接受一个<code>by</code>参数，它将使用要与其排序值的<code>DataFrame</code>的列名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line">unsorted_df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 按照年龄进行排序</span></span><br><span class="line">sorted_df = unsorted_df.sort_values(by=<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (sorted_df)</span><br><span class="line"><span class="comment"># 先按Age进行升序排序，然后按Rating降序排序</span></span><br><span class="line">sorted_df = unsorted_df.sort_values(by=[<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Rating&#x27;</span>], ascending=[<span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"><span class="built_in">print</span> (sorted_df)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="pandas分组"><a href="#pandas分组" class="headerlink" title="pandas分组"></a>pandas分组</h3><p>在许多情况下，我们将数据分成多个集合，并在每个子集上应用一些函数。在应用函数中，可以执行以下操作 :</p>
<ul>
<li><em>聚合</em> - 计算汇总统计</li>
<li><em>转换</em> - 执行一些特定于组的操作</li>
<li><em>过滤</em> - 在某些情况下丢弃数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">ipl_data = &#123;<span class="string">&#x27;Team&#x27;</span>: [<span class="string">&#x27;Riders&#x27;</span>, <span class="string">&#x27;Riders&#x27;</span>, <span class="string">&#x27;Devils&#x27;</span>, <span class="string">&#x27;Devils&#x27;</span>, <span class="string">&#x27;Kings&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;kings&#x27;</span>, <span class="string">&#x27;Kings&#x27;</span>, <span class="string">&#x27;Kings&#x27;</span>, <span class="string">&#x27;Riders&#x27;</span>, <span class="string">&#x27;Royals&#x27;</span>, <span class="string">&#x27;Royals&#x27;</span>, <span class="string">&#x27;Riders&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;Rank&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>,<span class="number">4</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">2</span> , <span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">         <span class="string">&#x27;Year&#x27;</span>: [<span class="number">2014</span>,<span class="number">2015</span>,<span class="number">2014</span>,<span class="number">2015</span>,<span class="number">2014</span>,<span class="number">2015</span>,<span class="number">2016</span>,<span class="number">2017</span>,<span class="number">2016</span>,<span class="number">2014</span>,<span class="number">2015</span>,<span class="number">2017</span>],</span><br><span class="line">         <span class="string">&#x27;Points&#x27;</span>:[<span class="number">876</span>,<span class="number">789</span>,<span class="number">863</span>,<span class="number">673</span>,<span class="number">741</span>,<span class="number">812</span>,<span class="number">756</span>,<span class="number">788</span>,<span class="number">694</span>,<span class="number">701</span>,<span class="number">804</span>,<span class="number">690</span>]&#125;</span><br><span class="line">df = pd.DataFrame(ipl_data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="将数据拆分成组"><a href="#将数据拆分成组" class="headerlink" title="将数据拆分成组"></a>将数据拆分成组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照年份Year字段分组</span></span><br><span class="line"><span class="built_in">print</span> (df.groupby(<span class="string">&#x27;Year&#x27;</span>))</span><br><span class="line"><span class="comment"># 查看分组结果</span></span><br><span class="line"><span class="built_in">print</span> (df.groupby(<span class="string">&#x27;Year&#x27;</span>).groups)</span><br></pre></td></tr></table></figure>

<h4 id="迭代遍历分组"><a href="#迭代遍历分组" class="headerlink" title="迭代遍历分组"></a>迭代遍历分组</h4><p>groupby返回可迭代对象，可以使用for循环遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grouped = df.groupby(<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line"><span class="comment"># 遍历每个分组</span></span><br><span class="line"><span class="keyword">for</span> year,group <span class="keyword">in</span> grouped:</span><br><span class="line">    <span class="built_in">print</span> (year)</span><br><span class="line">    <span class="built_in">print</span> (group)</span><br></pre></td></tr></table></figure>

<h4 id="获得一个分组细节"><a href="#获得一个分组细节" class="headerlink" title="获得一个分组细节"></a>获得一个分组细节</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grouped = df.groupby(<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (grouped.get_group(<span class="number">2014</span>))</span><br></pre></td></tr></table></figure>

<h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><p>​    聚合函数为每个组返回聚合值。当创建了分组(<em>group by</em>)对象，就可以对每个分组数据执行求和、求标准差等操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 聚合每一年的平均的分</span></span><br><span class="line">grouped = df.groupby(<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (grouped[<span class="string">&#x27;Points&#x27;</span>].agg(np.mean))</span><br><span class="line"><span class="comment"># 聚合每一年的分数之和、平均分、标准差</span></span><br><span class="line">grouped = df.groupby(<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line">agg = grouped[<span class="string">&#x27;Points&#x27;</span>].agg([np.<span class="built_in">sum</span>, np.mean, np.std])</span><br><span class="line"><span class="built_in">print</span> (agg)</span><br></pre></td></tr></table></figure>



<h3 id="pandas数据表关联操作"><a href="#pandas数据表关联操作" class="headerlink" title="pandas数据表关联操作"></a>pandas数据表关联操作</h3><p>​    Pandas具有功能全面的高性能内存中连接操作，与SQL等关系数据库非常相似。<br>​    Pandas提供了一个单独的<code>merge()</code>函数，作为DataFrame对象之间所有标准数据库连接操作的入口。</p>
<p><strong>合并两个DataFrame：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">left = pd.DataFrame(&#123;</span><br><span class="line">         <span class="string">&#x27;student_id&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">         <span class="string">&#x27;student_name&#x27;</span>: [<span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;Amy&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Ayoung&#x27;</span>, <span class="string">&#x27;Billy&#x27;</span>, <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;Bran&#x27;</span>, <span class="string">&#x27;Bryce&#x27;</span>, <span class="string">&#x27;Betty&#x27;</span>, <span class="string">&#x27;Emma&#x27;</span>, <span class="string">&#x27;Marry&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>, <span class="string">&#x27;Jean&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Daniel&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;class_id&#x27;</span>:[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>], </span><br><span class="line">         <span class="string">&#x27;gender&#x27;</span>:[<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>], </span><br><span class="line">         <span class="string">&#x27;age&#x27;</span>:[<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>], </span><br><span class="line">         <span class="string">&#x27;score&#x27;</span>:[<span class="number">98</span>,<span class="number">74</span>,<span class="number">67</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">29</span>,<span class="number">32</span>,<span class="number">34</span>,<span class="number">85</span>,<span class="number">64</span>,<span class="number">52</span>,<span class="number">38</span>,<span class="number">26</span>,<span class="number">89</span>,<span class="number">68</span>,<span class="number">46</span>,<span class="number">32</span>,<span class="number">78</span>,<span class="number">79</span>,<span class="number">87</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(</span><br><span class="line">         &#123;<span class="string">&#x27;class_id&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">         <span class="string">&#x27;class_name&#x27;</span>: [<span class="string">&#x27;ClassA&#x27;</span>, <span class="string">&#x27;ClassB&#x27;</span>, <span class="string">&#x27;ClassC&#x27;</span>, <span class="string">&#x27;ClassE&#x27;</span>]&#125;)</span><br><span class="line"><span class="comment"># 合并两个DataFrame</span></span><br><span class="line">data = pd.merge(left,right)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<p><strong>使用“how”参数合并DataFrame：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并两个DataFrame (左连接)</span></span><br><span class="line">rs = pd.merge(left, right, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br></pre></td></tr></table></figure>

<p>其他合并方法同数据库相同：<a href="https://www.durango.cn/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/">请参考MySQL连接操作</a></p>
<table>
<thead>
<tr>
<th>合并方法</th>
<th>SQL等效</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>left</code></td>
<td><code>LEFT OUTER JOIN</code></td>
<td>使用左侧对象的键</td>
</tr>
<tr>
<td><code>right</code></td>
<td><code>RIGHT OUTER JOIN</code></td>
<td>使用右侧对象的键</td>
</tr>
<tr>
<td><code>outer</code></td>
<td><code>FULL OUTER JOIN</code></td>
<td>使用键的联合</td>
</tr>
<tr>
<td><code>inner</code></td>
<td><code>INNER JOIN</code></td>
<td>使用键的交集</td>
</tr>
</tbody></table>
<p>试验：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并两个DataFrame (左连接)</span></span><br><span class="line">rs = pd.merge(left,right,on=<span class="string">&#x27;subject_id&#x27;</span>, how=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br><span class="line"><span class="comment"># 合并两个DataFrame (左连接)</span></span><br><span class="line">rs = pd.merge(left,right,on=<span class="string">&#x27;subject_id&#x27;</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br><span class="line"><span class="comment"># 合并两个DataFrame (左连接)</span></span><br><span class="line">rs = pd.merge(left,right,on=<span class="string">&#x27;subject_id&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br></pre></td></tr></table></figure>



<h3 id="pandas透视表与交叉表"><a href="#pandas透视表与交叉表" class="headerlink" title="pandas透视表与交叉表"></a>pandas透视表与交叉表</h3><p>有如下数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">left = pd.DataFrame(&#123;</span><br><span class="line">         <span class="string">&#x27;student_id&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">         <span class="string">&#x27;student_name&#x27;</span>: [<span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;Amy&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Ayoung&#x27;</span>, <span class="string">&#x27;Billy&#x27;</span>, <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;Bran&#x27;</span>, <span class="string">&#x27;Bryce&#x27;</span>, <span class="string">&#x27;Betty&#x27;</span>, <span class="string">&#x27;Emma&#x27;</span>, <span class="string">&#x27;Marry&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>, <span class="string">&#x27;Jean&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Daniel&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;class_id&#x27;</span>:[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>], </span><br><span class="line">         <span class="string">&#x27;gender&#x27;</span>:[<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>], </span><br><span class="line">         <span class="string">&#x27;age&#x27;</span>:[<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>], </span><br><span class="line">         <span class="string">&#x27;score&#x27;</span>:[<span class="number">98</span>,<span class="number">74</span>,<span class="number">67</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">29</span>,<span class="number">32</span>,<span class="number">34</span>,<span class="number">85</span>,<span class="number">64</span>,<span class="number">52</span>,<span class="number">38</span>,<span class="number">26</span>,<span class="number">89</span>,<span class="number">68</span>,<span class="number">46</span>,<span class="number">32</span>,<span class="number">78</span>,<span class="number">79</span>,<span class="number">87</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(</span><br><span class="line">         &#123;<span class="string">&#x27;class_id&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">         <span class="string">&#x27;class_name&#x27;</span>: [<span class="string">&#x27;ClassA&#x27;</span>, <span class="string">&#x27;ClassB&#x27;</span>, <span class="string">&#x27;ClassC&#x27;</span>, <span class="string">&#x27;ClassE&#x27;</span>]&#125;)</span><br><span class="line"><span class="comment"># 合并两个DataFrame</span></span><br><span class="line">data = pd.merge(left,right)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<h4 id="透视表"><a href="#透视表" class="headerlink" title="透视表"></a><strong>透视表</strong></h4><p>​    透视表(pivot table)是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。<strong>它根据一个或多个键对数据进行分组聚合，并根据每个分组进行数据汇总</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以class_id与gender做分组汇总数据，默认聚合统计所有列</span></span><br><span class="line"><span class="built_in">print</span>(data.pivot_table(index=[<span class="string">&#x27;class_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以class_id与gender做分组汇总数据，聚合统计score列</span></span><br><span class="line"><span class="built_in">print</span>(data.pivot_table(index=[<span class="string">&#x27;class_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>], values=[<span class="string">&#x27;score&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以class_id与gender做分组汇总数据，聚合统计score列，针对age的每个值列级分组统计</span></span><br><span class="line"><span class="built_in">print</span>(data.pivot_table(index=[<span class="string">&#x27;class_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>], values=[<span class="string">&#x27;score&#x27;</span>], </span><br><span class="line">                       columns=[<span class="string">&#x27;age&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以class_id与gender做分组汇总数据，聚合统计score列，针对age的每个值列级分组统计，添加行、列小计</span></span><br><span class="line"><span class="built_in">print</span>(data.pivot_table(index=[<span class="string">&#x27;class_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>], values=[<span class="string">&#x27;score&#x27;</span>], </span><br><span class="line">                       columns=[<span class="string">&#x27;age&#x27;</span>], margins=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以class_id与gender做分组汇总数据，聚合统计score列，针对age的每个值列级分组统计，添加行、列小计</span></span><br><span class="line"><span class="built_in">print</span>(data.pivot_table(index=[<span class="string">&#x27;class_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>], values=[<span class="string">&#x27;score&#x27;</span>], </span><br><span class="line">                       columns=[<span class="string">&#x27;age&#x27;</span>], margins=<span class="literal">True</span>, aggfunc=<span class="string">&#x27;max&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="交叉表"><a href="#交叉表" class="headerlink" title="交叉表"></a><strong>交叉表</strong></h4><p>交叉表(cross-tabulation, 简称crosstab)是一种用于<strong>计算分组频率的特殊透视表</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照class_id分组，针对不同的gender，统计数量</span></span><br><span class="line"><span class="built_in">print</span>(pd.crosstab(data.class_id, data.gender, margins=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>



<h3 id="pandas可视化"><a href="#pandas可视化" class="headerlink" title="pandas可视化"></a>pandas可视化</h3><h4 id="基本绘图"><a href="#基本绘图" class="headerlink" title="基本绘图"></a><strong>基本绘图</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> mp </span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">4</span>),index=pd.date_range(<span class="string">&#x27;2018/12/18&#x27;</span>,</span><br><span class="line">   periods=<span class="number">10</span>), columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line">df.plot()</span><br><span class="line">mp.show()</span><br></pre></td></tr></table></figure>

<p>plot方法允许除默认线图之外的少数绘图样式。 这些方法可以作为<code>plot()</code>的<code>kind</code>关键字参数。这些包括 ：</p>
<ul>
<li><code>bar</code>或<code>barh</code>为条形</li>
<li><code>hist</code>为直方图</li>
<li><code>scatter</code>为散点图</li>
</ul>
<h4 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a><strong>条形图</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">4</span>),columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df.plot.bar()</span><br><span class="line"><span class="comment"># df.plot.bar(stacked=True)</span></span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a><strong>直方图</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame()</span><br><span class="line">df[<span class="string">&#x27;a&#x27;</span>] = pd.Series(np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)-<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&#x27;b&#x27;</span>] = pd.Series(np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>))</span><br><span class="line">df[<span class="string">&#x27;c&#x27;</span>] = pd.Series(np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line">df.plot.hist(bins=<span class="number">20</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a><strong>散点图</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">50</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df.plot.scatter(x=<span class="string">&#x27;a&#x27;</span>, y=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a><strong>饼状图</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(<span class="number">3</span> * np.random.rand(<span class="number">4</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], columns=[<span class="string">&#x27;x&#x27;</span>])</span><br><span class="line">df.plot.pie(subplots=<span class="literal">True</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="数据读取与存储"><a href="#数据读取与存储" class="headerlink" title="数据读取与存储"></a>数据读取与存储</h3><h4 id="读取与存储csv："><a href="#读取与存储csv：" class="headerlink" title="读取与存储csv："></a><strong>读取与存储csv：</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filepath 文件路径。该字符串可以是一个URL。有效的URL方案包括http，ftp和file </span></span><br><span class="line"><span class="comment"># sep 分隔符。read_csv默认为“,”，read_table默认为制表符“[Tab]”。</span></span><br><span class="line"><span class="comment"># header 接收int或sequence。表示将某行数据作为列名。默认为infer，表示自动识别。</span></span><br><span class="line"><span class="comment"># names 接收array。表示列名。</span></span><br><span class="line"><span class="comment"># index_col 表示索引列的位置，取值为sequence则代表多重索引。 </span></span><br><span class="line"><span class="comment"># dtype 代表写入的数据类型（列名为key，数据格式为values）。</span></span><br><span class="line"><span class="comment"># engine 接收c或者python。代表数据解析引擎。默认为c。</span></span><br><span class="line"><span class="comment"># nrows 接收int。表示读取前n行。</span></span><br><span class="line"></span><br><span class="line">pd.read_table(</span><br><span class="line">    filepath_or_buffer, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="string">&#x27;infer&#x27;</span>, names=<span class="literal">None</span>, </span><br><span class="line">    index_col=<span class="literal">None</span>, dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, nrows=<span class="literal">None</span>) </span><br><span class="line">pd.read_csv(</span><br><span class="line">    filepath_or_buffer, sep=<span class="string">&#x27;,&#x27;</span>, header=<span class="string">&#x27;infer&#x27;</span>, names=<span class="literal">None</span>, </span><br><span class="line">    index_col=<span class="literal">None</span>, dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, nrows=<span class="literal">None</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_csv(excel_writer=<span class="literal">None</span>, sheetname=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, mode=’w’, encoding=<span class="literal">None</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="读取与存储excel："><a href="#读取与存储excel：" class="headerlink" title="读取与存储excel："></a><strong>读取与存储excel：</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># io 表示文件路径。</span></span><br><span class="line"><span class="comment"># sheetname 代表excel表内数据的分表位置。默认为0。 </span></span><br><span class="line"><span class="comment"># header 接收int或sequence。表示将某行数据作为列名。默认为infer，表示自动识别。</span></span><br><span class="line"><span class="comment"># names 表示索引列的位置，取值为sequence则代表多重索引。</span></span><br><span class="line"><span class="comment"># index_col 表示索引列的位置，取值为sequence则代表多重索引。</span></span><br><span class="line"><span class="comment"># dtype 接收dict。数据类型。</span></span><br><span class="line">pandas.read_excel(io, sheetname=<span class="number">0</span>, header=<span class="number">0</span>, index_col=<span class="literal">None</span>, names=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_excel(excel_writer=<span class="literal">None</span>, sheetname=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, mode=’w’, encoding=<span class="literal">None</span>) </span><br></pre></td></tr></table></figure>

<h4 id="读取与存储JSON："><a href="#读取与存储JSON：" class="headerlink" title="读取与存储JSON："></a><strong>读取与存储JSON：</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过json模块转换为字典，再转换为DataFrame</span></span><br><span class="line">pd.read_json(<span class="string">&#x27;../ratings.json&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="案例：movielens电影评分数据分析"><a href="#案例：movielens电影评分数据分析" class="headerlink" title="案例：movielens电影评分数据分析"></a>案例：movielens电影评分数据分析</h2><p>需求如下：</p>
<ol>
<li><p>读取数据，从用户表读取用户信息、同样方法，导入电影评分表、电影数据表。</p>
</li>
<li><p>合并数据表</p>
</li>
<li><p>对数据初步描述分析</p>
</li>
<li><p>查看每一部电影不同性别的平均评分并计算分歧差值，之后排序</p>
</li>
<li><p>算出每部电影平均得分并对其进行排序</p>
</li>
<li><p>查看评分次数多的电影并进行排序 </p>
</li>
<li><p>过滤掉评分条目数不足250条的电影</p>
</li>
<li><p>评分最高的十部电影</p>
</li>
<li><p>查看不同年龄的分布情况并且采用直方图进行可视化</p>
</li>
<li><p>在原数据中标记出用户位于的年龄分组</p>
</li>
<li><p>可视化显示movies_ratings中不同类型电影的频数</p>
</li>
</ol>
]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>生物信息学笔记</title>
    <url>/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="第三章-序列比较"><a href="#第三章-序列比较" class="headerlink" title="第三章 序列比较"></a>第三章 序列比较</h1><h2 id="3-1-认识序列"><a href="#3-1-认识序列" class="headerlink" title="3.1 认识序列"></a>3.1 认识序列</h2><h3 id="序列分类"><a href="#序列分类" class="headerlink" title="序列分类"></a>序列分类</h3><p>​    蛋白质序列和核酸序列。蛋白质序列是由 20 个不同的字母，也就是 20 种不同的氨基酸排列组合而成。核酸序列是由 4 种不同的字母，也就是 4 种 不同的碱基排列组合而成。核酸序列又分为 DNA 序列和 RNA 序列。 </p>
<h3 id="序列格式"><a href="#序列格式" class="headerlink" title="序列格式"></a>序列格式</h3><p>​    生物序列有自己的书写格式，而且格式很多。不同的处理软件会用到不同的格式，但是最常用的，大多数软件都识别的格式是 <strong>FASTA 格式</strong>。</p>
<p>​    FASTA 格式，第一行是一个大于号“&gt;”开头，后面紧接注释信息，比如序 列的名字，编号等。因为前面有大于号，序列分析软件会自动识别这是一条序列的开始，且 这一行是注释而不是序列。从第二行开始就是纯序列部分。</p>
<h2 id="3-2-序列相似性"><a href="#3-2-序列相似性" class="headerlink" title="3.2 序列相似性"></a>3.2 序列相似性</h2><h3 id="序列相似性的意义"><a href="#序列相似性的意义" class="headerlink" title="序列相似性的意义"></a>序列相似性的意义</h3><p>​    意义在于，相似的序列往往起源于一个共同的祖先。它们很可能有相似的 空间结构和生物学功能。因此，对于一个已知序列但未知结构和功能的蛋白质，如果与它序 列相似的某些蛋白质的结构和功能已知，那么就可以推测出这个未知结构和功能的蛋白质的结构和功能。简言之，相似的序列意味着相似的结构，相似的结构意味着相似的功能</p>
<h3 id="一致度和相似度"><a href="#一致度和相似度" class="headerlink" title="一致度和相似度"></a>一致度和相似度</h3><p>​    一致度可以定义为它们对应位置上相同的残基数目占总长度的百分比。一个残基就是指一个字母（氨基酸或碱基）</p>
<p>​    相似度可以暂时定义为他们对应位置上相似的残基 与相同的残基的数目和占总长度的百分比</p>
<h2 id="3-3-替换计分矩阵"><a href="#3-3-替换计分矩阵" class="headerlink" title="3.3 替换计分矩阵"></a>3.3 替换计分矩阵</h2><h3 id="核酸序列的替换记分矩阵"><a href="#核酸序列的替换记分矩阵" class="headerlink" title="核酸序列的替换记分矩阵"></a><strong>核酸序列的替换记分矩阵</strong></h3><h4 id="等价矩阵"><a href="#等价矩阵" class="headerlink" title="等价矩阵"></a>等价矩阵</h4><p>​    这个矩阵最简单. 其中，相同核苷酸之间的匹配得分为 1，不同核苷酸间的替换得分为 0。由于不含有碱基的 理化信息和不区别对待不同的替换，在实际的序列比较中很少使用，一般只用于理论计算。</p>
<h4 id="转换-颠换矩阵"><a href="#转换-颠换矩阵" class="headerlink" title="转换-颠换矩阵"></a>转换-颠换矩阵</h4><p>​    我们说 核酸的碱基按照环结构特征被划分为两类，一类是嘌呤，包括腺嘌呤 A 和鸟嘌呤 G，它们都有两个环；另一类是嘧啶，包括胞嘧啶 C 和胸腺嘧啶 T，它们只有一个环。</p>
<p>​    如果 DNA 碱基的替换保持环数不变，则称为<strong>转换</strong>，比如腺嘌呤 A 替换为 鸟嘌呤 G、或者胞嘧啶 C 替换 为胸腺嘧啶 T，也就是嘌呤变嘌呤，嘧啶变嘧啶；如果环数发生变化，则称为<strong>颠换</strong>，比如腺 嘌呤 A 替换为胞嘧啶 C、或者胸腺嘧啶 T 替换为鸟嘌呤 G，也就是嘌呤变嘧啶，或者嘧啶 变嘌呤。</p>
<p>​    在进化过程中，转换发生的频率远比颠换高。也就是说，大自然更倾向于接受嘌呤 和嘌呤之间的替换，以及嘧啶和嘧啶之间的替换，而嘌呤和嘧啶之间的替换会导致不好的事 情发生，这种替换大多在进化过程中已经被淘汰了。为了反映这一情况，转换-颠换矩阵中， 转换的得分比颠换要高为-1 分，而颠换的得分为-5 分。 </p>
<h4 id="BLAST矩阵"><a href="#BLAST矩阵" class="headerlink" title="BLAST矩阵"></a>BLAST矩阵</h4><p>​    经过大量实际比对发现，如果令被比对的两个核苷酸相同时 得分为+5 分，不相同为-4 分，这时比对效果最好。这个矩阵广泛地被 DNA 序列比较所采 用。没有为什么，就是好，实践经验所得。因为这个矩阵最早应用于 BLAST 工具，因此得名 BLAST 矩阵</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984260134.png" alt="1667984260134"></p>
<h3 id="蛋白质序列的替换记分矩阵"><a href="#蛋白质序列的替换记分矩阵" class="headerlink" title="蛋白质序列的替换记分矩阵"></a>蛋白质序列的替换记分矩阵</h3><h4 id="等价矩阵-1"><a href="#等价矩阵-1" class="headerlink" title="等价矩阵"></a>等价矩阵</h4><h4 id="PAM-矩阵"><a href="#PAM-矩阵" class="headerlink" title="PAM 矩阵"></a>PAM 矩阵</h4><p>​    PAM 矩阵基于进化原 理。如果两种氨基酸替换频繁，说明自然界容易接受这种替换，那么这一对氨基酸替换的得 分就应该高。</p>
<p>​    PAM 矩阵是目前蛋白质序列比较中最广泛使用的记分方法之一。基础的 PAM-1 矩阵反应的是进化产生的每一百个氨基酸平均发生一个突变的量值，由统计方法得到。 PAM-1 自乘 n 次，可以得到 PAM-n ，表示发生了更多次突变。</p>
<p>​    我们需要根据要比较的序列之间的亲缘关系远近，来选择适合的 PAM 矩阵。如果序列亲缘关系远，也就是说序列间会 有很多突变，那就选 PAM 后面跟一个大数字的矩阵。如果亲缘关系近，也就是突变比较少， 序列间大多数地方都是一样的，那就选 PAM 后面跟一个小数字的矩阵。</p>
<p>​    如PAM250矩阵。对角线上的数值为匹配氨基酸的得分。其他位置上≥0 的得分代 表对应的一对氨基酸为相似氨基酸，&lt;0 的是不相似的氨基酸。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984465411.png" alt="1667984465411"></p>
<h4 id="BLOSUM-矩阵"><a href="#BLOSUM-矩阵" class="headerlink" title="BLOSUM 矩阵"></a>BLOSUM 矩阵</h4><p>​    BLOSUM 矩阵有和 PAM 矩阵相同的地方，也有不同的地方。相同的是，BLOSUM 矩阵 后面也带有一个编号，有很多种 BLOSUM 矩阵。不同的是，BLOSUM 矩阵都是通过对大量 符合特定要求的序列计算而来的。这点和 PAM 矩阵不同的。</p>
<p>​    PAM-1 矩阵是基于相似度大于85%的序列计算产生的，也就是通过关系较近的序列计算出来的。那些进化距离较远的矩阵， 如 PAM-250，是通过 PAM-1 自乘得到的。也就是说，BLOSUM 矩阵的相似性是根据<strong>真实数</strong> <strong>据</strong>产生的，而 PAM 矩阵是通过矩阵自乘外推而来的。和 PAM 矩阵的另一个不同之处是 BLOSUM 矩阵的编号。这些编号，比如 BLOSUM80 中的 80，代表这个矩阵是由一致度≥80% 的序列计算而来的。同理，BLOSUM62 是指这个矩阵是由一致度≥62%的序列计算而来的。 因此，BLOSUM 后面跟一个小数字的矩阵适合用于比较相似度低的序列，也就是亲缘关系 远的序列；而 BLOSUM 后面跟一个大数字的矩阵适合比较相似度高的序列，也就是亲缘关 系近的序列。  </p>
<p>​    BLOSUM 62 矩阵.样子和 PAM 矩阵差不多，但是里面的数值是不一样的。同样， ≥0 的得分代表对应的一对氨基酸为相似氨基酸，&lt;0 的是不相似的氨基酸。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984606849.png" alt="1667984606849"></p>
<p>​    亲缘关系较近的序列之间的比较，用 PAM 数小的矩阵或 BLOSUM 数大的矩阵；而亲缘关系较远的序列之间的比较，用 PAM 数大的矩阵或 BLOSUM数小的矩阵。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984664136.png" alt="1667984664136"></p>
<h4 id="遗传密码矩阵"><a href="#遗传密码矩阵" class="headerlink" title="遗传密码矩阵"></a>遗传密码矩阵</h4><p>​    它是通过计算一个氨基酸转换成另一个氨基酸所需的密码子变化的数目而得到的。 矩阵的值对应为据此付出的代价。如果变化一个碱基就可以使一个氨基酸的密码子转换为另 一个氨基酸的密码子，则这两个氨基酸的替换代价为 1；如果需要 2 个碱基的改变，则替换 代价为 2；再比如从蛋氨酸（Met）到酪氨酸（Tyr）三个密码子都要变，则代价为 3。</p>
<p>​    遗传密码矩阵常用于进化距离的计算，它的优点是计算结果可以直接用于绘制进化树，但是它在 蛋白质序列比对，尤其是相似程度很低的蛋白质序列比对中，很少被使用。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984738576.png" alt="1667984738576"></p>
<h4 id="疏水矩阵"><a href="#疏水矩阵" class="headerlink" title="疏水矩阵"></a>疏水矩阵</h4><p>​    它是根据氨基酸残基替换前后疏水性的变化而得到的矩阵。 若一次氨基酸替换导致疏水特性不发生太大的变化，则这种替换得分高，否则替换得分低。 疏水矩阵物理意义明确，有一定的<strong>理化性质</strong>依据，适用于偏重蛋白质功能方面的序列比对。 在这个矩阵里，氨基酸按照亲疏水性排列。前边是亲水的，后面是疏水的。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984790580.png" alt="1667984790580"></p>
<h2 id="3-4-序列比对-Dotplot打点法"><a href="#3-4-序列比对-Dotplot打点法" class="headerlink" title="3.4 序列比对-Dotplot打点法"></a>3.4 序列比对-Dotplot打点法</h2><h3 id="序列比对概念"><a href="#序列比对概念" class="headerlink" title="序列比对概念"></a>序列比对概念</h3><p>​    <strong>Sequence aligmen</strong>t:运用特定的算法找出两个或者多个序列之间产生最大相似度得分的空格插入和序列排列方案。</p>
<p>比如：</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668043108983.png" alt="1668043108983"></p>
<p>​    这两条序列的比对就是把 s 和 t 这两个字符串上下排列起来，在某些位置插入空格，这些空格叫空位（gap）。然后依次比较它们在每一个位置上字符的匹配情况，匹配的好，这个位置 就会得高分，匹配的不好，看看能不能左右错一错，或填上个空位，让附近的位置更好的匹 配在一起，从而使所有位置的得分之和尽可能的高。说白了，就是通过插入空位，让上下两行中尽可能多的一致的和相似的字符对在一起。这不是随便摆摆看看就能完成的，需要使用专门的序列比对算法。 </p>
<p>​    根据比对序列的个数可以把序列比对分为<strong>双序列比对和多序列比对</strong>。顾名思义，双序列 比对就是比 2 条，而多序列比对是比 2 条以上。此外根据序列比对的算法不同，</p>
<p>​    双序列比对 又分为<strong>全局比对和局部比对</strong>。全局比对就是全长比较，一个字符都不能落下。而局部比对是 比较对得最好的局部，对得不好的部分会被忽略不计。我们将从双序列比对的全局比对入手，看看序列比对的算法是如何插入空位，并使得插入后两条序列的得分最高的。</p>
<h3 id="打点法概念"><a href="#打点法概念" class="headerlink" title="打点法概念"></a>打点法概念</h3><p>​    打点法是最简单的比较两个序列的方法，理论上可以用纸和笔来完成。如果要比较下面这两条序列： </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668043715094.png" alt="1668043715094"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668043742557.png" alt="1668043742557"></p>
<p>​    在打点矩阵中，<strong>连续的对角线及对角线的平行线代表两条序列中相同的区域</strong>。</p>
<p>​    这个矩阵 中在主对角线位置上连续的红色的对角线说明这个位置对应的序列 1 的部分和序列 2 的部分是完全相同的，都是 THEFA。此外，跟红对角线平行的蓝色平行线和绿色平行线，同样指出了序列 1 和序列 2 中两条相同的序列。也就是序列 1 和序列 2 中对应位置的 TCAT，以及序列 1 和序列 2 中对应位置的 AT。由这三条线，我们找到了序列 1 和序列 2 中三条相同的 子序列。最后，我们放眼全局，红色的线和蓝色的线加起来基本上构成了一条主对角线。由 此我们可以得出结论：序列 1 和序列 2 是比较相似的两条序列</p>
<p>​    </p>
<p>​    除了可以用打点法给两条不同的序列打点，还可以用一条序列自己跟自己打点。这样可 以发现序列中重复的片段。比如我们让下面这条序列自己和自己打点：</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668044008636.png" alt="1668044008636"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668044040422.png" alt="1668044040422"></p>
<p>​    这样的打点矩阵必然是对称的，并且一定有一条主对角线（图 3）。此外，在横向或纵向上， 与主对角线平行的短平行线所对应的序列片段就是重复的部分。其中，红色短平行线对应的 ‘THE’在序列中重复出现了 3 次。包括主对角线在内，平行线出现的次数就是重复的次数。 </p>
<p>​    用这种方法我们还可以快捷的发现序列中的<strong>串联重复序列以及重复的次数</strong>。我们只要数数在半个矩阵中包括主对角线在内的所有等距的平行线的个数，就可以知道重复的次数，而且最短的平行线对应的序列就是重复单元。</p>
<p>​    短的串联重复序列具有高度多态性，也就 是说不同的个体间重复次数存在差异，而且这种差异在基因遗传过程中一般遵循孟德尔共显性遗传规律，所以快速查找某些特定的短的串联复序列的重复次数可以用于法医学的<u>个体识别或亲子鉴定</u>等领域。 </p>
<h3 id="Dotlet-界面介绍"><a href="#Dotlet-界面介绍" class="headerlink" title="Dotlet 界面介绍"></a><strong>Dotlet 界面介绍</strong></h3><p>​    可以自动打点的软件有很多（表 1）。我们挑其中最常用的 Dotlet 软件做为演示（<strong><a href="http://myhits.isb-sib.ch/cgi-bin/dotlet">http://myhits.isb-sib.ch/cgi-bin/dotlet</a></strong>。Dotlet 基于 Java 开发，所以页面打开后会蹦出 JAVA 对话框。像对待 Jsmol 一样，接受 JAVA，信任 JAVA，运行 JAVA。当然前提是你的电脑已 经安装了 JAVA。如果还没有安装，可以到课程附件或者 JAVA 官网下载安装。别忘了安装后，重启浏览器，JAVA 才能生效。同样的，IE 如果不好使，可以尝试其他浏览器。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668044569496.png" alt="1668044569496"></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">网址链接</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Dotlet</td>
<td align="center"><a href="http://myhits.isb-sib.ch/cgi-bin/dotlet">http://myhits.isb-sib.ch/cgi-bin/dotlet</a></td>
</tr>
<tr>
<td align="center">Dnadot</td>
<td align="center"><a href="http://arbl.cvmbs.colostate.edu/molkit/dnadot">http://arbl.cvmbs.colostate.edu/molkit/dnadot</a></td>
</tr>
<tr>
<td align="center">Dotter</td>
<td align="center"><a href="http://sonnhammer.sbc.su.se/Dotter.html">http://sonnhammer.sbc.su.se/Dotter.html</a></td>
</tr>
<tr>
<td align="center">Dottup</td>
<td align="center"><a href="http://emboss.sourceforge.net/">http://emboss.sourceforge.net</a></td>
</tr>
</tbody></table>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668044813102.png" alt="1668044813102"></p>
<h3 id="Dotlet-应用实例"><a href="#Dotlet-应用实例" class="headerlink" title="Dotlet 应用实例"></a>Dotlet 应用实例</h3><p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668044956053.png" alt="1668044956053"></p>
<p>​    图 1 是上一节中 seq1 自己和自己打点计算出的打点图。注意默认的颜色方案是在越相 似的地方打的点的颜色越浅，越不相似的地方颜色越深。所以整体感觉像是在一张黑纸上打 白点。因为是 seq1 自己和自己打点，所以应该有一条明显的主对角线，这是所有自己和自 己打点的序列都会出现的情况。除此之外，还有一条与主对角线平行的次对角线，涉及 seq1 大约 1/2 的长度。这说明 seq1 的前半部分和后半部分非常的相似！</p>
<p>​    我们把鼠标点在这条次对角线上的任意位置，之后就可以从下面的序列显示区域看到，这一点，对应横着这条 seq1 的位置 153 开始的这一段，同时对应竖着这条 seq1 的位置 11 开 始的这一段。为什么这一点对应的是一段呢？因为我们这里选的单元长度是 15，也就是一 次比较 15 个字母。从这里也可以看出，如果把 seq1 的前半段和后半段重合起来的话，它们是完全一样的序列。  </p>
<p>​    图 1 右边给出了打点所用的参数设置。按照选定的替换计分矩阵和单元长度计算，比较 所能打出的最高分是 165 分，最低分是-60 分。默认的颜色方案是灰度从 0%到 100%。也就 是最高分 165 分的点具有 100%的灰度，即纯白色；最低分-60 分具有 0%的灰度，即纯黑色。参数下面的图给出了各个分值的点的个数。横坐标是分值，从-60 到 165，纵坐标是得某一分值的点的个数。我们可以看到绝大多数点的分值都是较低的，也就是绝大多数位置的比较 结果都是不相似的。只有少数对角线上的比较才是高分值的点，因为这些位置对应的是相似 的区域。这个情况反映在打点图上就是，绝大多数点都是深色的，只有少数点是浅色的，这 些浅色的点位于主对角线和两条对称的次对角线上。</p>
<p>​    这里我们可以通过调整灰度条，来屏蔽大多数低分值的点，让他们统统变成黑色背景， 并且强化高分值的点，让他们以纯白色突出显示出来（图 2）。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668045793136.png" alt="1668045793136"></p>
<h2 id="3-5-序列比对-动态规划法"><a href="#3-5-序列比对-动态规划法" class="headerlink" title="3.5 序列比对-动态规划法"></a>3.5 序列比对-动态规划法</h2><h3 id="双序列全局比对"><a href="#双序列全局比对" class="headerlink" title="双序列全局比对"></a>双序列全局比对</h3><p>​    经典的全局比对算法是 <strong>Needleman-Wunsch 算法</strong>。1970 年，Needleman 和 Wunsch 首先将<strong>动态规划</strong>法应用于两条序列的全局比对，后来这个算法就称为 Needleman-Wunsch 算法。今天，所有比对软件使用的算法都是从这个经典算法衍生出来的。  </p>
<p>​    我们用 Needleman-Wunsch 算法为序列 p 和序列 q 创建全局比对。输入值除了两条序列 之外，还要有<strong>替换计分矩阵</strong>以确定不同字母间的相似度得分，以及空位罚分（图 1）。空位 罚分就是当字母对空位的时候应该得几分。我们还是希望一致或相似的字母尽可能的对在一 起，字母对空位的情况和不相似的字母对在一起的情况一样，都不是我们希望的，还是少出 现为好，所以通常字母对空位会得到一个负分，这个负分就叫做<strong>空位罚分</strong>。这里我们让空位罚分，也就是 gap 分值为-5 分。在比对中没有空位对空位的情况。输入值就是这些。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046097925.png" alt="1668046097925"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046123952.png" alt="1668046123952"></p>
<p>​    接下来我们要创建一个得分矩阵（图 2-1），并根据公式（图 2-2）把得分矩阵填满。填 满后全局比对就会跃然于纸上。得分矩阵的第一行是序列 p，第一列是序列 q，这一步和打点法很像。不过要注意，p 和 q 的前面各留一个空列和一个空行，也就是第 0 列和第 0 行。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046208548.png" alt="1668046208548"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046444856.png" alt="1668046444856"></p>
<p>​    按照上面的公式，将整个得分矩阵填满。这时，我们再回过头来看一下第一行和第一列 （图 6）。其实，第一行的每一个值都是从左边的格加 gap 来的。所以我们给它们补上向左 的箭头。第一列的每一个值都是从上边的格加 gap 来的。所以我们给它们补上向上的箭头。 至此，所有的箭头和数值就都填好了。填满之后，<strong>右下角的分数就是整个全局比对最终的得 分</strong>。然后从这个位置开始<strong>追溯箭头一直到左上角的零</strong>，并且把这些箭头标记出来。</p>
<p>​    图 6 中标出的红色箭头是写出全局比对的唯一依据。追溯箭头是从右下角到左上角，但是写全局比对是从左上角开始，如果是<strong>斜箭头则是字符对字符，如果是水平箭头或垂直箭头 则是字符对空位，箭头指着的序列为空位</strong>。我们看第一个是斜箭头，字母对字母，就是 A 对 A，第二个是水平箭头，字母对空位，箭头指着的序列是空位，也就是 C 对空位。然后 斜箭头 G 对 A，斜箭头 T 对 T，斜箭头 C 对 C，一直写到右下角，全局比对就出现了（图 7）。 唯一的一个空位插在序列 q 的 A 与 A 之间，这样最终的比对得分最高。不信的话可以试试， 其他任何一种插入空位的比对结果，得分都不会超过 21 分。因为我们在得分矩阵的创建过 程中，每一步都是在上一步最优的情况下得出的当前最优结果。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046572690.png" alt="1668046572690"></p>
<h3 id="双序列局部对比"><a href="#双序列局部对比" class="headerlink" title="双序列局部对比"></a>双序列局部对比</h3><p>​    在看局部比对的算法之前，先看看序列 a 和序列 b 这两条序列，谁和序列 c 更相似一些 （图 1）。AC 做全局比对的得分是-46 分。BC 做全局比对的得分是 8 分。单从分数上看，b 跟 c 更相似，因为得分高。但是如果只看红框里这部分，a 和 c 显然比 b 和 c 对得要好。如 果只比较红框里这部分的话，a 和 c 的得分是 24 分，比 b 和 c 的得分要高。这个例子告诉我 们，对于像这样一长一短的两条序列，比较局部比比较全长更有意义。这就是为什么除了全局比对，还有局部比对。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046680161.png" alt="1668046680161"></p>
<p>​    局部比对的算法和全局比对很相似，只是在选最大值时通过增加了第四个元素“0”，来 达到比对局部的效果。序列 p 和序列 q，一长一短，其他输入值跟全局比对的一样（图 2）。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046702735.png" alt="1668046702735"></p>
<p>​    局部比对的计算公式在全局比对的基础上增加了第四个元素“0”。得分矩阵初始值仍是 0，但第一行和第一列与全局比对不同，全是 0（图 3）。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046728157.png" alt="1668046728157"></p>
<p>​    从 s(1,1)开始要选择四个值中的最大值。除了上面格 s(0,1)+gap=0+-5=-5，左边 格 s(1,0)+gap=0+-5=-5，斜上格 s(0,0)+w(1,1)=0+-3=-3，还有一个 0。max(-5,  -5,-3,0)=0。并且这个 0 既不是从上面格，也不是从左边格，以及斜上格三个方向来的， 而是来自于公式里增加的“0”，所以不用画箭头（图 4）。</p>
<p>​    s(1,4)的计算：上面格 s(0,4)+gap=0+-5=-5，左边格 s(1,3)+gap=4+-5=-1， 斜上格 s(0,3)+w(1,4)=0+0=0，还有一个 0。max(-5,-1,0,0)=0。这个 0 和 s(1,1) 的 0 是不一样的。这个 0 应该画上斜上的箭头（图 5），因为它可以来自公式中的 0，也可 以来自斜上格。而 s(1,1)的 0 没有箭头因为它只来自公式中的 0。两种情况虽然都是 0， 但来源不同，一定要通过箭头标识清楚。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046866779.png" alt="1668046866779"></p>
<p>​    按照公式，填充满整个得分矩阵（图 6）。与全局比对不同，<strong>局部比对的得分不是在右下角，而是在整个矩阵中找最大值</strong>。这个最大值才是局部比对的最终得分，他可能出现在任何一个位置。这次箭头追溯也不是从右下角到左上角，而是从<strong>刚刚找到的最大值开始追溯到没有箭头为止</strong>。追溯箭头终止的位置也可以是得分矩阵中的任何一个位置。 </p>
<p>​    最后根据标记好的箭头写出比对结果（图 7）。从左上到右下标记的红色箭头依次是： 斜箭头字母对字母，C 对 C；斜箭头字母对字母，G 对 G。相比这两条序列的全局比对结果， 两端的空位在局部比对中就全部被忽略掉了。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046946332.png" alt="1668046946332"></p>
<h2 id="3-6-一致度和相似度"><a href="#3-6-一致度和相似度" class="headerlink" title="3.6 一致度和相似度"></a>3.6 一致度和相似度</h2><p>​    我们回过头来，再看看一致度和相似度的计算。之前我们卡在长度不一样的两个序列如 何计算一致度和相似度这个问题上。现在学会了序列比对，我们就可以先给这两条长度不同 的序列做全局比对，然后计算全局比对中一致字符的个数和相似字符的个数，再除以全局比对的长度，就可以得到它们的一致度和相似度了。比如下面这两条序列：  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668059549705.png" alt="1668059549705"></p>
<p>首先做出它们的全局比对，比对中一致字符的个数是 4 个，全局比对长度 6，一致度=67%。 相似字符个数 1，相似度就是(4+1)/6=83%。 </p>
<p>​    由此，我们必须回过头来，把长度相同的两个序列计算一致度和相似度的方法重新规范 一下。尽管长度相同，但是做出的<strong>全局比对的长度并不一定等于序列的长度</strong>，比如下面这两条序列：  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668059716946.png" alt="1668059716946"></p>
<p>上下各加入一个空位，全局比对的长度就不等于序列的长度了。所以不管两条序列长度是否相同，都要先对它们做全局比对。让两条序列先以最优的方式比对起来，再从全局比对中数 出一致字符和相似字符的个数，除以全局比对的长度，来得到它们的一致度和相似度。 </p>
<h2 id="3-7-在线双序列比对工具"><a href="#3-7-在线双序列比对工具" class="headerlink" title="3.7 在线双序列比对工具"></a>3.7 在线双序列比对工具</h2><h3 id="EMBL全局双序列比对工具"><a href="#EMBL全局双序列比对工具" class="headerlink" title="EMBL全局双序列比对工具"></a>EMBL全局双序列比对工具</h3><p>​    目前，使用率最高的是 EMBL 网 站的双序列比对工具（<a href="http://www.ebi.ac.uk/Tools/psa%EF%BC%89%E3%80%82%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%B8%8A%E9%9D%A2%E6%9C%89%E5%85%A8%E5%B1%80%E6%AF%94%E5%AF%B9%E5%B7%A5%E5%85%B7%E3%80%81">http://www.ebi.ac.uk/Tools/psa）。打开页面，上面有全局比对工具、</a> 局部比对工具、还有基因组比对工具。</p>
<p>​    首先看全局比对中的蛋白质序列比对工具（图 1）。输入值非常简单，把要比较的两条 蛋白质序列贴在输入框里或者上传。可以使用示例文件 global.fasta 里面的两条序列。如果想 要进一步设置比对的参数，可以点 More options。从这里可以选择使用哪种替换记分矩阵。 按照之前讲过的原则，选择 PAM 矩阵或 BLOSUM 矩阵。如果实在不知道选哪个矩阵，就 闭着眼睛选 BLOSUME62 吧！下拉菜单里默认选的就是BLOSUM62。除了选择替换记分矩 阵，这里还可以设置空位罚分，也就是 gap 的分值。这里实际上是让你选空位对字母的情况罚几分，所以显示的是正数，但在计算的过程中还是按照负数处理。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668059927886.png" alt="1668059927886"></p>
<p>​    计算机只需要用几秒钟的时间，就可以计算出结果（图 2）。在结果页面里，上部是比对使用的参数，以及得出的<strong>序列比对的长度、一致度、相似度、空位比例和比对得分</strong>。下部就是序列比对。在序列比对里，左边是两条序列的名字，因为输入的是 FASTA 格式的序列， 所以程序自动识别出了序列的名字。右边的序列比对分 3 行。上下两行是序列，里面插入了 许多的空位。中间这行标记出了哪些位置上下两个字母是完全相同的，用<strong>竖线</strong>表示。<strong>上下两个字母相似，用双点表示。上下不相似，用单点表示</strong>。字母对空位的情况，用空格表示。</p>
<p>​    这样，我们只要数数比对结果里竖线的个数（40 个），再除以比对的长度（196 个），就可计算 出一致度。再用竖线的个数加上双点的个数（40+29=69 个），除以比对长度（196 个），就是相似度。整个比对里一共插入了 65 个空位，占整个比对长度的 33%。序列两边的数是这一行中的字母在序列中的位置数，而不是这一行的长度。比如第二行是 seq1 的第 49 个字母 到第 97 个字母，是 seq2 的第 27 个字母到第 75 个字母。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668060665974.png" alt="1668060665974"></p>
<h3 id="EMBL-局部双序列比对工具"><a href="#EMBL-局部双序列比对工具" class="headerlink" title="EMBL 局部双序列比对工具"></a><strong>EMBL 局部双序列比对工具</strong></h3><p>​    EMBL 的局部双序列比对工具可以选择经典的 Smith-Waterman 算法。仍然比对蛋白质序 列。输入的序列在示例文件 local.fasta 里面。More options 里面的参数设置和全局比对是一样 的。在这个例子里，我们保持所有参数都为默认值，点提交。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668060778365.png" alt="1668060778365"></p>
<p>​    从比对结果可以看出（图 2），只有中间黑色的相似的部分出现在比对结果中了，两头 红色的不相似的部分被忽略掉了。也就是只返回了局部最相似，得分最高的片段的比对结果。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061385996.png" alt="1668061385996"></p>
<p>​    用这两条序列再做一次全局比对（图 3）。从两次的比对结果可以更清楚的看出，全局比对里前面和后面对得不好的部分在局部比对里就都被忽略了</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061413235.png" alt="1668061413235"></p>
<p>​    除了一长一短两条序列适合做局部比对，有的时候两条差不多长的序列也可以做局部比对，<strong>以找出它们最相似的局部片段</strong>。比如示例文件 local2.fasta 里面的两条序列长度差不多。我们做局部比对看看结果如（图 4）。为了让相似的部分突出出来，我们把 gap 都调大，gap开头调到 10，gap 延长调到 5，提交。  </p>
<p>​    比对结果中，只有黑色的相似的部分出现在最终的比对结果中了，两头红色的不相似的 、部分全部被忽略了（图 5）。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061515140.png" alt="1668061515140"></p>
<p>​    如果给这两条序列做全局比对的话，会发现，绝大部分位置对得都很差，只有中间这一 段对的还不错（图 6）。所以，有时候两条序列并不同源，它们只是有一个功能相似的区域，这时用局部比对我们就能很快找到这一区域在两条序列中的位置。但是如果做全局比对的话，结果就不如局部比对明显了。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061599727.png" alt="1668061599727"></p>
<h3 id="Gap-的类型及分值设置"><a href="#Gap-的类型及分值设置" class="headerlink" title="Gap 的类型及分值设置"></a>Gap 的类型及分值设置</h3><p>​    EMBL 比对工具将 gap 分为两种，一种叫“gap 开头（GAP OPEN）”，另一种叫“gap 延长（GAP EXTEND）”（图 1）。gap 开头就是连续的一串 gap 里面打头的那一个，可以当 它是队长。gap 延长就是剩下的那些 gap，也就是队长后面跟着的小兵。这一串里，第一个 gap 是 gap 开头，后面的都是 gap 延长。单独的一个 gap 按 gap 开头算。</p>
<p>​    gap 开头和 gap 延长 可以分别定义不同的罚分。<strong>默认情况下，gap 开头罚分多，gap 延长罚分少</strong>。全局比对的例子里我们就是用这种搭配组合方案做出的比对。这次我们反过来试试，<strong>让 gap 开头罚分少， 让 gap 延长罚分多</strong>。比如 gap 开头选罚 1 分，gap 延长选罚 5 分，其他参数不变，再作一次看看结果发生了什么变化。 </p>
<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061742608.png" alt="1668061742608">

<p>​    <strong>当 gap 开头小，gap 延长大的时候，做出来的比对里面，gap 很分散</strong>，极少有连续长串 的 gap 出现（图 2-A）。开头的一串 gap 是个例外，因为 seq2 太短， seq1 的这一段只能跟 gap 相对。其他部分的 gap 都是分散出现的。这和我们第一次做出来的比对结果是截然不同的（图 2-B）。在第一次做的结果里，也就是 <strong>gap 开头大，gap 延长小的时候，gap 很集中</strong>，有很多成 长串出现的 gap。</p>
<p>​    大家可以想想其中的奥妙。当 gap 开头大，gap 延长小的时候，说明在连续的字母里插入一个 gap 打开一个缺口要付出很大的代价，因为 gap 开头罚分大。但是这个 缺口一旦打开了，也就是一旦有了第一个 gap，后面再接更多的 gap 就容易了，因为 gap 延 长罚分小。所以这种情况下，gap 都集中连成长串出现。</p>
<p>​    而反过来，当 gap 开头小，gap 延长大的时候，说明在连续的字母里插入一个 gap 打开一个缺口很容易，并不需要付出太大代价，因为 gap 开头罚分小。但是想在第一个 gap 后面再接一个 gap 就难了，因为 gap 延长罚分大。所以这种情况下很难有长串的 gap 出现，gap每延长一个都要付出巨大代价。因此在第二次我们做的结果里（图 2-A）都是分散的 gap。除了开头一段因两条序列长短不同而不得已出现的长串 gap 外，没有其他的长串 gap 了。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061932050.png" alt="1668061932050"></p>
<p>​    这就是说，通过调整 gap 开头和 gap 延长，我们可以把序列比对做成我们期待的样子。举两个例子，看看应该怎样调整 gap 最合理。第一个例子，你知道要比对的两条序列很相似，是同源序列，所以它们的结构和功能也应该都差不多。其中一条序列的结构已知，另一条未知。你想把它们很好的比对在一起，用其中已知结构的序列做模板，来预测另一个序列的结构。这时候我们期待得到的是 gap 分散的比对结果还是 gap 集中的呢？另一例子，你知道要比对的两条序列绝大部分区域都很相似，但是其中一条序列的一个功能区在另一条序列中是缺失的。你想要通过序列比对把这个功能区找出来。这时候我们要怎么设置 gap 开头和 gap延长呢？这两个例子告诉我们，在实际应用中，需要根据不同的情况选取不同的 gap 罚分，以满足不同的生物学意义。如果你对结果没有什么预期，那就请保持默认的参数。</p>
<h3 id="其他在线双序列比对工具"><a href="#其他在线双序列比对工具" class="headerlink" title="其他在线双序列比对工具"></a>其他在线双序列比对工具</h3><p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668236467003.png" alt="1668236467003"></p>
<table>
<thead>
<tr>
<th align="center">软件名</th>
<th align="center">比对类型</th>
<th align="center">网址链接</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EMBL</td>
<td align="center">Global/Local</td>
<td align="center">http:/ / www. ebi.ac.uk/Tools/psa</td>
</tr>
<tr>
<td align="center">PIR</td>
<td align="center">Global</td>
<td align="center"><a href="http://pir.georgetown.edu/pirwww/search/pairwise.shtml">http://pir.georgetown.edu/pirwww/search/pairwise.shtml</a></td>
</tr>
<tr>
<td align="center">Lalign</td>
<td align="center">Global/Local</td>
<td align="center"><a href="http://www.ch.embnet.org/software/LALIGNform.html">http://www.ch.embnet.org/software/LALIGNform.html</a></td>
</tr>
<tr>
<td align="center">LAGAN</td>
<td align="center">Global</td>
<td align="center"><a href="http://agan.stanford.edu/laganweb/index.shtml">http://agan.stanford.edu/laganweb/index.shtml</a></td>
</tr>
<tr>
<td align="center">AligmMe</td>
<td align="center">Alignment of Membrane Proteins</td>
<td align="center"><a href="http://bioinfo.mpg.de/AlignMe/AlignMe.html">http://bioinfo.mpg.de/AlignMe/AlignMe.html</a></td>
</tr>
<tr>
<td align="center">MCALIGN</td>
<td align="center">Alignment fo non-coding DNA sequences</td>
<td align="center"><a href="http://homepages.ed.ac.uk/eang33/mcalign/mcinstructions.html">http://homepages.ed.ac.uk/eang33/mcalign/mcinstructions.html</a></td>
</tr>
<tr>
<td align="center">Biotools</td>
<td align="center">Global/Local</td>
<td align="center"><a href="http://1.51.215.28/~gongj/biotools">http://1.51.215.28/~gongj/biotools</a></td>
</tr>
</tbody></table>
<h2 id="3-8-BLAST搜索"><a href="#3-8-BLAST搜索" class="headerlink" title="3.8 BLAST搜索"></a>3.8 BLAST搜索</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    我们已经学会如何做双序列比对，那可不可以拿一条序列和数据库中的每条序列逐一进行双序列比对，通过这种方法来找相似呢？这确实是一个办法。这样我们只要根据比对后得出的相似度排序，就可以找到最相似的那条序列了。但是，这种方法因计算耗时过长，只是理论上可行而已。之前我们用 EMBL 的双序列比对工具做全局比对，虽然很快就出结果了， 但至少也要经历一两秒钟的时间。而数据库中有几百万条序列，全部比对一遍，耗时太长。因此，我们需要<strong>快速的数据库相似性搜索工具</strong>。目前世界上广泛使用的就BLAST。它可以在尽可能准确的前提下，快速的从数据库中找到跟某一条序列相似的序列。 </p>
<p>​    BLAST 是 Basic Local Alignment Search Tool 的首字母缩写，直译过来就是<strong>基本局部比对搜索工具</strong>。    </p>
<p>​    BLAST 的<strong>基本原理</strong>很简单，要点是<strong>片段对</strong>的概念。所谓片段对是指两个给定序列中的一对子序列，它们的长度相等，且可以形成无空位的完全匹配。(图 1-A )中方框里的就是两个片段对。BLAST 从头至尾将两条序列扫描一遍并找出所有片段对，并在允许的阈值范围内对片段对进行延伸，最终找出高分值片段对（high-scoring pairs, HSPs）（图 1-B）。这样的<strong>计算复杂度是 n 的一次方</strong>（n 是序列的长度）。如果做双序列比对话需要构建一个 n 乘以 n 的表格，计算复杂度是 n 的二次方。所以找高分值片段对比做双序列比对节省了大量的时间，当然，前提是牺牲了一定的准确度。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668240861872.png" alt="1668240861872"></p>
<h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>（按搜索内容分类）</p>
<p>​    BLAST 实际上是综合在一起的一组工具的统称，它不仅可用于直接对蛋白质序列数据库和核酸序列数据库进行搜索，而且可以将待搜索的核酸序列翻译成蛋白质序列后再进行搜 索，或者反之，以提高搜索效率。因此 BLAST 可以分为 <strong>BLASTp，BLASTn，BLASTx，tBLASTn 和 tBLASTx</strong>。  </p>
<ul>
<li>BLASTp 也就是用蛋白质序列搜索蛋白质序列数据库</li>
<li>BLASTn 是用核酸序列搜索核酸序列数据库</li>
<li>BLASTx 是将核酸序列<strong>按 6 条链</strong>翻译成蛋白质序列后搜索蛋白质序列数据库。<ul>
<li><strong>为什么是按 6 条链翻译？</strong>在无法得知翻译起始位点在情况下，翻译可能是从第1个碱基开始，三个三个的往后翻译，也可能是从第 2 个碱基开始，也可能从第 3 个碱基开始。另外还有可能是从 这条链的互补链上开始，这样又有3个可能的开始位置，加起来一共会产生 6 条可能被翻译出来的蛋白质序列。这 6 条中有些是真实存在的，有些是不存在，但是谁真谁假我们无从知晓，所以 6 条序列都要到数据库中去搜索一下试试。</li>
<li>既然是核酸序列，<strong>为什么不做 BLASTn 直接到核酸数据库里去搜索</strong>，而是要到蛋白质数据库里搜索呢？我们说这样做是有意义的，比如，从核酸序列数据库里找不到跟你手里这条核酸序列相似的序列，或 找到了相似的序列但这些找到的序列无法提供有意义的注释信息。这时，就可以去蛋白质数 据库试试，看看这条核酸序列的翻译产物能不能从蛋白质数据库里找到相似的序列以及有意 义的注释信息。或者说，你不是想找跟你这条核酸序列相似的核酸序列，而是想找跟你这条 核酸序列编码蛋白质相似的蛋白质序列，这时就要做 BLASTx。 </li>
</ul>
</li>
<li>tBLASTn 是用蛋白质序列 搜核酸序列数据库，核酸数据库中的核酸序列要按 6 条链翻译成蛋白质序列后再被搜索<ul>
<li>核酸数据库里不是已经注释了某条核酸序列能够翻译成什么蛋白质序列吗？为 什么还要把这些序列可能翻译出来的 6 条蛋白质序列都翻译出来搜索呢？我们说，你看到的 是已经注释的，还有没注释的呢！就算是已经注释的，你看到的也只是已经研究出来的成果， 还有没研究出来的呢！别忘了，基因可以重叠，注释上说某段 DNA 序列可以编码某个蛋白，但是可能某个未被发现的基因也用到了这段 DNA 序列。而你要搜索的这个蛋白质序列可能 刚好就是这个未被发现的基因的翻译产物。这样就必须把核酸序列所有可能的翻译产物都翻译出来，才能搜索得到。  </li>
</ul>
</li>
<li> tBLASTx 是将核酸序列按 6 条链翻译成蛋白质序列后 搜索核酸序列数据库，核酸数据库中的所有核酸序列也要按 6 条链翻译成的蛋白质序列后再 被搜索。这样用 BLASTn 搜不着的，用 tBLASTx 就能搜着了。  </li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668241911377.png" alt="1668241911377"></p>
<h3 id="BLASTp"><a href="#BLASTp" class="headerlink" title="BLASTp"></a>BLASTp</h3><p><strong><a href="http://www.ncbi.nlm.nih.gov/">http://www.ncbi.nlm.nih.gov/</a></strong></p>
<p>1&gt; 在 BLASTp 输入界面里（图 1）：</p>
<ul>
<li>1）输入待搜索的蛋白质序列，这条序列可以在示例文件 blast.fasta 里面找到</li>
<li>2）指定搜索跟输入序列哪部分相似的序列，如果空着就是全长搜索</li>
<li>3）给搜索任务起一个名字，如果输入的是 FASTA 格式的序列，那么在输入框里面点一下，序列的名字就会被自动识别出来。</li>
<li>4）如果在 Align two or more sequences 前面打勾的话，可以同时提交多个 BLAST 任务。 </li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668242455679.png" alt="1668242455679"></p>
<p>2&gt; 在输入界面的下部（图 2）</p>
<ul>
<li>1）选择被搜索的数据库</li>
<li>2）Organism 可以把搜索范围限定在某一特定物种内， 或者排除某一物种</li>
<li>3）在算法选择这一栏里，有之前提到的三种不同的 BLAST 算法，标准BLAST，PSI-BLAST 和 PHI-BLAST</li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668242652994.png" alt="1668242652994"></p>
<p>3&gt; 图形化搜索结果部分</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668242912374.png" alt="1668242912374"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668242929689.png" alt="1668242929689"></p>
<h3 id="PSI-BLAST"><a href="#PSI-BLAST" class="headerlink" title="PSI-BLAST"></a>PSI-BLAST</h3><p>​    为了提高速度，标准 BLAST 牺牲了一定的准确度，牺牲掉的准确度对高度相似的序列， 也就是亲缘关系近的序列构成不了威胁，不会把它们落掉，但是对于那些只有一点点相似， 也就是远源的序列，就有点麻烦了。它们很可能被落掉而没有被 BLAST 发现。 </p>
<pre><code> 要解决这个问题，可以用 **PSI-BLAST**。PSI-BLAST 可以搜罗出一个庞大的蛋白质家族， 当然也包括标准 BLAST 不小心漏掉的那些远房亲戚。换言之，标准 BLAST 找到了直接认识的朋友，但朋友的朋友都丢掉了。PSI 是 **Position-Specific Iterated** 首字母缩写，中文是**位点特异性迭代**。
</code></pre>
<p>​    PSI-BLAST 的特色是搜完一遍再搜一遍，且从第二次搜索开始，每次搜索前都利用上一次搜索到的结果创建一个位置特异权重矩阵以扩大本次搜索的范围。如此反复直至没有新的结果产生为止。<strong>位置特异权重矩</strong>阵（Position-Specific Scoring Matrix，简称 PSSM）是 以矩阵的形式，统计一个多序列比对中，每个位置上不同残基出现的百分比。假设 A 的朋 友只有 B，B 朋友除 A 外还有 C。如果输入序列的第一个位置是 A，那么在第一轮没有 PSSM 辅助的情况下，只有第一个位置是 A 或 B 的序列被找到了。它们是图 1-A 中所示的四条序列。根据这四条序列创建的 PSSM（图 1-B）得知，第一个位置可以是 A，也可以是 B，那么在第二轮搜索中，除了 A 的朋友 B 之外，B 的朋友 C 也可以出现在第一个位置了。这样如此反复，我们就可以找到朋友的朋友了。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243096395.png" alt="1668243096395"></p>
<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243216063.png" alt="1668243216063" style="zoom: 67%;">

<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243227679.png" alt="1668243227679" style="zoom: 67%;">

<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243240064.png" alt="1668243240064" style="zoom:67%;">



<h3 id="PHI-BLAST"><a href="#PHI-BLAST" class="headerlink" title="PHI-BLAST"></a>PHI-BLAST</h3><p>​    PHI-BLAST 和 PSI-BLAST 不同，PSI-BLAST 是撒大网搜索，而 PHI-BLAST 则是<strong>精准搜索</strong>。PHI 是 Pattern-Hit Initiated 首字母缩写，中文是<strong>模式识别</strong>。PHI-BLAST 能找到与输入序列相似的并符合某种特征模式的蛋白质序列。模式 Pattern 是对特征的描述。</p>
<p>​    特定模式可通过正则表达式来表述。所谓正则表达式就是这句话的一个简约的规范性字 符书写法。发生 N 糖基化位点的序列符合的特定模式翻译成正则表达式为 N{P}[ST]{P}。 其中，N 是天冬酰胺，P 是脯氨酸，S 是丝氨酸，T 是苏氨酸。{}代表除大括号里的氨基酸 以外的任意氨基酸，[]代表中括号中的任意一个氨基酸。得知这些符号的含义之后，这个 正则表达式就很容易读懂了。PHI-BLAST 可以根据给入的正则表达式对搜索到的相似序列进行模式匹配，符合正则表达式的才会被作为结果输出。 </p>
<p>​    熟悉一下正则表达式，{}代表除什么以外，[]代表其中之一，x 代表任意字 母，(3,7)代表 3 到 7 个某字符。那么正则表达式{L}GEx[GAS][LIVM]x(3,7)的意思是， 除 L 以外的任意一个字母，紧接 G，再紧接 E，再接一个任意字符，之后是 GAS 中的任意 一个，再接 LIVM 中的任意一个，最后再接 3 到 7 个任意字符。</p>
<p>​    在 NCBI BLAST 工具的输入页面，当算法选择了 PHI-BLAST 之后，会自动出现模式输 入框（图 1）。输入正则表达式 S[IVFL]TPS(2)（含义为：一个 S 后面紧接 IVFL 中的任意 一个字母，再接 T，再接 P，再接两个 S）。这次搜索找到的相似序列中，只有符合该模式的才会被作为结果返回。 </p>
<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243596930.png" alt="1668243596930" style="zoom:67%;">

<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243608075.png" alt="1668243608075" style="zoom:67%;">



<h3 id="SMART-BLAST"><a href="#SMART-BLAST" class="headerlink" title="SMART-BLAST"></a>SMART-BLAST</h3><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243698142.png" alt="1668243698142" style="zoom:67%;">

<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243709460.png" alt="1668243709460" style="zoom:67%;">

<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243748950.png" alt="1668243748950" style="zoom:67%;">

<table>
<thead>
<tr>
<th>位置</th>
<th>服务器</th>
<th align="center">网址链接</th>
</tr>
</thead>
<tbody><tr>
<td>USA</td>
<td>NCBI</td>
<td align="center"><a href="http://www.ncbi.nlm.nih.gov/BLAST">http://www.ncbi.nlm.nih.gov/BLAST</a></td>
</tr>
<tr>
<td>Europe</td>
<td>ExPASys</td>
<td align="center"><a href="http://web.expasy.org/blast">http://web.expasy.org/blast</a></td>
</tr>
<tr>
<td>Europe</td>
<td>Uniprot</td>
<td align="center"><a href="http://www.uniprot.org/blast/">http://www.uniprot.org/blast/</a></td>
</tr>
<tr>
<td>Japan</td>
<td>DDBJ</td>
<td align="center"><a href="http://blast.ddbj.nig.ac.jp/">http://blast.ddbj.nig.ac.jp</a></td>
</tr>
</tbody></table>
<h2 id="3-9-多序列比对介绍"><a href="#3-9-多序列比对介绍" class="headerlink" title="3.9 多序列比对介绍"></a>3.9 多序列比对介绍</h2><h3 id="用途和算法"><a href="#用途和算法" class="headerlink" title="用途和算法"></a><strong>用途和算法</strong></h3><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li>（1）我们可以通过多序列比对确定某一个<strong>未知序列是否属于某一个家族</strong>。</li>
<li>（2）可以用多序列比对<strong>构建系统发生树</strong>，查看物种间或者序列间的进化关系。事实上， 做多序列比对是构建系统发生树的必要步骤之一。</li>
<li>（3）<strong>模式识别</strong>。一些特别保守的序列片段往往对应着重要的功能区。通过多序列比对，可以找到这些保守片段，并由此推测出潜在功能区。</li>
<li>（4）可以把已知的有特殊功能的序列片段通过多序列比对做出<strong>匹配模型</strong>。然后根据这个模型推测未知的序列片段是否也具有这个功能</li>
<li>（5）除此之外，多序列比对在生物信息学分析的很多方面都有应用，比如用来<strong>预测</strong>蛋白质的二级结构和三级<strong>结构</strong>，预测 RNA 的二级结构等等。由</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>​    两条序列的比对需要构建一个二维表格，然后从 右下角到左上角找出一条最优路线。</p>
<p>​    如果是做 3 条序列的比对，应该做一个三维立方体，从 (0,0,0)这个位置到(n,n,n)这个位置找到最优的贯穿路径。</p>
<p>​    以此类推，如果是做 n 条序列的比对，就要创建一个 n 维空间。这个 n 维空间实在是难以想象，但是有一点是明确的， 就是到了 n 维我们已经没有办法再像二维那样精确的计算出比对结果了。</p>
<p>​    由于计算量过于巨大，所以目前所有的多序列比对工具都是不完美的。它们都使用<strong>一种近似的算法</strong>。目的就是为了<strong>缩短计算时间，但也因此牺牲了一定的准确度</strong>。好在多序列比对并不像双序列比对对准确度要求极高。通常，我们是要从多序列比对中看到一个趋势，一个大体的位置，所以牺牲掉的这点儿准确度影响不大。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="序列选取"><a href="#序列选取" class="headerlink" title="序列选取"></a>序列选取</h4><ul>
<li>（1）做多序列比对的序列<strong>个数不能太多</strong>，一般 10 到 15 条序列刚好，最好不要超过 50 条。序列太多，任何软件都受不了。  </li>
<li>（2）<strong>关系太远的序列不适合</strong>做多序列比对。两两之间序列相似度低于 30%的一组序列， 做多序列比对要么做不出来，要么即使勉强做出来了，做得也是零七八碎，没有任何意义。  </li>
<li>（3）<strong>关系太近的序列不适合</strong>做多序列比对。两两之间序列相似度大于 90%的序列，有再多条都只等于一条。做出来的多序列比对无非就是把各条序列抄写了一遍，没有任何意义。  </li>
<li>（4）<strong>短序列受不了</strong>。多序列比对支持一组差不多长的序列，个别很短的序列纯属捣乱分子，受不了。</li>
<li>（5）<strong>有重复域的序列受不了</strong>。如果序列里包含重复片段，大多数多序列比对的程序都会出错，甚至崩溃。  </li>
</ul>
<h4 id="序列起名"><a href="#序列起名" class="headerlink" title="序列起名"></a>序列起名</h4><ul>
<li><p>（1）序列名字里不要有<strong>“空格”</strong>，用下划线代替“空格”是个好习惯。  </p>
</li>
<li><p>（2）不要使用<strong>特殊字符</strong>，比如中文，@，#之类的。</p>
</li>
<li><p>（3）序列名字不要太长，最好在 <strong>15 个字符</strong>以内。  </p>
</li>
<li><p>（4）一组序列里，不要有<strong>重名</strong>的序列。</p>
<p>如果不按上述几点建议命名的话，多序列比对工具会在不告诉你的情况下修改你的序列名称。比如这个名字“This_is_my_favorite_sequence_about_mouse”是一定会被程序截短的。通常只保留前 15 个字符。如果区分各个序列的关键词恰好在后面，那么截短之后，所有序列的名字都一样了，很难分辨。掌握了这几点之后就可以开始做多序列比对了。 </p>
</li>
</ul>
<h2 id="3-10-在线多序列比对工具"><a href="#3-10-在线多序列比对工具" class="headerlink" title="3.10 在线多序列比对工具"></a>3.10 在线多序列比对工具</h2><p>​    目前世界上最流行的多序列比对工具是 CLUSTAL 系列，TCOFFEE 和 MUSCLE。其中 CLUSTAL 系列使用率最高；TCOFFEE 最新，而且还有很多变形；MUSCLE 最快，而且胃口大，能接受的序列数量是其他工具比不了的。各大生物网站，比如 EBI、Expasy 等都可以 在线使用这些工具。当然它们也有自己的网站。 </p>
<h3 id="EMBL-Clustal-Omega"><a href="#EMBL-Clustal-Omega" class="headerlink" title="EMBL-Clustal Omega"></a>EMBL-Clustal Omega</h3><p>​    我们先介绍<a href="http://www.ebi.ac.uk/Tools/msa">EMBL的多序列比对工具</a>。EMBL 的多序列比对工具很多，包括前面提到的 CLUSTAL 系列、TCOFFEE、MUSCLE。我们看 EMBL这些比对工具中 CLUSTAL 系列的最新版本 <strong>Clustal Omega</strong>。 </p>
<h4 id="输入界面"><a href="#输入界面" class="headerlink" title="输入界面"></a>输入界面</h4><p>​    要比较的多条序列存放在 msa.fasta 文件中。这个文件里存了 10 条序列，每条序列都用FASTA 格式书写。这样程序会根据 “&gt;” 自动识别出每条序列以及它们的名字。这就是 FASTA格式的好处。进入Clustal Omega参数输入界面（图 1），黏贴或者上传序列。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669189410701.png" alt="1669189410701"></p>
<p>​    </p>
<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>在这个界面里可以点通过点击 More options，设置各种设置。在这个例子里，所有参数都使用默认值。参数里有输出格式（OUTPUT FORMAT）和输出顺序（ORDER）这两个参数。</p>
<p>​    <strong>输出格式</strong>里可以选择常用的多序列比对格式。我们选标准的 <strong>Clustal 格式</strong>。这是最常见的多序列比对格式。</p>
<p>​    <strong>输出顺序</strong>参数可以设定多序列比对中各个序列的排列顺序。<strong>“aligned”</strong>是按照比对过程中自动创建的计算顺序排列；<strong>“input”</strong>是按照输入序列的原始顺序排列。  </p>
<h4 id="比对结果"><a href="#比对结果" class="headerlink" title="比对结果"></a>比对结果</h4><p>​    做多序列比对的时间要比双序列略长。序列越多，序列越长，则时间越长。Clustal 格式的输出结果如图 2 所示。可以看到，比对中序列的排列顺序跟输入的时候不一样了，这是按 照比对创建时的计算顺序排列的。请点击 Download Alignment File 保存将当前结果，以便后 面章节进一步加工。保存的文件后缀名是<strong>“.clustal”</strong>。它是一个纯文本文件，用写字板或者记事本都可以打开</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669189903511.png" alt="1669189903511"></p>
<p>​    如果想要添加色彩，点击<strong>“Show Colors”</strong>。之后，不同的氨基酸根据它们的理化性质 不同会显示出不同的颜色（图 3）。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669189943396.png" alt="1669189943396"></p>
<p>​    除了颜色之外，多序列比对每一段的最后一行都有些星星点点的标记。这些标记和双序列比对中的竖线、双点、单点的意思类似，但并不完全相同。</p>
<ul>
<li><p>如果某一列是<strong>完全保守的一列</strong>，也就是说这一列里的字母完全相同，那么这一列的下面就打一个<strong>“*”</strong>。</p>
</li>
<li><p>如果这一列的残基有大致相似的分子大小及相同的亲疏水性，也就是这一列的字母<strong>要么相同要么相似</strong>，没有不相似的，那么就打一个<strong>“：”</strong>。</p>
</li>
<li><p>如果这一列残基的分子大小及亲疏水性被一定程度上保留了，但是有替换发生在不相似的残基间，也就是这一列的字母<strong>有相似的也有不相似的</strong>，那么就打一个<strong>“.”</strong>。</p>
</li>
<li><p>什么都不标记代表这一列是完全不保守的，也就是这一列的字母<strong>全部都不相似</strong>。</p>
</li>
<li><p>这些星星点点的标记可以为我们指出<strong>保守区域所在的位置</strong>，即，星星点点特别密集的区域。</p>
</li>
</ul>
<h4 id="结果总结"><a href="#结果总结" class="headerlink" title="结果总结"></a>结果总结</h4><p>​    <strong>Result Summary</strong>标签里，给出了全部结果信息的下载列表和一个 Jalview 的按钮（图 4）。</p>
<p>​    <strong>Jalview</strong> 是多序列比对编辑软件，之后的章节里面我们会详细介绍。</p>
<p>​    在下载列表里，如果打开“<strong>Percent Identity Matrix</strong>”链接，可以得到所有序列两两之间的<strong>一致度矩阵</strong>。一致度矩阵的第一行省略掉了。它和第一列完全相同，都是序列的名字并且按照相同的顺序排列。所以这个矩阵是以对角线为轴对称的，并且对角线上是某条序列自己和自己的一致度，都是 100%。这个矩阵可以帮助我们更好的了解这些序列之间的关系。 比如我们可以从中发现，一致度最 高的一对序列是 TLR1 和 TLR6。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669190687889.png" alt="1669190687889"></p>
<h4 id="系统发生树"><a href="#系统发生树" class="headerlink" title="系统发生树"></a>系统发生树</h4><p>​    除了通过一致度矩阵了解序列间的关系，还可以通过 <strong>Phylogenetic Tree</strong> 标签下的 <strong>Guide Tree</strong> 清楚的看出哪条序列和哪条序列更相似（图 5）。Phylogenetic Tree 翻译成中文是系统发生树。但是这里要<strong>特别注意</strong>，<strong>这不是真正意义上的系统发生树！</strong>它只是在创建多序列比对的过程中用到的树（Guide Tree），没有经过距离校正，所以不能当作系统发生树来使用。如果 想要根据多序列比对结果构建系统发生树，可以在 Alignments 标签下，点击<strong>“Send to ClustalW2_Phylogeny</strong>”链接，把做好的多序列比对发送给专门做系统发生树的工具。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669190796683.png" alt="1669190796683"></p>
<h3 id="TCOFFEE-Expresso"><a href="#TCOFFEE-Expresso" class="headerlink" title="TCOFFEE-Expresso"></a>TCOFFEE-Expresso</h3><p>​    <strong>TCOFFEE</strong> 是一个非常流行的多序列比对工具。TCOFFEE 与 CLUSTAL 系列在所使用的算法上类似，<strong>准确度上比 CLUSTAL 系列略高，但计算耗时也比 CLUSTAL 系列略高</strong>。最关键的是 TCOFFEE 有很多种变形，也就是说它有更多的功能。许多网站都提供 TCOFFEE的在线使用，比如 EMBL 的多序列比对工具里就有 TCOFFEE。但是这次，我们从 <a href="http://tcoffee.crg.cat/">TCOFFEE的网站</a>做多序列比对。 </p>
<h4 id="比对工具"><a href="#比对工具" class="headerlink" title="比对工具"></a>比对工具</h4><p>​    TCOFFEE 本身是一个标准的多序列比对工具，跟 CLUSTAL 没有什么区别。我们来看 它的变形，也就是根据比对序列种类的不同，TCOFFEE 网站下特有的比对工具（图 1）</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669191036312.png" alt="1669191036312"></p>
<p>针对蛋白质序列的比对工具，除了 TCOFFEE 以外，还有 Expresso，M-Coffee, TM-Coffee以及 PSI-Coffee。其中，</p>
<ul>
<li>Expresso 最有特色，它是为序列<strong>加入结构信息后</strong>再做多序列比对的工具。因为有结构信息的辅助，它可以大大提高比对的准确度。</li>
<li>M-Coffee 可以把多个比对的结果<strong>整合成一个</strong>。</li>
<li>TM-Coffee 专为<strong>穿膜蛋白打造</strong>，</li>
<li>PSI-Coffee 专为<strong>远源序列打造</strong>。</li>
<li>同样的还有针对 RNA 和 DNA 序列的 Coffee。</li>
</ul>
<h4 id="Expresso输入界面"><a href="#Expresso输入界面" class="headerlink" title="Expresso输入界面"></a>Expresso输入界面</h4><p>​    做 Expresso 的序列我们选用网站提供的示例序列（图 2）。Show more options 下，可以通过各种方式给入<strong>输入序列的结构信息</strong>。如果你有这些序列现成的结构文件，也就是 PDB文件，可以直接把它们上传上来。三条序列对应三个上传链接。可以上传的结构文件不只限于 <strong>PDB 数据库下载的</strong>，也包括还未正式发表的<strong>解析结构或者计算机预测的结构</strong>，只要是用PDB 文件格式保存的，都可以。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669191410895.png" alt="1669191410895"></p>
<ul>
<li><p>如果没有现成的结构文件，但是这些序列在 PDB 数据库里有对应结构的话，你可以从接下来的输入框里，按照规定的写法，指定哪条序列对应 PDB 数据库中的哪个结构（图 3）。 如果这里输入了信息，Expresso 会自动从 PDB 网站下载指定的 PDB 文件。</p>
</li>
<li><p>那些已经本地上传的结构，Expresso 也会根据序列信息自动匹配出它是哪条序列的结构，不需要再在这里列出了。</p>
</li>
<li><p>如果对结构信息一无所知，只需要将<strong>“MODE_PDB”</strong>钩选。之后，Expresso 就会自己在网络上为所有没有指定结构信息的序列搜索相应的结构。你提供给 Expresso 的结构信息越多，计算时间就会越短；你提供结构信息越少，计算时间就会越长。如果只勾选了 “MODE_PDB”，那么需要等待的时间会很长，因为 Expresso 首先要搜索，然后要下载， 最后要计算。因此，留下你的 Email 信息是很有必要的。 </p>
</li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669191624618.png" alt="1669191624618"></p>
<h4 id="比对结果-1"><a href="#比对结果-1" class="headerlink" title="比对结果"></a>比对结果</h4><p>​    比对结果的页面链接会发送至邮箱。打开链接后会得到 Expresso 做出的比对结果（图 4）。 TCOFFEE 系列各比对工具做出的多序列比对的颜色代表比对质量的好坏。<strong>越红质量越好， 越蓝质量越坏</strong>。这次的比对结果非常令人满意。如果配合上这些序列二级结构信息看一下的话，你会发现，螺旋和螺旋很好的对在了一起，折叠和折叠很好的对在了一起。 </p>
<p>​    同样的序列做普通的 TCOFFEE，质量远不如 Expresso（图 5）。可以看到二级结构全部错位。所以，如果你有序列的结构信息的话，用 Expresso 相比用普通的比对工具会大大提高比对质量。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669191789663.png" alt="1669191789663"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669191805058.png" alt="1669191805058"></p>
<h3 id="多序列比对的保存格式"><a href="#多序列比对的保存格式" class="headerlink" title="多序列比对的保存格式"></a>多序列比对的保存格式</h3><p>​    无论用哪种多序列比对工具，CLUSTAL 系列也好，TCOFFEE 系列也罢，都提供多种格式的多序列比对结果。比如有漂亮的<strong>网页格式</strong>的，标准的 <strong>Clustal 格式</strong>的，还有写完一条 序列再写下一条的 <strong>FASTA 格式</strong>的，以及方便下一步建树使用的 <strong>Phylip 格式</strong>的（图 1）。那到 底保存哪种格式好呢？ </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669191904017.png" alt="1669191904017"></p>
<p>要保存哪种格式主要看你下一步要干什么。在选择保存格式之前，需要问自己几个问题。 </p>
<ul>
<li><p>1）你选的这个格式大多数软件都支持吗？</p>
</li>
<li><p>2）你的同事能用吗？</p>
</li>
<li><p>3）你需要的信息这个格式都提供了吗？</p>
</li>
<li><p>4）这个格式适合进一步加工吗？</p>
</li>
</ul>
<p>通过回答这几个问题来确定你最终需要的格式。如果比对工具输出的格式里没有你想要的哪种，可以通过第三方软件进行格式转换。比如 <a href="http://www.bioinformatics.org/JaMBW/1/2">fmtseq工具</a>，它可以实现 20 多种格式间的转换。其中总有一款是你想要的。</p>
<h2 id="3-11-多序列比对的编辑和发布"><a href="#3-11-多序列比对的编辑和发布" class="headerlink" title="3.11 多序列比对的编辑和发布"></a>3.11 多序列比对的编辑和发布</h2><h3 id="Jalview-的介绍"><a href="#Jalview-的介绍" class="headerlink" title="Jalview 的介绍"></a>Jalview 的介绍</h3><p>​    比对工具刚刚做出来的多序列比对有点儿生，我们通常还需要给它们加工一下。这就需要多序列比对结果编辑器。它能给比对结果添加各种颜色，还能手动编辑比对。常用的比如 Jalview。这个名字我们之间见过。在 EMBL Clustal Omega 比对结果的 Result Summary 标签下有 Jalview 按钮（图 1）。这个按钮可以快速启动 Jalview，但这里启动的在线版本功能不完整。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669192286205.png" alt="1669192286205"></p>
<p>​    完全版的 jalview 可以从 <a href="http://www.jalview.org/">Jalview 官网</a>在线启动，或者下载安装到本地。从这个图 2 可以看出，Desktop 版的 Jalview 和许多序列分析软件及生物数据库之间都有关联。通过 Jalview 除了可以<strong>加工多序列比对</strong>，还可以针对比对中的序列做各种各样的分析、比如<strong>构建系统发生树、预测蛋白质二级结构、查看结构域家族、从 PDB 数据库中查询三级结构</strong>等。此外 Applet 版的 Jalview 可以被加载到网页中，就像 EMBL 的多序列比对工具那样，可以从网页上直接运行并显示某个比对结果</p>
<p>​    在线启动 Desktop 版的 Jalview 可以点击主页右上角的<strong>“Launch Jalview Desktop”链接</strong>。Jalview <strong>基于 java 编写</strong>，所以要安装 java、信任 java、接受 java、运行 java。主页上在线打开的Jalview 也并没有安装到本地，只是下载运行了一个远程连接的小插件而已。断网会导致Jalview 关闭。但这个版本的 Jalview 的功能是完整的。  </p>
<p>​    如果想要将 jalview 安装到本地，获得更稳定的使用体验，可以点击主页上的<strong>“Download”链接</strong>。目前 Jalview 支持几乎所有的操作系统，选择适合你的安装。此外，Windows 版本的安装文件也可以从附件里面下载。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669192470803.png" alt="1669192470803"></p>
<h3 id="Jalview-的操作"><a href="#Jalview-的操作" class="headerlink" title="Jalview 的操作"></a>Jalview 的操作</h3><h4 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h4><p>​    Jalview 打开之后，会自动展示许多 Demo 窗口（图 3）。通过这些窗口，你可以了解到，Jalview 能加工序列比对、做进化树、分析结构，等等。功能确实不少。不过，你需要做的，是把这些窗口统统关掉。打开你自己的多序列比对（图 4）。<strong>点击 File 菜单 - Input Alignment - From File - 打开我们之前用Clustal Omega做出并保存的多序列比对结果“clustalo.clustal”</strong>（如果你忘记保存了可以从附件中下载）。因为“.clustal”不是 Jalview 熟悉的后缀名，所以需要把文件类型改成“所有文件”才能看到它。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669192773697.png" alt="1669192773697"></p>
<p>​    在打开的多序列比对窗口的下方有三行柱状图（图 5）。它们体现了比对中每个位置的<strong>保守度高低（Conservation）、比对质量高低（Score）、以及共有序列（Consensus）</strong>。</p>
<ul>
<li>从<strong>保守度行</strong>，可以很清楚的找到<strong>保守区大致的位置</strong>。</li>
<li><strong>共有序列</strong>指的是某一列<strong>出现频率最高的那个字母</strong>， 比如第 58 列中 W 出现的频率最高，是 100%。如果某一列拥有的最高出现频率的字母是两或两个以上的话，会以“+”显示。把鼠标放在“+”上就可以看到是哪些字母出现的频率一样高。共有序列可以一定程度上体现出某个保守区域所具有的序列特征。以后如果看到和这段序列长相极其相似的序列，它很可能跟这个保守区的功能相似。</li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669193062549.png" alt="1669193062549"></p>
<h4 id="序列上色"><a href="#序列上色" class="headerlink" title="序列上色"></a>序列上色</h4><p>​    现在我们开始加工序列比对。首先先上颜色，在Colour 菜单下有很多种颜色方案（图 6）。<strong>能够和保守度这一行柱状图配合的颜色方案是</strong> <strong>Percentage Identity</strong>。选了这个颜色方案之后， 每一列会根据这一列的保守度用深浅不同的蓝色表示。蓝色越深说明这一列越保守，反之越不保守。再配合 Colour 菜单下的“By Conservation”参数，可以从弹出的参数设定窗口中设定保守程度达到百分之多少以上的才给赋予不同的蓝色，阈值以下的都是白色。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669193267579.png" alt="1669193267579"></p>
<p>​    另一个较常用的颜色方案是 <strong>Clustal 系列配色方案</strong>。这个配色方案和 EMBL 多序列比对工具做出的结果页面里“Show Colors”之后的颜色方案是基本相同的。具体哪个氨基酸选用哪个颜色可以参见表 1。我们从文献里看到的彩色多序列比对，大多是用的这种颜色方案。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669193326724.png" alt="1669193326724"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669193335298.png" alt="1669193335298"></p>
<h4 id="序列修瑕"><a href="#序列修瑕" class="headerlink" title="序列修瑕"></a>序列修瑕</h4><p>​    除了给多序列比对上彩妆，有时还需要给它修理一下局部瑕疵，也就是对局部位置进行手动调整。比如，从前期实验我们得知，图 1 中方框所示区域的 TLR2、10、6、1 这四条序 列的第 53 列应该往右挪一列，跟 TLR9、8、7 这三条序列的第 54 列对在一起。TLR2、10、6、1 这四条序列的第 53 列补空位。其他位置不动。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669193425246.png" alt="1669193425246"></p>
<p>​    要进行如上调整，首先要同时选中要处理的 TLR2、10、6、1 这四条序列：按住 Ctrl建，用鼠标点击这四条序列的名字。选中后，序列名字的底色由白变灰，且四条序列被框入红色虚线框中。然后，再次按住 Ctrl 键，把鼠标放在任意选中序列的第 53 列的字母上，并 向右拖动至第 54 列。拖动后选中序列的第 53 列自动补充空位，原第 53 列移至第 54 列，但是从第 55 列开始往后的位置也都跟着向右移了一位。所以需要再次用同样的方法，按住 Ctrl 键，把鼠标放在任意选中序列的第 58 列的字母上，向左拖动至第 57 列的位置，以保持第53、54 列以外的位置不变。如此，便完成了手动调整。 </p>
<h4 id="调整外观"><a href="#调整外观" class="headerlink" title="调整外观"></a>调整外观</h4><p>​    多序列比对的外观也很重要。默认情况下，多序列比对是单行显示的。由于序列长，需要拖动窗口拉条才能浏览全部。这样不利于查看分析，也不利于将导出的比对图片插入文献。 如果想要让多序列比对根据 Jalview 窗口的<strong>宽度自动换行</strong>，可以在 Format 菜单下勾选<strong>“Wrap”（</strong>图 2）。</p>
<p>​    此外，还可以通过<strong>“Font…”</strong>窗口对字体格式、大小等进行调整。</p>
<p>​     如果你只需要多序列比对，而不需要有关保守度等的注释行。可以关闭 View 标签下的 <strong>“Show annotations”</strong>选项，以达到<strong>去掉注释行</strong>的目的。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669193662270.png" alt="1669193662270"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669193674091.png" alt="1669193674091"></p>
<h4 id="分析功能"><a href="#分析功能" class="headerlink" title="分析功能"></a>分析功能</h4><p>Jalview 除了有编辑多序列比对的功能还有很多分析功能。比如，</p>
<ul>
<li><p>可以按照序列的名字、两两一致度或其他规则给比对中的序列重新排序以及为选中的两条序列做双序列全局比对 （图 4）</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669193741677.png" alt="1669193741677"></p>
</li>
<li><p>为选中的一组序列计算各种系统发生树（图 5）</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669193754095.png" alt="1669193754095"></p>
</li>
<li><p>或者用在线软件为某一条序列预测二级结构（图 6）。Web service 菜单下的所有功能都需要网络支持才能运行。更多 Jalview 的功能需要大家在实践中不断摸索。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669193782753.png" alt="1669193782753"></p>
</li>
</ul>
<h4 id="导出比对图"><a href="#导出比对图" class="headerlink" title="导出比对图"></a>导出比对图</h4><p>最后一步就是导出多序列比对为图片，插入到需要的地方：File 菜单 - Export Image -选择图片格式 - 保存（图 8）。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669193852099.png" alt="1669193852099"></p>
<h3 id="其他比对美化工具"><a href="#其他比对美化工具" class="headerlink" title="其他比对美化工具"></a>其他比对美化工具</h3><p>​    除了 Jalview，还有很多比对美化工具（表 1）。Boxshade 擅长黑白制图。因很多学术期 刊只收取彩图的编辑费，所以黑白图可以节省科研经费。ESPript 的功能十分强大。MView 擅长把彩色多序列比对转换成 HTML 源代码。这样就可以将它直接插入网页，并方便以文本形式选取。 </p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">网址</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JalView</td>
<td align="center"><a href="http://www.jalview.org/">http://www.jalview.org</a></td>
<td align="center">JAVA，可嵌入网页</td>
</tr>
<tr>
<td align="center">Boxshade</td>
<td align="center"><a href="http://www.ch.embnet.org/software/BOX_form.html">http://www.ch.embnet.org/software/BOX_form.html</a></td>
<td align="center">擅长黑白作图</td>
</tr>
<tr>
<td align="center">ESPript</td>
<td align="center"><a href="http://espript.ibcp.fr/ESPript/ESPript">http://espript.ibcp.fr/ESPript/ESPript</a></td>
<td align="center">功能强大</td>
</tr>
<tr>
<td align="center">MView</td>
<td align="center"><a href="http://bio-mview.sourceforge.net/">http://bio-mview.sourceforge.net</a></td>
<td align="center">擅长转换成 HTML 源码</td>
</tr>
</tbody></table>
<p>多序列比对是生物数据分析中特别常用的，也是文章里经常出现的，把它做漂亮了会令你的文章增色不少。把它分析好了，就会从中挖掘出许许多多重要的信息。 </p>
<h2 id="3-12-寻找保守区域"><a href="#3-12-寻找保守区域" class="headerlink" title="3.12 寻找保守区域"></a>3.12 寻找保守区域</h2><h3 id="序列标识图-WebLogo"><a href="#序列标识图-WebLogo" class="headerlink" title="序列标识图 WebLogo"></a>序列标识图 WebLogo</h3><h4 id="保守区域"><a href="#保守区域" class="headerlink" title="保守区域"></a>保守区域</h4><p>如果用一句话来描述你究竟想从多序列比对中得到什么，答案是你想要找到序列中重要的位置。说得更专业一点，就是要找到保守区域。通过多序列比对下方的星星点点可以大致发现图 1 中两个红框中的区域比较吸引眼球，因为星星点点特别多！我们稍微回忆一下这些 密码的含义：“<strong><em><strong>”代表这一列残基完全相同；“</strong>:”</em>*代表这一列残基或者相同或者相似；“</strong>.”**代表这一列残基有相似的但也有不相似的；什么都没有代表这一列残基都不相似。所以我们寻找的就是星星点点特别多的区域。当然用眼睛来数星星不那么靠谱。我们仍然需要借助软件来更好的寻来保守区域。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669257694544.png" alt="1669257694544"></p>
<h4 id="序列标识图"><a href="#序列标识图" class="headerlink" title="序列标识图"></a>序列标识图</h4><p>​    序列标识图（sequence logo）就是序列的 logo，它是以图形的方式依次绘出序列比对中各个位置上出现的残基，<strong>每个位置上残基的累积可以反应出该位置上残基的一致性。每个残基对应图形字符的大小与残基在该位置上出现的频率成正比</strong>。 但图形字符的大小并不等于频率百分比，而是经过简单统计计算后转化的结果。图2 是用一款流行的软件 WebLogo 创建的序列标识图</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669257846230.png" alt="1669257846230"></p>
<p>​    要创建序列标识图，首先需要一个多序列比对。多序列比对中的一列对应序列标识图中的一个位置。然后分别计算每一列中不同残基出现的频率，再根据以下公式把频率转换成高度值，最后根据高度值写出不同残基的彩色字母图形。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669258069096.png" alt="1669258069096"></p>
<ul>
<li>如果某一列<strong>非常保守（熵值小），字母高度就高</strong>。反之，如果某一列没有什么特征，各种残基都有出现，杂乱无章，那么就会看到一堆比较矮的字母摞在一起。</li>
<li>这里再次强调，字母的高度和 它在某一列中出现的频率成正比，但是并不等于频率。试想一下，如果字母高度就是频率的话，那么序列标识图中每个位置上字母摞起来的总高度应该是一样的，都是 100%。</li>
<li>但是从 图 2 中可以看到，序列标识图上每个位置字母摞起来的总高度是不一样的，这是因为在字母高度的计算过程中涉及了熵值。某一列中<strong>字母出现的情况越混乱（越不保守）</strong>，<strong>熵值越大，字母越矮</strong>。<strong>字母出现的情况越有规律（越保守），熵值越小，字母越高</strong>。所以序列标识图可以很好的展现多序列比对中每一列的保守程度，即，它们是杂乱无章的，还有有规律可循的。并且把可循的规律图形化的展现出来。这就是我们为什么要给序列打上 logo 的原因。</li>
</ul>
<h4 id="WebLogo"><a href="#WebLogo" class="headerlink" title="WebLogo"></a>WebLogo</h4><p>​    <a href="http://weblogo.threeplusone.com/">WebLogo</a> 是一款在线创建序列标识图的软件</p>
<p>​    主页面上点<strong>“Create your own logos”，</strong>然后输入多序列比对（图 2）。WebLogo 可以接受大多数常见的多序列比对格式。</p>
<p>​    示例文件 promoter.fasta 是一组启动子序列的多序列比对，以 FASTA 格式存储。FASTA 格式的多序列比对要求把多序列比对中的每一条序列连同插入的空位一起按 FASTA 格式书写，写完一条序列再写下一条。这和之前讲过的 Clustal 格式不太一样。</p>
<p>​    在序列输入框的下方可以设置不同参数，以定义序列标识图的样式，比如设置序列标识图的创建范围、定义字母的颜色方案等。保持所有参数默认，点“Create WebLogo”。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669258505065.png" alt="1669258505065"></p>
<p>​    图 3 为创建出的序列标识图。从图中可以清晰的看到：输入的这些启动子序列上 TATA-Box 的共有特征序列，以及它们出现的位置</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669258644765.png" alt="1669258644765"></p>
<h3 id="序列基序-MEME"><a href="#序列基序-MEME" class="headerlink" title="序列基序 MEME"></a>序列基序 MEME</h3><h4 id="序列基序"><a href="#序列基序" class="headerlink" title="序列基序"></a>序列基序</h4><p>​    在核酸或蛋白质序列中存在一些<strong>有特定模式的序列片段</strong>，这些片段称为<strong>序列的基序（motif）</strong>。</p>
<p>​    序列的基序<strong>与生物功能密切相关</strong>。比如，发生 N 糖基化位点的基序：发生糖基化的天冬酰胺后面一定紧跟一个脯氨酸以外的氨基酸，再紧跟丝氨酸或者苏氨酸，再紧跟一个脯氨酸以外的氨基酸。</p>
<p>​    这个特定模式<strong>可通过正则表达式来规范描述，也可以通过序列标识图来直观描述</strong>。基序的发现要通过大量相关序列的分析。MEME 就是一款可以自动从一组相关的核酸或蛋白质序列中发现序列基序的软件。 </p>
<h4 id="MEME"><a href="#MEME" class="headerlink" title="MEME"></a>MEME</h4><p><a href="http://meme-suite.org/">MEME</a> 是 The MEME Suite 在线软件套装中的一员。MEME 的使用非常简单，只需要将待分析的序列上传即可（图 1）。而且，上传的序列为原始序列， 不需要提前为它们做多序列比对。你也可以指定返回排名前几的基序。MEME 的等待时间 稍长，大约 10 分钟以上，所以最好留下邮箱</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669259059730.png" alt="1669259059730"></p>
<p>​    MEME 的返回结果被保存成各种格式：HTML、XML、test 等。便于在线查看的是“MEME HTML output”，即网页格式。  </p>
<p>​    网页格式的 MEME 结果页面中，给出了找到的排名前三的基序（图 2）。它们以序列标识图的形式展现出来。同时还提供这三个基序在每条序列中的大体位置。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669259236921.png" alt="1669259236921"></p>
<p>​    </p>
<p>​    如果要进一步了解某个基序，可以点击序列标识图右侧的<strong>“More”下面的“↓”箭头</strong>，以查看详细（图 3）。点击后，会得到大比例序列标识图，以及该基序在每条序列中对应的序列片段和它们出现的具体位置。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669259735874.png" alt="1669259735874"></p>
<p>​    </p>
<p>​    此外，还可以点击序列标识图右侧的<strong>“Submit/Download”下面的“→”箭头</strong>（图4），将某个基序提交至各种数据库，并进行<strong>针对该基序的序列相似性搜索</strong>，已找到数据库中含有该基序的序列，进而推测该基序的功能。这步操作是通过 The MEME Suite 软件套装下的另一个软件 FIMO 来实现的。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669259816540.png" alt="1669259816540"></p>
<h3 id="寻找保守区域：PRINTS指纹图谱数据库"><a href="#寻找保守区域：PRINTS指纹图谱数据库" class="headerlink" title="寻找保守区域：PRINTS指纹图谱数据库"></a>寻找保守区域：PRINTS指纹图谱数据库</h3><h4 id="蛋白质指纹"><a href="#蛋白质指纹" class="headerlink" title="蛋白质指纹"></a>蛋白质指纹</h4><p>​    <strong>蛋白质的指纹是指一组保守的序列基序，用于刻画蛋白质家族的特征</strong>。这些基序由多序列比对结果获得，且它们在氨基酸序列水平上是不相邻的，但是在三维结构中可能紧密地结合在一起。</p>
<p>​    目前，科学家已经对现有的蛋白质序列进行了充分的研究，而且早已发现并总结了这序列上的重要基序。相关成果汇入了<strong>PRINTS蛋白质序列指纹图谱数据库</strong>（<a href="http://www.bioinf.manchester.ac.uk/dbbrowser/PRINTS/%EF%BC%89%E3%80%82">http://www.bioinf.manchester.ac.uk/dbbrowser/PRINTS/）。</a></p>
<p>​    PRINTS数据库存储了目前已发现的绝大多数<strong>蛋白质家族的指纹图谱</strong>。对于一个陌生的蛋白质，只要看看它的序列是否符合某个蛋白质家族的图谱就可以对它进行分类并预测它的功能</p>
<h3 id="PRINTS数据库"><a href="#PRINTS数据库" class="headerlink" title="PRINTS数据库"></a>PRINTS数据库</h3><ul>
<li>要浏览PRINTS数据库，可以输入数据库编号、关键词、或标题等以查找某一个指纹谱。比如点击“By text”通过关键词搜索（图1）。输入条中输入“TRANSFERRIN”，也是搜索转铁蛋白家族的图谱。搜索返回转铁蛋白家族的指纹图谱链接。</li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669260466541.png" alt="1669260466541"></p>
<ul>
<li>点击结果页面中的<strong>“TRANSFERRIN”链接</strong>后，会显示包括指纹图谱的基本信息、与其他数据库之间的交叉链接、构建指纹图谱所使用的蛋白质序列、以及指纹图谱中每个基序等具体信息（图 2）。 </li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669260544594.png" alt="1669260544594"></p>
<ul>
<li>点击<strong>“View alignment”链接</strong>后，可以看到创建指纹图谱所使用的多序列比对（图 3）。 </li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669260576266.png" alt="1669260576266"></p>
<ul>
<li>点击<strong>“View structure”链接</strong>后，网页会打开一个三维视图插件，并以该家族中某一特征蛋白质具有的三维结构为例，在线显示指纹图谱中各个基序在三维结构中的位置（图 4）。从该三维结构图中可以看出，紫色的基序在氨基酸序列水平上并不相邻，但是在三维空间结构中是紧密联系在一起的，并形成蛋白质的重要功能区。 </li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669260649303.png" alt="1669260649303"></p>
<ul>
<li><p>除了浏览某一指纹图谱，PRINTS 还提供指纹匹配服务。也就是搜索某一序列所匹配的指纹图谱。此功能通过 PRINTS 主页也上的<strong>“FPScan”链接</strong>实现（图 5）。注意输入的待搜索序列只能是“a raw sequence”，也就是纯序列。换言之，FASTA 格式中带大于号的第一行不能拷贝进输入框。示例文件 prints.fasta 请从课程附件中下载。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669260766944.png" alt="1669260766944"></p>
</li>
<li><p>提交后返回的结果页面中，跟输入序列匹配的指纹图谱，根据匹配得分的高低被排列出来（只列出前十名）（图 6）。此外，还单独列出了排名前三的指纹图谱。由此可知，得分最高的是视紫红质家族的指纹图谱。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669260812152.png" alt="1669260812152"></p>
</li>
<li><p>点击排名第一的视紫红质家族的<strong>“Graphic”链接</strong>，可以得到该家族指纹图谱中各个基序在输入序列中所匹配的位置（图 7）。结果页面的下部还提供了视紫红质家族的 6 个基序在输入序列中所对应的具体序列片段。由此，可以推测，输入序列属于视紫红质家族，并具有该家族蛋白质的主要功能。事实上，输入序列确实是从 UniprotKB 数据库中下载的一条羊的视紫红质的序列（P02700）。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669260897975.png" alt="1669260897975"></p>
</li>
</ul>
<h1 id="第四章-分子进化与系统发生"><a href="#第四章-分子进化与系统发生" class="headerlink" title="第四章 分子进化与系统发生"></a>第四章 分子进化与系统发生</h1><h2 id="4-1-进化的故事"><a href="#4-1-进化的故事" class="headerlink" title="4.1 进化的故事"></a>4.1 进化的故事</h2><h3 id="拉马克与用进废退"><a href="#拉马克与用进废退" class="headerlink" title="拉马克与用进废退"></a>拉马克与用进废退</h3><div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p>​    拉马提出进废退理论。他说生物经常使用的器官会逐渐发达，不经常使用的器官会逐渐退化。而且这种后天获得的性状是可以遗传的，因此生物可以把后天锻炼的成果遗传给下一代。拉马克举了长颈鹿的例子。他说，长颈鹿原本脖子没那么长，但是为了吃到高处树叶不断的伸长脖子，久而久之，他的脖子越伸越长，并且把长脖子这个后天获得的性状，遗传给了下一代。再有鼹鼠一年到头的在地下打洞。因为地下漆黑一片，打洞只要鼻子闻，根本用不着眼睛看，久而久之，都成了瞎子。再有鸟吃饭都不嚼直接咽，所以鸟嘴里都没牙，而哺乳动物比如猫要撕咬食物，所以尖牙利齿。  </p>
<p>​    拉马克主义提出后，生物界支持声和反对声此起彼伏。先来听听反对他的声音。德国科学家魏斯曼做了一个实验。他把老鼠的尾巴都切断，之后再让没有尾巴的老鼠互相交配，生 出的下一代老鼠依然是有尾巴的。然后再把子代老鼠的尾巴切断之后交配，生出的下一代老 鼠依然是有尾巴的。实验一直重复至第 21 代，但是老鼠的尾巴依然长长的，一点儿都没短。于是魏斯曼说拉马克是错的！</p>
</div>



<h3 id="达尔文与自然选择"><a href="#达尔文与自然选择" class="headerlink" title="达尔文与自然选择"></a>达尔文与自然选择</h3><div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p>​    拉马克主义争论了几十年之后，达尔文时代终于来临了。或许你要问的第一个问题应该是“达尔文究竟做了什么？”。除非你与世隔绝，否则你一定听说过查尔斯-达尔文。但在研究出革命性的进化论之前，达尔文的生活却与生物学没什么关系。最初，他从医学院辍学，因为他总是晕血。之后他又差点成为一位神职人员。鉴于他有望成为神的仆人，那么达尔文 不是提出进化概念第一人的事实就不那么令人惊讶了。在大学里，达尔文对自然注意十分着迷。但是要以此作为事业的话，他需要习惯海上的颠簸。1835 年他抵达了加拉帕戈斯群岛， 在那里，自然的独特本质撼动了达尔文的世界。一切始于加拉帕戈斯地雀，在这一列岛中，每个岛上的地雀都长着独特的喙部。独特的喙部似乎都是为了适应不同的食物而生，不管是种子、仙人掌、还是幼虫。达尔文认为这绝不可能是巧合，于是开始调查研究生物的适应性。这项研究话费了 20 年才得以完成。然而他得出的结论却与当时盛行的神创论中关于生物起源的一切观点相悖。</p>
<p>​    达尔文认为，所有的生物物种都存在趋利的适应性变化。并且这些适应性变化会通过一种他称之为“自然选择”的过程遗传下去。而大自然是数百万年间推动演变 进化的唯一力量。这个理念让达尔文成为了现代生物学之父。对于一个渴望成为牧师的人来说，这个称谓也不赖。进化无时无刻不在发生，这一理念产生后，人们就想找到一种机制。 而这就是达尔文的贡献所在，也是他为何会花费如此长的时间进行思考、收集证据以及整理 入书。达尔文认为“物竞天择”意味着，存在一种最初的生物，之后通过某种方式得到了改 良。如果环境对你施加压力，压力有可能是捕食者的威胁或类似的情况，那些通过某种手段 生存下来，并且繁衍后代的生物，他们的后代也能生存下来，并且继续繁衍生息。因此，如 今我们所见到的动植物都拥有很强的适应性。他们所表现出来的适应性使得他们成功存活，并继续繁衍下一代。</p>
</div>



<h2 id="4-2-基本概念"><a href="#4-2-基本概念" class="headerlink" title="4.2 基本概念"></a>4.2 基本概念</h2><h3 id="如何研究进化"><a href="#如何研究进化" class="headerlink" title="如何研究进化"></a>如何研究进化</h3><h4 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h4><ul>
<li><p>化石</p>
<p>这是进化最直接，最确凿的证据。假如我们可以获得某个物种自诞生之日起每隔一百年的所有完整化石， 那么我们就可以看出这个物种是怎么一点一点演变来的。但是非常可惜的是，生物化石很零散，不完整。人类得到生物化石是个极其偶然的事件。  </p>
</li>
<li><p>利用比较形态学、比较解剖学和生理学等手段，确定大致的进化框架</p>
<p>这种方法比第一种方法更容易实现。但是这种方法仅局限于大致 的框架，很多细节是存在争议的。只能是仁者见仁智者见智，因为用肉眼观察存在误差。还有一个问题就是伦理学问题。</p>
</li>
</ul>
<h4 id="分子进化方法"><a href="#分子进化方法" class="headerlink" title="分子进化方法"></a>分子进化方法</h4><ul>
<li>利用软件，从分子水平上构建物种的进化树。这里说的分子水平是指 DNA、RNA、以及蛋白质序列。通过前几章的学习，我们知道随着测序技术的发展，这种分子水平上的信息量大而丰富，获取十分便捷。当然有优点自然就有缺点。缺点就是准确度依赖软件的优劣及参数的设置。随着相关软件的不断升级，这个缺点也再逐渐被克服。 </li>
<li><strong>分子进化理论</strong>：<ul>
<li>分子进化理论是 1962 年美国科学家 <strong>Linus Pauling</strong>提出的。</li>
<li>这种理论与传统研究方法的最大区别是，它研究的是 DNA、RNA 以及蛋白质序列这些<strong>分子水平上的信息</strong>，而不是物种的外在特征。并且基于某一个特定的分子在不同物种中的序列差异来<strong>构建系统发生树</strong>。</li>
<li>此外，分子进化有两个基本的假设条件，只有接受这两个假设，分子进化理论才能得以实施。<ul>
<li>第一、DNA、RNA 或蛋白质序列包含了物种的所有进化史信息。</li>
<li>第二是<strong>分子钟理论</strong>。这个理论说的是，一个特定基因或蛋白质的进化变异速度在不同物种中是基本恒定的。所谓变异速度是指一定时间内不同碱基或氨基酸突变的个数。这 进化变异速度被认为是恒定的，跟物种没有关系。所以，拿蛋白质来说，两个蛋白质在序列上越相似，他们距离共同祖先就越近。</li>
</ul>
</li>
<li>分子钟理论是进化研究领域被普遍认可的理论，但是至今也没有直接的证据证实。 </li>
</ul>
</li>
</ul>
<h3 id="不同的同源"><a href="#不同的同源" class="headerlink" title="不同的同源"></a>不同的同源</h3><h4 id="同源Homologs"><a href="#同源Homologs" class="headerlink" title="同源Homologs"></a>同源Homologs</h4><ul>
<li>来源于共同祖先的相似序 列为同源序列。</li>
<li>也就是说，相似序列有两种，一种是来源于共同祖先的，那么他们可以叫同源，另一种不是来源于共同祖先的，那么他们尽管相似也不能叫同源。第二种情况出现的概率虽然低，但还是存在的，所以相似序列并不一定是同源序列。</li>
<li>同源又分为三种，直系同源，旁系同源和异同源。  </li>
</ul>
<h4 id="直系同源（Orthologs）"><a href="#直系同源（Orthologs）" class="headerlink" title="直系同源（Orthologs）"></a>直系同源（Orthologs）</h4><p>​    <strong>来自于不同物种的、由垂直家系，也就是物种形成，进化而来的基因，并且典型的保留与原始基因相同的功能。</strong>也就是说，随着进化分支，一个基因进入了不同的物种，并保留了原有功能。这时，不同物种中的这个基因就属于直系同源。  </p>
<h4 id="旁系同源（Paralogs）"><a href="#旁系同源（Paralogs）" class="headerlink" title="旁系同源（Paralogs）"></a>旁系同源（Paralogs）</h4><p>​    <strong>是指在同一物种中的来源于基因复制的基因，可能会进化出新的但与原功能相关的功能来</strong>。</p>
<p>​    基因复制产生了两个重复的基因，多出来的这个有几种命运，一 个是又丢了。复制出来发现没有用，又删了。另一种命运是演化出了新的功能。如果这个新功能是往好的方向发展，就会被保留下了，如果是往不好的方面发展，就会被自然选择淘汰。 还有一种命运，就是被放置不用。复制出来以后，又加了个终止子，既不表达，也不删除， 搁那里搁着不管，成了伪基因。被保留下来的具有新功能的基因与另一个复制出来的基因之间就是旁系同源。  </p>
<h4 id="异同源（Xenologs）"><a href="#异同源（Xenologs）" class="headerlink" title="异同源（Xenologs）"></a>异同源（Xenologs）</h4><p>​    <strong>通过水平基因转移，来源于共生或病毒侵染所产生的相似基因。</strong>异同源的产生不是垂直进化而来的，也不是平行复制产生的，而是由于原核生物与真核生物的接触，比如病毒感染，在跨度巨大的物种间跳跃转移产生的</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669275627757.png" alt="1669275627757"></p>
<p>不同的同源，概念很容易混淆。图 1 清楚的描述了各种同源之间的关系。首先，有个早期的球蛋白基因，它通过基因复制，形成了α球蛋白基因和β球蛋白基因。后来随着进化，这两种复制产生的基因也存在于不同的物种中。</p>
<p>​    其中某一物种里的，比如老鼠里的α球蛋白基因和β球蛋白基因就属于旁系同源。</p>
<p>​    而某一个基因在不同物种中，比如青蛙里的α球蛋白基因和鸡里的α球蛋白基因就属于直系同源。</p>
<p>​    再比如，某个细菌，它没有早期的球蛋白基因，也自然没有β球蛋白基因，但是通过与青蛙的共生，发生了基因水平转移。于是它从某一天就起有了β球蛋白基因。那么这个细菌的β球蛋白基因和青蛙的β球蛋白基因就属于异同源。 </p>
<div class="note warning simple"><p>特别注意！！！</p>
<p>同源只是对性质的一种判定，只能定性描述，不能定量描述。所以“同源性等于 80%”这种 说法是错误的！ </p>
</div>

<h3 id="“树状”还是“网状”"><a href="#“树状”还是“网状”" class="headerlink" title="“树状”还是“网状”"></a>“树状”还是“网状”</h3><div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p>​    越来越多的细菌和动植物的基因组测序显示，基因并不是简单遗传给生命树上的个别枝条，它们还在物种之间以不同的进化路径转换，其结果是一个杂乱无章的“生命网”。这里 要区分“树”和“网”的概念。在计算机科学领域，树的定义规定，树上从一个点到另一个点的路径只有唯一的一条。而当两点之间的路径个数≥2 的时候，就形成了网。编织生命网 的要素之一就是水平基因转移。水平基因转移，是指生物将遗传物质传递给其他细胞而非其子代细胞的过程。 </p>
<p>​    早在 1993 年，就有生物学家提出细菌的基因排序不是树状的，而是网状的。1999 年，美国《科学》杂志发表言论说：“生命进化树并不是真实存在于自然界中的，而是人类用来规划自然界的一个理论。”但是，有研究者运用更多的研究捍卫达尔文的观点，认为所谓网状的进化论是理想化、不切实际的想法。</p>
<p>​     “树状”和“网状”的辩论在 2006 年正式拉开帷幕。位于德国海德堡的欧洲分子生物实验室（EMBL）派出由皮尔·博克领导的工作组，研究了来自细菌、古细菌以及真核细胞 的 191 个基因组。他们发现，其中 31 组基因没有任何迹象表明曾经被水平转移过，和尚未 完善的“树”相近。但是，来自德国杜塞尔多夫大学的达冈和马汀教授认为，31 组的结果 不能够证明什么，这个数字太小。 2008 年，达冈和他的团队研究了 181 个基因组，发现 80％ 的基因组存在水平基因转移，即网状树。 </p>
<p>​    此外，杂交也可能是物种进化的有力驱动。来自伦敦大学的生物进化学家詹姆斯·马里特说：“杂交是非常普遍的现象，有 1／10 的动物都是杂交的。”2008 年，美国得克萨斯大学 的科学家在包括家鼠、野鼠和非洲爪蛙在内的 8 种动物的基因组中发现了一种奇特的 DNA。 这是鸡、大象和人类所没有的 DNA，这说明它是一些动物通过异种交配形成的。几年前，科学家也曾在牛体内发现蛇的 DNA。此外，鱼类、昆虫和植物中也都曾发现水平基因转移 现象。<strong>这些新发现意味着，有一些物种的进化是呈现树状的，而有一些却不是，所以用达尔文的进化枝条来连接物种似乎过于简单了</strong>。  </p>
</div>





<h2 id="4-3-系统发生树"><a href="#4-3-系统发生树" class="headerlink" title="4.3 系统发生树"></a>4.3 系统发生树</h2><h3 id="系统发生树的样子"><a href="#系统发生树的样子" class="headerlink" title="系统发生树的样子"></a>系统发生树的样子</h3><p>​    研究分子进化所要构建的<strong>系统发生树（Phylogenetic tree）</strong>，也叫分子树。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>​    首先来看从系统发生树上我们都能研究出什么？</p>
<ul>
<li><p>对于一个未知的基因或蛋白质序列，可以利用系统发生树<strong>确定与其亲缘关系最近的物种</strong>。比如你得到了一个新发现的细菌的核糖体 RNA，你可以把它跟所有已知的核糖体 RNA 放在一起，然后用他们构建一棵系统发生树。这样就可以从树上推测出谁和这个新细菌的关系最近。</p>
</li>
<li><p>系统发生树还可以<strong>预测一个新发现的基因或蛋白质的功能</strong>。以基因为例，如果在树上与新基因关系十分密切的基因的功能已知，那么这个已知的功能可以被延伸到这个新基因上。</p>
</li>
<li><p>构建系统发生树还有助于<strong>预测一个分子功能的走势</strong>。也就是从树上可以看出某个基因是正在走向辉煌还是在逐渐衰落。</p>
</li>
<li><p>最后，系统发生树还能帮助我 们<strong>追溯一个基因的起源</strong>。甚至当它从一个物种“跳”到另一个物种上，也就是发生了水平基因转移时，系统发生树都可以很好的展示出来</p>
</li>
</ul>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>​    树是从<strong>根</strong>（root）长出来的。从根延伸出的树枝就叫<strong>枝</strong>（branch/lineage）。枝上有分叉，分叉的地方就叫<strong>节</strong>（node）。枝的顶端顶着的就是<strong>叶</strong>（leaf）。根、节和叶都可以叫做<strong>节点</strong>（node）。但是叶后面不再有枝了，是最外面的节点，所以叫<strong>外节点</strong>（outer node）。而节的前后都有枝，所以叫<strong>内节点</strong>（inner node）。</p>
<p>根是一切的起源，习惯上就叫根。根和节都表示理论上曾经存在的祖先，叶子是现存的物种。这一点很重要！比如我们要研究某个基因，于是搜集了很多物种的这个基因的序列，用它们构建了一棵系统发生树。搜集到的物种都出现在叶子上，也就是外节点上，没有在内节点上的。内节点上都是理论上曾经存在过的共同祖先，现在已经不存在了！此外，枝子的长短也是有意义的，我们后面再讲。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669363750772.png" alt="1669363750772"></p>
<p>​    用软件创建出的系统发生树有各种形状。圆形的，方形的，三角形的等（图 2）。从生物学意义上没有任何区别，只是表现形式不同而已。根据建树所用序列的多少来选择不同形状的树。如果序列非常多，那么圆形的看上去就要比方的或者三角的舒服得多，便于在文献里排版。<strong>系统发生树上从任何一个点发出的枝子围着这个点旋转都不改变树的生物学意义</strong>， 只是视觉上有点儿差别而已。所以，旋转之后的两棵树是等价的，生物学意义完全相同。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669363816958.png" alt="1669363816958"></p>
<h3 id="系统发生树的种类"><a href="#系统发生树的种类" class="headerlink" title="系统发生树的种类"></a>系统发生树的种类</h3><h4 id="有根树与无根树"><a href="#有根树与无根树" class="headerlink" title="有根树与无根树"></a>有根树与无根树</h4><p>​    系统发生树还分为<strong>有根树和无根树</strong>（图 1）。顾名思义，有根树就是有根，无根树就是无根。</p>
<p>​    其实两者是可以互换的。如果我们按住无根树上某一个点，然后用把梳子将树上所有 的枝条都以这个点为中心向右梳理，就能把它梳成有根树的样子。按住的这个点就是根。所 以对于一棵树来说，根的位置是主观的，你想让他在哪它就在哪里。但是你不能随意指定哪个内节点当根，毕竟根有其自身的生物学意义，它应该是所有叶子的共同祖先。那么我们如何确定根的位置呢？可以通过<strong>外类群</strong>（outgroup）来确定，从而把无根树变成有根树。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669363969013.png" alt="1669363969013"></p>
<p>​    <strong>有根树反映了树上基因或蛋白质进化的时间顺序</strong>，过分析有根树的树枝的长度，可以了解不同的基因或蛋白质以什么方式和速率进化。</p>
<p>​    而无根树只反映分类单元之间的距离,而不涉及谁是谁的祖先问题。</p>
<p>​    做有根树需要指定外类群。所谓外类群，就是你所研究的内容之外的一个群。比如你要分析某一个基因在不同人种间的进化关系，那就可以额外选择黑猩猩加入进来，作为外类群一同参与建树。或者你要分析哺乳动物，那就可以选鳄鱼、乌龟之类的。总之，保证外类群在你要研究的内容之外，但又不能太远。外类群可以不只是一个物种，而是多个，但也不要太多，两三个即可。为什么有了外类群之后，做出来的树就是有根树了呢？因为你知道外类群和你研究的内容一定不是一伙的，所以外类群分支出的那个内节点就是根。  </p>
<h4 id="物种树"><a href="#物种树" class="headerlink" title="物种树"></a>物种树</h4><p>​    1998 年，伍斯提出了一个涵盖整个生命界的系统树（图 2），也叫物种树。之后这棵树被后人不管的补充，不断的修改，不断的完善，变得无比常庞大。物种树勾画了生物进化的 大致轮廓。从完全版的物种树上，可以找到目前人类已发现的所有有生命的东西。</p>
<p>​    我们这里讲的分子树跟物种树是有本质区别的。物种树是基于每个物种整体的进化关系，也就是基于整个基因组构建的，<strong>而分子树是基于不同物种里某一个基因或蛋白质序列之间的关系构建的</strong>。那么一个分子树表达出来的各物种之间的关系就可能与物种树完全不同。此时，说明这个基因经历了特殊的进化故事。也许是受到了特殊环境变化的影响，也许是发生了水平基因转移等等。总之，这种区别的出现是很有研究价值的。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669364275050.png" alt="1669364275050"></p>
<h2 id="4-4-系统发生树的构建"><a href="#4-4-系统发生树的构建" class="headerlink" title="4.4 系统发生树的构建"></a>4.4 系统发生树的构建</h2><h3 id="构建方法"><a href="#构建方法" class="headerlink" title="构建方法"></a>构建方法</h3><ul>
<li><p>括非加权分组平均法 （Unweighted Pair Group Method with Arithmetic mean，<strong>UPGMA</strong>），</p>
</li>
<li><p>最近邻居法（Neighbor Joining method，<strong>NJ</strong>）</p>
</li>
<li><p>最小二乘法（Generalized Least Squares，<strong>GLS</strong>）</p>
</li>
<li><p>最大简约法 （Maximum Parsimony，<strong>MP</strong>）</p>
</li>
<li><p>最大似然法（Maximum Likelihood，<strong>ML</strong>）</p>
</li>
<li><p>贝叶斯推断法（Bayesian  Inference，<strong>BI</strong>）</p>
</li>
</ul>
<p>计算速度：基于距离的方法（UPGMA， NJ）&gt; 最大简约法 &gt; 最大似然法 &gt; 贝叶斯法</p>
<p>计算准确度：贝叶斯法 &gt; 最大似然法 &gt; 距离法 &gt; 最大简约法 &gt; 基于距离的方法（UPGMA， NJ）</p>
<p>最大似然法最实用，5因为这种方法无论从速度还是准确度都比较适中。</p>
<p>最近邻居法虽然算得快，但是当序列多，彼此差别小的时候，这种方法不适合。</p>
<p>最大简约法，似乎是个掉空里的方法，高不成低不就，所以很少有人使用。</p>
<p>贝叶斯法不是所有的建树软件都提供，算法开发上还有待提高，而且计算时间过长。<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669364957655.png" alt="1669364957655"></p>
<h3 id="建树软件"><a href="#建树软件" class="headerlink" title="建树软件"></a>建树软件</h3><table>
<thead>
<tr>
<th align="center">软件</th>
<th align="center">说明</th>
<th align="center">网址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PHYLIP</td>
<td align="center">免费的、集成的进化分析工具</td>
<td align="center"><a href="http://evolution.genetics.washington.edu/phylip.html">http://evolution.genetics.washington.edu/phylip.html</a></td>
</tr>
<tr>
<td align="center">MEGA</td>
<td align="center">图形化、集成的进化分析工具</td>
<td align="center"><a href="http://www.megasoftware.net/">http://www.megasoftware.net/</a></td>
</tr>
<tr>
<td align="center">PAUP</td>
<td align="center">商业软件，集成的进化分析工具</td>
<td align="center"><a href="http://paup.csit.fsu.edu/">http://paup.csit.fsu.edu/</a></td>
</tr>
<tr>
<td align="center">PHYML</td>
<td align="center">最快的 ML 建树工具</td>
<td align="center"><a href="http://www.atgc-montpellier.fr/phyml/">http://www.atgc-montpellier.fr/phyml/</a></td>
</tr>
<tr>
<td align="center">MrBayes</td>
<td align="center">基于贝叶斯方法的建树工具</td>
<td align="center"><a href="http://mrbayes.csit.fsu.edu/">http://mrbayes.csit.fsu.edu/</a></td>
</tr>
</tbody></table>
<p>如果构建的系统发生树要用于发表生物信息学领域的文章，需要两种以上的构建方法锁定同一个结果才能审稿通过。如果是用于发表以生物实验为主的文章用一种构建方法就可以了。 </p>
<h3 id="UPGMA法"><a href="#UPGMA法" class="headerlink" title="UPGMA法"></a>UPGMA法</h3><p>​    虽然软件可以快速自动地完成系统发生树的构建，但是对于基本算法的了解还是必不可少的。以<strong>非加权分组平均法（UPGMA 法</strong>）为例，介绍如何通过计算所有序列两两间的距离， 再根据距离远近构建系统发生树。序列两两间的距离可以用双序列比对得出的一致度/相似度代表，或用其他简化值代替。 </p>
<p>​    比如，有如下 A、B、C、D 四条序列： </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669365379467.png" alt="1669365379467"></p>
<p>​    </p>
<p>​    在接下来的例子里，我们用<strong>序列间不同的碱基数目作为序列间遗传距离的度量</strong>。首先，计算出每两条序列间有几个碱基不同，并以用矩阵的形式记录下这些距离。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669365434628.png" alt="1669365434628"></p>
<p>​    </p>
<p>​    <strong>找出距离最小的一对序列</strong>。A 和 B 之间的距离最小，d[AB]=1。然后将 A 与 B 合并聚集，其分支点为 d[AB]/2=1/2=0.5。即，A、B之间的距离等于 1，从中间折叠后每边各 0.5。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669365498734.png" alt="1669365498734"></p>
<p>​    </p>
<p>​    现在，<strong>把(AB)看成一个整体， 分别计算它们与 C 和 D 的距离</strong>。(AB)和 C 的距离等于 A 和 C 的距离加上 B 和 C 的距离除以 2，即，d[(AB)C]=(d[AC]+d[BC])/2 =(2+3)/2=2.5。同样，(AB)和 D的距离等于 A 和 D 的距离加上 B 和 D 的 距 离 除 以 2 ， 即 ， d[(AB)D]=(d[AD]+d[BD])/2=(4+3)/2=3.5。据此，计算出新的距离矩阵，并找出新矩阵中最小的距离。C 和 D 之间的距离最小，d[CD]=2。将 C 和 D 进行合并聚集，其分支点为 d[CD]/2=2/2=1。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669365636031.png" alt="1669365636031"></p>
<p>​    </p>
<p>​    接下来，把(CD)看成一个整体，计算它们与(AB)之间的距离。(CD)与(AB)之间的距离等 于 C 和 (AB) 的 距 离加上D 和 (AB) 的 距 离 除 以 2 ， 即 ， d[(CD)(AB)] = (d[C(AB)]+d[D(AB)])/2 =(2.5+3.5)/2=3。最后，将(AB)与(CD)进行合并聚集，归为一类，分支点为 d[(CD)(AB)]/2=3/2=1.5。这样，A、B、C、D 四条序列的系统发生树就构建好了。树上，枝的长短直接反应了它们与共同祖先的距离。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669365951511.png" alt="1669365951511"></p>
<h3 id="序列选取原则"><a href="#序列选取原则" class="headerlink" title="序列选取原则"></a>序列选取原则</h3><p>​    分子进化的研究对象是核酸和蛋白质序列。如果要研究某个基因的进化，是应该选用它的 DNA 序列，还是翻译后的蛋白质序列呢？</p>
<p>​    序列的选取要遵循以下原则：</p>
<ul>
<li><p>1）如果 DNA 序列两两间的一致度≥70%，选用 DNA 序列。因为，如果 DNA 序列都如此相似，它们对应的蛋白质序列会相似到几乎看不出区别。这对于构建系统发生树是不利的。所以这种情况选用 DNA 序列，而不选蛋白质序列。</p>
</li>
<li><p>2）如果 DNA 序列两两间的一致度&lt;70%，DNA 序列和蛋白质序列都可以选用。</p>
</li>
</ul>
<h2 id="4-5-MEGA构建NJ树"><a href="#4-5-MEGA构建NJ树" class="headerlink" title="4.5 MEGA构建NJ树"></a>4.5 MEGA构建NJ树</h2><h3 id="建树准备"><a href="#建树准备" class="headerlink" title="建树准备"></a>建树准备</h3><p>​    这一节将给你演示如何用 MEGA7 软件构建系统发生树。为何挑这个软件来演示呢？</p>
<p>1） 软件免费；2）软件在默认设置下建树的效果就很好；3）软件被业界普遍认可，做出结果可 以用于文章发表；4）软件支持多操作系统，而且安装简单。  </p>
<pre><code> MEGA7 是完全的图形化界面操作（http://www.megasoftware.net/）。在接下来的例子里我们要为附件中 TIR.fasta 里的序列构建 NJ 树。TIR.fasta 里存储了 10 条人的不同 Toll 样受 胞内域的氨基酸序列。只有具有一定亲缘关系，也就是彼此比较相似，但又存在一定差别的序列拿来做多序列比对，或拿来构建系统发生树才有意义。
</code></pre>
<ul>
<li>点击 MEGA 主窗口上的 File - Open A File - 找到并打开 <strong>TIR.fasta</strong>。这时，MEGA 会询问以何种方式打开。在介绍多序列比对时曾经说过，想要做系统发生树先要做多序列比对，然后把多序列比对结果提交给建树软件去建树。所以，<strong>此时可以输入一个现有的多序列比对，也可以输入原始序列</strong>，让 MEGA 先来做多序列比对，再建树。TIR.fasta 里面的序列为原始序列，需要 MEGA 来做多序列比对，因此选“Align”。</li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669366454881.png" alt="1669366454881"></p>
<ul>
<li>选择“Align”之后，在弹出的 Alignment Explorer 窗口上点击 Alignment - Align by ClustalW。MEGA 提供 ClustalW 和 Muscle 两种多序列比对方法。这里选择熟悉的 ClustalW 方法。弹出窗 口 询 问 “ Nothing  selected for alignment. Select all? （是否要选择所有序列来做多序列比对) ”，选择 OK。  <img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669366533402.png" alt="1669366533402"></li>
</ul>
<ul>
<li>之后，弹出多序列比对参数设置窗口。这个窗口和EMBL 的多序列比对在线工具一样，可以设置替换记分矩阵、不同的空位罚分等参数。MEGA 的所有默认参数都不是随便设置的，这些经过反复考量默认设置好的参数保证了 MEGA 傻瓜机全自动档的品质。所以，当你无从下手的时候，直接点 OK，接受这些默认参数，开 始计算多序列比对。  </li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669366583062.png" alt="1669366583062"></p>
<ul>
<li><p>将这个多序列比对作为中间结果保存下来。在 Alignment Explorer 窗口上点 Data - Export Alignment - MEGA Format。注意这里一定选 MEGA format 以方便 MEGA 继续加工。其他格式适用于其他软件。选择 MEGA 格式文件，文件自动赋予后缀名“.meg”。保存后，弹出窗口，要求给这组数据命名，命名为“test”。生成的 <strong>TIR.meg</strong> 文件属纯文本文件，可以用记事本打开查看，里面是用 MEGA 固有格式书写的多序列比对结果。 </p>
</li>
<li><p>可以双击“TIR.meg”文件将其导入 MEGA。也可直接将其拖入 MEGA 主窗口中。拖入后， 主窗口里增加了一个<strong>TA图标</strong>。点击该图标，弹出新窗口 Sequence Data Explorer，其中显示 出 MEGA 格式的多序列比对。</p>
</li>
<li><p>再点击 Sequence Data Explorer 窗口上的 TA 按钮。点击后， 多序列比对中的 10 条序列之上增加了一行。这一行是根据多序列比对结果分析得出共有序列（consensus sequence），也就是每一列里出现次数最多的那个字母。多序列比对中，每一 列里的字母<strong>如果和共有序列的字母相同则打点，不同则标出不同的字母，空位还是空位</strong>。</p>
</li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669367040617.png" alt="1669367040617"></p>
<ul>
<li><p>如果你想进一步了解这些序列的保守程度，可以点击<strong>C按钮</strong>，以黄色标记保守列，或者点击<strong>V按钮</strong>，以标黄标记不保守列。通过对比对结果的进一步分析，可以淘汰掉一些序列。比如海选的序列里有有一 些明显不合群的序列，就可以把它们前面的钩去掉，不让它们参与建树，以免影响建树质量。</p>
</li>
<li><p>此外，还可以对这些序列进行<strong>分组标记</strong>。点击分组按钮“①”。我们让 TLR3、7、8、9这四个内质网上的蛋白质序列在一组，点 “②，更改组名为“ER”。然后按住 Ctrl 键同时选中 Ungrouped Taxa 列表里的 TLR3、7、8、9 四条序列的名字。选中后点击”③“ ，将选中的序列归入 ER 组。再次点击“②” ，创建第二组，更名为 CM，即细胞膜上的蛋白质。按住 Ctrl 选中 Ungrouped Taxa 列表里剩下的所有序列，点击”③” ，将它们归入 CM 组。当序列数量较多的时候，人为分组，可以从树上更加清楚的看出组内哪些成员叛逃了去了别组。</p>
</li>
<li><p>此外，输入序列的名字较长。这样的名字如果作为构建的系统发生树上叶子的名字，会破坏树的外观也不利于信息的解读。因为，需要人为修改一下序列的名字。选中序列后点击“④”，把名字改为能区分彼此的关键词，比如只保留 TLR*。全部更改好之后，点 “⑤”，准备工作全部完成。</p>
</li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669372420448.png" alt="1669372420448"></p>
<h3 id="建树过程"><a href="#建树过程" class="headerlink" title="建树过程"></a>建树过程</h3><p>​    开始建树。点击 MEGA 主窗口上的 <strong>Phylogeny 下拉菜单</strong>，之前提到的各种建树方法这里基本都有。选 Neighbor Joining（最近邻居法）。弹出窗口询问是否使用当前 TIR.meg 里面的数据，选 Yes。接下来，弹出参数设置窗口（Analysis Preferences）。</p>
<p>​    参数设置对构建的系统 发生树的准确程度来说非常重要。在树构建好之后，还经常需要根据树的具体情况，重新设置参数，并重新建树，如此反复，直至结果令人满意为止。同样的，如果对于参数依然摸 着头脑，不知道应该怎样设置，那么继续使用 MEGA 的自动挡，接受默认参数，也能做出基本满意的系统发生树。如果想要做出更好的树，至少应该掌握其中三个参数的设置。</p>
<p>​    第一个参数 是 <strong>Test of phylogeny（建树的检验方法）</strong>。默认值为不进行检验。这显然比较偷工减料，不检验怎么知 道建出来的树质量如何，是否可信！因此，检 验 方 法 选 常 用 的<strong>Bootstrp method（步长检验）</strong>。步长检验需要设定检验次数，通常为100 的倍数，比如设置为 500。 </p>
<p>​    步长检验是根据所选的建树方法，计算并绘制指定次数株系统发生树。因为大多数建树方法的核心算法都是统计概率模型，所以每次计算出的树都会有所差别。而建好的系统发生树上每个节点上都会标记一个数字，它代表了指定次数次计算所得出的系统发生树中有百分之多少棵树都含有这一节点。一般来说，绝大多数节点上的数值都大于 70%的树才可信。个别低于 70%的节点可以暂且容忍，或通过添加，删减序列来改善质量。 </p>
<p>​    第二个参数是，<strong>Substitution Model</strong>。它是选择<strong>计算遗传距离时使用的计算模型</strong>。理论上应该尝试各种模型，根据检验结果选择最合适的模型进行计算。但在实际操作中，可先尝试选用较简单的距离模型，比如 <strong>p-distance</strong>。  </p>
<p>​    第三个参数是 <strong>Gap/Missing Data Treatment</strong>。大多数建树方法会要求<strong>删除多序列比对中含有空位的列</strong>。但是根据遗传距离度量方法的不同，删除原则也不同。如果是以序列间不同残 基的个数来度量遗传距离的话，这里需要选择 Complete deletion（全部删除）。如果是其他方 法，比如这里选用的 NJ 方法，可以选择 Partial deletion（部分删除）。删除程度定在 50%，即，保留一半含有空位的列。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669375753609.png" alt="1669375753609"></p>
<p>​    </p>
<p>按照以上方案参数设置后，点击“OK”开始构建系统发生树。经过一番计算之后，新窗口 Tree Explorer 里展示的就是创建好的系统发生树。这个窗口里有两个标签页。第一个是 <strong>Original Tree（原始树）</strong>，第二个是 <strong>Bootstrap consensus tree（步长检验合并出来的树</strong>）。Bootstrap consensus tree 上，节点处的数字表示，经步长检验有百分之几的树具有这根树枝，即，反应了该树枝的可信度。当前构建的这株系统发生树中，绝大多数节点处的数值都是≥70 的，所以这株树整体上是可信的。</p>
<p>​    Original Tree 是步长检验构建的 500 株树中的一株，未经过多棵树合并，所以树枝的长短可以精确代表遗传距离。此外， 从这株树也可以看出之前的人为分组情况是不是发生了意想不到的变化。比如，TLR5 似乎脱离了CM 组，成为了外类群，从而确定了树根。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669376021956.png" alt="1669376021956"> </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1669376042090.png" alt="1669376042090"></p>
]]></content>
      <categories>
        <category>《生物信息学》</category>
      </categories>
      <tags>
        <tag>生物信息学</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记</title>
    <url>/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668234025873.png" alt="1668234025873"></p>
<h3 id="类型检验"><a href="#类型检验" class="headerlink" title="类型检验"></a>类型检验</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = torch.randn(<span class="number">2</span>, <span class="number">3</span>)   <span class="comment"># 正态分布随机初始化2*3矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.<span class="built_in">type</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))  <span class="comment"># python自带type()函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合法化检验</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(data, torch.FloatTensor))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(data, torch.cuda.FloatTensor))</span><br><span class="line">data = data.cuda()  <span class="comment"># 将数据搬运到GPU上面</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(data, torch.cuda.FloatTensor))</span><br></pre></td></tr></table></figure>



<h3 id="张量和维度"><a href="#张量和维度" class="headerlink" title="张量和维度"></a>张量和维度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标量 Dimension 0 (0阶张量); 如Loss</span></span><br><span class="line">data = torch.tensor(<span class="number">1.</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape:&quot;</span>, data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size():&quot;</span>, data.size())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.ndimension():&quot;</span>, data.ndimension())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量 Dimension 1 (1阶张量); 如Bias，Linear Input</span></span><br><span class="line">data = torch.tensor([<span class="number">1.1</span>])</span><br><span class="line">data = torch.tensor([<span class="number">1.1</span>, <span class="number">2.2</span>])</span><br><span class="line"><span class="comment"># 随机初始化生成一维的长度为1、2的向量</span></span><br><span class="line">data = torch.FloatTensor(<span class="number">1</span>)</span><br><span class="line">data = torch.FloatTensor(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 用numpy初始化</span></span><br><span class="line">data = torch.from_numpy(np.ones(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape:&quot;</span>, data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size():&quot;</span>, data.size())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.ndimension():&quot;</span>, data.ndimension())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵 Dimension 2 (2阶张量); 如 Linear Input Batch，第一维度表示每个batch的样本数</span></span><br><span class="line">data = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape:&quot;</span>, data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape[0]:&quot;</span>, data.shape[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 取shape的第0个元素，即张量第一维的元素个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size(0):&quot;</span>, data.size(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size(1):&quot;</span>, data.size(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.ndimension():&quot;</span>, data.ndimension())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dimension 3 （3阶张量）; 如RNN Input Batch</span></span><br><span class="line">data = torch.randn(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape:&quot;</span>, data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size():&quot;</span>, data.size())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.ndimension():&quot;</span>, data.ndimension())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dimension 4 （4阶张量）; 如CNN</span></span><br><span class="line">data = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">28</span>)    <span class="comment"># 2张照片，3个通道，28 * 28个像素</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape:&quot;</span>, data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size():&quot;</span>, data.size())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.ndimension():&quot;</span>, data.ndimension())</span><br><span class="line"></span><br><span class="line"><span class="comment"># number of element</span></span><br><span class="line"><span class="built_in">print</span>(data.numel()) <span class="comment"># 2*3*28*28 元素个数</span></span><br><span class="line"><span class="built_in">print</span>(data.dim())	<span class="comment"># 张量维度</span></span><br></pre></td></tr></table></figure>



<h2 id="创建Tensor"><a href="#创建Tensor" class="headerlink" title="创建Tensor"></a>创建Tensor</h2><h3 id="通过list创建"><a href="#通过list创建" class="headerlink" title="通过list创建"></a>通过list创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过list创建tensor</span></span><br><span class="line">data = torch.tensor([<span class="number">2.</span>, <span class="number">3.2</span>])</span><br><span class="line">data = torch.FloatTensor([<span class="number">2.</span>, <span class="number">3.2</span>]) <span class="comment"># 尽量少用，容易混淆</span></span><br><span class="line">data = torch.tensor([[<span class="number">2.</span>, <span class="number">3.2</span>], [<span class="number">1.</span>, <span class="number">0.5</span>]])</span><br></pre></td></tr></table></figure>



<h3 id="通过numpy创建"><a href="#通过numpy创建" class="headerlink" title="通过numpy创建"></a>通过numpy创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过numpy创建tensor</span></span><br><span class="line">a = np.array([<span class="number">2</span>, <span class="number">3.3</span>])</span><br><span class="line">data = torch.from_numpy(a)</span><br><span class="line">a = np.ones([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">data = torch.from_numpy(a)</span><br></pre></td></tr></table></figure>



<h3 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建未初始化的tensor</span></span><br><span class="line">data = torch.empty(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">data = torch.FloatTensor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">data = torch.IntTensor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>



<h3 id="set-default-tensor-type"><a href="#set-default-tensor-type" class="headerlink" title="set_default_tensor_type()"></a>set_default_tensor_type()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置默认tensor类型</span></span><br><span class="line"><span class="built_in">print</span>(torch.tensor([<span class="number">1.2</span>, <span class="number">3</span>]).<span class="built_in">type</span>())    <span class="comment"># 默认是FloatTensor</span></span><br><span class="line">torch.set_default_tensor_type( torch.DoubleTensor)</span><br><span class="line"><span class="built_in">print</span>(torch.tensor([<span class="number">1.2</span>, <span class="number">3</span>]).<span class="built_in">type</span>())</span><br></pre></td></tr></table></figure>



<h3 id="rand-randn"><a href="#rand-randn" class="headerlink" title="rand/randn()"></a>rand/randn()</h3><ul>
<li><p>rand/rand_like; randint/randint_like</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rand/rand_like; randint/randint_like</span></span><br><span class="line">a = torch.rand(<span class="number">3</span>, <span class="number">3</span>)     <span class="comment"># 在[0,1]之间均匀采样</span></span><br><span class="line">data = torch.rand_like(a)   <span class="comment"># 接受参数不在是shape而是一个tensor</span></span><br><span class="line">a = torch.randint(<span class="number">1</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">3</span>])    <span class="comment"># 在[1,10)之间均匀采样</span></span><br><span class="line">data = torch.randint_like(a, <span class="number">1</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>randn</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># randn</span></span><br><span class="line">data = torch.randn(<span class="number">3</span>, <span class="number">3</span>)    <span class="comment"># N(0,1)标准正态分布取样</span></span><br><span class="line">data = torch.normal(mean=<span class="number">3</span>, std=<span class="number">1</span>, size=(<span class="number">3</span>, <span class="number">3</span>))     <span class="comment"># N(3,1)正态分布取样</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 让每一个值服从不同的正态分布</span></span><br><span class="line">torch.normal(mean=torch.arange(<span class="number">4.</span>), std=torch.arange(<span class="number">1.</span>, <span class="number">0.6</span>, -<span class="number">0.1</span>)).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="full"><a href="#full" class="headerlink" title="full()"></a>full()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建初始化为同一个值的tensor</span></span><br><span class="line">data = torch.full([<span class="number">2</span>, <span class="number">3</span>], <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>



<h3 id="arange"><a href="#arange" class="headerlink" title="arange()"></a>arange()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建等差数列的tensor</span></span><br><span class="line">data = torch.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)   <span class="comment"># [0, 10)步幅为2</span></span><br><span class="line">data = torch.linspace(<span class="number">0</span>, <span class="number">10</span>, steps=<span class="number">11</span>) <span class="comment"># [0, 10]等分为11份</span></span><br><span class="line">data = torch.logspace(<span class="number">0</span>, -<span class="number">1</span>, steps=<span class="number">11</span>) <span class="comment"># 将[0,-1]11等分的值作为10的指数返回</span></span><br></pre></td></tr></table></figure>



<h3 id="zeros-ones-eye"><a href="#zeros-ones-eye" class="headerlink" title="zeros/ones/eye()"></a>zeros/ones/eye()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成全0/1，对角的tensor</span></span><br><span class="line">data = torch.zeros(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">data = torch.ones(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">data = torch.eye(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>



<h3 id="randperm"><a href="#randperm" class="headerlink" title="randperm()"></a>randperm()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机打算取值创建1维tensor</span></span><br><span class="line">data = torch.randperm(<span class="number">10</span>)   <span class="comment"># 不包含10</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 协同shuffle洗牌</span></span><br><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">b = torch.rand(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a, <span class="string">&#x27;\n&#x27;</span>, b)</span><br><span class="line">idx = torch.randperm(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(idx)</span><br><span class="line"><span class="built_in">print</span>(a[idx], <span class="string">&#x27;\n&#x27;</span>, b[idx])</span><br></pre></td></tr></table></figure>



<h2 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h2><h3 id="四个维度"><a href="#四个维度" class="headerlink" title="四个维度"></a>四个维度</h3><p>batch，channel，height，width</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>



<h4 id="基本切片"><a href="#基本切片" class="headerlink" title="基本切片"></a>基本切片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切片 select fisrt/last N</span></span><br><span class="line"><span class="built_in">print</span>(a[:<span class="number">2</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(a[:<span class="number">2</span>, :<span class="number">1</span>, :, :].shape)</span><br><span class="line"><span class="built_in">print</span>(a[:<span class="number">2</span>, -<span class="number">3</span>:, :, :].shape)</span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>], -<span class="number">3</span>:, :, :].shape)</span><br></pre></td></tr></table></figure>



<h3 id="隔点采样"><a href="#隔点采样" class="headerlink" title="隔点采样"></a>隔点采样</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 隔点采样 select by steps</span></span><br><span class="line"><span class="built_in">print</span>(a[:, :, <span class="number">0</span>:<span class="number">28</span>:<span class="number">2</span>, <span class="number">0</span>:<span class="number">28</span>:<span class="number">2</span>].shape)  <span class="comment"># 步长为2采样</span></span><br><span class="line"><span class="built_in">print</span>(a[:, :, ::<span class="number">2</span>, ::<span class="number">2</span>].shape)</span><br></pre></td></tr></table></figure>



<h3 id="a-index-select"><a href="#a-index-select" class="headerlink" title="a.index_select()"></a>a.index_select()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在某一维度上根据具体索引采样 index_select</span></span><br><span class="line"><span class="built_in">print</span>(a.index_select(<span class="number">0</span>, torch.tensor([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])).shape)  <span class="comment"># 在第0维度（batch）上采样[0,1,2]</span></span><br><span class="line"><span class="built_in">print</span>(a.index_select(<span class="number">1</span>, torch.tensor([<span class="number">0</span>, <span class="number">1</span>])).shape)  <span class="comment"># 在第1维度（channel）上采样[0,1]</span></span><br><span class="line"><span class="built_in">print</span>(a.index_select(<span class="number">2</span>, torch.arange(<span class="number">0</span>, <span class="number">28</span>, <span class="number">2</span>)).shape)</span><br></pre></td></tr></table></figure>



<h3 id="…"><a href="#…" class="headerlink" title="…"></a>…</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...表示任意多维度</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, ...])  <span class="comment"># 等价于a[0, :, :, :]和a[0]</span></span><br><span class="line"><span class="built_in">print</span>(a[..., :<span class="number">2</span>])  <span class="comment"># 等价于a[:, :, :, :2]</span></span><br></pre></td></tr></table></figure>



<h3 id="masked-select"><a href="#masked-select" class="headerlink" title="masked_select()"></a>masked_select()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据掩码取满足条件的值（会改变shape ）masked_select</span></span><br><span class="line">x = torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">mask = x.ge(<span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.masked_select(x, mask))</span><br></pre></td></tr></table></figure>



<h3 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打平后根据索引采样  take</span></span><br><span class="line">x = torch.tensor([[<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="built_in">print</span>(torch.take(x, torch.tensor([<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>])))</span><br></pre></td></tr></table></figure>



<h2 id="维度变换"><a href="#维度变换" class="headerlink" title="维度变换"></a>维度变换</h2><h3 id="view-reshape"><a href="#view-reshape" class="headerlink" title="view/reshape"></a>view/reshape</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"></span><br><span class="line">a = a.view(<span class="number">4</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"></span><br><span class="line">a = a.reshape(<span class="number">4</span> * <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br></pre></td></tr></table></figure>



<h3 id="unsqueeze-squeeze-拉伸-挤压"><a href="#unsqueeze-squeeze-拉伸-挤压" class="headerlink" title="unsqueeze/squeeze 拉伸/挤压"></a>unsqueeze/squeeze 拉伸/挤压</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># unsqueeze</span></span><br><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(a.unsqueeze(<span class="number">0</span>).shape)  <span class="comment"># 在第0维度前插入维度；索引范围[-5, 4]</span></span><br><span class="line"><span class="built_in">print</span>(a.unsqueeze(-<span class="number">1</span>).shape)  <span class="comment"># 在最后一个维度后插入维度</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># squeeze</span></span><br><span class="line">b = torch.rand(<span class="number">32</span>)</span><br><span class="line">b = b.unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">2</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line"><span class="built_in">print</span>(b.squeeze().shape)  <span class="comment"># 挤压所有size为1的维度</span></span><br><span class="line"><span class="built_in">print</span>(b.squeeze(<span class="number">0</span>).shape)</span><br><span class="line"><span class="built_in">print</span>(b.squeeze(<span class="number">1</span>).shape)  <span class="comment"># size不为1的维度不能被挤压</span></span><br></pre></td></tr></table></figure>



<h3 id="expand-repeat-扩张-重复"><a href="#expand-repeat-扩张-重复" class="headerlink" title="expand/repeat  扩张/重复"></a>expand/repeat  扩张/重复</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># expand(推荐使用)</span></span><br><span class="line">f = torch.rand(<span class="number">4</span>, <span class="number">32</span>, <span class="number">14</span>, <span class="number">14</span>)  <span class="comment"># [4, 32, 14, 14]</span></span><br><span class="line">b = torch.rand(<span class="number">32</span>)</span><br><span class="line">b = b.unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">2</span>).unsqueeze(<span class="number">0</span>)  <span class="comment"># [1, 32, 1, 1]</span></span><br><span class="line"><span class="comment"># 每个channel所有像素增加一个bias</span></span><br><span class="line">b = b.expand(<span class="number">4</span>, <span class="number">32</span>, <span class="number">14</span>, <span class="number">14</span>)  <span class="comment"># 维度一致；只有size为1的维度才能扩张成N</span></span><br><span class="line">b = b.expand(-<span class="number">1</span>, <span class="number">32</span>, -<span class="number">1</span>, -<span class="number">1</span>)  <span class="comment"># -1表示维度size不变</span></span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># repeat</span></span><br><span class="line">b = torch.rand(<span class="number">32</span>)</span><br><span class="line">b = b.unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">2</span>).unsqueeze(<span class="number">0</span>)  <span class="comment"># [1, 32, 1, 1]</span></span><br><span class="line">b = b.repeat(<span class="number">4</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">14</span>)  <span class="comment"># 参数指重复次数</span></span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br></pre></td></tr></table></figure>



<h3 id="转置-t"><a href="#转置-t" class="headerlink" title="转置 t"></a>转置 t</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4.转置 t</span></span><br><span class="line"><span class="comment"># 只适用于矩阵，dimension为2</span></span><br><span class="line">a = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(a.t())</span><br></pre></td></tr></table></figure>



<h3 id="transpose-维度交换"><a href="#transpose-维度交换" class="headerlink" title="transpose 维度交换"></a>transpose 维度交换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># transpose 维度交换</span></span><br><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">14</span>)</span><br><span class="line"><span class="comment"># [b,c,h,w] =&gt; [b,w,h,c] =&gt; [b, whc] =&gt; [b,c,w,h]  导致数据污染</span></span><br><span class="line">a1 = a.transpose(<span class="number">1</span>, <span class="number">3</span>).contiguous().view(<span class="number">4</span>, <span class="number">3</span> * <span class="number">14</span> * <span class="number">14</span>).view(<span class="number">4</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">14</span>)</span><br><span class="line"><span class="comment"># [b,c,h,w] =&gt; [b,w,h,c] =&gt; [b, whc] =&gt; [b,w,h,c]  =&gt; [b,c,w,h]</span></span><br><span class="line">a2 = a.transpose(<span class="number">1</span>, <span class="number">3</span>).contiguous().view(<span class="number">4</span>, <span class="number">3</span> * <span class="number">14</span> * <span class="number">14</span>).view(<span class="number">4</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">3</span>).transpose(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(a, a1)))</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(a, a2)))</span><br></pre></td></tr></table></figure>



<h3 id="permute-维度排列"><a href="#permute-维度排列" class="headerlink" title="permute 维度排列"></a>permute 维度排列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># permute 维度排列</span></span><br><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">7</span>)</span><br><span class="line">a1 = a.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a1.shape)</span><br></pre></td></tr></table></figure>



<h2 id="Broadcast机制"><a href="#Broadcast机制" class="headerlink" title="Broadcast机制"></a>Broadcast机制</h2><ul>
<li>broadcast广播/自动扩张机制<ul>
<li>expand</li>
<li>不需要复制数据</li>
</ul>
</li>
<li>主要思想<ul>
<li>在前面插入维度，使维度一致</li>
<li>扩张size为1的维度使得size一致</li>
</ul>
</li>
<li>为什么需要broadcast<ul>
<li>需求场景</li>
<li>减少内存消耗</li>
</ul>
</li>
<li>可以broadcast的情况<ul>
<li>从最后一维往前开始匹配</li>
<li>如果当前维度为1，扩展size到一致</li>
<li>如果往前没有维度，则插入一个维度，并扩展size到一致</li>
<li>其他情况都是不能broadcast的</li>
</ul>
</li>
</ul>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668428901290.png" alt="1668428901290"></p>
<h2 id="拼接与拆分"><a href="#拼接与拆分" class="headerlink" title="拼接与拆分"></a>拼接与拆分</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>要求除dim=d外，其他维度size一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a1 = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">a2 = torch.rand(<span class="number">5</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">b = torch.cat([a1, a2], dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(b.size())</span><br><span class="line"></span><br><span class="line">a1 = torch.rand(<span class="number">4</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">a2 = torch.rand(<span class="number">4</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">b = torch.cat([a1, a2], dim=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(b.size())</span><br><span class="line"></span><br><span class="line">a1 = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">a2 = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">b = torch.cat([a1, a2], dim=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(b.size())</span><br></pre></td></tr></table></figure>



<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>要求所有维度一致，会在dim=d维度前新增一个维度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a1 = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">a2 = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">b = torch.stack([a1, a2], dim=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(b.size())</span><br></pre></td></tr></table></figure>



<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>按照长度拆分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">3</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">aa, bb = a.split([<span class="number">2</span>, <span class="number">1</span>], dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(aa.size(), bb.size())</span><br><span class="line"></span><br><span class="line">aa, bb, cc = a.split(<span class="number">1</span>, dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(aa.size(), bb.size(), cc.size())</span><br></pre></td></tr></table></figure>



<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>按照数量拆分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">3</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">aa, bb = a.chunk(<span class="number">2</span>, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">aa, bb, cc = a.chunk(<span class="number">3</span>, dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(aa.size(), bb.size(), cc.size())</span><br></pre></td></tr></table></figure>



<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h3><p> +=*/ 或者add，sub，mul，div</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">b = torch.rand(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据broadcast机制，b会自动扩展成[3, 4]再参与运算</span></span><br><span class="line">c1 = a + b</span><br><span class="line">c2 = a.add(b)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(c1, c2)))</span><br><span class="line"></span><br><span class="line">c1 = a - b</span><br><span class="line">c2 = a.sub(b)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(c1, c2)))</span><br><span class="line"></span><br><span class="line">c1 = a * b</span><br><span class="line">c2 = a.mul(b)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(c1, c2)))</span><br><span class="line"></span><br><span class="line">c1 = a / b</span><br><span class="line">c2 = a.div(b)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(c1, c2)))</span><br></pre></td></tr></table></figure>



<h3 id="matmul矩阵相乘"><a href="#matmul矩阵相乘" class="headerlink" title="matmul矩阵相乘"></a>matmul矩阵相乘</h3><ul>
<li><p>mm 只支持二维</p>
</li>
<li><p>matmul</p>
</li>
<li><p>@</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mm 只支持二维</span></span><br><span class="line">a = torch.tensor([[<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">3.</span>, <span class="number">4.</span>]])</span><br><span class="line">b = torch.ones(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">c = torch.mm(a, b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># matmul</span></span><br><span class="line">c = torch.matmul(a, b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># @</span></span><br><span class="line">c = a @ b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个例子</span></span><br><span class="line">x = torch.rand(<span class="number">4</span>, <span class="number">784</span>)</span><br><span class="line">w = torch.rand(<span class="number">512</span>, <span class="number">784</span>)</span><br><span class="line"><span class="built_in">print</span>((x @ w.t()).shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于2维张量相乘</span></span><br><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">64</span>)</span><br><span class="line">b = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">32</span>)</span><br><span class="line">c = torch.rand(<span class="number">4</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.matmul(a, b).size())</span><br><span class="line"><span class="built_in">print</span>(torch.matmul(a, c).size())</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pow-次方"><a href="#pow-次方" class="headerlink" title="pow/次方"></a>pow/次方</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.full([<span class="number">2</span>, <span class="number">2</span>], <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 平方</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">pow</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(a ** <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 开方</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">pow</span>(<span class="number">0.5</span>))</span><br><span class="line"><span class="built_in">print</span>(a ** <span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(a.sqrt())</span><br><span class="line"><span class="built_in">print</span>(a.rsqrt())  <span class="comment"># 开方倒数</span></span><br></pre></td></tr></table></figure>



<h3 id="exp-log"><a href="#exp-log" class="headerlink" title="exp/log"></a>exp/log</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(torch.exp(torch.ones(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(torch.log(torch.ones(<span class="number">2</span>, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure>



<h3 id="近似（取整）"><a href="#近似（取整）" class="headerlink" title="近似（取整）"></a>近似（取整）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.tensor(<span class="number">3.14</span>)</span><br><span class="line"><span class="built_in">print</span>(a.floor())    <span class="comment"># 向上取整</span></span><br><span class="line"><span class="built_in">print</span>(a.ceil())     <span class="comment"># 向下取整</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">round</span>())      <span class="comment"># 四舍五入</span></span><br><span class="line"><span class="built_in">print</span>(a.trunc())    <span class="comment"># 取整数部分</span></span><br><span class="line"><span class="built_in">print</span>(a.frac())     <span class="comment"># 取小数部分</span></span><br></pre></td></tr></table></figure>



<h3 id="clamp限幅"><a href="#clamp限幅" class="headerlink" title="clamp限幅"></a>clamp限幅</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grad = torch.rand(<span class="number">2</span>, <span class="number">3</span>) * <span class="number">15</span>    <span class="comment"># [0,15]随机采样</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>(), a.median(), a.<span class="built_in">min</span>())</span><br><span class="line"><span class="built_in">print</span>(grad.clamp(<span class="number">10</span>))   <span class="comment"># 最小值限制为10</span></span><br><span class="line"><span class="built_in">print</span>(grad.clamp(<span class="number">0</span>, <span class="number">10</span>))    <span class="comment">#最小值限制为0，最大值限制为10</span></span><br></pre></td></tr></table></figure>



<h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">b = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a, <span class="string">&#x27;\n&#x27;</span>, b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a &gt; b, <span class="string">&#x27;\n&#x27;</span>, a.gt(b))</span><br><span class="line"><span class="built_in">print</span>(a &gt;= b,  <span class="string">&#x27;\n&#x27;</span>, a.ge(b))</span><br><span class="line"><span class="built_in">print</span>(a != b)</span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"><span class="built_in">print</span>(torch.eq(a, b), torch.equal(a, b))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 结果</span></span><br><span class="line">tensor([[-<span class="number">1.9149</span>,  <span class="number">0.2055</span>, -<span class="number">0.9794</span>],</span><br><span class="line">        [ <span class="number">0.0520</span>,  <span class="number">1.4960</span>, -<span class="number">0.3995</span>]]) </span><br><span class="line">tensor([[-<span class="number">0.2851</span>, -<span class="number">0.4754</span>, -<span class="number">0.9211</span>],</span><br><span class="line">        [ <span class="number">2.2437</span>, -<span class="number">2.5068</span>,  <span class="number">0.0198</span>]])</span><br><span class="line">        tensor([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>]]) </span><br><span class="line">tensor([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>]])</span><br><span class="line">tensor([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>]]) </span><br><span class="line">tensor([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>]])</span><br><span class="line">tensor([[<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>]])</span><br><span class="line">tensor([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line">tensor([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]]) <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="统计属性"><a href="#统计属性" class="headerlink" title="统计属性"></a>统计属性</h2><h3 id="norm范数"><a href="#norm范数" class="headerlink" title="norm范数"></a>norm范数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 总体元素的范数</span></span><br><span class="line"><span class="built_in">print</span>(a.norm(<span class="number">1</span>), <span class="string">&#x27;\n&#x27;</span>, b.norm(<span class="number">1</span>), <span class="string">&#x27;\n&#x27;</span>, c.norm(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a.norm(<span class="number">2</span>), <span class="string">&#x27;\n&#x27;</span>, b.norm(<span class="number">1</span>), <span class="string">&#x27;\n&#x27;</span>, c.norm(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某个维度上面求范数</span></span><br><span class="line"><span class="built_in">print</span>(b.norm(<span class="number">1</span>, dim=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(b.norm(<span class="number">1</span>, dim=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">c = torch.tensor([[[<span class="number">1.</span>, <span class="number">1.</span>], [<span class="number">1.</span>, <span class="number">1.</span>]],</span><br><span class="line">                  [[<span class="number">2.</span>, <span class="number">2.</span>], [<span class="number">2.</span>, <span class="number">2.</span>]]])</span><br><span class="line"><span class="built_in">print</span>(c.norm(<span class="number">1</span>, dim=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(c.norm(<span class="number">1</span>, dim=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h3 id="min-max-mean-prod"><a href="#min-max-mean-prod" class="headerlink" title="min/max/mean/prod"></a>min/max/mean/prod</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.arange(<span class="number">1</span>, <span class="number">11</span>).view(<span class="number">2</span>, <span class="number">5</span>).<span class="built_in">float</span>()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 不带参数的话，求的是所有元素的(打平后再求)</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>())</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>())</span><br><span class="line"><span class="built_in">print</span>(a.mean())</span><br><span class="line"><span class="built_in">print</span>(a.prod())     <span class="comment"># 元素累乘</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 带参数 dim, keepdim</span></span><br><span class="line"><span class="comment"># dim:在该维度上进行操作</span></span><br><span class="line"><span class="comment"># keepdim:操作后保存维度不变</span></span><br><span class="line">a = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>(dim=<span class="number">0</span>, keepdim=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>(dim=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>(dim=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(a.mean(dim=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(a.prod(dim=<span class="number">0</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.9035, 0.6971, 0.4886, 0.7893],</span></span><br><span class="line"><span class="string">        [0.1721, 0.7944, 0.0457, 0.7884],</span></span><br><span class="line"><span class="string">        [0.9295, 0.3432, 0.1493, 0.7428]])</span></span><br><span class="line"><span class="string">torch.return_types.min(values=tensor([[0.1721, 0.3432, 0.0457, 0.7428]]),indices=tensor([[1, 2, 1, 2]]))</span></span><br><span class="line"><span class="string">torch.return_types.min(values=tensor([0.1721, 0.3432, 0.0457, 0.7428]),indices=tensor([1, 2, 1, 2]))</span></span><br><span class="line"><span class="string">torch.return_types.max(values=tensor([0.9295, 0.7944, 0.4886, 0.7893]),indices=tensor([2, 1, 0, 0]))</span></span><br><span class="line"><span class="string">tensor([0.6684, 0.6116, 0.2279, 0.7735])</span></span><br><span class="line"><span class="string">tensor([0.1445, 0.1901, 0.0033, 0.4623])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>))   <span class="comment"># keepdim=True保持原来的维度</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>(dim=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>(dim=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a.mean(dim=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a.prod(dim=<span class="number">1</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.7369, 0.7026, 0.7261, 0.6016],</span></span><br><span class="line"><span class="string">        [0.1645, 0.3403, 0.6544, 0.4276],</span></span><br><span class="line"><span class="string">        [0.5673, 0.4806, 0.7130, 0.7522]])</span></span><br><span class="line"><span class="string">torch.return_types.min(</span></span><br><span class="line"><span class="string">values=tensor([[0.6016],</span></span><br><span class="line"><span class="string">        		[0.1645],</span></span><br><span class="line"><span class="string">        		[0.4806]]),</span></span><br><span class="line"><span class="string">indices=tensor([[3],</span></span><br><span class="line"><span class="string">        		[0],</span></span><br><span class="line"><span class="string">        		[1]]))</span></span><br><span class="line"><span class="string">torch.return_types.min(values=tensor([0.6016, 0.1645, 0.4806]),indices=tensor([3, 0, 1]))</span></span><br><span class="line"><span class="string">torch.return_types.max(values=tensor([0.7369, 0.6544, 0.7522]),indices=tensor([0, 2, 3]))</span></span><br><span class="line"><span class="string">tensor([0.6918, 0.3967, 0.6283])</span></span><br><span class="line"><span class="string">tensor([0.2262, 0.0157, 0.1462])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="argmax-argmin"><a href="#argmax-argmin" class="headerlink" title="argmax/argmin"></a>argmax/argmin</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最大/小值索引</span></span><br><span class="line"><span class="built_in">print</span>(a.argmax())</span><br><span class="line"><span class="built_in">print</span>(a.argmin())</span><br></pre></td></tr></table></figure>



<h3 id="topk-kthvalue"><a href="#topk-kthvalue" class="headerlink" title="topk/kthvalue"></a>topk/kthvalue</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 取前k大/小的值 topK</span><br><span class="line"># 取第k小的值 kthvalue</span><br><span class="line">a = torch.arange(1, 11).view(2, 5).float()</span><br><span class="line">print(a.topk(3, dim=1))</span><br><span class="line">print(a.topk(3, dim=1, largest=False))	# largest=False取前k小</span><br><span class="line">print(a.kthvalue(2, dim=1))		# 取前k小</span><br></pre></td></tr></table></figure>



<h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>根据条件tensor赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">condition = torch.rand(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(condition, <span class="string">&#x27;\n&#x27;</span>, condition &gt; <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">a = torch.zeros_like(condition)</span><br><span class="line">b = torch.ones_like(condition)</span><br><span class="line">c = torch.where(condition &gt; <span class="number">0.5</span>, a, b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.8901, 0.9493],</span></span><br><span class="line"><span class="string">        [0.7294, 0.4096]]) </span></span><br><span class="line"><span class="string"> tensor([[ True,  True],</span></span><br><span class="line"><span class="string">        [ True, False]])</span></span><br><span class="line"><span class="string">tensor([[0., 0.],</span></span><br><span class="line"><span class="string">        [0., 1.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="gather"><a href="#gather" class="headerlink" title="gather"></a>gather</h3><p>根据索引tensor找值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># out[i][j][k] = input[index[i][j][k]][j][k] dim = 0</span></span><br><span class="line"><span class="comment"># out[i][j][k] = input[i][index[i][j][k]][k] dim = 1</span></span><br><span class="line"><span class="comment"># out[i][j][k] = input[i][j][index[i][j][k]] dim = 2</span></span><br><span class="line">prob = torch.randn(<span class="number">4</span>, <span class="number">10</span>)</span><br><span class="line">idx = prob.topk(<span class="number">3</span>, dim=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(idx[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">label = torch.arange(<span class="number">10</span>) + <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(label)</span><br><span class="line"></span><br><span class="line">res = torch.gather(label.expand(<span class="number">4</span>, <span class="number">10</span>), dim=<span class="number">1</span>, index=idx[<span class="number">0</span>].long())</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">torch.return_types.topk(</span></span><br><span class="line"><span class="string">values=tensor([[1.2671, 1.1393, 0.4483],</span></span><br><span class="line"><span class="string">        [1.3529, 0.8119, 0.7457],</span></span><br><span class="line"><span class="string">        [0.7395, 0.7150, 0.6264],</span></span><br><span class="line"><span class="string">        [0.9675, 0.7654, 0.6994]]),</span></span><br><span class="line"><span class="string">indices=tensor([[2, 6, 7],</span></span><br><span class="line"><span class="string">        [5, 0, 1],</span></span><br><span class="line"><span class="string">        [7, 4, 0],</span></span><br><span class="line"><span class="string">        [0, 6, 2]]))</span></span><br><span class="line"><span class="string">tensor([100, 101, 102, 103, 104, 105, 106, 107, 108, 109])</span></span><br><span class="line"><span class="string">tensor([[102, 106, 107],</span></span><br><span class="line"><span class="string">        [105, 100, 101],</span></span><br><span class="line"><span class="string">        [107, 104, 100],</span></span><br><span class="line"><span class="string">        [100, 106, 102]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="常见激活函数"><a href="#常见激活函数" class="headerlink" title="常见激活函数"></a>常见激活函数</h2><h3 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.arange(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line">b = torch.sigmoid(a)</span><br><span class="line">plt.plot(a, b)</span><br><span class="line">plt.title(<span class="string">&quot;sigmoid&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/sigmoid.jpg" alt="sigmoid"></p>
<h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = torch.tanh(a)</span><br><span class="line">plt.plot(a, b)</span><br><span class="line">plt.title(&quot;tanh&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/tanh.jpg" alt="tanh"></p>
<h3 id="relu"><a href="#relu" class="headerlink" title="relu"></a>relu</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = torch.relu(a)</span><br><span class="line">plt.plot(a, b)</span><br><span class="line">plt.title(&quot;relu&quot;)</span><br><span class="line">plt.savefig(&quot;relu.jpg&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/relu.jpg" alt="relu"></p>
<h2 id="损失和梯度"><a href="#损失和梯度" class="headerlink" title="损失和梯度"></a>损失和梯度</h2><h3 id="torch-autograd-grad"><a href="#torch-autograd-grad" class="headerlink" title="torch.autograd.grad"></a>torch.autograd.grad</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.torch.autograd.grad</span></span><br><span class="line">x = torch.ones(<span class="number">1</span>)</span><br><span class="line">w = torch.tensor([<span class="number">2.</span>])</span><br><span class="line">w.requires_grad_()		<span class="comment"># 设置参数需要求导</span></span><br><span class="line">mse = F.mse_loss(torch.ones(<span class="number">1</span>), x * w)	<span class="comment"># 求均方差损失</span></span><br><span class="line"><span class="built_in">print</span>(torch.autograd.grad(mse, [w]))	<span class="comment"># 求梯度</span></span><br><span class="line"></span><br><span class="line">x = torch.ones(<span class="number">1</span>)</span><br><span class="line">w = torch.tensor([<span class="number">2.</span>], requires_grad=<span class="literal">True</span>)	<span class="comment"># 设置参数需要求导</span></span><br><span class="line">mse = F.mse_loss(torch.ones(<span class="number">1</span>), x * w)</span><br><span class="line"><span class="built_in">print</span>(torch.autograd.grad(mse, [w]))</span><br></pre></td></tr></table></figure>



<h3 id="loss-backward"><a href="#loss-backward" class="headerlink" title="loss.backward"></a>loss.backward</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.ones(<span class="number">1</span>)</span><br><span class="line">w = torch.tensor([<span class="number">2.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">mse = F.mse_loss(torch.ones(<span class="number">1</span>), x * w)</span><br><span class="line">mse.backward()	<span class="comment"># 反向传播</span></span><br><span class="line"><span class="built_in">print</span>(w.grad)	<span class="comment"># 求梯度</span></span><br></pre></td></tr></table></figure>



<h3 id="F-softmax"><a href="#F-softmax" class="headerlink" title="F.softmax"></a>F.softmax</h3><p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668736008530.png" alt="1668736008530"></p>
<ul>
<li>求梯度推导过程</li>
</ul>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668736071190.png" alt="1668736071190"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668736096566.png" alt="1668736096566"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668736153084.png" alt="1668736153084"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">3</span>)</span><br><span class="line">a.requires_grad_()</span><br><span class="line">p = F.softmax(a, dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line">dp1 = torch.autograd.grad(p[<span class="number">0</span>], [a], retain_graph=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(dp1)</span><br><span class="line">dp2 = torch.autograd.grad(p[<span class="number">1</span>], [a], retain_graph=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(dp2)</span><br><span class="line">dp3 = torch.autograd.grad(p[<span class="number">2</span>], [a])</span><br><span class="line"><span class="built_in">print</span>(dp3)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([0.3132, 0.3989, 0.2879], grad_fn=&lt;SoftmaxBackward0&gt;)</span></span><br><span class="line"><span class="string">(tensor([ 0.2151, -0.1249, -0.0902]),)</span></span><br><span class="line"><span class="string">(tensor([-0.1249,  0.2398, -0.1148]),)</span></span><br><span class="line"><span class="string">(tensor([-0.0902, -0.1148,  0.2050]),)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h2><h3 id="单输出感知机"><a href="#单输出感知机" class="headerlink" title="单输出感知机"></a>单输出感知机</h3><p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668739371382.png" alt="1668739371382"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三个样本，每个样本对应10个输入，1个输出</span></span><br><span class="line">x = torch.rand(<span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">w = torch.rand(<span class="number">1</span>, <span class="number">10</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">o = torch.sigmoid(x @ w.t())</span><br><span class="line"><span class="built_in">print</span>(o)</span><br><span class="line"></span><br><span class="line">loss = F.mse_loss(torch.FloatTensor([[<span class="number">1</span>], [<span class="number">0</span>], [<span class="number">0</span>]]), o)</span><br><span class="line">loss.backward()</span><br><span class="line"><span class="built_in">print</span>(loss, w.grad)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.8605],</span></span><br><span class="line"><span class="string">        [0.8590],</span></span><br><span class="line"><span class="string">        [0.7049]], grad_fn=&lt;SigmoidBackward0&gt;)</span></span><br><span class="line"><span class="string">tensor(0.4181, grad_fn=&lt;MseLossBackward0&gt;) tensor([[0.0851, 0.0223, 0.0701, 0.0971, 0.0574, 0.0612, 0.0456, 0.0683, 0.0352, 0.0944]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="多输出感知机"><a href="#多输出感知机" class="headerlink" title="多输出感知机"></a>多输出感知机</h3><p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668739592059.png" alt="1668739592059"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">x = torch.rand(<span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">w = torch.rand(<span class="number">4</span>, <span class="number">10</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">o = torch.sigmoid(x @ w.t())</span><br><span class="line"><span class="built_in">print</span>(o)</span><br><span class="line"></span><br><span class="line">label = torch.FloatTensor([[<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0.2</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.8</span>]])</span><br><span class="line">loss = F.mse_loss(label, o)</span><br><span class="line">loss.backward()</span><br><span class="line"><span class="built_in">print</span>(loss, w.grad)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.9386, 0.8571, 0.8541, 0.8488],</span></span><br><span class="line"><span class="string">        [0.8648, 0.9295, 0.9111, 0.7584],</span></span><br><span class="line"><span class="string">        [0.9539, 0.9195, 0.8927, 0.9121]], grad_fn=&lt;SigmoidBackward0&gt;)</span></span><br><span class="line"><span class="string">tensor(0.4983, grad_fn=&lt;MseLossBackward0&gt;) </span></span><br><span class="line"><span class="string">tensor([[0.0148, 0.0137, 0.0151, 0.0075, 0.0186, 0.0043, 0.0097, 0.0156, 0.0149, 0.0040],</span></span><br><span class="line"><span class="string">        [0.0121, 0.0009, 0.0118, 0.0055, 0.0073, 0.0137, 0.0102, 0.0102, 0.0065, 0.0134],</span></span><br><span class="line"><span class="string">        [0.0260, 0.0099, 0.0312, 0.0133, 0.0204, 0.0245, 0.0174, 0.0205, 0.0177, 0.0251],</span></span><br><span class="line"><span class="string">        [0.0245, 0.0193, 0.0359, 0.0143, 0.0252, 0.0165, 0.0110, 0.0180, 0.0216, 0.0185]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="himmelblau函数优化"><a href="#himmelblau函数优化" class="headerlink" title="himmelblau函数优化"></a>himmelblau函数优化</h2><ul>
<li>himmelblau函数是数学家们构造出来的一个特殊的函数，可以用来测试深度学习算法是否能够收敛到局部最小值。这个函数的表达式是：<br>$$<br>f(x,y)=(x^{2}+y-11)^{2}+(x+y^{2}-7)^2<br>$$<br> 这个函数最小值为0，有四个最小值点，分别是 :<br>$$<br>f(3.0,2.0)=0\<br>f(−2.805118,3.131312)=0\<br>f(−3.779310,−3.283186)=0\<br>f(3.584428,−1.848126)=0<br>$$</li>
</ul>
<h3 id="三维图像展示"><a href="#三维图像展示" class="headerlink" title="三维图像展示"></a>三维图像展示</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># from mpl_toolkits.mplot3d import Axes3D</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># himmelblau函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">himmelblau</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x[<span class="number">0</span>] ** <span class="number">2</span> + x[<span class="number">1</span>] - <span class="number">11</span>) ** <span class="number">2</span> + (x[<span class="number">0</span>] + x[<span class="number">1</span>] ** <span class="number">2</span> - <span class="number">7</span>) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制himmelblau函数的三维图像</span></span><br><span class="line"><span class="comment"># 通过x,y两个张量调用meshgrid方法生成一个网格</span></span><br><span class="line">x = np.arange(-<span class="number">6</span>, <span class="number">6</span>, <span class="number">0.1</span>)</span><br><span class="line">y = np.arange(-<span class="number">6</span>, <span class="number">6</span>, <span class="number">0.1</span>)</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"><span class="comment"># 网格上每一个点x,y带入himmelblau求出z</span></span><br><span class="line">Z = himmelblau([X, Y])</span><br><span class="line"><span class="comment"># 作图</span></span><br><span class="line">fig = plt.figure(<span class="string">&#x27;himmelblau&#x27;</span>)</span><br><span class="line">ax = fig.add_subplot(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot_surface(X, Y, Z)</span><br><span class="line">ax.view_init(<span class="number">60</span>, -<span class="number">30</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;himmelblau.jpg&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/himmelblau.jpg" alt="himmelblau"></p>
<h3 id="梯度下降求最小值"><a href="#梯度下降求最小值" class="headerlink" title="梯度下降求最小值"></a>梯度下降求最小值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 梯度下降法求局部最小值</span></span><br><span class="line"><span class="comment"># 初始坐标 [0, 0] [1, 0] [-4, 0] [4, 0] </span></span><br><span class="line">x = torch.tensor([<span class="number">0.</span>, <span class="number">4.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 构造优化器</span></span><br><span class="line">optimizer = torch.optim.Adam([x], lr=<span class="number">1e-3</span>)</span><br><span class="line"><span class="comment"># 进行20000轮下降</span></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20000</span>):</span><br><span class="line">    <span class="comment"># 要找到himmelblau的最小值，损失函数就是himmelblau的函数值</span></span><br><span class="line">    loss = himmelblau(x)</span><br><span class="line">    <span class="comment"># 清空各参数的梯度</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    <span class="comment"># 反向传播重新计算各参数的梯度</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    <span class="comment"># 优化器更新参数x&#x27;=x-lr*梯度</span></span><br><span class="line">    optimizer.step()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">2000</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;step &#123;&#125;:x=&#123;&#125;,f(x)=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(step, x.tolist(), loss.item()))</span><br><span class="line">        </span><br><span class="line"> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> [0, 4]</span></span><br><span class="line"><span class="string"> step 18000:x=[-2.8051180839538574, 3.131312370300293],f(x)=2.2737367544323206e-13</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> [0,0]</span></span><br><span class="line"><span class="string"> step 18000:x=[3.0, 2.0],f(x)=0.0</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> [-4, 0]</span></span><br><span class="line"><span class="string"> step 18000:x=[-3.7793102264404297, -3.2831859588623047],f(x)=0.0</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"> [4, 0]</span></span><br><span class="line"><span class="string"> step 18000:x=[3.584428310394287, -1.8481265306472778],f(x)=0.0</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p> 初始化位置的不同将会影响最终收敛到哪个局部最小值 </p>
<h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>$$<br>H(p,q)=-\sum{p(x)logq(x)}<br>$$</p>
<p>衡量两个分布p和q的不一致程度，在分类问题中可用于衡量损失。</p>
<h3 id="F-cross-entropy"><a href="#F-cross-entropy" class="headerlink" title="F.cross_entropy"></a>F.cross_entropy</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">x = torch.randn(<span class="number">1</span>, <span class="number">784</span>)</span><br><span class="line">w = torch.randn(<span class="number">10</span>, <span class="number">784</span>)</span><br><span class="line">label = torch.tensor([<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(label)</span><br><span class="line"></span><br><span class="line">logits = x @ w.t()</span><br><span class="line"><span class="built_in">print</span>(logits)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cross_entropy = softmax + log + nll_loss(负对数似然损失)</span></span><br><span class="line">pred = F.softmax(logits, dim=<span class="number">1</span>)</span><br><span class="line">pred_log = torch.log(pred)</span><br><span class="line">loss = F.nll_loss(pred_log, label)</span><br><span class="line"><span class="built_in">print</span>(loss)</span><br><span class="line"></span><br><span class="line">cross_en = F.cross_entropy(logits, label)</span><br><span class="line"><span class="built_in">print</span>(cross_en)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">200</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载MNIST数据</span></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                   transform=transforms.Compose([</span><br><span class="line">                       transforms.ToTensor(),</span><br><span class="line">                       transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                   ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, transform=transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">    ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line">w1, b1 = torch.randn(<span class="number">200</span>, <span class="number">784</span>, requires_grad=<span class="literal">True</span>), \</span><br><span class="line">         torch.zeros(<span class="number">200</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">w2, b2 = torch.randn(<span class="number">200</span>, <span class="number">200</span>, requires_grad=<span class="literal">True</span>), \</span><br><span class="line">         torch.zeros(<span class="number">200</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">w3, b3 = torch.randn(<span class="number">10</span>, <span class="number">200</span>, requires_grad=<span class="literal">True</span>), \</span><br><span class="line">         torch.zeros(<span class="number">10</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">torch.nn.init.kaiming_normal_(w1)</span><br><span class="line">torch.nn.init.kaiming_normal_(w2)</span><br><span class="line">torch.nn.init.kaiming_normal_(w3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前向传播</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x</span>):</span></span><br><span class="line">    x = x @ w1.t() + b1</span><br><span class="line">    x = F.relu(x)</span><br><span class="line">    x = x @ w2.t() + b2</span><br><span class="line">    x = F.relu(x)</span><br><span class="line">    x = x @ w3.t() + b3</span><br><span class="line">    x = F.relu(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义优化器和损失</span></span><br><span class="line">optimizer = optim.SGD([w1, b1, w2, b2, w3, b3], lr=learning_rate)</span><br><span class="line">criteon = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="comment"># 训练集损失</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)    <span class="comment"># -1表示自适应维度的size</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 前向传播</span></span><br><span class="line">        logits = forward(data)</span><br><span class="line">        loss = criteon(logits, target)</span><br><span class="line">        <span class="comment"># 梯度清零</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># 反向传播</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># 梯度下降</span></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                       <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试集损失</span></span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">        logits = forward(data)</span><br><span class="line">        test_loss += criteon(logits, target).item()</span><br><span class="line"></span><br><span class="line">        pred = logits.data.<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">        correct += pred.eq(target.data).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)))</span><br></pre></td></tr></table></figure>



<h2 id="全连接神经网络"><a href="#全连接神经网络" class="headerlink" title="全连接神经网络"></a>全连接神经网络</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">200</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                   transform=transforms.Compose([</span><br><span class="line">                       transforms.ToTensor(),</span><br><span class="line">                       transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                   ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, transform=transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">    ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 定义模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化模型网络层&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(MLP, self).__init__()</span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>, <span class="number">200</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">200</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">10</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;前向传播&quot;&quot;&quot;</span></span><br><span class="line">        x = self.model(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定义优化器和损失函数</span></span><br><span class="line">net = MLP()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=learning_rate)</span><br><span class="line">criteon = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.训练模型</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前向传播，会自动调用模型的forward函数</span></span><br><span class="line">        logits = net(data)</span><br><span class="line">        loss = criteon(logits, target)</span><br><span class="line">        <span class="comment"># 梯度清零</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># 反向传播</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># 梯度下降</span></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                       <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line"></span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">        logits = net(data)</span><br><span class="line">        test_loss += criteon(logits, target).item()</span><br><span class="line"></span><br><span class="line">        pred = logits.data.<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">        correct += pred.eq(target.data).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)))</span><br></pre></td></tr></table></figure>



<h2 id="激活函数与CPU加速"><a href="#激活函数与CPU加速" class="headerlink" title="激活函数与CPU加速"></a>激活函数与CPU加速</h2><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><ul>
<li><p>tanh，sigmoid</p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668915387877.png" alt="1668915387877"></p>
</li>
<li><p>relu</p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668915414865.png" alt="1668915414865"></p>
</li>
<li><p>leak relu</p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668915439685.png" alt="1668915439685"></p>
</li>
<li><p>selu</p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668915461546.png" alt="1668915461546"></p>
</li>
<li><p>softplus</p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668915475286.png" alt="1668915475286"></p>
</li>
</ul>
<h3 id="CPU加速"><a href="#CPU加速" class="headerlink" title="CPU加速"></a>CPU加速</h3><p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668924196943.png" alt="1668924196943"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668927592950.png" alt="1668927592950"></p>
<h2 id="手写体数字识别"><a href="#手写体数字识别" class="headerlink" title="手写体数字识别"></a>手写体数字识别</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">from</span> plot.utils <span class="keyword">import</span> plot_image, plot_curve</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">200</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                   transform=transforms.Compose([</span><br><span class="line">                       transforms.ToTensor(),</span><br><span class="line">                       transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                   ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, transform=transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">    ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印几张图片的例子</span></span><br><span class="line">x, y = <span class="built_in">next</span>(<span class="built_in">iter</span>(train_loader))</span><br><span class="line"><span class="built_in">print</span>(x.shape, y.shape, x.<span class="built_in">min</span>(), x.<span class="built_in">max</span>())</span><br><span class="line">plot_image(x, y, <span class="string">&#x27;image sample&#x27;</span>)</span><br><span class="line"><span class="comment"># torch.Size([512, 1, 28, 28]) torch.Size([512]) tensor(-0.4242) tensor(2.8215)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MLP, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>, <span class="number">200</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">200</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">10</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.model(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line">net = MLP().to(device)</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=learning_rate)</span><br><span class="line">criteon = nn.CrossEntropyLoss().to(device)</span><br><span class="line"></span><br><span class="line">train_losses = []</span><br><span class="line">test_losses = []</span><br><span class="line">accuracys = []</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="comment"># 训练误差</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)   <span class="comment"># 将每张图片的数据打平</span></span><br><span class="line">        data, target = data.to(device), target.cuda()</span><br><span class="line"></span><br><span class="line">        logits = net(data)</span><br><span class="line">        loss = criteon(logits, target)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        train_losses.append(loss.item())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                       <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试误差与精度</span></span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">        data, target = data.to(device), target.cuda()</span><br><span class="line">        logits = net(data)</span><br><span class="line"></span><br><span class="line">        test_loss += criteon(logits, target).item()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在第一维度上求最大值所在索引，即模型预测值</span></span><br><span class="line">        pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 测试集中预测正确的图片数量</span></span><br><span class="line">        <span class="comment"># pred.eq(y)做一个掩码，相同为1不同为0</span></span><br><span class="line">        correct += pred.eq(target).<span class="built_in">float</span>().<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)   <span class="comment"># 取平均误差</span></span><br><span class="line"></span><br><span class="line">    test_losses.append(test_loss)</span><br><span class="line">    accuracys.append(correct / <span class="built_in">len</span>(test_loader.dataset))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)))</span><br><span class="line"></span><br><span class="line">plot_curve(train_losses)</span><br><span class="line">plot_curve(test_losses)</span><br><span class="line">plot_curve(accuracys)</span><br></pre></td></tr></table></figure>

<p>plot.utils</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_curve</span>(<span class="params">data</span>):</span></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    plt.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(data)), data, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">    plt.legend([<span class="string">&#x27;value&#x27;</span>], loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;step&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_image</span>(<span class="params">img, label, name</span>):</span></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i + <span class="number">1</span>)</span><br><span class="line">        plt.tight_layout()</span><br><span class="line">        plt.imshow(img[i][<span class="number">0</span>] * <span class="number">0.3081</span> + <span class="number">0.1307</span>, cmap=<span class="string">&#x27;gray&#x27;</span>, interpolation=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, label[i].item()))</span><br><span class="line">        plt.xticks([])</span><br><span class="line">        plt.yticks([])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_hot</span>(<span class="params">label, depth=<span class="number">10</span></span>):</span></span><br><span class="line">    out = torch.zeros(label.size(<span class="number">0</span>), depth)</span><br><span class="line">    idx = torch.LongTensor(label).view(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    out.scatter_(dim=<span class="number">1</span>, index=idx, value=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/train_loss.png" alt="train_loss" style="zoom: 80%;">

<img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/test_loss.png" alt="test_loss" style="zoom:80%;">

<img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/accuracy-1669089131638.png" alt="accuracy" style="zoom:80%;">



<h2 id="visdom可视化"><a href="#visdom可视化" class="headerlink" title="visdom可视化"></a>visdom可视化</h2><h3 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h3><ul>
<li><p>step1 安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install visdom</span><br><span class="line"><span class="comment"># 使用镜像源下载</span></span><br><span class="line">pip install visdom -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li>
<li><p>step2 启动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m visdom.server</span><br></pre></td></tr></table></figure></li>
<li><p>问题解决可参考</p>
<ul>
<li><a href="https://blog.csdn.net/didi_ya/article/details/108364679">Visdom库（pytorch中的可视化工具）安装问题的解决方案及使用方法详解</a></li>
<li><a href="https://blog.csdn.net/young1973/article/details/105509730">解决visdom使用中出现的一些问题（无需积分下载static文件）</a></li>
</ul>
</li>
</ul>
<h3 id="作图举例"><a href="#作图举例" class="headerlink" title="作图举例"></a>作图举例</h3><ul>
<li><p>实时绘制损失和精度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> visdom <span class="keyword">import</span> Visdom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在神经网络中绘制loss曲线和精度曲线时就可用下面的方法。</span></span><br><span class="line"><span class="comment"># 新建一个客户端，环境命名为&#x27;mnist&#x27;,如果不设置的话默认为&#x27;main&#x27;</span></span><br><span class="line">viz = visdom.Visdom(env=<span class="string">&#x27;mnist&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线图初始点。loss是差值图，acc是精度图</span></span><br><span class="line">viz.line([<span class="number">0.</span>], [<span class="number">0.</span>], win=<span class="string">&#x27;train_loss&#x27;</span>, opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;train loss&#x27;</span>))</span><br><span class="line">viz.line([<span class="number">0.</span>], [<span class="number">0.</span>], win=<span class="string">&#x27;acc&#x27;</span>, opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;test acc&#x27;</span>))</span><br><span class="line"><span class="comment"># 使用&#x27;append&#x27;可以实时的添加随程序运行逐渐产生的loss值。</span></span><br><span class="line">viz.line([loss.item()], [global_step], win=<span class="string">&#x27;train_loss&#x27;</span>, update=<span class="string">&#x27;append&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>绘制折线图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">![newplot](D:/QQPCmgr/Desktop/newplot.png<span class="comment"># a为x轴数值，b为y轴数值,win为绘制曲线的环境窗体名称，opts为图的名称</span></span><br><span class="line">viz = Visdom(env=<span class="string">&quot;line chart&quot;</span>)</span><br><span class="line"><span class="comment"># 创建线图初始点。</span></span><br><span class="line">viz.line([<span class="number">0.</span>], [<span class="number">0.</span>], win=<span class="string">&#x27;line&#x27;</span>, opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;line chart&#x27;</span>))</span><br><span class="line">a, b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    a = np.array([i])</span><br><span class="line">    <span class="comment"># 随机生成y值</span></span><br><span class="line">    b = np.random.randn(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 使用‘append’实时添加产生的a，b值</span></span><br><span class="line">    viz.line(b, a, win=<span class="string">&#x27;line&#x27;</span>, update=<span class="string">&quot;append&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/newplot.png" alt="line"></p>
</li>
<li><p>绘制Image图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用visdom绘制image图像</span></span><br><span class="line">viz = Visdom(env=<span class="string">&quot;images&quot;</span>)</span><br><span class="line"><span class="comment"># nrow表示每行显示的图片数量，(16,3,32,32)表示16张3通道的32*32大小的图片</span></span><br><span class="line">viz.images(torch.randn(<span class="number">16</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>).numpy(), nrow=<span class="number">4</span>, win=<span class="string">&#x27;imgs&#x27;</span>, opts=&#123;<span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;imgs&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/imgs.jpg" alt="imgs"></p>
</li>
</ul>
<h3 id="与pytorch联用"><a href="#与pytorch联用" class="headerlink" title="与pytorch联用"></a>与pytorch联用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> visdom <span class="keyword">import</span> Visdom</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">200</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                   transform=transforms.Compose([</span><br><span class="line">                       transforms.ToTensor(),</span><br><span class="line">                       <span class="comment"># transforms.Normalize((0.1307,), (0.3081,))</span></span><br><span class="line">                   ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, transform=transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        <span class="comment"># transforms.Normalize((0.1307,), (0.3081,))</span></span><br><span class="line">    ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MLP, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>, <span class="number">200</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">200</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">10</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.model(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line">net = MLP().to(device)</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=learning_rate)</span><br><span class="line">criteon = nn.CrossEntropyLoss().to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化viz</span></span><br><span class="line">viz = Visdom()</span><br><span class="line">viz.line([<span class="number">0.</span>], [<span class="number">0.</span>], win=<span class="string">&#x27;train_loss&#x27;</span>, opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;train loss&#x27;</span>))</span><br><span class="line">viz.line([[<span class="number">0.0</span>, <span class="number">0.0</span>]], [<span class="number">0.</span>], win=<span class="string">&#x27;test&#x27;</span>, opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;test loss&amp;acc.&#x27;</span>,</span><br><span class="line">                                                   legend=[<span class="string">&#x27;loss&#x27;</span>, <span class="string">&#x27;acc.&#x27;</span>]))</span><br><span class="line">global_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">        data, target = data.to(device), target.cuda()</span><br><span class="line"></span><br><span class="line">        logits = net(data)</span><br><span class="line">        loss = criteon(logits, target)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制训练损失</span></span><br><span class="line">        global_step += <span class="number">1</span></span><br><span class="line">        viz.line([loss.item()], [global_step], win=<span class="string">&#x27;train_loss&#x27;</span>, update=<span class="string">&#x27;append&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                       <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line"></span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">        data, target = data.to(device), target.cuda()</span><br><span class="line">        logits = net(data)</span><br><span class="line">        test_loss += criteon(logits, target).item()</span><br><span class="line"></span><br><span class="line">        pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line">        correct += pred.eq(target).<span class="built_in">float</span>().<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制测试损失</span></span><br><span class="line">    viz.line([[test_loss, correct / <span class="built_in">len</span>(test_loader.dataset)]],</span><br><span class="line">             [global_step], win=<span class="string">&#x27;test&#x27;</span>, update=<span class="string">&#x27;append&#x27;</span>)</span><br><span class="line">    <span class="comment"># 绘制测试图像和对应的标签值</span></span><br><span class="line">    viz.images(data.view(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>), win=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    viz.text(<span class="built_in">str</span>(pred.detach().cpu().numpy()), win=<span class="string">&#x27;pred&#x27;</span>,</span><br><span class="line">             opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;pred&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)))</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669119787758.png" alt="1669119787758"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669119806301.png" alt="1669119806301"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669119906052.png" alt="1669119906052"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669166801846.png" alt="1669166801846"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669120277247.png" alt="1669120277247"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669120436916.png" alt="1669120436916"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669166815409.png" alt="1669166815409"></p>
<h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">from</span> visdom <span class="keyword">import</span> Visdom</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">200</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">train_db = datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                          transform=transforms.Compose([</span><br><span class="line">                              transforms.ToTensor(),</span><br><span class="line">                              transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                          ]))</span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    train_db,</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test_db = datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, transform=transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">]))</span><br><span class="line">test_loader = torch.utils.data.DataLoader(test_db,</span><br><span class="line">                                          batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将训练集数据划分为训练集和验证集</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train:&#x27;</span>, <span class="built_in">len</span>(train_db), <span class="string">&#x27;test:&#x27;</span>, <span class="built_in">len</span>(test_db))</span><br><span class="line">train_db, val_db = torch.utils.data.random_split(train_db, [<span class="number">50000</span>, <span class="number">10000</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;db1:&#x27;</span>, <span class="built_in">len</span>(train_db), <span class="string">&#x27;db2:&#x27;</span>, <span class="built_in">len</span>(val_db))</span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    train_db,</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">val_loader = torch.utils.data.DataLoader(</span><br><span class="line">    val_db,</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MLP, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>, <span class="number">200</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">200</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">10</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.model(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line">net = MLP().to(device)</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=learning_rate)</span><br><span class="line">criteon = nn.CrossEntropyLoss().to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化viz</span></span><br><span class="line">viz = Visdom(env=<span class="string">&#x27;cross validation&#x27;</span>)</span><br><span class="line">viz.line([<span class="number">0.</span>], [<span class="number">0.</span>], win=<span class="string">&#x27;train_loss&#x27;</span>, opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;train loss&#x27;</span>))</span><br><span class="line">viz.line([[<span class="number">0.0</span>, <span class="number">0.0</span>]], [<span class="number">0.</span>], win=<span class="string">&#x27;val&#x27;</span>, opts=<span class="built_in">dict</span>(title=<span class="string">&#x27;validation loss&amp;acc.&#x27;</span>,</span><br><span class="line">                                                   legend=[<span class="string">&#x27;loss&#x27;</span>, <span class="string">&#x27;acc.&#x27;</span>]))</span><br><span class="line">global_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">        data, target = data.to(device), target.cuda()</span><br><span class="line"></span><br><span class="line">        logits = net(data)</span><br><span class="line">        loss = criteon(logits, target)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制训练损失</span></span><br><span class="line">        global_step += <span class="number">1</span></span><br><span class="line">        viz.line([loss.item()], [global_step], win=<span class="string">&#x27;train_loss&#x27;</span>, update=<span class="string">&#x27;append&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                       <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line"></span><br><span class="line">    val_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 验证集损失与精度，用来验证模型训练过程是否过拟合</span></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> val_loader:</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">        data, target = data.to(device), target.cuda()</span><br><span class="line">        logits = net(data)</span><br><span class="line">        val_loss += criteon(logits, target).item()</span><br><span class="line"></span><br><span class="line">        pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line">        correct += pred.eq(target.data).<span class="built_in">sum</span>().item()</span><br><span class="line">        <span class="comment"># print(type(pred.eq(target.data).sum().item()))</span></span><br><span class="line">        <span class="comment"># print(type(pred.eq(target.data).sum()))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制验证损失</span></span><br><span class="line">    viz.line([[val_loss, correct / <span class="built_in">len</span>(test_loader.dataset)]],</span><br><span class="line">             [global_step], win=<span class="string">&#x27;val&#x27;</span>, update=<span class="string">&#x27;append&#x27;</span>)</span><br><span class="line">    <span class="comment"># 绘制测试图像和对应的标签值</span></span><br><span class="line">    <span class="comment"># viz.images(data.view(-1, 1, 28, 28), win=&#x27;x&#x27;)</span></span><br><span class="line">    <span class="comment"># viz.text(str(pred.detach().cpu().numpy()), win=&#x27;pred&#x27;,</span></span><br><span class="line">    <span class="comment">#          opts=dict(title=&#x27;pred&#x27;))</span></span><br><span class="line"></span><br><span class="line">    val_loss /= <span class="built_in">len</span>(val_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nVAL set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        val_loss, correct, <span class="built_in">len</span>(val_loader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(val_loader.dataset)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集损失与精度，验证模型泛化能力</span></span><br><span class="line">test_loss = <span class="number">0</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">    data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">    data, target = data.to(device), target.cuda()</span><br><span class="line">    logits = net(data)</span><br><span class="line">    test_loss += criteon(logits, target).item()</span><br><span class="line"></span><br><span class="line">    pred = logits.data.<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">    correct += pred.eq(target.data).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">    test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">    <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_db = datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                          transform=transforms.Compose([</span><br><span class="line">                              transforms.ToTensor(),</span><br><span class="line">                              transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                          ]))</span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    train_db,</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test_db = datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, transform=transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">]))</span><br><span class="line">test_loader = torch.utils.data.DataLoader(test_db,</span><br><span class="line">                                          batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将训练集数据划分为训练集和验证集</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train:&#x27;</span>, <span class="built_in">len</span>(train_db), <span class="string">&#x27;test:&#x27;</span>, <span class="built_in">len</span>(test_db))</span><br><span class="line">train_db, val_db = torch.utils.data.random_split(train_db, [<span class="number">50000</span>, <span class="number">10000</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;db1:&#x27;</span>, <span class="built_in">len</span>(train_db), <span class="string">&#x27;db2:&#x27;</span>, <span class="built_in">len</span>(val_db))</span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    train_db,</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">val_loader = torch.utils.data.DataLoader(</span><br><span class="line">    val_db,</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h3 id="k-fold-cross-validation"><a href="#k-fold-cross-validation" class="headerlink" title="k-fold cross-validation"></a>k-fold cross-validation</h3><p><a href="https://blog.csdn.net/foneone/article/details/104445320">pytorch - K折交叉验证过程说明及实现</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader,Dataset   </span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"> </span><br><span class="line"><span class="comment">#####构造的训练集####</span></span><br><span class="line">x = torch.rand(<span class="number">100</span>,<span class="number">28</span>,<span class="number">28</span>) </span><br><span class="line">y = torch.randn(<span class="number">100</span>,<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">x = torch.cat((x,y),dim=<span class="number">0</span>)</span><br><span class="line">label =[<span class="number">1</span>] *<span class="number">100</span> + [<span class="number">0</span>]*<span class="number">100</span>  </span><br><span class="line">label = torch.tensor(label,dtype=torch.long)</span><br><span class="line"> </span><br><span class="line"><span class="comment">######网络结构##########</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="comment">#定义Net</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__() </span><br><span class="line">     </span><br><span class="line">        self.fc1   = nn.Linear(<span class="number">28</span>*<span class="number">28</span>, <span class="number">120</span>) </span><br><span class="line">        self.fc2   = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3   = nn.Linear(<span class="number">84</span>, <span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">       </span><br><span class="line">        x = x.view(-<span class="number">1</span>, self.num_flat_features(x)) </span><br><span class="line">      </span><br><span class="line">        x = F.relu(self.fc1(x)) </span><br><span class="line">        x = F.relu(self.fc2(x)) </span><br><span class="line">        x = self.fc3(x) </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_flat_features</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        size = x.size()[<span class="number">1</span>:] </span><br><span class="line">        num_features = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</span><br><span class="line">            num_features *= s</span><br><span class="line">        <span class="keyword">return</span> num_features</span><br><span class="line"> </span><br><span class="line"><span class="comment">##########定义dataset##########</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraindataSet</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,train_features,train_labels</span>):</span></span><br><span class="line">        self.x_data = train_features</span><br><span class="line">        self.y_data = train_labels</span><br><span class="line">        self.<span class="built_in">len</span> = <span class="built_in">len</span>(train_labels)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self,index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x_data[index],self.y_data[index]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">########k折划分############        </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_k_fold_data</span>(<span class="params">k, i, X, y</span>):</span>  <span class="comment">###此过程主要是步骤（1）</span></span><br><span class="line">    <span class="comment"># 返回第i折交叉验证时所需要的训练和验证数据，分开放，X_train为训练数据，X_valid为验证数据</span></span><br><span class="line">    <span class="keyword">assert</span> k &gt; <span class="number">1</span></span><br><span class="line">    fold_size = X.shape[<span class="number">0</span>] // k  <span class="comment"># 每份的个数:数据总条数/折数（组数）</span></span><br><span class="line">    </span><br><span class="line">    X_train, y_train = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        idx = <span class="built_in">slice</span>(j * fold_size, (j + <span class="number">1</span>) * fold_size)  <span class="comment">#slice(start,end,step)切片函数</span></span><br><span class="line">        <span class="comment">##idx 为每组 valid</span></span><br><span class="line">        X_part, y_part = X[idx, :], y[idx]</span><br><span class="line">        <span class="keyword">if</span> j == i: <span class="comment">###第i折作valid</span></span><br><span class="line">            X_valid, y_valid = X_part, y_part</span><br><span class="line">        <span class="keyword">elif</span> X_train <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            X_train, y_train = X_part, y_part</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = torch.cat((X_train, X_part), dim=<span class="number">0</span>) <span class="comment">#dim=0增加行数，竖着连接</span></span><br><span class="line">            y_train = torch.cat((y_train, y_part), dim=<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#print(X_train.size(),X_valid.size())</span></span><br><span class="line">    <span class="keyword">return</span> X_train, y_train, X_valid,y_valid</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_fold</span>(<span class="params">k, X_train, y_train, num_epochs=<span class="number">3</span>,learning_rate=<span class="number">0.001</span>, weight_decay=<span class="number">0.1</span>, batch_size=<span class="number">5</span></span>):</span></span><br><span class="line">    train_loss_sum, valid_loss_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    train_acc_sum ,valid_acc_sum = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        data = get_k_fold_data(k, i, X_train, y_train) <span class="comment"># 获取k折交叉验证的训练和验证数据</span></span><br><span class="line">        net =  Net()  <span class="comment">### 实例化模型</span></span><br><span class="line">        <span class="comment">### 每份数据进行训练,体现步骤三####</span></span><br><span class="line">        train_ls, valid_ls = train(net, *data, num_epochs, learning_rate,\</span><br><span class="line">                                   weight_decay, batch_size) </span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">25</span>,<span class="string">&#x27;第&#x27;</span>,i+<span class="number">1</span>,<span class="string">&#x27;折&#x27;</span>,<span class="string">&#x27;*&#x27;</span>*<span class="number">25</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;train_loss:%.6f&#x27;</span>%train_ls[-<span class="number">1</span>][<span class="number">0</span>],<span class="string">&#x27;train_acc:%.4f\n&#x27;</span>%valid_ls[-<span class="number">1</span>][<span class="number">1</span>],\</span><br><span class="line">              <span class="string">&#x27;valid loss:%.6f&#x27;</span>%valid_ls[-<span class="number">1</span>][<span class="number">0</span>],<span class="string">&#x27;valid_acc:%.4f&#x27;</span>%valid_ls[-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        train_loss_sum += train_ls[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        valid_loss_sum += valid_ls[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        train_acc_sum += train_ls[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">        valid_acc_sum += valid_ls[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#&#x27;</span>*<span class="number">10</span>,<span class="string">&#x27;最终k折交叉验证结果&#x27;</span>,<span class="string">&#x27;#&#x27;</span>*<span class="number">10</span>) </span><br><span class="line">    <span class="comment">####体现步骤四#####</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;train_loss_sum:%.4f&#x27;</span>%(train_loss_sum/k),<span class="string">&#x27;train_acc_sum:%.4f\n&#x27;</span>%(train_acc_sum/k),\</span><br><span class="line">          <span class="string">&#x27;valid_loss_sum:%.4f&#x27;</span>%(valid_loss_sum/k),<span class="string">&#x27;valid_acc_sum:%.4f&#x27;</span>%(valid_acc_sum/k))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#########训练函数##########</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, train_features, train_labels, test_features, test_labels, num_epochs, learning_rate,weight_decay, batch_size</span>):</span></span><br><span class="line">    train_ls, test_ls = [], [] <span class="comment">##存储train_loss,test_loss</span></span><br><span class="line">    dataset = TraindataSet(train_features, train_labels) </span><br><span class="line">    train_iter = DataLoader(dataset, batch_size, shuffle=<span class="literal">True</span>) </span><br><span class="line">    <span class="comment">### 将数据封装成 Dataloder 对应步骤（2）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#这里使用了Adam优化算法</span></span><br><span class="line">    optimizer = torch.optim.Adam(params=net.parameters(), lr= learning_rate, weight_decay=weight_decay)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:  <span class="comment">###分批训练 </span></span><br><span class="line">            output  = net(X)</span><br><span class="line">            loss = loss_func(output,y)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">        <span class="comment">### 得到每个epoch的 loss 和 accuracy </span></span><br><span class="line">        train_ls.append(log_rmse(<span class="number">0</span>,net, train_features, train_labels)) </span><br><span class="line">        <span class="keyword">if</span> test_labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            test_ls.append(log_rmse(<span class="number">1</span>,net, test_features, test_labels))</span><br><span class="line">    <span class="comment">#print(train_ls,test_ls)</span></span><br><span class="line">    <span class="keyword">return</span> train_ls, test_ls</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_rmse</span>(<span class="params">flag,net,x,y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>: <span class="comment">### valid 数据集</span></span><br><span class="line">        net.<span class="built_in">eval</span>()</span><br><span class="line">    output = net(x)</span><br><span class="line">    result = torch.<span class="built_in">max</span>(output,<span class="number">1</span>)[<span class="number">1</span>].view(y.size())</span><br><span class="line">    corrects = (result.data == y.data).<span class="built_in">sum</span>().item()</span><br><span class="line">    accuracy = corrects*<span class="number">100.0</span>/<span class="built_in">len</span>(y)  <span class="comment">#### 5 是 batch_size</span></span><br><span class="line">    loss = loss_func(output,y)</span><br><span class="line">    net.train()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (loss.data.item(),accuracy)</span><br><span class="line"> </span><br><span class="line">loss_func = nn.CrossEntropyLoss() <span class="comment">###申明loss函</span></span><br><span class="line">k_fold(<span class="number">10</span>,x,label) <span class="comment">### k=10,十折交叉验证</span></span><br></pre></td></tr></table></figure>



<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><h3 id="奥卡姆剃刀原则"><a href="#奥卡姆剃刀原则" class="headerlink" title="奥卡姆剃刀原则"></a>奥卡姆剃刀原则</h3><p><a href="https://baike.baidu.com/item/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80%E5%8E%9F%E7%90%86/10900565?fr=kg_general">奥卡姆剃刀原则</a></p>
<h3 id="减少过拟合"><a href="#减少过拟合" class="headerlink" title="减少过拟合"></a>减少过拟合</h3><ul>
<li>More data</li>
<li>Constraint model complexity<ul>
<li>shallow</li>
<li>regularization 正则化</li>
</ul>
</li>
<li>Dropput</li>
<li>Data argumentation 数据增强</li>
<li>Early stopptin</li>
</ul>
<h3 id="正则化项"><a href="#正则化项" class="headerlink" title="正则化项"></a>正则化项</h3><p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669172264288.png" alt="1669172264288"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>L2-regularization</p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669172347227.png" alt="1669172347227"></p>
</li>
<li><p>L1-regularization</p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669172468212.png" alt="1669172468212"></p>
</li>
</ul>
<h2 id="动量和学习率衰减"><a href="#动量和学习率衰减" class="headerlink" title="动量和学习率衰减"></a>动量和学习率衰减</h2><h3 id="动量-momentum"><a href="#动量-momentum" class="headerlink" title="动量 momentum"></a>动量 momentum</h3><p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669252095671.png" alt="1669252095671"></p>
<ul>
<li>也就是说，权值w现在不只向着 $\bigtriangledown{f}$ 的方向衰减，也向着的$z^{k}$方向进行衰减。而$z^{k}$是由$\bigtriangledown{w^{k-1}}$推出的，也就是现在w更新是当前衰减方向和之前衰减方向的惯性的结合。</li>
</ul>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669252733487.png" alt="1669252733487"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669252745212.png" alt="1669252745212"></p>
<ul>
<li><p>设置动量</p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669252833860.png" alt="1669252833860"></p>
<p> 对于优化器SGD是需要进行设置的，但是对于Adam优化器不需要设置，因为它本身就有。 </p>
</li>
</ul>
<h3 id="学习率衰减-learning-rate-decay"><a href="#学习率衰减-learning-rate-decay" class="headerlink" title="学习率衰减 learning rate decay"></a>学习率衰减 learning rate decay</h3><p>（1）  第一种，观测loss，如果到了一定时间，一直不变，就代表它无法找到更细分的地方，然后把learning rate减小点。 </p>
<p> .step（loss_val）用来监测记录loss，检测周期为patience=的次数，如果没有不变的情况，则只有记录的作用，如果检测到，那么会按设定的规则进行减小learning rate。 </p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669253046483.png" alt="1669253046483"></p>
<p>（2） 第二种是简单粗暴的，直接每多少次epoch减小多少 </p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669253122256.png" alt="1669253122256"></p>
<h2 id="Early-stop-and-Dropout"><a href="#Early-stop-and-Dropout" class="headerlink" title="Early stop and Dropout"></a>Early stop and Dropout</h2><h3 id="Early-stop"><a href="#Early-stop" class="headerlink" title="Early stop"></a>Early stop</h3><p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669254359267.png" alt="1669254359267"></p>
<h3 id="Dropput"><a href="#Dropput" class="headerlink" title="Dropput"></a>Dropput</h3><p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669254380365.png" alt="1669254380365"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669254406113.png" alt="1669254406113"></p>
<h2 id="卷积神经网络（CNN）"><a href="#卷积神经网络（CNN）" class="headerlink" title="卷积神经网络（CNN）"></a>卷积神经网络（CNN）</h2><h3 id="几个符号含义"><a href="#几个符号含义" class="headerlink" title="几个符号含义"></a>几个符号含义</h3><ul>
<li><strong>Input_channels:</strong> 输入数据的通道数，一般是RGB三个通道</li>
<li>**Kernel_channels: **Kernel的通道数，与 Input_channels一致， 也是每个kernel里面的卷积数</li>
<li><strong>Kernel_number:</strong> Kernel的数目，根据需要自定义</li>
<li><strong>Kernel_size:</strong> 卷积的尺寸，如3*3</li>
<li><strong>Stride:</strong>  步长</li>
<li><strong>Padding:</strong> 补丁</li>
</ul>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669345768825.png" alt="1669345768825"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669345996947.png" alt="1669345996947"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669346399823.png" alt="1669346399823"></p>
<h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><h4 id="nn-Conv2d"><a href="#nn-Conv2d" class="headerlink" title="nn.Conv2d"></a>nn.Conv2d</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. nn.Conv2d</span></span><br><span class="line">x = torch.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">28</span>)    <span class="comment"># [b, c, h, w]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># in_channels:每个kernel的通道数=输入通道数3， out_channels:kernel的数目=输出通道数</span></span><br><span class="line">layer = nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">4</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">out = layer.forward(x)</span><br><span class="line"><span class="built_in">print</span>(out.shape)    <span class="comment"># torch.Size([1, 4, 26, 26])</span></span><br><span class="line"></span><br><span class="line">layer = nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">4</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">out = layer.forward(x)</span><br><span class="line"><span class="built_in">print</span>(out.shape)    <span class="comment"># torch.Size([1, 4, 28, 28])</span></span><br><span class="line"></span><br><span class="line">layer = nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">4</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">out = layer.forward(x)</span><br><span class="line"><span class="built_in">print</span>(out.shape)    <span class="comment"># torch.Size([1, 4, 14, 14])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(layer.weight.shape)   <span class="comment"># torch.Size([4, 3, 3, 3])</span></span><br><span class="line"><span class="built_in">print</span>(layer.bias.shape) <span class="comment"># torch.Size([4])</span></span><br></pre></td></tr></table></figure>



<h4 id="F-Conv2d"><a href="#F-Conv2d" class="headerlink" title="F.Conv2d"></a>F.Conv2d</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. F.conv2d</span></span><br><span class="line">x = torch.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">28</span>)    <span class="comment"># [b, c, h, w]</span></span><br><span class="line">w = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)      <span class="comment"># 4个kernel,每个kernel有3个通道，尺寸为3*3</span></span><br><span class="line">b = torch.rand(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">out = F.conv2d(x, w, b, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(out.shape)    <span class="comment"># torch.Size([1, 4, 26, 26])</span></span><br></pre></td></tr></table></figure>



<h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><h4 id="nn-MaxPool2d"><a href="#nn-MaxPool2d" class="headerlink" title="nn.MaxPool2d"></a>nn.MaxPool2d</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">x = torch.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">28</span>)    <span class="comment"># [b, c, h, w]</span></span><br><span class="line">c_layer = nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">4</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">out1 = c_layer.forward(x)</span><br><span class="line"><span class="built_in">print</span>(out1.shape)	<span class="comment"># torch.Size([1, 4, 26, 26])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 下采样</span></span><br><span class="line"><span class="comment"># nn.MaxPool2d</span></span><br><span class="line">p_layer = nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line">out2 = p_layer(out1)</span><br><span class="line"><span class="built_in">print</span>(out2.shape)	<span class="comment"># torch.Size([1, 4, 13, 13])</span></span><br><span class="line"></span><br><span class="line">p_layer = nn.AvgPool2d(<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line">out2 = p_layer(out1)</span><br><span class="line"><span class="built_in">print</span>(out2.shape)	<span class="comment"># torch.Size([1, 4, 13, 13])</span></span><br></pre></td></tr></table></figure>



<h4 id="F-max-pool2d"><a href="#F-max-pool2d" class="headerlink" title="F.max_pool2d"></a>F.max_pool2d</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out2 = F.max_pool2d(out1, <span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(out2.shape)	<span class="comment"># torch.Size([1, 4, 13, 13])</span></span><br><span class="line"></span><br><span class="line">out2 = F.avg_pool2d(out1, <span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(out2.shape)	<span class="comment"># torch.Size([1, 4, 13, 13])</span></span><br></pre></td></tr></table></figure>



<h4 id="F-interpolate"><a href="#F-interpolate" class="headerlink" title="F.interpolate"></a>F.interpolate</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 上采样 F.interpolate</span></span><br><span class="line">x = torch.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">out = F.interpolate(x, scale_factor=<span class="number">2</span>, mode=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(out.shape)	<span class="comment"># torch.Size([1, 3, 56, 56])</span></span><br></pre></td></tr></table></figure>





<h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><ul>
<li>几种Normalization</li>
</ul>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669357924714.png" alt="1669357924714"></p>
<ul>
<li>batch normalizatioin</li>
</ul>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669357964873.png" alt="1669357964873"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669358018212.png" alt="1669358018212"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669358075614.png" alt="1669358075614"></p>
<ul>
<li>优点<ul>
<li>Converge faster 收敛更快</li>
<li>Better performance 更好的表现</li>
<li>Robust 鲁棒</li>
</ul>
</li>
</ul>
<h2 id="nn-Module模块"><a href="#nn-Module模块" class="headerlink" title="nn.Module模块"></a>nn.Module模块</h2><p>转载自 <a href="https://zhuanlan.zhihu.com/p/557253923">pytorch nn.Module模块以及nn部分函数的介绍使用</a></p>
<h3 id="nn-Module"><a href="#nn-Module" class="headerlink" title="nn.Module"></a>nn.Module</h3><p>​    ‎nn.Module是所有神经网络模块的基类，我们使用pytorch构建神经网络需要继承nn.Module类来实现，在<code>__init__</code>构造函数中申明各个层的定义，在<code>forward</code>中实现层之间的连接关系，实际上就是前向传播的过程。</p>
<p>举个栗子，下面是简单构建有一个神经网络：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">20</span>, <span class="number">20</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = nn.ReLU(self.conv1(x))</span><br><span class="line">        x = nn.ReLU(self.conv2(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>





<h3 id="nn-Conv2"><a href="#nn-Conv2" class="headerlink" title="nn.Conv2"></a>nn.Conv2</h3><p>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, groups=<span class="number">1</span>, bias=<span class="literal">True</span>, padding_mode=<span class="string">&#x27;zeros&#x27;</span>, device=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>‎对由多个输入平面组成的输入信号应用 <strong>2D 卷积</strong>。‎这个就是用在卷积神经网络中的卷积层。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数类型</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>in_channels</td>
<td>int</td>
<td>Number of channels in the input image</td>
<td>输入图像通道数</td>
</tr>
<tr>
<td>out_channels</td>
<td>int</td>
<td>Number of channels produced by the convolution</td>
<td>卷积产生的通道数</td>
</tr>
<tr>
<td>kernel_size</td>
<td>(int or tuple)</td>
<td>Size of the convolving kernel</td>
<td>卷积核尺寸，可以设为1个int型数或者一个(int, int)型的元组。例如(2,3)是高2宽3卷积核</td>
</tr>
<tr>
<td>stride</td>
<td>(int or tuple, optional)</td>
<td>Stride of the convolution. Default: 1</td>
<td>卷积步长，默认为1。可以设为1个int型数或者一个(int, int)型的元组。</td>
</tr>
<tr>
<td>padding</td>
<td>(int or tuple, optional)</td>
<td>Zero-padding added to both sides of the input. Default: 0</td>
<td>填充操作，控制padding_mode的数目。</td>
</tr>
<tr>
<td>padding_mode</td>
<td>(string, optional)</td>
<td>‘zeros’, ‘reflect’, ‘replicate’ or ‘circular’. Default: ‘zeros’</td>
<td>padding模式，默认为Zero-padding 。</td>
</tr>
<tr>
<td>dilation</td>
<td>(int or tuple, optional)</td>
<td>Spacing between kernel elements. Default: 1</td>
<td>扩张操作：控制kernel点（卷积核点）的间距，默认值:1。</td>
</tr>
<tr>
<td>groups</td>
<td>(int, optional)</td>
<td>Number of blocked connections from input channels to output channels. Default: 1</td>
<td>group参数的作用是控制分组卷积，默认不分组，为1组。</td>
</tr>
<tr>
<td>bias</td>
<td>(bool, optional)</td>
<td>If True, adds a learnable bias to the output. Default: True</td>
<td>为真，则在输出中添加一个可学习的偏差。默认：True。</td>
</tr>
</tbody></table>
<p>举个栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">x = torch.randn(1, 3, 28, 28)</span><br><span class="line">print(x.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conv2d = torch.nn.Conv2d(in_channels=3, out_channels=12, kernel_size=3)</span><br><span class="line">res = conv2d(x)</span><br><span class="line">print(res.shape)</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-06f173e656d0a8d77e4f41250459cf3c_720w.webp" alt="img"></p>
<h3 id="nn-MaxPool2d-1"><a href="#nn-MaxPool2d-1" class="headerlink" title="nn.MaxPool2d"></a>nn.MaxPool2d</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.MaxPool2d(kernel_size, stride=<span class="literal">None</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, return_indices=<span class="literal">False</span>, ceil_mode=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>‎对由多个输入平面组成的输入信号应用 <strong>2D 最大池化</strong>，用在池化层。Pool层用于提取重要信息的操作，可以去掉部分相邻的信息，减少计算开销。MaxPool在提取数据时，保留相邻信息中的最大值，去掉其他值。</p>
<p>我们先来看一下基本参数，一共六个：</p>
<ul>
<li><strong>kernel_size</strong> ：表示做最大池化的窗口大小，可以是单个值，也可以是tuple元组</li>
<li><strong>stride</strong> ：步长，可以是单个值，也可以是tuple元</li>
<li><strong>padding</strong> ：填充，可以是单个值，也可以是tuple元组</li>
<li><strong>dilation</strong> ：控制窗口中元素步幅</li>
<li><strong>return_indices</strong>：布尔类型，返回最大值位置索引</li>
<li><strong>ceil_mode</strong>：布尔类型，为True，用向上取整的方法，计算输出形状；默认是向下取整。</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(x.shape)</span><br><span class="line">conv2d = torch.nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">12</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line">res = conv2d(x)</span><br><span class="line"><span class="built_in">print</span>(res.shape)</span><br><span class="line">pool = torch.nn.MaxPool2d(kernel_size=<span class="number">2</span>)</span><br><span class="line">res = pool(res)</span><br><span class="line"><span class="built_in">print</span>(res.shape)</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-a16aa1273abb581c6001cbd092fffb94_720w.webp" alt="img"></p>
<h3 id="nn-BatchNorm2d"><a href="#nn-BatchNorm2d" class="headerlink" title="nn.BatchNorm2d"></a>nn.BatchNorm2d</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.BatchNorm2d(num_features, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>, device=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>功能：对输入的四维数组进行<strong>批量标准化处理</strong></p>
<ul>
<li><strong>num_features</strong>：输入图像的通道数量。</li>
<li><strong>eps</strong>：稳定系数，防止分母出现0。</li>
<li><strong>momentum</strong>： 动态均值和动态方差所使用的动量，即一个用于运行过程中均值和方差的一个估计参数，默认值为0.1。</li>
<li><strong>affine</strong>：代表gamma，beta是否可学。如果设为True，代表两个参数是通过学习得到的；如果设为False，代表两个参数是固定值，默认情况下，gamma是1，beta是0。</li>
<li><strong>track_running_stats</strong>：BatchNorm2d中存储的的均值和方差是否需要更新，若为True，表示需要更新；反之不需要更新。</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = torch.nn.BatchNorm2d(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>)</span><br><span class="line">output = m(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/v2-12ac857e3d114d7416c13595948b4493_720w.webp" alt="img"></p>
<h3 id="nn-Linear"><a href="#nn-Linear" class="headerlink" title="nn.Linear"></a>nn.Linear</h3><p><em><code>nn.Linear()</code>是用于设置网络中的<strong>全连接层</strong>的</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.Linear(in_features, out_features, bias=<span class="literal">True</span>, device=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>in_features</strong> - 每个输入样本的大小</li>
<li><strong>out_features</strong> - 每个输出样本的大小</li>
<li><strong>bias</strong> - 如果设置为False，则图层不会学习附加偏差。默认值：True</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">m = nn.Linear(<span class="number">3</span>, <span class="number">12</span>)</span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">128</span>, <span class="number">3</span>)</span><br><span class="line">output = m(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output.shape)</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/80/v2-6ba2c166235232c49c45606bf3ebe602_720w.webp" alt="img"></p>
<h3 id="nn-Dropout"><a href="#nn-Dropout" class="headerlink" title="nn.Dropout"></a>nn.Dropout</h3><p>‎在训练期间，使用伯努利分布中的样本，以概率p随机<strong>将输入张量的某些元素归零</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.Dropout(p=<span class="number">0.5</span>, inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><code>nn.dropout()</code>是为了<strong>防止或减轻过拟合</strong>而使用的函数，它一般用在全连接层,<code>Dropout</code>就是在不同的训练过程中随机扔掉一部分神经元。也就是让某个神经元的激活值以一定的概率p，让其停止工作，这次训练过程中不更新权值，也不参加神经网络的计算。但是它的权重得保留下来（只是暂时不更新而已），因为下次样本输入时它可能又得工作了。</p>
<h3 id="nn-ReLU"><a href="#nn-ReLU" class="headerlink" title="nn.ReLU"></a>nn.ReLU</h3><p>为了训练深层神经网络，需要一个激活函数神经网络，它看起来和行为都像一个线性函数，但实际上是一个非线性函数，允许学习数据中的复杂关系 。该函数还必须提供更灵敏的激活和输入，避免饱和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.ReLU(inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/v2-4a5a399e3c2067fe846906f25acc9223_720w.webp" alt="img"></p>
<h3 id="nn-Sigmoid"><a href="#nn-Sigmoid" class="headerlink" title="nn.Sigmoid"></a>nn.Sigmoid</h3><p><strong>Sigmoid 激活函数</strong>，也被称为 Logistic函数神经网络，传统上是一个非常受欢迎的神经网络激活函数。函数的输入被转换成介于0.0和1.0之间的值。大于1.0的输入被转换为值1.0，同样，小于0.0的值被折断为0.0。所有可能的输入函数的形状都是从0到0.5到1.0的 s 形。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f088a29d76c36b130ece733bc152ae91_720w.webp" alt="img"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/v2-3f153fe52a5023c2707dc09820223e27_720w.webp" alt="img"></p>
<h3 id="nn-Tanh"><a href="#nn-Tanh" class="headerlink" title="nn.Tanh"></a>nn.Tanh</h3><p>Tanh的诞生比Sigmoid晚一些，sigmoid函数我们提到过有一个缺点就是输出不以0为中心，使得收敛变慢的问题。而Tanh则就是解决了这个问题。</p>
<p><img src="https://pic2.zhimg.com/80/v2-6061833a1411df11c0cad810f2657409_720w.webp" alt="img"></p>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/v2-d25ddb0d267d329eff37e6746109aa7d_720w.webp" alt="img"></p>
<h3 id="nn-LSTM"><a href="#nn-LSTM" class="headerlink" title="nn.LSTM"></a>nn.LSTM</h3><p>LSTM*一般指长短期记忆人工神经网络。 <strong>长短期记忆网络</strong>（<em>LSTM</em>，Long Short-Term Memory）是一种时间循环神经网络，是为了解决一般的RNN（循环神经网络）存在的长期依赖问题而专门设计出来的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.lstm(input_size,hidden_size,num_layers,bias,batch_first,dropout,bidirectional)</span><br></pre></td></tr></table></figure>

<p>详细介绍一下参数：</p>
<ul>
<li><strong>input_size</strong>：表示的是输入的矩阵特征数，或者说是输入的维度；</li>
<li><strong>hidden_size</strong>：隐藏层的大小（即隐藏层节点数量），输出向量的维度等于隐藏节点数；</li>
<li><strong>num_layer</strong>s：lstm 隐层的层数，默认为1；</li>
<li><strong>bias</strong>：隐层状态是否带 bias，默认为 true；</li>
<li><strong>batch_first</strong>：True 或者 False，如果是 True，则 input 为(batch, seq, input_size)，默认值为：False（seq_len, batch, input_size）</li>
<li><strong>dropout</strong>：默认值0，除最后一层，每一层的输出都进行dropout；</li>
<li><strong>bidirectional</strong>：如果设置为 True, 则表示双向 LSTM，默认为 False。</li>
</ul>
<p>nn.LSTM中输入与输出关系为output, (hn, cn) = lstm(input, (h0, c0))，输入输出格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##输入数据格式：</span></span><br><span class="line"><span class="built_in">input</span>(seq_len, batch, input_size)</span><br><span class="line">h0(num_layers * num_directions, batch, hidden_size)</span><br><span class="line">c0(num_layers * num_directions, batch, hidden_size)</span><br><span class="line"> </span><br><span class="line"><span class="comment">##输出数据格式：</span></span><br><span class="line">output(seq_len, batch, hidden_size * num_directions)</span><br><span class="line">hn(num_layers * num_directions, batch, hidden_size)</span><br><span class="line">cn(num_layers * num_directions, batch, hidden_size)</span><br></pre></td></tr></table></figure>

<p>​    **input (seq_len, batch, input_size)**，seq_len表示每个batch输入多少数据，batch表示把数据分成了batch批,input_size为样本输入维度。</p>
<p>​    **output(seq_len, batch, hidden_size * num_directions)**，output是一个三维张量，第一维表示序列长度，第二维表示数据批次的多少batch，即数据分为几批送进来，第三维hidden_size隐藏层大小，双向则二倍，单向则等价于隐藏层大小。</p>
<p>​    <strong>hn</strong>是一个三维张量，第一维是num_layers*num_directions，num_layers是我们定义的神经网络的层数，num_directions表示是否为双向LSTM；第二维表示一批的样本数量；第三维表示隐藏层的大小。</p>
<p>​    c_n与h_n一致。</p>
<h3 id="nn-RNN"><a href="#nn-RNN" class="headerlink" title="nn.RNN"></a>nn.RNN</h3><p><em>RNN</em>一般指循环神经网络。 循环神经网络（Recurrent Neural Network,<em>RNN</em>）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络（recursive neural network）。</p>
<p>用法同<code>nn.LSTM</code></p>
<h3 id="nn-GRU"><a href="#nn-GRU" class="headerlink" title="nn.GRU"></a>nn.GRU</h3><p>门控循环神经网络（gated recurrent neural network）是为了更好地捕捉时序数据中间隔较大的依赖关系,门控循环单元（gated recurrent unit, GRU)是一种常用的门控循环神经网络。</p>
<p>用法同<code>nn.LSTM</code></p>
<h3 id="nn-Sequential"><a href="#nn-Sequential" class="headerlink" title="nn.Sequential"></a>nn.Sequential</h3><p>一个序列容器，用于搭建神经网络的模块被按照被传入构造器的顺序添加到<strong>nn.Sequential()容器</strong>中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">20</span>, <span class="number">64</span>, <span class="number">5</span>),</span><br><span class="line">    nn.ReLU()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">x = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">y = model(x)</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br></pre></td></tr></table></figure>



<p>转载自 <a href="https://zhuanlan.zhihu.com/p/499410228">named_parameters(), named_children, named_modules()方法</a></p>
<h3 id="named-parameters"><a href="#named-parameters" class="headerlink" title="named_parameters()"></a>named_parameters()</h3><p>可以对一个<code>nn.Module</code>中所有注册的参数进行迭代:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinear</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_features, out_features</span>):</span></span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    self.weight = nn.Parameter(torch.randn(in_features, out_features))</span><br><span class="line">    self.bias = nn.Parameter(torch.randn(out_features))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">input</span> @ self.weight) + self.bias</span><br></pre></td></tr></table></figure>



<p>可以通过调用<code>named_parameters()</code>方法得到我们定义的<code>nn.Module</code>, 即<code>MyLinear</code>中所有的可学习的参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_linear = MyLinear(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> my_linear.named_parameters():</span><br><span class="line">    <span class="built_in">print</span>(param)</span><br></pre></td></tr></table></figure>

<p>可以得到以下输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;weight&#x27;</span>, Parameter containing:</span><br><span class="line">tensor([[ <span class="number">0.9009</span>,  <span class="number">0.6984</span>,  <span class="number">3.0670</span>,  <span class="number">0.9113</span>],</span><br><span class="line">        [-<span class="number">0.2515</span>, -<span class="number">0.1617</span>,  <span class="number">0.2517</span>,  <span class="number">0.0977</span>],</span><br><span class="line">        [-<span class="number">1.0986</span>, -<span class="number">0.3517</span>, -<span class="number">0.4920</span>, -<span class="number">0.4112</span>]], requires_grad=<span class="literal">True</span>))</span><br><span class="line">(<span class="string">&#x27;bias&#x27;</span>, Parameter containing:</span><br><span class="line">tensor([-<span class="number">0.2491</span>, -<span class="number">0.1508</span>,  <span class="number">0.8393</span>, -<span class="number">1.3849</span>], requires_grad=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>



<p>我们可以输出更多信息, 来更仔细地查看一下<code>param</code>的内容:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_linear = MyLinear(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> my_linear.named_parameters():</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(param))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(param[<span class="number">0</span>]), param[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(param[<span class="number">1</span>]), param[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>得到了以下输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt; <span class="title">weight</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">torch</span>.<span class="title">nn</span>.<span class="title">parameter</span>.<span class="title">Parameter</span>&#x27;&gt; <span class="title">Parameter</span> <span class="title">containing</span>:</span></span><br><span class="line">tensor([[-<span class="number">0.3835</span>,  <span class="number">1.9484</span>,  <span class="number">0.6865</span>, -<span class="number">1.0978</span>],</span><br><span class="line">        [-<span class="number">1.7985</span>,  <span class="number">1.0263</span>, -<span class="number">0.7779</span>, -<span class="number">0.4302</span>],</span><br><span class="line">        [-<span class="number">0.2007</span>,  <span class="number">0.0540</span>,  <span class="number">0.2876</span>,  <span class="number">0.0776</span>]], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>可以发现<code>param</code>是由2个元素组成的<code>tuple</code>, 其中第一个元素是<code>str</code>类型的，表示参数的名字, 第二个元素是<code>torch.nn.parameter.Parameter</code>类型的，表示包含的参数信息</p>
<h3 id="named-children"><a href="#named-children" class="headerlink" title="named_children()"></a>named_children()</h3><p>​    可以通过调用<code>nn.Module</code>的<code>named_children()</code>方法来查看这个<code>nn.Module</code>的<strong>直接子级</strong>的模块:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    self.linear_0 = MyLinear(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">    self.linear_1 = MyLinear(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    x = self.linear_0(x)</span><br><span class="line">    x = F.relu(x)</span><br><span class="line">    x = self.linear_1(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<p>​    这里的<code>Net</code>是由我们定义的<code>MyLinear</code>层组成的, 其中包括了两个children，分别为<code>linear_0</code>和<code>linear_1</code>, 我们使用<code>named_children()</code>可以查看<code>Net</code>所包含的直接子级模块:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = Net()</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> net.named_children():</span><br><span class="line">    <span class="built_in">print</span>(child)</span><br></pre></td></tr></table></figure>

<p>此时可以得到以下输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;linear_0&#x27;</span>, MyLinear())</span><br><span class="line">(<span class="string">&#x27;linear_1&#x27;</span>, MyLinear())</span><br></pre></td></tr></table></figure>

<p>如果我们调用了<code>children()</code>方法，与<code>named_children()</code>的区别就是，不会输出名称:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> net.children():</span><br><span class="line">    <span class="built_in">print</span>(child)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyLinear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyLinear()</span><br></pre></td></tr></table></figure>





<h3 id="named-modules"><a href="#named-modules" class="headerlink" title="named_modules()"></a>named_modules()</h3><p>​    在上一个section中我们介绍了<code>named_children()</code>，但是这个方法只能遍历第一级的<code>nn.Module</code>，如果<code>nn.Module()</code>中的直接子级也是一个<code>nn.Module</code>，你需要连着子级一起遍历（<strong>going deeper</strong>）, 则可以调用<code>named_modules()</code>方法，这个方法会循环遍历<code>nn.Module</code>以及其<code>child nn.Modules</code> ,其实与<code>named_children()</code>的主要区别就是遍历的程度是否更deeper:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    self.linear_0 = MyLinear(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">    self.linear_1 = MyLinear(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    x = self.linear_0(x)</span><br><span class="line">    x = F.relu(x)</span><br><span class="line">    x = self.linear_1(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> net.named_modules():</span><br><span class="line">    <span class="built_in">print</span>(child)</span><br></pre></td></tr></table></figure>

<p>输出的结果如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;&#x27;</span>, Net(</span><br><span class="line">  (linear_0): MyLinear()</span><br><span class="line">  (linear_1): MyLinear()</span><br><span class="line">))</span><br><span class="line">(<span class="string">&#x27;linear_0&#x27;</span>, MyLinear())</span><br><span class="line">(<span class="string">&#x27;linear_1&#x27;</span>, MyLinear())</span><br></pre></td></tr></table></figure>



<p>​    这里可以看到输出了一个<code>Net</code>，是因为<code>named_modules()</code>方法会迭代地找到每个<code>nn.Module</code>，包括自身，我们可以循环打印一下<code>modules()</code>方法的输出的<code>__class__</code>，<code>modules</code>方法与<code>named_modules()</code>的区别就在于是否输出名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = Net()</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> net.modules():</span><br><span class="line">    <span class="built_in">print</span>(child.__class__)</span><br></pre></td></tr></table></figure>

<p>得到以下输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Net</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">MyLinear</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">MyLinear</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看出<code>modules()</code>方法和<code>named_modules()</code>方法会迭代自身</p>
<h3 id="train-and-eval"><a href="#train-and-eval" class="headerlink" title="train() and eval()"></a>train() and eval()</h3><p><a href="https://blog.csdn.net/qq_46284579/article/details/120439049">Pytorch 中net.train（） 和 net.eval（）的作用和如何使用？</a></p>
<p>​    net.train()和net.eval()到底在什么时候使用？如果一个模型有<strong>Dropout</strong>与<strong>BatchNormalization</strong>，那么它在训练时要以一定概率进行Dropout或者更新BatchNormalization参数，而在测试时不在需要Dropout或更新BatchNormalization参数。此时，要用net.train()和net.eval()进行区分。在没有涉及到BN与Dropout的模型，这两个函数没什么用。</p>
<h3 id="save-and-load"><a href="#save-and-load" class="headerlink" title="save and load"></a>save and load</h3><p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1669431670670.png" alt="1669431670670"></p>
<h3 id="定义自己的Module"><a href="#定义自己的Module" class="headerlink" title="定义自己的Module"></a>定义自己的Module</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinear</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inp, outp</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyLinear, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># requires_grad = True</span></span><br><span class="line">        self.w = nn.Parameter(torch.randn(outp, inp))</span><br><span class="line">        self.b = nn.Parameter(torch.randn(outp))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = x @ self.w.t() + self.b</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flatten</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Flatten, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span>.view(<span class="built_in">input</span>.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(TestNet, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.net = nn.Sequential(nn.Conv2d(<span class="number">1</span>, <span class="number">16</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">                                 nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">                                 Flatten(),</span><br><span class="line">                                 nn.Linear(<span class="number">1</span> * <span class="number">14</span> * <span class="number">14</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.net(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(BasicNet, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.net = nn.Linear(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.net(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.net = nn.Sequential(BasicNet(),</span><br><span class="line">                                 nn.ReLU(),</span><br><span class="line">                                 nn.Linear(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.net(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    device = torch.device(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">    net = Net()</span><br><span class="line">    net.to(device)</span><br><span class="line"></span><br><span class="line">    net.train()</span><br><span class="line"></span><br><span class="line">    net.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># net.load_state_dict(torch.load(&#x27;ckpt.mdl&#x27;))</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># torch.save(net.state_dict(), &#x27;ckpt.mdl&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, t <span class="keyword">in</span> net.named_parameters():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parameters:&#x27;</span>, name, t.shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, m <span class="keyword">in</span> net.named_children():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;children:&#x27;</span>, name, m)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, m <span class="keyword">in</span> net.named_modules():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;modules:&#x27;</span>, name, m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>





<h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><p><strong>Data argumentation</strong></p>
<ul>
<li>Flip 翻转</li>
<li>Rotate 旋转</li>
<li>Random Move and Crop 移动，裁剪</li>
<li>Noise 加噪声</li>
<li>GAN</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                   transform=transforms.Compose([</span><br><span class="line">                       transforms.RandomHorizontalFlip(),</span><br><span class="line">                       transforms.RandomVerticalFlip(),</span><br><span class="line">                       transforms.RandomRotation(<span class="number">15</span>),</span><br><span class="line">                       transforms.RandomRotation([<span class="number">90</span>, <span class="number">180</span>, <span class="number">270</span>]),</span><br><span class="line">                       transforms.Resize([<span class="number">32</span>, <span class="number">32</span>]),</span><br><span class="line">                       transforms.RandomCrop([<span class="number">28</span>, <span class="number">28</span>]),</span><br><span class="line">                       transforms.ToTensor(),</span><br><span class="line">                       <span class="comment"># transforms.Normalize((0.1307,), (0.3081,))</span></span><br><span class="line">                   ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pytorch</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实验</title>
    <url>/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="实验一-Linear-Regression"><a href="#实验一-Linear-Regression" class="headerlink" title="实验一 Linear Regression"></a>实验一 Linear Regression</h1><h2 id="采用-sklearn-设计线性回归模型"><a href="#采用-sklearn-设计线性回归模型" class="headerlink" title="采用 sklearn 设计线性回归模型"></a>采用 sklearn 设计线性回归模型</h2><div class="note info modern"><p>导入包</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_diabetes</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br></pre></td></tr></table></figure>



<div class="note info modern"><p>查看数据集前三个样本</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看数据集前三个样本的数据</span></span><br><span class="line">data = load_diabetes().data</span><br><span class="line">labels = load_diabetes().target</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data&#x27;</span>, data[:<span class="number">3</span>, :], <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;target&#x27;</span>, labels[:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data [[ <span class="number">0.03807591</span>  <span class="number">0.05068012</span>  <span class="number">0.06169621</span>  <span class="number">0.02187239</span> -<span class="number">0.0442235</span>  -<span class="number">0.03482076</span></span><br><span class="line">  -<span class="number">0.04340085</span> -<span class="number">0.00259226</span>  <span class="number">0.01990749</span> -<span class="number">0.01764613</span>]</span><br><span class="line"> [-<span class="number">0.00188202</span> -<span class="number">0.04464164</span> -<span class="number">0.05147406</span> -<span class="number">0.02632753</span> -<span class="number">0.00844872</span> -<span class="number">0.01916334</span></span><br><span class="line">   <span class="number">0.07441156</span> -<span class="number">0.03949338</span> -<span class="number">0.06833155</span> -<span class="number">0.09220405</span>]</span><br><span class="line"> [ <span class="number">0.08529891</span>  <span class="number">0.05068012</span>  <span class="number">0.04445121</span> -<span class="number">0.00567042</span> -<span class="number">0.04559945</span> -<span class="number">0.03419447</span></span><br><span class="line">  -<span class="number">0.03235593</span> -<span class="number">0.00259226</span>  <span class="number">0.00286131</span> -<span class="number">0.02593034</span>]] </span><br><span class="line"> target [<span class="number">151.</span>  <span class="number">75.</span> <span class="number">141.</span>]</span><br></pre></td></tr></table></figure>



<div class="note info modern"><p>按1:9分割数据集，查看分割结果</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按1:9分割数据集，查看分割结果</span></span><br><span class="line">offset = <span class="built_in">int</span>(data.shape[<span class="number">0</span>] * <span class="number">0.9</span>)</span><br><span class="line">X_train, y_train = data[:offset], labels[:offset].reshape((-<span class="number">1</span>, <span class="number">1</span>))    <span class="comment"># reshape(-1,1)转化为1列</span></span><br><span class="line">X_test, y_test = data[offset:], labels[offset:].reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X_train&#x27;</span>, X_train.shape, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;X_test&#x27;</span>, X_test.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y_train&#x27;</span>, y_train.shape, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;y_test&#x27;</span>, y_test.shape)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> target [<span class="number">151.</span>  <span class="number">75.</span> <span class="number">141.</span>]</span><br><span class="line">X_train (<span class="number">397</span>, <span class="number">10</span>) </span><br><span class="line"> X_test (<span class="number">45</span>, <span class="number">10</span>)</span><br><span class="line">y_train (<span class="number">397</span>, <span class="number">1</span>) </span><br><span class="line"> y_test (<span class="number">45</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<div class="note info modern"><p>通过调用 **linear_model.LinearRegression()**方法搭建模型，调用 **fit()**方法训练模型，展示模型各项参数，并计算测试集均方误差</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过调用 linear_model.LinearRegression()方法搭建模型，调用 fit()方法训练模型，展示模型各项参数并计算测试集均方误差</span></span><br><span class="line">model = linear_model.LinearRegression(fit_intercept=<span class="literal">True</span>, copy_X=<span class="literal">True</span>, n_jobs=<span class="number">1</span>)</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"><span class="comment"># fit_intercept: 是否对训练数据进行中心化</span></span><br><span class="line"><span class="comment"># normalize: 是否对数据进行标准化处理</span></span><br><span class="line"><span class="comment"># copy_X: 是否对X复制，如果选择false，则直接对原数据进行覆盖</span></span><br><span class="line"><span class="comment"># n_jobs: 计算时设置的任务个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;coefficients:&#x27;</span>, model.coef_, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;intercept:&#x27;</span>, model.intercept_, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;score:&#x27;</span>, model.score(X_test,y_test))</span><br><span class="line"><span class="comment"># conefficients:模型系数/权重  intercept:截距、偏置bias  score:评估指数，越接近1越好</span></span><br><span class="line"></span><br><span class="line">y_pred = model.predict(X_train)</span><br><span class="line">y_pred_t = model.predict(X_test)</span><br><span class="line">mse = mean_squared_error(y_pred_t, y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;MSE&#x27;</span>, mse)</span><br><span class="line"><span class="comment"># MSE: 均方误差</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coefficients: [[-<span class="number">4.32267019e-01</span> -<span class="number">2.37522416e+02</span>  <span class="number">5.20210764e+02</span>  <span class="number">3.04171914e+02</span></span><br><span class="line">  -<span class="number">7.51563208e+02</span>  <span class="number">4.29790050e+02</span>  <span class="number">9.94674947e+01</span>  <span class="number">2.14872395e+02</span></span><br><span class="line">   <span class="number">6.89370808e+02</span>  <span class="number">9.73256066e+01</span>]] </span><br><span class="line"> intercept: [<span class="number">152.40057362</span>] </span><br><span class="line"> score: <span class="number">0.6872989515490583</span></span><br></pre></td></tr></table></figure>



<div class="note info modern"><p>画出拟合曲线</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画出拟合曲线</span></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(X_train.shape[<span class="number">0</span>]), y_train, color=<span class="string">&#x27;blue&#x27;</span>) <span class="comment"># 绘图</span></span><br><span class="line">plt.plot(y_pred, color=<span class="string">&#x27;darkorange&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;sklearn train&#x27;</span>)</span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(X_test.shape[<span class="number">0</span>]), y_test, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.plot(y_pred_t, color=<span class="string">&#x27;darkorange&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;sklearn test&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669778724648.png" alt="训练集拟合曲线"></p>
<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669778748758.png" alt="测试集拟合曲线"></p>
<h2 id="复现线性回归核心代码"><a href="#复现线性回归核心代码" class="headerlink" title="复现线性回归核心代码"></a>复现线性回归核心代码</h2><div class="note info modern"><p>导入包</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_diabetes</span><br></pre></td></tr></table></figure>



<div class="note info modern"><p>定义模型LinearRegression类，并在其中定义模型参数初始化函数、损失函数、训练函数和预测函数</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegression</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_params</span>(<span class="params">self, dims</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化模型参数为0</span></span><br><span class="line"><span class="string">        :param dims: 数据的维度（属性个数）</span></span><br><span class="line"><span class="string">        :return: w,b</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        w = np.zeros((dims, <span class="number">1</span>))  <span class="comment"># dims行1列的矩阵，dims为特征个数</span></span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">linear_loss</span>(<span class="params">self, X, y, w, b</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        定义损失函数</span></span><br><span class="line"><span class="string">        :param X: 数据</span></span><br><span class="line"><span class="string">        :param y: 标签</span></span><br><span class="line"><span class="string">        :param w: 权重weight</span></span><br><span class="line"><span class="string">        :param b: 偏置bias</span></span><br><span class="line"><span class="string">        :return: y_hat,loss,dw,wb:预测值，损失值梯度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num_object = X.shape[<span class="number">0</span>]</span><br><span class="line">        num_feature = X.shape[<span class="number">1</span>]</span><br><span class="line">        y_hat = np.dot(X, w) + b  <span class="comment"># X是n*m维，w是m*1维，结果为n*1为</span></span><br><span class="line">        loss = np.<span class="built_in">sum</span>((y_hat - y) ** <span class="number">2</span>) / num_object  <span class="comment"># 损失：均方误差MSE</span></span><br><span class="line">        dw = np.dot(X.T, (y_hat - y)) / num_object  <span class="comment"># 求W梯度向量，X.T是m*n维，y_hat-y是n*1维，结果是m*1维（和W维度一致）</span></span><br><span class="line">        db = np.<span class="built_in">sum</span>(y_hat - y) / num_object</span><br><span class="line">        <span class="keyword">return</span> y_hat, loss, dw, db</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">linear_train</span>(<span class="params">self, X, y, learning_rate, epoch</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        定义模型训练函数</span></span><br><span class="line"><span class="string">        :param X: 数据</span></span><br><span class="line"><span class="string">        :param y: 标签</span></span><br><span class="line"><span class="string">        :param learning_rate:学习率</span></span><br><span class="line"><span class="string">        :param epoch: 训练次数</span></span><br><span class="line"><span class="string">        :return: loss, params, grads：最终损失，参数，梯度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        loss_his = []</span><br><span class="line">        w, b = self.initialize_params(X.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, epoch):</span><br><span class="line">            <span class="comment"># 计算训练集当前输出、损失函数值、梯度</span></span><br><span class="line">            y_hat, loss, dw, db = self.linear_loss(X, y, w, b)</span><br><span class="line">            loss_his.append(loss)</span><br><span class="line">            <span class="comment"># 更新参数</span></span><br><span class="line">            w += -learning_rate * dw</span><br><span class="line">            b += -learning_rate * db</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">10000</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;epoch %d loss %f&#x27;</span> % (i, loss))</span><br><span class="line">            params = &#123;<span class="string">&#x27;w&#x27;</span>: w, <span class="string">&#x27;b&#x27;</span>: b&#125;</span><br><span class="line">            grads = &#123;<span class="string">&#x27;dw&#x27;</span>: dw, <span class="string">&#x27;db&#x27;</span>: db&#125;</span><br><span class="line">        np.savetxt(<span class="string">&#x27;train_loss.txt&#x27;</span>, loss_his)  <span class="comment"># 保存损失函数值</span></span><br><span class="line">        <span class="keyword">return</span> loss, params, grads</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X, params</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        定义模型预测函数</span></span><br><span class="line"><span class="string">        :param X: 数据</span></span><br><span class="line"><span class="string">        :param params: 训练得到的参数w和b</span></span><br><span class="line"><span class="string">        :return: 预测值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        w = params[<span class="string">&#x27;w&#x27;</span>]</span><br><span class="line">        b = params[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">        y_pred = np.dot(X, w) + b</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure>



<div class="note info modern"><p>训练模型并展示损失曲线</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 训练模型并展示损失曲线</span></span><br><span class="line">    lr = LinearRegression()</span><br><span class="line">    X = load_diabetes().data</span><br><span class="line">    labels = load_diabetes().target</span><br><span class="line">    offset = <span class="built_in">int</span>(X.shape[<span class="number">0</span>] * <span class="number">0.9</span>)</span><br><span class="line">    X_train, y_train = X[:offset], labels[:offset].reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    X_test, y_test = X[offset:], labels[offset:].reshape((-<span class="number">1</span>, <span class="number">1</span>))  <span class="comment"># reshape((-1, 1)将y转换为1列</span></span><br><span class="line">    loss, params, grads = lr.linear_train(X_train, y_train, <span class="number">0.4</span>, <span class="number">100000</span>)  <span class="comment"># 训练模型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 观察损失值随训练次数的变化</span></span><br><span class="line">    train_loss = np.loadtxt(<span class="string">&#x27;train_loss.txt&#x27;</span>)</span><br><span class="line">    plt.plot(train_loss)</span><br><span class="line">    plt.legend([<span class="string">&#x27;train loss&#x27;</span>])</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">    plt.savefig(<span class="string">&#x27;train_loss.jpg&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669779132252.png" alt="损失曲线"></p>
<div class="note info modern"><p>测试模型并展示拟合曲线</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试模型并展示拟合曲线</span></span><br><span class="line">y_pred = lr.predict(X_test, params)</span><br><span class="line">y_pred_train = lr.predict(X_train, params)</span><br><span class="line">valid_score = <span class="number">1</span> - (np.<span class="built_in">sum</span>((y_test - y_pred) ** <span class="number">2</span>) / np.<span class="built_in">sum</span>((np.mean(y_test) - y_test) ** <span class="number">2</span>))  <span class="comment"># 计算测试集score</span></span><br><span class="line">mse = np.<span class="built_in">sum</span>(((y_pred - y_test) ** <span class="number">2</span>)) / <span class="built_in">len</span>(X_test)  <span class="comment"># MSE</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test score is&#x27;</span>, valid_score, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;mse&#x27;</span>, mse)</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(X_train.shape[<span class="number">0</span>]), y_train, color=<span class="string">&#x27;blue&#x27;</span>)  <span class="comment"># 绘训练集拟合图</span></span><br><span class="line">plt.plot(y_pred_train, color=<span class="string">&#x27;darkorange&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;detail train&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;detail_train.jpg&#x27;</span>)</span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(X_test.shape[<span class="number">0</span>]), y_test, color=<span class="string">&#x27;blue&#x27;</span>)  <span class="comment"># 绘测试集拟合图</span></span><br><span class="line">plt.plot(y_pred, color=<span class="string">&#x27;darkorange&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;detail test&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;detail_test.jpg&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669779286640.png" alt="训练集拟合曲线"></p>
<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669779298022.png" alt="测试集拟合曲线"></p>
<div class="note info modern"><p>调整学习率优化模型</p>
</div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 调整学习率优化模型</span><br><span class="line">lr.linear_train(X_train, y_train, 0.4, 100000)</span><br><span class="line">mse_his = []</span><br><span class="line">rates = [i / 100 for i in range(1, 41)]</span><br><span class="line">for learning_rate in rates:</span><br><span class="line">    loss, params, grads = lr.linear_train(X_train, y_train, learning_rate, 200000)</span><br><span class="line">    y_pred = lr.predict(X_test, params)</span><br><span class="line">    mse = np.sum(((y_pred - y_test) ** 2)) / len(X_test)  # MSE</span><br><span class="line">    mse_his.append(mse)</span><br><span class="line">print(mse_his)</span><br><span class="line">plt.plot(rates, mse_his, color=&#x27;blue&#x27;)</span><br><span class="line">plt.xlabel(&#x27;learning rate&#x27;)</span><br><span class="line">plt.ylabel(&#x27;mse&#x27;)</span><br><span class="line">plt.savefig(&#x27;learning_rate.jpg&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669790769334.png" alt="1669790769334"></p>
<div class="note info modern"><p>调整模型训练次数优化模型</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调整模型训练次数优化模型</span></span><br><span class="line">mse_his = []</span><br><span class="line">epochs = [i * <span class="number">10000</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">41</span>)]</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> epochs:</span><br><span class="line">    loss, params, grads = lr.linear_train(X_train, y_train, <span class="number">0.1</span>, epoch)</span><br><span class="line">    y_pred = lr.predict(X_test, params)</span><br><span class="line">    mse = np.<span class="built_in">sum</span>(((y_pred - y_test) ** <span class="number">2</span>)) / <span class="built_in">len</span>(X_test)  <span class="comment"># MSE</span></span><br><span class="line">    mse_his.append(mse)</span><br><span class="line"><span class="built_in">print</span>(mse_his)</span><br><span class="line">plt.plot(epochs, mse_his, color=<span class="string">&#x27;darkorange&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;mse&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;epoch.jpg&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669791789361.png" alt="1669791789361"></p>
<h1 id="实验二-Logistic-Regression"><a href="#实验二-Logistic-Regression" class="headerlink" title="实验二 Logistic Regression"></a>实验二 Logistic Regression</h1><h2 id="采用-sklearn-设计逻辑回归模型"><a href="#采用-sklearn-设计逻辑回归模型" class="headerlink" title="采用 sklearn 设计逻辑回归模型"></a>采用 sklearn 设计逻辑回归模型</h2><div class="note success modern"><p>导入包</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>显示数据集前 3 个样本</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = load_breast_cancer().data</span><br><span class="line">labels = load_breast_cancer().target</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data&#x27;</span>, X[:<span class="number">3</span>, :], <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;target&#x27;</span>, labels[:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data [[<span class="number">1.799e+01</span> <span class="number">1.038e+01</span> <span class="number">1.228e+02</span> <span class="number">1.001e+03</span> <span class="number">1.184e-01</span> <span class="number">2.776e-01</span> <span class="number">3.001e-01</span></span><br><span class="line">  <span class="number">1.471e-01</span> <span class="number">2.419e-01</span> <span class="number">7.871e-02</span> <span class="number">1.095e+00</span> <span class="number">9.053e-01</span> <span class="number">8.589e+00</span> <span class="number">1.534e+02</span></span><br><span class="line">  <span class="number">6.399e-03</span> <span class="number">4.904e-02</span> <span class="number">5.373e-02</span> <span class="number">1.587e-02</span> <span class="number">3.003e-02</span> <span class="number">6.193e-03</span> <span class="number">2.538e+01</span></span><br><span class="line">  <span class="number">1.733e+01</span> <span class="number">1.846e+02</span> <span class="number">2.019e+03</span> <span class="number">1.622e-01</span> <span class="number">6.656e-01</span> <span class="number">7.119e-01</span> <span class="number">2.654e-01</span></span><br><span class="line">  <span class="number">4.601e-01</span> <span class="number">1.189e-01</span>]</span><br><span class="line"> [<span class="number">2.057e+01</span> <span class="number">1.777e+01</span> <span class="number">1.329e+02</span> <span class="number">1.326e+03</span> <span class="number">8.474e-02</span> <span class="number">7.864e-02</span> <span class="number">8.690e-02</span></span><br><span class="line">  <span class="number">7.017e-02</span> <span class="number">1.812e-01</span> <span class="number">5.667e-02</span> <span class="number">5.435e-01</span> <span class="number">7.339e-01</span> <span class="number">3.398e+00</span> <span class="number">7.408e+01</span></span><br><span class="line">  <span class="number">5.225e-03</span> <span class="number">1.308e-02</span> <span class="number">1.860e-02</span> <span class="number">1.340e-02</span> <span class="number">1.389e-02</span> <span class="number">3.532e-03</span> <span class="number">2.499e+01</span></span><br><span class="line">  <span class="number">2.341e+01</span> <span class="number">1.588e+02</span> <span class="number">1.956e+03</span> <span class="number">1.238e-01</span> <span class="number">1.866e-01</span> <span class="number">2.416e-01</span> <span class="number">1.860e-01</span></span><br><span class="line">  <span class="number">2.750e-01</span> <span class="number">8.902e-02</span>]</span><br><span class="line"> [<span class="number">1.969e+01</span> <span class="number">2.125e+01</span> <span class="number">1.300e+02</span> <span class="number">1.203e+03</span> <span class="number">1.096e-01</span> <span class="number">1.599e-01</span> <span class="number">1.974e-01</span></span><br><span class="line">  <span class="number">1.279e-01</span> <span class="number">2.069e-01</span> <span class="number">5.999e-02</span> <span class="number">7.456e-01</span> <span class="number">7.869e-01</span> <span class="number">4.585e+00</span> <span class="number">9.403e+01</span></span><br><span class="line">  <span class="number">6.150e-03</span> <span class="number">4.006e-02</span> <span class="number">3.832e-02</span> <span class="number">2.058e-02</span> <span class="number">2.250e-02</span> <span class="number">4.571e-03</span> <span class="number">2.357e+01</span></span><br><span class="line">  <span class="number">2.553e+01</span> <span class="number">1.525e+02</span> <span class="number">1.709e+03</span> <span class="number">1.444e-01</span> <span class="number">4.245e-01</span> <span class="number">4.504e-01</span> <span class="number">2.430e-01</span></span><br><span class="line">  <span class="number">3.613e-01</span> <span class="number">8.758e-02</span>]] </span><br><span class="line"> target [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>调整数据集分割比例并查看分割结果，对数据进行标准化</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分割数据，标准化数据集</span></span><br><span class="line">offset = <span class="built_in">int</span>(X.shape[<span class="number">0</span>] * <span class="number">0.9</span>)</span><br><span class="line">X_train, y_train = X[:offset], labels[:offset]</span><br><span class="line">X_test, y_test = X[offset:], labels[offset:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X_train&#x27;</span>, X_train.shape, <span class="string">&#x27;y_train&#x27;</span>, y_train.shape, <span class="string">&#x27;X_test&#x27;</span>, X_test.shape, <span class="string">&#x27;y_test&#x27;</span>, y_test.shape)</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">sc.fit(X_train)</span><br><span class="line">X_train_std = sc.transform(X_train)  <span class="comment"># 数据标准化</span></span><br><span class="line">X_test_std = sc.transform(X_test)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train (<span class="number">512</span>, <span class="number">30</span>) y_train (<span class="number">512</span>,) X_test (<span class="number">57</span>, <span class="number">30</span>) y_test (<span class="number">57</span>,)</span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>型训练并评估结果</p>
</div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model = linear_model.LogisticRegression(penalty=&#x27;l2&#x27;, fit_intercept=True, \</span><br><span class="line">                                        intercept_scaling=1, solver=&#x27;liblinear&#x27;, \</span><br><span class="line">                                        max_iter=100, multi_class=&#x27;ovr&#x27;)</span><br><span class="line">model.fit(X_train_std, y_train)</span><br><span class="line">print(&#x27;coefficients:&#x27;, model.coef_, &#x27;\n&#x27;, &#x27;intercept:&#x27;, model.intercept_)  # coefficients系数, intercept截距</span><br><span class="line">acc1 = model.score(X_train_std, y_train)</span><br><span class="line">acc2 = model.score(X_test_std, y_test)</span><br><span class="line">W = model.coef_.reshape(-1)</span><br><span class="line">b = model.intercept_</span><br><span class="line">print(&#x27;train accuracy is:&#x27;, acc1)</span><br><span class="line">print(&#x27;test accuracy is:&#x27;, acc2)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coefficients: [[-<span class="number">0.3810934</span>  -<span class="number">0.65420282</span> -<span class="number">0.37976599</span> -<span class="number">0.45743451</span> -<span class="number">0.12937427</span>  <span class="number">0.52064464</span></span><br><span class="line">  -<span class="number">0.67219211</span> -<span class="number">0.72649327</span>  <span class="number">0.01905227</span>  <span class="number">0.26711084</span> -<span class="number">1.20265135</span>  <span class="number">0.36255618</span></span><br><span class="line">  -<span class="number">0.73109672</span> -<span class="number">0.9115291</span>  -<span class="number">0.19108819</span>  <span class="number">0.68556724</span>  <span class="number">0.2042336</span>  -<span class="number">0.44950466</span></span><br><span class="line">   <span class="number">0.26713624</span>  <span class="number">0.48778509</span> -<span class="number">1.00712835</span> -<span class="number">1.16788512</span> -<span class="number">0.86133031</span> -<span class="number">0.95809183</span></span><br><span class="line">  -<span class="number">0.8148613</span>   <span class="number">0.08182499</span> -<span class="number">0.72371698</span> -<span class="number">0.89605559</span> -<span class="number">0.89464349</span> -<span class="number">0.49145749</span>]] </span><br><span class="line"> intercept: [<span class="number">0.01458037</span>]</span><br><span class="line">train accuracy <span class="keyword">is</span>: <span class="number">0.98828125</span></span><br><span class="line">test accuracy <span class="keyword">is</span>: <span class="number">0.9824561403508771</span></span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>定义绘图函数并画出分类图像</p>
</div> 

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义绘图函数，并画出分类图像</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_LogisticRegression</span>(<span class="params">data, y_data, title</span>):</span>	<span class="comment"># 预测结果绘制函数</span></span><br><span class="line">    n = data.shape[<span class="number">0</span>]</span><br><span class="line">    x1cord1 = []</span><br><span class="line">    x2cord1 = []</span><br><span class="line">    x1cord0 = []</span><br><span class="line">    x2cord0 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> y_data[i] == <span class="number">1</span>:</span><br><span class="line">            x1cord1.append(data[i][<span class="number">0</span>])</span><br><span class="line">            x2cord1.append(data[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x1cord0.append(data[i][<span class="number">0</span>])</span><br><span class="line">            x2cord0.append(data[i][<span class="number">1</span>])</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(x1cord1, x2cord1, s=<span class="number">32</span>, c=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    ax.scatter(x1cord0, x2cord0, s=<span class="number">32</span>, c=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">    x = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.5</span>)</span><br><span class="line">    y = (-b - W[<span class="number">0</span>] * x) / W[<span class="number">1</span>]  <span class="comment"># 决策边界</span></span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;X1&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;X2&#x27;</span>)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plot_LogisticRegression(X_train_std, y_train, <span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">plot_LogisticRegression(X_test_std, y_test, <span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669875284508.png" alt="训练集分类结果"></p>
<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669875333992.png" alt="测试集分类结果"></p>
<h2 id="复现逻辑回归核心代码"><a href="#复现逻辑回归核心代码" class="headerlink" title="复现逻辑回归核心代码"></a>复现逻辑回归核心代码</h2><div class="note success modern"><p>导入包</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>构建 LogisticRegression 类，并在其中定义 sigmoid 函数、模型参数初始化函数 、代价函数、训练函数</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegression</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmod</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;sigmoid函数&quot;&quot;&quot;</span></span><br><span class="line">        z = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_params</span>(<span class="params">self, dims</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化模型参数为0&quot;&quot;&quot;</span></span><br><span class="line">        W = np.zeros((dims, <span class="number">1</span>))</span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> W, b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cost</span>(<span class="params">self, X, y, W, b</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;定义代价函数&quot;&quot;&quot;</span></span><br><span class="line">        num_train = X.shape[<span class="number">0</span>]</span><br><span class="line">        num_features = X.shape[<span class="number">1</span>]</span><br><span class="line">        f = self.sigmod(np.dot(X, W) + b)  <span class="comment"># num_train个预测值</span></span><br><span class="line">        cost = -<span class="number">1</span> / num_train * np.<span class="built_in">sum</span>(y * np.log(f) + (<span class="number">1</span> - y) * np.log(<span class="number">1</span> - f))</span><br><span class="line">        dW = np.dot(X.T, (f - y)) / num_train  <span class="comment"># 求梯度</span></span><br><span class="line">        db = np.<span class="built_in">sum</span>(f - y) / num_train</span><br><span class="line">        cost = np.squeeze(cost)  <span class="comment"># 删除多维度条目，如[[1,2,3]]变为[1,2,3]</span></span><br><span class="line">        <span class="keyword">return</span> f, cost, dW, db</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>定义模型训练函数</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, X, y, learning_rate, epochs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义模型训练函数&quot;&quot;&quot;</span></span><br><span class="line">    W, b = self.initialize_params(X.shape[<span class="number">1</span>])  <span class="comment"># 初始化模型参数</span></span><br><span class="line">    cost_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="comment"># 计算训练集当前输出，损失函数值，梯度</span></span><br><span class="line">        f, cost, dW, db = self.cost(X, y, W, b)</span><br><span class="line">        cost_list.append(cost)</span><br><span class="line">        <span class="comment"># 参数更新</span></span><br><span class="line">        W = W - learning_rate * dW</span><br><span class="line">        b = b - learning_rate * db</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;epoch %d cost %f&#x27;</span> % (i, cost))</span><br><span class="line">        params = &#123;<span class="string">&#x27;W&#x27;</span>: W, <span class="string">&#x27;b&#x27;</span>: b&#125;</span><br><span class="line">        grads = &#123;<span class="string">&#x27;dW&#x27;</span>: dW, <span class="string">&#x27;db&#x27;</span>: db&#125;</span><br><span class="line">    <span class="keyword">return</span> cost_list, params, grads</span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>定义模型预测函数和准确率计算函数</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X, params</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;模型测试函数&quot;&quot;&quot;</span></span><br><span class="line">    W = params[<span class="string">&#x27;W&#x27;</span>]</span><br><span class="line">    b = params[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    y_pred = self.sigmod(np.dot(X, W) + b)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_pred)):</span><br><span class="line">        <span class="keyword">if</span> y_pred[i] &gt; <span class="number">0.5</span>:</span><br><span class="line">            y_pred[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y_pred[i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self, y_test, y_pred</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算分类准确率&quot;&quot;&quot;</span></span><br><span class="line">    correct_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_test)):</span><br><span class="line">        <span class="keyword">if</span> y_test[i] == y_pred[i]:</span><br><span class="line">            correct_count += <span class="number">1</span></span><br><span class="line">    acc = correct_count / <span class="built_in">len</span>(y_test)</span><br><span class="line">    <span class="keyword">return</span> acc</span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>定义绘图函数</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_LogisticRegression</span>(<span class="params">self, X_train, y_train, params, title</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;可视化分类结果&quot;&quot;&quot;</span></span><br><span class="line">    n = X_train.shape[<span class="number">0</span>]</span><br><span class="line">    xcord1 = []</span><br><span class="line">    ycord1 = []</span><br><span class="line">    xcord2 = []</span><br><span class="line">    ycord2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 取前两个特征可视化</span></span><br><span class="line">        <span class="keyword">if</span> y_train[i] == <span class="number">1</span>:</span><br><span class="line">            xcord1.append(X_train[i][<span class="number">0</span>])</span><br><span class="line">            ycord1.append(X_train[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xcord2.append(X_train[i][<span class="number">0</span>])</span><br><span class="line">            ycord2.append(X_train[i][<span class="number">1</span>])</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(xcord1, ycord1, s=<span class="number">32</span>, c=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    ax.scatter(xcord2, ycord2, s=<span class="number">32</span>, c=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">    x = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.5</span>)</span><br><span class="line">    y = (-params[<span class="string">&#x27;b&#x27;</span>] - params[<span class="string">&#x27;W&#x27;</span>][<span class="number">0</span>] * x) / params[<span class="string">&#x27;W&#x27;</span>][<span class="number">1</span>]</span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;X1&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;X2&#x27;</span>)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.savefig(<span class="string">f&#x27;detail_<span class="subst">&#123;title&#125;</span>.jpg&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>测试模型并展示代价曲线</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 训练模型并展示代价曲线</span></span><br><span class="line">    model = LogisticRegression()</span><br><span class="line">    X = load_breast_cancer().data</span><br><span class="line">    labels = load_breast_cancer().target</span><br><span class="line">    labels = labels.reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    offset = <span class="built_in">int</span>(X.shape[<span class="number">0</span>] * <span class="number">0.9</span>)</span><br><span class="line">    X_train, y_train = X[:offset], labels[:offset]</span><br><span class="line">    X_test, y_test = X[offset:], labels[offset:]</span><br><span class="line">    sc = StandardScaler()</span><br><span class="line">    sc.fit(X_train)</span><br><span class="line">    <span class="comment"># 标准化数据</span></span><br><span class="line">    X_train_std = sc.transform(X_train)</span><br><span class="line">    X_test_std = sc.transform(X_test)</span><br><span class="line">    <span class="built_in">print</span>(X_train.shape, y_train.shape, X_test.shape, y_test.shape)</span><br><span class="line">    cost_list, params, grads = model.fit(X_train_std, y_train, <span class="number">0.05</span>, <span class="number">6000</span>)</span><br><span class="line">    plt.plot(cost_list)</span><br><span class="line">    plt.legend([<span class="string">&#x27;train cost&#x27;</span>])</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">    plt.savefig(<span class="string">&#x27;train_cost.jpg&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669877343167.png" alt="代价曲线"></p>
<div class="note success modern"><p>测试模型并展示分类图像</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试模型并展示分类图像</span></span><br><span class="line">y_train_pred = model.predict(X_train_std, params)</span><br><span class="line">accuracy_score_train = model.score(y_train, y_train_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;detail&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train accuracy is:&#x27;</span>, accuracy_score_train)</span><br><span class="line">y_test_pred = model.predict(X_test_std, params)</span><br><span class="line">accuracy_score_test = model.score(y_test, y_test_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test accuracy is:&#x27;</span>, accuracy_score_test)</span><br><span class="line">model.plot_LogisticRegression(X_train_std, y_train, params, <span class="string">&#x27;detail train&#x27;</span>)</span><br><span class="line">model.plot_LogisticRegression(X_test_std, y_test, params, <span class="string">&#x27;detail test&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669877406657.png" alt="训练集分类结果"></p>
<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669877418097.png" alt="测试集分类结果"></p>
<div class="note success modern"><p>调整学习率优化模型</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调整学习率优化模型</span></span><br><span class="line">acc = []</span><br><span class="line">lr_his = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">    learning_rate = <span class="number">0.0005</span>*i</span><br><span class="line">    lr_his.append(learning_rate)</span><br><span class="line">    cost_list, params, grads = model.fit(X_train_std, y_train, learning_rate, <span class="number">6000</span>)</span><br><span class="line">    y_train_pred = model.predict(X_train_std, params)</span><br><span class="line">    accuracy_score_train = model.score(y_train, y_train_pred)</span><br><span class="line">    acc.append(accuracy_score_train)</span><br><span class="line">plt.plot(lr_his, acc)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;learning rate&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;accurary&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669877891536.png" alt="学习曲线"></p>
<div class="note success modern"><p>调整训练次数优化模型</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调整模型训练次数优化模型</span></span><br><span class="line">acc = []</span><br><span class="line">epoch_his = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">    epoch = <span class="number">500</span> * i</span><br><span class="line">    epoch_his.append(epoch)</span><br><span class="line">    cost_list, params, grads = model.fit(X_train_std, y_train, <span class="number">0.01</span>, epoch)</span><br><span class="line">    y_train_pred = model.predict(X_train_std, params)</span><br><span class="line">    accuracy_score_train = model.score(y_train, y_train_pred)</span><br><span class="line">    acc.append(accuracy_score_train)</span><br><span class="line">plt.plot(epoch_his, acc)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;accurary&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669877956725.png" alt="训练次数曲线"></p>
<h1 id="实验七-Neural-Network"><a href="#实验七-Neural-Network" class="headerlink" title="实验七 Neural Network"></a>实验七 Neural Network</h1><h2 id="采用-keras-设计神经网络模型"><a href="#采用-keras-设计神经网络模型" class="headerlink" title="采用 keras 设计神经网络模型"></a>采用 keras 设计神经网络模型</h2><div class="note info modern"><p>导入包</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow.keras <span class="keyword">as</span> keras</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>



<div class="note info modern"><p>读取数据集并展示读取结果</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(train_data, train_labels), (test_data, test_labels) = keras.datasets.mnist.load_data()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train data&#x27;</span>, train_data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train labels&#x27;</span>, train_labels.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test data&#x27;</span>, test_data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test labels&#x27;</span>, test_labels.shape)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train data (<span class="number">60000</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">train labels (<span class="number">60000</span>,)</span><br><span class="line">test data (<span class="number">10000</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">test labels (<span class="number">10000</span>,)</span><br></pre></td></tr></table></figure>





<div class="note info modern"><p>调用imshow方法，打印训练集前四个样本</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">0</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">1</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">2</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">3</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"><span class="comment"># plt.imshow()函数负责对图像进行处理，并显示其格式，而plt.show()则是将plt.imshow()处理后的函数显示出来</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669945633268.png" alt="前四个样本"></p>
<div class="note info modern"><p>训练模型并评估结果</p>
</div> 

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = keras.Sequential([</span><br><span class="line">    keras.layers.Flatten(input_shape=[<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>]),</span><br><span class="line">    keras.layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>),</span><br><span class="line">])</span><br><span class="line">model.summary()  <span class="comment"># 输出模型各层的参数状况</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=keras.optimizers.Adam(learning_rate=<span class="number">0.001</span>), \</span><br><span class="line">              loss=keras.losses.sparse_categorical_crossentropy, \</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">train_data = train_data / <span class="number">255</span>  <span class="comment"># 转化为01矩阵</span></span><br><span class="line">history = model.fit(train_data.reshape(-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>), train_labels, epochs=<span class="number">5</span>)  <span class="comment"># reshape(-1, 28, 28, 1)转换为1列</span></span><br><span class="line">acc = model.evaluate(test_data.reshape(-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>), test_labels)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test accuracy:&#x27;</span>, acc[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Model: <span class="string">&quot;sequential&quot;</span></span><br><span class="line">_________________________________________________________________</span><br><span class="line"> Layer (<span class="built_in">type</span>)                Output Shape              Param <span class="comment">#   </span></span><br><span class="line">=================================================================</span><br><span class="line"> flatten (Flatten)           (<span class="literal">None</span>, <span class="number">784</span>)               <span class="number">0</span>         </span><br><span class="line">                                                                 </span><br><span class="line"> dense (Dense)               (<span class="literal">None</span>, <span class="number">64</span>)                <span class="number">50240</span>     </span><br><span class="line">                                                                 </span><br><span class="line"> dense_1 (Dense)             (<span class="literal">None</span>, <span class="number">10</span>)                <span class="number">650</span>       </span><br><span class="line">                                                                 </span><br><span class="line">=================================================================</span><br><span class="line">Total params: <span class="number">50</span>,<span class="number">890</span></span><br><span class="line">Trainable params: <span class="number">50</span>,<span class="number">890</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">_________________________________________________________________</span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">5</span></span><br><span class="line"><span class="number">1875</span>/<span class="number">1875</span> [==============================] - 9s 3ms/step - loss: <span class="number">0.2990</span> - accuracy: <span class="number">0.9155</span></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">5</span></span><br><span class="line"><span class="number">1875</span>/<span class="number">1875</span> [==============================] - 5s 3ms/step - loss: <span class="number">0.1446</span> - accuracy: <span class="number">0.9576</span></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">5</span></span><br><span class="line"><span class="number">1875</span>/<span class="number">1875</span> [==============================] - 6s 3ms/step - loss: <span class="number">0.1073</span> - accuracy: <span class="number">0.9678</span></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">5</span></span><br><span class="line"><span class="number">1875</span>/<span class="number">1875</span> [==============================] - 6s 3ms/step - loss: <span class="number">0.0847</span> - accuracy: <span class="number">0.9744</span></span><br><span class="line">Epoch <span class="number">5</span>/<span class="number">5</span></span><br><span class="line"><span class="number">1875</span>/<span class="number">1875</span> [==============================] - 6s 3ms/step - loss: <span class="number">0.0709</span> - accuracy: <span class="number">0.9783</span></span><br><span class="line"><span class="number">313</span>/<span class="number">313</span> [==============================] - 1s 3ms/step - loss: <span class="number">16.2302</span> - accuracy: <span class="number">0.9686</span></span><br><span class="line">test accuracy: <span class="number">0.9685999751091003</span></span><br></pre></td></tr></table></figure>



<div class="note info modern"><p>画出模型训练误差和训练准确率</p>
</div> 

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epochs = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>)]</span><br><span class="line">plt.title(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, history.history[<span class="string">&#x27;loss&#x27;</span>], <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;loss.jpg&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.plot(epochs, history.history[<span class="string">&#x27;accuracy&#x27;</span>], <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;accuracy.jpg&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669945797515.png" alt="模型损失"></p>
<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669945811563.png" alt="模式精度"></p>
<h2 id="复现神经网络核心代码"><a href="#复现神经网络核心代码" class="headerlink" title="复现神经网络核心代码"></a>复现神经网络核心代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">tf.disable_eager_execution()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据集并展示读取结果</span></span><br><span class="line">(train_data, train_labels), (test_data, test_labels) = tf.keras.datasets.mnist.load_data()</span><br><span class="line">train_y = tf.keras.utils.to_categorical(train_labels)</span><br><span class="line">test_y = tf.keras.utils.to_categorical(test_labels)</span><br><span class="line">train_data = train_data / <span class="number">255</span></span><br><span class="line">test_data = test_data / <span class="number">255</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train data&#x27;</span>, train_data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train label&#x27;</span>, train_labels.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test data&#x27;</span>, test_data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test label&#x27;</span>, test_labels.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型各项参数</span></span><br><span class="line">learning_rate = <span class="number">0.2</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">EPOCH = <span class="number">20</span></span><br><span class="line">train_losses = []</span><br><span class="line">test_losses = []</span><br><span class="line">train_accuracies = []</span><br><span class="line">test_accuracies = []</span><br><span class="line">batch = <span class="built_in">len</span>(train_labels)// BATCH_SIZE</span><br><span class="line">batch_test = <span class="built_in">len</span>(test_labels) // BATCH_SIZE</span><br><span class="line">lr = tf.placeholder(tf.float32)</span><br><span class="line">x_data = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">784</span>], name=<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">y_data = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>], name=<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">w1 = tf.Variable(tf.random_normal([<span class="number">784</span>, <span class="number">64</span>]), name=<span class="string">&#x27;w1&#x27;</span>)</span><br><span class="line">w2 = tf.Variable(tf.random_normal([<span class="number">64</span>, <span class="number">10</span>]), name=<span class="string">&#x27;w2&#x27;</span>)</span><br><span class="line">b1 = tf.Variable(tf.random_uniform([<span class="number">64</span>]), name=<span class="string">&#x27;b1&#x27;</span>)</span><br><span class="line">b2 = tf.Variable(tf.random_uniform([<span class="number">10</span>]), name=<span class="string">&#x27;b2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建神经网络模型，定义损失函数，优化器，搭建模型计算图</span></span><br><span class="line">out = tf.nn.relu(tf.add(tf.matmul(x_data, w1), b1))</span><br><span class="line">y_pred = tf.add(tf.matmul(out, w2), b2)</span><br><span class="line">loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y_data, logits=y_pred))</span><br><span class="line">optimizer = tf.train.AdagradOptimizer(learning_rate=lr).minimize(loss)</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(y_pred, <span class="number">1</span>),</span><br><span class="line">tf.argmax(y_data, <span class="number">1</span>)), <span class="string">&quot;float&quot;</span>))</span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练神经网络并评估其效果</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(EPOCH):</span><br><span class="line">        test_loss = <span class="number">0</span></span><br><span class="line">        train_loss = <span class="number">0</span></span><br><span class="line">        test_acc = <span class="number">0</span></span><br><span class="line">        train_acc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> now_batch <span class="keyword">in</span> <span class="built_in">range</span>(batch):</span><br><span class="line">            X = train_data[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE].reshape(BATCH_SIZE, -<span class="number">1</span>)</span><br><span class="line">            Y = train_y[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">            sess.run(optimizer, feed_dict=&#123;x_data: X, y_data: Y, lr:learning_rate&#125;)</span><br><span class="line">        <span class="keyword">for</span> now_batch <span class="keyword">in</span> <span class="built_in">range</span>(batch):</span><br><span class="line">            X = train_data[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE].reshape(BATCH_SIZE, -<span class="number">1</span>)</span><br><span class="line">            Y = train_y[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">            loss_, acc = sess.run([loss, accuracy], feed_dict=&#123;x_data: X, y_data: Y&#125;)</span><br><span class="line">            train_loss += loss_</span><br><span class="line">            train_acc += acc</span><br><span class="line">        train_loss /= batch</span><br><span class="line">        train_acc /= batch</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;now epoch: &#123;&#125;, loss: &#123;&#125;, acc:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(epoch, train_loss, train_acc))</span><br><span class="line">        <span class="keyword">for</span> now_batch <span class="keyword">in</span> <span class="built_in">range</span>(batch_test):</span><br><span class="line">            X = test_data[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE].reshape(BATCH_SIZE, -<span class="number">1</span>)</span><br><span class="line">            Y = test_y[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">            loss_, acc = sess.run([loss, accuracy], feed_dict=&#123;x_data: X, y_data: Y&#125;)</span><br><span class="line">            test_loss += loss_</span><br><span class="line">            test_acc += acc</span><br><span class="line">        test_loss /= batch_test</span><br><span class="line">        test_acc /= batch_test</span><br><span class="line">        train_losses.append(train_loss)</span><br><span class="line">        test_losses.append(test_loss)</span><br><span class="line">        train_accuracies.append(train_acc)</span><br><span class="line">        test_accuracies.append(test_acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test acc: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(test_accuracies[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制神经网络评估曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.plot(train_losses)</span><br><span class="line">plt.plot(test_losses)</span><br><span class="line">plt.legend([<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;test loss&#x27;</span>])</span><br><span class="line">plt.show()</span><br><span class="line">plt.title(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.plot(train_accuracies)</span><br><span class="line">plt.plot(test_accuracies)</span><br><span class="line">plt.legend([<span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669946081327.png" alt="模型损失"></p>
<p>​    <img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1669946091183.png" alt="模型精度"></p>
<h1 id="实验八-CNN"><a href="#实验八-CNN" class="headerlink" title="实验八 CNN"></a>实验八 CNN</h1><h2 id="采用-keras-设计CNN网络模型"><a href="#采用-keras-设计CNN网络模型" class="headerlink" title="采用 keras 设计CNN网络模型"></a>采用 keras 设计CNN网络模型</h2><div class="note success modern"><p>导入包</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>读取数据集，调用print方法查看分割结果</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(train_data, train_labels), (test_data, test_labels) = keras.datasets.mnist.load_data()</span><br><span class="line"><span class="built_in">print</span>(train_data.shape)</span><br><span class="line"><span class="built_in">print</span>(train_labels.shape)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(60000, 28, 28)</span><br><span class="line">(60000,)</span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>显示训练集前 4 个样本</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">0</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">1</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">2</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">3</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1670030339253.png" alt="前四个样本"></p>
<div class="note success modern"><p>通过调用 compile 方法搭建模型，调用 fit()方法训练模型，展示模型训练后的测试集准确率</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过调用 compile 方法搭建模型，调用 fit()方法训练模型，展示模型训练后的测试集准确率</span></span><br><span class="line">model = keras.Sequential([</span><br><span class="line">    keras.layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=[<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>]),</span><br><span class="line">    keras.layers.MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">    keras.layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=[<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>]),</span><br><span class="line">    keras.layers.MaxPooling2D(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">    keras.layers.Flatten(),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line">model.summary() <span class="comment"># 输出模型各层的参数状况</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.losses.sparse_categorical_crossentropy,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">train_data = train_data / <span class="number">255</span></span><br><span class="line">history = model.fit(train_data.reshape(-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>), train_labels, epochs=<span class="number">5</span>)</span><br><span class="line">test_data = test_data / <span class="number">255</span></span><br><span class="line">acc = model.evaluate(test_data.reshape(-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>), test_labels)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test accuracy:&#x27;</span>, acc[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Model: <span class="string">&quot;sequential&quot;</span></span><br><span class="line">_________________________________________________________________</span><br><span class="line"> Layer (<span class="built_in">type</span>)                Output Shape              Param <span class="comment">#   </span></span><br><span class="line">=================================================================</span><br><span class="line"> conv2d (Conv2D)             (<span class="literal">None</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">64</span>)        <span class="number">640</span>       </span><br><span class="line">                                                                 </span><br><span class="line"> max_pooling2d (MaxPooling2D  (<span class="literal">None</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">64</span>)       <span class="number">0</span>         </span><br><span class="line"> )                                                               </span><br><span class="line">                                                                 </span><br><span class="line"> conv2d_1 (Conv2D)           (<span class="literal">None</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">64</span>)        <span class="number">36928</span>     </span><br><span class="line">                                                                 </span><br><span class="line"> max_pooling2d_1 (MaxPooling  (<span class="literal">None</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">64</span>)         <span class="number">0</span>         </span><br><span class="line"> 2D)                                                             </span><br><span class="line">                                                                 </span><br><span class="line"> flatten (Flatten)           (<span class="literal">None</span>, <span class="number">1600</span>)              <span class="number">0</span>         </span><br><span class="line">                                                                 </span><br><span class="line"> dense (Dense)               (<span class="literal">None</span>, <span class="number">10</span>)                <span class="number">16010</span>     </span><br><span class="line">                                                                 </span><br><span class="line">=================================================================</span><br><span class="line">Total params: <span class="number">53</span>,<span class="number">578</span></span><br><span class="line">Trainable params: <span class="number">53</span>,<span class="number">578</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">_________________________________________________________________</span><br></pre></td></tr></table></figure>



<div class="note success modern"><p>画出模型训练误差和训练准确率</p>
</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epoch = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">plt.title(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.plot(epoch, history.history[<span class="string">&#x27;loss&#x27;</span>], <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">plt.title(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.plot(epoch, history.history[<span class="string">&#x27;accuracy&#x27;</span>], <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>





<h2 id="复现CNN核心代码"><a href="#复现CNN核心代码" class="headerlink" title="复现CNN核心代码"></a>复现CNN核心代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">tf.disable_eager_execution()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据集并展示读取结果</span></span><br><span class="line">(train_data, train_labels), (test_data, test_labels) = tf.keras.datasets.mnist.load_data()</span><br><span class="line">train_y = tf.keras.utils.to_categorical(train_labels)</span><br><span class="line">test_y = tf.keras.utils.to_categorical(test_labels)</span><br><span class="line">train_data = train_data / <span class="number">255</span></span><br><span class="line">test_data = test_data / <span class="number">255</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train data&#x27;</span>, train_data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train label&#x27;</span>, train_labels.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test data&#x27;</span>, test_data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test label&#x27;</span>, test_labels.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过调用 imshow 方法，展示了训练集的前 4 个数据</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">0</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">1</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">2</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">plt.imshow(train_data[<span class="number">3</span>], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义搭建模型所需要的各项参数，包括学习率，抽样大小，训练次数，神经网络的输入等等。</span></span><br><span class="line">LEARNING_RATE = <span class="number">0.01</span></span><br><span class="line">BATCH_SIZE = <span class="number">100</span></span><br><span class="line">EPOCH = <span class="number">10</span></span><br><span class="line">train_losses = []</span><br><span class="line">test_losses = []</span><br><span class="line">train_accuracies = []</span><br><span class="line">test_accuracies = []</span><br><span class="line">batch = <span class="built_in">len</span>(train_labels)// BATCH_SIZE</span><br><span class="line">batch_test = <span class="built_in">len</span>(test_labels) // BATCH_SIZE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数初始化方法并初始化模型参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weight</span>(<span class="params">name, shape, gain=np.sqrt(<span class="params"><span class="number">2</span></span>)</span>):</span></span><br><span class="line">    total = np.prod(shape)</span><br><span class="line">    init_std = gain / np.sqrt(total)</span><br><span class="line">    init = tf.initializers.random_normal(<span class="number">0</span>, init_std)</span><br><span class="line">    <span class="keyword">return</span> tf.get_variable(name, shape=shape, initializer=init)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型的计算过程，定义损失函数为交叉熵函数，优化器选择Adagrad 优化器。</span></span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&#x27;/cpu:0&#x27;</span>):</span><br><span class="line">    x = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">28</span>, <span class="number">28</span>])</span><br><span class="line">    x_data = tf.reshape(x, [-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br><span class="line">    y_data = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>])</span><br><span class="line">    lr = tf.placeholder(tf.float32)</span><br><span class="line">    bc1 = tf.Variable(tf.truncated_normal([<span class="number">32</span>]))</span><br><span class="line">    bc2 = tf.Variable(tf.truncated_normal([<span class="number">64</span>]))</span><br><span class="line">    b_fc = tf.Variable(tf.truncated_normal([<span class="number">512</span>]))</span><br><span class="line">    b1 = tf.Variable(tf.truncated_normal([<span class="number">10</span>]))</span><br><span class="line">    wc1 = get_weight(<span class="string">&#x27;wc1&#x27;</span>, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">32</span>])</span><br><span class="line">    wc2 = get_weight(<span class="string">&#x27;wc2&#x27;</span>, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">64</span>])</span><br><span class="line">    w_fc = get_weight(<span class="string">&#x27;w_fc&#x27;</span>, [<span class="number">1600</span>, <span class="number">512</span>])</span><br><span class="line">    w1 = get_weight(<span class="string">&#x27;w1&#x27;</span>, [<span class="number">512</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&#x27;/cpu:0&#x27;</span>):</span><br><span class="line">    out1 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(x_data, wc1, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">&#x27;VALID&#x27;</span>), bc1))</span><br><span class="line">    out2 = tf.nn.max_pool(out1, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">&#x27;VALID&#x27;</span>)</span><br><span class="line">    out3 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(out2, wc2, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">&#x27;VALID&#x27;</span>), bc2))</span><br><span class="line">    out4 = tf.nn.max_pool(out3, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">&#x27;VALID&#x27;</span>)</span><br><span class="line">    out5 = tf.reshape(out4, shape=[BATCH_SIZE, -<span class="number">1</span>])</span><br><span class="line">    out6 = tf.nn.relu(tf.matmul(out5, w_fc)+b_fc)</span><br><span class="line">    out7 = tf.nn.dropout(out6, keep_prob=<span class="number">0.8</span>)</span><br><span class="line">    y_pred = tf.matmul(out7, w1)+b1</span><br><span class="line"></span><br><span class="line">    loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y_data, logits=y_pred))</span><br><span class="line">    optimizer = tf.train.AdagradOptimizer(learning_rate=lr).minimize(loss)</span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(y_pred, <span class="number">1</span>), tf.argmax(y_data, <span class="number">1</span>)), <span class="string">&quot;float&quot;</span>))</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练深度学习模型并评估结果</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(EPOCH):</span><br><span class="line">        test_loss = <span class="number">0</span></span><br><span class="line">        train_loss = <span class="number">0</span></span><br><span class="line">        test_acc = <span class="number">0</span></span><br><span class="line">        train_acc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> now_batch <span class="keyword">in</span> <span class="built_in">range</span>(batch):</span><br><span class="line">            X = train_data[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">            Y = train_y[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">            sess.run(optimizer, feed_dict=&#123;x: X, y_data: Y, lr:LEARNING_RATE &#125;)</span><br><span class="line">        <span class="keyword">for</span> now_batch <span class="keyword">in</span> <span class="built_in">range</span>(batch):</span><br><span class="line">            X = train_data[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">            Y = train_y[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">            loss_, acc = sess.run([loss, accuracy], feed_dict=&#123;x: X, y_data: Y&#125;)</span><br><span class="line">            train_loss += loss_</span><br><span class="line">            train_acc += acc</span><br><span class="line">        train_loss /= batch</span><br><span class="line">        train_acc /= batch</span><br><span class="line">        <span class="keyword">for</span> now_batch <span class="keyword">in</span> <span class="built_in">range</span>(batch_test):</span><br><span class="line">            X = test_data[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">            Y = test_y[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">            loss_, acc = sess.run([loss, accuracy], feed_dict=&#123;x: X, y_data: Y&#125;)</span><br><span class="line">            test_loss += loss_</span><br><span class="line">            test_acc += acc</span><br><span class="line">        test_loss /= batch_test</span><br><span class="line">        test_acc /= batch_test</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;now epoch: &#123;&#125;, loss: &#123;&#125;, acc:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(epoch, test_loss, test_acc))</span><br><span class="line">        train_losses.append(train_loss)</span><br><span class="line">        test_losses.append(test_loss)</span><br><span class="line">        train_accuracies.append(train_acc)</span><br><span class="line">        test_accuracies.append(test_acc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制模型评估曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.plot(train_losses)</span><br><span class="line">plt.plot(test_losses)</span><br><span class="line">plt.legend([<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;test loss&#x27;</span>])</span><br><span class="line">plt.show()</span><br><span class="line">plt.title(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.plot(train_accuracies)</span><br><span class="line">plt.plot(test_accuracies)</span><br><span class="line">plt.legend([<span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(train_data, train_labels), (test_data, test_labels) = tf.keras.datasets.mnist.load_data()</span><br><span class="line">train_y = tf.keras.utils.to_categorical(train_labels)</span><br><span class="line">test_y = tf.keras.utils.to_categorical(test_labels)</span><br><span class="line">train_data = train_data / <span class="number">255</span></span><br><span class="line">test_data = test_data / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">BATCH_SIZE = <span class="number">100</span></span><br><span class="line">LEARNING_RATE = <span class="number">0.01</span></span><br><span class="line">EPOCH = <span class="number">5</span></span><br><span class="line">train_losses = []</span><br><span class="line">test_losses = []</span><br><span class="line">train_accuracies = []</span><br><span class="line">test_accuracies = []</span><br><span class="line">batch = <span class="built_in">len</span>(train_labels)// BATCH_SIZE</span><br><span class="line">batch_test = <span class="built_in">len</span>(test_labels) // BATCH_SIZE</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weight</span>(<span class="params">name, shape, gain=np.sqrt(<span class="params"><span class="number">2</span></span>)</span>):</span></span><br><span class="line">    total = np.prod(shape)</span><br><span class="line">    init_std = gain / np.sqrt(total)</span><br><span class="line">    init = tf.initializers.random_normal(<span class="number">0</span>, init_std)</span><br><span class="line">    <span class="keyword">return</span> tf.get_variable(name, shape=shape, initializer=init)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&#x27;/cpu:0&#x27;</span>):</span><br><span class="line">    x = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">28</span>, <span class="number">28</span>])</span><br><span class="line">    x_data = tf.reshape(x, [-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br><span class="line">    y_data = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>])</span><br><span class="line">    lr = tf.placeholder(tf.float32)</span><br><span class="line"></span><br><span class="line">    bc1 = tf.Variable(tf.truncated_normal([<span class="number">32</span>]))</span><br><span class="line">    bc2 = tf.Variable(tf.truncated_normal([<span class="number">64</span>]))</span><br><span class="line">    b_fc = tf.Variable(tf.truncated_normal([<span class="number">512</span>]))</span><br><span class="line">    b1 = tf.Variable(tf.truncated_normal([<span class="number">10</span>]))</span><br><span class="line">    wc1 = get_weight(<span class="string">&#x27;wc1&#x27;</span>, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">32</span>])</span><br><span class="line">    wc2 = get_weight(<span class="string">&#x27;wc2&#x27;</span>, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">64</span>])</span><br><span class="line">    w_fc = get_weight(<span class="string">&#x27;w_fc&#x27;</span>, [<span class="number">1600</span>, <span class="number">512</span>])</span><br><span class="line">    w1 = get_weight(<span class="string">&#x27;w1&#x27;</span>, [<span class="number">512</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&#x27;/cpu:0&#x27;</span>):</span><br><span class="line">    out1 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(x_data, wc1, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">&#x27;VALID&#x27;</span>), bc1))</span><br><span class="line">    out2 = tf.nn.max_pool(out1, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">&#x27;VALID&#x27;</span>)</span><br><span class="line">    out3 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(out2, wc2, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">&#x27;VALID&#x27;</span>), bc2))</span><br><span class="line">    out4 = tf.nn.max_pool(out3, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">&#x27;VALID&#x27;</span>)</span><br><span class="line">    out5 = tf.reshape(out4, shape=[BATCH_SIZE, -<span class="number">1</span>])</span><br><span class="line">    out6 = tf.nn.relu(tf.matmul(out5, w_fc)+b_fc)</span><br><span class="line">    out7 = tf.nn.dropout(out6, keep_prob=<span class="number">0.8</span>)</span><br><span class="line">    y_pred = tf.matmul(out7, w1)+b1</span><br><span class="line"></span><br><span class="line">    loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y_data, logits=y_pred))</span><br><span class="line">    optimizer = tf.train.AdagradOptimizer(learning_rate=lr).minimize(loss)</span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(y_pred, <span class="number">1</span>), tf.argmax(y_data, <span class="number">1</span>)), <span class="string">&quot;float&quot;</span>))</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line">lr_his = []</span><br><span class="line">lr_acc = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    LEARNING_RATE = <span class="number">0.005</span>*i</span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        sess.run(init)</span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(EPOCH):</span><br><span class="line">            test_acc = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> now_batch <span class="keyword">in</span> <span class="built_in">range</span>(batch):</span><br><span class="line">                X = train_data[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">                Y = train_y[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">                sess.run(optimizer, feed_dict=&#123;x: X, y_data: Y, lr:LEARNING_RATE&#125;)</span><br><span class="line">            <span class="keyword">for</span> now_batch <span class="keyword">in</span> <span class="built_in">range</span>(batch_test):</span><br><span class="line">                X = test_data[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">                Y = test_y[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">                loss_, acc = sess.run([loss, accuracy], feed_dict=&#123;x: X, y_data: Y&#125;)</span><br><span class="line">                test_acc += acc</span><br><span class="line">            test_acc /= batch_test</span><br><span class="line">            test_accuracies.append(test_acc)</span><br><span class="line">        lr_acc.append(test_accuracies[-<span class="number">1</span>])</span><br><span class="line">        lr_his.append(LEARNING_RATE)</span><br><span class="line">plt.title(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;leraning rate&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.plot(lr_his,lr_acc)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">ep_acc = []</span><br><span class="line">ep_his = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    EPOCH = i</span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        sess.run(init)</span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(EPOCH):</span><br><span class="line">            test_acc = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> now_batch <span class="keyword">in</span> <span class="built_in">range</span>(batch):</span><br><span class="line">                X = train_data[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE].reshape(BATCH_SIZE, -<span class="number">1</span>)</span><br><span class="line">                Y = train_y[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">                sess.run(optimizer, feed_dict=&#123;x_data: X, y_data: Y, lr: LEARNING_RATE&#125;)</span><br><span class="line">            <span class="keyword">for</span> now_batch <span class="keyword">in</span> <span class="built_in">range</span>(batch_test):</span><br><span class="line">                X = test_data[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE].reshape(BATCH_SIZE, -<span class="number">1</span>)</span><br><span class="line">                Y = test_y[now_batch * BATCH_SIZE: (now_batch + <span class="number">1</span>) * BATCH_SIZE]</span><br><span class="line">                loss_, acc = sess.run([loss, accuracy], feed_dict=&#123;x_data: X, y_data: Y&#125;)</span><br><span class="line">                test_acc += acc</span><br><span class="line">            test_acc /= batch_test</span><br><span class="line">            test_accuracies.append(test_acc)</span><br><span class="line">        ep_acc.append(test_accuracies[-<span class="number">1</span>])</span><br><span class="line">        ep_his.append(EPOCH)</span><br><span class="line">plt.title(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">plt.plot(ep_his, ep_acc)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1670039324632.png" alt="1670039324632"></p>
<p><img src="/2022/11/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/1670039330113.png" alt="1670039330113"></p>
]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="—-第一阶段-—"><a href="#—-第一阶段-—" class="headerlink" title="— 第一阶段 —"></a>— 第一阶段 —</h1><h1 id="第一章-内容介绍"><a href="#第一章-内容介绍" class="headerlink" title="第一章 内容介绍"></a>第一章 内容介绍</h1><p>略</p>
<h1 id="第二章-Java概述"><a href="#第二章-Java概述" class="headerlink" title="第二章 Java概述"></a>第二章 Java概述</h1><h2 id="2-1-Java历史"><a href="#2-1-Java历史" class="headerlink" title="2.1 Java历史"></a>2.1 Java历史</h2><ul>
<li>1995年，sun公司正式发布Java第一个版本</li>
<li>2009年，甲骨文公司收购sun</li>
</ul>
<h2 id="2-2-Java-技术体系平台"><a href="#2-2-Java-技术体系平台" class="headerlink" title="2.2 Java 技术体系平台"></a>2.2 Java 技术体系平台</h2><table>
<thead>
<tr>
<th>版本</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Java SE（Standard Edition）标准版</td>
<td>支持面向桌面级应用(如Windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE</td>
</tr>
<tr>
<td>Java EE（Enterprise Edition）企业版</td>
<td>是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet、Jsp等,主要针对于Web应用程序开发。版本以前称为J2EE</td>
</tr>
<tr>
<td>Java ME（Micro Edition）小型版</td>
<td>支持Java程序运行在移动终端(手机、PDA)上的平台，对Java API有所精简，并加入了钛对移动终端的支持，此版本以前称为J2ME</td>
</tr>
</tbody></table>
<h2 id="2-3-Java语言特点"><a href="#2-3-Java语言特点" class="headerlink" title="2.3 Java语言特点"></a>2.3 Java语言特点</h2><ul>
<li>Java 语言是面向对象的(<strong>oop</strong>)</li>
<li> Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保</li>
<li>Java 语言是<strong>跨平台性的</strong>。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]</li>
<li>Java 语言是解释型的</li>
</ul>
<h2 id="2-4-Java虚拟机及运行过程"><a href="#2-4-Java虚拟机及运行过程" class="headerlink" title="2.4 Java虚拟机及运行过程"></a>2.4 Java虚拟机及运行过程</h2><ul>
<li>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK 中. </li>
<li>程序运行过程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	A[Test.java]==编译javac==&gt;B[Test.class]==运行java==&gt;c&#123;JVM&#125;</span><br></pre></td></tr></table></figure>

<div class="mermaid"> 

graph LR
		A[Test.java]&#x3D;&#x3D;编译javac&#x3D;&#x3D;&gt;B[Test.class]&#x3D;&#x3D;运行java&#x3D;&#x3D;&gt;c{JVM}
</div>



<h2 id="2-5-JDK-JRE"><a href="#2-5-JDK-JRE" class="headerlink" title="2.5 JDK JRE"></a>2.5 JDK JRE</h2><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>JDK 的全称(Java Development Kit Java 开发工具包)</li>
</ul>
<p>​            <strong>JDK = JRE +</strong> <strong>开发工具集</strong>（例如 Javac,java 编译工具等)</p>
<ul>
<li>JRE(Java Runtime Environment Java 运行环境)</li>
</ul>
<p>​            <strong>JRE = JVM + Java SE</strong> <strong>标准类库</strong>（java 核心类库）</p>
</div>



<h2 id="2-6-Java注释"><a href="#2-6-Java注释" class="headerlink" title="2.6 Java注释"></a>2.6 Java注释</h2><ul>
<li><p>单行注释  //</p>
</li>
<li><p>多行注释 /*  */</p>
</li>
<li><p>文档注释  /**  */</p>
<ul>
<li><p>文档注释内容可以白JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。一般写在类和方法前。</p>
</li>
<li><p>javadoc -d d:\temp -author -version Test.java</p>
</li>
<li><p>javadoc标签</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@author</span> Durango</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-7-Java代码规范"><a href="#2-7-Java代码规范" class="headerlink" title="2.7 Java代码规范"></a>2.7 Java代码规范</h2><ul>
<li>类、方法的注释,要以javadoc的方式来写。</li>
<li>非Java Doc的注释，往往是给代码的维护者看的，着重告述读者为什么这样写,如何修改，注意什么问题等</li>
<li>使用tab操作,实现缩进,默认整体向右边移动，时候用shift+tab整体向左移4、运算符和=两边习惯性各加一个空格。比如:2 + 4 * 5 + 345  - 89</li>
<li>源文件使用<strong>utf-8编码</strong></li>
<li>行宽度不要超过80字符</li>
<li>代码编写<strong>次行风格</strong>（推荐）和行尾风格</li>
</ul>
<h1 id="第三章-基本数据类型"><a href="#第三章-基本数据类型" class="headerlink" title="第三章 基本数据类型"></a>第三章 基本数据类型</h1><h2 id="3-1-数据类型（必背）"><a href="#3-1-数据类型（必背）" class="headerlink" title="3.1 数据类型（必背）"></a>3.1 <font color="red">数据类型</font>（必背）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	A[Java数据类型]--&gt;B[基本数据类型]</span><br><span class="line">	A--&gt;C[引用数据类型]</span><br><span class="line">        B--&gt;D[数值型]</span><br><span class="line">        	D--&gt;d1[&quot;整型: byte【1】,short【2】,int【4】,long【8】&quot;]</span><br><span class="line">        	D--&gt;d2[&quot;浮点型: float【4】,double【8】&quot;]</span><br><span class="line">        B--&gt;E[&quot;字符型: char【2】&quot;]</span><br><span class="line">        B--&gt;F[&quot;布尔型: boolean【1】&quot;]</span><br><span class="line">    C--&gt;G[类class]</span><br><span class="line">    C--&gt;H[接口interface]</span><br><span class="line">    C--&gt;I[&quot;数组[ ]&quot;]</span><br></pre></td></tr></table></figure>

<div class="mermaid">
graph LR
	A[Java数据类型]--&gt;B[基本数据类型]
	A--&gt;C[引用数据类型]
        B--&gt;D[数值型]
        	D--&gt;d1[&quot;整型: byte【1】,short【2】,int【4】,long【8】&quot;]
        	D--&gt;d2[&quot;浮点型: float【4】,double【8】&quot;]
        B--&gt;E[&quot;字符型: char【2】&quot;]
        B--&gt;F[&quot;布尔型: boolean【1】&quot;]
    C--&gt;G[类class]
    C--&gt;H[接口interface]
    C--&gt;I[&quot;数组[ ]&quot;]
</div>



<h2 id="3-2-整数类型"><a href="#3-2-整数类型" class="headerlink" title="3.2 整数类型"></a>3.2 整数类型</h2><ul>
<li>表示范围</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">占用空间</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1字节</td>
<td align="center">-128 ~ 127</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2字节</td>
<td align="center">-2^15  ~ 2^15-1</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4字节</td>
<td align="center">-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8字节</td>
<td align="center">-2^63  ~ 2^63-1</td>
</tr>
</tbody></table>
<p>​    </p>
<ul>
<li>注意细节</li>
</ul>
<p>​        java的整数常量默认为int，声明long型常量时，<strong>须后加’L’或‘l’</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">12L</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">12L</span>	<span class="comment">// 报错，long转化为int会有精度损失</span></span><br></pre></td></tr></table></figure>



<h2 id="3-3-浮点类型"><a href="#3-3-浮点类型" class="headerlink" title="3.3 浮点类型"></a>3.3 浮点类型</h2><ul>
<li>表示范围</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">占用空间</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float(单精度)</td>
<td align="center">4</td>
<td align="center">-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td align="center">double(双精度)</td>
<td align="center">8</td>
<td align="center">-1.798E308 ~ 1.798E308</td>
</tr>
</tbody></table>
<ul>
<li>说明：浮点数=符号位+指数位+尾数位</li>
<li>注意细节：<ul>
<li>java的浮点型常量默认为double型，声明float型常量时，<strong>须后加‘F’或‘f’</strong></li>
<li>通常情况下使用double，它比float更加精确</li>
</ul>
</li>
<li><font color="red">两种表示形式</font><ul>
<li>十进制：5.12    0.512f    .512（0可以省略）</li>
<li>科学计数法：5.12e2 (5.12*10的2次方)    5.12E-2 (5.12/10的2次方)</li>
</ul>
</li>
<li>浮点数使用陷阱</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个重要的使用点: 当我们对运算结果是小数, 进行相等判断时要小心，应该是以两个数的差值的绝对值，在某个精度范围类判断</span></span><br><span class="line"><span class="keyword">double</span> num11 = <span class="number">2.7</span>;</span><br><span class="line"><span class="keyword">double</span> num12 = <span class="number">2.7</span>; <span class="comment">//8.1 / 3; //2.7</span></span><br><span class="line">System.out.println(num11);<span class="comment">//2.7</span></span><br><span class="line">System.out.println(num12);<span class="comment">//接近 2.7 的一个小数，而不是 2.7</span></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">if</span>( num11 == num12) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;num11 == num12 相等&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span>(Math.abs(num11 - num12) &lt; <span class="number">0.000001</span> ) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;差值非常小，到我的规定精度，认为相等...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-4-字符类型"><a href="#3-4-字符类型" class="headerlink" title="3.4 字符类型"></a>3.4 字符类型</h2><ul>
<li><p>使用细节</p>
<ul>
<li>java中，char的本质是一个整数，在<strong>输出时，是Unicode码对应的字符</strong></li>
<li>char类型时可以进行运算法</li>
</ul>
</li>
<li><p>Java API</p>
<ul>
<li><a href="https://www.matools.com/">JavaAPI在线中文文档</a></li>
</ul>
</li>
<li><p>字符型的本质</p>
<ul>
<li>存储：‘a’ ==&gt; 码值97 ==&gt; 二进制（110 0001）==&gt; 存储</li>
<li>读取：二进制（110 0001）==&gt;  码值97 ==&gt; ‘a’ </li>
</ul>
</li>
<li><p>常见编码</p>
<ul>
<li><p>ASCII (ASCII编码表，一个字节表示，一共128个字符, 实际上一个字节可以表示256个字符,只用128个)</p>
</li>
<li><p><strong>Unicode</strong> (Unicode编码表固定大小的编码使用两个字节来表示字符，字母和汉字统一都是占用<strong>两个字节</strong>,这样浪费空间)</p>
</li>
<li><p>utf-8(编码表，大小可变的编码字母使用1个字节，汉字使用3个字节)gbk(可以表示汉字，而且范围广，字母使用1个字节，汉字2个字节)gb2312(可以表示汉字,gb2312 &lt;gbk)</p>
</li>
<li><p>big5码(繁体中文,台湾，香港)</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-5-布尔类型"><a href="#3-5-布尔类型" class="headerlink" title="3.5 布尔类型"></a>3.5 布尔类型</h2><ul>
<li>占1个字节</li>
<li>true  or false</li>
<li>java中不可以用0或非0的整数替代false或true。（C语言中可以）</li>
</ul>
<h2 id="3-6-数据类型转换"><a href="#3-6-数据类型转换" class="headerlink" title="3.6 数据类型转换"></a>3.6 数据类型转换</h2><h3 id="3-6-1-自动类型转换（必背）"><a href="#3-6-1-自动类型转换（必背）" class="headerlink" title="3.6.1. 自动类型转换（必背）"></a>3.6.1. <font color="red">自动类型转换</font>（必背）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	char--&gt;int--&gt;long--&gt;float--&gt;double</span><br><span class="line">	byte--&gt;short--&gt;int</span><br></pre></td></tr></table></figure>

<ul>
<li>注意和细节</li>
</ul>
<p>​    <div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>​    （1）有多种类型的数据混合运算时，系统首先自动将所有数据<font color="red">转换成容量最大</font>的那种数据类型，然后再进行计算。</p>
<p>​    （2）当我们把精度(容量)大的数据类型赋值给精度(容量)小的数据类型时，就会报错，反之就会进行自动类型转换。</p>
<p>​    （3）(byte,short)和char之间不会相互自动转换。</p>
<p>​    （4）byte, short,char 他们三者可以参与计算，在<font color="red">计算时首先转换为int类型</font>。</p>
<p>​    （5）<strong>boolean不参与转换</strong></p>
<p>​    （6）自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</p>
<p>​    </p>
</div></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动类型转换细节</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConvertDetail</span> </span>&#123;</span><br><span class="line"><span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//细节 1： 有多种类型的数据混合运算时，</span></span><br><span class="line">        <span class="comment">//系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算</span></span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">10</span>; <span class="comment">//ok</span></span><br><span class="line">        <span class="keyword">float</span> d1 = n1 + <span class="number">1.1</span>;<span class="comment">//错误 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class="line">        <span class="keyword">double</span> d1 = n1 + <span class="number">1.1</span>;<span class="comment">//对 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class="line">        <span class="keyword">float</span> d1 = n1 + <span class="number">1.1F</span>;<span class="comment">//对 n1 + 1.1 =&gt; 结果类型是 float</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时，</span></span><br><span class="line">        <span class="comment">//就会报错，反之就会进行自动类型转换。</span></span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">1.1</span>;<span class="comment">//错误 double -&gt; int</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//细节 3: (byte, short) 和 char 之间不会相互自动转换</span></span><br><span class="line">        <span class="comment">//当把具体数赋给 byte 时，(1)先判断该数是否在 byte 范围内，如果是就可以</span></span><br><span class="line">        <span class="keyword">byte</span> b1 = <span class="number">10</span>; <span class="comment">//对 , -128-127</span></span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">1</span>; <span class="comment">//n2 是 int</span></span><br><span class="line">        <span class="keyword">byte</span> b2 = n2; <span class="comment">//错误，原因： 如果是变量赋值，判断类型</span></span><br><span class="line">        <span class="keyword">char</span> c1 = b1; <span class="comment">//错误， 原因 byte 不能自动转成 char</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//细节 4: byte，short，char 他们三者可以计算，在计算时首先转换为 int 类型</span></span><br><span class="line">        <span class="keyword">byte</span> b2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> b3 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">short</span> s2 = b2 + s1;<span class="comment">//错, b2 + s1 =&gt; int</span></span><br><span class="line">        <span class="keyword">int</span> s2 = b2 + s1;<span class="comment">//对, b2 + s1 =&gt; int</span></span><br><span class="line">        <span class="keyword">byte</span> b4 = b2 + b3; <span class="comment">//错误: b2 + b3 =&gt; int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//细节5boolean 不参与转换</span></span><br><span class="line">        <span class="keyword">boolean</span> pass = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//int num100 = pass;// 错误，boolean 不参与类型的自动转换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型</span></span><br><span class="line">        <span class="comment">//看一道题</span></span><br><span class="line">        <span class="keyword">byte</span> b4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">short</span> s3 = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> num200 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">float</span> num300 = <span class="number">1.1F</span>;</span><br><span class="line">        <span class="keyword">double</span> num500 = b4 + s3 + num200 + num300; <span class="comment">//float -&gt; double</span></span><br></pre></td></tr></table></figure>



<h3 id="3-6-2-强制类型转换"><a href="#3-6-2-强制类型转换" class="headerlink" title="3.6.2 强制类型转换"></a>3.6.2 强制类型转换</h3><ul>
<li>当进行数据从高精度到低精度转换时，需要使用强制转换</li>
<li>强制转换符 如(int)  (byte)等</li>
<li>char类型可以用int常量值赋值，但是不能用int变量值赋值</li>
<li>byte, short, char类型在参与运算时，当做int类型处理</li>
</ul>
<h3 id="3-6-3-与字符串转换"><a href="#3-6-3-与字符串转换" class="headerlink" title="3.6.3 与字符串转换"></a>3.6.3 与字符串转换</h3><ul>
<li><p>基本数据类型 -&gt; 字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line">String s1 = n1 + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串 -&gt; 基本数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s5 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = Integer.parseInt(s5);</span><br><span class="line"><span class="keyword">double</span> num2 = Double.parseDouble(s5);</span><br><span class="line"><span class="keyword">float</span> num3 = Float.parseFloat(s5);</span><br><span class="line"><span class="keyword">long</span> num4 = Long.parseLong(s5);</span><br><span class="line"><span class="keyword">byte</span> num5 = Byte.parseByte(s5);</span><br><span class="line"><span class="keyword">boolean</span> b = Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="keyword">short</span> num6 = Short.parseShort(s5)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="第四章-运算符"><a href="#第四章-运算符" class="headerlink" title="第四章 运算符"></a>第四章 运算符</h1><h2 id="4-1-算数运算符"><a href="#4-1-算数运算符" class="headerlink" title="4.1 算数运算符"></a>4.1 算数运算符</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230909141542866.png" alt="image-20230909141542866"></p>
<ul>
<li>注意事项</li>
</ul>
<p>​    <div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>对于除号”/“，它的整数除和小数除是有区别的: **<font color="red">整数之间做除法时，只保留整数部分而舍弃小数部分</font>**。例如: int x= 10/3,结果是3</li>
<li>当对一个数取模时，可以等价<font color="red">a%b = a-a/b*b</font>，这样我们可以看到取模的一个本质运算。</li>
<li>当自增当做一个独立语言使用时，不管是 ++i 还是 i++ 都是一样的</li>
<li>当自增当做一个表达式使用时 j=++i 等价于 i=i+1; j=i<br>当自增当做一个表达式使用时 j=i++ 等价 j=i; i=i+1</li>
</ol>
<p>​    </p>
</div></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// % 取模 ,取余</span></span><br><span class="line"><span class="comment">// 在 % 的本质 看一个公式!!!! a % b = a - a / b * b</span></span><br><span class="line"><span class="comment">// -10 % 3 =&gt; -10 - (-10) / 3 * 3 = -10 + 9 = -1</span></span><br><span class="line"><span class="comment">// 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1</span></span><br><span class="line"><span class="comment">// -10 % -3 = (-10) - (-10) / (-3) * (-3) = -10 + 9 = -1</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="number">10</span> % <span class="number">3</span>); <span class="comment">//1</span></span><br><span class="line">System.out.println(-<span class="number">10</span> % <span class="number">3</span>); <span class="comment">// -1</span></span><br><span class="line">System.out.println(<span class="number">10</span> % -<span class="number">3</span>); <span class="comment">//1</span></span><br><span class="line">System.out.println(-<span class="number">10</span> % -<span class="number">3</span>);<span class="comment">//-1</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="number">10</span> / <span class="number">3</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>



<h2 id="4-2-关系运算符"><a href="#4-2-关系运算符" class="headerlink" title="4.2 关系运算符"></a>4.2 关系运算符</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230909142820955.png" alt="image-20230909142820955"></p>
<h2 id="4-3-逻辑运算符"><a href="#4-3-逻辑运算符" class="headerlink" title="4.3 逻辑运算符"></a>4.3 逻辑运算符</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230909143251548.png" alt="image-20230909143251548"></p>
<ul>
<li><p>&amp;&amp; 和 &amp; 的区别</p>
<ul>
<li><p>&amp;&amp;短路与：如果第**<font color="red">一个条件为 false，则第二个条件不会判断</font>**，最终结果为 false，效率高</p>
</li>
<li><p>&amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于&amp;&amp;短路与而言，如果第一个条件为 false ,后面的条件不再判断</span></span><br><span class="line"><span class="comment">//对于&amp;逻辑与而言，如果第一个条件为 false ,后面的条件仍然会判断</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">1</span> &amp;&amp; ++b &lt; <span class="number">50</span>) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;ok300&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b);<span class="comment">// 4 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">1</span> &amp; ++b &lt; <span class="number">50</span>) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;ok300&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b);<span class="comment">// 4 10</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>|| 和 | 的区别</p>
<ul>
<li>||短路或：如果**<font color="red">第一个条件为 true，则第二个条件不会判断</font>**，最终结果为 true，效率高</li>
<li>| 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(1)||短路或：如果第一个条件为 true，</span></span><br><span class="line"><span class="comment">//则第二个条件不会判断，最终结果为 true，效率高</span></span><br><span class="line"><span class="comment">//(2)| 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span>( a &gt; <span class="number">1</span> || ++b &gt; <span class="number">4</span>) &#123; <span class="comment">// 可以换成 | 测试</span></span><br><span class="line">	System.out.println(<span class="string">&quot;ok300&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b); <span class="comment">//4 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a &gt; <span class="number">1</span> | ++b &gt; <span class="number">4</span>) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;ok300&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b); <span class="comment">//4 10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h2><ul>
<li>复合赋值运算符会进行类型转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br><span class="line">b += <span class="number">2</span>;	<span class="comment">//等价于 b = (byte)(b + 2)</span></span><br><span class="line">b ++;	<span class="comment">//等价于 b = (byte)(b + 1)</span></span><br></pre></td></tr></table></figure>



<h2 id="4-5-三元运算符"><a href="#4-5-三元运算符" class="headerlink" title="4.5 三元运算符"></a>4.5 三元运算符</h2><p>条件表达式 ? 表达式 1: 表达式 2;</p>
<p>运算规则：</p>
<ol>
<li><p>如果条件表达式为 true，运算后的结果是表达式 1；</p>
</li>
<li><p>如果条件表达式为 false，运算后的结果是表达式 2；</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">99</span>;</span><br><span class="line"><span class="comment">// 解读</span></span><br><span class="line"><span class="comment">// 1. a &gt; b 为 false</span></span><br><span class="line"><span class="comment">// 2. 返回 b--, 先返回 b 的值,然后在 b-1</span></span><br><span class="line"><span class="comment">// 3. 返回的结果是 99</span></span><br><span class="line"><span class="keyword">int</span> result = a &gt; b ? a++ : b--;</span><br><span class="line">System.out.println(<span class="string">&quot;result=&quot;</span> + result);	<span class="comment">// 99</span></span><br><span class="line">System.out.println(<span class="string">&quot;a=&quot;</span> + a);	<span class="comment">// 10</span></span><br><span class="line">System.out.println(<span class="string">&quot;b=&quot;</span> + b);	<span class="comment">// 98</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：实现三个数的最大值</span></span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">553</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">int</span> n3 = <span class="number">123</span>;</span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">//1. 先得到 n1 和 n2 中最大数 , 保存到 max1</span></span><br><span class="line"><span class="comment">//2. 然后再 求出 max1 和 n3 中的最大数，保存到 max2</span></span><br><span class="line"><span class="keyword">int</span> max1 = n1 &gt; n2 ? n1 : n2;</span><br><span class="line"><span class="keyword">int</span> max2 = max1 &gt; n3 ? max1 : n3;</span><br><span class="line">System.out.println(<span class="string">&quot;最大数=&quot;</span> + max2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用一条语句实现, 推荐使用上面方法</span></span><br><span class="line"><span class="comment">//老师提示: 后面我们可以使用更好方法,比如排序</span></span><br><span class="line"><span class="comment">// int max = (n1 &gt; n2 ? n1 : n2) &gt; n3 ?</span></span><br><span class="line"><span class="comment">// (n1 &gt; n2 ? n1 : n2) : n3;</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;最大数=&quot; + max);</span></span><br></pre></td></tr></table></figure>



<h2 id="4-6-标识符"><a href="#4-6-标识符" class="headerlink" title="4.6 标识符"></a>4.6 标识符</h2><ul>
<li>标识符命名规则</li>
</ul>
<p>​    <div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li><p>由26个英文字母大小写, 0-9，或 $ 组成</p>
</li>
<li><p>数字不可以开头。int 3ab = 1;//错误</p>
</li>
<li><p>不可以使用关键字和保留字，但能包含关键字和保留字。</p>
</li>
<li><p>Java中严格区分大小写，长度无限制。int totalNum = 10; int n = 90;</p>
</li>
<li><p>标识符不能包含空格。int a b = 90;</p>
</li>
</ol>
<p>​    </p>
</div></p>
<ul>
<li>标识符命名规范</li>
</ul>
<p>​    <div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li><p> 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm</p>
</li>
<li><p>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]</p>
</li>
<li><p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZz[小驼峰， 简称 驼峰法]</p>
</li>
<li><p>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p>
</li>
</ol>
<p>​    </p>
</div></p>
<h2 id="4-7-键盘输入"><a href="#4-7-键盘输入" class="headerlink" title="4.7 键盘输入"></a>4.7 键盘输入</h2><p>​    <div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li><p> next()：接收用户输入字符串</p>
</li>
<li><p> <font color="red">next().charAt(0)</font>：接收用户输入的一个字符</p>
</li>
<li><p> nextInt()：接收用户输入的int</p>
</li>
<li><p> nextDouble()：接收用户输入的Double</p>
</li>
</ol>
<p>​    </p>
</div></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//表示把 java.util 下的 Scanner 类导入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//步骤</span></span><br><span class="line">        <span class="comment">//Scanner 类 表示 简单文本扫描器，在 java.util 包</span></span><br><span class="line">        <span class="comment">//1. 引入/导入 Scanner 类所在的包</span></span><br><span class="line">        <span class="comment">//2. 创建 Scanner 对象 , new 创建一个对象</span></span><br><span class="line">        Scanner myScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//3. 接收用户输入了，使用相关的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入名字&quot;</span>);</span><br><span class="line">        <span class="comment">//当程序执行到 next 方法时，会等待用户输入~~~ </span></span><br><span class="line">        String name = myScanner.next(); <span class="comment">//接收用户输入字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入年龄&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = myScanner.nextInt(); <span class="comment">//接收用户输入 int</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入薪水&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> sal = myScanner.nextDouble(); <span class="comment">//接收用户输入 double</span></span><br><span class="line">        System.out.println(<span class="string">&quot;人的信息如下:&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;名字=&quot;</span> + name</span><br><span class="line">        + <span class="string">&quot; 年龄=&quot;</span> + age + <span class="string">&quot; 薪水=&quot;</span> + sal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-8-进制（基本功）"><a href="#4-8-进制（基本功）" class="headerlink" title="4.8 进制（基本功）"></a>4.8 进制（基本功）</h2><h3 id="4-8-1-进制介绍"><a href="#4-8-1-进制介绍" class="headerlink" title="4.8.1 进制介绍"></a>4.8.1 进制介绍</h3><ul>
<li>对于整数，有四种表示方式：<ul>
<li>二进制：0,1 ，满 2 进 1. <font color="red">以 <strong>0b</strong> 或 <strong>0B</strong> 开头</font>。</li>
<li>十进制：0-9 ，满 10 进 1。</li>
<li>八进制：0-7 ，满 8 进 1. <font color="red">以数字 以数字 <strong>0</strong> 开头表示 开头表示</font>。</li>
<li>十六进制：0-9 及 A(10)-F(15)，满 16 进 1. <font color="red">以 <strong>0x 或 0X</strong> 开头表示</font>。此处的 A-F 不区分大小写。</li>
</ul>
</li>
</ul>
<h3 id="4-8-2-进制转化"><a href="#4-8-2-进制转化" class="headerlink" title="4.8.2 进制转化"></a>4.8.2 进制转化</h3><ul>
<li>k进制转十进制</li>
</ul>
<p>​        从最低位（右边）开始，将每个位上的数提取出来，乘以 k的(位数-1)次方 后再求和</p>
<ul>
<li><p>十进制转k进制</p>
<p>除k取余法</p>
</li>
<li><p>二进制转八进制（十六进制）</p>
</li>
</ul>
<p>​         从低位开始, 将二进制数（十六进制数）<strong>每三位（四位）</strong>一组，转成对应的八进制数（十六进制数）即可。</p>
<ul>
<li>八进制（十六进制）转二进制</li>
</ul>
<p>​        将八进制数（十六进制）每 1 位，转成对应的一个 3 位（4位）的二进制数即可。</p>
<h3 id="4-8-3-源码、反码、补码（必背）"><a href="#4-8-3-源码、反码、补码（必背）" class="headerlink" title="4.8.3 源码、反码、补码（必背）"></a>4.8.3 源码、反码、补码（必背）</h3><p>​    <div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>二进制的<strong>最高位</strong>是符号位: 0表示正数,1表示负数</li>
<li>正数的原码，反码，补码都一样(三码合一)</li>
<li>负数的反码=它的原码<strong>符号位不变</strong>, 其它位取反(0-&gt;1,1-&gt;0)</li>
<li><strong>负数的补码=它的反码+1</strong>，负数的反码=负数的补码-1，0的反码，补码都是0</li>
<li>java没有无符号数,换言之,java中的数都是有符号的</li>
<li>在计算机运算的时候，都是<strong>以补码的方式来运算</strong>的.</li>
<li>当我们看运算结果的时候，要看他的原码(重点)</li>
</ol>
<p>​    </p>
</div></p>
<h2 id="4-9-位运算"><a href="#4-9-位运算" class="headerlink" title="4.9 位运算"></a>4.9 位运算</h2><ul>
<li>按位与&amp;：两位全为1,结果为1，否则为0</li>
<li>按位或：两位有一个为1，结果为1，否则为0</li>
<li>按位异或^：两位一个为0,一个为1，结果为1，否则为0</li>
<li>按位取反~：0-&gt;1,1-&gt;0</li>
<li>算术右移 &gt;&gt;：低位溢出,<strong>符号位不变</strong>,并用符号位补溢出的高位</li>
<li>算术左移 &lt;&lt;：<strong>符号位不变</strong>,低位补 0</li>
<li>无符号右移&gt;&gt;&gt;：运算规则是: 低位溢出，高位补 0</li>
<li>没有无符号左移</li>
</ul>
<ul>
<li>操作过程：先得到原码，再得到补码，在补码上进行操作，最后还原为原码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 先得到-2的原码（4字节） 10000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// 2. -2的反码              11111111 11111111 11111111 11111101</span></span><br><span class="line"><span class="comment">// 3. -2的补码              11111111 11111111 11111111 11111110</span></span><br><span class="line"><span class="comment">// 4. ~(-2)操作             00000000 00000000 00000000 00000001 运算后的补码</span></span><br><span class="line"><span class="comment">// 5. 运算后的补码为正数，源码也为 00000000 00000000 00000000 00000001 =&gt; 1</span></span><br><span class="line">System.out.println(~(-<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 先得到2的原码（4字节） 00000000 00000000 00000000 00000010 （正数）</span></span><br><span class="line"><span class="comment">// 2. ~2操作               11111111 11111111 11111111 11111101 运算后的补码（负数）</span></span><br><span class="line"><span class="comment">// 3. -2补码的反码（补码-1） 11111111 11111111 11111111 11111100         </span></span><br><span class="line"><span class="comment">// 3. ~2补码的原码          10000000 00000000 00000000 00000011 =&gt; -3     </span></span><br><span class="line">System.out.println(~<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">// 00000000 00000000 00000000 00000000</span></span><br><span class="line">System.out.println(<span class="number">1</span>&gt;&gt;<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="comment">// 00000000 00000000 00000000 00000100</span></span><br><span class="line">System.out.println(<span class="number">1</span>&gt;&gt;<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h1 id="第五章-程序控制结构"><a href="#第五章-程序控制结构" class="headerlink" title="第五章 程序控制结构"></a>第五章 程序控制结构</h1><h2 id="5-1-顺序结构"><a href="#5-1-顺序结构" class="headerlink" title="5.1 顺序结构"></a>5.1 顺序结构</h2><h2 id="5-2-分支控制"><a href="#5-2-分支控制" class="headerlink" title="5.2 分支控制"></a>5.2 分支控制</h2><ul>
<li><p>单分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式) &#123;</span><br><span class="line">    执行代码块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>双分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式) &#123;</span><br><span class="line">    执行代码块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    执行代码块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(条件表达式) &#123;</span><br><span class="line">    执行代码块1;</span><br><span class="line">&#125;</span><br><span class="line">if else(条件表达式2) &#123;</span><br><span class="line">    执行代码块2;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">if else(条件表达式n) &#123;</span><br><span class="line">    执行代码块n;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;					//可以没有else</span><br><span class="line">	 执行代码块n+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>switch分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>：</span><br><span class="line">		语句块<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">2</span>：</span><br><span class="line">		语句块<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">case</span> 常量n：</span><br><span class="line">        语句块n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    defalut:</span><br><span class="line">    	<span class="keyword">default</span>语句块;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><font color="red"><strong>特别注意</strong>：当前一个case没有break时，会直接进入下一个case的语句块，而不需要判断</font></li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230910160242133.png" alt="image-20230910160242133"></p>
<ul>
<li>使用细节</li>
</ul>
<p>​    <div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>表达式数据类型，应和case后的常量<strong>类型一致</strong>，或者是可以<strong>自动转换</strong>成可以相互比较的类型，比如输入的是字符，而常量是int</li>
<li>switch(表达式)中表达式的返回值必须是: <font color="red">byte, short, int, char, enum[枚举], String</font><br>double c = 1.1; switch(c)//错误</li>
<li>case子句中的值必须是<strong>常量</strong>,而不能是变量</li>
<li>default子句是可选的，当没有匹配的case时，执行default</li>
<li>break语句用来在执行完一个case分支后使程序跳出switch语句块; 如果没有写break，程序会顺序执行到switch结尾，除非遇到break; （穿透现象）</li>
</ol>
<p>​    </p>
</div></p>
</li>
</ul>
<ul>
<li>switch和if的比较<ul>
<li> 如果<strong>判断的具体数值不多</strong>，而且符合 byte、 short 、int、 char, enum[枚举], String 这 6 种类型。虽然两个语句都可以使用，建议使用 swtich 语句。</li>
<li> 其他情况：对区间判断，对结果为 boolean 类型判断，使用 if，if 的使用范围更广</li>
</ul>
</li>
</ul>
<h2 id="5-3-循环控制"><a href="#5-3-循环控制" class="headerlink" title="5.3 循环控制"></a>5.3 循环控制</h2><h3 id="5-3-1-for循环"><a href="#5-3-1-for循环" class="headerlink" title="5.3.1 for循环"></a>5.3.1 for循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环变量初始化; 循环条件; 循环变量迭代) &#123;</span><br><span class="line">	循环操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230911162316011.png" alt="image-20230911162316011"></p>
<ul>
<li><p>for 有四要素: (1)循环变量初始化 (2)循环条件 (3)循环操作 (4)循环变量迭代</p>
</li>
<li><p>for(; ;)表示无限循环</p>
</li>
<li><p>for(; 循环判断条件; ) 中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt;= <span class="number">10</span>; ) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
<li><p>循环初始值<strong>可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开</strong>，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++, j += <span class="number">2</span>) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;j=&quot;</span> + j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-3-2-while循环"><a href="#5-3-2-while循环" class="headerlink" title="5.3.2 while循环"></a>5.3.2 while循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">循环变量初始化；</span><br><span class="line"><span class="keyword">while</span>(循环条件) &#123;</span><br><span class="line">	循环体;</span><br><span class="line">	循环变量迭代;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230911163633782.png" alt="image-20230911163633782"></p>
<h3 id="5-3-3-do-while循环"><a href="#5-3-3-do-while循环" class="headerlink" title="5.3.3 do while循环"></a>5.3.3 do while循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">循环变量初始化;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体(语句);	<span class="comment">// 至少执行一次循环体</span></span><br><span class="line">    循环变量迭代;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230911163844949.png" alt="image-20230911163844949"></p>
<h3 id="5-3-4-嵌套循环"><a href="#5-3-4-嵌套循环" class="headerlink" title="5.3.4 嵌套循环"></a>5.3.4 嵌套循环</h3><p><font color="red">编程思想：化繁为简，先死后活</font></p>
<p>化繁为简：将复杂的程序简化为多个简单的步骤</p>
<p>先死后活：先考虑常量的情况，再考虑变量的情况</p>
<ul>
<li><p>打印九九乘法表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        System.out.print(j + <span class="string">&quot;*&quot;</span> + i +<span class="string">&quot;=&quot;</span> + j * i);</span><br><span class="line">        System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230911165707995.png" alt="image-20230911165707995"></p>
</li>
</ul>
<ul>
<li><p>打印空心金字塔</p>
<ul>
<li>化繁为简</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 空格数 = 层数 - 当前层数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">5</span> - i; k++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三版</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">5</span> - i; k++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 每行只有第一个位置和最后一个位置打印*</span></span><br><span class="line">        <span class="comment">// 最后一行全部输出</span></span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">1</span> || j == <span class="number">2</span> * i - <span class="number">1</span> || i == <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;	<span class="comment">//其他位置打印空格</span></span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先死后活</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终版</span></span><br><span class="line">Scanner myScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入金字塔层数：&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> level = myScanner.nextInt();</span><br><span class="line"><span class="comment">// 第三版</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= level - i; k++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 每行只有第一个位置和最后一个位置打印*</span></span><br><span class="line">        <span class="comment">// 最后一行全部输出</span></span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">1</span> || j == <span class="number">2</span> * i - <span class="number">1</span> || i == level) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;	<span class="comment">//其他位置打印空格</span></span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230912104055452.png" alt="image-20230912104055452"></p>
</li>
</ul>
<h3 id="5-3-5-break跳转"><a href="#5-3-5-break跳转" class="headerlink" title="5.3.5 break跳转"></a>5.3.5 break跳转</h3><ul>
<li><p>跳出最近的循环体</p>
</li>
<li><p>break语句出现在多层嵌套的语句块中时，可以通过**<font color="red">标签</font>**指明要终止的是哪一层语句块。</p>
</li>
<li><p>label1: { …{break label1}… }</p>
</li>
<li><p>label1是标签，名字由程序员指定，可以是任意如abc1，ABC2</p>
</li>
<li><p>在实际开发中尽量不要使用标签</p>
</li>
<li><p>如果break没有指定标签，默认退出最近的循环体</p>
</li>
</ul>
<h3 id="5-3-6-continue跳转"><a href="#5-3-6-continue跳转" class="headerlink" title="5.3.6 continue跳转"></a>5.3.6 continue跳转</h3><ul>
<li>结束本次循环，继续执行下一次循环</li>
<li>continue 语句出现在多层嵌套的循环语句体中时，可以通过**<font color="red">标签</font>**指明要跳过的是哪一层循环 , 这个和前面的标签的使用的规则一样.</li>
</ul>
<h1 id="第六章-数组"><a href="#第六章-数组" class="headerlink" title="第六章 数组"></a>第六章 数组</h1><h2 id="6-1-数组初始化"><a href="#6-1-数组初始化" class="headerlink" title="6.1 数组初始化"></a>6.1 数组初始化</h2><h3 id="6-1-1-静态初始化"><a href="#6-1-1-静态初始化" class="headerlink" title="6.1.1 静态初始化"></a>6.1.1 静态初始化</h3><ul>
<li><p>语法：<font color="red">数据类型[]  数组名 = {元素值1，元素值2，….}</font>  或  <font color="red">数据类型 数组名[] = {元素值1，元素值2，….}</font>  或  <font color="red">数据类型 数组名[] = new 数据类型[ ]{元素值1，元素值2，….}</font> .</p>
</li>
<li><p>```java<br>int a[] = {1, 2, 3, 4};<br>int[] b = {5, 6, 7, 8};</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  int a[] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">  double b[] = &#123;1.1, 2.2, 3.4&#125;;</span><br><span class="line">  char c[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>```java<br>int a[] = new int[]{1, 2, 3, 4};<br>double b[] = new double[]{1.1, 2.2, 3.4};<br>char c[] = new char[]{‘a’, ‘b’, ‘c’};</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 6.1.2 动态初始化</span><br><span class="line"></span><br><span class="line">- 语法：&lt;font color=&#x27;red&#x27;&gt;数据类型[] 数组名  = new 数据类型[大小]&lt;/font&gt; 或 &lt;font color=&#x27;red&#x27;&gt;数据类型 数组名[]  = new 数据类型[大小]&lt;/font&gt;</span><br><span class="line">- ```java</span><br><span class="line">  int a[] = new int[4];</span><br><span class="line">  int[] b = new int[4];</span><br><span class="line">  </span><br><span class="line">  int c[]; // int[] c;</span><br><span class="line">  c = new int[4];</span><br></pre></td></tr></table></figure></li>
<li><p>```java<br>char[] table = new char[26];<br>for(int i = 0; i &lt; table.length; i++) {</p>
<pre><code>// &#39;a&#39; + i是int类型，需要强制转换为char
table[i] = (char)(&#39;a&#39; + i);
</code></pre>
<p>}<br>System.out.println(“==table数组===”);<br>for(int i = 0; i &lt; table.length; i++) {</p>
<pre><code>System.out.print(table[i] + &quot; &quot;);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## 6.2 使用细节</span><br><span class="line"></span><br><span class="line">- 数组是多个**相同类型数据**的组合，实现对这些数据的统一管理</span><br><span class="line">-  数组中的**元素可以是任何数据类型**，包括基本类型和引用类型，但是不能混用。</span><br><span class="line">- 数组创建后，如果没有赋值，有&lt;a id=&quot;myid&quot;&gt; **默认值** &lt;/a&gt;**int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null**</span><br><span class="line">- 数组的**下标是从** **0** **开始的**。</span><br><span class="line">- 获取数组长度：&lt;font color=&#x27;red&#x27;&gt;数组名.length&lt;/font&gt;</span><br><span class="line">- 数组下标必须在指定范围内使用，否则报：下标越界异常</span><br><span class="line">- 数组属**引用类型**，数组型数据是对象(object)代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 6.3 数组赋值机制</span><br><span class="line"></span><br><span class="line">- 基本数据类型是&lt;font color=&#x27;red&#x27;&gt;值传递&lt;/font&gt;，赋值类型是&lt;font color=&#x27;red&#x27;&gt;值拷贝&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  // b的变化不会影响到a</span><br><span class="line">  int n1 = 10;</span><br><span class="line">  int n2 = a;</span><br><span class="line">  n2 = 80;</span><br><span class="line">  System.out.println(n1);	// 10</span><br><span class="line">  System.out.println(n2);	// 80</span><br></pre></td></tr></table></figure></li>
<li><p>数组在默认情况下是**<font color="red">引用传递，赋的值是地址</font>**，赋值方式为<font color="red"><strong>地址拷贝</strong></font>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b的变化会影响到a</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = arr1;	<span class="comment">//把数组a赋值给b，赋的是地址</span></span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">	System.out.println(arr1[i]);</span><br><span class="line">&#125;	<span class="comment">// 10, 2, 3</span></span><br></pre></td></tr></table></figure></li>
<li><p>值传递和引用传递区别</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230913101848477.png" alt="image-20230913101848477"></p>
</li>
</ul>
<h2 id="6-4-数组拷贝"><a href="#6-4-数组拷贝" class="headerlink" title="6.4 数组拷贝"></a>6.4 数组拷贝</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">    arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">    System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println(arr2[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-5-数组反转"><a href="#6-5-数组反转" class="headerlink" title="6.5 数组反转"></a>6.5 数组反转</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    temp = arr[i];</span><br><span class="line">    arr[i] = arr[len - <span class="number">1</span> - i];</span><br><span class="line">    arr[len - <span class="number">1</span> - i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">&quot;反转后的数组&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-6-数组扩容"><a href="#6-6-数组扩容" class="headerlink" title="6.6 数组扩容"></a>6.6 数组扩容</h2><ul>
<li><p>要求：实现动态的给数组添加元素效果，实现对数组扩容。</p>
</li>
<li><p>```Java<br>// 1. 定义初始数组 int[] arr = {1,2,3}//下标 0-2<br>// 2. 定义一个新的数组 int[] arrNew = new int[arr.length+1];<br>// 3. 遍历 arr 数组，依次将 arr 的元素拷贝到 arrNew 数组<br>// 4. 将 4 赋给 arrNew[arrNew.length - 1] = 4;把 4 赋给 arrNew 最后一个元素<br>// 5. 让 arr 指向 arrNew ; arr = arrNew; 那么 原来 arr 数组就被销毁<br>int[] arr = {1, 2, 3};<br>int[] arrNew = new int[arr.length + 1];<br>for(int i = 0; i &lt; arr.length; i++) {</p>
<pre><code>arrNew[i] = arr[i];   
</code></pre>
<p>}<br>arrNew[arrNew.length - 1] = 4;<br>arr = arrNew;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## 6.7 冒泡排序</span><br><span class="line"></span><br><span class="line">- 基本思想：每一轮，依次比较相邻元素的值，若发现逆序则交换，使得较大的元素逐渐从前向后移动，就像水底的气泡一样逐渐向上冒。</span><br><span class="line"></span><br><span class="line">- 例子</span><br><span class="line"></span><br><span class="line">  ![image-20230914092459709](Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230914092459709.png)</span><br><span class="line"></span><br><span class="line">- 化繁为简，先死后活</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  int[] arr = [24, 69, 80, 57, 13]</span><br><span class="line">      int temp;</span><br><span class="line">  </span><br><span class="line">  // 第一轮，4次比较</span><br><span class="line">  for(int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">      if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">          temp = arr[j];</span><br><span class="line">          arr[j] = arr[j + 1];</span><br><span class="line">          arr[j + 1] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 第二轮，3次比较</span><br><span class="line">  for(int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">      if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">          temp = arr[j];</span><br><span class="line">          arr[j] = arr[j + 1];</span><br><span class="line">          arr[j + 1] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 第三轮，2次比较</span><br><span class="line">  for(int j = 0; j &lt; 2; j++) &#123;</span><br><span class="line">      if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">          temp = arr[j];</span><br><span class="line">          arr[j] = arr[j + 1];</span><br><span class="line">          arr[j + 1] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 第四轮，1次比较</span><br><span class="line">  for(int j = 0; j &lt; 1; j++) &#123;</span><br><span class="line">      if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">          temp = arr[j];</span><br><span class="line">          arr[j] = arr[j + 1];</span><br><span class="line">          arr[j + 1] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 一共有四轮比较，可用i代表(轮数-1)，每轮比较4-i次</span><br><span class="line">  for(int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">      for(int j = 0; j &lt; 4 - i; j++) &#123;</span><br><span class="line">          if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">              temp = arr[j];</span><br><span class="line">              arr[j] = arr[j + 1];</span><br><span class="line">              arr[j + 1] = temp;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组长度length，一共需要比较length-1轮（冒泡length-1次），第i轮需要比较length-1-i次</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-8-二维数组"><a href="#6-8-二维数组" class="headerlink" title="6.8 二维数组"></a>6.8 二维数组</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230914102416900.png" alt="image-20230914102416900"></p>
<h3 id="6-8-1-初始化"><a href="#6-8-1-初始化" class="headerlink" title="6.8.1 初始化"></a>6.8.1 初始化</h3><ul>
<li><p>静态初始化：</p>
<ul>
<li><font color="red">数据类型[][] 数组名 = &lt;!–swig￼360–&gt;</font></li>
<li><font color="red">数据类型 数组名[][] = &lt;!–swig￼361–&gt;</font></li>
<li><font color="red">数据类型[] 数组名[] = &lt;!–swig￼362–&gt;</font></li>
</ul>
</li>
<li><p>动态初始化1：</p>
<ul>
<li><font color="red">数据类型[][] 数组名 = new 数据类型[大小][大小]</font></li>
<li><font color="red">数据类型 数组名[][] = new 数据类型[大小][大小]</font></li>
<li><font color="red">数据类型[] 数组名[] = new 数据类型[大小][大小]</font></li>
</ul>
</li>
<li><p>动态初始化2（列数不确定）：</p>
<ul>
<li><font color="red">数据类型[][] 数组名 = new 数据类型[大小][]</font></li>
<li><font color="red">数据类型 数组名[][] = new 数据类型[大小][]</font></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">		arr[i][j] = (i + <span class="number">1</span>) * (j + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明时列数不确定</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">	<span class="comment">//给每一个一维数组arr[i]开辟空间</span></span><br><span class="line">	arr[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">		arr[i][j] = i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-8-2-应用-杨辉三角"><a href="#6-8-2-应用-杨辉三角" class="headerlink" title="6.8.2 应用-杨辉三角"></a>6.8.2 应用-杨辉三角</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">1 3 3 1</span></span><br><span class="line"><span class="comment">1 4 6 4 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">规律：</span></span><br><span class="line"><span class="comment">1.第n行有n个元素</span></span><br><span class="line"><span class="comment">2. 每一行第一个和最后一个元素都为1</span></span><br><span class="line"><span class="comment">3. 从第三行开始，对于中间元素 </span></span><br><span class="line"><span class="comment">[i][j] = arr[i - 1][j] + arr[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span>[][] yanghui = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; yanghui.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 给每一个一维数组开辟空间</span></span><br><span class="line">    yanghui[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; yanghui[i].length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || j == yanghui[i].length - <span class="number">1</span>) &#123;</span><br><span class="line">            yanghui[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            yanghui[i][j] = yanghui[i - <span class="number">1</span>][j] + yanghui[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第七章-面向对象编程（基础）"><a href="#第七章-面向对象编程（基础）" class="headerlink" title="第七章 面向对象编程（基础）"></a>第七章 面向对象编程（基础）</h1><h2 id="7-1-类与对象"><a href="#7-1-类与对象" class="headerlink" title="7.1 类与对象"></a>7.1 类与对象</h2><ul>
<li><p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Cat &#123;</span><br><span class="line">	String name;</span><br><span class="line">	int age;</span><br><span class="line">	String color;</span><br><span class="line">	double weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-1-1-类与对象的区别和联系"><a href="#7-1-1-类与对象的区别和联系" class="headerlink" title="7.1.1 类与对象的区别和联系"></a>7.1.1 类与对象的区别和联系</h3><ul>
<li>类是<strong>抽象</strong>的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型. </li>
<li>对象是<strong>具体</strong>的，实际的，代表一个具体事物, 即 是实例. </li>
<li> 类是对象的模板，对象是类的一个个体，对应一个实例</li>
</ul>
<p>​        </p>
<h3 id="7-1-2-对象在内存中存在形式（重要！）"><a href="#7-1-2-对象在内存中存在形式（重要！）" class="headerlink" title="7.1.2 对象在内存中存在形式（重要！）"></a>7.1.2 对象在内存中存在形式（<font color="red">重要</font>！）</h3><p>​        <strong>栈</strong>中存放的是对象的<strong>引用</strong>（对象名），真正的对象在<strong>堆</strong>中。</p>
<p>​        年龄12是一个基本数据类型（整型），直接存放在堆中；名字和颜色是一个引用类型（字符串），在堆中存放的是地址，真正的数据存放在方法区的常量池中。</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230915192816359.png" alt="image-20230915192816359"></p>
<h3 id="7-1-3-成员变量-属性-字段"><a href="#7-1-3-成员变量-属性-字段" class="headerlink" title="7.1.3 成员变量|属性|字段"></a>7.1.3 成员变量|属性|字段</h3><ul>
<li><p>定义：<strong>访问修饰符 属性类型 属性名</strong></p>
</li>
<li><p>赋值：属性如果不赋值，有<a href="#myid">默认值</a>，规则和数组一致。具体说: int 0，short 0, byte 0, long 0, float 0.0,double 0.0，</p>
<p>char \u0000，boolean false，String null</p>
</li>
<li><p>访问属性：对象名.属性名</p>
</li>
</ul>
<h3 id="7-1-4-创建对象"><a href="#7-1-4-创建对象" class="headerlink" title="7.1.4 创建对象"></a>7.1.4 创建对象</h3><ul>
<li><p>先声明在创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明时会在栈中创建一个值为空的变量,创建时会在堆中创建一个对象并把它的地址赋给这个变量</span></span><br><span class="line">Cat cat;</span><br><span class="line">cat = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure></li>
<li><p>直接创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-1-5-类和对象的内存分配机制（重要！）"><a href="#7-1-5-类和对象的内存分配机制（重要！）" class="headerlink" title="7.1.5 类和对象的内存分配机制（重要！）"></a>7.1.5 类和对象的内存分配机制（重要！）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">p1.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">Person p2 = p1;</span><br><span class="line">p2.age = <span class="number">80</span>;</span><br><span class="line">System.out.print(p1.age);<span class="comment">//80</span></span><br><span class="line">System.out.print(p2.name);<span class="comment">//小明</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230916184807203.png" alt="image-20230916184807203"></p>
<ul>
<li>java的内存结构</li>
</ul>
<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>栈： 一般存放基本数据类型(局部变量)</li>
<li>堆： 存放对象(Cat cat , 数组等)</li>
<li>方法区：常量池(常量，比如字符串)， 类加载信息</li>
</ol>
</div>



<ul>
<li>java<font color="red">创建对象的流程</font></li>
</ul>
<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>先加载 Person 类信息到<strong>方法区</strong>中(属性和方法信息, 只会加载一次)</li>
<li>在<strong>堆</strong>中分配空间, 进行默认初始化(看规则)</li>
<li>把地址赋给<strong>栈</strong>中的变量p , p 就指向对象</li>
<li>进行指定初始化， 比如 p.name =”jack” p.age = 10</li>
</ol>
</div>



<h2 id="7-2-成员方法"><a href="#7-2-成员方法" class="headerlink" title="7.2 成员方法"></a>7.2 成员方法</h2><h3 id="7-2-1-方法的调用机制（重要！）"><a href="#7-2-1-方法的调用机制（重要！）" class="headerlink" title="7.2.1 方法的调用机制（重要！）"></a>7.2.1 方法的调用机制（重要！）</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230916191418109.png" alt="image-20230916191418109"></p>
<h3 id="7-2-2-方法的作用"><a href="#7-2-2-方法的作用" class="headerlink" title="7.2.2 方法的作用"></a>7.2.2 方法的作用</h3><ul>
<li>提高代码的<strong>复用性</strong></li>
<li>将实现的细节进行<strong>封装</strong>，然后供其他用户直接调用而不需要了解其内部细节</li>
</ul>
<h3 id="7-2-3-方法的定义"><a href="#7-2-3-方法的定义" class="headerlink" title="7.2.3 方法的定义"></a>7.2.3 方法的定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 返回数据类型 方法名(形参列表...) &#123;</span><br><span class="line">	语句; <span class="comment">//方法体</span></span><br><span class="line">	<span class="keyword">return</span>;	<span class="comment">//可以没有return，此时返回数据类型为void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-2-4-方法的使用细节"><a href="#7-2-4-方法的使用细节" class="headerlink" title="7.2.4 方法的使用细节"></a>7.2.4 方法的使用细节</h3><ul>
<li>访问修饰符：控制方法的使用范围，有 public，protected，默认，private</li>
<li>放回数据类型：<ul>
<li> 一个方法最多有一个返回值  [思考，如何返回多个结果 返回数组 ]</li>
<li> 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)</li>
<li> 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回数据类型必须和 return 的值类型<strong>一致或兼容</strong>（可以自动转换）</li>
<li>如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return ;</li>
</ul>
</li>
<li>方法名<ul>
<li>遵循小驼峰命名法</li>
<li>最好见名知义，如求和getSum</li>
</ul>
</li>
<li>形参列表<ul>
<li>调用带参数的列表时，传入的参数必须和参数列表是相同类型或兼容类型</li>
<li>方法定义时的参数成为<strong>形参</strong>，方法调用时传入的参数成为<strong>实参</strong>，实参和新参的类型必须一致或兼容，个数、顺序必须一致</li>
</ul>
</li>
<li>方法体：方法体里面不能再定义方法，即<font color="red"><strong>方法不能嵌套定义</strong></font>。</li>
</ul>
<h3 id="7-2-5-方法的调用"><a href="#7-2-5-方法的调用" class="headerlink" title="7.2.5 方法的调用"></a>7.2.5 方法的调用</h3><ul>
<li>同一个类中调用：直接调用即可</li>
<li>跨类中的方法调用：需要创建对象，对象名.方法名( )，能否调用与方法的访问修饰符有关</li>
</ul>
<h2 id="7-3-成员方法的传参机制（重要！）"><a href="#7-3-成员方法的传参机制（重要！）" class="headerlink" title="7.3 成员方法的传参机制（重要！）"></a>7.3 成员方法的传参机制（重要！）</h2><h3 id="7-3-1-值传递"><a href="#7-3-1-值传递" class="headerlink" title="7.3.1 值传递"></a>7.3.1 值传递</h3><ul>
<li>案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodParameter01</span> </span>&#123;</span><br><span class="line"><span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">//创建 AA 对象 名字 obj</span></span><br><span class="line">        AA obj = <span class="keyword">new</span> AA();</span><br><span class="line">        obj.swap(a, b); <span class="comment">//调用 swap</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main 方法 a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b);  <span class="comment">//a=10 b=20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\na 和 b 交换前的值\na=&quot;</span> + a + <span class="string">&quot;\tb=&quot;</span> + b);<span class="comment">//a=10 b=20</span></span><br><span class="line">        <span class="comment">//完成了 a 和 b 的交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">        System.out.println(<span class="string">&quot;\na 和 b 交换后的值\na=&quot;</span> + a + <span class="string">&quot;\tb=&quot;</span> + b);<span class="comment">//a=20 b=10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>基本数据类型的传参机制是<font color="red">值传递（值拷贝）</font>，形参的任何改变不会影响实参。</strong></li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230918132209849.png" alt="image-20230918132209849"></p>
<h3 id="7-3-2-地址传递"><a href="#7-3-2-地址传递" class="headerlink" title="7.3.2 地址传递"></a>7.3.2 地址传递</h3><ul>
<li><p>案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodParameter02</span> </span>&#123;</span><br><span class="line">    <span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        b.test100(arr);<span class="comment">//调用方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot; main 的 arr 数组 &quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        	System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);	<span class="comment">// &#123;200, 2, 3&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">        p.age = <span class="number">10</span>;</span><br><span class="line">        b.test200(p);</span><br><span class="line">        <span class="comment">//测试题, 如果 test200 执行的是 p = null ,下面的结果是 10</span></span><br><span class="line">        <span class="comment">//测试题, 如果 test200 执行的是 p = new Person();..., 下面输出的是 10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main 的 p.age=&quot;</span> + p.age);<span class="comment">//10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="comment">//可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test100</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">200</span>;<span class="comment">//修改元素</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test200</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">	p.age = <span class="number">10000</span>; <span class="comment">//修改对象属性</span></span><br><span class="line">    <span class="comment">// 思考</span></span><br><span class="line">    <span class="comment">// p = new Person();</span></span><br><span class="line">    <span class="comment">// p.name = &quot;tom&quot;;</span></span><br><span class="line">    <span class="comment">// p.age = 99;</span></span><br><span class="line">    <span class="comment">// 思考</span></span><br><span class="line">    <span class="comment">// p = null;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>引用数据类型的传参机制是<font color="red">地址传递（地址拷贝）</font>，形参的改变会影响实参</strong>。除非形参指向新的地址</li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230918135155966.png" alt="image-20230918135155966"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230918140357919.png" alt="image-20230918140357919"></p>
<h2 id="7-4-递归调用"><a href="#7-4-递归调用" class="headerlink" title="7.4 递归调用"></a>7.4 递归调用</h2><h3 id="7-4-1-注意事项"><a href="#7-4-1-注意事项" class="headerlink" title="7.4.1 注意事项"></a>7.4.1 注意事项</h3><ul>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响, 比如n变量</li>
<li>如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据</li>
<li>递归必须向退出递归的条件逼近, 否则就是无限递归,出现StackOverflowError，栈溢出错误)</li>
<li>当一个方法执行完毕，或者遇到return时，就会返回，遵守谁调用，就将结果返回给谁</li>
</ul>
<h3 id="7-4-2-执行机制"><a href="#7-4-2-执行机制" class="headerlink" title="7.4.2 执行机制"></a>7.4.2 执行机制</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230918142149760.png" alt="image-20230918142149760"></p>
<ul>
<li><p>案例：阶乘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int factorial(int n) &#123;</span><br><span class="line">	if(n == 1) &#123;</span><br><span class="line">		return 1</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return factorial(n - 2) * n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230918142950520.png" alt="image-20230918142950520"></p>
</li>
</ul>
<ul>
<li><p>案例：迷宫</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先创建迷宫，二维数组表示。规定0表示可以走，1表示障碍物</span></span><br><span class="line">		<span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">			map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">			map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">			map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		map[<span class="number">3</span>][<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">		map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		map[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;========当前地图情况========&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map[i].length; j++) &#123;</span><br><span class="line">				System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 定义findWay给老鼠找路</span></span><br><span class="line">		T t = <span class="keyword">new</span> T();</span><br><span class="line">		t.findWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;========找路的情况========&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map[i].length; j++) &#123;</span><br><span class="line">				System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. findWay 方法就是专门来找出迷宫的路径</span></span><br><span class="line">	<span class="comment">//2. 如果找到，就返回 true ,否则返回 false</span></span><br><span class="line">	<span class="comment">//3. map 就是二维数组，即表示迷宫</span></span><br><span class="line">	<span class="comment">//4. i,j 就是老鼠的位置，初始化的位置为(1,1)</span></span><br><span class="line">	<span class="comment">//5. 因为我们是递归的找路，所以我先规定 map 数组的各个值的含义</span></span><br><span class="line">	<span class="comment">// 	0 表示没有走过可以走（无障碍） 1 表示障碍物 2 表示走过且可以走通 3 表示走过，但是走不通是死路</span></span><br><span class="line">	<span class="comment">//6. 当 map[6][5] =2 就说明找到通路,就可以结束，否则就继续找. </span></span><br><span class="line">	<span class="comment">//7. 先确定老鼠找路策略 下-&gt;右-&gt;上-&gt;左</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;	<span class="comment">//找到出口</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(map[i][j] == <span class="number">0</span>) &#123;	<span class="comment">//当前位置没有障碍物可以走</span></span><br><span class="line">				<span class="comment">// 先假设这个位置可以走通</span></span><br><span class="line">				map[i][j] = <span class="number">2</span>;</span><br><span class="line">				<span class="comment">// 判断下一个位置（4个方向是否走得通）</span></span><br><span class="line">				<span class="keyword">if</span>(findWay(map, i + <span class="number">1</span>, j)) &#123;	<span class="comment">//下</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span>(findWay(map, i, j + <span class="number">1</span>))&#123;	<span class="comment">//右</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span>(findWay(map, i - <span class="number">1</span>, j))&#123;	<span class="comment">//上</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span>(findWay(map, i, j - <span class="number">1</span>))&#123;	<span class="comment">//左</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;	<span class="comment">//当前位置四个方向都试过了，走不通</span></span><br><span class="line">					map[i][j] = <span class="number">3</span>;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;	<span class="comment">//map[i][j]=1,2,3 当前位置是障碍物走不通，或者已经走过（2,3）</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230919100158512.png" alt="image-20230919100158512"></p>
<h2 id="7-5-方法重载-Overload"><a href="#7-5-方法重载-Overload" class="headerlink" title="7.5 方法重载 Overload"></a>7.5 方法重载 Overload</h2><ul>
<li><p>java 中允许同一个类中，多个同名方法的存在，但要求**<font color="red">形参列表不一致</font>**！</p>
</li>
<li><p>减轻了起名和记名的麻烦</p>
</li>
<li><p>注意事项</p>
<ul>
<li>方法名必须相同</li>
<li>形参列表必须不同（<font color="red">形参类型、个数、顺序至少有一样不同，形参名无要求</font>）</li>
<li>返回类型无要求</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoad</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Methods md = <span class="keyword">new</span> Methods();</span><br><span class="line">		System.out.println(md.max(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">		System.out.println(md.max(<span class="number">10.2</span>, <span class="number">20.5</span>));</span><br><span class="line">		System.out.println(md.max(<span class="number">33.0</span>, <span class="number">20.1</span>, <span class="number">44.0</span>));</span><br><span class="line">		System.out.println(md.max(<span class="number">33.0</span>, <span class="number">20.1</span>, <span class="number">44</span>));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Methods</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a &gt; b ? a : b) &gt; c ? (a &gt; b ? a : b) : c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a &gt; b ? a : b) &gt; c ? (a &gt; b ? a : b) : c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-6-可变参数"><a href="#7-6-可变参数" class="headerlink" title="7.6 可变参数"></a>7.6 可变参数</h2><ul>
<li><p>java 允许将同一个类中多个同名同功能但<strong>参数个数不同</strong>的方法，封装成一个方法。就可以通过可变参数实现</p>
</li>
<li><p>访问修饰符 返回类型 方法名(<font color="red">数据类型… 形参名</font>) { }</p>
</li>
<li><p>注意事项</p>
<ul>
<li>可变参数的实参个数可以为<strong>0或者任意多个</strong></li>
<li>可变参数的<strong>实参可以为数组</strong></li>
<li>可变参数的本质就是数组</li>
<li>可变参数可以和普通类型的参数一起放在形参列表，单必须保证<strong>可变参数在最后</strong></li>
<li>一个新参列表只能出现一个可变参数</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarParameterExercise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HspMethod hm = <span class="keyword">new</span> HspMethod();</span><br><span class="line">        System.out.println(hm.showScore(<span class="string">&quot;milan&quot;</span> , <span class="number">90.1</span>, <span class="number">80.0</span> ));</span><br><span class="line">        System.out.println(hm.showScore(<span class="string">&quot;terry&quot;</span> , <span class="number">90.1</span>, <span class="number">80.0</span>,<span class="number">10</span>,<span class="number">30.5</span>,<span class="number">70</span> ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HspMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    有三个方法，分别实现返回姓名和两门课成绩(总分)，</span></span><br><span class="line"><span class="comment">    返回姓名和三门课成绩(总分)，返回姓名和五门课成绩（总分）。</span></span><br><span class="line"><span class="comment">    封装成一个可变参数的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分析 1. 方法名 showScore 2. 形参(String ,double... ) 3. 返回 String</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showScore</span><span class="params">(String name ,<span class="keyword">double</span>... scores )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> totalScore = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scores.length; i++) &#123;</span><br><span class="line">            totalScore += scores[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; 有 &quot;</span> +scores.length + <span class="string">&quot;门课的成绩总分为=&quot;</span> + totalScore;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-7-作用域"><a href="#7-7-作用域" class="headerlink" title="7.7 作用域"></a>7.7 作用域</h2><ul>
<li><p>基本作用</p>
<ul>
<li><p>全局变量：也就是属性（成员变量），作用域在整个类体中</p>
</li>
<li><p>局部变量：一般指在成员方法中定义的变量</p>
</li>
<li><p>全局变量可以不赋值直接使用，因为有默认值。局部变量必须先赋值再使用，因为没有默认值。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>注意事项</p>
<ol>
<li><p>属性和局部变量可以重名，访问时遵循就近原则。</p>
</li>
<li><p>在同一个作用域中，比如在同一个成员方法中, 两个局部变量，不能重名。</p>
</li>
<li><p>属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量,生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中。</p>
</li>
<li><p>作用域范围不同：全局变量/属性可以被本类使用，或其他类使用(通过对象调用)。局部变量只能在本类中对应的方法中使用</p>
</li>
<li><p>修饰符不同：全局变量/属性可以加修饰符局部变量不可以加修饰符</p>
</li>
</ol>
</li>
</ul>
<h2 id="7-8-构造方法"><a href="#7-8-构造方法" class="headerlink" title="7.8 构造方法"></a>7.8 构造方法</h2><h3 id="7-8-1-基本介绍"><a href="#7-8-1-基本介绍" class="headerlink" title="7.8.1 基本介绍"></a>7.8.1 基本介绍</h3><ul>
<li>构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是<font color="red">完成对新对象的初始化</font>（调用时对象已经创建）。</li>
</ul>
<h3 id="7-8-2-注意事项"><a href="#7-8-2-注意事项" class="headerlink" title="7.8.2 注意事项"></a>7.8.2 注意事项</h3><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>构造器名与类名相同</li>
<li>构造器没有返回值，也不能加void</li>
<li>一个类中可以定义多个构造器，即构造器重载</li>
<li>构造器是完成对对象的初始化，并不是创建对象</li>
<li>在new创建对象时，系统自动调用该类的构造方法。</li>
<li>如果程序员没有定义构造器，系统会自动生成一个默认无参的构造器（<strong>默认构造器</strong>），如Dog(){}，使用<strong>javap指令反编译</strong>看看。javap dog.class</li>
<li>**一旦定义了自己的构造器，默认的构造器就被覆盖了，就不能再使用默认的无参构造器，除非显示的定义一下，即Dog(){}**（重要！）</li>
</ol>
</div>



<ul>
<li><p>案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		age = <span class="number">18</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String pName, <span class="keyword">int</span> pAge)</span> </span>&#123;</span><br><span class="line">		name = pName;</span><br><span class="line">		age = pAge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-9-对象创建的流程分析（重要！）"><a href="#7-9-对象创建的流程分析（重要！）" class="headerlink" title="7.9 对象创建的流程分析（重要！）"></a>7.9 对象创建的流程分析（重要！）</h2><ul>
<li><p>案例</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230919151736302.png" alt="image-20230919151736302"></p>
</li>
<li><p>流程</p>
<ol>
<li>先加载Person类信息到方法区</li>
<li>在堆中开辟空间，进行默认初始化</li>
<li>然后运行构造方法，给属性赋值（基本数据类型保存在堆中，引用类型保存在常量词）</li>
</ol>
</li>
</ul>
<h2 id="7-10-this关键字"><a href="#7-10-this关键字" class="headerlink" title="7.10 this关键字"></a>7.10 this关键字</h2><ul>
<li><p>java虚拟机会给每个对象分配一个this，表示当前对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//问题：构造器中的name和age是局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		name = Name;</span><br><span class="line">		age = Age;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//解决：用this关键字指明当前对象的属性</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String Name, <span class="keyword">int</span> Age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = Name;</span><br><span class="line">		<span class="keyword">this</span>.age = Age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-10-1-内存示意图"><a href="#7-10-1-内存示意图" class="headerlink" title="7.10.1 内存示意图"></a>7.10.1 内存示意图</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230920092051740.png" alt="image-20230920092051740"></p>
</li>
</ul>
<ul>
<li>使用**this.hashcode()**可以输出对象的唯一标识</li>
</ul>
<h3 id="7-10-2-this注意事项"><a href="#7-10-2-this注意事项" class="headerlink" title="7.10.2 this注意事项"></a>7.10.2 this注意事项</h3><ol>
<li>this 关键字可以用来<strong>访问本类的属性、方法、构造器</strong></li>
<li> this 用于<strong>区分当前类的属性和局部变量</strong></li>
<li><strong>访问成员方法</strong>的语法：this.方法名(参数列表);</li>
<li><strong>访问构造器语法</strong>：<font color="red">this(参数列表);</font> <font color="red">注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一条语句)</font></li>
<li>this <strong>不能在类定义的外部使用</strong>，只能在类定义的方法中使用。</li>
</ol>
<h1 id="第八章-面向对象编程（中级）"><a href="#第八章-面向对象编程（中级）" class="headerlink" title="第八章 面向对象编程（中级）"></a>第八章 面向对象编程（中级）</h1><h2 id="8-1-开发工具IDEA"><a href="#8-1-开发工具IDEA" class="headerlink" title="8.1 开发工具IDEA"></a>8.1 开发工具IDEA</h2><h3 id="8-1-1-目录结构"><a href="#8-1-1-目录结构" class="headerlink" title="8.1.1 目录结构"></a>8.1.1 目录结构</h3><ul>
<li>src：存放java源码文件</li>
<li>out：存放编译后的class文件</li>
</ul>
<h3 id="8-1-2-常用快捷键（重要！）"><a href="#8-1-2-常用快捷键（重要！）" class="headerlink" title="8.1.2 常用快捷键（重要！）"></a>8.1.2 常用快捷键（重要！）</h3><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li> 删除当前行, 默认是 ctrl + Y 自己配置 <strong>ctrl + d</strong></li>
<li> 复制当前行, 自己配置 <strong>ctrl + alt + 向下光标</strong></li>
<li> 补全代码 <strong><font color="red">alt + /</font></strong></li>
<li> 添加注释和取消注释 <strong>ctrl + /</strong> </li>
<li> 导入该行需要的类 先配置 auto import , 然后使用 <strong><font color="red">alt+enter</font></strong> 即可</li>
<li> 快速格式化代码 <strong>ctrl + alt + L</strong></li>
<li> 快速运行程序，默认是shift + F10，自己定义<font color="red"> <strong>alt + R</strong></font></li>
<li> 生成构造器等 <strong>alt + insert</strong> [提高开发效率]</li>
<li> 查看一个类的层级关系<font color="red"> <strong>ctrl + H</strong></font> [学习继承后，非常有用]</li>
<li> 将光标放在一个方法上，输入 <strong><font color="red">ctrl + B</font></strong> , 可以定位到方法 [学继承后，非常有用]</li>
<li> 自动的分配变量名 , 通过在后面<font color="red"><strong>加.var</strong></font> [老师最喜欢的]</li>
<li> 另起一行编写代码，**<font color="red">shift + enter</font>**</li>
<li> 将当前行代码向上/下移动，<strong>ctrl + shift + ↑ / ↓</strong></li>
</ol>
</div>



<h3 id="8-1-3-自定义模板（提高开发速度）"><a href="#8-1-3-自定义模板（提高开发速度）" class="headerlink" title="8.1.3 自定义模板（提高开发速度）"></a>8.1.3 自定义模板（提高开发速度）</h3><ul>
<li>设置：file -&gt; settings -&gt; editor-&gt; Live templates -&gt;</li>
<li>如fori , sout等，多用多查孰能生巧</li>
</ul>
<h2 id="8-2-包"><a href="#8-2-包" class="headerlink" title="8.2 包"></a>8.2 包</h2><h3 id="8-4-1-作用"><a href="#8-4-1-作用" class="headerlink" title="8.4.1 作用"></a>8.4.1 作用</h3><ul>
<li>区分相同名字的类</li>
<li>当类很多时，便于管理类</li>
<li>控制访问范围</li>
</ul>
<h3 id="8-4-2-基本语法"><a href="#8-4-2-基本语法" class="headerlink" title="8.4.2 基本语法"></a>8.4.2 基本语法</h3><ul>
<li><p>package com.durango.xxx</p>
</li>
<li><p>package + 包名</p>
</li>
</ul>
<h3 id="8-4-3-包的本质"><a href="#8-4-3-包的本质" class="headerlink" title="8.4.3 包的本质"></a>8.4.3 包的本质</h3><p>​    包的本质实际上就是创建<strong>不同的文件夹/目录</strong>来保存类文件</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230922101528833.png" alt="image-20230922101528833"></p>
<h3 id="8-4-4-包的命名"><a href="#8-4-4-包的命名" class="headerlink" title="8.4.4 包的命名"></a>8.4.4 包的命名</h3><ul>
<li>命名规则<ul>
<li>只能包含数字、字母、下划线、小圆点</li>
<li>不能用数字开头 ，如demo.12a</li>
<li>不能是关键字或保留字，如demo.class.exec</li>
</ul>
</li>
<li> 命名规范</li>
<li>一般是 <strong>小写字母+小圆点</strong></li>
<li>包名一般是 <font color="red"><strong>com.公司名.项目名.业务模块名</strong></font></li>
<li>如，com.sina.crm.user    com.sina.crm.order    com.sina.vrm.utils</li>
</ul>
<h3 id="8-4-5-常用的包"><a href="#8-4-5-常用的包" class="headerlink" title="8.4.5 常用的包"></a>8.4.5 常用的包</h3><ol>
<li>java.lang.* ：lang 包是<strong>基本包，默认引入</strong>，不需要再引入. </li>
<li>java.util.* ：util 包，系统提供的工具包, 工具类，使用 Scanner</li>
<li> java.net.* ：网络包，网络开发</li>
<li> java.awt.* ：是做 java 界面的开发，GUI</li>
</ol>
<h3 id="8-4-6-包的导入"><a href="#8-4-6-包的导入" class="headerlink" title="8.4.6 包的导入"></a>8.4.6 包的导入</h3><ul>
<li><p>两种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;	<span class="comment">//推荐，用到哪个导入哪个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br></pre></td></tr></table></figure></li>
<li><p>使用系统提供Arrays完成数组排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Import01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用系统提供 Arrays 完成 数组排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;-<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出排序结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length ; i++) &#123;</span><br><span class="line">        System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-4-9-注意事项"><a href="#8-4-9-注意事项" class="headerlink" title="8.4.9 注意事项"></a>8.4.9 注意事项</h3><ul>
<li><p>package的作用是声明当前类所在的包，需要放在类的<strong>最上面</strong>，一个类中最多只有一句package</p>
</li>
<li><p>import指令位置放在package的下面，在类定义前面,可以有多句且没有顺序要求</p>
</li>
</ul>
<h2 id="8-5-访问修饰符-Modifier"><a href="#8-5-访问修饰符-Modifier" class="headerlink" title="8.5 访问修饰符 Modifier"></a>8.5 访问修饰符 Modifier</h2><h3 id="8-5-1-基本介绍（必背）"><a href="#8-5-1-基本介绍（必背）" class="headerlink" title="8.5.1 基本介绍（必背）"></a>8.5.1 基本介绍（必背）</h3><ol>
<li><p>公开级别:用 public 修饰,对外公开</p>
</li>
<li><p>受保护级别:用 protected 修饰，对子类和同一个包中的类公开</p>
</li>
<li><p>默认级别:没有修饰符号,向同一个包的类公开. </p>
</li>
<li><p>私有级别:用 private 修饰,只有类本身可以访问,不对外公开.</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">访问级别</th>
<th align="center">访问修饰符</th>
<th align="center">同类</th>
<th align="center">同包</th>
<th align="center">子类</th>
<th align="center">不同包</th>
</tr>
</thead>
<tbody><tr>
<td align="center">公开</td>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">受保护</td>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">默认</td>
<td align="center">无修饰符</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">私有</td>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h3 id="8-5-2-注意事项"><a href="#8-5-2-注意事项" class="headerlink" title="8.5.2 注意事项"></a>8.5.2 注意事项</h3><ul>
<li>修饰符可以用来修饰类中的<strong>属性、成员方法以及类</strong></li>
<li><strong><font color="red">只有默认的和public才能修饰类</font></strong>!,并且遵循上述访问权限的特点。</li>
</ul>
<h2 id="8-6-封装-Encapsulation"><a href="#8-6-封装-Encapsulation" class="headerlink" title="8.6 封装 Encapsulation"></a>8.6 封装 Encapsulation</h2><h3 id="8-6-1-封装介绍"><a href="#8-6-1-封装介绍" class="headerlink" title="8.6.1 封装介绍"></a>8.6.1 封装介绍</h3><p>​    封装(<strong>encapsulation</strong>)就是把抽象出的数据[<font color="red">属性</font>]和对数据的操作[<font color="red">方法</font>]封装在一起，数据被保护在内部，程序的其它部分（比如不同类，不同包）<strong>只有通过被授权的操作[方法]，才能对数据进行操作</strong>。</p>
<h3 id="8-6-2-作用"><a href="#8-6-2-作用" class="headerlink" title="8.6.2 作用"></a>8.6.2 作用</h3><ul>
<li>隐藏实现细节</li>
<li>可以对数据进行验证，保证安全合理</li>
</ul>
<h3 id="8-6-3-封装实现步骤"><a href="#8-6-3-封装实现步骤" class="headerlink" title="8.6.3 封装实现步骤"></a>8.6.3 封装实现步骤</h3><ol>
<li><p>将属性进行私有化<strong>private</strong></p>
</li>
<li><p>提供一个公共的<strong>public</strong>  <strong>set方法</strong> ，用于对属性判断和赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXxx</span><span class="params">(类型 参数名)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 加入数据验证的逻辑</span></span><br><span class="line">	属性 = 参数名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>提供一个公共的<strong>public</strong>  <strong>get方法</strong> ，用于获取属性的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">puclic 类型 getXxx() &#123;</span><br><span class="line">	<span class="keyword">return</span> 属性;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="8-6-4-快速入门案例"><a href="#8-6-4-快速入门案例" class="headerlink" title="8.6.4 快速入门案例"></a>8.6.4 快速入门案例</h3><p>需求：新建一个Person类，不能随便查看人的年龄、工资等隐私，并对设置的年龄、姓名进行合理验证。年龄合理则设置，否则给默认值。年龄必须在1-120。name长度在2-6个字符之间</p>
<p><font color="red">alt + insert</font>：编写set和get方法的快捷键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        setName(name);</span><br><span class="line">        setAge(age);</span><br><span class="line">        setSalary(salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手写get,set太慢。使用快捷键 alt + insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增加对数据的校验</span></span><br><span class="line">        <span class="keyword">if</span> (name.length() &gt;= <span class="number">2</span> &amp;&amp; name.length() &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的名字长度不对，必须为2-6个字符，已设置默认名字无名&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.name = <span class="string">&quot;无名&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增加数据的合理性判断</span></span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">1</span> &amp;&amp; age &lt;= <span class="number">120</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入年龄范围不对，必须为1-20，已设置默认年龄18&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以增加对当前对象的权限判断</span></span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;信息为 name=&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot; age=&quot;</span> + <span class="keyword">this</span>.age + <span class="string">&quot; salary=&quot;</span> + <span class="keyword">this</span>.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-7-继承-Extends"><a href="#8-7-继承-Extends" class="headerlink" title="8.7 继承 Extends"></a>8.7 继承 Extends</h2><h3 id="8-7-1-继承介绍"><a href="#8-7-1-继承介绍" class="headerlink" title="8.7.1 继承介绍"></a>8.7.1 继承介绍</h3><ul>
<li><p>继承可以解决<strong>代码复用</strong>, 让我们的编程更加靠近人类思维.  当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类, 在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。画出继承的示意图。</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230923164603231.png" alt="image-20230923164603231"></p>
</li>
</ul>
<ul>
<li><p>基本语法</p>
<p>class 子类 <font color="red"><strong>extends</strong> </font>父类 {    }</p>
<ul>
<li>子类会自动拥有父类定义的属性和方法</li>
<li>父类又叫<strong>超类、基类</strong>，子类又叫<strong>派生类</strong></li>
</ul>
</li>
<li><p>**<font color="red">ctrl + H</font>**：可以看到类的继承关系</p>
</li>
</ul>
<h3 id="8-7-2-继承细节"><a href="#8-7-2-继承细节" class="headerlink" title="8.7.2 继承细节"></a>8.7.2 继承细节</h3><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是<strong>私有属性和方法不能在子类直接访问</strong>，<strong>要通过父类提供公共的方法去访问</strong></li>
</ol>
<ol start="2">
<li><p>子类必须<strong>调用父类的构造器</strong>， 完成父类的初始化</p>
</li>
<li><p>当创建子类对象时，不管使用子类的哪个构造器，<strong>默认情况下总会去调用父类的无参构造器</strong>，<strong>如果父类没有提供无参构造器（无参构造器被覆盖），则必须在子类的构造器中用 <font color="red">super </font>去指定使用父类的哪个构造器完成对父类的初始化工作</strong>，否则，编译不会通过(怎么理解。) [举例说明]。若父类提供了无参构造器，super写不写都行。</p>
</li>
<li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下 : <strong>super(参数列表)</strong></p>
</li>
<li><p>super 在使用时，<strong>必须放在构造器<font color="red">第一行</font></strong>(super 只能在构造器中使用)</p>
</li>
<li><p><strong>super() 和 this()</strong> 都只能放在构造器<strong>第一行</strong>，因此这两个方法不能共存在一个构造器。<strong>如果写了this()，隐式的super()将不会被调用</strong></p>
</li>
<li><p>java 所有类都是 <strong>Object 类</strong>的子类, Object 是所有类的基类. <strong>ctrl + H</strong>可以看到类的继承关系</p>
</li>
<li><p>父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)</p>
</li>
<li><p>子类最多只能继承一个父类(指直接继承)，即 java 中是<font color="red">单继承机制</font>。思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】</p>
</li>
<li><p>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</p>
</li>
</ol>
</div>



<h3 id="8-7-3-继承本质分析（重要！）"><a href="#8-7-3-继承本质分析（重要！）" class="headerlink" title="8.7.3 继承本质分析（重要！）"></a>8.7.3 继承本质分析（重要！）</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230924111103504.png" alt="image-20230924111103504"></p>
<ol>
<li>创建Son对象</li>
<li>在方法区中加载Son类及其父类信息</li>
<li>在堆中给GranPa开辟空间，并初始化其属性，引用数据类型时存放在方法区的常量池中</li>
<li>在堆中给Father开辟空间，并初始化其属性，基本数据类型直接存放在堆中</li>
<li>最后给Son开辟空间，并初始化其属性</li>
<li>这时请大家注意，要<strong>按照查找关系来返回信息</strong><ol>
<li>首先看子类是否有该属性，如果子类<strong>有这个属性，并且可以访问</strong>，则返回信息</li>
<li>如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)</li>
<li>如果父类没有就按照2的规则，继续找上级父类，直到 Object… </li>
</ol>
</li>
</ol>
<h3 id="8-7-4-本质分析案例"><a href="#8-7-4-本质分析案例" class="headerlink" title="8.7.4 本质分析案例"></a>8.7.4 本质分析案例</h3><ul>
<li><p>Exercise01</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.extend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsExercise01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;abc&quot;</span>);	<span class="comment">// 不会调用super()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String name)</span> </span>&#123;	<span class="comment">//会调用super()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b name</span></span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure></li>
<li><p>Exercise02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.extend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsExercise02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        C2 c = <span class="keyword">new</span> C2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> </span>&#123;<span class="comment">//A2 类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是 A2 类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">A2</span> </span>&#123; <span class="comment">//B2 类,继承 A2 类 //main 方法中： C2 c =new C2(); 输出么内容? 3min</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是 B2 类的无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;我是 B2 类的有参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">extends</span> <span class="title">B2</span> </span>&#123; <span class="comment">//C2 类，继承 B2 类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">C2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;我是 c 类的无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">C2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;hahah&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;我是 c 类的有参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我是 A2 类</span></span><br><span class="line"><span class="comment">// hahah我是 B2 类的有参构造</span></span><br><span class="line"><span class="comment">// 我是 c 类的有参构造</span></span><br><span class="line"><span class="comment">// 我是 c 类的无参构造</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-8-super关键字"><a href="#8-8-super关键字" class="headerlink" title="8.8 super关键字"></a>8.8 super关键字</h2><h3 id="8-8-1-基本介绍"><a href="#8-8-1-基本介绍" class="headerlink" title="8.8.1 基本介绍"></a>8.8.1 基本介绍</h3><ul>
<li>super 代表父类的引用，用于<strong>访问父类的属性、方法、构造器</strong></li>
<li>不能访问父类私有的private属性、方法<ul>
<li>访问父类属性：super.属性名</li>
<li>访问父类方法：super.方法名(参数列表)</li>
<li>访问父类构造器：super(参数列表) <strong>只能放在构造器第一句，只能出现一句</strong></li>
<li>如果父类中属性设置为private，则不能通过super访问。可以在父类中设置公共的get方法，然后在子类中调用get方法获取父类私有属性。</li>
</ul>
</li>
</ul>
<h3 id="8-8-2-作用和细节"><a href="#8-8-2-作用和细节" class="headerlink" title="8.8.2 作用和细节"></a>8.8.2 作用和细节</h3><ul>
<li>调用父类的构造器的好处(<strong>分工明确, 父类属性由父类初始化，子类的属性由子类初始</strong>)</li>
<li>当子类中有和父类中的成员**(属性和方法)重名时**，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果!</li>
<li><strong>super的访问不限于直接父类</strong>，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员; 如果多个基类(上级类)中都有同名的成员，使用super访问遵循就近原则。A-&gt;B-&gt;C，当然也需要遵守访问权限的相关规则</li>
</ul>
<h3 id="8-8-3-super和this的比较"><a href="#8-8-3-super和this的比较" class="headerlink" title="8.8.3 super和this的比较"></a>8.8.3 super和this的比较</h3><table>
<thead>
<tr>
<th align="center">区别点</th>
<th align="center">this</th>
<th align="center">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问属性</td>
<td align="center">访问本类中的属性，如果本类中没有此属性，则从父类中继续查找</td>
<td align="center">从父类开始查找属性</td>
</tr>
<tr>
<td align="center">调用方法</td>
<td align="center">访问本类中的方法，如果本类中没有此方法，则从父类中继续查找</td>
<td align="center">从父类开始查找方法</td>
</tr>
<tr>
<td align="center">调用构造器</td>
<td align="center">调用本类构造器，必须放在构造器的首行</td>
<td align="center">调用父类的构造器，必须放在子类构造器的首行</td>
</tr>
<tr>
<td align="center">特殊</td>
<td align="center">对当前对象的引用</td>
<td align="center">对父类对象的引用</td>
</tr>
</tbody></table>
<h2 id="8-9-方法重写-重构-覆盖-Override"><a href="#8-9-方法重写-重构-覆盖-Override" class="headerlink" title="8.9 方法重写/重构/覆盖 Override"></a>8.9 方法重写/重构/覆盖 Override</h2><h3 id="8-9-1-基本介绍"><a href="#8-9-1-基本介绍" class="headerlink" title="8.9.1 基本介绍"></a>8.9.1 基本介绍</h3><p>​    方法覆盖(重写)就是<strong>子类有一个方法和父类的某个方法的名称、返回类型、参数一样</strong>，那么我们就说子类的这个方法覆盖了父类的方法</p>
<h3 id="8-9-2-注意事项"><a href="#8-9-2-注意事项" class="headerlink" title="8.9.2 注意事项"></a>8.9.2 注意事项</h3><ul>
<li>子类的方法的<font color="red">方法名称，形参列表</font>要和父类方法的<strong>形参列表，方法名称</strong>完全一样。</li>
<li>子类方法的返回类型和父类方法<strong>返回类型一样</strong>，<font color="red">或者是父类返回类型的子类</font>。比如父类返回类型是Object,子类方法返回类型是String</li>
<li><font color="red">子类方法不能缩小父类方法的访问权限</font>。public &gt; protected &gt; 默认 &gt; privat</li>
</ul>
<h3 id="8-9-3-重写与重载的比较"><a href="#8-9-3-重写与重载的比较" class="headerlink" title="8.9.3 重写与重载的比较"></a>8.9.3 重写与重载的比较</h3><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">发生范围</th>
<th>方法名</th>
<th align="center">形参列表</th>
<th align="center">返回类型</th>
<th align="center">修饰符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">重载overload</td>
<td align="center">本类</td>
<td>必须一样</td>
<td align="center">类型、个数、顺序至少一个不同</td>
<td align="center">无要求</td>
<td align="center">无要求</td>
</tr>
<tr>
<td align="center">重写override</td>
<td align="center">父子类</td>
<td>必须一样</td>
<td align="center">必须一样</td>
<td align="center">子类重写的方法的返回类型和父类放回类型一致，或者是其子类</td>
<td align="center">子类方法不能缩小父类方法的访问权限</td>
</tr>
</tbody></table>
<h3 id="8-9-4-案例"><a href="#8-9-4-案例" class="headerlink" title="8.9.4 案例"></a>8.9.4 案例</h3><ol>
<li><p>编写一个 Person 类，包括属性/private（name、age），构造器、方法 say(返回自我介绍的字符串）。</p>
</li>
<li><p>编写一个 Student 类，继承 Person 类，增加 id属性/private，、score 属性/private，以及构造器，定义 say 方法(返回自我介绍的信息)。</p>
</li>
<li><p>在 main 中,分别创建 Person 和 </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.override_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;，今年&quot;</span> + age + <span class="string">&quot;岁。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.override_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, String id, <span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.say(); <span class="comment">// 父类的name和age是私有属性，不能直接访问</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我的id是&quot;</span> + id + <span class="string">&quot;,考了&quot;</span> + score + <span class="string">&quot;分。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="8-10-多态-Polymorphic"><a href="#8-10-多态-Polymorphic" class="headerlink" title="8.10 多态 Polymorphic"></a>8.10 多态 Polymorphic</h2><h3 id="8-10-1-一个场景"><a href="#8-10-1-一个场景" class="headerlink" title="8.10.1 一个场景"></a>8.10.1 一个场景</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230925164315604.png" alt="image-20230925164315604"></p>
<p>需要在Master类中重载3*3=9个feed方法，才能完成“主人给什么动物喂什么食物”的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完成主人给小狗 喂 骨头</span></span><br><span class="line"><span class="comment">//    public void feed(Dog dog, Bone bone) &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;主人&quot; + name + &quot;给&quot; + dog.getName() + &quot;吃&quot; + bone.getName());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成主人给小猫 喂 鱼</span></span><br><span class="line"><span class="comment">//    public void feed(Cat cat, Fish fish) &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;主人&quot; + name + &quot;给&quot; + cat.getName() + &quot;吃&quot; + fish.getName());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果动物很多，食物很多，需要写很多重载的feed，不利于维护和管理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Animal animal, Food food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人&quot;</span> + name + <span class="string">&quot;给&quot;</span> + animal.getName() + <span class="string">&quot;吃&quot;</span> + food.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-10-2-基本介绍"><a href="#8-10-2-基本介绍" class="headerlink" title="8.10.2 基本介绍"></a>8.10.2 基本介绍</h3><p>多态：<font color="red">方法</font>或<font color="red">对象</font>具有多种形态，建立在封装和继承基础上。</p>
<p>（1）方法的多态：<strong>重写和重载</strong>就体现多态</p>
<p>（2）<strong>对象的多态</strong>（核心）</p>
<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>一个对象的编译类型和运行类型可以不一致</li>
<li>编译类型在定义对象时，就确定了，不能改变</li>
<li>运行类型是可以变化的.</li>
<li>编译类型看定义时=号的左边；运行类型看=号的右边</li>
</ol>
</div>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230925165752251.png" alt="image-20230925165752251"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// animal 编译类型时Animal，运行类型是Dog</span><br><span class="line">Animal animal = new Dog(&quot;大黄&quot;);</span><br><span class="line">animal.cry();</span><br><span class="line"></span><br><span class="line">// 编译类型时Animal，运行类型是Cat</span><br><span class="line">animal = new Cat(&quot;小花&quot;);</span><br><span class="line">animal.cry();</span><br></pre></td></tr></table></figure>



<h3 id="8-10-3-注意事项"><a href="#8-10-3-注意事项" class="headerlink" title="8.10.3 注意事项"></a>8.10.3 注意事项</h3><ul>
<li><p>多态的前提：两个类存在继承关系</p>
</li>
<li><p><font color="red"><strong>多态的向上转型</strong></font></p>
<ul>
<li><p>本质：<strong>父类的引用指向了子类的对象</strong></p>
</li>
<li><p>语法：**<font color="red">父类类型 引用名 = new 子类类型( );</font>**</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>编译类型看左边，运行类型看右边</p>
</li>
<li><p><font color="red">可以调用父类中的所有成员</font>（需要遵循访问权限）</p>
</li>
<li><p><font color="red">不能调用子类中的特有成员</font></p>
</li>
<li><p>方法的调用看运行类型，属性的调用看编译类型。</p>
</li>
<li><p>最终运行效果看子类的具体实现，即<strong>调用方法时，按照从子类开始查找方法，子类没有则查看父类。</strong></p>
</li>
</ul>
</li>
<li><p>Animal类有【public】cry,eat,run,sleep方法和【private】name属性，Cat类继承了Animal，重写了run方法，增加了一个catchMouse方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poly_.detail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyDetail</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        Cat animal = <span class="keyword">new</span> Cat(<span class="string">&quot;小花&quot;</span>);</span><br><span class="line">        <span class="comment">// Object obj = new Cat(&quot;小花&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以调用父类中所有成员（遵守访问权限）</span></span><br><span class="line">        animal.cry();</span><br><span class="line">        <span class="comment">// animal.name 不能访问父类private的成员</span></span><br><span class="line">        <span class="comment">// annimal.catchMouse();  不能访问子类特有的方法</span></span><br><span class="line">        animal.eat();</span><br><span class="line">        animal.run();</span><br><span class="line">        animal.sleep();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结果</span></span><br><span class="line">        <span class="comment">// 小猫叫</span></span><br><span class="line">        <span class="comment">// 动物吃</span></span><br><span class="line">        <span class="comment">// 动物跑</span></span><br><span class="line">        <span class="comment">// 动物睡</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><font color="red"><strong>多态的向下转型</strong></font></p>
<ul>
<li>本质：子类的引用指向父类的<strong>引用</strong></li>
<li>语法：**<font color="red">子类类型 引用名 = （子类类型）父类引用</font>；**</li>
<li>特点：<ul>
<li>要求<strong>父类的引用必须指向的是当前目标类型的对象</strong>；</li>
<li>当向下转型后，<strong>可以调用子类类型中的所有成员</strong>（包括特有的）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poly_.detail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyDetail</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        Cat animal = <span class="keyword">new</span> Cat(<span class="string">&quot;小花&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// annimal.catchMouse();  不能访问子类特有的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        <span class="comment">// 需要animal原本就指向Cat对象</span></span><br><span class="line">        <span class="comment">// 向下转型后可以访问子类特有对象</span></span><br><span class="line">        Cat cat = (Cat)animal;</span><br><span class="line">        cat.catchMouse();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>属性没有重写之说！属性的值看编译类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyDetail02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性没有重写之说！属性的值看编译类型</span></span><br><span class="line">    Base base = <span class="keyword">new</span> Sub();<span class="comment">//向上转型</span></span><br><span class="line">    System.out.println(base.count);<span class="comment">// ？ 看编译类型 10</span></span><br><span class="line">    Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">    System.out.println(sub.count);<span class="comment">//? 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;<span class="comment">//属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;<span class="comment">//子类</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">20</span>;<span class="comment">//属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong><font color="red">instanceOf</font></strong> 比较操作符，用于判断对象的**<font color="red">运行类型</font>**是否为 XX 类型或 XX 类型的子类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PolyDetail03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BB bb = new BB();</span><br><span class="line">        System.out.println(bb instanceof BB);// true</span><br><span class="line">        System.out.println(bb instanceof AA);// true</span><br><span class="line">        </span><br><span class="line">        //aa 编译类型 AA, 运行类型是 BB</span><br><span class="line">        //BB 是 AA 子类</span><br><span class="line">        AA aa = new BB();</span><br><span class="line">        System.out.println(aa instanceof AA); // true</span><br><span class="line">        System.out.println(aa instanceof BB); // true, 判断的是aa的运行类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一个题目</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">	int count = 10;</span><br><span class="line">	public void display()&#123;</span><br><span class="line">		System.out.println(this.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub extends Base &#123;</span><br><span class="line">	int count = 20;</span><br><span class="line">	public void display()&#123;</span><br><span class="line">		System.out.println(this.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class test &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Sub s = new Sub();</span><br><span class="line">		System.out.println(s.count);	// 20</span><br><span class="line">		s.display();	// 20</span><br><span class="line">		</span><br><span class="line">		Base b = s;	//向上转型</span><br><span class="line">		System.out.println(b == s);	//True，指向同一个对象</span><br><span class="line">		System.out.println(b.count);	//10 属性看编译类型</span><br><span class="line">		b.display();	// 20 方法看运行类型</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-10-4-java的动态绑定机制（非常重要！）"><a href="#8-10-4-java的动态绑定机制（非常重要！）" class="headerlink" title="8.10.4 java的动态绑定机制（非常重要！）"></a>8.10.4 java的动态绑定机制（非常重要！）</h3><ul>
<li><p><font color="red"><strong>当调用对象方法的时候，该方法会和对象的内存地址/运行类型绑定（动态绑定）</strong></font></p>
</li>
<li><p><strong><font color="red">当调用对象属性的时候，没有动态绑定机制，哪里声明，哪里使用</font></strong></p>
</li>
<li><p>第一个案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicBanding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();  <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="comment">// 分析</span></span><br><span class="line">        <span class="comment">/* 调用方法时看运行类型</span></span><br><span class="line"><span class="comment">        	a.sum()调用的是B类中的sum()，返回getI+i=20+20</span></span><br><span class="line"><span class="comment">        	a.sum1()同理 i+20=20+20=40</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(a.sum()); <span class="comment">// 40</span></span><br><span class="line">        System.out.println(a.sum1()); <span class="comment">// 40</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;   <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;   <span class="comment">//子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>第二个案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicBanding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();  <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="comment">// 分析</span></span><br><span class="line">        <span class="comment">/* 调用方法时看运行类型（动态绑定），子类中没有该方法则向上找父类</span></span><br><span class="line"><span class="comment">        a的运行类型是B，B中没有sum()方法，则调用父类A中的sum()方法。在A中的sum()方法中会调用</span></span><br><span class="line"><span class="comment">        getI()，这个getI()也会动态绑定运行类型，即调用B中的getI()。</span></span><br><span class="line"><span class="comment">        最终返回(B)getI+10=20+10=30</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        a的运行类型是B，B中没有sum1()方法，则调用父类A中的sum1()方法。属性i不会动态绑定</span></span><br><span class="line"><span class="comment">        返回(A)i+10=20</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(a.sum()); <span class="comment">// 30</span></span><br><span class="line">        System.out.println(a.sum1()); <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;   <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;	<span class="comment">//运行类型是B时，会调用B类的getI()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;   <span class="comment">//子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>第三个案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicBanding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();  <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="comment">// 分析</span></span><br><span class="line">        <span class="comment">/* 调用方法时看运行类型</span></span><br><span class="line"><span class="comment">        	a.sum()调用的是B类中的sum()，sum()会调用getI(),此时B类中没有getI()，</span></span><br><span class="line"><span class="comment">        	会向上查找调用父类A的getI()。属性没有动态绑定机制，A的getI()中返回的是A的i</span></span><br><span class="line"><span class="comment">        	最终结果 (A)getI+20 = (A)i+20 = 10+20 = 30</span></span><br><span class="line"><span class="comment">        	</span></span><br><span class="line"><span class="comment">        	a.sum1()返回(B)i+20 = 40</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(a.sum()); <span class="comment">// 30</span></span><br><span class="line">        System.out.println(a.sum1()); <span class="comment">// 40</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;   <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;   <span class="comment">//子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-11-多态的应用"><a href="#8-11-多态的应用" class="headerlink" title="8.11 多态的应用"></a>8.11 多态的应用</h2><h3 id="8-11-1-多态数组"><a href="#8-11-1-多态数组" class="headerlink" title="8.11.1 多态数组"></a>8.11.1 多态数组</h3><ul>
<li><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</p>
</li>
<li><p>案例：</p>
<ul>
<li>Person类：name, age, say()；</li>
<li>Student类：继承Person：score, 重写say()，特有study()；</li>
<li>Teacher类：继承Person，salary，重写say()，特有teach()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poly_.polyarr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyArr</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多态数组</span></span><br><span class="line">        Person[] persons = <span class="keyword">new</span> Person[<span class="number">5</span>];</span><br><span class="line">        persons[<span class="number">0</span>] = <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        persons[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">&quot;Mary&quot;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line">        persons[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">&quot;Smith&quot;</span>, <span class="number">19</span>, <span class="number">98</span>);</span><br><span class="line">        persons[<span class="number">3</span>] = <span class="keyword">new</span> Teacher(<span class="string">&quot;Scott&quot;</span>, <span class="number">30</span>, <span class="number">2000.0</span>);</span><br><span class="line">        persons[<span class="number">4</span>] = <span class="keyword">new</span> Teacher(<span class="string">&quot;King&quot;</span>, <span class="number">50</span>, <span class="number">40000.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; persons.length; i++) &#123;</span><br><span class="line">            <span class="comment">//persons[i]的编译类型时Person，运行类型根据实际情况由jvm判断</span></span><br><span class="line">            System.out.println(persons[i].say());   <span class="comment">//动态绑定机制</span></span><br><span class="line"><span class="comment">//            persons[i].teach();</span></span><br><span class="line"><span class="comment">//            persons[i].study()    //向上转型无法调用子类特有方法</span></span><br><span class="line">            <span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span> Student)&#123;  <span class="comment">// 判断persons[i]的运行类型是不是Student</span></span><br><span class="line">                ((Student)persons[i]).study();  <span class="comment">// 向下转型才能调用子类特有的方法</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(persons[i] <span class="keyword">instanceof</span> Teacher)&#123;  <span class="comment">// 判断persons[i]的运行类型是不是Teacher</span></span><br><span class="line">                ((Teacher)persons[i]).teach();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="8-11-2-多态参数"><a href="#8-11-2-多态参数" class="headerlink" title="8.11.2 多态参数"></a>8.11.2 多态参数</h3><ul>
<li>方法定义的形参类型为父类类型，实参类型为子类类型。</li>
<li>案例<ul>
<li>Employee类：name, salary, getAnnual( )</li>
<li>Worker类：特有work()</li>
<li>Manager类：bonus, 重写getAnnual( ), 特有manage( )</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.poly_.polyparameter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyParameter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Worker tom = <span class="keyword">new</span> Worker(<span class="string">&quot;tom&quot;</span>, <span class="number">2500</span>);</span><br><span class="line">        Manager willian = <span class="keyword">new</span> Manager(<span class="string">&quot;willian&quot;</span>, <span class="number">5000</span>, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">        PolyParameter polyParameter = <span class="keyword">new</span> PolyParameter();</span><br><span class="line">        polyParameter.showEmpAnnual(tom);   <span class="comment">//多态参数</span></span><br><span class="line">        polyParameter.showEmpAnnual(willian);</span><br><span class="line">        polyParameter.testWork(tom);   <span class="comment">//多态参数</span></span><br><span class="line">        polyParameter.testWork(willian);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showEmpAnnual</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e.getAnnual());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWork</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Worker) &#123;</span><br><span class="line">            ((Worker) e).work();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Manager) &#123;</span><br><span class="line">            ((Manager) e).manage();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不做处理&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="8-12-Object类详解"><a href="#8-12-Object类详解" class="headerlink" title="8.12 Object类详解"></a>8.12 Object类详解</h2><h3 id="8-12-1-equals方法"><a href="#8-12-1-equals方法" class="headerlink" title="8.12.1 equals方法"></a>8.12.1 equals方法</h3><ul>
<li><font color="red"><strong>==</strong></font> 比较运算符<ul>
<li>如果判断基本数据类型，判断的是<strong>值</strong>是否相等</li>
<li>如果判断引用数据类型，判断的是<strong>地址</strong>是否相等</li>
</ul>
</li>
</ul>
<ul>
<li><p><font color="red"><strong>equals方法</strong></font></p>
<ul>
<li><p>equals: 是Object类中的方法，只能判断引用类型，<strong>默认判断的是地址是否相等</strong>，<strong>子类中往往重写该方法，用于判断内容(值)是否相等</strong>。比如Integer,String【看看String 和 Integer的equals 源代码】</p>
</li>
<li><p>Object类中的equals</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span> == ojb); /默认比较两个引用地址是否相同（指向同一个对象）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>String中重写的equals</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;	<span class="comment">// 同一个对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;	<span class="comment">// 判断类型</span></span><br><span class="line">        String anotherString = (String)anObject;	<span class="comment">// 向下转型</span></span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;	<span class="comment">// 判断长度</span></span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;	<span class="comment">// 比较每一个字符</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Integer中重写的equals</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><font color="red">重写equals方法</font></strong></p>
<ul>
<li>重写Person类中的equals方法，当两个Person类的name, age, gender相同时，就返回true</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.object_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equals02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;jack&quot;</span>, <span class="number">10</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;jack&quot;</span>, <span class="number">10</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        System.out.println(person.equals(person1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">char</span> gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写equals（参考String中的equals）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)&#123;   <span class="comment">//如果是同一个对象直接返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123;    <span class="comment">//判断(运行)类型，是Person类才（能）比较</span></span><br><span class="line">            <span class="comment">// 进行向下转型 (为什么？obj的运行类型虽然判断为Person类，但是</span></span><br><span class="line">            <span class="comment">// 编译类型是Object,不能访问子类Person中特有的属性方法，需要向下转型)</span></span><br><span class="line">            Person p = (Person)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age &amp;&amp; <span class="keyword">this</span>.gender == p.gender;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-12-2-hashcode方法"><a href="#8-12-2-hashcode方法" class="headerlink" title="8.12.2 hashcode方法"></a>8.12.2 hashcode方法</h3><ul>
<li>6个结论<ul>
<li>提高具有哈希结构的容器的效率！如java.util.Hashtable中提供的哈希表</li>
<li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！</li>
<li>两个引用，如果指向的是不同对象，则哈希值是不一样的</li>
<li> 哈希值一般是通过该对象的内部地址转换成一个整数来实现的，不能完全将哈希值等价于地址。</li>
</ul>
</li>
</ul>
<ul>
<li><p>案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.object_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashCode_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AA aa = <span class="keyword">new</span> AA();</span><br><span class="line">        AA aa1 = <span class="keyword">new</span> AA();</span><br><span class="line">        AA aa2 = aa;</span><br><span class="line"></span><br><span class="line">        System.out.println(aa.hashCode());</span><br><span class="line">        System.out.println(aa1.hashCode());</span><br><span class="line">        System.out.println(aa2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1163157884</span></span><br><span class="line"><span class="comment">// 1956725890</span></span><br><span class="line"><span class="comment">// 1163157884</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-12-2-toString方法"><a href="#8-12-2-toString方法" class="headerlink" title="8.12.2 toString方法"></a>8.12.2 toString方法</h3><ul>
<li><p>默认返回：**<font color="red">全类名+@+哈希值的十六进制</font>**，子类往往重写 toString 方法，用于返回对象的属性信息</p>
</li>
<li><p>查看 Object 的 toString 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (1)getClass().getName() 类的全类名(包名+类名 )</span></span><br><span class="line"><span class="comment">// (2)Integer.toHexString(hashCode()) 将对象的 hashCode 值转成 16 进制字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重写toString方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> sal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monster</span><span class="params">(String name, String job, <span class="keyword">double</span> sal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.job = job;</span><br><span class="line">        <span class="keyword">this</span>.sal = sal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString，快捷键alt+insert</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Monster&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, job=&#x27;&quot;</span> + job + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sal=&quot;</span> + sal +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用</p>
<p>monster.toString()</p>
</li>
</ul>
<h3 id="8-12-3-finalize-方法"><a href="#8-12-3-finalize-方法" class="headerlink" title="8.12.3 finalize 方法"></a>8.12.3 finalize 方法</h3><ul>
<li>当对象被回收时，系统会自动调用该对象的finalize方法。子类可以重写该方法，做一些<strong>释放资源</strong>的操作。</li>
<li>什么时候回收：<strong>当某个对象没有任何引用时</strong>，则jvm就认为这个对象是一个垃圾对象，就会用垃圾回收机制来摧毁该对象，在摧毁该对象之前，会调用finalize方法。</li>
<li>垃圾回收机制的调用，是由系统来决定的（即有自己的GC算法），也可以通过<font color="red">System.gc()</font>主动触发垃圾回收机制。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.object_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Finalize_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car bmw = <span class="keyword">new</span> Car(<span class="string">&quot;宝马&quot;</span>);</span><br><span class="line">        bmw = <span class="keyword">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 主动调用垃圾回收器</span></span><br><span class="line">        <span class="comment">//这时候car对象没有任何引用，会被垃圾回收器回收（摧毁）</span></span><br><span class="line">        <span class="comment">//在销毁对象前，会调用该对象的 finalize 方法</span></span><br><span class="line">        <span class="comment">//程序员就可以在 finalize 中，写自己的业务逻辑代码(比如释放资源：数据库连接,或者打开文件..)</span></span><br><span class="line">        <span class="comment">//如果程序员不重写 finalize,那么就会调用 Object 类的 finalize, 即默认处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写finalize</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们销毁了&quot;</span> + name + <span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;释放了一些资源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-13-断点调试-debug"><a href="#8-13-断点调试-debug" class="headerlink" title="8.13 断点调试 debug"></a>8.13 断点调试 debug</h2><h3 id="8-13-1-介绍"><a href="#8-13-1-介绍" class="headerlink" title="8.13.1 介绍"></a>8.13.1 介绍</h3><ul>
<li>—步一步的看源码执行的过程,从而发现错误所在。</li>
<li><strong><font color="red">重要提示:</font></strong> 在断点调试过程中，是运行状态，是以对象的运行类型来执行的</li>
<li>断点调试是指在程序的某一行设置一个断点，<strong>调试时，程序运行到这一行时就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值</strong>，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个Bug</li>
<li>断点调试时程序员<strong>必须掌握的技能</strong></li>
<li>断点调试也能帮助我们查看java底层源代码的执行过程，提高程序员java水平</li>
</ul>
<h3 id="8-13-2-快捷键"><a href="#8-13-2-快捷键" class="headerlink" title="8.13.2  快捷键"></a>8.13.2  快捷键</h3><ul>
<li>F7跳入：跳入方法内</li>
<li>F8跳过：逐行执行代码</li>
<li>shift + F8：跳出方法</li>
<li>F9：resume执行到下一个断电</li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231009104027696.png" alt="image-20231009104027696"></p>
<h3 id="8-13-3-案例"><a href="#8-13-3-案例" class="headerlink" title="8.13.3 案例"></a>8.13.3 案例</h3><ul>
<li>使用断点调试，追踪对象创建的过程</li>
<li>使用断点调试，查看动态绑定机制如何工作</li>
</ul>
<h2 id="8-14-案例：零钱通"><a href="#8-14-案例：零钱通" class="headerlink" title="8.14 案例：零钱通"></a>8.14 案例：零钱通</h2><p>使用 Java 开发 零钱通项目 , 可以完成收益入账，消费，查看明细，退出系统等功能.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 先完成显示菜单，并可以选择</span><br><span class="line">2) 完成零钱通明细.</span><br><span class="line">3) 完成收益入账</span><br><span class="line">4) 消费</span><br><span class="line">5) 退出</span><br></pre></td></tr></table></figure>





<h1 id="第九章-项目：房屋出租系统"><a href="#第九章-项目：房屋出租系统" class="headerlink" title="第九章 项目：房屋出租系统"></a>第九章 项目：房屋出租系统</h1><h2 id="9-1-项目需求"><a href="#9-1-项目需求" class="headerlink" title="9.1 项目需求"></a>9.1 项目需求</h2><ul>
<li>实现基于文本界面的《房屋出租软件》</li>
<li>能够实现对房屋信息的添加、修改和删除（用数组实现），并能够打印房屋明细表</li>
</ul>
<h2 id="9-2-界面设计"><a href="#9-2-界面设计" class="headerlink" title="9.2  界面设计"></a>9.2  界面设计</h2><ul>
<li><p>主菜单</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231011095214080.png" alt="image-20231011095214080"></p>
</li>
<li><p>新增房屋</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231011095238934.png" alt="image-20231011095238934"></p>
</li>
<li><p>查找房屋<img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231011095306640.png" alt="image-20231011095306640"></p>
</li>
<li><p>删除房屋</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231011095332012.png" alt="image-20231011095332012"></p>
</li>
<li><p>修改房屋</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231011095347017.png" alt="image-20231011095347017"></p>
</li>
<li><p>房屋列表</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231011095358271.png" alt="image-20231011095358271"></p>
</li>
<li><p>退出系统</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231011095413116.png" alt="image-20231011095413116"></p>
</li>
</ul>
<h2 id="9-3-系统设计"><a href="#9-3-系统设计" class="headerlink" title="9.3 系统设计"></a>9.3 系统设计</h2><p>​    项目设计-程序框架图 (分层模式=&gt;当软件比较复杂，需要模式管理)</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231011100426182.png" alt="image-20231011100426182"></p>
<h2 id="9-4-系统实现"><a href="#9-4-系统实现" class="headerlink" title="9.4 系统实现"></a>9.4 系统实现</h2><h3 id="9-4-1-了解和使用工具库"><a href="#9-4-1-了解和使用工具库" class="headerlink" title="9.4.1 了解和使用工具库"></a>9.4.1 了解和使用工具库</h3><p>​    在实际开发中，公司都会提供相应的工具类和开发库，可以提高开发效率，程序员也需要能够看懂别人写的代码，并能够正确的调用。（造轮子的事情别人已经做好了）</p>
<ul>
<li><p>了解 Utility 类的使用</p>
</li>
<li><p> 测试 Utility 类</p>
</li>
<li><p>当作API使用，会用就行，有余力的可以读懂源码</p>
</li>
</ul>
<h3 id="9-4-2-完成House类"><a href="#9-4-2-完成House类" class="headerlink" title="9.4.2 完成House类"></a>9.4.2 完成House类</h3><p>编号 房主 电话 地址 月租 状态(未出租/已出租）</p>
<h3 id="9-4-3-显示主菜单和完成退出软件功能"><a href="#9-4-3-显示主菜单和完成退出软件功能" class="headerlink" title="9.4.3 显示主菜单和完成退出软件功能"></a>9.4.3 显示主菜单和完成退出软件功能</h3><p>实现功能的三部曲 [<strong>明确完成功能-&gt;思路分析-&gt;代码实现</strong>]</p>
<ul>
<li><p>功能说明: 用户打开软件，可以看到主菜单，可以退出软件. </p>
</li>
<li><p>思路分析: 在 HouseView.java 中，编写一个方法 mainMenu,显示菜单.</p>
</li>
</ul>
<h3 id="9-4-4-显示房屋列表的功能"><a href="#9-4-4-显示房屋列表的功能" class="headerlink" title="9.4.4 显示房屋列表的功能"></a>9.4.4 显示房屋列表的功能</h3><ul>
<li><p>功能说明: 用户输入对应的key，可以显示房屋信息列表</p>
</li>
<li><p>思路分析: </p>
<ul>
<li>在 HouseView.java 中，编写一个方法 <strong>listHouses</strong>显示房屋信息列表.</li>
<li>在HouseService.java中，编写一个方法<strong>list</strong>可以返回所有的房屋信息</li>
</ul>
</li>
</ul>
<h3 id="9-4-5-添加房屋信息的功能"><a href="#9-4-5-添加房屋信息的功能" class="headerlink" title="9.4.5 添加房屋信息的功能"></a>9.4.5 添加房屋信息的功能</h3><ul>
<li><p>功能说明：显示添加房屋信息的界面，用户输入相关信息，可以添加房屋信息到系统，新增的房屋id按照自增长来定</p>
</li>
<li><p>思路分析</p>
<ul>
<li>在 HouseView.java 中，编写一个方法 <strong>addHouse</strong>接收用户输入</li>
<li>在HouseService.java中，编写一个方法<strong>add</strong>可以添加新增的房屋信息到系统。<strong>需要判断数组容量是否满了</strong></li>
</ul>
</li>
</ul>
<h3 id="9-4-6-删除房屋信息的功能"><a href="#9-4-6-删除房屋信息的功能" class="headerlink" title="9.4.6 删除房屋信息的功能"></a>9.4.6 删除房屋信息的功能</h3><ul>
<li>功能说明：<ul>
<li>显示删除房屋信息的界面</li>
<li>用户输入房源编号（-1退出）</li>
<li>Y确认删除，N 取消</li>
</ul>
</li>
<li>思路分析<ul>
<li>在 HouseView.java 中，编写一个方法 <strong>delHouse</strong>接收用户输入id</li>
<li>在HouseService.java中，编写一个方法<strong>del</strong>可以根据房源id从系统中删除相关信息。<strong>需要判断该id是否存在</strong></li>
</ul>
</li>
</ul>
<h3 id="9-4-7-退出确认功能"><a href="#9-4-7-退出确认功能" class="headerlink" title="9.4.7 退出确认功能"></a>9.4.7 退出确认功能</h3><ul>
<li>功能说明：显示退出界面，根据用户输入确认是否退出</li>
</ul>
<h3 id="9-4-8-查找房屋信息功能"><a href="#9-4-8-查找房屋信息功能" class="headerlink" title="9.4.8 查找房屋信息功能"></a>9.4.8 查找房屋信息功能</h3><ul>
<li>功能说明：根据用户输入的id显示对应的房屋信息</li>
<li>思路分析：<ul>
<li>在 HouseView.java 中，编写一个方法 <strong>findHouse</strong>接收用户输入id，并显示房屋信息</li>
<li>在HouseService.java中，编写一个方法<strong>find</strong>可以根据房源id从系统中查找相关信息。</li>
</ul>
</li>
</ul>
<h3 id="9-4-9-修改房屋信息功能"><a href="#9-4-9-修改房屋信息功能" class="headerlink" title="9.4.9 修改房屋信息功能"></a>9.4.9 修改房屋信息功能</h3><ul>
<li>功能说明：根据用户输入的id显示原始房屋信息，并可以修改</li>
<li>思路分析：<ul>
<li>在 HouseView.java 中，编写一个方法 <strong>updateHouse</strong>接收用户输入id，并显示原始房屋信息。接收新的房屋信息。</li>
<li>在HouseService.java中，编写一个方法<strong>update</strong>可以根据用户输入的新信息进行更新</li>
</ul>
</li>
</ul>
<h1 id="—-第二阶段-—"><a href="#—-第二阶段-—" class="headerlink" title="— 第二阶段 —"></a>— 第二阶段 —</h1><h1 id="第十章-面向对象编程（高级）"><a href="#第十章-面向对象编程（高级）" class="headerlink" title="第十章 面向对象编程（高级）"></a>第十章 面向对象编程（高级）</h1><h2 id="10-1-类变量和类方法（static）"><a href="#10-1-类变量和类方法（static）" class="headerlink" title="10.1 类变量和类方法（static）"></a>10.1 类变量和类方法（static）</h2><h3 id="10-1-1-类变量快速入门"><a href="#10-1-1-类变量快速入门" class="headerlink" title="10.1.1 类变量快速入门"></a>10.1.1 类变量快速入门</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.static_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child child1 = <span class="keyword">new</span> Child(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        child1.join();</span><br><span class="line">        child1.count++;</span><br><span class="line">        Child child2 = <span class="keyword">new</span> Child(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        child2.join();</span><br><span class="line">        child1.count++;</span><br><span class="line">        Child child3 = <span class="keyword">new</span> Child(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        child3.join();</span><br><span class="line">        child1.count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类变量可以通过类名访问</span></span><br><span class="line">        System.out.println(<span class="string">&quot;共有&quot;</span> + Child.count + <span class="string">&quot;个小孩加入了游戏&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;child1.count=&quot;</span> + child1.count); <span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child2.count=&quot;</span> + child2.count); <span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child3.count=&quot;</span> + child3.count); <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 类变量（静态变量），被所有实例所共享</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有一个小孩加入&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-1-2-类变量内存布局"><a href="#10-1-2-类变量内存布局" class="headerlink" title="10.1.2 类变量内存布局"></a>10.1.2 类变量内存布局</h3><p>​    有不同说法：在堆中（jdk8以后）； 在方法区的静态域中。与jdk版本有关</p>
<ul>
<li>共识<ul>
<li><font color="red">static变量是同一个类的所有对象共享的</font></li>
<li><font color="red">static变量在类加载时就生成了</font></li>
</ul>
</li>
<li>参考文章<ul>
<li><a href="https://blog.csdn.net/x_iya/article/details/81260154/">https://blog.csdn.net/x_iya/article/details/81260154/</a></li>
<li><a href="https://www.zhihu.com/question/59174759/answer/163207831">https://www.zhihu.com/question/59174759/answer/163207831</a></li>
</ul>
</li>
</ul>
<h3 id="10-2-3-类变量基本介绍"><a href="#10-2-3-类变量基本介绍" class="headerlink" title="10.2.3 类变量基本介绍"></a>10.2.3 类变量基本介绍</h3><ol>
<li><p>概念</p>
<p>类变量也叫<strong>静态变量/静态属性</strong>，是<strong>该类的所有对象共享的</strong>变量,任何一个该类的对象去访问它时,取到的都是相同的值,同样任何一个该类的对象去修改它时,修改的也是同一个变量。</p>
</li>
<li><p>定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据类型 变量名; 【推荐】</span><br><span class="line"><span class="keyword">static</span> 访问修饰符 数据类型 变量名;</span><br></pre></td></tr></table></figure></li>
<li><p>访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.变量名; 【推荐】</span><br><span class="line">对象名.变量名;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="10-2-4-类变量注意事项"><a href="#10-2-4-类变量注意事项" class="headerlink" title="10.2.4 类变量注意事项"></a>10.2.4 类变量注意事项</h3><p>​    <div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li><p>什么时候需要用类变量</p>
<pre><code>当我们需要让某个类的**所有对象都共享一个变量时**，就可以考虑使用类变量(静态变量)，比如:定义学生类,统计所有学生共交多少钱。Student (name, static fee)
</code></pre>
</li>
<li><p>类变量与实例变量(普通属性)区别类变量是该类的所有对象共享的,而实例变量是每个对象独享的。类变量是该类的所有对象共享的，而实例变量是每个对象独享的.</p>
</li>
<li><p>加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量</p>
</li>
<li><p>类变量可以通过<strong>类名.变量名</strong>或者<strong>对象名.变量名</strong>来访问，但java设计者推荐类名.类变量名我们使用类名.类变量名方式访问。【前提是满足访问修饰符的访问权限和范围】</p>
</li>
<li><p>实例变量不能通过类名.类变量名方式访问。</p>
</li>
<li><p>类变量是<strong>在类加载时就初始化了</strong>，也就是说，即使你没有创建对象，只要类加载了,就可以使用类变量了。</p>
</li>
<li><p>类变量的生命周期是随类的加载开始,随着类消亡而销毁</p>
</li>
</ol>
<p>​    </p>
</div></p>
<h3 id="10-2-5-类方法基本介绍"><a href="#10-2-5-类方法基本介绍" class="headerlink" title="10.2.5 类方法基本介绍"></a>10.2.5 类方法基本介绍</h3><ol>
<li><p>概念</p>
<p>类方法也叫<strong>静态方法</strong>，是<strong>该类的所有对象共享的</strong>方法</p>
</li>
<li><p>定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 返回数据类型 方法名; 【推荐】</span><br><span class="line"><span class="keyword">static</span> 访问修饰符 返回数据类型 方法名;</span><br></pre></td></tr></table></figure></li>
<li><p>访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.方法名; 【推荐】</span><br><span class="line">对象名.方法名;</span><br></pre></td></tr></table></figure></li>
<li><p>快速入门</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.static_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stu t1 = <span class="keyword">new</span> Stu(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        Stu t2 = <span class="keyword">new</span> Stu(<span class="string">&quot;tom1&quot;</span>);</span><br><span class="line">        Stu t3 = <span class="keyword">new</span> Stu(<span class="string">&quot;tom2&quot;</span>);</span><br><span class="line">        t1.payFee(<span class="number">100</span>);</span><br><span class="line">        t2.payFee(<span class="number">200</span>);</span><br><span class="line">        t3.payFee(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        Stu.showFee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 静态变量累计学生交的学费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> fee = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">payFee</span><span class="params">(<span class="keyword">double</span> fee)</span> </span>&#123;</span><br><span class="line">        Stu.fee += fee; <span class="comment">//累计学费</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showFee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;总学费=&quot;</span> + Stu.fee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="10-2-5-类方法使用场景"><a href="#10-2-5-类方法使用场景" class="headerlink" title="10.2.5 类方法使用场景"></a>10.2.5 类方法使用场景</h3><p>如果我们希望不创建实例，也可以调用某个方法时（当做工具来使用）</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231012103815736.png" alt="image-20231012103815736"></p>
<h3 id="10-2-5-类方法注意事项"><a href="#10-2-5-类方法注意事项" class="headerlink" title="10.2.5 类方法注意事项"></a>10.2.5 类方法注意事项</h3><p>​    <div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在<strong>方法区</strong>。类方法中无this的参数，普通方法中隐含着this的参数</li>
<li>类方法可以通过类名调用，也可以通过对象名调用。</li>
<li>普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用。</li>
<li>类方法中不允许使用和对象有关的关键字，比如<strong>this和super</strong>。普通方法(成员方法)可以。</li>
<li>**<font color="red">类方法(静态方法)中只能访问静态成员（变量和方法）</font>**。</li>
<li><strong>普通方法，既可以访问非静态成员,也可以访问静态成员</strong>。</li>
</ol>
<p>​    </p>
</div></p>
<h2 id="10-2-main方法"><a href="#10-2-main方法" class="headerlink" title="10.2 main方法"></a>10.2 main方法</h2><h3 id="10-2-1-深入理解main方法"><a href="#10-2-1-深入理解main方法" class="headerlink" title="10.2.1 深入理解main方法"></a>10.2.1 深入理解main方法</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231012105301547.png" alt="image-20231012105301547"></p>
<h3 id="10-2-2-特别提示"><a href="#10-2-2-特别提示" class="headerlink" title="10.2.2 特别提示"></a>10.2.2 特别提示</h3><ul>
<li>在 main()方法中，我们<strong>可以直接调用 main 方法所在类的静态方法或静态属性</strong>。</li>
<li>但是，<strong>不能直接访问该类中的非静态成员</strong>，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.main_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.applet.Main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Durango&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态变量</span></span><br><span class="line">    <span class="keyword">private</span> String name1 = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 静态方法可以直接访问本类的静态成员</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        hi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 静态方法不可以直接访问本类的非静态成员</span></span><br><span class="line"><span class="comment">//        System.out.println(name1);</span></span><br><span class="line"><span class="comment">//        hi1();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法中要访问本类的静态成员，需要先创建本类对象，再调用</span></span><br><span class="line">        Main01 main01 = <span class="keyword">new</span> Main01();</span><br><span class="line">        System.out.println(main01.name1);</span><br><span class="line">        main01.hi1();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-2-2-在IDEA中给Main-传参"><a href="#10-2-2-在IDEA中给Main-传参" class="headerlink" title="10.2.2 在IDEA中给Main()传参"></a>10.2.2 在IDEA中给Main()传参</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231012142744360.png" alt="image-20231012142744360"></p>
<h2 id="10-3-代码块"><a href="#10-3-代码块" class="headerlink" title="10.3 代码块"></a>10.3 代码块</h2><h3 id="10-3-1-基本介绍"><a href="#10-3-1-基本介绍" class="headerlink" title="10.3.1 基本介绍"></a>10.3.1 基本介绍</h3><ul>
<li>代码化块又称为<strong>初始化块</strong>,属于类中的成员[即是类的一部分，类似于方法，将逻辑语句封装在方法体中，通过{ }包围起来</li>
<li>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。</li>
</ul>
<h3 id="10-3-2-基本语法"><a href="#10-3-2-基本语法" class="headerlink" title="10.3.2 基本语法"></a>10.3.2 基本语法</h3><ul>
<li>语法：【修饰符】{ 代码块内容 };</li>
<li>【修饰符】可选项，写的话只能写static。分为静态代码块和普通代码块。“；”可以省略</li>
</ul>
<h3 id="10-3-3-使用场景和好处"><a href="#10-3-3-使用场景和好处" class="headerlink" title="10.3.3 使用场景和好处"></a>10.3.3 使用场景和好处</h3><ul>
<li>相当于另外一种形式的构造器(对构造器的补充机制)，可以<strong>做初始化的操作</strong></li>
<li>场景: 如果多个构造器中都有重复的语句，可以抽取到初始化块中，<strong>提高代码的重用性</strong>。代码块调用的顺序优先于构造器</li>
</ul>
<h3 id="10-3-4-注意事项（重要！！）"><a href="#10-3-4-注意事项（重要！！）" class="headerlink" title="10.3.4 注意事项（重要！！）"></a>10.3.4 注意事项（重要！！）</h3><ul>
<li><p><font color="red">类加载时（3种情况）执行静态代码块，创建类对象时执行普通代码块</font></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231012150553113.png" alt="image-20231012150553113"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeBlockDetail01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类加载时会执行静态代码块，之后执行一次</span></span><br><span class="line">        <span class="comment">// 类加载的3种情况</span></span><br><span class="line">        <span class="comment">// 1. 创建类对象时</span></span><br><span class="line">        AA aa = <span class="keyword">new</span> AA();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建子类对象时，父类信息会先被加载</span></span><br><span class="line">        BB bb = <span class="keyword">new</span> BB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用类的静态成员时，也会加载类(其父类信息也会被加载)</span></span><br><span class="line">        System.out.println(CC.n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通代码块（只有）在创建类对象时会被调用；如果只是使用类的静态成员，则不会被调用</span></span><br><span class="line">        DD dd = <span class="keyword">new</span> DD();</span><br><span class="line">        DD dd1 = <span class="keyword">new</span> DD();</span><br><span class="line">        System.out.println(DD.n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AA类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> <span class="keyword">extends</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BB类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n1 = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CC类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DD</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DD类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DD类的普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">AA类的静态代码块</span><br><span class="line"></span><br><span class="line">BB类的静态代码块 <span class="comment">//这里由于父类AA已经加载过，不会再执行AA类的静态代码块</span></span><br><span class="line"></span><br><span class="line">CC类的静态代码块</span><br><span class="line"><span class="number">1000</span></span><br><span class="line">    </span><br><span class="line">DD类的静态代码块</span><br><span class="line">DD类的普通代码块</span><br><span class="line">DD类的普通代码块</span><br><span class="line"><span class="number">999</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><font color="red">调用顺序</font>（重点，难点）</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231012160942764.png" alt="image-20231012160942764"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeBlockDetail02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用顺序</span></span><br><span class="line">        <span class="comment">//1. 调用静态代码块和静态属性初始化</span></span><br><span class="line">        <span class="comment">//2. 调用普通代码块和普通属性初始化</span></span><br><span class="line">        <span class="comment">//3. 调用构造方法</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态属性初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n1 = getN1();</span><br><span class="line">    <span class="comment">//普通属性初始化</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> n2 = getN2();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行A类的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行A类的普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行A类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getN1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getN1被调用...静态属性初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getN2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getN2被调用...普通属性初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">getN1被调用...静态属性初始化</span><br><span class="line">执行A类的静态代码块</span><br><span class="line">getN2被调用...普通属性初始化</span><br><span class="line">执行A类的普通代码块</span><br><span class="line">执行A类的构造方法</span><br></pre></td></tr></table></figure>



<ul>
<li><p><font color="red">构造器前面其实隐含了super()、调用普通代码块和普通属性初始化！！！</font></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231012162629060.png" alt="image-20231012162629060"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeBlockDetail03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BBB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA类的普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AAA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA类构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBB</span> <span class="keyword">extends</span> <span class="title">AAA</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = getN();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用getN...普通属性初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBB类的普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BBB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构造器前面其实隐含了super()、调用普通代码块和普通属性初始化</span></span><br><span class="line">        <span class="comment">// super();</span></span><br><span class="line">        <span class="comment">// 调用BBB的普通代码块和普通属性初始化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;BBB类构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">AAA类的普通代码块</span><br><span class="line">AAA类的构造器被调用</span><br><span class="line">调用getN...普通属性初始化</span><br><span class="line">BBB类的普通代码块</span><br><span class="line">BBB类的构造器被调用</span><br></pre></td></tr></table></figure>



<ul>
<li><p>存在继承关系时，静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法调用顺序</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231012163641321.png" alt="image-20231012163641321"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeBlockDetail04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> CCCC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAAA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1 = getN1();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n2 = getN2();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AAAA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAA类的构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAA类的普通代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAA类的静态代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getN1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAA类的普通属性初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getN2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAA类的静态属性初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBBB</span> <span class="keyword">extends</span> <span class="title">AAAA</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n3 = getN3();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n4 = getN4();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BBBB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBB类的构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBB类的普通代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBB类的静态代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getN3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBB类的普通属性初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getN4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBB类的静态属性初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCCC</span> <span class="keyword">extends</span> <span class="title">BBBB</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n5 = getN5();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n6 = getN6();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CCCC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CCCC类的构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CCCC类的普通代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CCCC类的静态代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getN5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CCCC类的普通属性初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getN6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CCCC类的静态属性初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">AAAA类的静态属性初始化</span><br><span class="line">AAAA类的静态代码块被执行</span><br><span class="line">BBBB类的静态属性初始化</span><br><span class="line">BBBB类的静态代码块被执行</span><br><span class="line">CCCC类的静态属性初始化</span><br><span class="line">CCCC类的静态代码块被执行</span><br><span class="line"></span><br><span class="line">AAAA类的普通属性初始化</span><br><span class="line">AAAA类的普通代码块被执行</span><br><span class="line">AAAA类的构造器被调用</span><br><span class="line">BBBB类的普通属性初始化</span><br><span class="line">BBBB类的普通代码块被执行</span><br><span class="line">BBBB类的构造器被调用</span><br><span class="line">CCCC类的普通属性初始化</span><br><span class="line">CCCC类的普通代码块被执行</span><br><span class="line">CCCC类的构造器被调用</span><br></pre></td></tr></table></figure>



<h2 id="10-4-单例设计模式（static实践）"><a href="#10-4-单例设计模式（static实践）" class="headerlink" title="10.4 单例设计模式（static实践）"></a>10.4 单例设计模式（static实践）</h2><h3 id="10-4-1-设计模式"><a href="#10-4-1-设计模式" class="headerlink" title="10.4.1 设计模式"></a>10.4.1 设计模式</h3><p>​    <strong>是为解决软件设计中通用问题而被提出的一套指导性思想</strong>。它是一种被反复验证、经过实践证明并被广泛应用的<strong>代码设计经验和思想总结</strong>，可以帮助开发者通过一定的模式来快速的<strong>开发高质量、可维护性强</strong>的软件。</p>
<h3 id="10-4-2-单例模式"><a href="#10-4-2-单例模式" class="headerlink" title="10.4.2 单例模式"></a>10.4.2 单例模式</h3><ul>
<li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，<strong>对某个类只能存在一个对象实例</strong>, 并<strong>且该类只提供一个取得其对象实例的方法</strong></li>
</ul>
<h3 id="10-4-3-设计步骤"><a href="#10-4-3-设计步骤" class="headerlink" title="10.4.3 设计步骤"></a>10.4.3 设计步骤</h3><p>​    <div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>先将<strong>构造器私有化</strong>，防止外部直接new 对象</li>
<li>在类的内部<strong>直接创建一个静态对象</strong>（恶汉式：在属性处创建；懒汉式：在方法中创建）</li>
<li>向外部<strong>暴露一个公共的静态方法</strong>，返回这个对象实例</li>
</ol>
<p>​    </p>
</div></p>
<h3 id="10-4-4-恶汉式和懒汉式"><a href="#10-4-4-恶汉式和懒汉式" class="headerlink" title="10.4.4 恶汉式和懒汉式"></a>10.4.4 恶汉式和懒汉式</h3><ul>
<li><p>恶汉式（类加载时就创建了实例，存在资源浪费问题）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.single_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(GirlFriend.n1); <span class="comment">// 此时已经创建对象实例</span></span><br><span class="line"></span><br><span class="line">        GirlFriend instance = GirlFriend.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GirlFriend gf = <span class="keyword">new</span> GirlFriend(<span class="string">&quot;小花&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 饿汉式</span></span><br><span class="line">    <span class="comment">// 1. 先将构造器私有化</span></span><br><span class="line">    <span class="comment">// 2. 在类的内部直接创建一个静态对象</span></span><br><span class="line">    <span class="comment">// 3. 用公共的静态方法返回这个对象实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GirlFriend</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器被调用&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>懒汉式（类使用时才创建实例，存在线程安全问题）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.single_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Cat.n1); <span class="comment">// 此时不会创建对象实例</span></span><br><span class="line"></span><br><span class="line">        Cat cat = Cat.getInstance();    <span class="comment">// 会创建单例</span></span><br><span class="line">        System.out.println(cat.toString());</span><br><span class="line"></span><br><span class="line">        Cat cat1 = Cat.getInstance();    <span class="comment">// 不会重复创建实例</span></span><br><span class="line">        System.out.println(cat1.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(cat == cat1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n1 = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒汉式</span></span><br><span class="line">    <span class="comment">// 1. 先将构造器私有化</span></span><br><span class="line">    <span class="comment">// 2. 在类的内部（getInstance方法）直接创建一个静态对象</span></span><br><span class="line">    <span class="comment">// 3. 用公共的静态方法返回这个对象实例</span></span><br><span class="line">    <span class="comment">// 用户调用getInstance方法时才创建对象，重复调用会返回上次创建的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器被调用&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cat == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cat = <span class="keyword">new</span> Cat(<span class="string">&quot;小花&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231013162756514.png" alt="image-20231013162756514"></p>
</li>
</ul>
<h2 id="10-5-final关键字"><a href="#10-5-final关键字" class="headerlink" title="10.5 final关键字"></a>10.5 final关键字</h2><h3 id="10-5-1-基本介绍"><a href="#10-5-1-基本介绍" class="headerlink" title="10.5.1 基本介绍"></a>10.5.1 基本介绍</h3><ul>
<li>final可以修饰类、属性、方法、局部变量<ul>
<li>修饰类时，该类<strong>不能被继承</strong></li>
<li>修饰属性（成员变量）时，属性的值<strong>不能被修改</strong><ul>
<li>属性是基本数据类型，值是数值，不能被修改</li>
<li>属性是引用数据类型，值是地址，不能被修改</li>
</ul>
</li>
<li>修饰方法时，方法不能被重写/覆盖</li>
<li>修饰局部变量时，变量的值<strong>不能被修改</strong></li>
</ul>
</li>
</ul>
<h3 id="10-5-2-注意事项"><a href="#10-5-2-注意事项" class="headerlink" title="10.5.2 注意事项"></a>10.5.2 注意事项</h3><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>final修饰的属性又叫<strong>常量</strong>,一般用XX_XX_XX来命名</li>
<li>final修饰的属性<strong>在定义时,必须赋初值</strong>,并且以后不能再修改，赋值可以在如<br> 下位置之一【选择一个位置赋初值即可】:<br> ①定义时:如public final double TAX_RATE=0.08;     ②在构造器中    ③在代码块中。</li>
<li>如果final修饰的属性是静态的，则初始化的位置只能是  ①定义时    ②在静态代码块。不能在构造器中赋值。</li>
<li>final类不能继承,但是可以实例化对象。</li>
<li>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。</li>
<li>一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法。6) final不能修饰构造方法(即构造器</li>
<li>final和 static往往搭配使用，效率更高，<font color="red">不会导致类加载</font>！！！底层编译器做了优化处理。</li>
</ol>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.final_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(AAA.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line">    <span class="comment">// final修饰的属性必须赋初始值，赋值的位置有三个</span></span><br><span class="line">    <span class="comment">// 1. 定义时；2. 在构造器中 3. 在代码块中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> TAX_RATE = <span class="number">0.08</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> TAX_RATE2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> TAX_RATE3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TAX_RATE2 = <span class="number">0.09</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        TAX_RATE3 = <span class="number">0.07</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> </span>&#123;</span><br><span class="line">    <span class="comment">// final修饰的属性如果是static的，则初始化位置只能是</span></span><br><span class="line">    <span class="comment">// 1. 定义时；2. 在静态代码块中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> TAX_RATE = <span class="number">0.08</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> TAX_RATE1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        TAX_RATE1 = <span class="number">0.07</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> </span>&#123;</span><br><span class="line">    <span class="comment">// final和static搭配使用效率更高，不会导致类加载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBB类被加载，静态代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-6-抽象类"><a href="#10-6-抽象类" class="headerlink" title="10.6  抽象类"></a>10.6  抽象类</h2><h3 id="10-6-1-基本介绍"><a href="#10-6-1-基本介绍" class="headerlink" title="10.6.1 基本介绍"></a>10.6.1 基本介绍</h3><ul>
<li>当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象（abstract）方法, 那么这个类就是抽象类</li>
<li>抽象方法必须存在于抽象类中，用abstract关键字修饰。</li>
<li>抽象类的价值更多是在于设计，是设计者设计好后，让子类继承并实现抽象类()</li>
</ul>
<h3 id="10-6-2-注意事项-（面试常考）"><a href="#10-6-2-注意事项-（面试常考）" class="headerlink" title="10.6.2 注意事项 （面试常考）"></a>10.6.2 注意事项 （面试常考）</h3><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>抽象类<strong>不能被实例化</strong></li>
<li><strong>抽象类不一定要包含抽象方法；但是抽象方法一定要存在于抽象类</strong></li>
<li>abstract只能修饰类和方法，不能修饰属性和其他的</li>
<li>抽象类可以有任意成员，如非抽象方法、构造器、静态属性等等</li>
<li><strong>抽象方法不能有方法体</strong>，即不能实现</li>
<li><strong>如果一个类继承了抽象类，则他<font color="red">必须实现</font>抽象类的所有抽象方法</strong>，除非它还是声明为抽象类</li>
<li>抽象方法<strong>不能用private、final和static来修饰</strong>，这些关键字都是和重写相违背的</li>
</ol>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="10-7-模板设计模式（abstract实践）"><a href="#10-7-模板设计模式（abstract实践）" class="headerlink" title="10.7 模板设计模式（abstract实践）"></a>10.7 模板设计模式（abstract实践）</h2><ul>
<li><p>有不同的几个类，需要完成不同的job，但都需要计算完成job的时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AA().calculateTime();</span><br><span class="line">        <span class="keyword">new</span> BB().calculateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;   <span class="comment">// 模板类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">job</span><span class="params">()</span></span>; <span class="comment">// 模板方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        job();  <span class="comment">// 动态绑定机制</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;job执行了&quot;</span> + (end - start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">job</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">job</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            num -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10-8-接口（interface）"><a href="#10-8-接口（interface）" class="headerlink" title="10.8 接口（interface）"></a>10.8 接口（interface）</h2><h3 id="10-8-1-基本介绍"><a href="#10-8-1-基本介绍" class="headerlink" title="10.8.1 基本介绍"></a>10.8.1 基本介绍</h3><ul>
<li><p>接口就是给出一些没有实现的方法,封装到一起,到某个类要使用的时候,在根据具体情况把这些方法写出来</p>
</li>
<li><p>语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;</span><br><span class="line">	属性；</span><br><span class="line">	方法；（<span class="number">1.</span> 抽象方法【<span class="keyword">abstract</span>可以省略】； <span class="number">2.</span>默认实现方法【<span class="keyword">default</span>】；<span class="number">3.</span>静态方法【<span class="keyword">static</span>】）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名 </span>&#123;</span><br><span class="line">	自己的属性；</span><br><span class="line">	自己的方法；</span><br><span class="line">	必须实现的接口的抽象方法；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>小结</p>
<ul>
<li><p>在JDK7以前，接口里的方法都是抽象方法，没有方法体</p>
</li>
<li><p>在JDK8以后，接口里面也可以有<strong>静态方法、默认方法</strong>（default），也就是说可以有方法具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//jdk8以后可以有默认方法和静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="10-8-2-应用场景"><a href="#10-8-2-应用场景" class="headerlink" title="10.8.2 应用场景"></a>10.8.2 应用场景</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231014101020720.png" alt="image-20231014101020720"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231014101059395.png" alt="image-20231014101059395"></p>
<ul>
<li><p>举例：项目需要实现对三个不同数据库的连接操作，如果直接编写三个连接的类，类中的连接方法名可能不统一；在项目使用数据库时，需要<strong>重载</strong>三种不同形参类型的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.durango.interface_;</span><br><span class="line"></span><br><span class="line">public class Interface03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DBManager manager = new DBManager();</span><br><span class="line">        manager.toDatabase(new MysqlDB());</span><br><span class="line">        manager.toDatabase(new OracleDB());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DBManager &#123;</span><br><span class="line">    public void toDatabase(DBInterface dbInterface) &#123;</span><br><span class="line">        dbInterface.connect();</span><br><span class="line">        dbInterface.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MysqlDB implements DBInterface &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void connect() &#123;</span><br><span class="line">        System.out.println(&quot;连接Mysql数据库&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        System.out.println(&quot;关闭Mysql数据库&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OracleDB implements DBInterface &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void connect() &#123;</span><br><span class="line">        System.out.println(&quot;连接Oracle数据库&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        System.out.println(&quot;关闭Oracle数据库&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-8-3-注意事项"><a href="#10-8-3-注意事项" class="headerlink" title="10.8.3 注意事项"></a>10.8.3 注意事项</h3><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>接口<strong>不能被实例化</strong></li>
<li>接口中所有**<font color="red">方法都是public的</font>**（可以省略public），接口中的抽象方法可以不用abstract修饰</li>
<li>普通类实现接口，就必须实现接口中的所有抽象方法。快捷键 alt+enter</li>
<li>抽象类实现接口，可以不用实现接口中的抽象方法</li>
<li>一个类可以<strong>实现多个接口</strong>。</li>
<li>接口中的**<font color="red">属性是public static final的</font>**，比如 int n1 = 100 实际上是 public static final int n1 = 100;（必须初始化）。实现了接口的类也可以调用接口中的属性，但是不能修改。</li>
<li>接口不能继承其他的类，但是可以<strong>继承多个别的接口</strong></li>
<li>接口的修饰符只能是public和默认，这点和类的修饰符是一样的</li>
</ol>
</div>



<h3 id="10-8-4-实现接口-VS-继承类"><a href="#10-8-4-实现接口-VS-继承类" class="headerlink" title="10.8.4 实现接口 VS 继承类"></a>10.8.4 实现接口 VS 继承类</h3><ol>
<li>接口和继承解决的问题不同<ul>
<li>继承的价值在于：解决代码的<strong>复用性和可维护性</strong></li>
<li>接口的价值在于：设计并<strong>设计好各种规范</strong>（方法），让其他类去实现这些方法，即更加灵活</li>
</ul>
</li>
<li>接口比继承更加灵活<ul>
<li>继承是 is-a 的关系</li>
<li>接口是 like-a 的关系</li>
</ul>
</li>
<li>接口在一定程度上实现了代码解耦 【接口规范性+动态绑定】</li>
</ol>
<h3 id="10-8-5-接口的多态特性"><a href="#10-8-5-接口的多态特性" class="headerlink" title="10.8.5 接口的多态特性"></a>10.8.5 接口的多态特性</h3><ul>
<li><p><font color="red">多态参数</font></p>
<ul>
<li><strong>接口的引用可以指向实现了接口的类的对象</strong>，比如在前面的连接数据库案例中，DBInterface dbInterface既可以接收MysqlDB，也可以接收OrcalDB</li>
</ul>
</li>
<li><p><font color="red">多态数组</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">USBInterface[] usbs = <span class="keyword">new</span> USBInterface[<span class="number">2</span>];</span><br><span class="line">usbs[<span class="number">0</span>] = <span class="keyword">new</span> Phone();</span><br><span class="line">usbs[<span class="number">1</span>] = <span class="keyword">new</span> Camera();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; usbs.length; i++) &#123;</span><br><span class="line">    usbs[i].start();    <span class="comment">// 动态绑定</span></span><br><span class="line">    <span class="keyword">if</span> (usbs[i] <span class="keyword">instanceof</span> Phone) &#123;</span><br><span class="line">        ((Phone) usbs[i]).call();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (usbs[i] <span class="keyword">instanceof</span> Camera) &#123;</span><br><span class="line">        ((Camera) usbs[i]).photo();</span><br><span class="line">    &#125;</span><br><span class="line">    usbs[i].end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color="red">多态传递</font></p>
<ul>
<li>接口的父级接口的引用也可以指向实现了该接口的类的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfacePolyPass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Teacher实现了IG，IG继承了IH。</span></span><br><span class="line">        IG ig = <span class="keyword">new</span> Teacher();</span><br><span class="line">        IH ih = <span class="keyword">new</span> Teacher();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IH</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IG</span> <span class="keyword">extends</span> <span class="title">IH</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">IG</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10-9-内部类"><a href="#10-9-内部类" class="headerlink" title="10.9 内部类"></a>10.9 内部类</h2><h3 id="10-9-1-基本介绍"><a href="#10-9-1-基本介绍" class="headerlink" title="10.9.1 基本介绍"></a>10.9.1 基本介绍</h3><ul>
<li><p>类的五大成员：属性；方法；构造器；代码块；<strong>内部类</strong></p>
</li>
<li><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。内部类的最大特点：<strong>可以直接访问私有属性，并且可以体现类与类之间的包含关系</strong></p>
</li>
<li><p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;	<span class="comment">// 外部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;	<span class="comment">// 内部类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;	<span class="comment">// 外部其他类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-9-2-分类"><a href="#10-9-2-分类" class="headerlink" title="10.9.2 分类"></a>10.9.2 分类</h3><ul>
<li>定义在外部类<strong>局部位置</strong>上（比如方法内，代码块中），本质是局部变量<ul>
<li>局部内部类（有类名）</li>
<li>匿名内部类（无类名，重点！！！）</li>
</ul>
</li>
<li>定义在外部类<strong>成员位置</strong>上，本质是类的成员<ul>
<li>成员内部类（没有static修饰）</li>
<li>静态内部类（使用static修饰）</li>
</ul>
</li>
</ul>
<h3 id="10-9-3-局部内部类"><a href="#10-9-3-局部内部类" class="headerlink" title="10.9.3 局部内部类"></a>10.9.3 局部内部类</h3><ol>
<li>可以<strong>直接访问</strong>外部类的所有成员,包含私有的</li>
<li><strong>不能添加访问修饰符</strong>, 因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰, 因为局部变量也可以使用final</li>
<li><strong>作用域</strong>: 仅仅在<strong>定义它的方法或代码块中</strong>。</li>
<li>局部内部类—访问—-&gt;外部类的成员，访问方式:<strong>直接访问</strong></li>
<li>外部类—&gt;访问—-&gt;局部内部类的成员，访问方式:<strong>创建对象, 再访问</strong>(注意:<strong>必须在作用域内</strong>)<ul>
<li>(1)局部内部类定义在方法中/代码块</li>
<li>(2)作用域在方法体或者代码块中    </li>
<li>(3)本质仍然是个类</li>
</ul>
</li>
<li>外部其他类—不能访问—–&gt;局部内部类（因为局部内部类地位是一个<strong>局部变量</strong>)</li>
<li>如果外部类和局部内部类的成员重名时，默认遵循<strong>就近原则</strong>，如果想访问外部类的成员，则可以使用**<font color="red">(外部类名.this.成员</font>**)去访问【演示】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.innerclass_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer02 outer02 = <span class="keyword">new</span> Outer02();</span><br><span class="line">        outer02.m1();</span><br><span class="line">        System.out.println(<span class="string">&quot;outer02的hashcode=&quot;</span> + outer02.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer02 m2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部内部类：</span></span><br><span class="line">    <span class="comment">// 1. 可以直接访问外部类成员（包括私有）</span></span><br><span class="line">    <span class="comment">// 2. 不能添加访问修饰符，相当于局部变量，可以加final修饰</span></span><br><span class="line">    <span class="comment">// 3. 作用域，定义它的方法或代码块中</span></span><br><span class="line">    <span class="comment">// 4. 外部类访问内部类成员，需要new对象。注意必须在作用域中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner02</span> </span>&#123; <span class="comment">//方法中的局部内部类</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">200</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;n1=&quot;</span> + n1); <span class="comment">//遵循就近原则</span></span><br><span class="line">                <span class="comment">// Outer02.this本质是外部类的对象，哪个对象调用了m1，Outer02.this就指向哪个对象</span></span><br><span class="line">                System.out.println(<span class="string">&quot;外部类的n1=&quot;</span> + Outer02.<span class="keyword">this</span>.n1);</span><br><span class="line">                System.out.println(<span class="string">&quot;Outer02.this的hashcode=&quot;</span> + Outer02.<span class="keyword">this</span>.hashCode());</span><br><span class="line">                m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m2();</span><br><span class="line">        <span class="keyword">new</span> Inner02().f1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner03</span> </span>&#123;  <span class="comment">//代码块中的局部内部类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line"><span class="function">Outer02 <span class="title">m2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">n1</span>=<span class="number">200</span></span><br><span class="line">外部类的n1=<span class="number">100</span></span><br><span class="line">Outer02.<span class="keyword">this</span>的hashcode=<span class="number">1163157884</span></span><br><span class="line"><span class="function">Outer02 <span class="title">m2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">outer02的hashcode</span>=<span class="number">1163157884</span></span><br></pre></td></tr></table></figure>



<h3 id="10-9-4-匿名内部类（重要！！！）"><a href="#10-9-4-匿名内部类（重要！！！）" class="headerlink" title="10.9.4 匿名内部类（重要！！！）"></a>10.9.4 匿名内部类（重要！！！）</h3><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>（1）本质是类；（2）内部类；（3）该类没有名字；（4）同时还是一个对象<ul>
<li><font color="red">new 类或接口（参数列表）{ 类体 };</font></li>
</ul>
</li>
<li>因为匿名内部类<strong>既是一个类的定义，同时它本身也是一个对象</strong>，因此从语法上看，它既有定义类的特征，也有创建对象的特征。调用匿名内部类的成员有两种方式：赋值后调用；直接调用。</li>
<li>可以直接访问外部类成员，包括私有的</li>
<li>不能添加访问修饰符，本质是一个局部变量，可以加final修饰</li>
<li>作用域：定义它的方法或代码块中</li>
<li>匿名内部类 –&gt; 访问 –&gt; 外部类 成员 : 直接访问</li>
<li> 外部类 –&gt; 访问 –&gt; 匿名内部类 成员：new对象赋值后调用； new对象直接调用</li>
<li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则,如果想访问外部类的成员，则可以使用(<strong>外部类名.this.成员</strong>)去访问</li>
<li>底层给匿名内部类分配的名字为：<strong>外部类名$X</strong>，可以用**getClass()**查看，即运行类型</li>
</ol>
</div>



<ul>
<li><p>基于接口实现的匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.innerclass_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer04 outer04 = <span class="keyword">new</span> Outer04();</span><br><span class="line">        outer04.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基于接口的匿名内部类</span></span><br><span class="line">        <span class="comment">// 1. 需求：使用A接口，并创建对象</span></span><br><span class="line">        <span class="comment">// 2. 传统做法：写一个类实现A接口，然后创建这个类的对象</span></span><br><span class="line">        <span class="comment">// 3. 需求是 Tiger/Dog 类只是使用一次，后面不再使用</span></span><br><span class="line">        <span class="comment">// 4. 可以使用匿名内部类来简化开发</span></span><br><span class="line">        <span class="comment">// 5. tiger 的编译类型 ? A</span></span><br><span class="line">        <span class="comment">// 6. tiger 的运行类型 ? 就是匿名内部类 (名字由jvm分配为Outer04$1)</span></span><br><span class="line">        <span class="comment">// 7. jvm底层在创建匿名内部类Outer04$1，并创建了Outer04$1实例把地址返回给tiger</span></span><br><span class="line">        <span class="comment">// 8. 这个匿名内部类只能使用一次，是指不能再创建这个匿名内部类的实例了。</span></span><br><span class="line">        <span class="comment">//    tiger是已经创建的唯一匿名内部类对象，可以使用多次</span></span><br><span class="line">        A tiger = <span class="keyword">new</span> A() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎叫唤&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;tiger的运行类型=&quot;</span> + tiger.getClass());</span><br><span class="line">        tiger.cry();</span><br><span class="line">        tiger.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">tiger的运行类型=<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">durango</span>.<span class="title">innerclass_</span>.<span class="title">Outer04</span>$1</span></span><br><span class="line"><span class="class">老虎叫唤</span></span><br><span class="line"><span class="class">老虎叫唤</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>基于类或抽象类继承的匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.innerclass_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer04 outer04 = <span class="keyword">new</span> Outer04();</span><br><span class="line">        outer04.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基于类的匿名内部类</span></span><br><span class="line">        <span class="comment">// 1. father 编译类型 Father</span></span><br><span class="line">        <span class="comment">// 2. father 运行类型 Outer04$2</span></span><br><span class="line">        <span class="comment">// 3. 底层会创建匿名内部类Outer04$2继承Father，并创建Outer04$2实例返回给father</span></span><br><span class="line">        Father father = <span class="keyword">new</span> Father(<span class="string">&quot;jack&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是匿名内部类的Test&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;father对象的运行类型=&quot;</span> + father.getClass());</span><br><span class="line">        father.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是Father的test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">接收到name</span><br><span class="line">father对象的运行类型=<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">durango</span>.<span class="title">innerclass_</span>.<span class="title">Outer04</span>$2</span></span><br><span class="line"><span class="class">这是匿名内部类的<span class="title">Test</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>调用匿名内部类的成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer05</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先赋值再调用</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了hi方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.hi(); <span class="comment">//动态绑定，运行类型时Outer05$1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以直接调用，匿名内部类创建类并返回了一个实例</span></span><br><span class="line">        <span class="keyword">new</span> Person()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了hi方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-9-5-匿名内部类最佳实践"><a href="#10-9-5-匿名内部类最佳实践" class="headerlink" title="10.9.5 匿名内部类最佳实践"></a>10.9.5 匿名内部类最佳实践</h3><ul>
<li><p><strong><font color="red">匿名内部类当作实参直接传递，简洁高效</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.innerclass_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassExercise01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名内部类当做实参直接传递</span></span><br><span class="line">        f1(<span class="keyword">new</span> IL() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类当做实参直接传递&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传统方式</span></span><br><span class="line">        f1(<span class="keyword">new</span> Tr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法，形参是接口类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(IL il)</span> </span>&#123;</span><br><span class="line">        il.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IL</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tr</span> <span class="keyword">implements</span> <span class="title">IL</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传统方式，实现接口再传参&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>形参有多个接口，<strong>实参可以是多个匿名内部类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.innerclass_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassExercise02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CellPhone cp = <span class="keyword">new</span> CellPhone();</span><br><span class="line">        cp.alarmClock(<span class="keyword">new</span> Bell() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;懒猪起床了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Bell() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;上班要迟到了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ring</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CellPhone</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 形参是接口类型，实参可以用匿名内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarmClock</span><span class="params">(Bell b1, Bell b2)</span></span>&#123;</span><br><span class="line">        b1.ring();</span><br><span class="line">        System.out.println(b1.getClass());</span><br><span class="line">        b2.ring();</span><br><span class="line">        System.out.println(b2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">懒猪起床了</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">durango</span>.<span class="title">innerclass_</span>.<span class="title">InnerClassExercise02</span>$1</span></span><br><span class="line"><span class="class">上班要迟到了</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">com</span>.<span class="title">durango</span>.<span class="title">innerclass_</span>.<span class="title">InnerClassExercise02</span>$2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-9-6-成员内部类"><a href="#10-9-6-成员内部类" class="headerlink" title="10.9.6 成员内部类"></a>10.9.6 成员内部类</h3><ol>
<li><p>可以直接访问外部类成员，包括私有的</p>
</li>
<li><p>可以添加任意访问修饰符，本质是类的成员</p>
</li>
<li><p>作用域：定义它的整个类体</p>
</li>
<li><p>成员内部类访问外部类成员：直接访问</p>
</li>
<li><p>外部类访问内部类成员：创建对象访问</p>
</li>
<li><p>成员重名时遵循就近原则，可以通过 外部类名.this.成员 访问外部成员</p>
</li>
<li><p>外部其他类 可以 访问 内部类：有两种方式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberInnerClass01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer08 outer08 = <span class="keyword">new</span> Outer08();</span><br><span class="line">        outer08.hi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外部其他类，使用成员内部类的三种方式(遵循访问权限)</span></span><br><span class="line">        <span class="comment">// 1. new Outer08().new Inner08()相当于把new Inner08()当做是new Outer08()的成员</span></span><br><span class="line">        Outer08.Inner08 inner08 = <span class="keyword">new</span> Outer08().<span class="function">new <span class="title">Inner08</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 在外部类中编写一个方法，放回Inner08的实例</span></span><br><span class="line">        Outer08.Inner08 inner08_1 = <span class="keyword">new</span> Outer08().getInner();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer08</span> </span>&#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner08</span> </span>&#123;  <span class="comment">// 可以添加访问修饰符</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">99</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 可以直接访问外部类成员，包括私有的</span></span><br><span class="line">            System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1 + <span class="string">&quot; name=&quot;</span> + name);</span><br><span class="line">            <span class="comment">// 重名时遵守就近原则，通过&quot;外部类.this.成员&quot;访问外部类成员</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Outer n1=&quot;</span>+Outer08.<span class="keyword">this</span>.n1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 成员内部类的作用域是定义它的整个类体</span></span><br><span class="line">        <span class="comment">// 外部类访问内部类成员，需要new对象</span></span><br><span class="line">        Inner08 inner08 = <span class="keyword">new</span> Inner08();</span><br><span class="line">        inner08.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner08 <span class="title">getInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner08();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="10-9-6-静态内部类"><a href="#10-9-6-静态内部类" class="headerlink" title="10.9.6 静态内部类"></a>10.9.6 静态内部类</h3><ol>
<li><p>可以直接访问外部类<strong>静态的</strong>成员，包括私有的。不能访问外部类非静态成员</p>
</li>
<li><p>可以添加任意访问修饰符，本质是类的成员</p>
</li>
<li><p>作用域：定义它的整个类体</p>
</li>
<li><p>成员内部类访问外部类<strong>静态的</strong>成员：直接访问</p>
</li>
<li><p>外部类访问静态内部类成员：创建对象访问</p>
</li>
<li><p>成员重名时遵循就近原则，可以通过 <strong><font color="red">外部类名.成员</font></strong> 访问外部成员</p>
</li>
<li><p>外部其他类 可以 访问 静态内部类：有两种方式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberInnerClass02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 外部其他类访问静态内部类</span></span><br><span class="line">        <span class="comment">// 1. 静态成员可以直接通过类名访问Outer09.Inner09(),无需创建外部类对象</span></span><br><span class="line">        Outer09.Inner09 inner09 = <span class="keyword">new</span> Outer09.Inner09();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.编写一个(静态)方法，可以返回静态内部类的对象实例</span></span><br><span class="line">        Outer09.Inner09 inner09_1 = <span class="keyword">new</span> Outer09().getInner();</span><br><span class="line">        Outer09.Inner09 inner09_2 = Outer09.getInner_();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer09</span> </span>&#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner09</span> </span>&#123;  <span class="comment">// 可以添加访问修饰符</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> n1 = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 可以直接访问外部类的静态成员(不能访问非静态成员)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1 + <span class="string">&quot; name=&quot;</span> + name);</span><br><span class="line">            <span class="comment">// 重名时遵守就近原则，通过&quot;外部类.成员&quot;访问外部类成员</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Outer n1=&quot;</span> + Outer09.n1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态内部类的作用域是定义它的整个类体</span></span><br><span class="line">        <span class="comment">// 外部类访问静态内部类成员，需要new对象</span></span><br><span class="line">        Inner09 inner09 = <span class="keyword">new</span> Inner09();</span><br><span class="line">        inner09.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner09 <span class="title">getInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner09();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Inner09 <span class="title">getInner_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner09();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第十一章-枚举和注解"><a href="#第十一章-枚举和注解" class="headerlink" title="第十一章 枚举和注解"></a>第十一章 枚举和注解</h1><h2 id="11-1-自定义类实现枚举"><a href="#11-1-自定义类实现枚举" class="headerlink" title="11.1 自定义类实现枚举"></a>11.1 自定义类实现枚举</h2><ol>
<li><p><strong>构造器私有化</strong>，防止直接new对象</p>
</li>
<li><p>本类<strong>内部创建一组对象</strong> [四个 春夏秋冬]</p>
</li>
<li><p>对外<strong>暴露对象</strong>（通过为对象添加 public final static 修饰符）</p>
</li>
<li><p><strong>可以提供 get 方法</strong>，但是不要提供 set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义了四个对象, 固定.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="11-2-enum关键字实现枚举"><a href="#11-2-enum关键字实现枚举" class="headerlink" title="11.2 enum关键字实现枚举"></a>11.2 enum关键字实现枚举</h2><h3 id="11-2-1-说明"><a href="#11-2-1-说明" class="headerlink" title="11.2.1 说明"></a>11.2.1 说明</h3><ol>
<li>用enum关键字替代class</li>
<li>将定义的常量对象写在最前面，<strong>常量名（实参列表）</strong>，多个常量用 “<strong>，</strong>”隔开</li>
<li>最后加上构造器和get方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumeration02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Season2.SPRING);	<span class="comment">//春天</span></span><br><span class="line">        Season2 spring1 = Season2.SPRING;</span><br><span class="line">        Season2 spring2 = Season2.SPRING;</span><br><span class="line">        System.out.println(spring1 == spring2);	<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 enum 来实现枚举类</span></span><br><span class="line"><span class="comment">//1. 使用关键字 enum 替代 class</span></span><br><span class="line"><span class="comment">//2. public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;) 直接替换成</span></span><br><span class="line"><span class="comment">// SPRING(&quot;春天&quot;, &quot;温暖&quot;) 解读 常量名(实参列表)</span></span><br><span class="line"><span class="comment">//3. 如果有多个常量(对象)， 使用 ,号间隔即可</span></span><br><span class="line"><span class="comment">//4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面</span></span><br><span class="line"><span class="comment">//5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season2</span> </span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>),	<span class="comment">//调用有参构造器</span></span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>),</span><br><span class="line">    Other;	<span class="comment">//调用无参构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season2</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-2-2-注意事项"><a href="#11-2-2-注意事项" class="headerlink" title="11.2.2 注意事项"></a>11.2.2 注意事项</h3><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>当我们使用 enum 关键字开发一个枚举类时，默认会<strong>继承 Enum 类</strong>, 而且是一个 final 类[如何证明],使用 javap 工具来演示</li>
</ol>
<ol start="2">
<li><p>传统的 public static final Season2 SPRING = new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)， 这里必须知道，它调用的是哪个构造器. </p>
</li>
<li><p>如果使用无参构造器 创建 枚举对象，则<strong>实参列表和小括号都可以省略</strong></p>
</li>
<li><p>当有多个枚举对象时，<strong>使用”,”间隔，最后有一个分号结尾</strong></p>
</li>
<li><p>枚举对象必须放在枚举类的行首</p>
</li>
</ol>
</div>



<h3 id="11-2-3-Enum类常用方法"><a href="#11-2-3-Enum类常用方法" class="headerlink" title="11.2.3 Enum类常用方法"></a>11.2.3 Enum类常用方法</h3><ul>
<li>说明：使用关键字 enum 时，会隐式继承 Enum 类, 这样我们就可以使用 Enum 类相关的方法。</li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231018101743063.png" alt="image-20231018101743063"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season2 autumn = Season2.AUTUMN;</span><br><span class="line"></span><br><span class="line">        System.out.println(autumn.name());  <span class="comment">//枚举对象的名称（常量名）</span></span><br><span class="line">        System.out.println(autumn.ordinal());   <span class="comment">//枚举对象的次序</span></span><br><span class="line"></span><br><span class="line">        Season2[] values = Season2.values();    <span class="comment">// 返回所有枚举对象的数组</span></span><br><span class="line">        <span class="keyword">for</span> (Season2 season : values) &#123;</span><br><span class="line">            System.out.println(season.name());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据输入字符串查找对应的枚举对象</span></span><br><span class="line">        Season2 winter = Season2.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">        System.out.println(winter.name());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较两个枚举常量的编号 self.ordinal - other.ordinal</span></span><br><span class="line">        System.out.println(autumn.compareTo(winter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-2-4-enum实现接口"><a href="#11-2-4-enum实现接口" class="headerlink" title="11.2.4 enum实现接口"></a>11.2.4 enum实现接口</h3><ul>
<li>使用 enum 关键字后，就<strong>不能再继承其它类</strong>了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制。</li>
<li>枚举类和普通类一样，<strong>可以实现接口</strong>，如下形式。enum 类名 implements 接口 1，接口 2{}</li>
</ul>
<h2 id="11-3-注解（Annotation）"><a href="#11-3-注解（Annotation）" class="headerlink" title="11.3 注解（Annotation）"></a>11.3 注解（Annotation）</h2><ul>
<li><p>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。</p>
</li>
<li><p>和注释一样，注解不影响程序逻辑，<strong>但注解可以被编译或运行</strong>，<strong>相当于嵌入在代码中的补充信息</strong>。</p>
</li>
<li><p>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。</p>
</li>
</ul>
<h2 id="11-4-三个基本的Annotation"><a href="#11-4-三个基本的Annotation" class="headerlink" title="11.4 三个基本的Annotation"></a>11.4 三个基本的Annotation</h2><ol>
<li><p><strong>@Override</strong>: 限定某个方法，是重写父类方法, 该注解只能用于方法</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019093232279.png" alt="image-20231019093232279"></p>
</li>
<li><p><strong>@Deprecated</strong>: 用于表示某个程序元素(类, 方法等)已过时</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019093638120.png" alt="image-20231019093638120"></p>
</li>
<li><p><strong>@SuppressWarnings</strong>: 抑制编译器警告</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019094220353.png" alt="image-20231019094220353"></p>
<ul>
<li>(1) 放置的位置就是 TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE</li>
<li>(2) 该注解类有数组 String[] values() 设置一个数组比如 {“rawtypes”, “unchecked”, “unused”}</li>
</ul>
</li>
</ol>
<h2 id="11-5-JDK的元注解（了解）"><a href="#11-5-JDK的元注解（了解）" class="headerlink" title="11.5 JDK的元注解（了解）"></a>11.5 JDK的元注解（了解）</h2><h3 id="11-5-1-基本介绍"><a href="#11-5-1-基本介绍" class="headerlink" title="11.5.1 基本介绍"></a>11.5.1 基本介绍</h3><ul>
<li>JDK 的元 Annotation 用于修饰其他 Annotation</li>
<li>四种<ul>
<li><strong>Retention</strong> //指定注解的作用时间范围，三种 SOURCE,CLASS,RUNTIME</li>
<li><strong>Target</strong> // 指定注解可以在哪些地方使用</li>
<li><strong>Documented</strong> //指定该注解是否会在 javadoc 体现</li>
<li><strong>Inherited</strong> //子类会继承父类注解</li>
</ul>
</li>
</ul>
<h3 id="11-5-2-Retention"><a href="#11-5-2-Retention" class="headerlink" title="11.5.2 Retention"></a>11.5.2 Retention</h3><ul>
<li><p>只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值:</p>
</li>
<li><p>@Retention 的三种值</p>
<ul>
<li>RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释</li>
<li>RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注解。 这是默认值</li>
<li> RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以通过反射获取该注解</li>
</ul>
</li>
<li><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019100145122.png" alt="image-20231019100145122"></p>
</li>
</ul>
<h3 id="11-5-3-Target"><a href="#11-5-3-Target" class="headerlink" title="11.5.3 Target"></a>11.5.3 Target</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019100225152.png" alt="image-20231019100225152"></p>
<h3 id="11-5-4-Documented"><a href="#11-5-4-Documented" class="headerlink" title="11.5.4 Documented"></a>11.5.4 Documented</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019100259358.png" alt="image-20231019100259358"></p>
<h3 id="11-5-5-Inherited"><a href="#11-5-5-Inherited" class="headerlink" title="11.5.5 Inherited"></a>11.5.5 Inherited</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231019100325048.png" alt="image-20231019100325048"> </p>
<h1 id="第十二章-异常"><a href="#第十二章-异常" class="headerlink" title="第十二章 异常"></a>第十二章 异常</h1><h2 id="12-1-基本概念"><a href="#12-1-基本概念" class="headerlink" title="12.1 基本概念"></a>12.1 基本概念</h2><ul>
<li>Java语言中，将程序执行中发生的不正常情况称为“异常”。(开发过程中的语法错误和逻辑错误不是异常)</li>
<li>执行过程中所发生的异常事件可分为两大类<ul>
<li><strong>Error(错误):</strong> Java虚拟机无法解决的严重问题。如:JVM系统内部错误、资源耗尽等严重情况。比如:<strong>StackOverflowError[栈溢出]和OOM(out of memory)</strong>. Error是严重错误,程序会崩溃。</li>
<li><strong>Exception(异常)</strong>: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如<strong>空指针访问，试图读取不存在的文件，网络连接中断</strong>等等，Exception分为两大类: <font color="red">运行时异常</font>[程序运行时，发生的异常]和<font color="red">编译时异常</font>[编程时,编译器检查出的异常]。</li>
</ul>
</li>
<li>处理异常快捷键：<strong>Ctrl +Alt + T</strong></li>
</ul>
<h2 id="12-2-异常体系图"><a href="#12-2-异常体系图" class="headerlink" title="12.2 异常体系图"></a>12.2 异常体系图</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231020100303282.png" alt="image-20231020100303282"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231020100407648.png" alt="image-20231020100407648"></p>
<h2 id="12-3-常见运行时异常"><a href="#12-3-常见运行时异常" class="headerlink" title="12.3 常见运行时异常"></a>12.3 常见运行时异常</h2><ul>
<li><strong>NullPointerException</strong> 空指针异常<ul>
<li>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</li>
</ul>
</li>
<li><strong>ArithmeticException</strong> 数学运算异常<ul>
<li>当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时</li>
</ul>
</li>
<li><strong>ArrayIndexOutOfBoundsException</strong> 数组下标越界异常<ul>
<li>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引</li>
</ul>
</li>
<li><strong>ClassCastException</strong> 类型转换异<ul>
<li>当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>
</ul>
</li>
<li><strong>NumberFormatException</strong> 数字格式不正确异常<ul>
<li>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常</li>
</ul>
</li>
</ul>
<h2 id="12-4-常见编译异常"><a href="#12-4-常见编译异常" class="headerlink" title="12.4 常见编译异常"></a>12.4 常见编译异常</h2><ul>
<li><strong>SQLException</strong>  操作数据库时，查询表可能发生异常</li>
<li><strong>IOException</strong>  操作文件时，发生的异常</li>
<li><strong>FileNotFoundException</strong>   当操作一个不存在的文件时，发生异常</li>
<li><strong>ClassNotFoundException</strong>    加载类,，而该类不存在时,异常</li>
<li><strong>EOFException</strong>   操作文件，到文件末尾,发生异常</li>
<li><strong>IllegalArguementException</strong>   参数异常</li>
</ul>
<h2 id="12-5-异常处理"><a href="#12-5-异常处理" class="headerlink" title="12.5 异常处理"></a>12.5 异常处理</h2><ul>
<li><p>**<font color="red">try-catch-finally</font>**：程序员在代码中捕获发生的异常，自行处理</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231020102616097.png" alt="image-20231020102616097"></p>
</li>
</ul>
<ul>
<li><p>**<font color="red">throws</font>**：将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者就是JVM。如果没有try-catch处理，则默认采用throws处理</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231020102734625.png" alt="image-20231020102734625"></p>
</li>
</ul>
<h2 id="12-6-try-catch-异常处理"><a href="#12-6-try-catch-异常处理" class="headerlink" title="12.6 try-catch 异常处理"></a>12.6 try-catch 异常处理</h2><ol>
<li><p>如果异常发生了，则<strong>异常发生后面的代码不会执行</strong>，直接进入到catch块；如果异常没有发生，则顺序执行try的代码块，不会进入到catch.</p>
</li>
<li><p>如果异常没有发生，则<strong>顺序执行 try 的代码块</strong>，不会进入到 catch</p>
</li>
<li><p>如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用如下代码- finally</p>
</li>
<li><p><strong>可以有多个catch语句，捕获不同的异常</strong>(进行不同的业务处理)，<strong>要求父类异常在后，子类异常在前</strong>，比如(Exception在后，NullPointerException在前)，如果发生异常，只会匹配一个catch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDetail02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.如果 try 代码块有可能有多个异常</span></span><br><span class="line">        <span class="comment">//2.可以使用多个 catch 分别捕获不同的异常，相应处理</span></span><br><span class="line">        <span class="comment">//3.要求子类异常写在前面，父类异常写在后面</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person person = <span class="keyword">new</span> Person();</span><br><span class="line">            <span class="comment">// person = null;</span></span><br><span class="line">            System.out.println(person.getName());<span class="comment">//NullPointerException</span></span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> res = n1 / n2;<span class="comment">//ArithmeticException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空指针异常=&quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;算术异常=&quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以进行<strong>try-finally</strong> 配合使用，这种用法<strong>相当于没有捕获异常</strong>，因此程序会直接崩掉/退出。应用场景，就是<strong>执行一段代码，不管是否发生异常，都必须执行某个业务逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDetail02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = <span class="number">0</span>;</span><br><span class="line">            System.out.println(n1 / n2);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行了finally...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;程序继续执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">执行了<span class="keyword">finally</span>...    </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="12-7-try-catch-异常处理练习"><a href="#12-7-try-catch-异常处理练习" class="headerlink" title="12.7 try-catch 异常处理练习"></a>12.7 try-catch 异常处理练习</h2><ul>
<li><p>Exercise01</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchExercise01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(method());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] names = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (names[<span class="number">1</span>].equals(<span class="string">&quot;durango&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(names[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                names[<span class="number">3</span>] = <span class="string">&quot;zlx&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;  <span class="comment">// finally必须执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></li>
<li><p>Exercise02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchExercise02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(method());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i++;    <span class="comment">// i=2</span></span><br><span class="line">            String[] names = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (names[<span class="number">1</span>].equals(<span class="string">&quot;durango&quot;</span>)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(names[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">                names[<span class="number">3</span>] = <span class="string">&quot;zlx&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;     <span class="comment">// i=3</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;  <span class="comment">// finally必须执行</span></span><br><span class="line">            <span class="keyword">return</span> ++i;     <span class="comment">// i=4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Exercise03</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.trycatch_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchExercise03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(method());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i++;    <span class="comment">// i=2</span></span><br><span class="line">            String[] names = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (names[<span class="number">1</span>].equals(<span class="string">&quot;durango&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(names[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                names[<span class="number">3</span>] = <span class="string">&quot;zlx&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;     <span class="comment">// i=3 ==&gt; 保存到临时变量temp=3并执行完finally后再return!!</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  <span class="comment">// finally必须执行</span></span><br><span class="line">            ++i;     <span class="comment">// i=4</span></span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">i=<span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="12-8-throws异常处理"><a href="#12-8-throws异常处理" class="headerlink" title="12.8 throws异常处理"></a>12.8 throws异常处理</h2><ol>
<li><p>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理,而<strong>由该方法的调用者负责处理</strong>。</p>
</li>
<li><p>在方法声明中用<strong>throws语句可以声明抛出异常的列表</strong>，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p>
</li>
<li><p>注意事项：</p>
<ul>
<li>对于<strong>编译异常</strong>，程序中必须<strong>显式地处理</strong>，比如try-catch或者throws</li>
<li>对于<strong>运行时异常</strong>，程序中如果没有处理，<strong>默认就是抛出的方式处理</strong>（隐式地处理）</li>
<li>子类重写父类的方法时，对抛出异常的规定: <strong>子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型</strong></li>
<li>在throws 过程中，如果有方法 try-catch,就相当于处理异常，就可以不必throws</li>
</ul>
</li>
<li><p>throw和throws的区别</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231021155142632.png" alt="image-20231021155142632"></p>
</li>
<li><p>一个练习</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.throws_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowExercise01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReturnExceptionDemo.methodA();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReturnExceptionDemo.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入方法A&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;制造异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A方法的finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入方法B&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B方法的finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">进入方法A</span><br><span class="line">A方法的<span class="keyword">finally</span></span><br><span class="line">制造异常</span><br><span class="line">进入方法B</span><br><span class="line">B方法的<span class="keyword">finally</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="12-9-自定义异常"><a href="#12-9-自定义异常" class="headerlink" title="12.9 自定义异常"></a>12.9 自定义异常</h2><h3 id="12-9-1-基本概念"><a href="#12-9-1-基本概念" class="headerlink" title="12.9.1 基本概念"></a>12.9.1 基本概念</h3><p>​    当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类,用于描述该错误信息。</p>
<h3 id="12-9-2-步骤"><a href="#12-9-2-步骤" class="headerlink" title="12.9.2 步骤"></a>12.9.2 步骤</h3><ul>
<li>定义类:自定义异常类名(程序员自己写)继承Exception或RuntimeException</li>
<li><strong>如果继承Exception，属于编译异常</strong></li>
<li><strong>如果继承RuntimeException,属于运行异常</strong>(一般来说,继承RuntimeException，好处是可以使用默认处理机制)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AgeException(<span class="string">&quot;年龄需要再18-120之间&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入年龄范围正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第十三章-常用类"><a href="#第十三章-常用类" class="headerlink" title="第十三章 常用类"></a>第十三章 常用类</h1><h2 id="13-1-包装类"><a href="#13-1-包装类" class="headerlink" title="13.1 包装类"></a>13.1 包装类</h2><h3 id="13-1-1-包装类的分类"><a href="#13-1-1-包装类的分类" class="headerlink" title="13.1.1 包装类的分类"></a>13.1.1 包装类的分类</h3><ul>
<li><p>针对八种基本数据类型相应的引用类型—包装类</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231023093841832.png" alt="image-20231023093841832"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231023093942360.png" alt="image-20231023093942360"></p>
</li>
</ul>
<p>​            <img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231023093958943-16980252473951.png" alt="image-20231023093958943"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231023094111547.png" alt="image-20231023094111547"></p>
<h3 id="13-1-2-包装类与基本数据类型转换"><a href="#13-1-2-包装类与基本数据类型转换" class="headerlink" title="13.1.2 包装类与基本数据类型转换"></a>13.1.2 包装类与基本数据类型转换</h3><ul>
<li><p>jdk5前的<strong>手动</strong>装箱和拆箱方式，装箱: 基本类型-&gt;包装类型，反之，拆箱</p>
</li>
<li><p>jdk5 以后(含jdk5)的<strong>自动</strong>装箱和拆箱方式</p>
</li>
<li><p><strong>自动装箱底层调用的是valueOf方法</strong>，比如Integer.valueOf()</p>
</li>
<li><p>其它包装类的用法类似，不举例</p>
</li>
<li><p>基本方法：<strong>Interger.<font color="red">valueOf(n)</font>，integer.<font color="red">intValue()</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.wrapper_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int &lt;--&gt; Integer</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//jdk5以前是手动装箱和拆箱</span></span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line">        Integer integer = <span class="keyword">new</span> Integer(n1);</span><br><span class="line">        Integer integer1 = Integer.valueOf(n1);</span><br><span class="line">        <span class="keyword">int</span> i = integer.intValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jdk5以后，就可以自动装箱和拆箱</span></span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">100</span>;</span><br><span class="line">        Integer integer2 = n2;  <span class="comment">//底层仍然是使用Integer.valueOf(n2)</span></span><br><span class="line">        <span class="keyword">int</span> j = integer2;       <span class="comment">//底层仍然使用的是 intValue()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一个经典面试题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(obj);    <span class="comment">// 输出为1.0，三元运算符是一个整体，结果会向高精度类型转换</span></span><br><span class="line"></span><br><span class="line">Object obj2;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    obj2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(obj2);   <span class="comment">// 输出为1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-1-3-包装类与String相互转化"><a href="#13-1-3-包装类与String相互转化" class="headerlink" title="13.1.3 包装类与String相互转化"></a>13.1.3 包装类与String相互转化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.wrapper_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperVSString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 包装类 --&gt; String</span></span><br><span class="line">        Integer i = <span class="number">100</span>;    <span class="comment">//自动装箱</span></span><br><span class="line">        <span class="comment">// 方式1</span></span><br><span class="line">        String str1 = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 方式2</span></span><br><span class="line">        String str2 = i.toString();</span><br><span class="line">        <span class="comment">// 方式3</span></span><br><span class="line">        String str3 = String.valueOf(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String --&gt; 包装类</span></span><br><span class="line">        String str4 = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="comment">// 方式一</span></span><br><span class="line">        Integer i2 = Integer.parseInt(str4); <span class="comment">//parseInt返回的是int类型，使用到自动装箱</span></span><br><span class="line">        <span class="comment">// 方式二</span></span><br><span class="line">        Integer i3 = <span class="keyword">new</span> Integer(str4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-1-4-Integer类-和-Character类的常用方法"><a href="#13-1-4-Integer类-和-Character类的常用方法" class="headerlink" title="13.1.4 Integer类 和 Character类的常用方法"></a>13.1.4 Integer类 和 Character类的常用方法</h3><ul>
<li>即用即查</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Integer.MIN_VALUE); <span class="comment">//返回最小值</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE);<span class="comment">//返回最大值</span></span><br><span class="line">System.out.println(Character.isDigit(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是数字</span></span><br><span class="line">System.out.println(Character.isLetter(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是字母</span></span><br><span class="line">System.out.println(Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是大写</span></span><br><span class="line">System.out.println(Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是小写</span></span><br><span class="line">System.out.println(Character.isWhitespace(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是空格</span></span><br><span class="line">System.out.println(Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//转成大写</span></span><br><span class="line">System.out.println(Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>));<span class="comment">//转成小写</span></span><br></pre></td></tr></table></figure>



<h3 id="13-1-5-经典面试题"><a href="#13-1-5-经典面试题" class="headerlink" title="13.1.5 经典面试题"></a>13.1.5 经典面试题</h3><ul>
<li><p>Exercise01</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(obj);    <span class="comment">// 输出为1.0，三元运算符是一个整体，结果会向高精度类型转换</span></span><br><span class="line"></span><br><span class="line">Object obj2;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    obj2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(obj2);   <span class="comment">// 输出为1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>Exercise02</strong>：<font color="red">查看valueOf源码</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回</span></span><br><span class="line"><span class="comment">//2. 如果不在 -128~127,就 new Integer(i)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        public static Integer valueOf(int i) &#123;</span></span><br><span class="line"><span class="comment">            if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span></span><br><span class="line"><span class="comment">                return IntegerCache.cache[i + (-IntegerCache.low)];</span></span><br><span class="line"><span class="comment">            return new Integer(i);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Integer m = Integer.valueOf(<span class="number">1</span>); <span class="comment">// 查看valueOf源码</span></span><br><span class="line">Integer n = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">System.out.println(m == n); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer x = <span class="number">128</span>;    <span class="comment">// 自动包装，底层也是调用Integer.valueOf，看源码</span></span><br><span class="line">Integer y = <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
<li><p>Exercise03</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">System.out.println(i1 == i2);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i3 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">System.out.println(i3 == i4);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i5 = <span class="number">127</span>;</span><br><span class="line">Integer i6 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i5 == i6);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer i7 = <span class="number">128</span>;</span><br><span class="line">Integer i8 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i7 == i8);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i9 = <span class="number">127</span>;</span><br><span class="line">Integer i10 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">System.out.println(i9 == i10);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有基本数据类型，判断的就是值是否相等</span></span><br><span class="line">Integer i11 = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">int</span> i12 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i11 == i12); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer i13 = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">int</span> i14 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i13 == i14); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-2-String类-（重要！）"><a href="#13-2-String类-（重要！）" class="headerlink" title="13.2 String类 （重要！）"></a>13.2 String类 （重要！）</h2><h3 id="13-2-1-String基本介绍"><a href="#13-2-1-String基本介绍" class="headerlink" title="13.2.1 String基本介绍"></a>13.2.1 String基本介绍</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231023104323731.png" alt="image-20231023104323731"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231023104356952.png" alt="image-20231023104356952"></p>
<ul>
<li>构造器<ul>
<li>String s1 = new String();</li>
<li>String s2 = new String(String original);</li>
<li>String s3 = new String(char[] a);</li>
<li>String s4 = new String(char[] a,int startIndex,int count)</li>
<li> String s5 = new String(byte[] b)</li>
</ul>
</li>
<li>String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】 接口 Comparable [String 对象可以比较大小]</li>
<li>String 是 <strong>final 类</strong>，因此不能被其他的类继承</li>
<li>String 有属性 <strong><font color="red">private final char value[]; 用于存放字符串内容</font></strong></li>
<li>**<font color="red">一定要注意</font>**：value 是一个 final 类型（的引用类型）， 不可以修改：即 <strong>value 不能指向新的地址</strong>，但是单个字符内容是可以变化</li>
</ul>
<h3 id="13-2-2-创建-String-对象的两种方式"><a href="#13-2-2-创建-String-对象的两种方式" class="headerlink" title="13.2.2 创建 String 对象的两种方式"></a>13.2.2 创建 String 对象的两种方式</h3><ul>
<li><a href="https://blog.csdn.net/weixin_44273302/article/details/115343069">字符串常量 VS 字符串对象</a></li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231023110429072.png" alt="image-20231023110429072"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231023110742572.png" alt="image-20231023110742572"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建String对象</span></span><br><span class="line"><span class="comment">// 1.直接赋值 字符串常量</span></span><br><span class="line"><span class="comment">// 2.调用构造器 创建字符串对象</span></span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">//false（比较的是引用地址）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// str1指向的是常量池中的&quot;abc&quot;</span></span><br><span class="line"><span class="comment">// str2指向的是堆中的String对象空间，其中维护的一个value属性指向常量池中的&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="13-2-3-练习题"><a href="#13-2-3-练习题" class="headerlink" title="13.2.3 练习题"></a>13.2.3 练习题</h3><ul>
<li><p>Exercise01</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//true 查看equals源码，equals比较的是value数组的每一个字符</span></span><br><span class="line">System.out.println(a == b); <span class="comment">//true 都是指向常量池中的&quot;abc&quot;，==比较的是地址</span></span><br></pre></td></tr></table></figure></li>
<li><p>Exercise02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(c.equals(d)); <span class="comment">//true</span></span><br><span class="line">System.out.println(c == b); <span class="comment">//false c和d指向堆中不同的对象空间，都维护了value属性指向常量池中的&quot;abc&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Exercise03</p>
<ul>
<li><font color="red">当调用<strong>intern方法</strong>时，如果池已经包含一个等于此String对象的字符串(用equals(Object)方法确定），则返回池中的字符串。否则，将此 String 对象加到池中，并返回此String 对象的引用</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//true</span></span><br><span class="line">System.out.println(a == b); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(a == b.intern()); <span class="comment">// true b.intern()返回的是常量池的地址(value指向的地址)</span></span><br><span class="line">System.out.println(b == b.intern()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-3-字符串特性及面试题"><a href="#13-3-字符串特性及面试题" class="headerlink" title="13.3 字符串特性及面试题"></a>13.3 字符串特性及面试题</h2><h3 id="13-3-1-字符串特性"><a href="#13-3-1-字符串特性" class="headerlink" title="13.3.1 字符串特性"></a>13.3.1 字符串特性</h3><ul>
<li><p>String是一个<strong>final</strong>类，代表不可变的字符序列</p>
</li>
<li><p>字符串是不可变的。一个<strong>字符串对象一旦被分配，其内容是不可变的</strong>。（区分对象的引用和对象本身）</p>
<ul>
<li>```java<br>String s1 = “hello”;<br>s1 = “haha”;<br>// 创建了几个对象，画出内存布局图<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ![image-20231024103622642](Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231024103622642.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 13.3.2 面试题</span><br><span class="line"></span><br><span class="line">- 题目1</span><br><span class="line"></span><br><span class="line">  ![image-20231024103856817](Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231024103856817.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 题目2</span><br><span class="line"></span><br><span class="line">  - &lt;font color=&#x27;red&#x27;&gt;两个字符串**常量相加**，直接在**池**中创建新常量。引用直接指向池中的这个常量&lt;/font&gt;</span><br><span class="line">  - &lt;font color=&#x27;red&#x27;&gt;两个字符串**变量相加**，在**堆**中创建字符串对象，value[]指向池中的新常量。引用指向的是堆中的字符串对象。&lt;/font&gt;</span><br><span class="line">  - 常量相加指向池，变量相加指向堆</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  String a = &quot;hello&quot;;</span><br><span class="line">  String b = &quot;haha&quot;;</span><br><span class="line">  String c = &quot;hello&quot; + &quot;haha&quot;;</span><br><span class="line">  // 优化等价于String c = &quot;hellohaha&quot;;</span><br><span class="line">  // c指向池中的&quot;hellohaha&quot;</span><br><span class="line">  </span><br><span class="line">  System.out.println(c == &quot;hellohaha&quot;); // true</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">String c = a + b;</span><br><span class="line"><span class="comment">// 1. 先创建一个StringBuilder sb = StringBuilder()</span></span><br><span class="line"><span class="comment">// 2. 执行 sb.append(&quot;hello&quot;)</span></span><br><span class="line"><span class="comment">// 3. 执行 sb.append(&quot;haha&quot;)</span></span><br><span class="line"><span class="comment">// 4. 调用 sb.toString(), 返回一个new String(&quot;hellohaha&quot;)给c</span></span><br><span class="line"><span class="comment">// 最终效果，c指向堆中的对象(String), value[]指向池中的&quot;hellohaha&quot;</span></span><br><span class="line"></span><br><span class="line">System.out.println(c == <span class="string">&quot;hellohaha&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li><p>题目3</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231024111346679.png" alt="image-20231024111346679"></p>
</li>
</ul>
<ul>
<li><p>题目4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.string_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test1 ex = <span class="keyword">new</span> Test1();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str); <span class="comment">//hsp</span></span><br><span class="line">        System.out.println(ex.ch);  <span class="comment">//hava</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//        ex.ch = new char[]&#123;&#x27;a&#x27;, &#x27;b&#x27;&#125;; 报错，ex.ch是final类型，不能重新指向新对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;hsp&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] ch = &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span>[] ch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//str是形参，调用时指向实参对象</span></span><br><span class="line">        str = <span class="string">&quot;java&quot;</span>;	<span class="comment">//str重新指向新的对象后不会影响实参对象</span></span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">        ch = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">        System.out.println(str); <span class="comment">//java</span></span><br><span class="line">        System.out.println(ch); <span class="comment">// ab</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%98%E5%9B%BE1.jpg" alt="绘图1"></p>
</li>
</ul>
<h2 id="13-4-String类常见方法"><a href="#13-4-String类常见方法" class="headerlink" title="13.4 String类常见方法"></a>13.4 String类常见方法</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025164812593.png" alt="image-20231025164812593"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. equals 比较内容是否相同，区分大小写</span></span><br><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.equalsIgnoreCase 忽略大小写的判断内容是否相等</span></span><br><span class="line">String username = <span class="string">&quot;johN&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;john&quot;</span>.equalsIgnoreCase(username)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Failure!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.length 获取字符的个数，字符串的长度</span></span><br><span class="line">System.out.println(<span class="string">&quot;韩顺平&quot;</span>.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1</span></span><br><span class="line">String s1 = <span class="string">&quot;wer@terwe@g&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> index = s1.indexOf(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">System.out.println(index);<span class="comment">// 3</span></span><br><span class="line">System.out.println(<span class="string">&quot;weIndex=&quot;</span> + s1.indexOf(<span class="string">&quot;we&quot;</span>));<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1</span></span><br><span class="line">s1 = <span class="string">&quot;wer@terwe@g@&quot;</span>;</span><br><span class="line">index = s1.lastIndexOf(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">System.out.println(index);<span class="comment">//11</span></span><br><span class="line">System.out.println(<span class="string">&quot;ter 的位置=&quot;</span> + s1.lastIndexOf(<span class="string">&quot;ter&quot;</span>));<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.substring 截取指定范围的子串[start, end)</span></span><br><span class="line">String name = <span class="string">&quot;hello,张三&quot;</span>;</span><br><span class="line"><span class="comment">//下面 name.substring(6) 从索引 6 开始截取后面所有的内容</span></span><br><span class="line">System.out.println(name.substring(<span class="number">6</span>));<span class="comment">//截取后面的字符</span></span><br><span class="line"><span class="comment">//name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置</span></span><br><span class="line">System.out.println(name.substring(<span class="number">2</span>,<span class="number">5</span>));<span class="comment">//llo</span></span><br></pre></td></tr></table></figure>



<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231025165410347.png" alt="image-20231025165410347"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.toUpperCase 转换成大写</span></span><br><span class="line">String s = <span class="string">&quot;heLLo&quot;</span>;</span><br><span class="line">System.out.println(s.toUpperCase());<span class="comment">//HELLO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.toLowerCase</span></span><br><span class="line">System.out.println(s.toLowerCase());<span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.concat 拼接字符串</span></span><br><span class="line">String s1 = <span class="string">&quot;宝玉&quot;</span>;</span><br><span class="line">s1 = s1.concat(<span class="string">&quot;林黛玉&quot;</span>).concat(<span class="string">&quot;薛宝钗&quot;</span>).concat(<span class="string">&quot;together&quot;</span>);</span><br><span class="line">System.out.println(s1);<span class="comment">//宝玉林黛玉薛宝钗 together</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.replace 替换字符串中的字符</span></span><br><span class="line">s1 = <span class="string">&quot;宝玉 and 林黛玉 林黛玉 林黛玉&quot;</span>;</span><br><span class="line"><span class="comment">//在 s1 中，将 所有的 林黛玉 替换成薛宝钗</span></span><br><span class="line"><span class="comment">// s1.replace() 方法执行后，返回的结果才是替换过的. // 注意对 s1 没有任何影响</span></span><br><span class="line">String s11 = s1.replace(<span class="string">&quot;林黛玉&quot;</span>, <span class="string">&quot;薛宝钗&quot;</span>);</span><br><span class="line">System.out.println(s1);<span class="comment">//宝玉 and 林黛玉 林黛玉 林黛玉</span></span><br><span class="line">System.out.println(s11);<span class="comment">//宝玉 and 薛宝钗 薛宝钗 薛宝钗</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\等</span></span><br><span class="line">String poem = <span class="string">&quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;</span>;</span><br><span class="line">String[] split = poem.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">poem = <span class="string">&quot;E:\\aaa\\bbb&quot;</span>;</span><br><span class="line">split = poem.split(<span class="string">&quot;\\\\&quot;</span>); <span class="comment">//分隔符为&quot;\\&quot;</span></span><br><span class="line">System.out.println(<span class="string">&quot;==分割后内容===&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; split.length; i++) &#123;</span><br><span class="line">    System.out.println(split[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.toCharArray 转换成字符数组</span></span><br><span class="line">s = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">    System.out.println(chs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.compareTo 比较两个字符串的大小，如果前者大，</span></span><br><span class="line"><span class="comment">// 则返回正数，后者大，则返回负数，如果相等，返回 0</span></span><br><span class="line"><span class="comment">// (1) 如果长度相同，并且每个字符也相同，就返回 0</span></span><br><span class="line"><span class="comment">// (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小</span></span><br><span class="line"><span class="comment">// 就返回 if (c1 != c2) &#123;</span></span><br><span class="line"><span class="comment">// return c1 - c2;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// (3) 如果前面的部分都相同，就返回 str1.len - str2.len</span></span><br><span class="line">String a = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">System.out.println(a.compareTo(b)); <span class="comment">// 返回值是0</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">b = <span class="string">&quot;jcck&quot;</span>;</span><br><span class="line">System.out.println(a.compareTo(b)); <span class="comment">// 返回值是&#x27;a&#x27;-&#x27;c&#x27;=-2</span></span><br><span class="line">a = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">b = <span class="string">&quot;jckcc&quot;</span>;</span><br><span class="line">System.out.println(a.compareTo(b)); <span class="comment">// 返回值是&#x27;a&#x27;-&#x27;c&#x27;=-2</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">b = <span class="string">&quot;jackabc&quot;</span>;</span><br><span class="line">System.out.println(a.compareTo(b)); <span class="comment">// 返回值是str1.len - str2.len = -3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.format 格式字符串</span></span><br><span class="line"><span class="comment">/* 占位符有:</span></span><br><span class="line"><span class="comment">         * %s 字符串 %c 字符 %d 整型 %.2f 浮点型</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">String name = <span class="string">&quot;john&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> score = <span class="number">56.857</span>;</span><br><span class="line"><span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="comment">//将所有的信息都拼接在一个字符串.</span></span><br><span class="line">String info =</span><br><span class="line">    <span class="string">&quot;我的姓名是&quot;</span> + name + <span class="string">&quot;年龄是&quot;</span> + age + <span class="string">&quot;,成绩是&quot;</span> + score + <span class="string">&quot;性别是&quot;</span> + gender + <span class="string">&quot;。希望大家喜欢我！&quot;</span>;</span><br><span class="line">System.out.println(info);</span><br><span class="line"><span class="comment">//1. %s , %d , %.2f %c 称为占位符</span></span><br><span class="line"><span class="comment">//2. 这些占位符由后面变量来替换</span></span><br><span class="line"><span class="comment">//3. %s 表示后面由 字符串来替换</span></span><br><span class="line"><span class="comment">//4. %d 是整数来替换</span></span><br><span class="line"><span class="comment">//5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理</span></span><br><span class="line"><span class="comment">//6. %c 使用 char 类型来替换</span></span><br><span class="line">String formatStr = <span class="string">&quot;我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！&quot;</span>;</span><br><span class="line">String info2 = String.format(formatStr, name, age, score, gender);</span><br><span class="line">System.out.println(<span class="string">&quot;info2=&quot;</span> + info2);</span><br></pre></td></tr></table></figure>



<h2 id="13-5-Stringuffer类"><a href="#13-5-Stringuffer类" class="headerlink" title="13.5 Stringuffer类"></a>13.5 Stringuffer类</h2><h3 id="13-5-1-基本介绍"><a href="#13-5-1-基本介绍" class="headerlink" title="13.5.1 基本介绍"></a>13.5.1 基本介绍</h3><ul>
<li>String类是保存字符串常量的<strong>。每次更新都需要重新开辟空间(new 对象)，效率较低</strong>, 因此java设计者还提供了String Builder 和 StringBuffer 来增强String的功能并提高效率。</li>
<li>java.lang.StringBuffer代表<strong>可变的字符序列</strong>，可以对字符串内容进行增删</li>
<li>很多方法与String相同，但StringBuffer是<strong>可变长度的</strong>。</li>
<li>StringBuffer是一个<strong>容器</strong>。</li>
</ul>
<ul>
<li><p>继承关系图</p>
<ol>
<li>StringBuffer 的直接父类 是 AbstractStringBuilder</li>
<li> StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化</li>
<li> 在父类中 AbstractStringBuilder <strong><font color="red">有属性 char[] value, 不是 final， 该value数组存放字符串内容，存放在堆中（而不是存放在常量池）</font></strong></li>
<li>StringBuffer 是一个 final 类，不能被继承</li>
<li>因为 StringBuffer字符内容是存放在 char[] value, 所以变化(增加/删除)，<strong>不用每次</strong>都更换地址(即不是每次创建新对象)， 所以效率高于 String</li>
</ol>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231026102141270.png" alt="image-20231026102141270"></p>
</li>
</ul>
<p>​    </p>
<h3 id="13-5-2-StingBuffer-VS-String-（重要！）"><a href="#13-5-2-StingBuffer-VS-String-（重要！）" class="headerlink" title="13.5.2 StingBuffer VS String （重要！）"></a>13.5.2 StingBuffer VS String （重要！）</h3><ul>
<li><p>​    <a href="https://zhuanlan.zhihu.com/p/640172085">Java中的String类真的不可变吗？java面试常见问题</a></p>
</li>
<li><p>String通过 <font color="red">private final char value[]</font>属性 保存的是<strong>字符串常量</strong>，保存在<strong>常量池</strong>。</p>
<ul>
<li>value是private的，且String内部没有提供setValue方法修改value数组里面的内容，即从String类外部无法修改value数组里面的内容（不代表不能修改）【value内容的不可变性】；</li>
<li>value是final的，所以value不能重新指向新的字符串常量【value地址的不可变性】</li>
<li>因为有这两个不可变性，我们对String的更新既不能通过改变value的内容实现，也不能通过改变value的地址实现。每次String类的更新，实际上是在堆中new了一个新的String对象，这个对象的value属性指向了常量池中新的字符串常量，因此效率较低 。</li>
</ul>
</li>
<li><p>StringBuffer通过 <font color="red">char[] value</font>属性 保存的是<strong>字符串变量</strong>，保存在<strong>堆</strong>中。</p>
<ul>
<li>value数组里面的内容可以修改，value的地址也可以修改。</li>
<li>StringBuffer的更新实际上可以修改内容，<strong>不用每次修改地址</strong>（除非数组要扩容），因此效率较高。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String a = <span class="string">&quot;avd&quot;</span>;</span><br><span class="line"><span class="comment">//a = &quot;ac&quot;; 报错 final修饰的引用类型不能修改其地址（引用类型赋值是赋地址）</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">char</span>[] b = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">b[<span class="number">1</span>] = <span class="string">&#x27;c&#x27;</span>; <span class="comment">// final修饰的char数组内容可以修改</span></span><br><span class="line"><span class="comment">// b = new char[]&#123;&#x27;a&#x27;,&#x27;c&#x27;&#125;; 报错 // final修饰的char数组地址不可以修改</span></span><br></pre></td></tr></table></figure>



<h3 id="13-5-3-StringBuffer与String相互转化"><a href="#13-5-3-StringBuffer与String相互转化" class="headerlink" title="13.5.3 StringBuffer与String相互转化"></a>13.5.3 StringBuffer与String相互转化</h3><ul>
<li><p>StringBuffer构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuffer构造器</span></span><br><span class="line"><span class="comment">//1. 创建一个大小为 16 的char[] value,用于存放字符内容</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">//2. 通过构造器指定char[] value的大小</span></span><br><span class="line">stringBuffer = <span class="keyword">new</span> StringBuffer(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//3. 通过给一个String创建StringBuffer,char[] value大小是str.length()+16</span></span><br></pre></td></tr></table></figure></li>
<li><p>String–&gt;StringBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String --&gt; StringBuffer</span></span><br><span class="line"><span class="comment">// 1. 通过构造器</span></span><br><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">StringBuffer stringBuffer1 = <span class="keyword">new</span> StringBuffer(str);</span><br><span class="line"><span class="comment">// 2.通过append</span></span><br><span class="line">StringBuffer stringBuffer2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer2.append(str);</span><br></pre></td></tr></table></figure></li>
<li><p>StringBuffer–&gt;String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuffer -&gt;String</span></span><br><span class="line">StringBuffer stringBuffer3 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line"><span class="comment">//1.使用构造器来搞定</span></span><br><span class="line">String s = <span class="keyword">new</span> String(stringBuffer3);</span><br><span class="line"><span class="comment">//2. 使用 StringBuffer 提供的 toString 方法</span></span><br><span class="line">String s1 = stringBuffer3.toString();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-5-4-StringBuffer常用方法"><a href="#13-5-4-StringBuffer常用方法" class="headerlink" title="13.5.4 StringBuffer常用方法"></a>13.5.4 StringBuffer常用方法</h3><ul>
<li>增<ul>
<li>s.<strong>append</strong>(string)</li>
</ul>
</li>
<li>删<ul>
<li>s.<strong>delete</strong>(start, end)，删除索引在区间 [start,end) 处的字符</li>
</ul>
</li>
<li>改<ul>
<li>s.<strong>replace</strong>(start, end, string)，替换区间[start,end) 处的字符</li>
</ul>
</li>
<li>查<ul>
<li>s.<strong>indexOf</strong>(string)，查找指定的子串在字符串第一次出现的索引，如果找不到返回-1</li>
</ul>
</li>
<li>插<ul>
<li>s.<strong>insert</strong>(index, string)，在指定索引index前插入</li>
</ul>
</li>
<li>长度<ul>
<li>s.<strong>length</strong>()</li>
</ul>
</li>
<li>注意！！String类型的修改会返回一个新的String对象，不会影响原String对象，因此需要一个新的引用或者将原引用指向这个新的String对象。<strong>StringBuffer的修改会直接影响到原StringBuffer对象，原引用即指向修改后的StringBuffer对象。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">s.append(<span class="string">&#x27;,&#x27;</span>);<span class="comment">// &quot;hello,&quot;</span></span><br><span class="line">s.append(<span class="string">&quot;张三丰&quot;</span>);<span class="comment">//&quot;hello,张三丰&quot;</span></span><br><span class="line">s.append(<span class="string">&quot;赵敏&quot;</span>).append(<span class="number">100</span>).append(<span class="keyword">true</span>).append(<span class="number">10.5</span>);<span class="comment">//&quot;hello,张三丰赵敏 100true10.5&quot;</span></span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰赵敏 100true10.5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</span></span><br><span class="line"><span class="comment">* 解读: 删除 11~14 的字符 [11, 14)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s.delete(<span class="number">11</span>, <span class="number">14</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰赵敏 true10.5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line"><span class="comment">//老韩解读，使用 周芷若 替换 索引 9-11 的字符 [9,11)</span></span><br><span class="line">s.replace(<span class="number">9</span>, <span class="number">11</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰周芷若 true10.5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="comment">//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1</span></span><br><span class="line"><span class="keyword">int</span> indexOf = s.indexOf(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">System.out.println(indexOf);<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插</span></span><br><span class="line"><span class="comment">//老韩解读，在索引为 9 的位置插入 &quot;赵敏&quot;,原来索引为 9 的内容自动后移</span></span><br><span class="line">s.insert(<span class="number">9</span>, <span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰赵敏周芷若 true10.5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">System.out.println(s.length());<span class="comment">//22</span></span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>



<h3 id="13-5-5-测试题"><a href="#13-5-5-测试题" class="headerlink" title="13.5.5 测试题"></a>13.5.5 测试题</h3><ul>
<li><p>Exercise01 区分<strong>空指针 和 空字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;  <span class="comment">// str是个空指针，没有赋值（地址）</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer.append(str);   <span class="comment">////需要看源码,底层调用的是AbstractStringBuilder的appendNull</span></span><br><span class="line">System.out.println(stringBuffer.length()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(stringBuffer); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的构造器，会抛出NullpointerException</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    StringBuffer stringBuffer1 = <span class="keyword">new</span> StringBuffer(str); <span class="comment">// 看底层源码super(str.length()+16);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">&quot;&quot;</span>;   <span class="comment">//str1不是空指针，指向看内存中一个空字符串</span></span><br><span class="line">StringBuffer stringBuffer2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer.append(str1);   <span class="comment">////需要看源码,底层调用的是AbstractStringBuilder的appendNull</span></span><br><span class="line">System.out.println(stringBuffer2.length()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(stringBuffer2); <span class="comment">// 无输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的构造器，不会报错</span></span><br><span class="line">StringBuffer stringBuffer3 = <span class="keyword">new</span> StringBuffer(str1); <span class="comment">// 看底层源码super(str.length()+16);</span></span><br><span class="line">System.out.println(stringBuffer2.length()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(stringBuffer3); <span class="comment">//无输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>Exercise02 将价格格式化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String price = <span class="string">&quot;123443545123.57&quot;</span>;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(price);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = sb.lastIndexOf(<span class="string">&quot;.&quot;</span>) - <span class="number">3</span>; i &gt; <span class="number">0</span>; i -= <span class="number">3</span>) &#123;</span><br><span class="line">    sb.insert(i, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb);<span class="comment">//123,443,545,123.57</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-6-StringBuilder"><a href="#13-6-StringBuilder" class="headerlink" title="13.6 StringBuilder"></a>13.6 StringBuilder</h2><h3 id="13-6-1-基本介绍"><a href="#13-6-1-基本介绍" class="headerlink" title="13.6.1 基本介绍"></a>13.6.1 基本介绍</h3><ul>
<li>一个可变的字符序列。此类提供一个与 StringBuffer兼容的API, 但不保证同步(<font color="red">StringBuilder 不是线程安全</font>)。该类被设计用作 StringBuffer的一个简易替换，<strong>用在<font color="red">字符串缓冲区被单个线程使用</font>的时候</strong>。如果可能，建议优先采用该类因为在大多数实现中，它比 StringBuffer 要快[后面测]。</li>
<li>在StringBuilder上的主要操作是 append和insert方法，可重载这些方法,以接受任意类型的数据。</li>
</ul>
<ul>
<li><p>继承关系图</p>
<ul>
<li>StringBuilder 继承 AbstractStringBuilder 类</li>
<li> 实现了 Serializable ,说明 StringBuilder 对象是可以串行化(对象可以网络传输,可以保存到文件)</li>
<li>StringBuilder 是 final 类, 不能被继承</li>
<li>StringBuilder 对象字符序列仍然是存放在其父类AbstractStringBuilder 的 <strong>char[] value;</strong> 因此，字符序列是堆中</li>
<li>StringBuilder 的方法，<font color="red">没有做互斥的处理,即没有 <strong>synchronized</strong> 关键字,因此在<strong>单线程</strong>的情况下使用</font></li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231028145818607.png" alt="image-20231028145818607"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231028150627951.png" alt="image-20231028150627951"></p>
</li>
</ul>
<h3 id="13-6-2-String-StringBuffer-StringBuilder比较（重要！）"><a href="#13-6-2-String-StringBuffer-StringBuilder比较（重要！）" class="headerlink" title="13.6.2 String StringBuffer StringBuilder比较（重要！）"></a>13.6.2 String StringBuffer StringBuilder比较（重要！）</h3><ul>
<li><p>字符串生成器和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样</p>
</li>
<li><p>字符串：不可变字符序列(final char value[])，<font color="red">效率低，但是复用率高</font>.</p>
</li>
<li><p>StringBuffer：可变字符序列(char[] value)、<font color="red">效率较高(增删)、线程安全</font>，看源码</p>
</li>
<li><p>StringBuilder：可变字符序列、<font color="red">效率最高、线程不安全</font></p>
</li>
<li><p>如何选择</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231028151831369.png" alt="image-20231028151831369"></p>
</li>
</ul>
<h3 id="13-6-3-效率测试"><a href="#13-6-3-效率测试" class="headerlink" title="13.6.3 效率测试"></a>13.6.3 效率测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;<span class="comment">//StringBuffer 拼接 20000 次</span></span><br><span class="line">    buffer.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;StringBuffer 的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;<span class="comment">//StringBuilder 拼接 20000 次</span></span><br><span class="line">    builder.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder 的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">String text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;<span class="comment">//String 拼接 20000</span></span><br><span class="line">    text = text + i;</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;String 的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">StringBuffer 的执行时间：<span class="number">6</span></span><br><span class="line">StringBuilder 的执行时间：<span class="number">4</span></span><br><span class="line">String 的执行时间：<span class="number">5644</span></span><br></pre></td></tr></table></figure>





<h2 id="13-7-Math类"><a href="#13-7-Math类" class="headerlink" title="13.7 Math类"></a>13.7 Math类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//看看 Math 常用的方法(静态方法)</span></span><br><span class="line"><span class="comment">//1.abs 绝对值</span></span><br><span class="line"><span class="keyword">int</span> abs = Math.abs(-<span class="number">9</span>);</span><br><span class="line">System.out.println(abs);<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.pow 求幂</span></span><br><span class="line"><span class="keyword">double</span> pow = Math.pow(<span class="number">2</span>, <span class="number">4</span>);<span class="comment">//2 的 4 次方</span></span><br><span class="line">System.out.println(pow);<span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.ceil 向上取整,返回&gt;=该参数的最小整数(转成 double);</span></span><br><span class="line"><span class="keyword">double</span> ceil = Math.ceil(<span class="number">3.9</span>);</span><br><span class="line">System.out.println(ceil);<span class="comment">//4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.floor 向下取整，返回&lt;=该参数的最大整数(转成 double)</span></span><br><span class="line"><span class="keyword">double</span> floor = Math.floor(<span class="number">4.001</span>);</span><br><span class="line">System.out.println(floor);<span class="comment">//4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.round 四舍五入 Math.floor(该参数+0.5)</span></span><br><span class="line"><span class="keyword">long</span> round = Math.round(<span class="number">5.51</span>);</span><br><span class="line">System.out.println(round);<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.sqrt 求开方</span></span><br><span class="line"><span class="keyword">double</span> sqrt = Math.sqrt(<span class="number">9.0</span>);</span><br><span class="line">System.out.println(sqrt);<span class="comment">//3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.random 求随机数</span></span><br><span class="line"><span class="comment">// random 返回的是 0 &lt;= x &lt; 1 之间的一个随机小数</span></span><br><span class="line"><span class="comment">// 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7</span></span><br><span class="line"><span class="comment">// 即返回一个数 x 2 &lt;= x &lt;= 7</span></span><br><span class="line"><span class="comment">// Math.random() * (b-a) 返回的就是 0 &lt;= 数 &lt;= b-a</span></span><br><span class="line"><span class="comment">// (1) (int)(a) &lt;= x &lt;= (int)(a + Math.random() * (b-a +1) )</span></span><br><span class="line"><span class="comment">// (2) 使用具体的数给小伙伴介绍 a = 2 b = 7</span></span><br><span class="line"><span class="comment">// (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)</span></span><br><span class="line"><span class="comment">// Math.random()*6 返回的是 0 &lt;= x &lt; 6 小数</span></span><br><span class="line"><span class="comment">// 2 + Math.random()*6 返回的就是 2 &lt;= x &lt; 8 小数</span></span><br><span class="line"><span class="comment">// (int)(2 + Math.random()*6) = 2 &lt;= x &lt;= 7 整数</span></span><br><span class="line"><span class="comment">// (3) 公式就是 (int)(a + Math.random() * (b-a +1) )</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println((<span class="keyword">int</span>)(<span class="number">2</span> + Math.random() * (<span class="number">7</span> - <span class="number">2</span> + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. max , min 返回最大值和最小值</span></span><br><span class="line"><span class="keyword">int</span> min = Math.min(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">int</span> max = Math.max(<span class="number">45</span>, <span class="number">90</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;min=&quot;</span> + min);</span><br><span class="line">System.out.println(<span class="string">&quot;max=&quot;</span> + max);</span><br></pre></td></tr></table></figure>



<h2 id="13-8-Arrays类"><a href="#13-8-Arrays类" class="headerlink" title="13.8 Arrays类"></a>13.8 Arrays类</h2><h3 id="13-8-1-常用方法"><a href="#13-8-1-常用方法" class="headerlink" title="13.8.1 常用方法"></a>13.8.1 常用方法</h3><ul>
<li><p><strong>toString</strong>：返回数组的字符串形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = &#123;<span class="number">1</span>, <span class="number">23</span>, <span class="number">44</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(integers)); <span class="comment">// [1, 23, 44]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>sort</strong>：默认排序或定制排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. sort：默认排序和定制排序</span></span><br><span class="line"><span class="comment">// 数组是引用类型，排序后会直接印象实参</span></span><br><span class="line"><span class="comment">// 重载的sort，也可以通过传入一个接口 Comparator 实现定制排序</span></span><br><span class="line"><span class="comment">// 调用 定制排序 时，传入两个参数</span></span><br><span class="line"><span class="comment">// (1) 排序的数组 arr</span></span><br><span class="line"><span class="comment">// (2) 实现了 Comparator 接口的匿名内部类 , 要求实现 compare 方法</span></span><br><span class="line">Integer[] arr = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">88</span>, <span class="number">20</span>&#125;;</span><br><span class="line">Arrays.sort(arr);   <span class="comment">//默认排序（从小到大）</span></span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制排序</span></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o2 - o1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">// 源码分析</span></span><br><span class="line"><span class="comment">//(1) Arrays.sort(arr, new Comparator()&#123;&#125;);</span></span><br><span class="line"><span class="comment">//(2) 最终到 TimSort 类的 private static &lt;T&gt; void binarySort(T[] a, int lo, int hi, int start, Comparator&lt;? super T&gt; c)()</span></span><br><span class="line"><span class="comment">//(3) 执行到 binarySort 方法的代码, 会根据动态绑定机制 c.compare()执行我们传入的匿名内部类的 compare ()</span></span><br><span class="line"><span class="comment">// while (left &lt; right) &#123;</span></span><br><span class="line"><span class="comment">// int mid = (left + right) &gt;&gt;&gt; 1;</span></span><br><span class="line"><span class="comment">// if (c.compare(pivot, a[mid]) &lt; 0)</span></span><br><span class="line"><span class="comment">//     right = mid;</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">//     left = mid + 1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//(4) new Comparator() &#123;</span></span><br><span class="line"><span class="comment">// @Override</span></span><br><span class="line"><span class="comment">// public int compare(Object o1, Object o2) &#123;</span></span><br><span class="line"><span class="comment">// Integer i1 = (Integer) o1;</span></span><br><span class="line"><span class="comment">// Integer i2 = (Integer) o2;</span></span><br><span class="line"><span class="comment">// return i2 - i1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//(5) public int compare(Object o1, Object o2) 返回的值&gt;0 还是 &lt;0</span></span><br><span class="line"><span class="comment">// 会影响整个排序结果, 这就充分体现了 接口编程+动态绑定+匿名内部类的综合使用</span></span><br><span class="line"><span class="comment">// 将来的底层框架和源码的使用方式，会非常常见</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定制冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraySortCustom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">        bubble(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        bubble(arr, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i1 = (Integer)o1;</span><br><span class="line">                <span class="keyword">int</span> i2 = (Integer)o2;</span><br><span class="line">                <span class="keyword">return</span> i2 - i1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr, Comparator c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">// 排序规则由c.compare(arr[j], arr[j + 1])返回值决定</span></span><br><span class="line">                <span class="keyword">if</span> (c.compare(arr[j], arr[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>binarySearch</strong>：二分查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">90</span>, <span class="number">123</span>, <span class="number">567</span>&#125;;</span><br><span class="line"><span class="comment">// binarySearch 通过二分搜索法进行查找，要求必须排好</span></span><br><span class="line"><span class="comment">//1. 使用 binarySearch 二叉查找</span></span><br><span class="line"><span class="comment">//2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch</span></span><br><span class="line"><span class="comment">//3. 如果数组中不存在该元素，就返回 return -(low + 1); // key not found.</span></span><br><span class="line"><span class="comment">// low是指元素应该插入的位置</span></span><br><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(arr, <span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;index=&quot;</span> + index);   <span class="comment">// -4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>copyOf</strong>：数组拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copyOf 数组拷贝</span></span><br><span class="line"><span class="comment">//1. 从 arr 数组中，拷贝 length 个元素到 newArr 数组中</span></span><br><span class="line"><span class="comment">//2. 如果拷贝的长度length &gt; oldArr.length 就在新数组的后面 增加 null</span></span><br><span class="line"><span class="comment">//3. 如果拷贝长度length &lt; 0 就抛出异常 NegativeArraySizeException</span></span><br><span class="line"><span class="comment">//4. 该方法的底层使用的是 System.arraycopy()</span></span><br><span class="line">Integer[] newArr = Arrays.copyOf(oldArr, length);</span><br><span class="line">System.out.println(<span class="string">&quot;==拷贝执行完毕后==&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(newArr));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>fill</strong>：数组填充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fill 数组元素的填充</span></span><br><span class="line">Integer[] num = <span class="keyword">new</span> Integer[]&#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//1. 使用 99 去填充 num 数组，可以理解成是替换原理的元素</span></span><br><span class="line">Arrays.fill(num, <span class="number">99</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;==num 数组填充后==&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(num));</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>equals</strong>：数组比对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//equals 比较两个数组元素内容是否完全一致</span></span><br><span class="line">Integer[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">90</span>, <span class="number">123</span>&#125;;</span><br><span class="line"><span class="comment">//1. 如果 arr 和 arr2 数组的元素一样，则方法 true;</span></span><br><span class="line"><span class="comment">//2. 如果不是完全一样，就返回 false</span></span><br><span class="line"><span class="keyword">boolean</span> equals = Arrays.equals(arr, arr2);</span><br><span class="line">System.out.println(<span class="string">&quot;equals=&quot;</span> + equals);</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>asList</strong>：将一组数据转换成 list</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. asList 方法，会将 (2,3,4,5,6,1)数据转成一个 List 集合</span></span><br><span class="line"><span class="comment">//2. 返回的 asList编译类型：List(是接口)</span></span><br><span class="line"><span class="comment">//3. 返回的 asList运行类型：java.util.Arrays#ArrayList,</span></span><br><span class="line"><span class="comment">// ArrayList是 Arrays 类的静态内部类 private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span></span><br><span class="line"><span class="comment">// implements RandomAccess, java.io.Serializable</span></span><br><span class="line">List asList = Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;asList=&quot;</span> + asList);</span><br><span class="line">System.out.println(<span class="string">&quot;asList 的运行类型&quot;</span> + asList.getClass());</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-8-2-练习题"><a href="#13-8-2-练习题" class="headerlink" title="13.8.2 练习题"></a>13.8.2 练习题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定制排序</span><br><span class="line">// 1.实现自定义book类数组按price从小到大排序</span><br><span class="line">// 2.实现自定义book类数组按price从大到小排序</span><br><span class="line">// 3.实现自定义book类数组按name的长度从小到大排序</span><br><span class="line"></span><br><span class="line">public class ArrayExercise &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Book[] books = new Book[4];</span><br><span class="line">        books[0] = new Book(&quot;红楼梦&quot;, 100);</span><br><span class="line">        books[1] = new Book(&quot;金瓶梅新&quot;, 90);</span><br><span class="line">        books[2] = new Book(&quot;青年文摘 20 年&quot;, 5);</span><br><span class="line">        books[3] = new Book(&quot;java 从入门到放弃~&quot;, 300);</span><br><span class="line"></span><br><span class="line">        // 按price从小到大排序</span><br><span class="line">        Arrays.sort(books, new Comparator&lt;Book&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Book o1, Book o2) &#123;</span><br><span class="line">                double priceVal = o1.getPrice() - o2.getPrice();</span><br><span class="line">                if (priceVal &gt; 0) &#123;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125; else if (priceVal &lt; 0) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(books));</span><br><span class="line"></span><br><span class="line">        // 按price从大到小排序</span><br><span class="line">        Arrays.sort(books, new Comparator&lt;Book&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Book o1, Book o2) &#123;</span><br><span class="line">                double priceVal = o1.getPrice() - o2.getPrice();</span><br><span class="line">                if (priceVal &gt; 0) &#123;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125; else if (priceVal &lt; 0) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(books));</span><br><span class="line"></span><br><span class="line">        // 按照name长度从小到大排序</span><br><span class="line">        Arrays.sort(books, new Comparator&lt;Book&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Book o1, Book o2) &#123;</span><br><span class="line">                double nameVal = o1.getName().length() - o2.getName().length();</span><br><span class="line">                if (nameVal &gt; 0) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125; else if (nameVal &lt; 0) &#123;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(books));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Book &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double price;</span><br><span class="line"></span><br><span class="line">    public Book(String name, double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="13-9-System类"><a href="#13-9-System类" class="headerlink" title="13.9 System类"></a>13.9 System类</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231030182047674.png" alt="image-20231030182047674"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exit 退出当前程序</span></span><br><span class="line">System.out.println(<span class="string">&quot;ok1&quot;</span>);</span><br><span class="line"><span class="comment">//1. exit(0) 表示程序退出</span></span><br><span class="line"><span class="comment">//2. 0 表示一个状态 , 正常的状态</span></span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arraycopy ：复制数组元素，比较适合底层调用，</span></span><br><span class="line"><span class="comment">// 一般使用 Arrays.copyOf 完成复制数组</span></span><br><span class="line"><span class="keyword">int</span>[] src=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];<span class="comment">// dest 当前是 &#123;0,0,0&#125;</span></span><br><span class="line"><span class="comment">//1. 主要是搞清楚这五个参数的含义</span></span><br><span class="line"><span class="comment">// * @param     src         源数组</span></span><br><span class="line"><span class="comment">// * @param     srcPos      从源数组的哪个索引位置开始拷贝</span></span><br><span class="line"><span class="comment">// * @param     dest        目标数组，即把源数组的数据拷贝到哪个数组</span></span><br><span class="line"><span class="comment">// * @param     destPos     把源数组的数据拷贝到 目标数组的哪个索引</span></span><br><span class="line"><span class="comment">// * @param     length      从源数组拷贝多少个数据到目标数组</span></span><br><span class="line">System.arraycopy(src, <span class="number">0</span>, dest, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// int[] src=&#123;1,2,3&#125;;</span></span><br><span class="line">System.out.println(<span class="string">&quot;dest=&quot;</span> + Arrays.toString(dest));<span class="comment">//[0, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//currentTimeMillens:返回当前时间距离 1970-1-1 的毫秒数</span></span><br><span class="line">System.out.println(System.currentTimeMillis());</span><br></pre></td></tr></table></figure>



<h2 id="13-10-BigInteger-和-BigDecimal-类"><a href="#13-10-BigInteger-和-BigDecimal-类" class="headerlink" title="13.10 BigInteger 和 BigDecimal 类"></a>13.10 BigInteger 和 BigDecimal 类</h2><ul>
<li><p>应用场景：</p>
<ul>
<li>Biglnteger适合保存比较大的整型</li>
<li>BigDecimal适合保存精度更高的浮点型(小数)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当我们编程中，需要处理很大的整数，long 不够用</span></span><br><span class="line"><span class="comment">// 可以使用 BigInteger 的类来搞定</span></span><br><span class="line"><span class="comment">//long l = 23788888899999999999999999999l;</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;l=&quot; + l);</span></span><br><span class="line"></span><br><span class="line">BigInteger bigInteger = <span class="keyword">new</span> BigInteger(<span class="string">&quot;23788888899999999999999999999&quot;</span>);</span><br><span class="line">System.out.println(bigInteger);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当我们需要保存一个精度很高的数时，double 不够用</span></span><br><span class="line"><span class="comment">// 可以用 BigDecimal</span></span><br><span class="line"><span class="comment">//double d = 1999.11111111111999999999999977788d;</span></span><br><span class="line"><span class="comment">//System.out.println(d); //会缩减精度</span></span><br><span class="line">BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1999.11&quot;</span>);</span><br><span class="line">BigDecimal bigDecimal2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">System.out.println(bigDecimal);</span><br></pre></td></tr></table></figure></li>
<li><p>加、减、乘、除操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /</span></span><br><span class="line"><span class="comment">//2. 可以创建一个 要操作的 BigInteger 然后进行相应操作</span></span><br><span class="line">BigInteger add = bigInteger.add(bigInteger2);</span><br><span class="line">System.out.println(add);<span class="comment">//加</span></span><br><span class="line">BigInteger subtract = bigInteger.subtract(bigInteger2);</span><br><span class="line">System.out.println(subtract);<span class="comment">//减</span></span><br><span class="line">BigInteger multiply = bigInteger.multiply(bigInteger2);</span><br><span class="line">System.out.println(multiply);<span class="comment">//乘</span></span><br><span class="line">BigInteger divide = bigInteger.divide(bigInteger2);</span><br><span class="line">System.out.println(divide);<span class="comment">//除</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 如果对 BigDecimal 进行运算，比如加减乘除，需要使用对应的方法</span></span><br><span class="line"><span class="comment">//2. 创建一个需要操作的 BigDecimal 然后调用相应的方法即可</span></span><br><span class="line">System.out.println(bigDecimal.add(bigDecimal2));</span><br><span class="line">System.out.println(bigDecimal.subtract(bigDecimal2));</span><br><span class="line">System.out.println(bigDecimal.multiply(bigDecimal2));</span><br><span class="line"><span class="comment">//System.out.println(bigDecimal.divide(bigDecimal2));//可能抛出异常ArithmeticException，无限循环小数</span></span><br><span class="line"><span class="comment">//在调用 divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING</span></span><br><span class="line"><span class="comment">//如果有无限循环小数，就会保留 和“被除数”一致的 精度</span></span><br><span class="line">System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-11-日期类"><a href="#13-11-日期类" class="headerlink" title="13.11 日期类"></a>13.11 日期类</h2><h3 id="13-11-1-第一代日期类-Date"><a href="#13-11-1-第一代日期类-Date" class="headerlink" title="13.11.1 第一代日期类 Date"></a>13.11.1 第一代日期类 Date</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031093802564.png" alt="image-20231031093802564"></p>
<ul>
<li><p>获取日期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取当前系统时间</span></span><br><span class="line"><span class="comment">//2. 这里的 Date 类是在 java.util 包的</span></span><br><span class="line"><span class="comment">//3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换</span></span><br><span class="line">Date d1 = <span class="keyword">new</span> Date(); <span class="comment">//获取当前系统时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期=&quot;</span> + d1);</span><br><span class="line"></span><br><span class="line">Date d2 = <span class="keyword">new</span> Date(<span class="number">9234567</span>); <span class="comment">//通过指定毫秒数得到时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;d2=&quot;</span> + d2);</span><br><span class="line"></span><br><span class="line">System.out.println(d1.getTime());   <span class="comment">//获取某个时间对应的毫秒数</span></span><br></pre></td></tr></table></figure></li>
<li><p>Date转格式化String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建 SimpleDateFormat 对象，将Date转换成格式化字符串</span></span><br><span class="line"><span class="comment">//2. 这里的格式使用的字母是规定好，不能乱写</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line">String format = sdf.format(d1); <span class="comment">// format:将日期转换成指定格式的字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期=&quot;</span> + format);</span><br></pre></td></tr></table></figure></li>
<li><p>格式化String转Date</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 可以把一个格式化的 String 转成对应的 Date</span></span><br><span class="line"><span class="comment">//2. 得到 Date 在输出时，仍然还是按照国外的形式，如果希望指定格式输出，还是需要转换</span></span><br><span class="line"><span class="comment">//3. 在把 String -&gt; Date ， String 的格式 需要和 定义的sdf格式 一致，否则会抛出转换异常</span></span><br><span class="line">String s = <span class="string">&quot;1996 年 01 月 01 日 10:20:30 星期一&quot;</span>;</span><br><span class="line">Date parse = sdf.parse(s); <span class="comment">//可能会报异常ParseException</span></span><br><span class="line">System.out.println(<span class="string">&quot;parse=&quot;</span> + sdf.format(parse));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-11-2-第二代日期类-Calendar"><a href="#13-11-2-第二代日期类-Calendar" class="headerlink" title="13.11.2 第二代日期类 Calendar"></a>13.11.2 第二代日期类 Calendar</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031095901376.png" alt="image-20231031095901376"></p>
<ul>
<li><p>获取Calendar对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. Calendar 是一个抽象类， 并且构造器是 private</span></span><br><span class="line"><span class="comment">//2. 可以通过 getInstance() 来获取实例</span></span><br><span class="line"><span class="comment">//3. 提供大量的方法和字段提供给程序员</span></span><br><span class="line"><span class="comment">//4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)</span></span><br><span class="line"><span class="comment">//5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAY</span></span><br><span class="line">Calendar c = Calendar.getInstance(); <span class="comment">//创建日历类对象，比较简单，自由</span></span><br><span class="line">System.out.println(<span class="string">&quot;c=&quot;</span> + c); <span class="comment">//会输出很多字段信息</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取日历字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取日历对象的某个日历字段</span></span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span> + c.get(Calendar.YEAR));</span><br><span class="line"><span class="comment">// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号</span></span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span> + (c.get(Calendar.MONTH) + <span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span> + c.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;小时：&quot;</span> + c.get(Calendar.HOUR));</span><br><span class="line">System.out.println(<span class="string">&quot;分钟：&quot;</span> + c.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;秒：&quot;</span> + c.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure></li>
<li><p>格式化输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示</span></span><br><span class="line">System.out.println(c.get(Calendar.YEAR) + <span class="string">&quot;-&quot;</span> + (c.get(Calendar.MONTH) + <span class="number">1</span>) + <span class="string">&quot;-&quot;</span> +</span><br><span class="line">c.get(Calendar.DAY_OF_MONTH) +</span><br><span class="line"><span class="string">&quot; &quot;</span> + c.get(Calendar.HOUR_OF_DAY) + <span class="string">&quot;:&quot;</span> + c.get(Calendar.MINUTE) + <span class="string">&quot;:&quot;</span> + c.get(Calendar.SECOND) );</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-11-3-第三代日期类-LocalDateTime"><a href="#13-11-3-第三代日期类-LocalDateTime" class="headerlink" title="13.11.3 第三代日期类 LocalDateTime"></a>13.11.3 第三代日期类 LocalDateTime</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031100935458.png" alt="image-20231031100935458"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031101058708.png" alt="image-20231031101058708"></p>
<ul>
<li><p>获取日期时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 使用 now() 返回表示当前日期时间的 对象</span></span><br><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line">LocalDate now = LocalDate.now(); <span class="comment">//可以获取年月日</span></span><br><span class="line">LocalTime now2 = LocalTime.now();<span class="comment">//获取到时分秒</span></span><br></pre></td></tr></table></figure></li>
<li><p>格式化输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. 使用 DateTimeFormatter 对象来进行格式化</span></span><br><span class="line"><span class="comment">// 创建 DateTimeFormatter 对象</span></span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">String format = dateTimeFormatter.format(ldt);</span><br><span class="line">System.out.println(<span class="string">&quot;格式化的日期=&quot;</span> + format);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以向Calendar一样输出各个字段，组合显示</span></span><br><span class="line">System.out.println(<span class="string">&quot;年=&quot;</span> + ldt.getYear());</span><br><span class="line">System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonthValue());</span><br><span class="line">System.out.println(<span class="string">&quot;日=&quot;</span> + ldt.getDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;时=&quot;</span> + ldt.getHour());</span><br><span class="line">System.out.println(<span class="string">&quot;分=&quot;</span> + ldt.getMinute());</span><br><span class="line">System.out.println(<span class="string">&quot;秒=&quot;</span> + ldt.getSecond());</span><br></pre></td></tr></table></figure></li>
<li><p>对当前时间进行加减</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提供 plus 和 minus 方法可以对当前时间进行加或者减</span></span><br><span class="line"><span class="comment">//看看 890 天后，是什么时候 把 年月日-时分秒</span></span><br><span class="line">LocalDateTime ldt2 = ldt.plusDays(<span class="number">890</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;890 天后=&quot;</span> + dateTimeFormatter.format(ldt2));</span><br><span class="line"><span class="comment">//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出</span></span><br><span class="line">LocalDateTime ldt3 = ldt.minusMinutes(<span class="number">3456</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;3456 分钟前 日期=&quot;</span> + dateTimeFormatter.format(ldt3));</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="第十四章-集合"><a href="#第十四章-集合" class="headerlink" title="第十四章 集合"></a>第十四章 集合</h1><h2 id="14-1-集合介绍"><a href="#14-1-集合介绍" class="headerlink" title="14.1 集合介绍"></a>14.1 集合介绍</h2><ul>
<li>数组的不足<ul>
<li>长度开始时必须指定，而且一旦指定，不能更改</li>
<li>保存的必须为同一类型的元素</li>
<li>使用数组进行增加/删除元素比较麻烦（需要创建一个新数组）</li>
</ul>
</li>
<li>集合的好处<ul>
<li>可以<strong>动态保存</strong>任意多个对象，使用比较方便!</li>
<li>提供了一系列方便的操作对象的方法:add、remove、set、get等</li>
<li>使用集合添加，删除新元素的代码-<strong>简洁</strong>明了</li>
</ul>
</li>
</ul>
<h2 id="14-2-框架体系图（必背）"><a href="#14-2-框架体系图（必背）" class="headerlink" title="14.2 框架体系图（必背）"></a>14.2 框架体系图（必背）</h2><ol>
<li><p>集合主要是两组(单列集合 , 双列集合)</p>
</li>
<li><p>Collection 接口有两个重要的子接口 List和Set , 他们的实现子类都是单列集合</p>
</li>
<li><p>Map 接口的实现子类 是双列集合，存放的是 K-V</p>
</li>
</ol>
<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>Collection<ul>
<li><strong>List</strong><ul>
<li>Vector</li>
<li>ArrayList</li>
<li>LinkedList</li>
</ul>
</li>
<li><strong>Set</strong><ul>
<li>TreeSet</li>
<li>HashSet</li>
</ul>
</li>
</ul>
</li>
<li><strong>Map</strong><ul>
<li>TreeMap</li>
<li>HashMap<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li>Hashtable<ul>
<li>Properties</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    </p>
</div>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101093437236.png" alt="image-20231101093437236"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101093444815.png" alt="image-20231101093444815"></p>
<h2 id="14-3-Collection接口"><a href="#14-3-Collection接口" class="headerlink" title="14.3 Collection接口"></a>14.3 Collection接口</h2><h3 id="14-3-1-实现类的特点和常用方法"><a href="#14-3-1-实现类的特点和常用方法" class="headerlink" title="14.3.1 实现类的特点和常用方法"></a>14.3.1 实现类的特点和常用方法</h3><ol>
<li><p>收集实现子类可以存放多个元素，每个元素可以是Object</p>
</li>
<li><p>有些Collection的实现类，可以存放重复的元素，有些不可以</p>
</li>
<li><p>有些的实现类，有些是<strong>有序的(List)<strong>，有些是</strong>无序的(Set)</strong></p>
</li>
<li><p>集合接口没有直接的实现子类，是通过它的子接口<strong>Set</strong>和<strong>List</strong>来实现的</p>
</li>
</ol>
<ul>
<li><p>常用方法：以ArrayList为例</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101095156361.png" alt="image-20231101095156361"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">// 1.add：添加单个元素</span></span><br><span class="line">list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">list.add(<span class="number">10</span>); <span class="comment">//会自动装箱list.add(Integer.valueOf(10))</span></span><br><span class="line">list.add(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.contains：查找元素是否存在</span></span><br><span class="line">System.out.println(list.contains(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.remove：删除指定元素</span></span><br><span class="line">list.remove(<span class="number">0</span>); <span class="comment">//按索引删除</span></span><br><span class="line">list.remove(Integer.valueOf(<span class="number">10</span>)); <span class="comment">//按元素删除</span></span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.size：获取元素个数</span></span><br><span class="line">System.out.println(list.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.isEmpty：判断集合是否为空</span></span><br><span class="line">System.out.println(list.isEmpty());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.clear：清空集合 (list.removeAll(list)与之等价)</span></span><br><span class="line">list.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.addAll：添加多个元素</span></span><br><span class="line">List list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list2.add(<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;三国演义&quot;</span>);</span><br><span class="line">list.addAll(list2);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.containAll：判断多个元素是否同时存在</span></span><br><span class="line">System.out.println(list.containsAll(list2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.removeAll：删除多个元素</span></span><br><span class="line">list.add(<span class="string">&quot;西游记&quot;</span>);</span><br><span class="line">list.removeAll(list2);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br></pre></td></tr></table></figure>



<h3 id="14-3-2-遍历1-Iterator迭代器"><a href="#14-3-2-遍历1-Iterator迭代器" class="headerlink" title="14.3.2 遍历1 - Iterator迭代器"></a>14.3.2 遍历1 - Iterator迭代器</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101101622869.png" alt="image-20231101101622869"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101101905703.png" alt="image-20231101101905703"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101102225179.png" alt="image-20231101102225179"></p>
<ul>
<li>快捷键 <font color="red">itit</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection col = <span class="keyword">new</span> ArrayList();</span><br><span class="line">col.add(<span class="keyword">new</span> Book(<span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;罗贯中&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">col.add(<span class="keyword">new</span> Book(<span class="string">&quot;小李飞刀&quot;</span>, <span class="string">&quot;古龙&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line">col.add(<span class="keyword">new</span> Book(<span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;曹雪芹&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;col=&quot;</span> + col);</span><br><span class="line"><span class="comment">// 1.先得到col的Iterator对象</span></span><br><span class="line">Iterator iterator = col.iterator();</span><br><span class="line"><span class="comment">// 2. 使用while循环遍历  快捷键 itit (ctrl+j可以查看所有快捷键)</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Object obj = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素</span></span><br><span class="line"><span class="comment">// iterator.next();//NoSuchElementException</span></span><br><span class="line"><span class="comment">//4. 如果希望再次遍历，需要重置我们的迭代器</span></span><br><span class="line">iterator = col.iterator();</span><br><span class="line">System.out.println(<span class="string">&quot;===第二次遍历===&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Object obj = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-3-2-遍历3-for循环增强"><a href="#14-3-2-遍历3-for循环增强" class="headerlink" title="14.3.2 遍历3 - for循环增强"></a>14.3.2 遍历3 - for循环增强</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101103127471.png" alt="image-20231101103127471"></p>
<ul>
<li>快捷键：<font color="red">I</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection col = <span class="keyword">new</span> ArrayList();</span><br><span class="line">col.add(<span class="keyword">new</span> Book(<span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;罗贯中&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">col.add(<span class="keyword">new</span> Book(<span class="string">&quot;小李飞刀&quot;</span>, <span class="string">&quot;古龙&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line">col.add(<span class="keyword">new</span> Book(<span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;曹雪芹&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用增强for循环遍历集合</span></span><br><span class="line"><span class="comment">// 底层仍然使用的是Iterator，debug看源码</span></span><br><span class="line"><span class="comment">// 快捷键 I</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : col) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强for循环也可以遍历数组</span></span><br></pre></td></tr></table></figure>



<h2 id="14-4-List接口"><a href="#14-4-List接口" class="headerlink" title="14.4 List接口"></a>14.4 List接口</h2><h3 id="14-4-1-基本介绍"><a href="#14-4-1-基本介绍" class="headerlink" title="14.4.1 基本介绍"></a>14.4.1 基本介绍</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101104403257.png" alt="image-20231101104403257"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. List 集合类中元素有序(即添加顺序和取出顺序一致)、且可重复</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;hsp&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//2. List 集合中的每个元素都有其对应的顺序索引，即支持索引</span></span><br><span class="line"><span class="comment">// 使用get()方法获取元素，索引是从 0 开始的</span></span><br><span class="line">System.out.println(list.get(<span class="number">3</span>));<span class="comment">//hsp</span></span><br></pre></td></tr></table></figure>



<h3 id="14-4-2-常用方法"><a href="#14-4-2-常用方法" class="headerlink" title="14.4.2 常用方法"></a>14.4.2 常用方法</h3><ol>
<li>add</li>
<li>addAll</li>
<li><strong>get</strong></li>
<li>indexOf</li>
<li>lastIndexOf</li>
<li>remove</li>
<li><strong>set</strong>：替换或设置</li>
<li><strong>subList</strong>：子集合或切片</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;贾宝玉&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.void add(int index, Object ele):在 index 位置插入 ele 元素</span></span><br><span class="line"><span class="comment">//在 index = 1 的位置插入一个对象</span></span><br><span class="line">list.add(<span class="number">1</span>, <span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来</span></span><br><span class="line">List list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list2.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">list.addAll(<span class="number">1</span>, list2);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.Object get(int index):获取指定 index 位置的元素</span></span><br><span class="line">System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.int indexOf(Object obj):返回 obj 在集合中首次出现的位置</span></span><br><span class="line">System.out.println(list.indexOf(<span class="string">&quot;tom&quot;</span>));<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置</span></span><br><span class="line">list.add(<span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">System.out.println(list.lastIndexOf(<span class="string">&quot;韩顺平&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.Object remove(int index):移除指定 index 位置的元素，并返回此元素</span></span><br><span class="line">list.remove(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, &quot;玛丽&quot;);</span></span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合. </span></span><br><span class="line"><span class="comment">// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span></span><br><span class="line">List returnlist = list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;returnlist=&quot;</span> + returnlist);</span><br></pre></td></tr></table></figure>



<h3 id="14-3-3-遍历方式"><a href="#14-3-3-遍历方式" class="headerlink" title="14.3.3 遍历方式"></a>14.3.3 遍历方式</h3><ul>
<li><p>Iterator迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="keyword">new</span> Book(<span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;罗贯中&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Book(<span class="string">&quot;小李飞刀&quot;</span>, <span class="string">&quot;古龙&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Book(<span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;曹雪芹&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.先得到list的Iterator对象</span></span><br><span class="line">Iterator iterator = list.iterator();</span><br><span class="line"><span class="comment">// 2. 使用while循环遍历  快捷键 itit (ctrl+j可以查看所有快捷键)</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Object obj = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>增强for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用增强for循环遍历集合</span></span><br><span class="line"><span class="comment">// 底层仍然使用的是Iterator，debug看源码</span></span><br><span class="line"><span class="comment">// 快捷键 I</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : list) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>普通for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;obj=&quot;</span> + list.get(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="14-5-List-ArrayList"><a href="#14-5-List-ArrayList" class="headerlink" title="14.5 List - ArrayList"></a>14.5 List - ArrayList</h2><h3 id="14-5-1-注意事项"><a href="#14-5-1-注意事项" class="headerlink" title="14.5.1 注意事项"></a>14.5.1 注意事项</h3><ul>
<li>ArrayList允许所有元素，包括null；ArrayList<strong>可以加入null</strong>、并且多个</li>
<li>ArrayList是由<strong>数组来实现</strong>数据存储的</li>
<li>ArrayList基本等同于Vector，除了<strong>ArrayList是线程不安全</strong>(执行效率高)看源码。在多线程情况下，不建议使用数组列表</li>
</ul>
<h3 id="14-5-2-底层操作机制（重要！）"><a href="#14-5-2-底层操作机制（重要！）" class="headerlink" title="14.5.2 底层操作机制（重要！）"></a>14.5.2 底层操作机制（重要！）</h3><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>ArrayList中维护了一个**<font color="red">Object类型的数组elementData</font><strong>. [debug 看源码]<strong>。transient Object[] elementData</strong>; //<strong>transient</strong>表示瞬间,短暂的,表示该属性</strong>不会被序列号**</li>
<li>当创建ArrayList对象时，如果使用的是<strong>无参构造器</strong>，则初始elementData容量为**<font color="red">0</font><strong>，第1次添加，则扩容elementData为<font color="red"><strong>10</strong></font>，如需要再次扩容，则扩容elementData为</strong><font color="red">1.5</font>**倍（即第一次扩容为15，第二次22……）。</li>
<li>如果使用的是<strong>指定大小的构造器</strong>，则初始elementData容量为**<font color="red">指定大小</font><strong>，如果需要扩容,则直接扩容elementData为</strong><font color="red">1.5</font>**倍。</li>
</ol>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用无参构造器创建 ArrayList 对象</span></span><br><span class="line"><span class="comment">//ArrayList list = new ArrayList();</span></span><br><span class="line"><span class="comment">// 使用有参构造器创建 ArrayList 对象</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 for 给 list 集合添加 1-10个 数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 for 给 list 集合添加 11-15 数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">11</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line">list.add(<span class="number">200</span>);</span><br><span class="line">list.add(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102155326382.png" alt="image-20231102155326382"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102155512644.png" alt="image-20231102155512644"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102155550922.png" alt="image-20231102155550922"></p>
<h2 id="14-6-List-Vector"><a href="#14-6-List-Vector" class="headerlink" title="14.6 List - Vector"></a>14.6 List - Vector</h2><h3 id="14-6-1-注意事项"><a href="#14-6-1-注意事项" class="headerlink" title="14.6.1 注意事项"></a>14.6.1 注意事项</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103100547672.png" alt="image-20231103100547672"></p>
<h3 id="14-6-2-底层操作机制（重要！）"><a href="#14-6-2-底层操作机制（重要！）" class="headerlink" title="14.6.2 底层操作机制（重要！）"></a>14.6.2 底层操作机制（重要！）</h3><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>Vector中维护了一个**<font color="red">Object类型的数组elementData</font><strong>. 。</strong>protected Object[] elementData**; </li>
<li>当创建Vector对象时，如果使用的是<strong>无参构造器</strong>，则初始elementData容量为**<font color="red">10</font><strong>（调用有参构造器</strong>super(10)<strong>），之后每次扩容为原容量的</strong><font color="red"> 2 </font>**倍，即20, 40, 80…</li>
<li>如果使用的是<strong>指定大小的构造器</strong>，则初始elementData容量为**<font color="red">指定大小</font><strong>，如果需要扩容,则扩容elementData为原容量的</strong><font color="red"> 2 </font>**倍。</li>
</ol>
</div>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103102804447.png" alt="image-20231103102804447"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103103955275.png" alt="image-20231103103955275"><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103103955355.png" alt="image-20231103103955355"></p>
<h3 id="14-6-3-Vector-和-ArrayList-的比较"><a href="#14-6-3-Vector-和-ArrayList-的比较" class="headerlink" title="14.6.3 Vector 和 ArrayList 的比较"></a>14.6.3 Vector 和 ArrayList 的比较</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">底层结构</th>
<th align="center">版本</th>
<th align="center">线程安全（同步）效率</th>
<th align="center">扩容倍数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArrayList</td>
<td align="center">可变数组 transient Object[] elementData</td>
<td align="center">jdk1.2</td>
<td align="center">不安全，效率高</td>
<td align="center">（1）无参构造器：默认容量0，第一次扩容为10，后面每次扩容为1.5倍；（2）有参构造器：1.5倍</td>
</tr>
<tr>
<td align="center">Vector</td>
<td align="center">可变数组 protected Object[] elementData</td>
<td align="center">jdk1.0</td>
<td align="center">安全，效率低</td>
<td align="center">（1）无参构造器：默认容量为10，后面每次扩容为2倍；（2）有参构造器：2倍</td>
</tr>
</tbody></table>
<h2 id="14-7-List-LinkedList"><a href="#14-7-List-LinkedList" class="headerlink" title="14.7 List - LinkedList"></a>14.7 List - LinkedList</h2><h3 id="14-7-1-LinkedList-的全面说明"><a href="#14-7-1-LinkedList-的全面说明" class="headerlink" title="14.7.1 LinkedList 的全面说明"></a>14.7.1 LinkedList 的全面说明</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103105431067.png" alt="image-20231103105431067"></p>
<h3 id="14-7-2-底层操作机制"><a href="#14-7-2-底层操作机制" class="headerlink" title="14.7.2 底层操作机制"></a>14.7.2 底层操作机制</h3><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>LinkedList底层维护了一个**<font color="red">双向链表</font>**</li>
<li>LinedList中维护了两个属性 <font color="red">first</font> 和<font color="red"> last</font>，分别只想首节点和为节点</li>
<li>每个节点（Node）里面又维护了 <font color="red">pre、next、item</font>三个属性。pre指向前一个、next指向后一个节点，item存储数据</li>
<li>所以LinkedList元素的<font color="red">添加和删除</font>不是通过数组完成，相对来说<strong>效率较高</strong></li>
</ol>
</div>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103105629283.png" alt="image-20231103105629283"></p>
<ul>
<li><p>模拟一个简单的双向链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟一个简单的双向链表</span></span><br><span class="line">        Node jack = <span class="keyword">new</span> Node(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        Node tom = <span class="keyword">new</span> Node(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        Node hsp = <span class="keyword">new</span> Node(<span class="string">&quot;老韩&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接三个结点，形成双向链表</span></span><br><span class="line">        <span class="comment">//jack -&gt; tom -&gt; hsp</span></span><br><span class="line">        jack.next = tom;</span><br><span class="line">        tom.next = hsp;</span><br><span class="line">        <span class="comment">//hsp -&gt; tom -&gt; jack</span></span><br><span class="line">        hsp.pre = tom;</span><br><span class="line">        tom.pre = jack;</span><br><span class="line">        Node first = jack;<span class="comment">//让 first 引用指向 jack,就是双向链表的头结点</span></span><br><span class="line">        Node last = hsp; <span class="comment">//让 last 引用指向 hsp,就是双向链表的尾结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示，从头到尾进行遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===从头到尾进行遍历===&quot;</span>);</span><br><span class="line">        Node cur = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出 first 信息</span></span><br><span class="line">            System.out.println(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示，从尾到头的遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;====从尾到头的遍历====&quot;</span>);</span><br><span class="line">        cur = last;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出 last 信息</span></span><br><span class="line">            System.out.println(cur);</span><br><span class="line">            cur = cur.pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示 链表的添加对象/数据</span></span><br><span class="line">        <span class="comment">//要求，是在 tom 和 hsp 之间，插入一个对象 smith</span></span><br><span class="line">        <span class="comment">//1. 先创建一个 Node 结点，name 就是 smith</span></span><br><span class="line">        Node smith = <span class="keyword">new</span> Node(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        <span class="comment">//下面就把 smith 加入到双向链表了</span></span><br><span class="line">        smith.next = hsp;</span><br><span class="line">        smith.pre = tom;</span><br><span class="line">        hsp.pre = smith;</span><br><span class="line">        tom.next = smith;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个 Node 类，Node对象 表示双向链表的一个结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object item; <span class="comment">//真正存放数据</span></span><br><span class="line">    <span class="keyword">public</span> Node next; <span class="comment">//指向后一个结点</span></span><br><span class="line">    <span class="keyword">public</span> Node pre; <span class="comment">//指向前一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.item = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node name=&quot;</span> + item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>LinkedList增删改查及其源码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增删改查及其源码分析</span></span><br><span class="line">        LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        linkedList.add(<span class="number">1</span>);</span><br><span class="line">        linkedList.add(<span class="number">2</span>);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        linkedList.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;linkedlist=&quot;</span> + linkedList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        linkedList.remove();    <span class="comment">// 默认删除第一个节点</span></span><br><span class="line">        linkedList.remove(<span class="number">1</span>); <span class="comment">//删除第二个节点</span></span><br><span class="line">        System.out.println(<span class="string">&quot;linkedlist=&quot;</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        linkedList.set(<span class="number">1</span>, <span class="number">999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;linkedlist=&quot;</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        linkedList.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3种遍历</span></span><br><span class="line">        Iterator iterator = linkedList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;    <span class="comment">// 快捷键itit</span></span><br><span class="line">            Object next =  iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object o : linkedList) &#123;   <span class="comment">// 快捷键I</span></span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">            System.out.println(linkedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>增</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105143229015.png" alt="image-20231105143229015"></p>
</li>
<li><p>删</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105143254333.png" alt="image-20231105143254333"><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105143340454.png" alt="image-20231105143340454"></p>
</li>
<li><p>改</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105143408422.png" alt="image-20231105143408422"></p>
</li>
<li><p>查</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105143421789.png" alt="image-20231105143421789"></p>
</li>
</ul>
<h3 id="14-7-3-ArrayList和Linked比较"><a href="#14-7-3-ArrayList和Linked比较" class="headerlink" title="14.7.3 ArrayList和Linked比较"></a>14.7.3 ArrayList和Linked比较</h3><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删效率</th>
<th>改查效率</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>较低（数组扩容，创建新数组，数组拷贝）</td>
<td>较高（顺序存储，通过索引直接定位目标）</td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向链表</td>
<td>较高（通过链表追加和删除节点）</td>
<td>较低（非顺序存储，通过索引不能直接定位目标节点，需要顺着链表依次定位到目标节点）</td>
</tr>
</tbody></table>
<ul>
<li>怎么选择ArrayList和LinkedList<ul>
<li>如果我们<strong>改查</strong>的操作多，选择<strong>ArrayList</strong></li>
<li>如果我们<strong>增删</strong>的操作多，选择<strong>LinkedList</strong></li>
<li>一般来说，在程序中，80%-90%的都是查询，因此大部分情况下会选择ArrayList</li>
<li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList。</li>
</ul>
</li>
</ul>
<h2 id="14-8-Set接口"><a href="#14-8-Set接口" class="headerlink" title="14.8 Set接口"></a>14.8 Set接口</h2><h3 id="14-8-1-基本介绍"><a href="#14-8-1-基本介绍" class="headerlink" title="14.8.1 基本介绍"></a>14.8.1 基本介绍</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105150701433.png" alt="image-20231105150701433"></p>
<h3 id="14-8-2-常用方法"><a href="#14-8-2-常用方法" class="headerlink" title="14.8.2 常用方法"></a>14.8.2 常用方法</h3><ul>
<li><p>和 List 接口一样, Set 接口也是 Collection 的子接口，因此，常用方法和 Collection 接口一样.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 以HashSet为例，说明Set的方法</span><br><span class="line">//1. 以 Set 接口的实现类 HashSet 来讲解 Set 接口的方法</span><br><span class="line">//2. set 接口的实现类的对象(Set 接口对象), 不能存放重复的元素, 可以添加一个 null</span><br><span class="line">//3. set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致)</span><br><span class="line">//4. 注意：取出的顺序的顺序虽然不是添加的顺序，但是他的固定.</span><br><span class="line">Set set = new HashSet();</span><br><span class="line">set.add(&quot;john&quot;);</span><br><span class="line">set.add(&quot;lucy&quot;);</span><br><span class="line">set.add(&quot;john&quot;);//重复</span><br><span class="line">set.add(&quot;jack&quot;);</span><br><span class="line">set.add(&quot;hsp&quot;);</span><br><span class="line">set.add(&quot;mary&quot;);</span><br><span class="line">set.add(null);//</span><br><span class="line">set.add(null);//再次添加 null</span><br><span class="line">System.out.println(&quot;set=&quot; + set);</span><br><span class="line"></span><br><span class="line">// 其他方法参考Collection</span><br><span class="line">输出：</span><br><span class="line">set=[null, hsp, mary, john, lucy, jack]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="14-8-3-遍历方式"><a href="#14-8-3-遍历方式" class="headerlink" title="14.8.3 遍历方式"></a>14.8.3 遍历方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//方式 1： 使用迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;=====使用迭代器====&quot;</span>);</span><br><span class="line">Iterator iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">Object obj = iterator.next();</span><br><span class="line">System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式 2: 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;=====增强 for====&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;o=&quot;</span> + o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set 接口对象，不能通过索引来获取</span></span><br><span class="line"><span class="comment">//所以不能通过普通for循环遍历</span></span><br></pre></td></tr></table></figure>



<h2 id="14-9-Set-HashSet"><a href="#14-9-Set-HashSet" class="headerlink" title="14.9 Set - HashSet"></a>14.9 Set - HashSet</h2><h3 id="14-9-1-基本说明"><a href="#14-9-1-基本说明" class="headerlink" title="14.9.1 基本说明"></a>14.9.1 基本说明</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105152549978.png" alt="image-20231105152549978"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public HashSet() &#123;</span></span><br><span class="line"><span class="comment">map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">set.add(<span class="keyword">null</span>);</span><br><span class="line">set.add(<span class="keyword">null</span>);  <span class="comment">// 会返回false表示添加失败</span></span><br><span class="line">System.out.println(<span class="string">&quot;set=&quot;</span> + set);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 在执行 add 方法后，会返回一个 boolean 值</span></span><br><span class="line"><span class="comment">//2. 如果添加成功，返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">//3. 可以通过 remove 指定删除哪个对象</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;john&quot;</span>));<span class="comment">//T</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;lucy&quot;</span>));<span class="comment">//T</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;john&quot;</span>));<span class="comment">//F</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;jack&quot;</span>));<span class="comment">//T</span></span><br><span class="line">System.out.println(set.add(<span class="string">&quot;Rose&quot;</span>));<span class="comment">//T</span></span><br><span class="line">System.out.println(<span class="string">&quot;set=&quot;</span> + set);</span><br><span class="line"><span class="comment">// 输出顺序：set=[null, Rose, john, lucy, jack]</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>怎么理解**<font color="red">不能添加重复的元素或对象</font>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">set.add(<span class="string">&quot;lucy&quot;</span>);<span class="comment">//添加成功T</span></span><br><span class="line">set.add(<span class="string">&quot;lucy&quot;</span>);<span class="comment">//加入不了F</span></span><br><span class="line">set.add(<span class="keyword">new</span> Dog(<span class="string">&quot;tom&quot;</span>));<span class="comment">//T</span></span><br><span class="line">set.add(<span class="keyword">new</span> Dog(<span class="string">&quot;tom&quot;</span>));<span class="comment">//T（是两个不同的对象）</span></span><br><span class="line">System.out.println(<span class="string">&quot;set=&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">&quot;hsp&quot;</span>));<span class="comment">//T</span></span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">&quot;hsp&quot;</span>));<span class="comment">//F 添加失败，为什么？看add源码（调用equals进行比较）</span></span><br><span class="line">System.out.println(<span class="string">&quot;set=&quot;</span> + set);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="14-9-2-HashSet底层机制"><a href="#14-9-2-HashSet底层机制" class="headerlink" title="14.9.2 HashSet底层机制"></a>14.9.2 HashSet底层机制</h3><ul>
<li><p>HashSet底层是**<font color="red">HashMap</font>**，底层原理是<font color="red"> <strong>数组 + 链表 + 红黑树</strong></font></p>
</li>
<li><p>HashSet只使用到了HashMap中的Key，value是一个常量PRESENT。</p>
</li>
<li><p>模拟一个简单的 数组+链表结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetStructure</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟HashSet底层的 数组+链表结构</span></span><br><span class="line">        <span class="comment">// 1.创建数组(也叫作表)</span></span><br><span class="line">        Node[] table = <span class="keyword">new</span> Node[<span class="number">16</span>];</span><br><span class="line">        <span class="comment">// 2.创建节点</span></span><br><span class="line">        Node john = <span class="keyword">new</span> Node(<span class="string">&quot;john&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        table[<span class="number">2</span>] = john;</span><br><span class="line">        Node jack = <span class="keyword">new</span> Node(<span class="string">&quot;jack&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        john.next = jack;   <span class="comment">//挂载到john节点之后</span></span><br><span class="line">        Node rose = <span class="keyword">new</span> Node(<span class="string">&quot;rose&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        jack.next = rose;</span><br><span class="line"></span><br><span class="line">        Node lucy = <span class="keyword">new</span> Node(<span class="string">&quot;lucy&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        table[<span class="number">3</span>] = lucy;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Object item;    <span class="comment">//存放数据</span></span><br><span class="line">    Node next;      <span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String john, Object o)</span> </span>&#123;</span><br><span class="line">        item = john;</span><br><span class="line">        next = (Node) o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><a id="hashset"><strong>add底层源码分析</strong></a></li>
</ul>
<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>HashSet底层是<strong>HashMap</strong></li>
<li>添加一个元素时，先得到**<font color="red">hash值-会转成-&gt;索引值</font>**</li>
<li>找到存储数据表table，看这个索引位置是否已经存放的有元素<ul>
<li>如果没有，直接加入</li>
<li>如果有，调用 <strong><font color="red">equals</font></strong> 比较。如果相同，就放弃添加；如果不相同，则添加到最后</li>
</ul>
</li>
<li>在Java 8中，如果一条<strong>链表的元素个数</strong>到达TREEIFY_THRESHOLD(默认是<font color="red">8</font>)，并且<strong>table的大小</strong>&gt;=<br>MIN_TREEIFY_CAPACITY(默认<font color="red">64</font>)，就会进行<font color="red"><strong>树化(红黑树)</strong></font></li>
</ol>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet hashSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">hashSet.add(<span class="string">&quot;java&quot;</span>);<span class="comment">//到此位置，第 1 次 add 分析完毕.</span></span><br><span class="line">hashSet.add(<span class="string">&quot;php&quot;</span>);<span class="comment">//到此位置，第 2 次 add 分析完毕</span></span><br><span class="line">hashSet.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;set=&quot;</span> + hashSet);</span><br></pre></td></tr></table></figure>

<img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108123806622.png" alt="image-20231108123806622">

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108123834886.png" alt="image-20231108123834886"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108123910809.png" alt="image-20231108123910809"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108123936587.png" alt="image-20231108123936587"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108124038555.png" alt="image-20231108124038555"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108124055848.png" alt="image-20231108124055848"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108124106708.png" alt="image-20231108124106708"></p>
<ul>
<li><font color="red"><strong>扩容和转化成红黑树机制</strong></font></li>
</ul>
<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>HashSet底层是HashMap，第一次添加时，table数组扩容到**<font color="red">16</font><strong>，临界值(threshold)是</strong><font color="red">12</font>** 【16 * 加载因子<br>(loadFactor)0.75 = 12】</li>
<li>如果table数组使用到了临界值12，就会扩容到16 * 2 = <strong>32</strong>，新的临界值就是32 * 0.75 =<strong>24</strong>，依次类推</li>
<li>在Java8中, 如果一条链表的<font color="red">元素个数到达 TREEIFY_THRESHOLD(默认是8)</font>.并且<font color="red">table的大小&gt;=MIN TREEIFY CAPACITY(默认64),</font>就会进行**<font color="red">树化</font>**(红黑树)，否则仍然采用数组扩容机制</li>
</ol>
</div>

<p>【小技巧】怎么让不同对象挂载到table的统一条列表。重写类的hashCode方法使其返回同一个固定值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet hashSet = <span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    hashSet.add(i);<span class="comment">//1,2,3,4,5...100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108125936570.png" alt="image-20231108125936570"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line">    hashSet.add(<span class="keyword">new</span> A(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108130926446.png" alt="image-20231108130926446"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108131551385.png" alt="image-20231108131551385"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108131821816.png" alt="image-20231108131821816"></p>
<h3 id="14-9-3-HashSet练习题"><a href="#14-9-3-HashSet练习题" class="headerlink" title="14.9.3 HashSet练习题"></a>14.9.3 HashSet练习题</h3><ul>
<li><p>定义一个Employee类，该类包含：私有成员属性名称，年龄要求；<br>1.创建3个雇员对象放入HashSet中<br>2.当名称和Aage的值相同时，认为是相同员工，不能添加到HashSet集合中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Employee employee = (Employee) o;</span><br><span class="line">        <span class="keyword">return</span> age == employee.age &amp;&amp; Objects.equals(name, employee.name);	<span class="comment">//当name和age相同时会返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age); <span class="comment">//name和age(哈希值)相同会返回相同哈希值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义一个Employee类，该类包含:private成员属性name,sal,birthday(MyDate类型)，其中 birthday 为MyDate类型(属性包括:year, month, day),要求:<br>1.创建3个Employee放入HashSet中<br>2.当name和birthday的值相同时，认为是相同员工,不能添加到HashSet集合中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> sal;</span><br><span class="line">    <span class="keyword">private</span> MyDate birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee2</span><span class="params">(String name, <span class="keyword">double</span> sal, MyDate birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sal = sal;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Employee2 employee2 = (Employee2) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, employee2.name) &amp;&amp; Objects.equals(birthday, employee2.birthday);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.year = year;</span><br><span class="line">        <span class="keyword">this</span>.month = month;</span><br><span class="line">        <span class="keyword">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        MyDate myDate = (MyDate) o;</span><br><span class="line">        <span class="keyword">return</span> year == myDate.year &amp;&amp; month == myDate.month &amp;&amp; day == myDate.day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(year, month, day); <span class="comment">// year,month,day的哈希值相同，会返回相同的哈希值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>看看Objects.hash()源码</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109093116457.png" alt="image-20231109093116457"></p>
</li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109093157377.png" alt="image-20231109093157377"></p>
<ul>
<li><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115103348306.png" alt="image-20231115103348306"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">说明：修改之后的p1对象和原p1对象的hash值不一致，所以p1.name=&quot;CC&quot;以后，现在的p1对象用的是原p1对象的hash值索引位置，而不是它现在的hash值索引位置。</span></span><br><span class="line"><span class="comment">当set.add(new Person(1001, &quot;CC&quot;))后，在该对象的hash值索引位置不会比较到相同元素（原因如上），所以可以添加成功</span></span><br><span class="line"><span class="comment">当set.add(new Person(1001, &quot;AA&quot;))后，该对象会加在现p1对象链表的后面，因为hash值相同且和p1不equals</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetExercise3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        <span class="comment">//[Person&#123;name=&#x27;BB&#x27;, age=1002&#125;, Person&#123;name=&#x27;AA&#x27;, age=1001&#125;]</span></span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        <span class="comment">//[Person&#123;name=&#x27;BB&#x27;, age=1002&#125;, Person&#123;name=&#x27;CC&#x27;, age=1001&#125;]</span></span><br><span class="line">        System.out.println(set.remove(p1)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        <span class="comment">//[Person&#123;name=&#x27;BB&#x27;, age=1002&#125;, Person&#123;name=&#x27;CC&#x27;, age=1001&#125;, Person&#123;name=&#x27;CC&#x27;, age=1001&#125;]</span></span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        <span class="comment">//[Person&#123;name=&#x27;BB&#x27;, age=1002&#125;, Person&#123;name=&#x27;CC&#x27;, age=1001&#125;, Person&#123;name=&#x27;CC&#x27;, age=1001&#125;, Person&#123;name=&#x27;AA&#x27;, age=1001&#125;]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="14-10-Set-LinkedHashSet"><a href="#14-10-Set-LinkedHashSet" class="headerlink" title="14.10 Set - LinkedHashSet"></a>14.10 Set - LinkedHashSet</h2><h3 id="14-10-1-基本说明"><a href="#14-10-1-基本说明" class="headerlink" title="14.10.1 基本说明"></a>14.10.1 基本说明</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109103359524.png" alt="image-20231109103359524"></p>
<h3 id="14-10-2-LinkedHashSet底层机制"><a href="#14-10-2-LinkedHashSet底层机制" class="headerlink" title="14.10.2 LinkedHashSet底层机制"></a>14.10.2 LinkedHashSet底层机制</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109111130186.png" alt="image-20231109111130186"></p>
<ul>
<li>节点是LinkedHashMap$Entry类型（继承了HashMap$Node），有自身的before和tail属性，同时也有父类的next属性</li>
<li><strong>p.next = newNode(hash, key, value, null);</strong> 其实做了两件事：一是创建新节点(Entry类型)，且将新节点 **linkNodeLast()**接到双向列表tail尾节点处；二是将p.next指向新节点</li>
<li>疑问？afterNodeAccess(e);和afterNodeInsertion(evict);的作用是什么</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashSet linkedHashSet = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> Car(<span class="string">&quot;奥拓&quot;</span>, <span class="number">1000</span>));<span class="comment">//OK</span></span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> Car(<span class="string">&quot;奥迪&quot;</span>, <span class="number">300000</span>));<span class="comment">//OK</span></span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> Car(<span class="string">&quot;法拉利&quot;</span>, <span class="number">10000000</span>));<span class="comment">//OK</span></span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> Car(<span class="string">&quot;奥迪&quot;</span>, <span class="number">300000</span>));<span class="comment">//加入不了</span></span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> Car(<span class="string">&quot;保时捷&quot;</span>, <span class="number">70000000</span>));<span class="comment">//OK</span></span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> Car(<span class="string">&quot;奥迪&quot;</span>, <span class="number">300000</span>));<span class="comment">//加入不了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;linkedHashSet=&quot;</span> + linkedHashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. LinkedHashSet 加入顺序和取出元素顺序一致</span></span><br><span class="line">        <span class="comment">// 2. LinkedHashSet 底层维护的是一个LinkedHashMap(HashMap的子类)</span></span><br><span class="line">        <span class="comment">// 3. LinkedHashSet 底层结构 （数组table+双向链表）</span></span><br><span class="line">        <span class="comment">// 4. 第一次添加时，直接将数组table扩容到16，</span></span><br><span class="line">        <span class="comment">// 5. 数组table是HashMap$Node[]类型，存放的节点类型是LinkedHashMap$Entry（继承了HashMap$Node）</span></span><br><span class="line">        <span class="comment">/* Entry继承关系是在内部类完成的</span></span><br><span class="line"><span class="comment">        static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span></span><br><span class="line"><span class="comment">            LinkedHashMap.Entry&lt;K,V&gt; before, after;</span></span><br><span class="line"><span class="comment">            Entry(int hash, K key, V value, HashMap.Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">                super(hash, key, value, next);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\nCar&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写 equals 方法 和 hashCode</span></span><br><span class="line">    <span class="comment">//当 name 和 price 相同时， 就返回相同的 hashCode 值, equals 返回 t</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Car car = (Car) o;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(car.price, price) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                Objects.equals(name, car.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-11-Map接口"><a href="#14-11-Map接口" class="headerlink" title="14.11 Map接口"></a>14.11 Map接口</h2><h3 id="14-11-1-基本介绍"><a href="#14-11-1-基本介绍" class="headerlink" title="14.11.1 基本介绍"></a>14.11.1 基本介绍</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113103555012.png" alt="image-20231113103555012"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113104451042.png" alt="image-20231113104451042"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">&quot;no1&quot;</span>, <span class="string">&quot;韩顺平&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">    map.put(<span class="string">&quot;no2&quot;</span>, <span class="string">&quot;张无忌&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. k-v存储在 HashMap$Node node = new Node(hash,key,value,null)</span></span><br><span class="line"><span class="comment">        2. k-v为了方便遍历，还会创建 entrySet 集合，该集合存放的元素类型是 Entry</span></span><br><span class="line"><span class="comment">            而一个Entry对象有k,v  即 transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span></span><br><span class="line"><span class="comment">        3. entrySet中，定义的类型是Map.Entry，但实际存放的还是HashMap$Node</span></span><br><span class="line"><span class="comment">            因为hashMap$Node 实现了Map.Entry接口，即static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;&#123;&#125;</span></span><br><span class="line"><span class="comment">        4. 当把hashMap$Node 对象存放到 entrySet 就方便我们遍历，因为 Map.Entry提供了两个重要的方法</span></span><br><span class="line"><span class="comment">            K getKey(); V getValue();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    Set set = map.entrySet();</span><br><span class="line">    System.out.println(set.getClass()); <span class="comment">//HashMap$EntrySet</span></span><br><span class="line">    <span class="keyword">for</span> (Object obj : set) &#123;</span><br><span class="line">        System.out.println(obj.getClass()); <span class="comment">//HashMap$Node</span></span><br><span class="line">        <span class="comment">// 为了从HashMap$Node中取出k-v</span></span><br><span class="line">        <span class="comment">// 1.先向下转型</span></span><br><span class="line">        Map.Entry entry = (Map.Entry)obj;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;-&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set set1 = map.keySet();</span><br><span class="line">    System.out.println(set1.getClass()); <span class="comment">//HashMap$KeySet</span></span><br><span class="line">    Collection values = map.values();</span><br><span class="line">    System.out.println(values.getClass()); <span class="comment">//HashMap$Values</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-11-2-常用方法"><a href="#14-11-2-常用方法" class="headerlink" title="14.11.2 常用方法"></a>14.11.2 常用方法</h3><ol>
<li> put：添加k-v，若k存在则<strong>更新</strong>v</li>
<li>remove：根据键删除映射关系</li>
<li>get：根据键获取值</li>
<li>size:获取元素个数</li>
<li> isEmpty:判断个数是否为 0</li>
<li>clear:清除 所有k-v</li>
<li>containsKey:查找键是否存在</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//演示 map 接口常用方法</span></span><br><span class="line">        <span class="comment">// put：添加k-v，若k存在则更新v</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="keyword">new</span> Object());<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);<span class="comment">//替换-&gt; 一会分析源码</span></span><br><span class="line">        map.put(<span class="string">&quot;王宝强&quot;</span>, <span class="string">&quot;马蓉&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;宋喆&quot;</span>, <span class="string">&quot;马蓉&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;刘令博&quot;</span>, <span class="keyword">null</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="keyword">null</span>, <span class="string">&quot;刘亦菲&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;鹿晗&quot;</span>, <span class="string">&quot;关晓彤&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;hsp&quot;</span>, <span class="string">&quot;hsp 的老婆&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;map=&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove:根据键删除映射关系</span></span><br><span class="line">        map.remove(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;map=&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get：根据键获取值</span></span><br><span class="line">        Object val = map.get(<span class="string">&quot;鹿晗&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;val=&quot;</span> + val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// size:获取元素个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k-v=&quot;</span> + map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// isEmpty:判断个数是否为 0</span></span><br><span class="line">        System.out.println(map.isEmpty());<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear:清除 k-v</span></span><br><span class="line">        <span class="comment">//map.clear();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;map=&quot;</span> + map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// containsKey:查找键是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果=&quot;</span> + map.containsKey(<span class="string">&quot;hsp&quot;</span>));<span class="comment">//T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-11-3-遍历方式"><a href="#14-11-3-遍历方式" class="headerlink" title="14.11.3 遍历方式"></a>14.11.3 遍历方式</h3><ol>
<li><p>第一组: <strong>先取出 所有的 Key , 通过 Key 取出对应的 Value</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set keyset = map.keySet();</span><br><span class="line"><span class="comment">//(1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----第一种方式-------&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object key : keyset) &#123;</span><br><span class="line">System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;----第二种方式--------&quot;</span>);</span><br><span class="line">Iterator iterator = keyset.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">Object key = iterator.next();</span><br><span class="line">System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二组: <strong>把所有的 values 取出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection values = map.values();</span><br><span class="line"><span class="comment">//这里可以使用所有的 Collections 使用的遍历方法</span></span><br><span class="line"><span class="comment">//(1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;---取出所有的 value 增强 for----&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;---取出所有的 value 迭代器----&quot;</span>);</span><br><span class="line">Iterator iterator2 = values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">    Object value = iterator2.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第三组: <strong>通过 EntrySet 来获取 k-v</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set entrySet = map.entrySet();<span class="comment">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span></span><br><span class="line"><span class="comment">//(1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;----使用 EntrySet 的 for 增强(第 3 种)----&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">    <span class="comment">//将 entry 转成 Map.Entry</span></span><br><span class="line">    Map.Entry m = (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;----使用 EntrySet 的 迭代器(第 4 种)----&quot;</span>);</span><br><span class="line">Iterator iterator3 = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator3.hasNext()) &#123;</span><br><span class="line">    Object entry = iterator3.next();</span><br><span class="line">    <span class="comment">//System.out.println(entry.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)</span></span><br><span class="line">    <span class="comment">//向下转型 Map.Entry</span></span><br><span class="line">    Map.Entry m = (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="14-12-Map-HashMap"><a href="#14-12-Map-HashMap" class="headerlink" title="14.12 Map - HashMap"></a>14.12 Map - HashMap</h2><h3 id="14-12-1-基本说明"><a href="#14-12-1-基本说明" class="headerlink" title="14.12.1 基本说明"></a>14.12.1 基本说明</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113160440645.png" alt="image-20231113160440645"></p>
<h3 id="14-12-2-HashMap底层源码"><a href="#14-12-2-HashMap底层源码" class="headerlink" title="14.12.2 HashMap底层源码"></a>14.12.2 HashMap底层源码</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113163611349.png" alt="image-20231113163611349"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113163812898.png" alt="image-20231113163812898"></p>
<ul>
<li><p>put底层源码分析：具体流程与<a href="#hashset">HashSet底层机制</a>一样</p>
</li>
<li><p>需要补充的一点：当Key相同时，会更新对应的Value</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113164722020.png" alt="image-20231113164722020"></p>
</li>
<li><p>扩容和树化机制</p>
</li>
</ul>
<h2 id="14-13-Map-Hashtable"><a href="#14-13-Map-Hashtable" class="headerlink" title="14.13 Map - Hashtable"></a>14.13 Map - Hashtable</h2><h3 id="14-13-1-基本介绍"><a href="#14-13-1-基本介绍" class="headerlink" title="14.13.1 基本介绍"></a>14.13.1 基本介绍</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114101200404.png" alt="image-20231114101200404"></p>
<h3 id="14-13-2-底层机制"><a href="#14-13-2-底层机制" class="headerlink" title="14.13.2 底层机制"></a>14.13.2 底层机制</h3><ol>
<li>底层有Entry[]类型的数组table 初始化大小为**<font color="red">11</font>**</li>
<li>初始临界值 threshold <strong><font color="red">8</font></strong> = 11 * 0.75</li>
<li>扩容机制:<ul>
<li> 执行 addEntry(hash, key, value, index); 封装k-v到一个Entry</li>
<li>  当if (count &gt;= threshold) 满足时就扩容，指向rehash()</li>
<li> 按照 int newCapacity = (oldCapacity &lt;&lt; 1) + 1; 方式扩容</li>
</ul>
</li>
</ol>
<h3 id="14-13-2-Hashtable-VS-HashMap"><a href="#14-13-2-Hashtable-VS-HashMap" class="headerlink" title="14.13.2 Hashtable VS HashMap"></a>14.13.2 Hashtable VS HashMap</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114101241707.png" alt="image-20231114101241707"></p>
<h2 id="14-14-Map-Properties"><a href="#14-14-Map-Properties" class="headerlink" title="14.14 Map - Properties"></a>14.14 Map - Properties</h2><h3 id="14-14-1-基本介绍"><a href="#14-14-1-基本介绍" class="headerlink" title="14.14.1 基本介绍"></a>14.14.1 <a id="properties">基本介绍</a></h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114103553427.png" alt="image-20231114103553427"></p>
<p><a href="https://www.cnblogs.com/xudong-bupt/p/3758136.html">Java读取Properties配置文件</a></p>
<h2 id="14-15-开发中如何选择集合实现类（记住！）"><a href="#14-15-开发中如何选择集合实现类（记住！）" class="headerlink" title="14.15 开发中如何选择集合实现类（记住！）"></a>14.15 开发中如何选择集合实现类（记住！）</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114104350142.png" alt="image-20231114104350142"></p>
<h2 id="14-16-TreeSet-和-TreeMap"><a href="#14-16-TreeSet-和-TreeMap" class="headerlink" title="14.16 TreeSet 和 TreeMap"></a>14.16 TreeSet 和 TreeMap</h2><h3 id="14-16-1-TreeSet"><a href="#14-16-1-TreeSet" class="headerlink" title="14.16.1 TreeSet"></a>14.16.1 TreeSet</h3><ul>
<li><font color="red">注意：</font>如果TreeSet使用的是无参构造器，即没有传入Comparator接口的匿名内部类。使用add(key)时，底层会调用key实现的Comparable接口进行比较，Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; 如果Key没有实现Comparable接口，则会报错 ClassCastException</li>
<li><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115102142671.png" alt="image-20231115102142671"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 当我们使用无参构造器，创建 TreeSet 时，仍然是无序的</span></span><br><span class="line">        <span class="comment">//2. 希望添加的元素，按照字符串大小（或字符串长度）来排序</span></span><br><span class="line">        <span class="comment">//3. 使用 TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)</span></span><br><span class="line">        <span class="comment">// 并指定排序规则</span></span><br><span class="line">        TreeSet treeSet = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//下面调用 String 的 compareTo 方法进行字符串大小比较</span></span><br><span class="line">                <span class="comment">//如果老韩要求加入的元素，按照长度大小排序</span></span><br><span class="line">                <span class="comment">//return ((String) o2).compareTo((String) o1);</span></span><br><span class="line">                <span class="keyword">return</span> ((String) o1).length() - ((String) o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加数据.</span></span><br><span class="line">        treeSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;tom&quot;</span>);<span class="comment">//3</span></span><br><span class="line">        treeSet.add(<span class="string">&quot;sp&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;abc&quot;</span>);<span class="comment">//3 比较规则是长度，已经存在长度为3的元素，&quot;abc&quot;添加不了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;treeSet=&quot;</span> + treeSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 简单看看源码</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 构造器把传入的比较器对象，赋给了 TreeSet 的底层的 TreeMap 的属性 this.comparator</span></span><br><span class="line"><span class="comment">            public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span></span><br><span class="line"><span class="comment">                this.comparator = comparator;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        2. 在 调用 treeSet.add(&quot;tom&quot;), 在底层会执行到</span></span><br><span class="line"><span class="comment">            if (cpr != null) &#123; //cpr 就是我们的匿名内部类(对象)</span></span><br><span class="line"><span class="comment">                do &#123;</span></span><br><span class="line"><span class="comment">                    parent = t;</span></span><br><span class="line"><span class="comment">                    //动态绑定到我们的匿名内部类(对象)compare</span></span><br><span class="line"><span class="comment">                    cmp = cpr.compare(key, t.key);</span></span><br><span class="line"><span class="comment">                    if (cmp &lt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.left;</span></span><br><span class="line"><span class="comment">                    else if (cmp &gt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.right;</span></span><br><span class="line"><span class="comment">                    else //如果相等，即返回 0,这个 Key 就没有加入</span></span><br><span class="line"><span class="comment">                        return t.setValue(value);</span></span><br><span class="line"><span class="comment">                &#125; while (t != null);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-16-2-TreeMap"><a href="#14-16-2-TreeMap" class="headerlink" title="14.16.2 TreeMap"></a>14.16.2 TreeMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap treeMap = <span class="keyword">new</span> TreeMap(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//按照传入的 key(String) 的大小进行排序</span></span><br><span class="line">                <span class="comment">//按照 Key(String) 的长度大小排序</span></span><br><span class="line">                <span class="comment">//return ((String) o2).compareTo((String) o1);</span></span><br><span class="line">                <span class="keyword">return</span> ((String) o2).length() - ((String) o1).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;杰克&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;kristina&quot;</span>, <span class="string">&quot;克瑞斯提诺&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;smith&quot;</span>, <span class="string">&quot;斯密斯&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;hsp&quot;</span>, <span class="string">&quot;韩顺平&quot;</span>);<span class="comment">//加入不了,比较规则是Key的长度，已存在长度为3的Key</span></span><br><span class="line">        System.out.println(<span class="string">&quot;treemap=&quot;</span> + treeMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 源码解读</span></span><br><span class="line"><span class="comment">        1. 构造器. 把传入的实现了 Comparator 接口的匿名内部类(对象)，传给给 TreeMap 的 comparator</span></span><br><span class="line"><span class="comment">            public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span></span><br><span class="line"><span class="comment">                this.comparator = comparator;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2. 调用 put 方法</span></span><br><span class="line"><span class="comment">        2.1 第一次添加, 把 k-v 封装到 Entry 对象，放入 root</span></span><br><span class="line"><span class="comment">            Entry&lt;K,V&gt; t = root;</span></span><br><span class="line"><span class="comment">            if (t == null) &#123;</span></span><br><span class="line"><span class="comment">                compare(key, key); // type (and possibly null) check</span></span><br><span class="line"><span class="comment">                root = new Entry&lt;&gt;(key, value, null);</span></span><br><span class="line"><span class="comment">                size = 1;</span></span><br><span class="line"><span class="comment">                modCount++;</span></span><br><span class="line"><span class="comment">                return null;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        2.2 以后添加</span></span><br><span class="line"><span class="comment">            Comparator&lt;? super K&gt; cpr = comparator;</span></span><br><span class="line"><span class="comment">            if (cpr != null) &#123;</span></span><br><span class="line"><span class="comment">                do &#123; //遍历所有的 key , 给当前 key 找到适当位置</span></span><br><span class="line"><span class="comment">                    parent = t;</span></span><br><span class="line"><span class="comment">                    cmp = cpr.compare(key, t.key);//动态绑定到我们的匿名内部类的 compare</span></span><br><span class="line"><span class="comment">                    if (cmp &lt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.left;</span></span><br><span class="line"><span class="comment">                    else if (cmp &gt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.right;</span></span><br><span class="line"><span class="comment">                    else //如果遍历过程中，发现准备添加 Key 和当前已有的 Key 相等，就不添加</span></span><br><span class="line"><span class="comment">                         return t.setValue(value);</span></span><br><span class="line"><span class="comment">                &#125; while (t != null);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-17-Collections工具类"><a href="#14-17-Collections工具类" class="headerlink" title="14.17 Collections工具类"></a>14.17 Collections工具类</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114143658150.png" alt="image-20231114143658150"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114143810012.png" alt="image-20231114143810012"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建 ArrayList 集合，用于测试.</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;king&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;milan&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）reverse(List)：反转 List 中元素的顺序</span></span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2） shuffle(List)：对 List 集合元素进行随机排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">Collections.shuffle(list);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3）sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.println(<span class="string">&quot;自然排序后&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4）sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span></span><br><span class="line"><span class="comment">// 比如我们希望按照 字符串的长度大小排序</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((String) o2).length() - ((String) o1).length();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串长度大小排序=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6）swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line">Collections.swap(list, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;交换后的情况&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br></pre></td></tr></table></figure>



<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114144446373.png" alt="image-20231114144446373"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1）Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;自然顺序最大元素=&quot;</span> + Collections.max(list));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span></span><br><span class="line"><span class="comment">//比如，我们要返回长度最大的元素</span></span><br><span class="line">Object maxObject = Collections.max(list, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((String)o1).length() - ((String)o2).length();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;长度最大的元素=&quot;</span> + maxObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3）Object min(Collection)</span></span><br><span class="line"><span class="comment">// 4）Object min(Collection，Comparator)</span></span><br><span class="line"><span class="comment">//上面的两个方法，参考 max 即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5）int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</span></span><br><span class="line">System.out.println(<span class="string">&quot;tom 出现的次数=&quot;</span> + Collections.frequency(list, <span class="string">&quot;tom&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6）void copy(List dest,List src)：将 src 中的内容复制到 dest 中</span></span><br><span class="line">ArrayList dest = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//为了完成一个完整拷贝，我们需要先给 dest 赋值，大小和 list.size()一样</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">dest.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝</span></span><br><span class="line">Collections.copy(dest, list);</span><br><span class="line">System.out.println(<span class="string">&quot;dest=&quot;</span> + dest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7）boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span></span><br><span class="line">Collections.replaceAll(list, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list 替换后=&quot;</span> + list);</span><br></pre></td></tr></table></figure>



<h1 id="第十五章-泛型"><a href="#第十五章-泛型" class="headerlink" title="第十五章 泛型"></a>第十五章 泛型</h1><h2 id="15-1-泛型入门"><a href="#15-1-泛型入门" class="headerlink" title="15.1 泛型入门"></a>15.1 泛型入门</h2><h3 id="15-1-1-传统方法问题分析"><a href="#15-1-1-传统方法问题分析" class="headerlink" title="15.1.1 传统方法问题分析"></a>15.1.1 传统方法问题分析</h3><ul>
<li>不能对加入到集合ArrayList中的数据类型进行约束(不安全)</li>
<li>遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响</li>
</ul>
<h3 id="15-1-2-泛型的好处"><a href="#15-1-2-泛型的好处" class="headerlink" title="15.1.2  泛型的好处"></a>15.1.2  泛型的好处</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115152106005.png" alt="image-20231115152106005"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 当我们 ArrayList&lt;Dog&gt; 表示存放到 ArrayList 集合中的元素是 Dog 类型 (细节后面说...)</span></span><br><span class="line"><span class="comment">//2. 如果编译器发现添加的类型，不满足要求，就会报错</span></span><br><span class="line"><span class="comment">//3. 在遍历的时候，可以直接取出 Dog 类型而不是 Object</span></span><br><span class="line"><span class="comment">//4. public class ArrayList&lt;E&gt; &#123;&#125; E 称为泛型,那么 Dog-&gt;E</span></span><br><span class="line">ArrayList&lt;Dog&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">arrayList.add(<span class="keyword">new</span> Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>));</span><br><span class="line">arrayList.add(<span class="keyword">new</span> Dog(<span class="string">&quot;发财&quot;</span>, <span class="number">1</span>));</span><br><span class="line">arrayList.add(<span class="keyword">new</span> Dog(<span class="string">&quot;小黄&quot;</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">//假如我们的程序员，不小心，添加了一只猫</span></span><br><span class="line"><span class="comment">//arrayList.add(new Cat(&quot;招财猫&quot;, 8)); 编译会报错</span></span><br><span class="line">System.out.println(<span class="string">&quot;===使用泛型====&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Dog dog : arrayList) &#123;</span><br><span class="line">    System.out.println(dog.getName() + <span class="string">&quot;-&quot;</span> + dog.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="15-2-泛型介绍"><a href="#15-2-泛型介绍" class="headerlink" title="15.2 泛型介绍"></a>15.2 泛型介绍</h2><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li><strong>泛型</strong>又称**<font color="red">参数化类型</font><strong>，是Jdk5.0出现的新特性，解决</strong>数据类型的安全性问题**</li>
<li>在类声明或实例化时只要指定好需要的具体的类型即可。</li>
<li>JAVA泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生<strong>ClassCastException异常</strong>.同时，代码更加<strong>简洁、健壮</strong></li>
<li>泛型的作用是:可以在类声明时通过一个标识表示类中<strong>某个属性的类型</strong>，或者是某个方法<strong>返回值的类型</strong>，或者是某个方法的<strong>参数类型</strong>.</li>
</ol>
</div>



<h2 id="15-3-泛型的语法"><a href="#15-3-泛型的语法" class="headerlink" title="15.3 泛型的语法"></a>15.3 泛型的语法</h2><ul>
<li><p>声明</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115154817021.png" alt="image-20231115154817021"></p>
</li>
<li><p>实例化</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115154942951.png" alt="image-20231115154942951"></p>
</li>
<li><p>举例</p>
<ul>
<li><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115160310713.png" alt="image-20231115160310713"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericExercise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用泛型方式给 HashSet 放入 3 个学生对象</span></span><br><span class="line">        HashSet&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> Student(<span class="string">&quot;jack&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> Student(<span class="string">&quot;tom&quot;</span>, <span class="number">28</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> Student(<span class="string">&quot;mary&quot;</span>, <span class="number">19</span>));</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用泛型方式给 HashMap 放入 3 个学生对象</span></span><br><span class="line">        <span class="comment">//K -&gt; String   V-&gt;Student</span></span><br><span class="line">        HashMap&lt;String, Student&gt; hm = <span class="keyword">new</span> HashMap&lt;String, Student&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public class HashMap&lt;K,V&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        hm.put(<span class="string">&quot;milan&quot;</span>, <span class="keyword">new</span> Student(<span class="string">&quot;milan&quot;</span>, <span class="number">38</span>));</span><br><span class="line">        hm.put(<span class="string">&quot;smith&quot;</span>, <span class="keyword">new</span> Student(<span class="string">&quot;smith&quot;</span>, <span class="number">48</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span></span><br><span class="line"><span class="comment">                Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span></span><br><span class="line"><span class="comment">                return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Student&gt;&gt; entries = hm.entrySet();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span></span><br><span class="line"><span class="comment">                return new EntryIterator();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Student&gt;&gt; iterator = entries.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Student&gt; next =  iterator.next();</span><br><span class="line">            System.out.println(next.getKey() + <span class="string">&quot;=&quot;</span> + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="15-4-注意事项"><a href="#15-4-注意事项" class="headerlink" title="15.4 注意事项"></a>15.4 注意事项</h2><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ol>
<li>泛型的参数化类型只能是<strong>引用类型</strong>，不能是基本数据类型</li>
<li>在给泛型指定具体类型后，可以<strong>传入该类型或其子类类型</strong>。</li>
<li>不指定泛型的具体类型时，<strong>默认的泛型是Object</strong></li>
<li>泛型的使用形式：<ul>
<li><strong>List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();</strong></li>
<li><strong>List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();</strong> 【推荐】</li>
</ul>
</li>
</ol>
</div>



<h2 id="15-5-练习题"><a href="#15-5-练习题" class="headerlink" title="15.5 练习题"></a>15.5 练习题</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115172404368.png" alt="image-20231115172404368"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericExercise01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;durango&quot;</span>, <span class="number">18000</span>, <span class="keyword">new</span> MyDate(<span class="number">1999</span>, <span class="number">4</span>, <span class="number">2</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;durango&quot;</span>, <span class="number">18000</span>, <span class="keyword">new</span> MyDate(<span class="number">1999</span>, <span class="number">1</span>, <span class="number">2</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;durango&quot;</span>, <span class="number">18000</span>, <span class="keyword">new</span> MyDate(<span class="number">1999</span>, <span class="number">4</span>, <span class="number">20</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="string">&quot;aoiegn&quot;</span>, <span class="number">18000</span>, <span class="keyword">new</span> MyDate(<span class="number">2000</span>, <span class="number">7</span>, <span class="number">2</span>)));</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        list.sort(<span class="keyword">new</span> Comparator&lt;Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Employee o1, Employee o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> sal;</span><br><span class="line">    <span class="keyword">private</span> MyDate birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> sal, MyDate birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sal = sal;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSal</span><span class="params">(<span class="keyword">double</span> sal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sal = sal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyDate <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(MyDate birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&quot;</span> + name +</span><br><span class="line">                <span class="string">&quot;, sal=&quot;</span> + sal +</span><br><span class="line">                <span class="string">&quot;, birthday=&quot;</span> + birthday +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((c = <span class="keyword">this</span>.name.compareTo(o.name)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果名字相同，则比较生日</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.birthday.compareTo(o.birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">MyDate</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.year = year;</span><br><span class="line">        <span class="keyword">this</span>.month = month;</span><br><span class="line">        <span class="keyword">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYear</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.year = year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMonth</span><span class="params">(<span class="keyword">int</span> month)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.month = month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDay</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(MyDate o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y, m;</span><br><span class="line"><span class="comment">//        if ((y = this.year - o.year) == 0) &#123;</span></span><br><span class="line"><span class="comment">//            if ((m = this.month - o.month) == 0) &#123;</span></span><br><span class="line"><span class="comment">//                return this.day - o.day;</span></span><br><span class="line"><span class="comment">//            &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                return m;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            return y;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">// 简洁写法</span></span><br><span class="line">        <span class="keyword">if</span> ((y = <span class="keyword">this</span>.year - o.year) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 年份相同则比较月份</span></span><br><span class="line">        <span class="keyword">if</span> ((m = <span class="keyword">this</span>.month - o.month) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 月份相同比较天数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.day - o.day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-6-自定义泛型"><a href="#15-6-自定义泛型" class="headerlink" title="15.6 自定义泛型"></a>15.6 自定义泛型</h2><h3 id="15-6-1-自定义泛型类"><a href="#15-6-1-自定义泛型类" class="headerlink" title="15.6.1 自定义泛型类"></a>15.6.1 自定义泛型类</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116104904262.png" alt="image-20231116104904262"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类</span></span><br><span class="line"><span class="comment">//2, T, R, M 泛型的标识符, 一般是单个大写字母</span></span><br><span class="line"><span class="comment">//3. 泛型标识符可以有多个. //4. 普通成员可以使用泛型 (属性、方法)</span></span><br><span class="line"><span class="comment">//5. 使用泛型的数组，不能初始化</span></span><br><span class="line"><span class="comment">//6. 静态方法中不能使用类的泛型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span>&lt;<span class="title">T</span>, <span class="title">R</span>, <span class="title">M</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    R r; <span class="comment">//属性使用到泛型</span></span><br><span class="line">    M m;</span><br><span class="line">    T t;</span><br><span class="line">    <span class="comment">// T[] ts = new T[8];</span></span><br><span class="line">    <span class="comment">//因为数组在 new 时不能确定 T 的类型，就无法在内存中开辟空间</span></span><br><span class="line">    T[] ts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tiger</span><span class="params">(String name, R r, M m, T t)</span> </span>&#123;<span class="comment">//构造器使用泛型</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为静态是和类相关的，在类加载时，对象还没有创建</span></span><br><span class="line">    <span class="comment">//所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化</span></span><br><span class="line">    <span class="comment">// static R r2;</span></span><br><span class="line">    <span class="comment">// public static void m1(M m) &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法使用泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">getR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setR</span><span class="params">(R r)</span> </span>&#123;<span class="comment">//方法使用到泛型</span></span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> M <span class="title">getM</span><span class="params">()</span> </span>&#123;<span class="comment">//返回类型可以使用泛型. return m;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setM</span><span class="params">(M m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Tiger&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, r=&quot;</span> + r +</span><br><span class="line">                <span class="string">&quot;, m=&quot;</span> + m +</span><br><span class="line">                <span class="string">&quot;, t=&quot;</span> + t +</span><br><span class="line">                <span class="string">&quot;, ts=&quot;</span> + Arrays.toString(ts) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15-6-2-自定义泛型接口"><a href="#15-6-2-自定义泛型接口" class="headerlink" title="15.6.2 自定义泛型接口"></a>15.6.2 自定义泛型接口</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116110621493.png" alt="image-20231116110621493"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口使用的说明</span></span><br><span class="line"><span class="comment"> * 1. 接口中，静态成员也不能使用泛型</span></span><br><span class="line"><span class="comment"> * 2. 泛型接口的类型, 在继承接口或者实现接口时确定</span></span><br><span class="line"><span class="comment"> * 3. 没有指定类型，默认为 Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在继承接口 指定泛型接口的类型</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span> <span class="keyword">extends</span> <span class="title">IUsb</span>&lt;<span class="title">String</span>, <span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们去实现 IA 接口时，因为 IA 在继承 IUsu 接口时，指定了 U 为 String R 为 Double</span></span><br><span class="line"><span class="comment">//在实现 IUsu 接口的方法时，使用 String 替换 U, 使用 Double 替换 R</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">implements</span> <span class="title">IA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">get</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(Double aDouble)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Double r1, Double r2, String u1, String u2)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口时，直接指定泛型接口的类型</span></span><br><span class="line"><span class="comment">//给 U 指定 Integer，给 R 指定了 Float</span></span><br><span class="line"><span class="comment">//所以，当我们实现 IUsb 方法时，会使用 Integer 替换 U, 使用 Float 替换 R</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> <span class="keyword">implements</span> <span class="title">IUsb</span>&lt;<span class="title">Integer</span>, <span class="title">Float</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">get</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(Float aFloat)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Float r1, Float r2, Integer u1, Integer u2)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有指定类型，默认为 Object</span></span><br><span class="line"><span class="comment">//建议直接写成 IUsb&lt;Object,Object&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> <span class="keyword">implements</span> <span class="title">IUsb</span> </span>&#123; <span class="comment">//等价 class CC implements IUsb&lt;Object,Object&gt;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Object r1, Object r2, Object u1, Object u2)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUsb</span>&lt;<span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//U name; 不能这样使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通方法中，可以使用接口泛型</span></span><br><span class="line">    <span class="function">R <span class="title">get</span><span class="params">(U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hi</span><span class="params">(R r)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(R r1, R r2, U u1, U u2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 jdk8 中，可以在接口中使用默认方法, 也是可以使用泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> R <span class="title">method</span><span class="params">(U u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15-6-3-自定义泛型方法"><a href="#15-6-3-自定义泛型方法" class="headerlink" title="15.6.3 自定义泛型方法"></a>15.6.3 自定义泛型方法</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119145951717.png" alt="image-20231119145951717"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomMethodGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        car.fly(<span class="string">&quot;宝马&quot;</span>, <span class="number">100</span>);<span class="comment">//当调用方法时，传入参数，编译器，就会确定类型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">        car.fly(<span class="number">300</span>, <span class="number">100.1</span>);<span class="comment">//当调用方法时，传入参数，编译器，就会确定类型</span></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="comment">//T-&gt;String, R-&gt; ArrayList</span></span><br><span class="line">        Fish&lt;String, ArrayList&gt; fish = <span class="keyword">new</span> Fish&lt;&gt;();</span><br><span class="line">        fish.hello(<span class="keyword">new</span> ArrayList(), <span class="number">11.3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型方法，可以定义在普通类中, 也可以定义在泛型类中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;<span class="comment">//普通类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明 泛型方法</span></span><br><span class="line">    <span class="comment">//1. &lt;T,R&gt; 就是泛型</span></span><br><span class="line">    <span class="comment">//2. 是提供给 fly 使用的</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(T t, R r)</span> </span>&#123;<span class="comment">//泛型方法</span></span><br><span class="line">        System.out.println(t.getClass());<span class="comment">//String</span></span><br><span class="line">        System.out.println(r.getClass());<span class="comment">//Integer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;<span class="comment">//泛型类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;U, M&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(U u, M m)</span> </span>&#123;<span class="comment">//泛型方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 下面 hi 方法不是泛型方法</span></span><br><span class="line">    <span class="comment">//2. 只是 hi 方法使用了类声明的 泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K&gt; <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(R r, K k)</span> </span>&#123;</span><br><span class="line">        System.out.println(r.getClass());<span class="comment">//ArrayList</span></span><br><span class="line">        System.out.println(k.getClass());<span class="comment">//Float</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-7-泛型的继承和通配符"><a href="#15-7-泛型的继承和通配符" class="headerlink" title="15.7 泛型的继承和通配符"></a>15.7 泛型的继承和通配符</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119151234218.png" alt="image-20231119151234218"></p>
<h2 id="15-8-JUnit单元测试类"><a href="#15-8-JUnit单元测试类" class="headerlink" title="15.8 JUnit单元测试类"></a>15.8 JUnit单元测试类</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119152211721.png" alt="image-20231119152211721"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119152603009.png" alt="image-20231119152603009"></p>
<h1 id="第十六章-坦克大战【1】"><a href="#第十六章-坦克大战【1】" class="headerlink" title="第十六章 坦克大战【1】"></a>第十六章 坦克大战【1】</h1><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120105005091.png" alt="image-20231120105005091"></p>
<h2 id="16-1-绘制坦克"><a href="#16-1-绘制坦克" class="headerlink" title="16.1 绘制坦克"></a>16.1 绘制坦克</h2><h3 id="16-1-1-坐标和像素"><a href="#16-1-1-坐标和像素" class="headerlink" title="16.1.1 坐标和像素"></a>16.1.1 坐标和像素</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119155510069.png" alt="image-20231119155510069"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119155552024.png" alt="image-20231119155552024"></p>
<ul>
<li><p>绘制一个圆形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawCircle</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123; <span class="comment">// DrawCircle继承JFrame，画框类（一个窗口）</span></span><br><span class="line">    <span class="keyword">private</span> MyPanel mp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DrawCircle();</span><br><span class="line">        System.out.println(<span class="string">&quot;退出程序~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawCircle</span><span class="params">()</span> </span>&#123; <span class="comment">//构造器</span></span><br><span class="line">        <span class="comment">// 初始化画板</span></span><br><span class="line">        mp = <span class="keyword">new</span> MyPanel();</span><br><span class="line">        <span class="comment">// 把画板加入到画框（窗口）</span></span><br><span class="line">        <span class="keyword">this</span>.add(mp);</span><br><span class="line">        <span class="comment">// 设置窗口大小</span></span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">        <span class="comment">//当点击窗口的小×，程序完全退出.</span></span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="comment">// 设置可以显示</span></span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.先定义一个MyPanel，继承JPanel类，画板类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> </span>&#123;</span><br><span class="line">    <span class="comment">//说明:</span></span><br><span class="line">    <span class="comment">//1. MyPanel 对象就是一个画板</span></span><br><span class="line">    <span class="comment">//2. Graphics g 把 g 理解成一支画笔</span></span><br><span class="line">    <span class="comment">//3. Graphics 提供了很多绘图的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123; <span class="comment">//绘图方法</span></span><br><span class="line">        <span class="keyword">super</span>.paint(g);</span><br><span class="line">        System.out.println(<span class="string">&quot;paint方法被调用了&quot;</span>);</span><br><span class="line">        <span class="comment">// 画圆形</span></span><br><span class="line">        g.drawOval(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="16-1-2-绘图原理"><a href="#16-1-2-绘图原理" class="headerlink" title="16.1.2 绘图原理"></a>16.1.2 绘图原理</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119163054954.png" alt="image-20231119163054954"></p>
<h3 id="16-1-3-Graphics类"><a href="#16-1-3-Graphics类" class="headerlink" title="16.1.3 Graphics类"></a>16.1.3 Graphics类</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119163153997.png" alt="image-20231119163153997"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画圆形</span></span><br><span class="line">g.drawOval(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示绘制不同的图形..</span></span><br><span class="line"><span class="comment">//画直线 drawLine(int x1,int y1,int x2,int y2)</span></span><br><span class="line">g.drawLine(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//画矩形边框 drawRect(int x, int y, int width, int height)</span></span><br><span class="line">g.drawRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//画椭圆边框 drawOval(int x, int y, int width, int height)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//填充矩形 fillRect(int x, int y, int width, int height)</span></span><br><span class="line"><span class="comment">//设置画笔的颜色</span></span><br><span class="line">g.setColor(Color.blue);</span><br><span class="line">g.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充椭圆 fillOval(int x, int y, int width, int height)</span></span><br><span class="line">g.setColor(Color.red);</span><br><span class="line">g.fillOval(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//画图片 drawImage(Image img, int x, int y, ..)</span></span><br><span class="line"><span class="comment">//1. 获取图片资源, /bg.png 表示在该项目的根目录[chapter16/out/production/chapter16]去获取 bq.png 图片资源</span></span><br><span class="line">Image image = Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="string">&quot;/bq.png&quot;</span>));</span><br><span class="line">g.drawImage(image, <span class="number">10</span>, <span class="number">10</span>, <span class="number">175</span>, <span class="number">221</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//画字符串 drawString(String str, int x, int y)//写字</span></span><br><span class="line"><span class="comment">//给画笔设置颜色和字体</span></span><br><span class="line">g.setColor(Color.red);</span><br><span class="line">g.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;隶书&quot;</span>, Font.BOLD, <span class="number">50</span>));</span><br><span class="line"><span class="comment">//这里设置的 100， 100， 是 &quot;北京你好&quot;左下角</span></span><br><span class="line">g.drawString(<span class="string">&quot;北京你好&quot;</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>



<h3 id="16-1-4-绘制坦克"><a href="#16-1-4-绘制坦克" class="headerlink" title="16.1.4 绘制坦克"></a>16.1.4 绘制坦克</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119174509641.png" alt="image-20231119174509641"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> </span>&#123; <span class="comment">//自定义画板类</span></span><br><span class="line">    Hero hero = <span class="keyword">null</span>; <span class="comment">// 定义我的坦克</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hero = <span class="keyword">new</span> Hero(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">// 初始化坦克</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.paint(g);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="number">750</span>); <span class="comment">//填充背景，默认是黑色</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 画出坦克-封装成方法</span></span><br><span class="line">        drawTank(hero.getX(), hero.getY(), g, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        drawTank(hero.getX() - <span class="number">50</span>, hero.getY(), g, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 画坦克</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x      左上角坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y      右上角坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> g      画笔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> direct 方向（上下左右）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type   坦克类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTank</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Graphics g, <span class="keyword">int</span> direct, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据不同坦克类型，设置不同颜色</span></span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//我们的坦克</span></span><br><span class="line">                g.setColor(Color.cyan);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//敌人的坦克</span></span><br><span class="line">                g.setColor(Color.yellow);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据坦克方向，绘制坦克</span></span><br><span class="line">        <span class="keyword">switch</span> (direct) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//向上</span></span><br><span class="line">                g.fill3DRect(x, y, <span class="number">10</span>, <span class="number">60</span>, <span class="keyword">false</span>); <span class="comment">//左边轮子</span></span><br><span class="line">                g.fill3DRect(x + <span class="number">30</span>, y, <span class="number">10</span>, <span class="number">60</span>, <span class="keyword">false</span>); <span class="comment">//右边轮子</span></span><br><span class="line">                g.fill3DRect(x + <span class="number">10</span>, y + <span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="keyword">false</span>); <span class="comment">//中间部分</span></span><br><span class="line">                g.fillOval(x + <span class="number">10</span>, y + <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>); <span class="comment">//中间的圆</span></span><br><span class="line">                g.drawLine(x + <span class="number">20</span>, y + <span class="number">30</span>, x + <span class="number">20</span>, y); <span class="comment">//炮筒</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;没有处理&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="16-2-java事件处理机制"><a href="#16-2-java事件处理机制" class="headerlink" title="16.2 java事件处理机制"></a>16.2 java事件处理机制</h2><h3 id="16-2-1-小球移动"><a href="#16-2-1-小球移动" class="headerlink" title="16.2.1 小球移动"></a>16.2.1 小球移动</h3><ul>
<li>MyPanel要实现KeyListener键盘监听器，并实现对应监听方法（逻辑是 哪个键 ==&gt; 哪个变量变化），注意要**repaint()**才能看到画面变化</li>
<li>BallMove窗口要添加这个监听器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BallMove</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyPanel mp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BallMove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BallMove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mp = <span class="keyword">new</span> MyPanel();</span><br><span class="line">        <span class="keyword">this</span>.add(mp);</span><br><span class="line">        <span class="comment">// 使窗口 JFrame 对象可以监听键盘事件, 即可以监听到面板发生的键盘事件</span></span><br><span class="line">        <span class="keyword">this</span>.addKeyListener(mp);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KeyListener监听器，可以监听键盘事件KeyEvent</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">Panel</span> <span class="keyword">implements</span> <span class="title">KeyListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">10</span>; <span class="comment">//小球初始坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.paint(g);</span><br><span class="line">        g.fillOval(x, y, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有字符输出时，该方法触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyTyped</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有按键按下时，该方法触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) e.getKeyCode() + <span class="string">&quot;被按下..&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据按下的键控制小球移动(每个键分配了一个int值)</span></span><br><span class="line">        <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_DOWN) &#123; <span class="comment">//向下</span></span><br><span class="line">            y++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_UP) &#123; <span class="comment">//向上</span></span><br><span class="line">            y--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_LEFT) &#123; <span class="comment">//向左</span></span><br><span class="line">            x--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_RIGHT) &#123; <span class="comment">//向右</span></span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新绘制面板</span></span><br><span class="line">        <span class="keyword">this</span>.repaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有按键松开时，该方法出发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyReleased</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="16-2-2-事件处理机制"><a href="#16-2-2-事件处理机制" class="headerlink" title="16.2.2 事件处理机制"></a>16.2.2 事件处理机制</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120094737864.png" alt="image-20231120094737864"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120094802149.png" alt="image-20231120094802149"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120095147376.png" alt="image-20231120095147376"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120095208027.png" alt="image-20231120095208027"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120095314114.png" alt="image-20231120095314114"></p>
<h2 id="16-3-坦克移动"><a href="#16-3-坦克移动" class="headerlink" title="16.3 坦克移动"></a>16.3 坦克移动</h2><ul>
<li><p>绘制不同方向的坦克</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTank</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Graphics g, <span class="keyword">int</span> direct, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据不同坦克类型，设置不同颜色</span></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 根据不同方向，绘制坦克</span></span><br><span class="line">        <span class="keyword">switch</span> (direct) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//向上</span></span><br><span class="line">                g.fill3DRect(x, y, <span class="number">10</span>, <span class="number">60</span>, <span class="keyword">false</span>); <span class="comment">//左边轮子</span></span><br><span class="line">                g.fill3DRect(x + <span class="number">30</span>, y, <span class="number">10</span>, <span class="number">60</span>, <span class="keyword">false</span>); <span class="comment">//右边轮子</span></span><br><span class="line">                g.fill3DRect(x + <span class="number">10</span>, y + <span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="keyword">false</span>); <span class="comment">//中间部分</span></span><br><span class="line">                g.fillOval(x + <span class="number">10</span>, y + <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>); <span class="comment">//中间的圆</span></span><br><span class="line">                g.drawLine(x + <span class="number">20</span>, y + <span class="number">30</span>, x + <span class="number">20</span>, y); <span class="comment">//炮筒</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//向右</span></span><br><span class="line">                g.fill3DRect(x, y, <span class="number">60</span>, <span class="number">10</span>, <span class="keyword">false</span>); <span class="comment">//左边轮子</span></span><br><span class="line">                g.fill3DRect(x, y + <span class="number">30</span>, <span class="number">60</span>, <span class="number">10</span>, <span class="keyword">false</span>); <span class="comment">//右边轮子</span></span><br><span class="line">                g.fill3DRect(x + <span class="number">10</span>, y + <span class="number">10</span>, <span class="number">40</span>, <span class="number">20</span>, <span class="keyword">false</span>); <span class="comment">//中间部分</span></span><br><span class="line">                g.fillOval(x + <span class="number">20</span>, y + <span class="number">10</span>, <span class="number">20</span>, <span class="number">20</span>); <span class="comment">//中间的圆</span></span><br><span class="line">                g.drawLine(x + <span class="number">30</span>, y + <span class="number">20</span>, x + <span class="number">60</span>, y + <span class="number">20</span>); <span class="comment">//炮筒</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//向下</span></span><br><span class="line">                g.fill3DRect(x, y, <span class="number">10</span>, <span class="number">60</span>, <span class="keyword">false</span>); <span class="comment">//右边轮子</span></span><br><span class="line">                g.fill3DRect(x + <span class="number">30</span>, y, <span class="number">10</span>, <span class="number">60</span>, <span class="keyword">false</span>); <span class="comment">//左边轮子</span></span><br><span class="line">                g.fill3DRect(x + <span class="number">10</span>, y + <span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="keyword">false</span>); <span class="comment">//中间部分</span></span><br><span class="line">                g.fillOval(x + <span class="number">10</span>, y + <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>); <span class="comment">//中间的圆</span></span><br><span class="line">                g.drawLine(x + <span class="number">20</span>, y + <span class="number">30</span>, x + <span class="number">20</span>, y + <span class="number">60</span>); <span class="comment">//炮筒</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//向左</span></span><br><span class="line">                g.fill3DRect(x, y, <span class="number">60</span>, <span class="number">10</span>, <span class="keyword">false</span>); <span class="comment">//左边轮子</span></span><br><span class="line">                g.fill3DRect(x, y + <span class="number">30</span>, <span class="number">60</span>, <span class="number">10</span>, <span class="keyword">false</span>); <span class="comment">//右边轮子</span></span><br><span class="line">                g.fill3DRect(x + <span class="number">10</span>, y + <span class="number">10</span>, <span class="number">40</span>, <span class="number">20</span>, <span class="keyword">false</span>); <span class="comment">//中间部分</span></span><br><span class="line">                g.fillOval(x + <span class="number">20</span>, y + <span class="number">10</span>, <span class="number">20</span>, <span class="number">20</span>); <span class="comment">//中间的圆</span></span><br><span class="line">                g.drawLine(x + <span class="number">30</span>, y + <span class="number">20</span>, x, y + <span class="number">20</span>); <span class="comment">//炮筒</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;没有处理&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>监听键盘事件，让坦克移动。注意：repaint() 和 addListener()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.getKeyCode() == KeyEvent.VK_W) &#123; <span class="comment">//W 上</span></span><br><span class="line">        <span class="comment">// 修改方向</span></span><br><span class="line">        hero.setDirect(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 修改坐标</span></span><br><span class="line">        hero.moveUp();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_D) &#123; <span class="comment">// D 右</span></span><br><span class="line">        hero.setDirect(<span class="number">1</span>);</span><br><span class="line">        hero.moveRight();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_S) &#123; <span class="comment">// S 下</span></span><br><span class="line">        hero.setDirect(<span class="number">2</span>);</span><br><span class="line">        hero.moveDown();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_A) &#123; <span class="comment">// A 左</span></span><br><span class="line">        hero.setDirect(<span class="number">3</span>);</span><br><span class="line">        hero.moveLeft();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写绘制画板</span></span><br><span class="line">    <span class="keyword">this</span>.repaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="16-4-作业"><a href="#16-4-作业" class="headerlink" title="16.4 作业"></a>16.4 作业</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120103410941.png" alt="image-20231120103410941"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">KeyListener</span> </span>&#123; <span class="comment">//自定义画板类</span></span><br><span class="line">    Hero hero = <span class="keyword">null</span>; <span class="comment">// 定义我的坦克</span></span><br><span class="line">    <span class="comment">// 定义敌人的坦克，放入Vector集合中（线程安全）</span></span><br><span class="line">    Vector&lt;Enemy&gt; enemies = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> enemySize = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hero = <span class="keyword">new</span> Hero(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">// 初始化自己的坦克</span></span><br><span class="line">        hero.setSpeed(<span class="number">5</span>); <span class="comment">// 初始化坦克速度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化敌人坦克</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enemySize; i++) &#123;</span><br><span class="line">            Enemy enemy = <span class="keyword">new</span> Enemy(<span class="number">100</span> * (i + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">            enemy.setDirect(<span class="number">2</span>); <span class="comment">// 设置初始炮筒方向</span></span><br><span class="line">            enemies.add(enemy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.paint(g);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="number">750</span>); <span class="comment">//填充背景，默认是黑色</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 画出坦克-封装成方法</span></span><br><span class="line">        drawTank(hero.getX(), hero.getY(), g, hero.getDirect(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 画出敌人坦克(遍历Vector)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enemies.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 取出坦克并绘制</span></span><br><span class="line">            Enemy enemy = enemies.get(i);</span><br><span class="line">            drawTank(enemy.getX(), enemy.getY(), g, enemy.getDirect(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="第十七章-多线程基础"><a href="#第十七章-多线程基础" class="headerlink" title="第十七章 多线程基础"></a>第十七章 多线程基础</h1><h2 id="17-1-线程相关概念"><a href="#17-1-线程相关概念" class="headerlink" title="17.1 线程相关概念"></a>17.1 线程相关概念</h2><ol>
<li>程序、<ul>
<li>是为完成特定任务、用某种语言编写的一组指令的集合。简单的说:就是我们写的代码</li>
</ul>
</li>
<li>进程<ul>
<li>进程是指<strong>运行中的程序</strong>，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配新的内存空间.</li>
<li>进程是<strong>程序的一次执行过程</strong>，或是正在运行的一个程序.是动态过程:有它自身的产生、存在和消亡过程</li>
</ul>
</li>
<li>线程<ul>
<li>线程由进程创建的，是进程的一个实体</li>
<li>一个进程可以拥有多个线程</li>
</ul>
</li>
<li>其他概念<ul>
<li><strong>单线程</strong>: 同一个时刻，只允许执行一个线程</li>
<li><strong>多线程</strong>: 同一个时刻，可以执行多个线程，比如:一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件</li>
<li><strong>并发</strong>: 同一个时刻，多个任务<strong>交替执行</strong>，造成一种<strong>“貌似同时”的错觉</strong>，简单的说, 单核cpu实现的多任务就是并发。</li>
<li><strong>并行</strong>: 同一个时刻，多个任务同时执行。多核cpu可以实现并行。</li>
</ul>
</li>
</ol>
<h2 id="17-2-线程基本使用"><a href="#17-2-线程基本使用" class="headerlink" title="17.2 线程基本使用"></a>17.2 线程基本使用</h2><h3 id="17-2-1-创建线程的两种方式"><a href="#17-2-1-创建线程的两种方式" class="headerlink" title="17.2.1 创建线程的两种方式"></a>17.2.1 创建线程的两种方式</h3><ol>
<li><p><strong>继承Thread 类</strong>, 重写run方法</p>
</li>
<li><p><strong>实现Runnable接口</strong>, 重写run方法</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121104552926.png" alt="image-20231121104552926"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121093524733.png" alt="image-20231121093524733"></p>
</li>
</ol>
<h3 id="17-2-2-继承Thread类"><a href="#17-2-2-继承Thread类" class="headerlink" title="17.2.2 继承Thread类"></a>17.2.2 继承Thread类</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121095419896.png" alt="image-20231121095419896"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121101159823.png" alt="image-20231121101159823"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121101613160.png" alt="image-20231121101613160"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Cat 对象，可以当做线程使用</span></span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        cat.start(); <span class="comment">////启动线程-&gt;start0()-&gt; 最终会执行cat的run方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        (1)</span></span><br><span class="line"><span class="comment">        public synchronized void start() &#123;</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">            start0();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        (2)</span></span><br><span class="line"><span class="comment">        start0() 是本地方法，是 JVM 调用, 底层是 c/c++实现真正实现多线程的效果， 是 start0(), 而不是 run</span></span><br><span class="line"><span class="comment">        private native void start0();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//cat.run();//run 方法就是一个普通的方法, 没有真正的启动一个线程，就会把 run方法执行完毕，然后才向下执行</span></span><br><span class="line">        <span class="comment">//说明: 当 main 线程启动一个子线程 Thread-0, 主线程不会阻塞, 会继续执行</span></span><br><span class="line">        <span class="comment">//这时 主线程和子线程是交替执行..</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行&quot;</span> + Thread.currentThread().getName());<span class="comment">//名字 main</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; i=&quot;</span> + i);</span><br><span class="line">            <span class="comment">//让主线程休眠</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 当一个类继承了 Thread 类， 该类就可以当做线程使用</span></span><br><span class="line"><span class="comment">//2. 我们会重写 run 方法，写上自己的业务代码</span></span><br><span class="line"><span class="comment">//3. Thread类 实现了 Runnable接口 的 run 方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@Override</span></span><br><span class="line"><span class="comment">public void run() &#123;</span></span><br><span class="line"><span class="comment">    if (target != null) &#123;</span></span><br><span class="line"><span class="comment">        target.run();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//该线程每隔 1 秒。在控制台输出 “喵喵, 我是小猫咪”</span></span><br><span class="line">            System.out.println(<span class="string">&quot;喵喵, 我是小猫咪&quot;</span> + (++times) + <span class="string">&quot; 线程名=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 让线程休眠一秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">80</span>) &#123; <span class="comment">// times到达80时，子线程执行完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="17-2-3-实现Runnable接口"><a href="#17-2-3-实现Runnable接口" class="headerlink" title="17.2.3 实现Runnable接口"></a>17.2.3 实现Runnable接口</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121102613498.png" alt="image-20231121102613498"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">//dog.start() //错误，Dog类没有start</span></span><br><span class="line">        <span class="comment">//创建Thread对象，把Dog对象（实现了Runnable）放入Thread</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(dog);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">//实现Runnable接口来开发线程</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小狗汪汪叫..hi&quot;</span> + (++count) + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>模拟一个简单的Thread代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Tiger tiger = new Tiger();//实现了 Runnable</span></span><br><span class="line">        <span class="comment">// ThreadProxy threadProxy = new ThreadProxy(tiger);</span></span><br><span class="line">        <span class="comment">// threadProxy.start();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老虎嗷嗷叫....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程代理类 , 模拟了一个极简的 Thread 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadProxy</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">//你可以把 Proxy 类当做 ThreadProxy</span></span><br><span class="line">    <span class="keyword">private</span> Runnable target = <span class="keyword">null</span>;<span class="comment">//属性，类型是 Runnable</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();<span class="comment">//动态绑定（运行类型 Tiger）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadProxy</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        start0();<span class="comment">//这个方法时真正实现多线程方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="17-2-4-多线程案例"><a href="#17-2-4-多线程案例" class="headerlink" title="17.2.4 多线程案例"></a>17.2.4 多线程案例</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121104204115.png" alt="image-20231121104204115"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T1 t1 = <span class="keyword">new</span> T1();</span><br><span class="line">        T2 t2 = <span class="keyword">new</span> T2();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(t1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(t2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 每个1s输出“hello, world!”，输出10次</span></span><br><span class="line">            System.out.println(<span class="string">&quot;hello, world!&quot;</span> + (++count) + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 每个1s输出“hi”，输出5次</span></span><br><span class="line">            System.out.println(<span class="string">&quot;hi!&quot;</span> + (++count) + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-3-模拟售票系统"><a href="#17-3-模拟售票系统" class="headerlink" title="17.3 模拟售票系统"></a>17.3 模拟售票系统</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        SellTicket01 sellTicket01 = new SellTicket01();</span></span><br><span class="line"><span class="comment">//        SellTicket01 sellTicket02 = new SellTicket01();</span></span><br><span class="line"><span class="comment">//        SellTicket01 sellTicket03 = new SellTicket01();</span></span><br><span class="line"><span class="comment">//        // 这里会有多个进程同时执行，同时访问共享数据时会出现数据竞争，从而导致错误结果</span></span><br><span class="line"><span class="comment">//        sellTicket01.start();</span></span><br><span class="line"><span class="comment">//        sellTicket02.start();</span></span><br><span class="line"><span class="comment">//        sellTicket03.start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也会出现资源竞争问题，从而导致错误结果</span></span><br><span class="line">        SellTicket02 sellTicket02 = <span class="keyword">new</span> SellTicket02();</span><br><span class="line">        <span class="keyword">new</span> Thread(sellTicket02).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(sellTicket02).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(sellTicket02).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 继承Thread方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTicket01</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ticketNum = <span class="number">100</span>; <span class="comment">//设置static，多个线程共享</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;售票结束...&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//休眠 50 毫秒, 模拟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">60</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;窗口&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;售出一张票&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;，剩余票数=&quot;</span> + (--ticketNum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTicket02</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNum = <span class="number">100</span>; <span class="comment">//让多个线程共享 ticketNum</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;售票结束...&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//休眠 50 毫秒, 模拟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; 剩余票数=&quot;</span> + (--ticketNum));<span class="comment">//1 - 0 - -1 - -2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123094913189.png" alt="image-20231123094913189"></p>
<h2 id="17-4-线程终止"><a href="#17-4-线程终止" class="headerlink" title="17.4 线程终止"></a>17.4 线程终止</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122093546074.png" alt="image-20231122093546074"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// 通知方式：主线程通过修改loop变量，让线程终止（停止run方法）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main线程休眠10s&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        t.setLoop(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置控制变量，控制run方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在运行：&quot;</span> + (count++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoop</span><span class="params">(<span class="keyword">boolean</span> loop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-5-线程常用方法"><a href="#17-5-线程常用方法" class="headerlink" title="17.5 线程常用方法"></a>17.5 线程常用方法</h2><h3 id="17-5-1-第一组方法"><a href="#17-5-1-第一组方法" class="headerlink" title="17.5.1 第一组方法"></a>17.5.1 第一组方法</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122093745346.png" alt="image-20231122093745346"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122093956022.png" alt="image-20231122093956022"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 测试相关方法</span></span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        t.setName(<span class="string">&quot;durango&quot;</span>);</span><br><span class="line">        t.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程打印5个hi，然后中断子线程的休眠</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;hi&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.getName() + <span class="string">&quot;优先级是&quot;</span> + t.getPriority());</span><br><span class="line">        t.interrupt(); <span class="comment">//执行到这里是会中断t线程的休眠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取当前线程名称</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 当线程执行到一个interrupt方法时，就会catch到一个异常，可以加入自己的业务代码</span></span><br><span class="line">                <span class="comment">// InterruptedException是捕获到的一个中断异常</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被中断了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="17-5-2-第二组方法"><a href="#17-5-2-第二组方法" class="headerlink" title="17.5.2 第二组方法"></a>17.5.2 第二组方法</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122100737396.png" alt="image-20231122100737396"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        T1 t1 = <span class="keyword">new</span> T1();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;hi&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">//Thread.yield(); //主线程礼让，资源充足时不一定成功</span></span><br><span class="line">                t1.join(); <span class="comment">//子线程插队，会先执行完毕，再执行主线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="17-5-3-用户线程和守护线程"><a href="#17-5-3-用户线程和守护线程" class="headerlink" title="17.5.3 用户线程和守护线程"></a>17.5.3 用户线程和守护线程</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122102151846.png" alt="image-20231122102151846"></p>
<ul>
<li><p>在main主线程中开启了一个无限执行的子线程T，即使主线程指向完毕了，T也还在继续执行。</p>
</li>
<li><p>将一个线程设置成<strong>守护线程</strong>。<font color="red">setDaemon(true)</font></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122102545351.png" alt="image-20231122102545351"></p>
</li>
</ul>
<h2 id="17-6-线程的生命周期"><a href="#17-6-线程的生命周期" class="headerlink" title="17.6 线程的生命周期"></a>17.6 线程的生命周期</h2><h3 id="17-6-1-线程的状态"><a href="#17-6-1-线程的状态" class="headerlink" title="17.6.1 线程的状态"></a>17.6.1 线程的状态</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122103200151.png" alt="image-20231122103200151"></p>
<h3 id="17-6-2-状态转化图（重要！）"><a href="#17-6-2-状态转化图（重要！）" class="headerlink" title="17.6.2 状态转化图（重要！）"></a>17.6.2 状态转化图（重要！）</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122105844283.png" alt="image-20231122105844283"></p>
<h3 id="17-6-3-通过程序查看"><a href="#17-6-3-通过程序查看" class="headerlink" title="17.6.3 通过程序查看"></a>17.6.3 通过程序查看</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        T t = <span class="keyword">new</span> T();</span><br><span class="line">        System.out.println(t.getState());</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">while</span> (t.getState() != Thread.State.TERMINATED) &#123;</span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot;状态&quot;</span> + t.getState());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;状态&quot;</span> + Thread.currentThread().getState());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hi&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-7-线程同步"><a href="#17-7-线程同步" class="headerlink" title="17.7 线程同步"></a>17.7 线程同步</h2><h3 id="17-7-1-线程同步机制"><a href="#17-7-1-线程同步机制" class="headerlink" title="17.7.1 线程同步机制"></a>17.7.1 线程同步机制</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123093337461.png" alt="image-20231123093337461"></p>
<h3 id="17-7-2-synchronized关键字"><a href="#17-7-2-synchronized关键字" class="headerlink" title="17.7.2 synchronized关键字"></a>17.7.2 synchronized关键字</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123093453121.png" alt="image-20231123093453121"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123095054030.png" alt="image-20231123095054030"></p>
<ul>
<li><p>使用synchronized解决售票问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTicket02 sellTicket02 = <span class="keyword">new</span> SellTicket02();</span><br><span class="line">        <span class="keyword">new</span> Thread(sellTicket02).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(sellTicket02).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(sellTicket02).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口方式，使用synchronized关键字实现同步</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTicket02</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNum = <span class="number">100</span>; <span class="comment">//让多个线程共享 ticketNum</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123; <span class="comment">//同步方法，在同一个时刻，只能有一个线程来sell方法</span></span><br><span class="line">        <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;售票结束...&quot;</span>);</span><br><span class="line">            loop = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span> +</span><br><span class="line">                <span class="string">&quot; 剩余票数=&quot;</span> + (--ticketNum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            sell();</span><br><span class="line">            <span class="comment">//休眠 50 毫秒, 模拟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123094808434.png" alt="image-20231123094808434"></p>
</li>
</ul>
<h2 id="17-8-互斥锁"><a href="#17-8-互斥锁" class="headerlink" title="17.8 互斥锁"></a>17.8 互斥锁</h2><h3 id="17-8-1-基本概念"><a href="#17-8-1-基本概念" class="headerlink" title="17.8.1 基本概念"></a>17.8.1 基本概念</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123100946318.png" alt="image-20231123100946318"></p>
<h3 id="17-8-2-注意事项"><a href="#17-8-2-注意事项" class="headerlink" title="17.8.2 注意事项"></a>17.8.2 注意事项</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123101105826.png" alt="image-20231123101105826"></p>
<h3 id="17-8-3-售票系统的同步问题"><a href="#17-8-3-售票系统的同步问题" class="headerlink" title="17.8.3 售票系统的同步问题"></a>17.8.3 售票系统的同步问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTicket01 sellTicket01 = <span class="keyword">new</span> SellTicket01();</span><br><span class="line">        SellTicket01 sellTicket02 = <span class="keyword">new</span> SellTicket01();</span><br><span class="line">        SellTicket01 sellTicket03 = <span class="keyword">new</span> SellTicket01();</span><br><span class="line">        sellTicket01.start();</span><br><span class="line">        sellTicket02.start();</span><br><span class="line">        sellTicket03.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        SellTicket02 sellTicket02 = new SellTicket02();</span></span><br><span class="line"><span class="comment">//        new Thread(sellTicket02).start();</span></span><br><span class="line"><span class="comment">//        new Thread(sellTicket02).start();</span></span><br><span class="line"><span class="comment">//        new Thread(sellTicket02).start();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Thread方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTicket01</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ticketNum = <span class="number">100</span>; <span class="comment">//设置static，多个线程共享</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法，锁在this对象上（无法实现同步，为什么？）</span></span><br><span class="line">    <span class="comment">// 注意！！！继承继承Thread方式创建线程时，创建的是多个对象</span></span><br><span class="line">    <span class="comment">// 因此this是三个不同的对象！！！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;售票结束...&quot;</span>);</span><br><span class="line">            loop = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span> +</span><br><span class="line">                <span class="string">&quot; 剩余票数=&quot;</span> + (--ticketNum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，锁在同一对象obj（obj是所有SellTicket01对象共享的才行）</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;售票结束...&quot;</span>);</span><br><span class="line">                loop = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; 剩余票数=&quot;</span> + (--ticketNum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            <span class="comment">//sell(); //无法同步</span></span><br><span class="line">            sell2(); <span class="comment">//可以同步</span></span><br><span class="line">            <span class="comment">//休眠 50 毫秒, 模拟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTicket02</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNum = <span class="number">100</span>; <span class="comment">//让多个线程共享 ticketNum</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法，锁在this对象上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;售票结束...&quot;</span>);</span><br><span class="line">            loop = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span> +</span><br><span class="line">                <span class="string">&quot; 剩余票数=&quot;</span> + (--ticketNum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，锁可以在this，也可以在同一对象obj</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;售票结束...&quot;</span>);</span><br><span class="line">                loop = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; 剩余票数=&quot;</span> + (--ticketNum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态同步方法，锁在当前类本身，即类名.class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态方法中的同步代码块，锁在当前类本身，即类名.class</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SellTicket.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            sell();</span><br><span class="line">            <span class="comment">//sell2();</span></span><br><span class="line">            <span class="comment">//休眠 50 毫秒, 模拟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-9-线程的死锁"><a href="#17-9-线程的死锁" class="headerlink" title="17.9 线程的死锁"></a>17.9 线程的死锁</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123103318317.png" alt="image-20231123103318317"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟死锁现象</span></span><br><span class="line">        DeadLockDemo A = <span class="keyword">new</span> DeadLockDemo(<span class="keyword">true</span>);</span><br><span class="line">        A.setName(<span class="string">&quot;A 线程&quot;</span>);</span><br><span class="line">        DeadLockDemo B = <span class="keyword">new</span> DeadLockDemo(<span class="keyword">false</span>);</span><br><span class="line">        B.setName(<span class="string">&quot;B 线程&quot;</span>);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object(); <span class="comment">// 设为static，所有DeadLockDemo对象共享</span></span><br><span class="line">    <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLockDemo</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 如果 flag 为 T, 线程 A 就会先得到/持有 o1 对象锁, 然后尝试去获取 o2 对象锁</span></span><br><span class="line">        <span class="comment">//2. 如果线程 A 得不到 o2 对象锁，就会 Blocked</span></span><br><span class="line">        <span class="comment">//3. 如果 flag 为 F, 线程 B 就会先得到/持有 o2 对象锁, 然后尝试去获取 o1 对象锁</span></span><br><span class="line">        <span class="comment">//4. 如果线程 B 得不到 o1 对象锁，就会 Blocked</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123; <span class="comment">// 同步代码块</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到o1的锁，进入1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到o2的锁，进入2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到o2的锁，进入3&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到o1的锁，进入4&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123104309556.png" alt="image-20231123104309556"></p>
<h2 id="17-10-锁的释放"><a href="#17-10-锁的释放" class="headerlink" title="17.10 锁的释放"></a>17.10 锁的释放</h2><h3 id="17-10-1-下面操作会释放锁"><a href="#17-10-1-下面操作会释放锁" class="headerlink" title="17.10.1 下面操作会释放锁"></a>17.10.1 下面操作会释放锁</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123104530485.png" alt="image-20231123104530485"></p>
<h3 id="17-10-2-下面操作不会释放锁"><a href="#17-10-2-下面操作不会释放锁" class="headerlink" title="17.10.2 下面操作不会释放锁"></a>17.10.2 下面操作不会释放锁</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123104706798.png" alt="image-20231123104706798"></p>
<h1 id="第十八章-坦克大战【2】"><a href="#第十八章-坦克大战【2】" class="headerlink" title="第十八章 坦克大战【2】"></a>第十八章 坦克大战【2】</h1><h2 id="18-1-坦克大战0-3"><a href="#18-1-坦克大战0-3" class="headerlink" title="18.1 坦克大战0.3"></a>18.1 坦克大战0.3</h2><h3 id="18-1-1-发射子弹"><a href="#18-1-1-发射子弹" class="headerlink" title="18.1.1 发射子弹"></a>18.1.1 发射子弹</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231124101154619.png" alt="image-20231124101154619"></p>
<ul>
<li><p>Shot.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shot</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;  <span class="comment">//子弹坐标</span></span><br><span class="line">    <span class="keyword">int</span> direct = <span class="number">0</span>; <span class="comment">//子弹方向</span></span><br><span class="line">    <span class="keyword">int</span> speed = <span class="number">10</span>; <span class="comment">//子弹速度</span></span><br><span class="line">    <span class="keyword">boolean</span> isLive = <span class="keyword">true</span>; <span class="comment">//子弹是否还存活</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> direct)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.direct = direct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 休眠50ms</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据方向改变坐标</span></span><br><span class="line">            <span class="keyword">switch</span> (direct) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//上</span></span><br><span class="line">                    y -= speed;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//右</span></span><br><span class="line">                    x += speed;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//下</span></span><br><span class="line">                    y += speed;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//左</span></span><br><span class="line">                    x -= speed;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 测试输出坐标</span></span><br><span class="line">            System.out.println(<span class="string">&quot;子弹线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; x = &quot;</span> + x + <span class="string">&quot;, y = &quot;</span> + y);</span><br><span class="line">                    <span class="comment">// 当子弹移动到面板的边界时，就应该销毁（把启动的子弹的线程销毁)</span></span><br><span class="line">            <span class="keyword">if</span> (!(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">1000</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt;= <span class="number">750</span>)) &#123;</span><br><span class="line">                isLive = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>hero.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">Tank</span> </span>&#123; <span class="comment">// 自定义坦克类</span></span><br><span class="line">    <span class="comment">// 定义一个Shot对象</span></span><br><span class="line">    Shot shot = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 射击，开启一个线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shotEnemyTank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Shot对象，根据当前Hero对象的位置和方向创建Shot</span></span><br><span class="line">        <span class="keyword">int</span> direct = getDirect();</span><br><span class="line">        <span class="keyword">switch</span> (direct) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//向上</span></span><br><span class="line">                shot = <span class="keyword">new</span> Shot(getX() + <span class="number">20</span>, getY(), getDirect());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//向右</span></span><br><span class="line">                shot = <span class="keyword">new</span> Shot(getX() + <span class="number">60</span>, getY() + <span class="number">20</span>, getDirect());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//向下</span></span><br><span class="line">                shot = <span class="keyword">new</span> Shot(getX() + <span class="number">20</span>, getY() + <span class="number">60</span>, getDirect());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//向左</span></span><br><span class="line">                shot = <span class="keyword">new</span> Shot(getX(), getY() + <span class="number">20</span>, getDirect());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动Shot线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(shot).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">KeyListener</span>, <span class="title">Runnable</span></span>&#123; <span class="comment">//自定义画板类</span></span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 画出hero射击的子弹</span></span><br><span class="line">        <span class="keyword">if</span>(hero.shot != <span class="keyword">null</span> &amp;&amp; hero.shot.isLive) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子弹被绘制！&quot;</span>);</span><br><span class="line">            <span class="comment">//g.fill3DRect(hero.shot.x, hero.shot.y, 1, 1, false);</span></span><br><span class="line">            g.draw3DRect(hero.shot.x, hero.shot.y, <span class="number">1</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="comment">// 如果按下的是J，就发射子弹</span></span><br><span class="line">        <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_J) &#123;</span><br><span class="line">            hero.shotEnemyTank();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//每隔100ms，重绘面板，刷新绘图区域，子弹就会移动</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.repaint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TankGame03.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankGame03</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankGame03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mp = <span class="keyword">new</span> MyPanel();</span><br><span class="line">        <span class="comment">// 将mp放入Thread并启动</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(mp);</span><br><span class="line">        thread.start();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="18-2-坦克大战0-4"><a href="#18-2-坦克大战0-4" class="headerlink" title="18.2 坦克大战0.4"></a>18.2 坦克大战0.4</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231124144906258.png" alt="image-20231124144906258"></p>
<h3 id="18-2-1-敌人发射子弹"><a href="#18-2-1-敌人发射子弹" class="headerlink" title="18.2.1 敌人发射子弹"></a>18.2.1 敌人发射子弹</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231124145042566.png" alt="image-20231124145042566"></p>
<ul>
<li><p>Enemy.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enemy</span> <span class="keyword">extends</span> <span class="title">Tank</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在敌人坦克类，使用Vector 保存多个Shot线程</span></span><br><span class="line">    Vector&lt;Shot&gt; shots = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Enemy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">KeyListener</span>, <span class="title">Runnable</span></span>&#123; <span class="comment">//自定义画板类</span></span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//初始化敌人坦克</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enemySize; i++) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 给该enemy对象初始化Shot对象</span></span><br><span class="line">            Shot shot = <span class="keyword">new</span> Shot(enemy.getX() + <span class="number">20</span>, enemy.getY() + <span class="number">60</span>, enemy.getDirect());</span><br><span class="line">            enemy.shots.add(shot);</span><br><span class="line">            <span class="comment">//启动Shot对象</span></span><br><span class="line">            <span class="keyword">new</span> Thread(shot).start();</span><br><span class="line">            enemies.add(enemy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 画出enemy坦克(遍历Vector)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enemies.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 取出坦克并绘制</span></span><br><span class="line">            Enemy enemy = enemies.get(i);</span><br><span class="line">            drawTank(enemy.getX(), enemy.getY(), g, enemy.getDirect(), <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 绘制enemy的所有子弹</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; enemy.shots.size(); j++) &#123;</span><br><span class="line">                <span class="comment">// 取出子弹</span></span><br><span class="line">                Shot shot = enemy.shots.get(j);</span><br><span class="line">                <span class="comment">// 绘制</span></span><br><span class="line">                <span class="keyword">if</span> (shot.isLive) &#123;</span><br><span class="line">                    g.draw3DRect(shot.x, shot.y, <span class="number">1</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 子弹消亡，从Vector移除</span></span><br><span class="line">                    enemy.shots.remove(shot);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18-2-2-敌人坦克被击中"><a href="#18-2-2-敌人坦克被击中" class="headerlink" title="18.2.2 敌人坦克被击中"></a>18.2.2 敌人坦克被击中</h3><ul>
<li><p>MyPanel.java：判断子弹是否击中敌人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">KeyListener</span>, <span class="title">Runnable</span> </span>&#123; <span class="comment">//自定义画板类</span></span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">    	...</span><br><span class="line">        <span class="comment">// 画出enemy坦克(遍历Vector)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enemies.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 取出坦克并绘制</span></span><br><span class="line">            Enemy enemy = enemies.get(i);</span><br><span class="line">            <span class="comment">// 当坦克存活时才绘制</span></span><br><span class="line">            <span class="keyword">if</span> (enemy.isLive) &#123;</span><br><span class="line">                drawTank(enemy.getX(), enemy.getY(), g, enemy.getDirect(), <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//坦克死亡时从Vector中删除</span></span><br><span class="line">                enemies.remove(enemy);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 判断我方子弹是否击中敌人的子弹</span></span><br><span class="line">    <span class="comment">// 什么时候需要判断是否击中坦克？run方法中循环判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hitTank</span><span class="params">(Shot s, Enemy enemy)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断s 击中坦克</span></span><br><span class="line">        <span class="keyword">switch</span> (enemy.getDirect()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//坦克向上</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//坦克向下</span></span><br><span class="line">                <span class="keyword">if</span> (s.x &gt; enemy.getX() &amp;&amp; s.x &lt; enemy.getX() + <span class="number">40</span></span><br><span class="line">                        &amp;&amp; s.y &gt; enemy.getY() &amp;&amp; s.y &lt; enemy.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                    s.isLive = <span class="keyword">false</span>; <span class="comment">//子弹销毁</span></span><br><span class="line">                    enemy.isLive = <span class="keyword">false</span>; <span class="comment">//敌人坦克销毁</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//坦克向右</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//坦克向左</span></span><br><span class="line">                <span class="keyword">if</span> (s.x &gt; enemy.getX() &amp;&amp; s.x &lt; enemy.getX() + <span class="number">60</span></span><br><span class="line">                        &amp;&amp; s.y &gt; enemy.getY() &amp;&amp; s.y &lt; enemy.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                    s.isLive = <span class="keyword">false</span>;     <span class="comment">//子弹销毁</span></span><br><span class="line">                    enemy.isLive = <span class="keyword">false</span>; <span class="comment">//敌人坦克销毁</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//每隔100ms，重绘面板，刷新绘图区域，子弹就会移动</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否击中了敌人坦克</span></span><br><span class="line">            <span class="keyword">if</span> (hero.shot != <span class="keyword">null</span> &amp;&amp; hero.shot.isLive) &#123;</span><br><span class="line">                <span class="comment">// 遍历所有的敌人坦克</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enemies.size(); i++) &#123;</span><br><span class="line">                    Enemy enemy = enemies.get(i);</span><br><span class="line">                    hitTank(hero.shot, enemy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.repaint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18-2-3-爆炸效果"><a href="#18-2-3-爆炸效果" class="headerlink" title="18.2.3 爆炸效果"></a>18.2.3 爆炸效果</h3><ul>
<li><p>Bomb.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bomb</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y; <span class="comment">//炸弹坐标</span></span><br><span class="line">    <span class="keyword">int</span> life = <span class="number">9</span>; <span class="comment">//炸弹生命周期</span></span><br><span class="line">    <span class="keyword">boolean</span> isLive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bomb</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少生命值，配合图片出现爆炸效果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifeDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (life &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            life --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isLive = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">KeyListener</span>, <span class="title">Runnable</span> </span>&#123; <span class="comment">//自定义画板类</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 定义一个Vector，用于存放炸弹（爆炸效果）</span></span><br><span class="line">    <span class="comment">// 当子弹击中坦克时，就加入一个爆炸效果</span></span><br><span class="line">    Vector&lt;Bomb&gt; bombs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="comment">// 定义三张炸弹图片，用于显示爆炸效果</span></span><br><span class="line">    Image image1 = <span class="keyword">null</span>;</span><br><span class="line">    Image image2 = <span class="keyword">null</span>;</span><br><span class="line">    Image image3 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 初始化Image对象</span></span><br><span class="line">        image1 = Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="string">&quot;/bomb_1.gif&quot;</span>));</span><br><span class="line">        image2 = Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="string">&quot;/bomb_2.gif&quot;</span>));</span><br><span class="line">        image3 = Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="string">&quot;/bomb_3.gif&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">    	...</span><br><span class="line">    	<span class="comment">// 画出所有炸弹（爆炸效果）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bombs.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;绘制爆炸效果&quot;</span>);</span><br><span class="line">            Bomb bomb = bombs.get(i);</span><br><span class="line">            <span class="comment">// 根据bomb的life值，画出对应的图片</span></span><br><span class="line">            <span class="keyword">if</span> (bomb.life &gt; <span class="number">6</span>) &#123;</span><br><span class="line">                g.drawImage(image1, bomb.x, bomb.y, <span class="number">60</span>, <span class="number">60</span>, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bomb.life &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                g.drawImage(image2, bomb.x, bomb.y, <span class="number">60</span>, <span class="number">60</span>, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                g.drawImage(image3, bomb.x, bomb.y, <span class="number">60</span>, <span class="number">60</span>, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 让炸弹生命值减少</span></span><br><span class="line">            bomb.lifeDown();</span><br><span class="line">            <span class="comment">// 如果炸弹的life为0了(isLive为false)，就从bombs中删除</span></span><br><span class="line">            <span class="keyword">if</span> (!bomb.isLive) &#123;</span><br><span class="line">                bombs.remove(bomb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    / 判断我方子弹是否击中敌人的子弹</span><br><span class="line">    <span class="comment">// 什么时候需要判断是否击中坦克？run方法中循环判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hitTank</span><span class="params">(Shot s, Enemy enemy)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断s 击中坦克</span></span><br><span class="line">        <span class="keyword">switch</span> (enemy.getDirect()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//坦克向上</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//坦克向下</span></span><br><span class="line">                <span class="keyword">if</span> (s.x &gt; enemy.getX() &amp;&amp; s.x &lt; enemy.getX() + <span class="number">40</span></span><br><span class="line">                        &amp;&amp; s.y &gt; enemy.getY() &amp;&amp; s.y &lt; enemy.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                    s.isLive = <span class="keyword">false</span>; <span class="comment">//子弹销毁</span></span><br><span class="line">                    enemy.isLive = <span class="keyword">false</span>; <span class="comment">//敌人坦克销毁</span></span><br><span class="line">                    <span class="comment">// 创建Bomb对象，加入到bombs集合中</span></span><br><span class="line">                    Bomb bomb = <span class="keyword">new</span> Bomb(enemy.getX(), enemy.getY());</span><br><span class="line">                    bombs.add(bomb);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//坦克向右</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//坦克向左</span></span><br><span class="line">                <span class="keyword">if</span> (s.x &gt; enemy.getX() &amp;&amp; s.x &lt; enemy.getX() + <span class="number">60</span></span><br><span class="line">                        &amp;&amp; s.y &gt; enemy.getY() &amp;&amp; s.y &lt; enemy.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                    s.isLive = <span class="keyword">false</span>;     <span class="comment">//子弹销毁</span></span><br><span class="line">                    enemy.isLive = <span class="keyword">false</span>; <span class="comment">//敌人坦克销毁</span></span><br><span class="line">                    <span class="comment">// 创建Bomb对象，加入到bombs集合中</span></span><br><span class="line">                    Bomb bomb = <span class="keyword">new</span> Bomb(enemy.getX(), enemy.getY());</span><br><span class="line">                    bombs.add(bomb);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18-2-4-敌人坦克自由移动"><a href="#18-2-4-敌人坦克自由移动" class="headerlink" title="18.2.4 敌人坦克自由移动"></a>18.2.4 敌人坦克自由移动</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231124163454322.png" alt="image-20231124163454322"></p>
<ul>
<li><p>Enemy.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enemy</span> <span class="keyword">extends</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在敌人坦克类，使用Vector 保存多个Shot线程</span></span><br><span class="line">    Vector&lt;Shot&gt; shots = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isLive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Enemy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> direct, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; i++) &#123;</span><br><span class="line">            <span class="comment">// 休眠50ms</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">switch</span> (direct) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//上</span></span><br><span class="line">                    moveUp();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//右</span></span><br><span class="line">                    moveRight();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//下</span></span><br><span class="line">                    moveDown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//左</span></span><br><span class="line">                    moveLeft();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isLive) &#123;</span><br><span class="line">            <span class="comment">// 根据坦克的方向来继续移动</span></span><br><span class="line">            move(getDirect(), <span class="number">30</span>);</span><br><span class="line">            <span class="comment">// 然后随机地改变坦克方向 0-3</span></span><br><span class="line">            setDirect((<span class="keyword">int</span>)(Math.random() * <span class="number">4</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">KeyListener</span>, <span class="title">Runnable</span> </span>&#123; <span class="comment">//自定义画板类</span></span><br><span class="line">   ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hero = <span class="keyword">new</span> Hero(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">// 初始化自己的坦克</span></span><br><span class="line">        hero.setSpeed(<span class="number">5</span>); <span class="comment">// 初始化坦克速度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化敌人坦克</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enemySize; i++) &#123;</span><br><span class="line">            Enemy enemy = <span class="keyword">new</span> Enemy(<span class="number">100</span> * (i + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">            enemy.setDirect(<span class="number">2</span>); <span class="comment">// 设置初始炮筒方向</span></span><br><span class="line">            <span class="keyword">new</span> Thread(enemy).start(); <span class="comment">//启动Enemy线程，让坦克自由移动</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18-2-4-控制坦克移动范围"><a href="#18-2-4-控制坦克移动范围" class="headerlink" title="18.2.4 控制坦克移动范围"></a>18.2.4 控制坦克移动范围</h3><ul>
<li><p>Enemy.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> direct, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; i++) &#123;</span><br><span class="line">        <span class="comment">// 休眠50ms</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (direct) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//上</span></span><br><span class="line">                <span class="keyword">if</span> (getY() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    moveUp();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span> (getX() + <span class="number">60</span> &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                    moveRight();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//下</span></span><br><span class="line">                <span class="keyword">if</span> (getY() + <span class="number">60</span> &lt; <span class="number">750</span>) &#123;</span><br><span class="line">                    moveDown();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span> (getX() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    moveLeft();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//jSystem.out.println((char) e.getKeyCode() + &quot;被按下..&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_W) &#123; <span class="comment">//W 上</span></span><br><span class="line">        <span class="comment">// 修改方向</span></span><br><span class="line">        hero.setDirect(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 修改坐标</span></span><br><span class="line">        <span class="keyword">if</span> (hero.getY() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            hero.moveUp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_D) &#123; <span class="comment">// D 右</span></span><br><span class="line">        hero.setDirect(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (hero.getX() + <span class="number">60</span> &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            hero.moveRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_S) &#123; <span class="comment">// S 下</span></span><br><span class="line">        hero.setDirect(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (hero.getY() + <span class="number">60</span> &lt; <span class="number">750</span>) &#123;</span><br><span class="line">            hero.moveDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_A) &#123; <span class="comment">// A 左</span></span><br><span class="line">        hero.setDirect(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (hero.getX() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            hero.moveLeft();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="18-3-坦克大战0-5"><a href="#18-3-坦克大战0-5" class="headerlink" title="18.3 坦克大战0.5"></a>18.3 坦克大战0.5</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231125165359114.png" alt="image-20231125165359114"></p>
<h3 id="18-3-1-发射多颗子弹"><a href="#18-3-1-发射多颗子弹" class="headerlink" title="18.3.1 发射多颗子弹"></a>18.3.1 发射多颗子弹</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231125165711044.png" alt="image-20231125165711044"></p>
<ul>
<li><p>Hero.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">Tank</span> </span>&#123; <span class="comment">// 自定义坦克类</span></span><br><span class="line">    <span class="comment">// 定义一个Shot对象</span></span><br><span class="line">    Shot shot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 可以发射多颗子弹</span></span><br><span class="line">    Vector&lt;Shot&gt; shots = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 射击，开启一个线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shotEnemyTank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 控制一次最多发射几颗子弹</span></span><br><span class="line">        <span class="keyword">if</span> (shots.size() == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">        <span class="comment">// 新创建的shot放入shots集合中</span></span><br><span class="line">        shots.add(shot);</span><br><span class="line">        <span class="comment">// 启动Shot线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(shot).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">KeyListener</span>, <span class="title">Runnable</span> </span>&#123; <span class="comment">//自定义画板类</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 画出hero射击的子弹</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hero.shots.size(); i++) &#123;</span><br><span class="line">            Shot shot = hero.shots.get(i);</span><br><span class="line">            <span class="keyword">if</span> (shot != <span class="keyword">null</span> &amp;&amp; shot.isLive) &#123;</span><br><span class="line">                g.draw3DRect(shot.x, shot.y, <span class="number">1</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// shot对象已经销毁，从shots集合中移除</span></span><br><span class="line">                hero.shots.remove(shot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断我方所有子弹是否击中任意敌人</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hitEnemyTank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hero.shots.size(); i++) &#123;</span><br><span class="line">            Shot shot = hero.shots.get(i);</span><br><span class="line">            <span class="comment">// 判断该颗子弹是否击中任意敌人</span></span><br><span class="line">            <span class="keyword">if</span> (hero.shot != <span class="keyword">null</span> &amp;&amp; hero.shot.isLive)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; enemies.size(); j++) &#123;</span><br><span class="line">                    Enemy enemy = enemies.get(j);</span><br><span class="line">                    hitTank(shot, enemy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断我方子弹是否击中敌人的子弹</span></span><br><span class="line">    <span class="comment">// 什么时候需要判断是否击中坦克？run方法中循环判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hitTank</span><span class="params">(Shot s, Enemy enemy)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断s 击中坦克</span></span><br><span class="line">        <span class="keyword">switch</span> (enemy.getDirect()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//坦克向上</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//坦克向下</span></span><br><span class="line">                <span class="keyword">if</span> (s.x &gt; enemy.getX() &amp;&amp; s.x &lt; enemy.getX() + <span class="number">40</span></span><br><span class="line">                        &amp;&amp; s.y &gt; enemy.getY() &amp;&amp; s.y &lt; enemy.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                    s.isLive = <span class="keyword">false</span>; <span class="comment">//子弹销毁</span></span><br><span class="line">                    enemy.isLive = <span class="keyword">false</span>; <span class="comment">//敌人坦克销毁</span></span><br><span class="line">                    enemies.remove(enemy); <span class="comment">//将敌人坦克从Vector中删除</span></span><br><span class="line">                    <span class="comment">// 创建Bomb对象，加入到bombs集合中</span></span><br><span class="line">                    Bomb bomb = <span class="keyword">new</span> Bomb(enemy.getX(), enemy.getY());</span><br><span class="line">                    bombs.add(bomb);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//坦克向右</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//坦克向左</span></span><br><span class="line">                <span class="keyword">if</span> (s.x &gt; enemy.getX() &amp;&amp; s.x &lt; enemy.getX() + <span class="number">60</span></span><br><span class="line">                        &amp;&amp; s.y &gt; enemy.getY() &amp;&amp; s.y &lt; enemy.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                    s.isLive = <span class="keyword">false</span>;     <span class="comment">//子弹销毁</span></span><br><span class="line">                    enemy.isLive = <span class="keyword">false</span>; <span class="comment">//敌人坦克销毁</span></span><br><span class="line">                    enemies.remove(enemy);</span><br><span class="line">                    <span class="comment">// 创建Bomb对象，加入到bombs集合中</span></span><br><span class="line">                    Bomb bomb = <span class="keyword">new</span> Bomb(enemy.getX(), enemy.getY());</span><br><span class="line">                    bombs.add(bomb);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 如果按下的是J，就发射子弹</span></span><br><span class="line">        <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_J) &#123;</span><br><span class="line">            <span class="comment">//只能发射一颗子弹，且子弹消亡了才能发射新的子弹</span></span><br><span class="line">            <span class="comment">/*if (hero.shot == null || !hero.shot.isLive) &#123;</span></span><br><span class="line"><span class="comment">                hero.shotEnemyTank();</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="comment">// 发射多颗子弹</span></span><br><span class="line">            hero.shotEnemyTank();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//每隔100ms，重绘面板，刷新绘图区域，子弹就会移动</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断我方所有子弹是否击中了任意敌人坦克</span></span><br><span class="line">            hitEnemyTank();</span><br><span class="line">            <span class="keyword">this</span>.repaint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18-3-2-敌人发射多颗子弹"><a href="#18-3-2-敌人发射多颗子弹" class="headerlink" title="18.3.2 敌人发射多颗子弹"></a>18.3.2 敌人发射多颗子弹</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231126094243019.png" alt="image-20231126094243019"></p>
<ul>
<li><p>Enemy.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isLive) &#123;</span><br><span class="line">        <span class="comment">// 敌人发射多颗子弹，如果shots.size() &lt; 3,创建新子弹</span></span><br><span class="line">        <span class="keyword">if</span> (shots.size() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            Shot shot = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (getDirect()) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    shot = <span class="keyword">new</span> Shot(getX() + <span class="number">20</span>, getY(), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    shot = <span class="keyword">new</span> Shot(getX() + <span class="number">60</span>, getY() + <span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    shot = <span class="keyword">new</span> Shot(getX() + <span class="number">20</span>, getY() + <span class="number">60</span>, <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    shot = <span class="keyword">new</span> Shot(getX(), getY(), <span class="number">3</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            shots.add(shot);</span><br><span class="line">            <span class="keyword">new</span> Thread(shot).start();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 根据坦克的方向来继续移动</span></span><br><span class="line">        move(getDirect(), <span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 然后随机地改变坦克方向 0-3</span></span><br><span class="line">        setDirect((<span class="keyword">int</span>) (Math.random() * <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18-3-3-敌人坦克击中我方"><a href="#18-3-3-敌人坦克击中我方" class="headerlink" title="18.3.3 敌人坦克击中我方"></a>18.3.3 敌人坦克击中我方</h3><ul>
<li><p>Tank.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isLive = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">KeyListener</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.paint(g);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="number">750</span>); <span class="comment">//填充背景，默认是黑色</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 画出hero坦克-封装成方法</span></span><br><span class="line">        <span class="keyword">if</span> (hero != <span class="keyword">null</span> &amp;&amp; hero.isLive)&#123;</span><br><span class="line">            drawTank(hero.getX(), hero.getY(), g, hero.getDirect(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     ...</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line">    / 判断敌人子弹是否击中我方坦克</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hitHero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有敌人坦克</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enemies.size(); i++) &#123;</span><br><span class="line">            Enemy enemy = enemies.get(i);</span><br><span class="line">            <span class="comment">// 遍历敌人坦克所有子弹</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; enemy.shots.size(); j++) &#123;</span><br><span class="line">                Shot shot = enemy.shots.get(j);</span><br><span class="line">                <span class="keyword">if</span> (hero.isLive &amp;&amp; shot.isLive) &#123;</span><br><span class="line">                    hitTank(shot, hero);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断我方所有子弹是否击中任意敌人</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hitEnemyTank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取出我方所有子弹</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hero.shots.size(); i++) &#123;</span><br><span class="line">            Shot shot = hero.shots.get(i);</span><br><span class="line">            <span class="comment">// 判断该颗子弹是否击中任意敌人</span></span><br><span class="line">            <span class="keyword">if</span> (hero.shot != <span class="keyword">null</span> &amp;&amp; hero.shot.isLive) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; enemies.size(); j++) &#123;</span><br><span class="line">                    Enemy enemy = enemies.get(j);</span><br><span class="line">                    hitTank(shot, enemy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断子弹是否击中坦克</span></span><br><span class="line">    <span class="comment">// 什么时候需要判断是否击中坦克？run方法中循环判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hitTank</span><span class="params">(Shot s, Tank tank)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断s 击中坦克</span></span><br><span class="line">        <span class="keyword">switch</span> (tank.getDirect()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//坦克向上</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//坦克向下</span></span><br><span class="line">                <span class="keyword">if</span> (s.x &gt; tank.getX() &amp;&amp; s.x &lt; tank.getX() + <span class="number">40</span></span><br><span class="line">                        &amp;&amp; s.y &gt; tank.getY() &amp;&amp; s.y &lt; tank.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                    s.isLive = <span class="keyword">false</span>; <span class="comment">//子弹销毁</span></span><br><span class="line">                    tank.isLive = <span class="keyword">false</span>; <span class="comment">//敌人坦克销毁</span></span><br><span class="line">                    enemies.remove(tank); <span class="comment">//将敌人坦克从Vector中删除</span></span><br><span class="line">                    <span class="comment">// 创建Bomb对象，加入到bombs集合中</span></span><br><span class="line">                    Bomb bomb = <span class="keyword">new</span> Bomb(tank.getX(), tank.getY());</span><br><span class="line">                    bombs.add(bomb);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//坦克向右</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//坦克向左</span></span><br><span class="line">                <span class="keyword">if</span> (s.x &gt; tank.getX() &amp;&amp; s.x &lt; tank.getX() + <span class="number">60</span></span><br><span class="line">                        &amp;&amp; s.y &gt; tank.getY() &amp;&amp; s.y &lt; tank.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                    s.isLive = <span class="keyword">false</span>;     <span class="comment">//子弹销毁</span></span><br><span class="line">                    tank.isLive = <span class="keyword">false</span>; <span class="comment">//敌人坦克销毁</span></span><br><span class="line">                    enemies.remove(tank);</span><br><span class="line">                    <span class="comment">// 创建Bomb对象，加入到bombs集合中</span></span><br><span class="line">                    Bomb bomb = <span class="keyword">new</span> Bomb(tank.getX(), tank.getY());</span><br><span class="line">                    bombs.add(bomb);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//每隔100ms，重绘面板，刷新绘图区域，子弹就会移动</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           ...</span><br><span class="line">            <span class="comment">// 判断敌人子弹是否击中我方坦克</span></span><br><span class="line">            hitHero();</span><br><span class="line">            <span class="keyword">this</span>.repaint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="第十九章-IO流"><a href="#第十九章-IO流" class="headerlink" title="第十九章 IO流"></a>第十九章 IO流</h1><h2 id="19-1-文件流"><a href="#19-1-文件流" class="headerlink" title="19.1 文件流"></a>19.1 文件流</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231127091955868.png" alt="image-20231127091955868"></p>
<h2 id="19-2-常用的文件操作"><a href="#19-2-常用的文件操作" class="headerlink" title="19.2 常用的文件操作"></a>19.2 常用的文件操作</h2><h3 id="19-2-1-创建文件"><a href="#19-2-1-创建文件" class="headerlink" title="19.2.1 创建文件"></a>19.2.1 创建文件</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231127092406701.png" alt="image-20231127092406701"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式 1 new File(String pathname) 根据路径构建</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;e:\\news1.txt&quot;</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 2 new File(File parent,String child) //根据父目录文件+子路径构建</span></span><br><span class="line"><span class="comment">// e:\\news2.txt</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File parentFile = <span class="keyword">new</span> File(<span class="string">&quot;e:\\&quot;</span>);</span><br><span class="line">    String fileName = <span class="string">&quot;news2.txt&quot;</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(parentFile, fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功~&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 3 new File(String parent,String child) //根据父目录+子路径构建</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String parentPath = <span class="string">&quot;e:\\&quot;</span>;</span><br><span class="line">    String fileName = <span class="string">&quot;news4.txt&quot;</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(parentPath, fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功~&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19-2-2-获取文件相关信息"><a href="#19-2-2-获取文件相关信息" class="headerlink" title="19.2.2 获取文件相关信息"></a>19.2.2 获取文件相关信息</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231127094041249.png" alt="image-20231127094041249"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先创建文件对象</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;e:\\news1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件名字=&quot;</span> + file.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件绝对路径=&quot;</span> + file.getAbsolutePath());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件父级目录=&quot;</span> + file.getParent());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件大小(字节)=&quot;</span> + file.length());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件是否存在=&quot;</span> + file.exists());</span><br><span class="line">    System.out.println(<span class="string">&quot;是不是一个文件=&quot;</span> + file.isFile());</span><br><span class="line">    System.out.println(<span class="string">&quot;是不是一个目录=&quot;</span> + file.isDirectory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19-2-3-目录的操作和文件删除"><a href="#19-2-3-目录的操作和文件删除" class="headerlink" title="19.2.3 目录的操作和文件删除"></a>19.2.3 目录的操作和文件删除</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231127094541531.png" alt="image-20231127094541531"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断文件是否存在，存在则删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;d:\\news1.txt&quot;</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.delete())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断目录是否存在，存在则删除，不存在则创建</span></span><br><span class="line"><span class="comment">// 目录也是一种文件</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;d:\\demo&quot;</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.delete())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目录不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (file.mkdirs()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;目录创建成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-3-IO流原理和分类"><a href="#19-3-IO流原理和分类" class="headerlink" title="19.3 IO流原理和分类"></a>19.3 IO流原理和分类</h2><h3 id="19-3-1-IO流原理"><a href="#19-3-1-IO流原理" class="headerlink" title="19.3.1 IO流原理"></a>19.3.1 IO流原理</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231127095822070.png" alt="image-20231127095822070"></p>
<h3 id="19-3-2-流的分类"><a href="#19-3-2-流的分类" class="headerlink" title="19.3.2 流的分类"></a>19.3.2 流的分类</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231127100030596.png" alt="image-20231127100030596"></p>
<h3 id="19-3-3-IO流体系图"><a href="#19-3-3-IO流体系图" class="headerlink" title="19.3.3 IO流体系图"></a>19.3.3 IO流体系图</h3><p><a href="https://zhuanlan.zhihu.com/p/641983694">【IO系列】一篇带你读懂java中的IO流！</a></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaIO%E6%B5%81%E4%BD%93%E7%B3%BB%E5%9B%BE.jpg" alt="javaIO流体系图"></p>
<h2 id="19-4-IO流常用的类"><a href="#19-4-IO流常用的类" class="headerlink" title="19.4 IO流常用的类"></a>19.4 IO流常用的类</h2><h3 id="19-4-1-FileInputStream"><a href="#19-4-1-FileInputStream" class="headerlink" title="19.4.1 FileInputStream"></a>19.4.1 FileInputStream</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231127101619906.png" alt="image-20231127101619906"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231127104542559.png" alt="image-20231127104542559"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 单个字节的读取，效率比较低</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> readData = <span class="number">0</span>;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建 FileInputStream 对象，用于读取文件</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">        <span class="comment">//从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止。</span></span><br><span class="line">        <span class="comment">//如果返回-1 , 表示读取完毕</span></span><br><span class="line">        <span class="keyword">while</span> ((readData = fileInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) readData); <span class="comment">//转成 char 显示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭文件流，释放资源.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 read(byte[] b) </span></span><br><span class="line"><span class="comment">* 字节数组读取文件，提高效率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="comment">//字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>]; <span class="comment">//一次读取 8 个字节.</span></span><br><span class="line">    <span class="keyword">int</span> readLen = <span class="number">0</span>;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建 FileInputStream 对象，用于读取 文件</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">        <span class="comment">//从该输入流读取最多 b.length 字节的数据到字节数组。 此方法将阻塞，直到某些输入可用。</span></span><br><span class="line">        <span class="comment">//如果返回-1 , 表示读取完毕</span></span><br><span class="line">        <span class="comment">//如果读取正常, 返回实际读取的字节数 &lt;=8</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, readLen));<span class="comment">//显示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭文件流，释放资源.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19-4-2-FileOutputStream"><a href="#19-4-2-FileOutputStream" class="headerlink" title="19.4.2 FileOutputStream"></a>19.4.2 FileOutputStream</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231127104815075.png" alt="image-20231127104815075"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231127105032806.png" alt="image-20231127105032806"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示使用 FileOutputStream 将数据写到文件中, * 如果该文件不存在，则创建该文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建 FileOutputStream 对象</span></span><br><span class="line">    String filePath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\a.txt&quot;</span>;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//得到 FileOutputStream 对象</span></span><br><span class="line">        <span class="comment">//1. new FileOutputStream(filePath) 创建方式，当写入内容是，会覆盖原来的内容</span></span><br><span class="line">        <span class="comment">//2. new FileOutputStream(filePath, true) 创建方式，当写入内容是，是追加到文件后面</span></span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(filePath, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//写入一个字节</span></span><br><span class="line">        fileOutputStream.write(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        <span class="comment">//写入字符串</span></span><br><span class="line">        String str = <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">        <span class="comment">//str.getBytes() 可以把 字符串 -&gt; 字节数组</span></span><br><span class="line">        <span class="comment">//fileOutputStream.write(str.getBytes());</span></span><br><span class="line">        fileOutputStream.write(str.getBytes(), <span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*文件拷贝</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 创建文件的输入流 , 将文件读入到程序</span></span><br><span class="line">    <span class="comment">//2. 创建文件的输出流， 将读取到的文件数据，写入到指定的文件.</span></span><br><span class="line">    String srcFilePath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\img.png&quot;</span>;</span><br><span class="line">    String destFilePath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\img1.png&quot;</span>;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(srcFilePath);</span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(destFilePath);</span><br><span class="line">        <span class="comment">//定义一个字节数组,提高读取效果</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> readLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//读取到后，就写入到文件 通过 fileOutputStream</span></span><br><span class="line">            <span class="comment">//即，是一边读，一边写</span></span><br><span class="line">            fileOutputStream.write(buf, <span class="number">0</span>, readLen);<span class="comment">//一定要使用这个方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;拷贝完成！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//关闭输入流和输出流，释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (fileInputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19-4-3-FileReader"><a href="#19-4-3-FileReader" class="headerlink" title="19.4.3 FileReader"></a>19.4.3 FileReader</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231128093504951.png" alt="image-20231128093504951"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231128093627408.png" alt="image-20231128093627408"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 单个字符读取文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\story.txt&quot;</span>;</span><br><span class="line">    FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> readData = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建 FileReader 对象</span></span><br><span class="line">        fileReader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">        <span class="comment">//循环读取 使用 read, 单个字符读取</span></span><br><span class="line">        <span class="keyword">while</span> ((readData = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) readData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 字符数组读取文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\story.txt&quot;</span>;</span><br><span class="line">    FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> readLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建 FileReader 对象</span></span><br><span class="line">        fileReader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">        <span class="comment">//循环读取 使用 read(buf), 返回的是实际读取到的字符数</span></span><br><span class="line">        <span class="comment">//如果返回-1, 说明到文件结束</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileReader.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19-4-4-FileWriter"><a href="#19-4-4-FileWriter" class="headerlink" title="19.4.4 FileWriter"></a>19.4.4 FileWriter</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231128093836575.png" alt="image-20231128093836575"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231128093932631.png" alt="image-20231128093932631"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileWriter01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\note.txt&quot;</span>;</span><br><span class="line">    <span class="comment">//创建 FileWriter 对象</span></span><br><span class="line">    FileWriter fileWriter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileWriter = <span class="keyword">new</span> FileWriter(filePath);<span class="comment">//默认是覆盖写入</span></span><br><span class="line">        <span class="comment">// 3) write(int):写入单个字符</span></span><br><span class="line">        fileWriter.write(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        <span class="comment">// 4) write(char[]):写入指定数组</span></span><br><span class="line">        fileWriter.write(chars);</span><br><span class="line">        <span class="comment">// 5) write(char[],off,len):写入指定数组的指定部分</span></span><br><span class="line">        fileWriter.write(<span class="string">&quot;韩顺平教育&quot;</span>.toCharArray(), <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 6) write（string）：写入整个字符串</span></span><br><span class="line">        fileWriter.write(<span class="string">&quot; 你好北京~&quot;</span>);</span><br><span class="line">        fileWriter.write(<span class="string">&quot;风雨之后，定见彩虹&quot;</span>);</span><br><span class="line">        <span class="comment">// 7) write(string,off,len):写入字符串的指定部分</span></span><br><span class="line">        fileWriter.write(<span class="string">&quot;上海天津&quot;</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//在数据量大的情况下，可以使用循环操作.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//对应 FileWriter , 一定要关闭流，或者 flush 才能真正的把数据写入到文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//fileWriter.flush();</span></span><br><span class="line">            <span class="comment">//关闭文件流，等价 flush() + 关闭</span></span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序结束...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-5-节点流和处理流"><a href="#19-5-节点流和处理流" class="headerlink" title="19.5 节点流和处理流"></a>19.5 节点流和处理流</h2><h3 id="19-5-1-基本介绍"><a href="#19-5-1-基本介绍" class="headerlink" title="19.5.1 基本介绍"></a>19.5.1 基本介绍</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231128100629711.png" alt="image-20231128100629711"></p>
<ul>
<li><p>一览图</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81.png" alt="字节流和处理流"></p>
</li>
<li><p>节点流和处理流的区别和联系</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231128101924537.png" alt="image-20231128101924537"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231128102740720.png" alt="image-20231128102740720"></p>
</li>
<li><p>处理流的功能主要体现在以下两个方面:</p>
<ul>
<li>性能的提高: 主要以<strong>增加缓冲的方式</strong>来提高输入输出的效率.</li>
<li>操作的便捷: 处理流可能提供了一系列<strong>便捷的方法</strong>来一次输入输出大批量的数据，使用更加灵活方便</li>
</ul>
</li>
</ul>
<h3 id="19-5-2-缓冲流-BufferedReader-和-BufferedWriter"><a href="#19-5-2-缓冲流-BufferedReader-和-BufferedWriter" class="headerlink" title="19.5.2 缓冲流-BufferedReader 和 BufferedWriter"></a>19.5.2 缓冲流-BufferedReader 和 BufferedWriter</h3><ol>
<li><p>使用BufferedReader读取文本文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;e:\\a.java&quot;</span>;</span><br><span class="line">    <span class="comment">//创建 bufferedReader</span></span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filePath));</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    String line; <span class="comment">//按行读取, 效率高</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. bufferedReader.readLine() 是按行读取文件</span></span><br><span class="line">    <span class="comment">//2. 当返回 null 时，表示文件读取完毕</span></span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动地去关闭 节点流</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用BufferedWriter写入文本文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;e:\\ok.txt&quot;</span>;</span><br><span class="line">    <span class="comment">//创建 BufferedWriter</span></span><br><span class="line">    <span class="comment">//说明:</span></span><br><span class="line">    <span class="comment">//1. new FileWriter(filePath, true) 表示以追加的方式写入</span></span><br><span class="line">    <span class="comment">//2. new FileWriter(filePath) , 表示以覆盖的方式写入</span></span><br><span class="line">    BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(filePath));</span><br><span class="line">    bufferedWriter.write(<span class="string">&quot;hello, 韩顺平教育!&quot;</span>);</span><br><span class="line">    bufferedWriter.newLine();<span class="comment">//插入一个和系统相关的换行</span></span><br><span class="line">    bufferedWriter.write(<span class="string">&quot;hello2, 韩顺平教育!&quot;</span>);</span><br><span class="line">    bufferedWriter.newLine();</span><br><span class="line">    bufferedWriter.write(<span class="string">&quot;hello3, 韩顺平教育!&quot;</span>);</span><br><span class="line">    bufferedWriter.newLine();</span><br><span class="line">    <span class="comment">//说明：关闭外层流即可 ， 传入的 new FileWriter(filePath) ,会在底层关闭</span></span><br><span class="line">    bufferedWriter.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝文本文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 不要去操作 二进制文件[声音，视频，doc, pdf ], 可能造成文件损坏</span></span><br><span class="line">        String srcPath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\story.txt&quot;</span>;</span><br><span class="line">        String desPath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\story2.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(srcPath));</span><br><span class="line">        bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(desPath));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bufferedWriter.write(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="19-5-3-缓冲流-BufferedInputStream-和-BufferedOutputStream"><a href="#19-5-3-缓冲流-BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="19.5.3 缓冲流-BufferedInputStream 和 BufferedOutputStream"></a>19.5.3 缓冲流-BufferedInputStream 和 BufferedOutputStream</h3><ul>
<li><p><strong>字节流可以操作二进制文件</strong>，也可以操作文本文件</p>
</li>
<li><p>拷贝图片、音频文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String srcPath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\img.png&quot;</span>;</span><br><span class="line">    String desPath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\img2.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    BufferedInputStream bufferedInputStream = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bufferedOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(srcPath));</span><br><span class="line">    bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(desPath));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> readLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((readLen = bufferedInputStream.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bufferedOutputStream.write(buff, <span class="number">0</span>, readLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bufferedInputStream.close();</span><br><span class="line">    bufferedOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-5-4-序列化和反序列化"><a href="#19-5-4-序列化和反序列化" class="headerlink" title="19.5.4 序列化和反序列化"></a>19.5.4 序列化和反序列化</h3><ul>
<li><p>看一个需求</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231129100806911.png" alt="image-20231129100806911"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231129101412433.png" alt="image-20231129101412433"></p>
</li>
</ul>
<ul>
<li><p><strong><font color="red">序列化和反序列化</font></strong></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231129101022414.png" alt="image-20231129101022414"></p>
</li>
</ul>
<h3 id="19-5-5-对象流-ObjectInputStream-和-ObjectOutputStream"><a href="#19-5-5-对象流-ObjectInputStream-和-ObjectOutputStream" class="headerlink" title="19.5.5 对象流-ObjectInputStream 和 ObjectOutputStream"></a>19.5.5 对象流-ObjectInputStream 和 ObjectOutputStream</h3><ul>
<li><p>提供了对基本类型或对象类型的序列化和反序列化的方法</p>
<ul>
<li>ObjectOutputStream 提供 序列化功能</li>
<li>ObjectInputStream 提供 反序列化功能</li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231129101606079.png" alt="image-20231129101606079"></p>
</li>
</ul>
<ul>
<li><p>演示 ObjectOutputStream 的使用, 完成数据的序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStream_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存</span></span><br><span class="line">        String filePath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\data.dat&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(filePath));</span><br><span class="line">        <span class="comment">//序列化数据</span></span><br><span class="line">        oos.writeInt(<span class="number">100</span>);<span class="comment">// int -&gt; Integer (实现了 Serializable)</span></span><br><span class="line">        oos.writeBoolean(<span class="keyword">true</span>);<span class="comment">// boolean -&gt; Boolean (实现了 Serializable)</span></span><br><span class="line">        oos.writeChar(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// char -&gt; Character (实现了 Serializable)</span></span><br><span class="line">        oos.writeDouble(<span class="number">9.5</span>);<span class="comment">// double -&gt; Double (实现了 Serializable)</span></span><br><span class="line">        oos.writeUTF(<span class="string">&quot;韩顺平教育&quot;</span>);<span class="comment">//String</span></span><br><span class="line">        <span class="comment">//保存一个 dog 对象</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>演示 ObjectInputStream的使用，完成数据的反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInputStream_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\data.dat&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.读取， 注意顺序和保存数据一致</span></span><br><span class="line">        System.out.println(ois.readInt());</span><br><span class="line">        System.out.println(ois.readBoolean());</span><br><span class="line">        System.out.println(ois.readChar());</span><br><span class="line">        System.out.println(ois.readDouble());</span><br><span class="line">        System.out.println(ois.readUTF());</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行类型=&quot;</span> + o.getClass()); <span class="comment">//class com.durango.outputstream.Dog</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Dog信息&quot;</span> + o); <span class="comment">//Dog信息Dog&#123;name=&#x27;旺财&#x27;, age=10&#125;</span></span><br><span class="line">        <span class="comment">// 3.关闭</span></span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;以反序列化的方式读取(恢复)ok~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>注意事项<ol>
<li>读写顺序要一致</li>
<li>要求序列化或反序列化对象，需要实现可序列化</li>
<li>序列化的类中建议添加<strong>SerialVersionUID</strong>，为了提高版本的兼容性</li>
<li>序列化对象时，默认将里面所有属性都进行序列化，但<strong>除了static或transient修饰的</strong>成员</li>
<li>序列化对象时，要求<strong>里面属性的数据类型也需要实现序列化接口</strong></li>
<li>序列化具备<strong>可继承性</strong>，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</li>
</ol>
</li>
</ul>
<h3 id="19-5-6-标准输入输出流"><a href="#19-5-6-标准输入输出流" class="headerlink" title="19.5.6 标准输入输出流"></a>19.5.6 标准输入输出流</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231129104244722.png" alt="image-20231129104244722"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// System.in 标准输入 - 键盘</span></span><br><span class="line"><span class="comment">// System 类的 public final static InputStream in = null;</span></span><br><span class="line"><span class="comment">// System.in的编译类型 InputStream</span></span><br><span class="line"><span class="comment">// System.in的运行类型 BufferedInputStream</span></span><br><span class="line">System.out.println(System.in.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// System.out 标准输出 - 显示器</span></span><br><span class="line"><span class="comment">// System 类的 public final static PrintStream out = null;</span></span><br><span class="line"><span class="comment">// System.in的编译类型 PrintStream</span></span><br><span class="line"><span class="comment">// System.in的运行类型 PrintStream</span></span><br><span class="line">System.out.println(System.out.getClass());</span><br></pre></td></tr></table></figure>



<h3 id="19-5-7-转换流-InputStreamReader-和-OutputStreamWriter"><a href="#19-5-7-转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="19.5.7 转换流-InputStreamReader 和 OutputStreamWriter"></a>19.5.7 转换流-InputStreamReader 和 OutputStreamWriter</h3><ul>
<li>一个编码问题<ul>
<li>默认情况下，<strong>字符流</strong>读取文件是按照 utf-8 编码，无法指定编码</li>
<li>字节流可以指定编码</li>
</ul>
</li>
<li><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231129105841034.png" alt="image-20231129105841034"></li>
</ul>
<ul>
<li><p>演示：将字节流 FileInputStream 转成字符流 InputStreamReader, <strong>指定编码 gbk/utf-8</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\note.txt&quot;</span>;</span><br><span class="line">    <span class="comment">//1. 把 FileInputStream 转成 InputStreamReader</span></span><br><span class="line">    <span class="comment">//2. 指定编码 gbk</span></span><br><span class="line">    <span class="comment">//3. 把 InputStreamReader 传入 BufferedReader</span></span><br><span class="line">    <span class="comment">//InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), &quot;gbk&quot;);</span></span><br><span class="line">    <span class="comment">//BufferedReader br = new BufferedReader(isr);</span></span><br><span class="line">    <span class="comment">//将 2 和 3 合在一起</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(filePath), <span class="string">&quot;gbk&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 读取</span></span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取内容=&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. 关闭外层流</span></span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>演示：编程将字节流FileOutputStream包装成(转换成)字符流OutputStreamWriter，对文件进行写入(按照GBK格式，可以指定其他，比如utf-8)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建流对象</span></span><br><span class="line">    String filePath = <span class="string">&quot;D:\\Code\\IdeaJavaProjects\\chapter19\\src\\note2.txt&quot;</span>;</span><br><span class="line">    OutputStreamWriter osw =</span><br><span class="line">        <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(filePath), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.写入</span></span><br><span class="line">    osw.write(<span class="string">&quot;hello,韩顺平教育~&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.关闭</span></span><br><span class="line">    osw.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;保存成功~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="19-5-8-打印流-PrintStream-和-PrintWriter"><a href="#19-5-8-打印流-PrintStream-和-PrintWriter" class="headerlink" title="19.5.8 打印流-PrintStream 和 PrintWriter"></a>19.5.8 打印流-PrintStream 和 PrintWriter</h3><ul>
<li><p>继承关系图</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231130093409020.png" alt="image-20231130093409020"></p>
</li>
<li><p>​    案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    PrintStream out = System.out;</span><br><span class="line">    <span class="comment">//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器</span></span><br><span class="line">    out.print(<span class="string">&quot;john, hello&quot;</span>);</span><br><span class="line">    <span class="comment">//因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印/输出</span></span><br><span class="line">    out.write(<span class="string">&quot;韩顺平,你好&quot;</span>.getBytes());</span><br><span class="line">    out.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们可以去修改打印流输出的位置/设备</span></span><br><span class="line">    <span class="comment">//1. 输出修改成 &quot;e:\\f1.txt&quot;</span></span><br><span class="line">    <span class="comment">// public static void setOut(PrintStream out) &#123;</span></span><br><span class="line">    <span class="comment">//      checkIO();</span></span><br><span class="line">    <span class="comment">//      setOut0(out); // native 方法，修改了 out</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    System.setOut(<span class="keyword">new</span> PrintStream(<span class="string">&quot;e:\\f1.txt&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;hello, 韩顺平教育~&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">    PrintWriter printWriter1 = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;e:\\f1.txt&quot;</span>));</span><br><span class="line">    printWriter.println(<span class="string">&quot;hi,你好&quot;</span>);</span><br><span class="line">    printWriter1.println(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    printWriter.close();</span><br><span class="line">    printWriter1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="19-6-Properties-类"><a href="#19-6-Properties-类" class="headerlink" title="19.6 Properties 类"></a>19.6 Properties 类</h2><ul>
<li><a href="#properties">Map-Properties</a></li>
</ul>
<h3 id="19-6-1-基本介绍"><a href="#19-6-1-基本介绍" class="headerlink" title="19.6.1 基本介绍"></a>19.6.1 基本介绍</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231130100339284.png" alt="image-20231130100339284"></p>
<h3 id="19-6-2-常用方法"><a href="#19-6-2-常用方法" class="headerlink" title="19.6.2 常用方法"></a>19.6.2 常用方法</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231130100503751.png" alt="image-20231130100503751"></p>
<h3 id="19-6-3-案例"><a href="#19-6-3-案例" class="headerlink" title="19.6.3 案例"></a>19.6.3 案例</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231130100601965.png" alt="image-20231130100601965"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 Properties 类来读取 mysql.properties 文件</span></span><br><span class="line"><span class="comment">//1. 创建 Properties 对象</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//2. 加载指定配置文件</span></span><br><span class="line">properties.load(<span class="keyword">new</span> FileReader(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line"><span class="comment">//3. 把 k-v 显示到控制台</span></span><br><span class="line">properties.list(System.out);</span><br><span class="line"><span class="comment">//4. 根据 key 获取对应的值</span></span><br><span class="line">String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">String pwd = properties.getProperty(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;用户名=&quot;</span> + user);</span><br><span class="line">System.out.println(<span class="string">&quot;密码是=&quot;</span> + pwd);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 Properties 类来创建 配置文件, 修改配置文件内容</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="comment">//1.如果该文件没有 key 就是创建</span></span><br><span class="line"><span class="comment">//2.如果该文件有 key ,就是修改</span></span><br><span class="line">properties.setProperty(<span class="string">&quot;charset&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);<span class="comment">//注意保存时，是中文的 unicode 码值</span></span><br><span class="line">properties.setProperty(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;888888&quot;</span>);</span><br><span class="line"><span class="comment">//将 k-v 存储文件中即可</span></span><br><span class="line">properties.store(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src\\mysql2.properties&quot;</span>), <span class="string">&quot;this is a comment&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;保存配置文件成功~&quot;</span>);</span><br></pre></td></tr></table></figure>



<h1 id="第二十章-坦克大战【3】"><a href="#第二十章-坦克大战【3】" class="headerlink" title="第二十章 坦克大战【3】"></a>第二十章 坦克大战【3】</h1><h2 id="20-1-坦克大战0-6"><a href="#20-1-坦克大战0-6" class="headerlink" title="20.1 坦克大战0.6"></a>20.1 坦克大战0.6</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231201092439847.png" alt="image-20231201092439847"></p>
<h3 id="20-1-1-防止坦克重叠"><a href="#20-1-1-防止坦克重叠" class="headerlink" title="20.1.1 防止坦克重叠"></a>20.1.1 防止坦克重叠</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231201093358055.png" alt="image-20231201093358055"></p>
<ul>
<li><p>Enemy.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Enemy extends Tank implements Runnable &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 增加成员enemies，可以得到敌人坦克的Vector(在MyPanel中创建的)</span><br><span class="line">    Vector&lt;Enemy&gt; enemies = new Vector&lt;&gt;();</span><br><span class="line">    // 编写方法，判断当前坦克是否和其他Enemy坦克发生碰撞</span><br><span class="line">    </span><br><span class="line">    public boolean isTouchEnemy() &#123;</span><br><span class="line">        // 判断当前坦克方向</span><br><span class="line">        switch (this.getDirect()) &#123;</span><br><span class="line">            case 0: //上</span><br><span class="line">                for (int i = 0; i &lt; enemies.size(); i++) &#123;</span><br><span class="line">                    //遍历Vector中所有敌人坦克</span><br><span class="line">                    Enemy enemy = enemies.get(i);</span><br><span class="line">                    if (enemy != this) &#123;</span><br><span class="line">                        int direct = enemy.getDirect();</span><br><span class="line">                        //1. 敌人坦克上下，x范围[x,x+40],y范围[y,y+60]</span><br><span class="line">                        if (direct == 0 || direct == 2) &#123;</span><br><span class="line">                            //当前坦克左上角[x,y],右上角[x+40,y]</span><br><span class="line">                            if (this.getX() &gt;= enemy.getX()</span><br><span class="line">                                    &amp;&amp; this.getX() &lt;= enemy.getX() + 40</span><br><span class="line">                                    &amp;&amp; this.getY() &gt;= enemy.getY()</span><br><span class="line">                                    &amp;&amp; this.getY() &lt;= enemy.getY() + 60) &#123;</span><br><span class="line">                                return true;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (this.getX() + 40 &gt;= enemy.getX()</span><br><span class="line">                                    &amp;&amp; this.getX() + 40 &lt;= enemy.getX() + 40</span><br><span class="line">                                    &amp;&amp; this.getY() &gt;= enemy.getY()</span><br><span class="line">                                    &amp;&amp; this.getY() &lt;= enemy.getY() + 60) &#123;</span><br><span class="line">                                return true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //2. 敌人坦克左右，x范围[x,x+60],y范围[y,y+40]</span><br><span class="line">                        if (direct == 1 || direct == 3) &#123;</span><br><span class="line">                            //当前坦克左上角[x,y],右上角[x+40,y]</span><br><span class="line">                            if (this.getX() &gt;= enemy.getX()</span><br><span class="line">                                    &amp;&amp; this.getX() &lt;= enemy.getX() + 60</span><br><span class="line">                                    &amp;&amp; this.getY() &gt;= enemy.getY()</span><br><span class="line">                                    &amp;&amp; this.getY() &lt;= enemy.getY() + 40) &#123;</span><br><span class="line">                                return true;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (this.getX() + 40 &gt;= enemy.getX()</span><br><span class="line">                                    &amp;&amp; this.getX() + 40 &lt;= enemy.getX() + 60</span><br><span class="line">                                    &amp;&amp; this.getY() &gt;= enemy.getY()</span><br><span class="line">                                    &amp;&amp; this.getY() &lt;= enemy.getY() + 40) &#123;</span><br><span class="line">                                return true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 1: //右</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">            case 2: //下</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">            case 3: //左</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void move(int direct, int step) &#123;</span><br><span class="line">        for (int i = 0; i &lt; step; i++) &#123;</span><br><span class="line">            ...</span><br><span class="line">            switch (direct) &#123;</span><br><span class="line">                case 0: //上</span><br><span class="line">                    if (getY() &gt; 0 &amp;&amp; !isTouchEnemy()) &#123;</span><br><span class="line">                        moveUp();</span><br><span class="line">                    &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化敌人坦克</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enemySize; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设置Enemy的成员Vector&lt;Enemy&gt; enemies</span></span><br><span class="line">    enemy.setEnemies(enemies);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="20-1-2-记录总成绩"><a href="#20-1-2-记录总成绩" class="headerlink" title="20.1.2 记录总成绩"></a>20.1.2 记录总成绩</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231201102934955.png" alt="image-20231201102934955"></p>
<ul>
<li><p>Recorder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recorder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 击毁坦克数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> allEnemyNum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义IO对象，写数据到文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String recordFile = <span class="string">&quot;src\\myRecord.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当我方坦克击毁一辆敌方坦克，allEnemyNum++</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addAllEnemyNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Recorder.allEnemyNum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 游戏退出时，保存信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keepRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(recordFile));</span><br><span class="line">            bw.write(allEnemyNum + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAllEnemyNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allEnemyNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAllEnemyNum</span><span class="params">(<span class="keyword">int</span> allEnemyNum)</span> </span>&#123;</span><br><span class="line">        Recorder.allEnemyNum = allEnemyNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hitTank</span><span class="params">(Shot s, Tank tank)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断s 击中坦克</span></span><br><span class="line">    <span class="keyword">switch</span> (tank.getDirect()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//坦克向上</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//坦克向下</span></span><br><span class="line">            <span class="keyword">if</span> (s.x &gt; tank.getX() &amp;&amp; s.x &lt; tank.getX() + <span class="number">40</span></span><br><span class="line">                &amp;&amp; s.y &gt; tank.getY() &amp;&amp; s.y &lt; tank.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">               	...</span><br><span class="line">                <span class="keyword">if</span> (tank <span class="keyword">instanceof</span> Enemy) &#123;</span><br><span class="line">                    enemies.remove(tank); <span class="comment">//将敌人坦克从Vector中删除</span></span><br><span class="line">                    Recorder.addAllEnemyNum();</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TankGame06.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TankGame06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 在JFame中增加窗口监听</span></span><br><span class="line">    <span class="keyword">this</span>.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭窗口&quot;</span>);</span><br><span class="line">            Recorder.keepRecord();</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="20-1-3-记录敌人信息"><a href="#20-1-3-记录敌人信息" class="headerlink" title="20.1.3 记录敌人信息"></a>20.1.3 记录敌人信息</h3><ul>
<li><p>Recorder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recorder</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 定义Vector指向MyPane对象的 enemies</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Enemy&gt; enemies = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 游戏退出时，保存信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keepRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(recordFile));</span><br><span class="line">            <span class="comment">// 保存成绩</span></span><br><span class="line">            bw.write(allEnemyNum + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 遍历敌人坦克Vector，保存敌人信息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enemies.size(); i++) &#123;</span><br><span class="line">                Enemy enemy = enemies.get(i);</span><br><span class="line">                <span class="keyword">if</span> (enemy.isLive) &#123;</span><br><span class="line">                    String record = enemy.getX() + <span class="string">&quot; &quot;</span> + enemy.getY() + <span class="string">&quot; &quot;</span> + enemy.getDirect();</span><br><span class="line">                    bw.write(record+ <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setEnemies</span><span class="params">(Vector&lt;Enemy&gt; enemies)</span> </span>&#123;</span><br><span class="line">        Recorder.enemies = enemies;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Recorder获取到enemies，用于保存信息</span></span><br><span class="line">    Recorder.setEnemies(enemies);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="20-1-4-恢复敌人信息"><a href="#20-1-4-恢复敌人信息" class="headerlink" title="20.1.4 恢复敌人信息"></a>20.1.4 恢复敌人信息</h3><ul>
<li><p>Node.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> direct;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Recorder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recorder</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 定义Vector保存敌人的信息node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Node&gt; nodes = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加一个方法，用于读取recordFile，恢复相关信息</span></span><br><span class="line">    <span class="comment">// 继续上局游戏时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector&lt;Node&gt; <span class="title">getNodesAndEnemyRec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(recordFile));</span><br><span class="line">            allEnemyNum = Integer.parseInt(br.readLine());</span><br><span class="line">            <span class="comment">// 循环读取，生成nodes集合</span></span><br><span class="line">            String line = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String[] xyd = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                Node node = <span class="keyword">new</span> Node(Integer.parseInt(xyd[<span class="number">0</span>]), Integer.parseInt(xyd[<span class="number">1</span>]),</span><br><span class="line">                        Integer.parseInt(xyd[<span class="number">2</span>]));</span><br><span class="line">                nodes.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TankGame06.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TankGame06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入选择：1：新游戏；2：继续游戏&quot;</span>);</span><br><span class="line">    String key = scanner.next();</span><br><span class="line">    mp = <span class="keyword">new</span> MyPanel(key);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> <span class="keyword">implements</span> <span class="title">KeyListener</span>, <span class="title">Runnable</span> </span>&#123; <span class="comment">//自定义画板类</span></span><br><span class="line">	<span class="comment">// 定义一个存放Node对象的Vector，用于恢复坦克信息</span></span><br><span class="line">    Vector&lt;Node&gt; nodes = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPanel</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    	nodes = Recorder.getNodesAndEnemyRec();</span><br><span class="line">    	...</span><br><span class="line">    	<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>: <span class="comment">// 新游戏</span></span><br><span class="line">                Recorder.setAllEnemyNum(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//初始化敌人坦克</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enemySize; i++) &#123;</span><br><span class="line">                    Enemy enemy = <span class="keyword">new</span> Enemy(<span class="number">100</span> * (i + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">                    enemy.setDirect(<span class="number">2</span>); <span class="comment">// 设置初始炮筒方向</span></span><br><span class="line">                    <span class="keyword">new</span> Thread(enemy).start(); <span class="comment">//启动Enemy线程，让坦克自由移动</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 给该enemy对象初始化Shot对象</span></span><br><span class="line">                    Shot shot = <span class="keyword">new</span> Shot(enemy.getX() + <span class="number">20</span>, enemy.getY() + <span class="number">60</span>, enemy.getDirect());</span><br><span class="line">                    enemy.shots.add(shot);</span><br><span class="line">                    <span class="comment">//启动Shot线程</span></span><br><span class="line">                    <span class="keyword">new</span> Thread(shot).start();</span><br><span class="line">                    enemies.add(enemy);</span><br><span class="line">                    <span class="comment">// 设置Enemy的成员Vector&lt;Enemy&gt; enemies</span></span><br><span class="line">                    enemy.setEnemies(enemies);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>: <span class="comment">// 继续游戏</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">                    Node node = nodes.get(i);</span><br><span class="line">                    Enemy enemy = <span class="keyword">new</span> Enemy(node.getX(), node.getY());</span><br><span class="line">                    enemy.setDirect(node.getDirect()); <span class="comment">// 设置初始炮筒方向</span></span><br><span class="line">                    <span class="keyword">new</span> Thread(enemy).start(); <span class="comment">//启动Enemy线程，让坦克自由移动</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 给该enemy对象初始化Shot对象</span></span><br><span class="line">                    Shot shot = <span class="keyword">new</span> Shot(enemy.getX() + <span class="number">20</span>, enemy.getY() + <span class="number">60</span>, enemy.getDirect());</span><br><span class="line">                    enemy.shots.add(shot);</span><br><span class="line">                    <span class="comment">//启动Shot线程</span></span><br><span class="line">                    <span class="keyword">new</span> Thread(shot).start();</span><br><span class="line">                    enemies.add(enemy);</span><br><span class="line">                    <span class="comment">// 设置Enemy的成员Vector&lt;Enemy&gt; enemies</span></span><br><span class="line">                    enemy.setEnemies(enemies);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;输入有误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="20-2-坦克大战0-7"><a href="#20-2-坦克大战0-7" class="headerlink" title="20.2 坦克大战0.7"></a>20.2 坦克大战0.7</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231202104735994.png" alt="image-20231202104735994"></p>
<h3 id="20-2-1-播放音乐"><a href="#20-2-1-播放音乐" class="headerlink" title="20.2.1 播放音乐"></a>20.2.1 播放音乐</h3><ul>
<li><p>AePlayWave.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankGame07</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyPanel mp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TankGame07();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankGame07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入选择：1：新游戏；2：继续游戏&quot;</span>);</span><br><span class="line">        String key = scanner.next();</span><br><span class="line">        mp = <span class="keyword">new</span> MyPanel(key);</span><br><span class="line">        <span class="comment">// 将mp放入Thread并启动</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(mp);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">this</span>.add(mp);</span><br><span class="line">        <span class="keyword">this</span>.addKeyListener(mp);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">1300</span>, <span class="number">750</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在JFame中增加窗口监听</span></span><br><span class="line">        <span class="keyword">this</span>.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;关闭窗口&quot;</span>);</span><br><span class="line">                Recorder.keepRecord();</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyPanel</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">        <span class="comment">// 游戏初始化后，播放音乐</span></span><br><span class="line">        <span class="keyword">new</span> AePlayWave(<span class="string">&quot;src\\111.wav&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="20-2-2-处理文件相关异常"><a href="#20-2-2-处理文件相关异常" class="headerlink" title="20.2.2 处理文件相关异常"></a>20.2.2 处理文件相关异常</h3><ul>
<li><p>MyPanel.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyPanel</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断记录文件是否存在</span></span><br><span class="line">        <span class="comment">// 不存在则只能开启&quot;新游戏&quot; key = &quot;1&quot;</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(Recorder.getRecordFile());</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            nodes = Recorder.getNodesAndEnemyRec();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有存档，只能开启新游戏&quot;</span>);</span><br><span class="line">            key = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="—-第三阶段-—"><a href="#—-第三阶段-—" class="headerlink" title="— 第三阶段 —"></a>— 第三阶段 —</h1><h1 id="第二十一章-网络编程"><a href="#第二十一章-网络编程" class="headerlink" title="第二十一章 网络编程"></a>第二十一章 网络编程</h1><h2 id="21-1-网络的相关概念"><a href="#21-1-网络的相关概念" class="headerlink" title="21.1 网络的相关概念"></a>21.1 网络的相关概念</h2><h3 id="21-1-1-网络通讯"><a href="#21-1-1-网络通讯" class="headerlink" title="21.1.1 网络通讯"></a>21.1.1 网络通讯</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204101445466.png" alt="image-20231204101445466"></p>
<h3 id="21-1-2-网络"><a href="#21-1-2-网络" class="headerlink" title="21.1.2 网络"></a>21.1.2 网络</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204101507849.png" alt="image-20231204101507849"></p>
<h3 id="21-1-3-IP地址"><a href="#21-1-3-IP地址" class="headerlink" title="21.1.3 IP地址"></a>21.1.3 IP地址</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204101613377.png" alt="image-20231204101613377"></p>
<h3 id="21-1-4-ipv4-地址分类"><a href="#21-1-4-ipv4-地址分类" class="headerlink" title="21.1.4 ipv4 地址分类"></a>21.1.4 ipv4 地址分类</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204102429075.png" alt="image-20231204102429075"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204102445872.png" alt="image-20231204102445872"></p>
<h3 id="21-1-5-域名和端口"><a href="#21-1-5-域名和端口" class="headerlink" title="21.1.5 域名和端口"></a>21.1.5 域名和端口</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204102903300.png" alt="image-20231204102903300"></p>
<h3 id="21-1-6-TCP-IP协议"><a href="#21-1-6-TCP-IP协议" class="headerlink" title="21.1.6 TCP/IP协议"></a>21.1.6 TCP/IP协议</h3><ul>
<li>TCP/IP(Transmission Control Protocol/Internet Protocol)的简写中文译名为 <strong>传输控制协议/因特网互联协议</strong>，又叫网络通讯协议，这个协议是 Internet 最基本的协议、国际互联网络的基础，简单地说，就是由网络层的IP协议和传输层的TCP协议组成的。</li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204103420610.png" alt="image-20231204103420610"></p>
<h3 id="21-1-7-网络通信协议"><a href="#21-1-7-网络通信协议" class="headerlink" title="21.1.7 网络通信协议"></a>21.1.7 网络通信协议</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204104003243.png" alt="image-20231204104003243"></p>
<h3 id="21-1-8-TCP-和-UDP"><a href="#21-1-8-TCP-和-UDP" class="headerlink" title="21.1.8 TCP 和 UDP"></a>21.1.8 TCP 和 UDP</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204104325582.png" alt="image-20231204104325582"></p>
<h2 id="21-2-InetAddress-类"><a href="#21-2-InetAddress-类" class="headerlink" title="21.2 InetAddress 类"></a>21.2 InetAddress 类</h2><h3 id="21-2-1-相关方法"><a href="#21-2-1-相关方法" class="headerlink" title="21.2.1 相关方法"></a>21.2.1 相关方法</h3><ol>
<li><strong>getLocalhost</strong>：获取本机InetAddress对象</li>
<li><strong>getByName</strong>：根据指定<strong>主机名/域名</strong>获取InetAddress对象</li>
<li><strong>getHostName</strong>：获取InetAddress对象的主机名</li>
<li><strong>getHostAddress</strong>：获取InetAddress对象的地址</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取本机 InetAddress 对象 getLocalHost</span></span><br><span class="line">InetAddress localHost = InetAddress.getLocalHost();</span><br><span class="line">System.out.println(localHost); <span class="comment">//Durango/172.25.153.218</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定主机名/域名获取 InetAddress对象  getByName</span></span><br><span class="line">InetAddress host2 = InetAddress.getByName(<span class="string">&quot;Durango&quot;</span>);</span><br><span class="line">System.out.println(host2); <span class="comment">//Durango/172.25.153.218</span></span><br><span class="line">InetAddress host3 = InetAddress.getByName(<span class="string">&quot;www.durango.cn&quot;</span>);</span><br><span class="line">System.out.println(host3); <span class="comment">//www.durango.cn/185.199.108.153</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 InetAddress 对象的主机名 getHostName</span></span><br><span class="line">String host3Name = host3.getHostName();</span><br><span class="line">System.out.println(host3Name); <span class="comment">//www.durango.cn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 InetAddress 对象的地址 getHostAddress</span></span><br><span class="line">String host3Address = host3.getHostAddress();</span><br><span class="line">System.out.println(host3Address); <span class="comment">//185.199.108.153</span></span><br></pre></td></tr></table></figure>



<h2 id="21-3-Socket套接字"><a href="#21-3-Socket套接字" class="headerlink" title="21.3 Socket套接字"></a>21.3 Socket套接字</h2><h3 id="21-3-1-基本介绍"><a href="#21-3-1-基本介绍" class="headerlink" title="21.3.1 基本介绍"></a>21.3.1 基本介绍</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204110318452.png" alt="image-20231204110318452"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204110548528.png" alt="image-20231204110548528"></p>
<h2 id="21-4-TCP网络通信编程"><a href="#21-4-TCP网络通信编程" class="headerlink" title="21.4 TCP网络通信编程"></a>21.4 TCP网络通信编程</h2><h3 id="21-4-1-基本介绍和流程"><a href="#21-4-1-基本介绍和流程" class="headerlink" title="21.4.1 基本介绍和流程"></a>21.4.1 基本介绍和流程</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204110802157.png" alt="image-20231204110802157"></p>
<p><font color="red"><strong>注意事项：</strong></font></p>
<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><ul>
<li>思路流程图很重要！</li>
<li>数据发送完毕后记得设置结束标记</li>
<li>最后要关闭相关的流</li>
</ul>
</div>





<h3 id="21-4-2-应用案例-1-使用字节流"><a href="#21-4-2-应用案例-1-使用字节流" class="headerlink" title="21.4.2 应用案例 1(使用字节流)"></a>21.4.2 应用案例 1(使用字节流)</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204111017264.png" alt="image-20231204111017264"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204111528687.png" alt="image-20231204111528687"></p>
<p><font color="red">注意！设置结束标记 socket.shutdownOutput();</font></p>
<ul>
<li><p>SocketTCP01Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTCP01Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 在本机 的 9999 端口监听, 等待连接</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端，在 9999 端口监听，等待连接..&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 当没有客户端连接 9999 端口时，程序会阻塞, 等待连接</span></span><br><span class="line">        <span class="comment">//   如果有客户端连接，则会返回 Socket 对象，程序继续</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端 socket =&quot;</span> + socket.getClass() +<span class="string">&quot;已连接！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 通过 socket.getInputStream() 读取客户端写入到数据通道的数据, 显示</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="comment">//4. IO 读取</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> readLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((readLen = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.关闭流和 socket</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();<span class="comment">//关闭</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端退出.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>SocketTCP01Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTCP01Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 连接服务端 (ip , 端口）</span></span><br><span class="line">        <span class="comment">//解读: 连接本机的 9999 端口, 如果连接成功，返回 Socket 对象</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端 socket 返回=&quot;</span> + socket.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 连接上后，生成 Socket, 通过 socket.getOutputStream()</span></span><br><span class="line">        <span class="comment">// 得到 和 socket 对象关联的输出流对象</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 通过输出流，写入数据到 数据通道</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;hello, server&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 关闭流对象和 socket, 必须关闭</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端退出.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="21-4-3-应用案例-2-使用字节流"><a href="#21-4-3-应用案例-2-使用字节流" class="headerlink" title="21.4.3 应用案例 2(使用字节流)"></a>21.4.3 应用案例 2(使用字节流)</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204135824646.png" alt="image-20231204135824646"></p>
<ul>
<li><p>SocketTCP02Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTCP02Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 在本机 的 9999 端口监听, 等待连接</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端，在 9999 端口监听，等待连接..&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 当没有客户端连接 9999 端口时，程序会阻塞, 等待连接</span></span><br><span class="line">        <span class="comment">//   如果有客户端连接，则会返回 Socket 对象，程序继续</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端 socket 返回=&quot;</span> + socket.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 通过 socket.getInputStream() 读取客户端写入到数据通道的数据, 显示</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="comment">//4. IO 读取</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> readLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((readLen = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 获取 socket 相关联的输出流</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;hello, client&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 设置结束标记</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭流和 socket</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();<span class="comment">//关闭</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端退出.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>SocketTCP02Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTCP02Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 连接服务端 (ip , 端口）</span></span><br><span class="line">        <span class="comment">//解读: 连接本机的 9999 端口, 如果连接成功，返回 Socket 对象</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端 socket 返回=&quot;</span> + socket.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 连接上后，生成 Socket, 通过 socket.getOutputStream()</span></span><br><span class="line">        <span class="comment">// 得到 和 socket 对象关联的输出流对象</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 通过输出流，写入数据到 数据通道</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;hello, server&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 设置结束标记</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 获取和 socket 关联的输入流. 读取数据(字节)，并显示</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> readLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((readLen = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 关闭流对象和 socket, 必须关闭</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端退出.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="21-4-4-应用案例-3-使用字符流"><a href="#21-4-4-应用案例-3-使用字符流" class="headerlink" title="21.4.4 应用案例 3(使用字符流)"></a>21.4.4 应用案例 3(使用字符流)</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231204140444469.png" alt="image-20231204140444469"></p>
<p><font color="red">注意！bufferedWriter.newLine();和bufferedWriter.flush();</font></p>
<ul>
<li><p>SocketTCP03Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 在本机 的 9999 端口监听, 等待连接</span></span><br><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;服务端，在 9999 端口监听，等待连接..&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 当没有客户端连接 9999 端口时，程序会阻塞, 等待连接</span></span><br><span class="line"><span class="comment">//   如果有客户端连接，则会返回 Socket 对象，程序继续</span></span><br><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line">System.out.println(<span class="string">&quot;服务端 socket 返回=&quot;</span> + socket.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 通过 socket.getInputStream() 读取客户端写入到数据通道的数据, 显示</span></span><br><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. IO 读取, 使用字符流, 使用 InputStreamReader 将 inputStream 转成字符流</span></span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">String s = bufferedReader.readLine();</span><br><span class="line">System.out.println(s);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 获取 socket 相关联的输出流</span></span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"><span class="comment">// 使用字符输出流的方式回复信息 使用 OutputStreamWriter 将 outputStream 转换成字符流</span></span><br><span class="line">BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(outputStream));</span><br><span class="line">bufferedWriter.write(<span class="string">&quot;hello client 字符流&quot;</span>);</span><br><span class="line">bufferedWriter.newLine();<span class="comment">// 插入一个换行符，表示回复内容的结束！！！ 相当于socket.shutdownOutput()</span></span><br><span class="line">bufferedWriter.flush(); <span class="comment">//注意需要手动的 flush!!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.关闭流和 socket</span></span><br><span class="line">bufferedReader.close();</span><br><span class="line">bufferedWriter.close();</span><br><span class="line">socket.close();</span><br><span class="line">serverSocket.close();<span class="comment">//关闭</span></span><br><span class="line">System.out.println(<span class="string">&quot;服务端退出.....&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>SocketTCP03Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 连接服务端 (ip , 端口）</span></span><br><span class="line"><span class="comment">//解读: 连接本机的 9999 端口, 如果连接成功，返回 Socket 对象</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;客户端 socket 返回=&quot;</span> + socket.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 连接上后，生成 Socket, 通过 socket.getOutputStream()</span></span><br><span class="line"><span class="comment">// 得到 和 socket 对象关联的输出流对象</span></span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 通过输出流，写入数据到 数据通道, 使用字符流</span></span><br><span class="line">BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(outputStream));</span><br><span class="line">bufferedWriter.write(<span class="string">&quot;hello, server 字符流&quot;</span>);</span><br><span class="line">bufferedWriter.newLine();<span class="comment">//插入一个换行符，表示写入的内容结束, 注意，要求对方使用 readLine()!!!!</span></span><br><span class="line">bufferedWriter.flush();<span class="comment">// 如果使用的字符流，需要手动刷新，否则数据不会写入数据通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 获取和 socket 关联的输入流. 读取数据(字符)，并显示</span></span><br><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">String s = bufferedReader.readLine();</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 关闭流对象和 socket, 必须关闭</span></span><br><span class="line">bufferedReader.close();<span class="comment">//关闭外层流</span></span><br><span class="line">bufferedWriter.close();</span><br><span class="line">socket.close();</span><br><span class="line">System.out.println(<span class="string">&quot;客户端退出.....&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="21-4-5-应用案例-4-上传图片"><a href="#21-4-5-应用案例-4-上传图片" class="headerlink" title="21.4.5 应用案例 4(上传图片)"></a>21.4.5 应用案例 4(上传图片)</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231205092658640.png" alt="image-20231205092658640"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231205102621085.png" alt="image-20231205102621085"></p>
<ul>
<li><p>StreamUtils.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//功能：将输入流转换成字节数组 byte[]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] streamToByteArray(InputStream is) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">//创建输出流对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; <span class="comment">//字节数组</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] array = bos.toByteArray();</span><br><span class="line">        bos.close();</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//功能：将 InputStream 转换成 String</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">streamToString</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">//当读取到 null 时，就表示结束</span></span><br><span class="line">            builder.append(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TCPFileUploadServer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPFileUploadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 服务端在本机监听8888端口</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端在8888端口监听，等待连接...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 等待连接</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.通过socket获取输入流，读取客户端发送的数据</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(socket.getInputStream());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = StreamUtils.streamToByteArray(bis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将bytes写入到指定路径的文件</span></span><br><span class="line">        String filePath = <span class="string">&quot;src\\copy.jpg&quot;</span>;</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(filePath));</span><br><span class="line">        bos.write(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.通过socket获取输出流，发送“收到图片”(通过字符流)</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">        bw.write(<span class="string">&quot;收到图片&quot;</span>);</span><br><span class="line">        bw.flush(); <span class="comment">//把内容刷新到数据通道</span></span><br><span class="line">        socket.shutdownOutput();<span class="comment">//设置结束标记</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.关闭相关流</span></span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">        bw.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TCPFileUploadClient.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPFileUploadClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 客户端连接服务端，得到socket对象</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接到服务器...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建读取磁盘文件的输入流</span></span><br><span class="line">        String filePath = <span class="string">&quot;D:\\zlx18\\Pictures\\Camera Roll\\绘图1.jpg&quot;</span>;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(filePath));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 把文件保存到字节数组中</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = StreamUtils.streamToByteArray(bis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.通过socket获取输出流，将bytes发送到服务端</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line">        bos.write(bytes); <span class="comment">//将文件对应的字节内容写入到数据通道</span></span><br><span class="line">        socket.shutdownOutput(); <span class="comment">//设置结束标记</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.通过socket获取输入流，接收服务端回复的消息</span></span><br><span class="line">        <span class="comment">// 使用StreamUtils工具类将输入流转换为String</span></span><br><span class="line">        String s = StreamUtils.streamToString(socket.getInputStream());</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.关闭相关流</span></span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="21-4-6-netstat-指令"><a href="#21-4-6-netstat-指令" class="headerlink" title="21.4.6 netstat 指令"></a>21.4.6 netstat 指令</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231205103402358.png" alt="image-20231205103402358"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231205104119614.png" alt="image-20231205104119614"></p>
<h2 id="21-5-UDP网络通信编程"><a href="#21-5-UDP网络通信编程" class="headerlink" title="21.5 UDP网络通信编程"></a>21.5 UDP网络通信编程</h2><h3 id="21-5-1-基本介绍和流程"><a href="#21-5-1-基本介绍和流程" class="headerlink" title="21.5.1 基本介绍和流程"></a>21.5.1 基本介绍和流程</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231205104754694.png" alt="image-20231205104754694"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231205105054222.png" alt="image-20231205105054222"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231205105303498.png" alt="image-20231205105303498"></p>
<h3 id="21-5-2-案例1"><a href="#21-5-2-案例1" class="headerlink" title="21.5.2 案例1"></a>21.5.2 案例1</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231205105332697.png" alt="image-20231205105332697"></p>
<ul>
<li><p>UDPReceiverA.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPReceiverA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建一个 DatagramSocket 对象，准备在 9999 接收数据</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 构建一个 (空的)DatagramPacket 对象，准备接收数据</span></span><br><span class="line">        <span class="comment">//   一个数据包最大 64k</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 调用接收方法, 将通过网络传输的 DatagramPacket 对象 填充到 packet 对象</span></span><br><span class="line">        <span class="comment">//   当有数据报发送到 本机的 9999 端口时，就会接收到数据</span></span><br><span class="line">        <span class="comment">//   如果没有数据包发送到 本机的 9999 端口, 就会阻塞等待.</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收端 A 等待接收数据..&quot;</span>);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 把 packet 进行拆包，取出数据，并显示.</span></span><br><span class="line">        <span class="keyword">int</span> length = packet.getLength();<span class="comment">//实际接收到的数据字节长度</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = packet.getData();<span class="comment">//接收到数据</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(data, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//===回复信息给 B 端</span></span><br><span class="line">        <span class="comment">//将需要发送的数据，封装到 DatagramPacket 对象</span></span><br><span class="line">        data = <span class="string">&quot;好的, 明天见&quot;</span>.getBytes();</span><br><span class="line">        packet =</span><br><span class="line">                <span class="keyword">new</span> DatagramPacket(data, data.length, InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9998</span>);</span><br><span class="line">        socket.send(packet);<span class="comment">//发送</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;A 端退出...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>UDPSenderB.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //1.创建 DatagramSocket 对象，准备在 9998 端口 接收数据</span><br><span class="line">        DatagramSocket socket = new DatagramSocket(9998);</span><br><span class="line"></span><br><span class="line">        //2. 将需要发送的数据，封装到 DatagramPacket 对象</span><br><span class="line">        byte[] data = &quot;hello 明天吃火锅~&quot;.getBytes(); //</span><br><span class="line">        DatagramPacket packet =</span><br><span class="line">                new DatagramPacket(data, data.length, InetAddress.getByName(&quot;127.0.0.1&quot;), 9999);</span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        //3.=== 接收从 A 端回复的信息</span><br><span class="line">        //(1) 构建一个 DatagramPacket 对象，准备接收数据</span><br><span class="line">        byte[] buf = new byte[1024];</span><br><span class="line">        packet = new DatagramPacket(buf, buf.length);</span><br><span class="line">        //(2) 调用 接收方法, 将通过网络传输的 DatagramPacket 对象填充到 packet 对象</span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        //(3) 可以把 packet 进行拆包，取出数据，并显示.</span><br><span class="line">        int length = packet.getLength();//实际接收到的数据字节长度</span><br><span class="line">        data = packet.getData();//接收到数据</span><br><span class="line">        String s = new String(data, 0, length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        //4.关闭资源</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(&quot;B 端退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="21-6-Homeworks"><a href="#21-6-Homeworks" class="headerlink" title="21.6 Homeworks"></a>21.6 Homeworks</h2><h3 id="21-6-1-多次对话"><a href="#21-6-1-多次对话" class="headerlink" title="21.6.1 多次对话"></a>21.6.1 多次对话</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231205150951816.png" alt="image-20231205150951816"></p>
<ul>
<li><p>Homework01Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Homework01Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待客户端连接...&quot;</span>);</span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">        <span class="keyword">boolean</span> key = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (key) &#123;</span><br><span class="line">            <span class="comment">// 采用字符流</span></span><br><span class="line">            String s = bufferedReader.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端：&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;name&quot;</span>)) &#123;</span><br><span class="line">                bufferedWriter.write(<span class="string">&quot;我是nova&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">&quot;hobby&quot;</span>)) &#123;</span><br><span class="line">                bufferedWriter.write(<span class="string">&quot;编写java程序&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                bufferedWriter.write(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">                key = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bufferedWriter.write(<span class="string">&quot;你说什么&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            bufferedWriter.newLine();</span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;与客户端对话结束&quot;</span>);</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Homework01Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Homework01Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">8080</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接到服务端！&quot;</span>);</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> key = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (key) &#123;</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            String message = scanner.next();</span><br><span class="line"></span><br><span class="line">            bufferedWriter.write(message);</span><br><span class="line">            bufferedWriter.newLine(); <span class="comment">// 插入换行符表示结束标志</span></span><br><span class="line">            bufferedWriter.flush();   <span class="comment">// 注意需要手动的 flush!!!</span></span><br><span class="line"></span><br><span class="line">            String s = bufferedReader.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端：&quot;</span> + s);</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                key = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;与服务端对话结束&quot;</span>);</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="21-6-2-音乐下载"><a href="#21-6-2-音乐下载" class="headerlink" title="21.6.2 音乐下载"></a>21.6.2 音乐下载</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231205153031867.png" alt="image-20231205153031867"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231205195815546.png" alt="image-20231205195815546"></p>
<ul>
<li><p>Homework03Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Homework03Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 监听端口，等待客户端连接</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端等待连接...&quot;</span>);</span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已连接！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 得到socket关联的输入流，读取客户端要下载的文件名</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        String musicName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            musicName += <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端想要下载音乐《&quot;</span> + musicName + <span class="string">&quot;》&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 判断用户下载的文件是否存在</span></span><br><span class="line">        String filePath = <span class="string">&quot;src\\music\\&quot;</span> + musicName + <span class="string">&quot;.mp3&quot;</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\music\\无名.mp3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.从磁盘读取文件到字节数组</span></span><br><span class="line">        BufferedInputStream bis2 = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = StreamUtils.streamToByteArray(bis2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 得到socket关联的输出流，写入数据通道</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line">        System.out.println(<span class="string">&quot;音乐传输中...&quot;</span>);</span><br><span class="line">        bos.write(bytes);</span><br><span class="line">        bos.flush();</span><br><span class="line">        System.out.println(<span class="string">&quot;音乐传输完毕！&quot;</span>);</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 关闭相关流</span></span><br><span class="line">        is.close();</span><br><span class="line">        bis2.close();</span><br><span class="line">        bos.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Homework03Client.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Homework03Client &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 1. 连接服务端</span><br><span class="line">        Socket socket = new Socket(InetAddress.getLocalHost(), 8888);</span><br><span class="line">        System.out.println(&quot;连接到服务器&quot;);</span><br><span class="line"></span><br><span class="line">        // 2. 得到socket关联的输出流，发送要下载的文件名给客户端</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入你想下载的音乐名称：&quot;);</span><br><span class="line">        String musicName = scanner.next();</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(musicName.getBytes());</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        // 3. 得到socket关联的输入流，从数据通道读取数据到字节数组</span><br><span class="line">        String filePath = &quot;src\\music.mp3&quot;;</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());</span><br><span class="line">        byte[] bytes = StreamUtils.streamToByteArray(bis);</span><br><span class="line"></span><br><span class="line">        // 4. 将字节数组数据写入文件</span><br><span class="line">        BufferedOutputStream bos2 = new BufferedOutputStream(new FileOutputStream(filePath));</span><br><span class="line">        bos2.write(bytes);</span><br><span class="line">        System.out.println(&quot;音乐已经保存&quot;);</span><br><span class="line"></span><br><span class="line">		// 5. 关闭相关流</span><br><span class="line">        os.close();</span><br><span class="line">        bos2.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="第二十二章-多用户及时通信系统"><a href="#第二十二章-多用户及时通信系统" class="headerlink" title="第二十二章 多用户及时通信系统"></a>第二十二章 多用户及时通信系统</h1><h2 id="22-1-相关技术"><a href="#22-1-相关技术" class="headerlink" title="22.1 相关技术"></a>22.1 相关技术</h2><ul>
<li>项目框架设计</li>
<li>java面向对象编程</li>
<li>网络编程</li>
<li>多线程</li>
<li>IO流</li>
<li>mysql/使用集合充当内存数据库</li>
</ul>
<h2 id="22-2-项目开发流程"><a href="#22-2-项目开发流程" class="headerlink" title="22.2 项目开发流程"></a>22.2 项目开发流程</h2><ul>
<li>需求分析(30%) ==》设计阶段(20%) ==》实现阶段(20%) ==》测试阶段(20%) ==》实施阶段(10%) ==》维护阶段</li>
<li>开发 –&gt; 架构师、项目经理 or 产品经理</li>
<li>项目越大，需求和设计阶段占用时间越多</li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231206100702907.png" alt="image-20231206100702907"></p>
<h2 id="22-3-需求分析"><a href="#22-3-需求分析" class="headerlink" title="22.3 需求分析"></a>22.3 需求分析</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231206101857544.png" alt="image-20231206101857544"></p>
<h2 id="22-4-界面设计"><a href="#22-4-界面设计" class="headerlink" title="22.4 界面设计"></a>22.4 界面设计</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231206102025331.png" alt="image-20231206102025331"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231206102035230.png" alt="image-20231206102035230"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231206102100889.png" alt="image-20231206102100889"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231206102116587.png" alt="image-20231206102116587"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231206102147145.png" alt="image-20231206102147145"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231206102408675.png" alt="image-20231206102408675"></p>
<h2 id="22-5-功能-用户登录"><a href="#22-5-功能-用户登录" class="headerlink" title="22.5 功能 - 用户登录"></a>22.5 功能 - 用户登录</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231206103323570.png" alt="image-20231206103323570"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231206103521638.png" alt="image-20231206103521638"></p>
<h2 id="22-6-功能-拉取在线用户列表"><a href="#22-6-功能-拉取在线用户列表" class="headerlink" title="22.6 功能 - 拉取在线用户列表"></a>22.6 功能 - 拉取在线用户列表</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231211095407465.png" alt="image-20231211095407465"></p>
<h2 id="22-7-功能-无异常退出"><a href="#22-7-功能-无异常退出" class="headerlink" title="22.7 功能 - 无异常退出"></a>22.7 功能 - 无异常退出</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231211100407993.png" alt="image-20231211100407993"></p>
<h2 id="22-8-功能-私聊"><a href="#22-8-功能-私聊" class="headerlink" title="22.8 功能 - 私聊"></a>22.8 功能 - 私聊</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231211103253939.png" alt="image-20231211103253939"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231211105712625.png" alt="image-20231211105712625"></p>
<h2 id="22-9-功能-群发"><a href="#22-9-功能-群发" class="headerlink" title="22.9 功能 - 群发"></a>22.9 功能 - 群发</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231212100345453.png" alt="image-20231212100345453"></p>
<h2 id="22-10-功能-发文件"><a href="#22-10-功能-发文件" class="headerlink" title="22.10 功能 - 发文件"></a>22.10 功能 - 发文件</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231213095343660.png" alt="image-20231213095343660"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231213095700939.png" alt="image-20231213095700939"></p>
<h2 id="22-11-功能-服务器推送新闻"><a href="#22-11-功能-服务器推送新闻" class="headerlink" title="22.11 功能 - 服务器推送新闻"></a>22.11 功能 - 服务器推送新闻</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231214094835659.png" alt="image-20231214094835659"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231214094854374.png" alt="image-20231214094854374"></p>
<h2 id="22-12-功能扩展-离线发送"><a href="#22-12-功能扩展-离线发送" class="headerlink" title="22.12 功能扩展 - 离线发送"></a>22.12 功能扩展 - 离线发送</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231214100731327.png" alt="image-20231214100731327"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231214101119272.png" alt="image-20231214101119272"></p>
<h2 id="22-13-项目框架分析"><a href="#22-13-项目框架分析" class="headerlink" title="22.13 项目框架分析"></a>22.13 项目框架分析</h2><h3 id="22-13-1-文件目录"><a href="#22-13-1-文件目录" class="headerlink" title="22.13.1 文件目录"></a>22.13.1 文件目录</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231217113613542.png" alt="image-20231217113613542"></p>
<h3 id="22-13-2-客户端框架"><a href="#22-13-2-客户端框架" class="headerlink" title="22.13.2 客户端框架"></a>22.13.2 客户端框架</h3><ul>
<li><p>视图类：QQView</p>
</li>
<li><p>服务类：</p>
<ul>
<li>ClientService：<em>完成用户登录验证、用户注册、退出客户端等功能</em></li>
<li>MessageClientService：<em>提供和消息相关的服务功能</em></li>
<li>FileClientService：<em>提供文件传输服务</em></li>
</ul>
</li>
<li><p>线程类：ClientConnectServerThread，<em>用于保持和服务器端的<strong>socket</strong>连接</em></p>
</li>
<li><p>管理类：ManageClientConnectServerThread，<em>管理客户端连接到服务器端线程</em></p>
</li>
<li><p><strong>视图类</strong>根据用户选择调用各个<strong>服务类</strong>的功能，ClientService建立起和服务器的socket连接，并创建<strong>线程类</strong>ClientConnectServerThread，保持和服务器端的<strong>socket</strong>连接。该<strong>线程类</strong>通过ManageClientConnectServerThread管理类进行管理，以便于其他服务能获得该线程及socket连接。MessageClientService和FileClientService都是通过<strong>管理类</strong>获得维持连接的<strong>线程类</strong>socket后，完成相应功能。</p>
</li>
</ul>
<h3 id="22-13-3-服务端框架"><a href="#22-13-3-服务端框架" class="headerlink" title="22.13.3 服务端框架"></a>22.13.3 服务端框架</h3><ul>
<li>服务类：<ul>
<li>ServerService：建立来自各个客户端的socket连接，验证登录是否合法</li>
</ul>
</li>
<li>线程类：<ul>
<li>ServerConnectClientThread：用于保持和用户端的<strong>socket</strong>连接，实现各种业务逻辑，如获取在线用户列表、退出系统、转发、群发、发文件等。</li>
<li>SendNewsToAllService：服务器推送消息的线程</li>
</ul>
</li>
<li>管理类：ManageServerConnectClientThread，管理ServerConnectClientThread线程类</li>
<li><strong>服务类</strong>监听端口并建立各个客户端的socket连接，验证登录是否合法后开启ServerConnectClientThread<strong>线程类</strong>维持<strong>socket</strong>连接，线程类通过接收到的客户端请求，做出相应业务处理。管理类ManageServerConnectClientThread便于获取线程socket连接以及断开连接等操作。</li>
</ul>
<h1 id="第二十三章-反射"><a href="#第二十三章-反射" class="headerlink" title="第二十三章 反射"></a>第二十三章 反射</h1><h2 id="23-1-一个需求引出反射"><a href="#23-1-一个需求引出反射" class="headerlink" title="23.1 一个需求引出反射"></a>23.1 一个需求引出反射</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240119100103895.png" alt="image-20240119100103895"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据配置文件 re.properties 指定信息, 创建 Cat 对象并调用方法 hi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传统的方式 new 对象 -》 调用方法</span></span><br><span class="line"><span class="comment">// Cat cat = new Cat();</span></span><br><span class="line"><span class="comment">// cat.hi(); ===&gt; cat.cry() 修改源码.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用 Properties 类, 可以读写配置文件</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line">String classfullpath = properties.get(<span class="string">&quot;classfullpath&quot;</span>).toString(); <span class="comment">//&quot;com.hspedu.Cat&quot;</span></span><br><span class="line">String methodName = properties.get(<span class="string">&quot;method&quot;</span>).toString(); <span class="comment">//&quot;hi&quot;</span></span><br><span class="line">System.out.println(<span class="string">&quot;classfullpath=&quot;</span> + classfullpath);</span><br><span class="line">System.out.println(<span class="string">&quot;method=&quot;</span> + methodName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建对象 , 传统的方法，行不通 =》 反射机制</span></span><br><span class="line"><span class="comment">//new classfullpath(); classfullpath是字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 使用反射机制解决</span></span><br><span class="line"><span class="comment">//  修改配置文件可加载不同的类和不同的方法</span></span><br><span class="line"><span class="comment">// (1) 加载类, 返回 Class 类型的对象 cls</span></span><br><span class="line">Class cls = Class.forName(classfullpath);</span><br><span class="line"><span class="comment">// (2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例</span></span><br><span class="line">Object o = cls.newInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;o 的运行类型=&quot;</span> + o.getClass()); <span class="comment">//运行类型</span></span><br><span class="line"><span class="comment">// (3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName 的方法对象</span></span><br><span class="line"><span class="comment">// 即：在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line">Method method1 = cls.getMethod(methodName);</span><br><span class="line"><span class="comment">//(4) 通过 method1 调用方法: 即通过方法对象来实现调用方法</span></span><br><span class="line">method1.invoke(o); <span class="comment">//传统方法 对象.方法() , 反射机制 方法对象.invoke(对象实例)</span></span><br></pre></td></tr></table></figure>



<h2 id="23-2-反射机制"><a href="#23-2-反射机制" class="headerlink" title="23.2 反射机制"></a>23.2 反射机制</h2><h3 id="23-2-1-Java-Reflection"><a href="#23-2-1-Java-Reflection" class="headerlink" title="23.2.1 Java Reflection"></a>23.2.1 Java Reflection</h3><ul>
<li>反射机制允许程序在执行期借助于Reflection API<strong>取得任何类的内部信息</strong>(比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法。反射<strong>在设计模式和框架底层都会用到</strong>。</li>
<li>加载完类之后，在堆中就产生了一个<strong>Class类型的对象</strong> (一个类只对应一个Class对象) ，<strong>这个对象包含了类的完整结构信息</strong>。通过这个对象得到类的结构。这个Class对象就像一面镜子，透过这个镜子看到类的结构，以，形象的称之为: 反射</li>
</ul>
<h3 id="23-2-2-原理示意图"><a href="#23-2-2-原理示意图" class="headerlink" title="23.2.2 原理示意图"></a>23.2.2 原理示意图</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240119103941797.png" alt="image-20240119103941797"></p>
<h3 id="23-2-3-反射的作用"><a href="#23-2-3-反射的作用" class="headerlink" title="23.2.3 反射的作用"></a>23.2.3 反射的作用</h3><ol>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时得到任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>生成动态代理（<strong>动态加载类</strong>，降低依赖性）</li>
</ol>
<h3 id="23-2-4-反射相关的主要类"><a href="#23-2-4-反射相关的主要类" class="headerlink" title="23.2.4 反射相关的主要类"></a>23.2.4 反射相关的主要类</h3><ol>
<li>java.lang.<strong>Class</strong>:代表一个类， Class对象表示某个类加载后在堆中的对象</li>
<li>构造器java.lang.reflect.<strong>Method</strong>: 代表类的方法,Method对象表示某个类的方法</li>
<li>java.lang.reflect.<strong>Field</strong>: 代表类的成员变量,Field对象表示某个类的成员变量</li>
<li>java.lang.reflect.<strong>Constructor</strong>: 代表类的构造方法, Constructor对象表示</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 使用 Properties 类, 可以读写配置文件</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line">String classfullpath = properties.get(<span class="string">&quot;classfullpath&quot;</span>).toString();<span class="comment">//&quot;com.durango.Cat&quot;</span></span><br><span class="line">String methodName = properties.get(<span class="string">&quot;method&quot;</span>).toString();<span class="comment">//&quot;hi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用反射机制解决</span></span><br><span class="line"><span class="comment">//(1) 加载类, 返回 Class 类型的对象 cls</span></span><br><span class="line">Class cls = Class.forName(classfullpath);</span><br><span class="line"><span class="comment">//(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例</span></span><br><span class="line">Object o = cls.newInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;o 的运行类型=&quot;</span> + o.getClass()); <span class="comment">//运行类型</span></span><br><span class="line"><span class="comment">//(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName&quot;hi&quot; 的方法对象</span></span><br><span class="line"><span class="comment">// 即：在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line">Method method1 = cls.getMethod(methodName);</span><br><span class="line"><span class="comment">//(4) 通过 method1 调用方法: 即通过方法对象来实现调用方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;=============================&quot;</span>);</span><br><span class="line">method1.invoke(o); <span class="comment">//传统方法 对象.方法() , 反射: 成员方法.invoke(对象)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(5)java.lang.reflect.Field: 代表类的成员变量, Field 对象表示某个类的成员变量</span></span><br><span class="line"><span class="comment">//得到 name 字段</span></span><br><span class="line"><span class="comment">//getField 不能得到私有的属性</span></span><br><span class="line">Field nameField = cls.getField(<span class="string">&quot;name&quot;</span>); <span class="comment">//</span></span><br><span class="line">System.out.println(nameField.get(o)); <span class="comment">// 传统写法 对象.成员变量 , 反射 : 成员变量.get(对象)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(6)java.lang.reflect.Constructor: 代表类的构造方法, Constructor 对象表示构造器</span></span><br><span class="line">Constructor constructor = cls.getConstructor(); <span class="comment">//返回无参构造器</span></span><br><span class="line">System.out.println(constructor);<span class="comment">//Cat()</span></span><br><span class="line">Constructor constructor2 = cls.getConstructor(String.class);</span><br><span class="line">System.out.println(constructor2);<span class="comment">//Cat(String name)</span></span><br></pre></td></tr></table></figure>



<h3 id="23-2-5-反射优点和缺点"><a href="#23-2-5-反射优点和缺点" class="headerlink" title="23.2.5 反射优点和缺点"></a>23.2.5 反射优点和缺点</h3><ul>
<li>优点: 可以<strong>动态的创建和使用对象</strong>(也是框架底层核心)，使用灵活,没有反射机制，框架技术就失去底层支撑。</li>
<li>缺点: 使用反射基本是解释执行，对<strong>执行速度</strong>有影响</li>
</ul>
<h3 id="23-2-6-反射调用优化"><a href="#23-2-6-反射调用优化" class="headerlink" title="23.2.6 反射调用优化"></a>23.2.6 反射调用优化</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240119141022509.png" alt="image-20240119141022509"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Reflection02 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchMethodException &#123;</span><br><span class="line">        m1();//传统 耗时=0</span><br><span class="line">        m2();//反射 耗时=1075</span><br><span class="line">        m3();//反射优化 耗时=766</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //传统方法来调用 hi</span><br><span class="line">    public static void m1() &#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; 90; i++) &#123;</span><br><span class="line">            cat.hi();</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;m1() 耗时=&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //反射机制调用方法 hi</span><br><span class="line">    public static void m2() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class cls = Class.forName(&quot;com.durango.Cat&quot;);</span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        Method hi = cls.getMethod(&quot;hi&quot;);</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; 900000000; i++) &#123;</span><br><span class="line">            hi.invoke(o);//反射调用方法</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;m2() 耗时=&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //反射调用优化 + 关闭访问检查</span><br><span class="line">    public static void m3() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class cls = Class.forName(&quot;com.durango.Cat&quot;);</span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        Method hi = cls.getMethod(&quot;hi&quot;);</span><br><span class="line">        hi.setAccessible(true);//在反射调用方法时，取消访问检查</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; 900000000; i++) &#123;</span><br><span class="line">            hi.invoke(o);//反射调用方法</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;m3() 耗时=&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="23-3-Class类"><a href="#23-3-Class类" class="headerlink" title="23.3 Class类"></a>23.3 Class类</h2><h3 id="23-3-1-基本介绍"><a href="#23-3-1-基本介绍" class="headerlink" title="23.3.1 基本介绍"></a>23.3.1 基本介绍</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240120101117147.png" alt="image-20240120101117147"></p>
<ul>
<li>Class也是类，因此也继承Obiect类[类图]</li>
<li>Class类对象不是new出来的，而是系统创建的。ClassLoader类的loadClass方法</li>
<li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li>
<li>每个类的实例都会记得自己是由哪个Class实例所生成</li>
<li>通过Class对象可以完整地得到一个<strong>类的完整结构</strong>，通过一系列API</li>
<li>Class对象是存放在<strong>堆</strong>的</li>
<li>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据(包括方法代码(<a href="https://www.zhihu.com/question/38496907)%E5%8F%98%E9%87%8F%E5%90%8D%EF%BC%8C%E6%96%B9%E6%B3%95%E5%90%8D%EF%BC%8C%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%AD%89%E7%AD%89">https://www.zhihu.com/question/38496907)变量名，方法名，访问权限等等</a>)</li>
</ul>
<h3 id="23-3-2-常用方法"><a href="#23-3-2-常用方法" class="headerlink" title="23.3.2 常用方法"></a>23.3.2 常用方法</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240120103747056.png" alt="image-20240120103747056"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Class02 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">        String classAllPath = &quot;com.durango.Car&quot;;</span><br><span class="line">        //1 . 获取到 Car 类 对应的 Class 对象</span><br><span class="line">        //&lt;?&gt; 表示不确定的 Java 类型</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(classAllPath);</span><br><span class="line"></span><br><span class="line">        //2. 输出 cls</span><br><span class="line">        System.out.println(cls); //显示 cls 对象, 是哪个类的 Class 对象 com.durango.Car</span><br><span class="line">        System.out.println(cls.getClass());//输出 cls 运行类型 java.lang.Class</span><br><span class="line"></span><br><span class="line">        //3. 得到包名</span><br><span class="line">        System.out.println(cls.getPackage().getName());//包名 com.durango</span><br><span class="line"></span><br><span class="line">        //4. 得到全类名</span><br><span class="line">        System.out.println(cls.getName()); //com.durango.Car</span><br><span class="line"></span><br><span class="line">        //5. 通过 cls 创建对象实例</span><br><span class="line">        Car car = (Car) cls.newInstance();</span><br><span class="line">        System.out.println(car);//car.toString()</span><br><span class="line"></span><br><span class="line">        //6. 通过反射获取属性 brand</span><br><span class="line">        Field brand = cls.getField(&quot;brand&quot;);</span><br><span class="line">        System.out.println(brand.get(car));//宝马</span><br><span class="line"></span><br><span class="line">        //7. 通过反射给属性赋值</span><br><span class="line">        brand.set(car, &quot;奔驰&quot;);</span><br><span class="line">        System.out.println(brand.get(car));//奔驰</span><br><span class="line"></span><br><span class="line">        //8 我希望大家可以得到所有的属性(字段)</span><br><span class="line">        System.out.println(&quot;=======所有的字段属性====&quot;);</span><br><span class="line">        Field[] fields = cls.getFields();</span><br><span class="line">        for (Field f : fields) &#123;</span><br><span class="line">            System.out.println(f.getName());//名称</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="23-4-获取Class类对象"><a href="#23-4-获取Class类对象" class="headerlink" title="23.4 获取Class类对象"></a>23.4 获取Class类对象</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240120110300919.png" alt="image-20240120110300919"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240120110310107.png" alt="image-20240120110310107"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. Class.forName</span></span><br><span class="line">String classAllPath = <span class="string">&quot;com.durango.Car&quot;</span>; <span class="comment">//通过读取配置文件获取</span></span><br><span class="line">Class&lt;?&gt; cls1 = Class.forName(classAllPath);</span><br><span class="line">System.out.println(cls1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 类名.class , 应用场景: 用于参数传递</span></span><br><span class="line">Class cls2 = Car.class;</span><br><span class="line">System.out.println(cls2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对象.getClass(), 应用场景，有对象实例</span></span><br><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">Class cls3 = car.getClass();</span><br><span class="line">System.out.println(cls3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 通过类加载器来获取到类的 Class 对象</span></span><br><span class="line"><span class="comment">//  (1)先得到类加载器 car</span></span><br><span class="line">ClassLoader classLoader = car.getClass().getClassLoader();</span><br><span class="line"><span class="comment">//  (2)通过类加载器得到 Class 对象</span></span><br><span class="line">Class cls4 = classLoader.loadClass(classAllPath);</span><br><span class="line">System.out.println(cls4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cls1 , cls2 , cls3 , cls4 其实是同一个对象</span></span><br><span class="line">System.out.println(cls1.hashCode());</span><br><span class="line">System.out.println(cls2.hashCode());</span><br><span class="line">System.out.println(cls3.hashCode());</span><br><span class="line">System.out.println(cls4.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 基本数据(int, char,boolean,float,double,byte,long,short) 按如下方式得到 Class 类对象</span></span><br><span class="line">Class&lt;Integer&gt; integerClass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;Character&gt; characterClass = <span class="keyword">char</span>.class;</span><br><span class="line">Class&lt;Boolean&gt; booleanClass = <span class="keyword">boolean</span>.class;</span><br><span class="line">System.out.println(integerClass);<span class="comment">//int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 基本数据类型对应的包装类，可以通过 .TYPE 得到 Class 类对象</span></span><br><span class="line">Class&lt;Integer&gt; type1 = Integer.TYPE;</span><br><span class="line">Class&lt;Character&gt; type2 = Character.TYPE; <span class="comment">//其它包装类 BOOLEAN, DOUBLE, LONG,BYTE 等待</span></span><br><span class="line">System.out.println(type1);</span><br><span class="line">System.out.println(integerClass.hashCode());<span class="comment">//1956725890</span></span><br><span class="line">System.out.println(type1.hashCode());<span class="comment">//1956725890</span></span><br></pre></td></tr></table></figure>



<h2 id="23-5-哪些类型有-Class-对象"><a href="#23-5-哪些类型有-Class-对象" class="headerlink" title="23.5 哪些类型有 Class 对象"></a>23.5 哪些类型有 Class 对象</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240120110435904.png" alt="image-20240120110435904"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;String&gt; cls1 = String.class;<span class="comment">//外部类</span></span><br><span class="line">Class&lt;Serializable&gt; cls2 = Serializable.class;<span class="comment">//接口</span></span><br><span class="line">Class&lt;Integer[]&gt; cls3 = Integer[].class;<span class="comment">//数组</span></span><br><span class="line">Class&lt;<span class="keyword">float</span>[][]&gt; cls4 = <span class="keyword">float</span>[][].class;<span class="comment">//二维数组</span></span><br><span class="line">Class&lt;Deprecated&gt; cls5 = Deprecated.class;<span class="comment">//注解</span></span><br><span class="line">Class&lt;Thread.State&gt; cls6 = Thread.State.class;<span class="comment">//枚举</span></span><br><span class="line">Class&lt;Long&gt; cls7 = <span class="keyword">long</span>.class;<span class="comment">//基本数据类型</span></span><br><span class="line">Class&lt;Void&gt; cls8 = <span class="keyword">void</span>.class;<span class="comment">//void 数据类型</span></span><br><span class="line">Class&lt;Class&gt; cls9 = Class.class;<span class="comment">// Class</span></span><br></pre></td></tr></table></figure>



<h2 id="23-6-类加载"><a href="#23-6-类加载" class="headerlink" title="23.6 类加载"></a>23.6 类加载</h2><h3 id="23-6-1-基本说明"><a href="#23-6-1-基本说明" class="headerlink" title="23.6.1 基本说明"></a>23.6.1 基本说明</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121125253492.png" alt="image-20240121125253492"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121125833970.png" alt="image-20240121125833970"></p>
<h3 id="23-6-2-类加载时机"><a href="#23-6-2-类加载时机" class="headerlink" title="23.6.2 类加载时机"></a>23.6.2 类加载时机</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121125423921.png" alt="image-20240121125423921"></p>
<h3 id="23-6-3-类加载过程图"><a href="#23-6-3-类加载过程图" class="headerlink" title="23.6.3 类加载过程图"></a>23.6.3 类加载过程图</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121130105461.png" alt="image-20240121130105461"></p>
<h3 id="23-6-4-类加载各阶段完成任务"><a href="#23-6-4-类加载各阶段完成任务" class="headerlink" title="23.6.4 类加载各阶段完成任务"></a>23.6.4 类加载各阶段完成任务</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121130715158.png" alt="image-20240121130715158"></p>
<h3 id="23-6-5-加载阶段"><a href="#23-6-5-加载阶段" class="headerlink" title="23.6.5 加载阶段"></a>23.6.5 加载阶段</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121131146246.png" alt="image-20240121131146246"></p>
<h3 id="23-6-6-连接阶段-验证"><a href="#23-6-6-连接阶段-验证" class="headerlink" title="23.6.6 连接阶段 - 验证"></a>23.6.6 连接阶段 - 验证</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121131401578.png" alt="image-20240121131401578"></p>
<h3 id="23-6-7-连接阶段-准备"><a href="#23-6-7-连接阶段-准备" class="headerlink" title="23.6.7 连接阶段 - 准备"></a>23.6.7 连接阶段 - 准备</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121131457998.png" alt="image-20240121131457998"></p>
<h3 id="23-6-8-连接阶段-解析"><a href="#23-6-8-连接阶段-解析" class="headerlink" title="23.6.8 连接阶段 - 解析"></a>23.6.8 连接阶段 - 解析</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121131741830.png" alt="image-20240121131741830"></p>
<h3 id="23-6-9-初始化-Initialization"><a href="#23-6-9-初始化-Initialization" class="headerlink" title="23.6.9 初始化 Initialization"></a>23.6.9 初始化 Initialization</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121132156139.png" alt="image-20240121132156139"></p>
<h2 id="23-7-通过反射获取类的结构信息"><a href="#23-7-通过反射获取类的结构信息" class="headerlink" title="23.7 通过反射获取类的结构信息"></a>23.7 通过反射获取类的结构信息</h2><h3 id="23-7-1-第一组-java-lang-Class-类"><a href="#23-7-1-第一组-java-lang-Class-类" class="headerlink" title="23.7.1 第一组: java.lang.Class 类"></a>23.7.1 第一组: java.lang.Class 类</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121144201063.png" alt="image-20240121144201063"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一组</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">api_01</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 得到 Class 对象</span></span><br><span class="line">    Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;com.durango.reflection.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getName:获取全类名</span></span><br><span class="line">    System.out.println(personCls.getName());<span class="comment">//com.durango.reflection.Person</span></span><br><span class="line">    <span class="comment">// getSimpleName:获取简单类名</span></span><br><span class="line">    System.out.println(personCls.getSimpleName());<span class="comment">//Person</span></span><br><span class="line">    <span class="comment">//getPackage:以 Package 形式返回 包信息</span></span><br><span class="line">    System.out.println(personCls.getPackage());<span class="comment">//com.durango.reflection</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getFields:获取所有 public 修饰的属性，包含本类以及父类的</span></span><br><span class="line">    Field[] fields = personCls.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;<span class="comment">//增强 for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;本类以及父类的属性=&quot;</span> + field.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">    Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getMethods:获取所有 public 修饰的方法，包含本类以及父类的</span></span><br><span class="line">    Method[] methods = personCls.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类以及父类的方法=&quot;</span> + method.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">    Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getConstructors: 获取所有 public 修饰的构造器，包含本类</span></span><br><span class="line">    Constructor&lt;?&gt;[] constructors = personCls.getConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类的构造器=&quot;</span> + constructor.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">    Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里老师只是输出名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getSuperClass:以 Class 形式返回父类信息</span></span><br><span class="line">    Class&lt;?&gt; superclass = personCls.getSuperclass();</span><br><span class="line">    System.out.println(<span class="string">&quot;父类的 class 对象=&quot;</span> + superclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getInterfaces:以 Class[]形式返回接口信息</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口信息=&quot;</span> + anInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getAnnotations:以 Annotation[] 形式返回注解信息</span></span><br><span class="line">    Annotation[] annotations = personCls.getAnnotations();</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注解信息=&quot;</span> + annotation);<span class="comment">//注解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="23-7-2-第二组-java-lang-reflect-Field-类"><a href="#23-7-2-第二组-java-lang-reflect-Field-类" class="headerlink" title="23.7.2 第二组: java.lang.reflect.Field 类"></a>23.7.2 第二组: java.lang.reflect.Field 类</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121144335991.png" alt="image-20240121144335991"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到 Class 对象</span></span><br><span class="line">Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;com.durango.reflection.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line"><span class="comment">//规定 说明: 默认修饰符 是 0 ， public 是 1 ，private 是 2 ，protected 是 4 , static 是 8 ，final 是 16</span></span><br><span class="line">Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName()</span><br><span class="line">                       + <span class="string">&quot; 该属性的修饰符值=&quot;</span> + declaredField.getModifiers()</span><br><span class="line">                       + <span class="string">&quot; 该属性的类型=&quot;</span> + declaredField.getType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="23-7-3-第三组-java-lang-reflect-Method-类"><a href="#23-7-3-第三组-java-lang-reflect-Method-类" class="headerlink" title="23.7.3 第三组: java.lang.reflect.Method 类"></a>23.7.3 第三组: java.lang.reflect.Method 类</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121144357121.png" alt="image-20240121144357121"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName()</span><br><span class="line">                       + <span class="string">&quot; 该方法的访问修饰符值=&quot;</span> + declaredMethod.getModifiers()</span><br><span class="line">                       + <span class="string">&quot; 该方法返回类型&quot;</span> + declaredMethod.getReturnType());</span><br><span class="line">    <span class="comment">//输出当前这个方法的形参数组情况</span></span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = declaredMethod.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;该方法的形参类型=&quot;</span> + parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="23-7-4-第四组-java-lang-reflect-Constructor-类"><a href="#23-7-4-第四组-java-lang-reflect-Constructor-类" class="headerlink" title="23.7.4 第四组: java.lang.reflect.Constructor 类"></a>23.7.4 第四组: java.lang.reflect.Constructor 类</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240121144435308.png" alt="image-20240121144435308"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = declaredConstructor.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;该构造器的形参类型=&quot;</span> + parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="23-8-通过反射创建对象"><a href="#23-8-通过反射创建对象" class="headerlink" title="23.8 通过反射创建对象"></a>23.8 通过反射创建对象</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240122115415198.png" alt="image-20240122115415198"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 先获取到 User 类的 Class 对象</span></span><br><span class="line">    Class&lt;?&gt; userClass = Class.forName(<span class="string">&quot;com.durango.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 通过 public 的无参构造器创建实例</span></span><br><span class="line">    Object o = userClass.newInstance();</span><br><span class="line">    System.out.println(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 通过 public 的有参构造器创建实例</span></span><br><span class="line">    <span class="comment">//  3.1 先得到对应构造器</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);</span><br><span class="line">    <span class="comment">//  3.2 创建实例，并传入实参</span></span><br><span class="line">    Object durango = constructor.newInstance(<span class="string">&quot;durango&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;durango = &quot;</span> + durango);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 通过非 public 的有参构造器创建实例</span></span><br><span class="line">    <span class="comment">//  4.1 得到 private 的构造器对象</span></span><br><span class="line">    Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">//  4.2 创建实例</span></span><br><span class="line">    constructor1.setAccessible(<span class="keyword">true</span>);<span class="comment">// 暴破, 使用反射可以访问 private 构造器/方法/属性</span></span><br><span class="line">    Object user2 = constructor1.newInstance(<span class="string">&quot;张三丰&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user2=&quot;</span> + user2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="23-9-通过反射访问类中的成员"><a href="#23-9-通过反射访问类中的成员" class="headerlink" title="23.9 通过反射访问类中的成员"></a>23.9 通过反射访问类中的成员</h2><h3 id="23-9-1-访问属性"><a href="#23-9-1-访问属性" class="headerlink" title="23.9.1 访问属性"></a>23.9.1 访问属性</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240122121055144.png" alt="image-20240122121055144"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 得到 Student 类对应的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; stuClass = Class.forName(<span class="string">&quot;com.durango.reflection.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 创建对象</span></span><br><span class="line">        Object o = stuClass.newInstance();<span class="comment">//o 的运行类型就是 Student</span></span><br><span class="line">        System.out.println(o.getClass());<span class="comment">//Student</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 使用反射得到 age 属性对象</span></span><br><span class="line">        Field age = stuClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.set(o, <span class="number">88</span>);<span class="comment">//通过反射来操作属性</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(age.get(o));<span class="comment">//返回 age 属性的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 使用反射操作 name 属性</span></span><br><span class="line">        Field name = stuClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//对 name 进行暴破, 可以操作 private 属性</span></span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//name.set(o, &quot;durango&quot;);</span></span><br><span class="line">        name.set(<span class="keyword">null</span>, <span class="string">&quot;durango~&quot;</span>);<span class="comment">//因为 name 是 static 属性，因此 o 也可以写出 null</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(name.get(o)); <span class="comment">//获取属性值</span></span><br><span class="line">        System.out.println(name.get(<span class="keyword">null</span>));<span class="comment">//获取属性值, 要求 name 是 static</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="23-9-2-访问方法"><a href="#23-9-2-访问方法" class="headerlink" title="23.9.2 访问方法"></a>23.9.2 访问方法</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240122121858946.png" alt="image-20240122121858946"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 得到 Boss 类对应的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; bossCls = Class.forName(<span class="string">&quot;com.durango.reflection.Boss&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 创建对象</span></span><br><span class="line">        Object o = bossCls.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 调用 public 的 hi 方法</span></span><br><span class="line">        <span class="comment">//Method hi = bossCls.getMethod(&quot;hi&quot;, String.class);//OK</span></span><br><span class="line">        <span class="comment">//3.1 得到 hi 方法对象</span></span><br><span class="line">        Method hi = bossCls.getDeclaredMethod(<span class="string">&quot;hi&quot;</span>, String.class);<span class="comment">//OK</span></span><br><span class="line">        <span class="comment">//3.2 调用</span></span><br><span class="line">        hi.invoke(o, <span class="string">&quot;韩顺平教育~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 调用 private static 方法</span></span><br><span class="line">        <span class="comment">//4.1 得到 say 方法对象</span></span><br><span class="line">        Method say = bossCls.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, <span class="keyword">int</span>.class, String.class, <span class="keyword">char</span>.class);</span><br><span class="line">        <span class="comment">//4.2 因为 say 方法是 private, 所以需要暴破，原理和前面讲的构造器和属性一样</span></span><br><span class="line">        say.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(say.invoke(o, <span class="number">100</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;男&#x27;</span>));</span><br><span class="line">        <span class="comment">//4.3 因为 say 方法是 static 的，还可以这样调用 ，可以传入 null</span></span><br><span class="line">        System.out.println(say.invoke(<span class="keyword">null</span>, <span class="number">200</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;女&#x27;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 在反射中，如果方法有返回值，统一返回 Object , 但是他运行类型和方法定义的返回类型一致</span></span><br><span class="line">        Object reVal = say.invoke(<span class="keyword">null</span>, <span class="number">300</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;reVal 的运行类型=&quot;</span> + reVal.getClass());<span class="comment">//String</span></span><br><span class="line">        <span class="comment">//在演示一个返回的案例</span></span><br><span class="line">        Method m1 = bossCls.getDeclaredMethod(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">        Object reVal2 = m1.invoke(o);</span><br><span class="line">        System.out.println(<span class="string">&quot;reVal2 的运行类型=&quot;</span> + reVal2.getClass());<span class="comment">//Monster</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="第二十四章-MySQL"><a href="#第二十四章-MySQL" class="headerlink" title="第二十四章  MySQL"></a>第二十四章  MySQL</h1><p>（略）<a href="https://www.durango.cn/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/">MySQL基础篇</a></p>
<h1 id="第二十五章-JDBC和连接池"><a href="#第二十五章-JDBC和连接池" class="headerlink" title="第二十五章 JDBC和连接池"></a>第二十五章 JDBC和连接池</h1><h2 id="25-1-JDBC概述"><a href="#25-1-JDBC概述" class="headerlink" title="25.1 JDBC概述"></a>25.1 JDBC概述</h2><h3 id="25-1-1-基本介绍"><a href="#25-1-1-基本介绍" class="headerlink" title="25.1.1 基本介绍"></a>25.1.1 基本介绍</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240124104024941.png" alt="image-20240124104024941"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240124104154409.png" alt="image-20240124104154409"></p>
<h3 id="25-1-2-JDBC-带来的好处"><a href="#25-1-2-JDBC-带来的好处" class="headerlink" title="25.1.2 JDBC 带来的好处"></a>25.1.2 JDBC 带来的好处</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240124105311887.png" alt="image-20240124105311887"></p>
<h3 id="25-1-3-JDBC-API"><a href="#25-1-3-JDBC-API" class="headerlink" title="25.1.3 JDBC API"></a>25.1.3 JDBC API</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240124105548191.png" alt="image-20240124105548191"></p>
<h2 id="25-2-JDBC快速入门"><a href="#25-2-JDBC快速入门" class="headerlink" title="25.2 JDBC快速入门"></a>25.2 JDBC快速入门</h2><h3 id="25-2-1-JDBC程序编写步骤"><a href="#25-2-1-JDBC程序编写步骤" class="headerlink" title="25.2.1 JDBC程序编写步骤"></a>25.2.1 JDBC程序编写步骤</h3><ol>
<li>注册驱动 - 加载Driver类</li>
<li>获取连接 - 得到Connection</li>
<li>执行增删改查 - 通过Statement</li>
<li>释放资源 - 关闭Statement和Connection</li>
</ol>
<h3 id="25-2-2-JDBC第一个程序"><a href="#25-2-2-JDBC第一个程序" class="headerlink" title="25.2.2 JDBC第一个程序"></a>25.2.2 JDBC第一个程序<img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240124112817723.png" alt="image-20240124112817723"></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.durango.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Connection;</span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Driver;</span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Statement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBC01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//前置工作： 在项目下创建一个文件夹比如 libs</span></span><br><span class="line">        <span class="comment">// 将 mysql.jar 拷贝到该目录下，点击 add to project ..加入到项目中</span></span><br><span class="line">        <span class="comment">// 1.注册驱动</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> Driver(); <span class="comment">//创建 driver 对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.得到连接</span></span><br><span class="line">        <span class="comment">//  (1) jdbc:mysql:// 规定好表示协议，通过 jdbc 的方式连接 mysql</span></span><br><span class="line">        <span class="comment">//  (2) localhost 主机，可以是 ip 地址</span></span><br><span class="line">        <span class="comment">//  (3) 3306 表示 mysql 监听的端口</span></span><br><span class="line">        <span class="comment">//  (4) db01 连接到 mysql dbms 的哪个数据库</span></span><br><span class="line">        <span class="comment">//  (5) ?characterEncoding=utf8 解决中文显示乱码问题</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/db01?characterEncoding=utf8&quot;</span>;</span><br><span class="line">        <span class="comment">//  将用户名和密码放入到 Properties 对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        Connection connection = (Connection) driver.connect(url, properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.执行sql语句</span></span><br><span class="line">        <span class="comment">//String sql = &quot;insert into actor values(null, &#x27;刘德华&#x27;, &#x27;男&#x27;, &#x27;1970-11-11&#x27;, &#x27;110&#x27;)&quot;;</span></span><br><span class="line">        <span class="comment">//String sql = &quot;update actor set name=&#x27;周星驰&#x27; where id = 1&quot;;</span></span><br><span class="line">        String sql = <span class="string">&quot;delete from actor where id = 1&quot;</span>;</span><br><span class="line">        <span class="comment">//statement 用于执行静态 SQL 语句并返回其生成的结果的对象</span></span><br><span class="line">        Statement statement = (Statement) connection.createStatement();</span><br><span class="line">        <span class="keyword">int</span> rows = statement.executeUpdate(sql); <span class="comment">// 如果是 DML 语句，返回的就是影响行数</span></span><br><span class="line">        System.out.println(rows &gt; <span class="number">0</span> ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭连接</span></span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="25-3-获取数据库连接-5-种方式"><a href="#25-3-获取数据库连接-5-种方式" class="headerlink" title="25.3 获取数据库连接 5 种方式"></a>25.3 获取数据库连接 5 种方式</h2><h3 id="25-3-1-方式一"><a href="#25-3-1-方式一" class="headerlink" title="25.3.1 方式一"></a>25.3.1 方式一</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240125102720128.png" alt="image-20240125102720128"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect01</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Driver driver = <span class="keyword">new</span> Driver(); <span class="comment">//创建driver对象 静态加载</span></span><br><span class="line"></span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">    <span class="comment">//将用户名和密码放入到 Properties 对象</span></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">// 用户</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>); <span class="comment">//密码</span></span><br><span class="line">    Connection connect = driver.connect(url, properties);</span><br><span class="line">    System.out.println(connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-3-2-方式二"><a href="#25-3-2-方式二" class="headerlink" title="25.3.2 方式二"></a>25.3.2 方式二</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240125103108015.png" alt="image-20240125103108015"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect02</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="comment">//使用反射加载 Driver 类 , 动态加载，更加的灵活，减少依赖性</span></span><br><span class="line">    Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    Driver driver = (Driver) aClass.newInstance();</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">    <span class="comment">//将用户名和密码放入到 Properties 对象</span></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">// 用户</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>); <span class="comment">//密码</span></span><br><span class="line"></span><br><span class="line">    Connection connect = driver.connect(url, properties);</span><br><span class="line">    System.out.println(<span class="string">&quot;方式 2=&quot;</span> + connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-3-3-方式三"><a href="#25-3-3-方式三" class="headerlink" title="25.3.3 方式三"></a>25.3.3 方式三</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240125103158622.png" alt="image-20240125103158622"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式 3 使用 DriverManager 替代 driver 进行统一管理</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect03</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//使用反射加载 Driver</span></span><br><span class="line">    Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    Driver driver = (Driver) aClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 url 和 user 和 password</span></span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">    String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    DriverManager.registerDriver(driver);<span class="comment">//注册 Driver 驱动</span></span><br><span class="line">    Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(<span class="string">&quot;第三种方式=&quot;</span> + connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-3-4-方式四"><a href="#25-3-4-方式四" class="headerlink" title="25.3.4 方式四"></a>25.3.4 方式四</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240125103359657.png" alt="image-20240125103359657"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式 4: 使用 Class.forName 自动完成注册驱动，简化代码</span></span><br><span class="line"><span class="comment">//这种方式获取连接是使用的最多，推荐使用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect04</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//使用反射加载了 Driver 类</span></span><br><span class="line">    <span class="comment">//在加载 Driver 类时，完成了注册</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 url 和 user 和 password</span></span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">    String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(<span class="string">&quot;第 4 种方式~ &quot;</span> + connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-3-5-方式-5"><a href="#25-3-5-方式-5" class="headerlink" title="25.3.5 方式 5"></a>25.3.5 方式 5</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240125103505378.png" alt="image-20240125103505378"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式 5 , 在方式 4 的基础上改进，增加配置文件，让连接 mysql 更加灵活</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect05</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取相关的值</span></span><br><span class="line">    String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line">    Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(<span class="string">&quot;方式 5 &quot;</span> + connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="25-4-ResultSet（结果集）"><a href="#25-4-ResultSet（结果集）" class="headerlink" title="25.4 ResultSet（结果集）"></a>25.4 ResultSet（结果集）</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240125103940095.png" alt="image-20240125103940095"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSet_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//获取相关的值</span></span><br><span class="line">        String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 得到连接</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 得到 Statement</span></span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 执行SQL语句</span></span><br><span class="line">        String sql = <span class="string">&quot;select id, name , sex, borndate from actor&quot;</span>;</span><br><span class="line">        <span class="comment">//执行给定的 SQL 语句，该语句返回单个 ResultSet 对象</span></span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 使用 while 取出数据</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123; <span class="comment">// 让光标向后移动，如果没有更多行，则返回 false</span></span><br><span class="line">            <span class="keyword">int</span> id = resultSet.getInt(<span class="number">1</span>); <span class="comment">//获取该行的第 1 列</span></span><br><span class="line">            <span class="comment">//int id1 = resultSet.getInt(&quot;id&quot;); 通过列名来获取值, 推荐</span></span><br><span class="line">            String name = resultSet.getString(<span class="number">2</span>);<span class="comment">//获取该行的第 2 列</span></span><br><span class="line">            String sex = resultSet.getString(<span class="number">3</span>);</span><br><span class="line">            Date date = resultSet.getDate(<span class="number">4</span>);</span><br><span class="line">            System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + sex + <span class="string">&quot;\t&quot;</span> + date);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="25-5-Statement"><a href="#25-5-Statement" class="headerlink" title="25.5 Statement"></a>25.5 Statement</h2><h3 id="25-5-1-基本介绍"><a href="#25-5-1-基本介绍" class="headerlink" title="25.5.1 基本介绍"></a>25.5.1 基本介绍</h3><ol>
<li>Statement对象 用于<strong>执行静态SQL语句并返回其生成的结果的对象</strong></li>
<li>在连接建立后，需要对数据库进行访问，执行命名或是SQL 语句，可以通过<ul>
<li>Statement 【存在SQL注入】</li>
<li>PreparedStatement【预处理】</li>
<li>CallableStatement 【存储过程】</li>
</ul>
</li>
<li>语句对象执行sql语句，存在<font color="red"><strong>sql注入</strong>风险</font></li>
<li>SQL 注入是 利用某些系统没有对用户输入的数据进行充分的检查，而在用户输数据中<strong>注入非法的 SQL 语句段或命令</strong>,恶意攻击数据库。</li>
<li>要防范 SQL 注入，只要用 PreparedStatement (从Statement扩展而来) 取代 Statement 就可以了</li>
</ol>
<h3 id="25-5-2-SQL注入案例"><a href="#25-5-2-SQL注入案例" class="headerlink" title="25.5.2 SQL注入案例"></a>25.5.2 SQL注入案例</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 演示 sql 注入</span></span><br><span class="line"><span class="comment">-- 创建一张表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> admin ( <span class="comment">-- 管理员表</span></span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>, pwd <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> admin <span class="keyword">VALUES</span>(<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;123&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找某个管理是否存在</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> admin</span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;tom&#x27;</span> <span class="keyword">AND</span> pwd <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- SQL注入</span></span><br><span class="line"><span class="comment">-- 输入用户名 为 1&#x27; or</span></span><br><span class="line"><span class="comment">-- 输入万能密码 为 or &#x27;1&#x27;= &#x27;1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> admin</span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">OR</span><span class="string">&#x27; AND pwd = &#x27;</span><span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="25-5-3-应用实例"><a href="#25-5-3-应用实例" class="headerlink" title="25.5.3 应用实例"></a>25.5.3 应用实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Statement_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//让用户输入管理员名(1&#x27; or)和密码 (or &#x27;1&#x27; = &#x27;1)</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入管理员的名字: &quot;</span>); <span class="comment">//next(): 当接收到 空格或者 &#x27;就是表示结束</span></span><br><span class="line">        String admin_name = scanner.nextLine(); <span class="comment">//如果希望看到 SQL 注入，这里需要用 nextLine</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入管理员的密码: &quot;</span>);</span><br><span class="line">        String admin_pwd = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//获取相关的值</span></span><br><span class="line">        String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line">        <span class="comment">//2. 得到连接</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="comment">//3. 得到 Statement</span></span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        <span class="comment">//4. 组织 SqL</span></span><br><span class="line">        String sql = <span class="string">&quot;select name , pwd from admin where name =&#x27;&quot;</span> + admin_name + <span class="string">&quot;&#x27; and pwd = &#x27;&quot;</span> + admin_pwd + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">if</span> (resultSet.next()) &#123; <span class="comment">//如果查询到一条记录，则说明该管理存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜， 登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="25-6-PreparedStatement"><a href="#25-6-PreparedStatement" class="headerlink" title="25.6 PreparedStatement"></a>25.6 PreparedStatement</h2><h3 id="25-6-1-基本介绍"><a href="#25-6-1-基本介绍" class="headerlink" title="25.6.1 基本介绍"></a>25.6.1 基本介绍</h3><ol>
<li>PreparedStatement 执行的 SQL 语句中的<strong>参数用问号(?)来表示</strong>，调用<br>PreparedStatement 对象的 <strong>setXxx()方法</strong>来设置这些参数setXxx() 方法有<br>两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</li>
<li>调用 executeQuery()，返回 ResultSet 对象</li>
<li>调用 executeUpdate0()， 执行更新，包括增、删、修改</li>
</ol>
<h3 id="25-6-2-预处理好处"><a href="#25-6-2-预处理好处" class="headerlink" title="25.6.2 预处理好处"></a>25.6.2 预处理好处</h3><ol>
<li>不再使用+ 拼接sql语句，减少语法错误</li>
<li>有效的解决了**<font color="red">sql注入问题</font>**!</li>
<li>大大减少了编译次数，效率较高</li>
</ol>
<h3 id="25-6-3-应用案例"><a href="#25-6-3-应用案例" class="headerlink" title="25.6.3 应用案例"></a>25.6.3 应用案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatement_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//让用户输入管理员名和密码</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入管理员的名字: &quot;</span>); <span class="comment">//next(): 当接收到 空格或者 &#x27;就是表示结束</span></span><br><span class="line">        String admin_name = scanner.nextLine(); <span class="comment">//如果希望看到 SQL 注入，这里需要用 nextLine</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入管理员的密码: &quot;</span>);</span><br><span class="line">        String admin_pwd = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//获取相关的值</span></span><br><span class="line">        String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line">        <span class="comment">//2. 得到连接</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 得到 PreparedStatement</span></span><br><span class="line">        <span class="comment">// 3.1 组织 SqL , Sql 语句的 ? 就相当于占位符</span></span><br><span class="line">        String sql = <span class="string">&quot;select name , pwd from admin where name =? and pwd = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象</span></span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">// 3.3 给 ? 赋值</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, admin_name);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, admin_pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 执行 select 语句使用 executeQuery</span></span><br><span class="line">        <span class="comment">// 如果执行的是 dml(update, insert ,delete)语句 使用executeUpdate()</span></span><br><span class="line">        <span class="comment">// 这里执行 executeQuery ,不要在写 sql</span></span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resultSet.next()) &#123; <span class="comment">//如果查询到一条记录，则说明该管理存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜， 登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-7-JDBC-的相关-API-小结"><a href="#25-7-JDBC-的相关-API-小结" class="headerlink" title="25.7 JDBC 的相关 API 小结"></a>25.7 JDBC 的相关 API 小结</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240126145750445.png" alt="image-20240126145750445"></p>
<h2 id="25-8-封装-JDBCUtils工具类"><a href="#25-8-封装-JDBCUtils工具类" class="headerlink" title="25.8 封装 JDBCUtils工具类"></a>25.8 封装 JDBCUtils工具类</h2><ul>
<li>在jdbc操作中，获取连接和释放资源是经常使用到可以将其封装jdbc连接的工具类JDBCUtils</li>
</ul>
<h3 id="25-8-1-JDBCUtils工具类"><a href="#25-8-1-JDBCUtils工具类" class="headerlink" title="25.8.1 JDBCUtils工具类"></a>25.8.1 JDBCUtils工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义相关的属性(4 个), 因为只需要一份，因此，我们做出 static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password; <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url; <span class="comment">//url</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver; <span class="comment">//驱动名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 static 代码块去初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">            <span class="comment">//读取相关的属性值</span></span><br><span class="line">            user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//在实际开发中，我们可以这样处理</span></span><br><span class="line">            <span class="comment">//1. 将 编译异常 转成 运行异常</span></span><br><span class="line">            <span class="comment">//2. 调用者，可以选择捕获该异常，也可以选择默认处理该异常，比较方便. throw new RuntimeException(e);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接数据库, 返回 Connection</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//1. 将编译异常转成 运行异常</span></span><br><span class="line">            <span class="comment">//2. 调用者，可以选择捕获该异常，也可以选择默认处理该异常，比较方便.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭相关资源</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ResultSet 结果集</span></span><br><span class="line"><span class="comment">    2. Statement 或者 PreparedStatement</span></span><br><span class="line"><span class="comment">    3. Connection</span></span><br><span class="line"><span class="comment">    4. 如果需要关闭资源，就传入对象，否则传入 null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet set, Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为 null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (set != <span class="keyword">null</span>) &#123;</span><br><span class="line">                set.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转成运行异常抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-8-1-JDBCUtils工具类使用"><a href="#25-8-1-JDBCUtils工具类使用" class="headerlink" title="25.8.1 JDBCUtils工具类使用"></a>25.8.1 JDBCUtils工具类使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils_Use</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        String sql = <span class="string">&quot;select * from actor where id = ?&quot;</span>;</span><br><span class="line">        PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet set = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.得到连接</span></span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            System.out.println(connection.getClass());</span><br><span class="line">            <span class="comment">// 2.创建PreparedStatement对象</span></span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            <span class="comment">// 3. 给？赋值</span></span><br><span class="line">            preparedStatement.setInt(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">            <span class="comment">// 4. 执行sql</span></span><br><span class="line">            set = preparedStatement.executeQuery();</span><br><span class="line">            <span class="comment">// 5. 遍历结果集</span></span><br><span class="line">            <span class="keyword">while</span> (set.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = set.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String name = set.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String sex = set.getString(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">                Date borndate = set.getDate(<span class="string">&quot;borndate&quot;</span>);</span><br><span class="line">                String phone = set.getString(<span class="string">&quot;phone&quot;</span>);</span><br><span class="line">                System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + sex + <span class="string">&quot;\t&quot;</span> + borndate + <span class="string">&quot;\t&quot;</span> + phone);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 关闭资源</span></span><br><span class="line">            JDBCUtils.close(set, preparedStatement, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDML</span><span class="params">()</span> </span>&#123;<span class="comment">//insert , update, delete</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        String sql = <span class="string">&quot;update actor set name = ? where id = ?&quot;</span>;</span><br><span class="line">        PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//给占位符赋值</span></span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;周星驰&quot;</span>);</span><br><span class="line">            preparedStatement.setInt(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            preparedStatement.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            JDBCUtils.close(<span class="keyword">null</span>, preparedStatement, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="25-9-事务"><a href="#25-9-事务" class="headerlink" title="25.9 事务"></a>25.9 事务</h2><h3 id="25-9-1-基本介绍"><a href="#25-9-1-基本介绍" class="headerlink" title="25.9.1 基本介绍"></a>25.9.1 基本介绍</h3><ol>
<li>JDBC程序中当一个Connection对象创建时，<strong>默认情况下是自动提交事务</strong>:每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚</li>
<li>JDBC程序中为了让多个 SQL 语句作为一个整体执行，需要<strong>使用事务</strong></li>
<li>调用 Connection 的 **<font color="red">setAutoCommit(false)</font>**可以取消自动提交事务(开启事务)</li>
<li>在所有的 SQL 语句都成功执行后，调用 Connection 的 <strong><font color="red">commit()</font></strong> 方法提交事务</li>
<li>在其中某个操作失败或出现异常时，调用 Connection 的 <strong><font color="red">rollback()</font></strong> 方法回滚事务</li>
</ol>
<h3 id="25-9-2-应用案例"><a href="#25-9-2-应用案例" class="headerlink" title="25.9.2 应用案例"></a>25.9.2 应用案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction_</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟经典的转账业务</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//操作转账的业务</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        String sql = <span class="string">&quot;update account set balance = balance - 100 where name = ?&quot;</span>;</span><br><span class="line">        String sql2 = <span class="string">&quot;update account set balance = balance + 100 where name = ?&quot;</span>;</span><br><span class="line">        PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection(); <span class="comment">// 在默认情况下，connection 是默认自动提交</span></span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;马化腾&quot;</span>);</span><br><span class="line">            preparedStatement.executeUpdate(); <span class="comment">// 执行第 1 条 sql</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>; <span class="comment">//抛出异常(下面两行代码不会执行)</span></span><br><span class="line">            preparedStatement = connection.prepareStatement(sql2);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;马云&quot;</span>);</span><br><span class="line">            preparedStatement.executeUpdate(); <span class="comment">// 执行第 2 条 sql</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            JDBCUtils.close(<span class="keyword">null</span>, preparedStatement, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务来解决</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//操作转账的业务</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        String sql = <span class="string">&quot;update account set balance = balance - 100 where id = 1&quot;</span>;</span><br><span class="line">        String sql2 = <span class="string">&quot;update account set balance = balance + 100 where id = 2&quot;</span>;</span><br><span class="line">        PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection(); <span class="comment">// 在默认情况下，connection 是默认自动提交</span></span><br><span class="line">            <span class="comment">//将 connection 设置为不自动提交</span></span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>); <span class="comment">//开启了事务</span></span><br><span class="line"></span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.executeUpdate(); <span class="comment">// 执行第 1 条 sql</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>; <span class="comment">//抛出异常</span></span><br><span class="line">            preparedStatement = connection.prepareStatement(sql2);</span><br><span class="line">            preparedStatement.executeUpdate(); <span class="comment">// 执行第 2 条 sql</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里提交事务</span></span><br><span class="line">            connection.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//这里我们可以进行回滚，即撤销执行的 SQL</span></span><br><span class="line">            <span class="comment">//默认回滚到事务开始的状态.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;执行发生了异常，撤销已经执行的 sql&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            JDBCUtils.close(<span class="keyword">null</span>, preparedStatement, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="25-10-批处理"><a href="#25-10-批处理" class="headerlink" title="25.10 批处理"></a>25.10 批处理</h2><h3 id="25-10-1-基本介绍"><a href="#25-10-1-基本介绍" class="headerlink" title="25.10.1 基本介绍"></a>25.10.1 基本介绍</h3><ol>
<li>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理<strong>效率更高</strong></li>
<li>JDBC的批量处理语句包括下面方法:<ul>
<li>**<font color="red">addBatch()</font>**：添加需要批量处理的SQL语句或参数</li>
<li>**<font color="red">executeBatch()</font>**：执行批量处理语句:</li>
<li>**<font color="red">clearBatch()</font>**：清空批处理包的语句</li>
</ul>
</li>
<li>JDBC连接MySQL时，如果要使用批处理功能，请再<strong>url中加参数<font color="red">?rewriteBatchedStatements=true</font></strong></li>
<li>批处理往往和PreparedStatement一起搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高</li>
</ol>
<h3 id="25-10-2-应用案例"><a href="#25-10-2-应用案例" class="headerlink" title="25.10.2 应用案例"></a>25.10.2 应用案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Batch</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传统方法，添加 5000 条数据到 admin</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql = <span class="string">&quot;insert into admin2 values(null, ?, ?)&quot;</span>;</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();<span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;<span class="comment">//5000 执行</span></span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;jack&quot;</span> + i);</span><br><span class="line">            preparedStatement.setString(<span class="number">2</span>, <span class="string">&quot;666&quot;</span>);</span><br><span class="line">            preparedStatement.executeUpdate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;传统的方式 耗时=&quot;</span> + (end - start));<span class="comment">//传统的方式 耗时=2805</span></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        JDBCUtils.close(<span class="keyword">null</span>, preparedStatement, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用批量方式添加数据</span></span><br><span class="line">    <span class="comment">//批量处理会减少我们发送 sql 语句的网络开销，而且减少编译次数，因此效率提高</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql = <span class="string">&quot;insert into admin2 values(null, ?, ?)&quot;</span>;</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();<span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;<span class="comment">//5000 执行</span></span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;jack&quot;</span> + i);</span><br><span class="line">            preparedStatement.setString(<span class="number">2</span>, <span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">            preparedStatement.addBatch(); <span class="comment">//添加</span></span><br><span class="line">            <span class="comment">//当有 1000 条记录时，在批量执行</span></span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">1000</span> == <span class="number">0</span>) &#123;<span class="comment">//满 1000 条 sql</span></span><br><span class="line">                preparedStatement.executeBatch(); <span class="comment">//执行批处理</span></span><br><span class="line">                preparedStatement.clearBatch(); <span class="comment">//清空</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;批量方式 耗时=&quot;</span> + (end - start));<span class="comment">//批量方式 耗时=65</span></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        JDBCUtils.close(<span class="keyword">null</span>, preparedStatement, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="25-11数据库连接池"><a href="#25-11数据库连接池" class="headerlink" title="25.11数据库连接池"></a>25.11数据库连接池</h2><h3 id="25-11-1-5k-次连接数据库"><a href="#25-11-1-5k-次连接数据库" class="headerlink" title="25.11.1 5k 次连接数据库"></a>25.11.1 5k 次连接数据库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConQuestion</span> </span>&#123;</span><br><span class="line">    <span class="comment">//代码 连接 mysql 5000 次</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//看看连接-关闭 connection 会耗用多久</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始连接.....&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//使用传统的 jdbc 方式，得到连接</span></span><br><span class="line">            Connection connection = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//做一些工作，比如得到 PreparedStatement ，发送 sql</span></span><br><span class="line">            <span class="comment">//.......... //关闭</span></span><br><span class="line">            JDBCUtils.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;传统方式 5000 次 耗时=&quot;</span> + (end - start));<span class="comment">//传统方式 5000 次 耗时=6684</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-11-2-传统获取-Connection-问题分析"><a href="#25-11-2-传统获取-Connection-问题分析" class="headerlink" title="25.11.2 传统获取 Connection 问题分析"></a>25.11.2 传统获取 Connection 问题分析</h3><ol>
<li><p>传统的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中再<strong>验证IP地址，用户名和密码</strong>(0.05s~1s时间)。需要数据库连接的时候，就向数据库要求一个，频</p>
<p>繁的进行数据库连接操作将<strong>占用很多的系统资源容易造成服务器崩溃</strong>。</p>
</li>
<li><p>每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库<strong>内存泄漏</strong>，最终将导致重启数据库</p>
</li>
<li><p>传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，MySQL崩溃。</p>
</li>
<li><p>解决传统开发中的数据库连接问题，可以采用<strong>数据库连接池技术</strong>(connection pool)</p>
</li>
</ol>
<h3 id="25-11-3-数据库连接池种类"><a href="#25-11-3-数据库连接池种类" class="headerlink" title="25.11.3 数据库连接池种类"></a>25.11.3 数据库连接池种类</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240128214046525.png" alt="image-20240128214046525"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240128214424546.png" alt="image-20240128214424546"></p>
<ol>
<li>JDBC 的数据库连接池使用 javax.sgl.<strong>DataSource</strong> 来表示，DataSource只是一个接口，该接口通常由第三方提供实现[提供 .jar]</li>
<li><strong><font color="red">C3PO</font></strong> 数据库连接池，速度相对较慢，稳定性不错 (hibernate,spring)</li>
<li><strong><font color="red">DBCP</font></strong> 数据库连接池，速度相对c3p0较快，但不稳定</li>
<li><strong><font color="red">Proxool</font></strong> 数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点</li>
<li><strong><font color="red">BoneCP</font></strong> 数据库连接池，速度快</li>
<li><strong><font color="red">Druid</font></strong>(德鲁伊)是阿里提供的数据库连接池，集DBCP 、C3PO 、Proxoo优点于一身的数据库连接池</li>
</ol>
<h3 id="25-11-4-C3P0-应用实例"><a href="#25-11-4-C3P0-应用实例" class="headerlink" title="25.11.4 C3P0 应用实例"></a>25.11.4 C3P0 应用实例</h3><ul>
<li>方式一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式 1： 相关参数，在程序中指定 user, url , password 等</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testC3P0_01</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1. 创建一个数据源对象</span></span><br><span class="line">    ComboPooledDataSource comboPooledDataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 通过配置文件 mysql.properties 获取相关连接的信息</span></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">    <span class="comment">//读取相关的属性值</span></span><br><span class="line">    String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    String driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 给数据源 comboPooledDataSource 设置相关的参数</span></span><br><span class="line">    <span class="comment">//注意：连接管理是由 comboPooledDataSource 来管理</span></span><br><span class="line">    comboPooledDataSource.setDriverClass(driver);</span><br><span class="line">    comboPooledDataSource.setJdbcUrl(url);</span><br><span class="line">    comboPooledDataSource.setUser(user);</span><br><span class="line">    comboPooledDataSource.setPassword(password);</span><br><span class="line">    <span class="comment">//设置初始化连接数</span></span><br><span class="line">    comboPooledDataSource.setInitialPoolSize(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//最大连接数</span></span><br><span class="line">    comboPooledDataSource.setMaxPoolSize(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 测试连接池的效率, 测试对 mysql 5000 次操作</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">        Connection connection = comboPooledDataSource.getConnection(); <span class="comment">//这个方法就是从 DataSource 接口实现的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接 OK&quot;</span>);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//c3p0 5000 连接 mysql 耗时=318</span></span><br><span class="line">    System.out.println(<span class="string">&quot;c3p0 5000 连接 mysql 耗时=&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方式二</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种方式 使用配置文件模板来完成</span></span><br><span class="line"><span class="comment">//1. 将 c3p0 提供的 c3p0.config.xml 拷贝到 src 目录下</span></span><br><span class="line"><span class="comment">//2. 该文件指定了连接数据库和连接池的相关参数</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testC3P0_02</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ComboPooledDataSource comboPooledDataSource = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">&quot;durango&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试 5000 次连接 mysql</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;开始执行....&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">        Connection connection = comboPooledDataSource.getConnection();</span><br><span class="line">        System.out.println(<span class="string">&quot;连接 OK~&quot;</span>);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//c3p0 的第二种方式 耗时=413</span></span><br><span class="line">    System.out.println(<span class="string">&quot;c3p0 的第二种方式(500000) 耗时=&quot;</span> + (end - start));<span class="comment">//3371</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件 c3p0.config.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据源名称 代表连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;durango&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- url--&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://127.0.0.1:3306/db01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用户名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 密码 --&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- 每次增长的连接数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 初始的连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最小连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 最大连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 可连接的最多的命令对象数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每个连接对象可连接的最多的命令对象数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="25-11-5-Druid-德鲁伊-应用实例"><a href="#25-11-5-Druid-德鲁伊-应用实例" class="headerlink" title="25.11.5 Druid(德鲁伊) 应用实例"></a>25.11.5 Druid(德鲁伊) 应用实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Durid_</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDruid</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1. 加入 Druid jar 包</span></span><br><span class="line">        <span class="comment">//2. 加入 配置文件 druid.properties , 将该文件拷贝项目的 src 目录</span></span><br><span class="line">        <span class="comment">//3. 创建 Properties 对象, 读取配置文件</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//4. 创建一个指定参数的数据库连接池, Druid 连接池</span></span><br><span class="line">        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            Connection connection = dataSource.getConnection();</span><br><span class="line">            System.out.println(connection.getClass());</span><br><span class="line">            <span class="comment">//System.out.println(&quot;连接成功!&quot;);</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//druid 连接池 操作 5000 耗时=2333</span></span><br><span class="line">        System.out.println(<span class="string">&quot;druid 连接池 操作 500000 耗时=&quot;</span> + (end - start));<span class="comment">//539</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-11-6-将-JDBCUtils-工具类改成-Druid-德鲁伊-实现"><a href="#25-11-6-将-JDBCUtils-工具类改成-Druid-德鲁伊-实现" class="headerlink" title="25.11.6 将 JDBCUtils 工具类改成 Druid(德鲁伊)实现"></a>25.11.6 将 JDBCUtils 工具类改成 Druid(德鲁伊)实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtilsByDruid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在静态代码块完成 ds 初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写 getConnection 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭连接, 在数据库连接池技术中，close 不是真的断掉连接</span></span><br><span class="line">    <span class="comment">//而是把使用的 Connection 对象放回连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet resultSet, Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="25-12-Apache—DBUtils"><a href="#25-12-Apache—DBUtils" class="headerlink" title="25.12 Apache—DBUtils"></a>25.12 Apache—DBUtils</h2><h3 id="25-12-1-先分析一个问题"><a href="#25-12-1-先分析一个问题" class="headerlink" title="25.12.1 先分析一个问题"></a>25.12.1 先分析一个问题</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240201101600286.png" alt="image-20240201101600286"></p>
<h3 id="25-12-2-用自己的土方法来解决"><a href="#25-12-2-用自己的土方法来解决" class="headerlink" title="25.12.2 用自己的土方法来解决"></a>25.12.2 用自己的土方法来解决</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用老师的土方法来解决 ResultSet =封装=&gt; Arraylist</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Actor&gt; <span class="title">testSelectToArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;使用 druid 方式完成&quot;</span>);</span><br><span class="line">    <span class="comment">//1. 得到连接</span></span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//2. 组织一个 sql</span></span><br><span class="line">    String sql = <span class="string">&quot;select * from actor where id &gt;= ?&quot;</span>;</span><br><span class="line">    PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet set = <span class="keyword">null</span>;</span><br><span class="line">    ArrayList&lt;Actor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//创建 ArrayList 对象,存放 actor 对象</span></span><br><span class="line">    <span class="comment">//3. 创建 PreparedStatement 对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">        System.out.println(connection.getClass());<span class="comment">//运行类com.alibaba.druid.pool.DruidPooledConnection</span></span><br><span class="line">        preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        preparedStatement.setInt(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//给?号赋值</span></span><br><span class="line">        <span class="comment">//执行, 得到结果集</span></span><br><span class="line">        set = preparedStatement.executeQuery();</span><br><span class="line">        <span class="comment">//遍历该结果集</span></span><br><span class="line">        <span class="keyword">while</span> (set.next()) &#123;</span><br><span class="line">			<span class="keyword">int</span> id = set.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">   			String name = set.getString(<span class="string">&quot;name&quot;</span>);<span class="comment">//getName()</span></span><br><span class="line">            String sex = set.getString(<span class="string">&quot;sex&quot;</span>);<span class="comment">//getSex()</span></span><br><span class="line">            Date borndate = set.getDate(<span class="string">&quot;borndate&quot;</span>);</span><br><span class="line">            String phone = set.getString(<span class="string">&quot;phone&quot;</span>);</span><br><span class="line">            <span class="comment">//把得到的 resultset 的记录，封装到 Actor 对象，放入到 list 集合</span></span><br><span class="line">            list.add(<span class="keyword">new</span> Actor(id, name, sex, borndate, phone));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;list 集合数据=&quot;</span> + list);</span><br><span class="line">        <span class="keyword">for</span>(Actor actor : list) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id=&quot;</span> + actor.getId() + <span class="string">&quot;\t&quot;</span> + actor.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        JDBCUtilsByDruid.close(set, preparedStatement, connection);</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="comment">//因为 ArrayList 和 connection 没有任何关联，所以该集合可以复用. </span></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-12-3-基本介绍"><a href="#25-12-3-基本介绍" class="headerlink" title="25.12.3 基本介绍"></a>25.12.3 基本介绍</h3><ol>
<li><p><strong>commons-dbutils</strong> 是 Apache 组织提供的-一个开源JDBC工具类库，它是对JDBC的封装使用dbutils能极大简化jdbc编码的工作量。</p>
</li>
<li><p><strong>DbUtils</strong>类</p>
</li>
<li><p>**<font color="red">QueryRunner</font>**类: 该类封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理</p>
</li>
<li><p><strong>ResultSetHandler</strong>接口: 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式，有如下几种：</p>
<p>​    <img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240201102308514.png" alt="image-20240201102308514"></p>
</li>
</ol>
<h3 id="25-12-4-应用实例"><a href="#25-12-4-应用实例" class="headerlink" title="25.12.4 应用实例"></a>25.12.4 应用实例</h3><p>query()方法源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement stmt = <span class="keyword">null</span>; <span class="comment">//定义 PreparedStatement</span></span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>; <span class="comment">//接收返回的 ResultSet</span></span><br><span class="line">    T result = <span class="keyword">null</span>; <span class="comment">//返回 ArrayList</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt = <span class="keyword">this</span>.prepareStatement(conn, sql); <span class="comment">//创建 PreparedStatement</span></span><br><span class="line">        <span class="keyword">this</span>.fillStatement(stmt, params); ;<span class="comment">//对 sql 进行 ? 赋值</span></span><br><span class="line">        rs = <span class="keyword">this</span>.wrap(stmt.executeQuery()); ;<span class="comment">//执行 sql,返回 resultset</span></span><br><span class="line">        result = rsh.handle(rs); <span class="comment">//返回的 resultset --&gt; arrayList[result] [使用到反射，对传入 class 对象</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var33) &#123;</span><br><span class="line">        <span class="keyword">this</span>.rethrow(var33, sql, params);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.close(rs); ;<span class="comment">//关闭 resultset</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.close((Statement)stmt); <span class="comment">//关闭 preparedstatement 对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>apache-DBUtils 工具类 + druid 完成对表的查询操作</p>
<ul>
<li>返回结果是多行数据的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryMany</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.用druid方式得到连接</span></span><br><span class="line">    Connection connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">    <span class="comment">// 2.使用 DBUtilsl 类和接口， 先引入DBUtils相关的jar</span></span><br><span class="line">    <span class="comment">// 3.创建 QueryRunner</span></span><br><span class="line">    QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">    <span class="comment">// 4. 执行相关的方法，返回ArrayList结果集</span></span><br><span class="line">    String sql = <span class="string">&quot;select * from actor where id &gt;= ?&quot;</span>;</span><br><span class="line">    <span class="comment">// (1) query 方法就是执行 sql 语句，得到 resultset ---封装到 --&gt; ArrayList 集合中</span></span><br><span class="line">    <span class="comment">// (2) list: 返回集合</span></span><br><span class="line">    <span class="comment">// (3) connection: 连接</span></span><br><span class="line">    <span class="comment">// (4) sql : 执行的 sql 语句</span></span><br><span class="line">    <span class="comment">// (5) new BeanListHandler&lt;&gt;(Actor.class): 在将 resultset -&gt; Actor 对象 -&gt; 封装到 ArrayList</span></span><br><span class="line">    <span class="comment">//      底层使用反射机制 去获取 Actor 类的属性，然后进行封装</span></span><br><span class="line">    <span class="comment">// (6) 1 就是给 sql 语句中的 ? 赋值，可以有多个值，因为是可变参数 Object... params</span></span><br><span class="line">    <span class="comment">// (7) 底层得到的 resultset,会在query中关闭, 还会关闭 PreparedStatment</span></span><br><span class="line">    List&lt;Actor&gt; list = queryRunner.query(connection, sql, <span class="keyword">new</span> BeanListHandler&lt;&gt;(Actor.class), <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;输出集合信息&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Actor actor : list) &#123;</span><br><span class="line">        System.out.println(actor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回结果是单行数据的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuerySingle</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.用druid方式得到连接</span></span><br><span class="line">    Connection connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">    <span class="comment">// 2.使用 DBUtilsl 类和接口， 先引入DBUtils相关的jar</span></span><br><span class="line">    <span class="comment">// 3.创建 QueryRunner</span></span><br><span class="line">    QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">    <span class="comment">// 4. 执行相关的方法，返回单个对象</span></span><br><span class="line">    String sql = <span class="string">&quot;select * from actor where id = ?&quot;</span>;</span><br><span class="line">    Actor actor = queryRunner.query(connection, sql, <span class="keyword">new</span> BeanHandler&lt;&gt;(Actor.class), <span class="number">4</span>);</span><br><span class="line">    System.out.println(actor);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询结果是单行单列-返回的就是 object</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testScalar</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.用druid方式得到连接</span></span><br><span class="line">    Connection connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">    <span class="comment">// 2.使用 DBUtilsl 类和接口， 先引入DBUtils相关的jar</span></span><br><span class="line">    <span class="comment">// 3.创建 QueryRunner</span></span><br><span class="line">    QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">    <span class="comment">// 4. 就可以执行相关的方法，返回单行单列 , 返回的就是 Object</span></span><br><span class="line">    String sql = <span class="string">&quot;select name from actor where id = ?&quot;</span>;</span><br><span class="line">    <span class="comment">//因为返回的是一个对象, 使用的 handler 就是 ScalarHandler</span></span><br><span class="line">    Object obj = queryRunner.query(connection, sql, <span class="keyword">new</span> ScalarHandler(), <span class="number">4</span>);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>使用apache-dbutils + druid 完成 dml (update, insert ,delete)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDML</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.用druid方式得到连接</span></span><br><span class="line">    Connection connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">    <span class="comment">// 2.使用 DBUtilsl 类和接口， 先引入DBUtils相关的jar</span></span><br><span class="line">    <span class="comment">// 3.创建 QueryRunner</span></span><br><span class="line">    QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">    <span class="comment">//4. 这里组织 sql 完成 update, insert delete</span></span><br><span class="line">    <span class="comment">//String sql = &quot;update actor set name = ? where id = ?&quot;;</span></span><br><span class="line">    <span class="comment">//String sql = &quot;insert into actor values(null, ?, ?, ?, ?)&quot;;</span></span><br><span class="line">    String sql = <span class="string">&quot;delete from actor where id = ?&quot;</span>;</span><br><span class="line">    <span class="comment">// (1) 执行 dml 操作是 queryRunner.update()</span></span><br><span class="line">    <span class="comment">// (2) 返回的值是受影响的行数 (affected: 受影响)</span></span><br><span class="line">    <span class="comment">//int affectedRow = queryRunner.update(connection, sql, &quot;林青霞&quot;, &quot;女&quot;, &quot;1966-10-10&quot;, &quot;116&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> affectedRow = queryRunner.update(connection, sql, <span class="number">1000</span> );</span><br><span class="line">    System.out.println(affectedRow &gt; <span class="number">0</span> ? <span class="string">&quot;执行成功&quot;</span> : <span class="string">&quot;执行没有影响到表&quot;</span>);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="25-12-5-表和-JavaBean-的类型映射关系"><a href="#25-12-5-表和-JavaBean-的类型映射关系" class="headerlink" title="25.12.5 表和 JavaBean 的类型映射关系"></a>25.12.5 表和 JavaBean 的类型映射关系</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240201111944056.png" alt="image-20240201111944056"></p>
<h2 id="25-13-DAO-和增删改查通用方法-BasicDao"><a href="#25-13-DAO-和增删改查通用方法-BasicDao" class="headerlink" title="25.13 DAO 和增删改查通用方法-BasicDao"></a>25.13 DAO 和增删改查通用方法-BasicDao</h2><h3 id="25-13-1-先分析一个问题"><a href="#25-13-1-先分析一个问题" class="headerlink" title="25.13.1 先分析一个问题"></a>25.13.1 先分析一个问题</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240203215133282.png" alt="image-20240203215133282"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240203215636053.png" alt="image-20240203215636053"></p>
<h3 id="25-13-2-基本说明"><a href="#25-13-2-基本说明" class="headerlink" title="25.13.2 基本说明"></a>25.13.2 基本说明</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240203220023888.png" alt="image-20240203220023888"></p>
<h3 id="25-13-3-BasicDAO-应用实例"><a href="#25-13-3-BasicDAO-应用实例" class="headerlink" title="25.13.3 BasicDAO 应用实例"></a>25.13.3 BasicDAO 应用实例</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240203220057648.png" alt="image-20240203220057648"></p>
<img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240203223232503.png" alt="image-20240203223232503" style="zoom:50%;">

<ul>
<li><p>JDBCUtilsByDruid.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtilsByDruid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在静态代码块完成 ds 初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写 getConnection 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭连接, 在数据库连接池技术中，close 不是真的断掉连接</span></span><br><span class="line">    <span class="comment">//而是把使用的 Connection 对象放回连接池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet resultSet, Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Actor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Actor</span> </span>&#123; <span class="comment">//Javabean, POJO, Domain对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Date borndate;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Actor</span><span class="params">()</span> </span>&#123; <span class="comment">//一定要给一个无参构造器[反射需要]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Actor</span><span class="params">(Integer id, String name, String sex, Date borndate, String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.borndate = borndate;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBorndate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> borndate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorndate</span><span class="params">(Date borndate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.borndate = borndate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\nActor&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, borndate=&quot;</span> + borndate +</span><br><span class="line">                <span class="string">&quot;, phone=&#x27;&quot;</span> + phone + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>BasicDAO.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicDAO</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">//泛型指定具体类型</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner qr = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开发通用的 dml 方法, 针对任意的表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql, Object... parameters)</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">int</span> update = qr.update(connection, sql, parameters);</span><br><span class="line">            <span class="keyword">return</span> update;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回多个对象(即查询的结果是多行), 针对任意表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql        sql 语句，可以有 ?</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz      传入一个类的 Class 对象 比如 Actor.class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameters 传入 ? 的具体的值，可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 根据 Actor.class 返回对应的 ArrayList 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">queryMulti</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单行结果 的通用方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">querySingle</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单行单列的方法,即返回单值的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">queryScalar</span><span class="params">(String sql, Object... parameters)</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> ScalarHandler(), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="keyword">null</span>, <span class="keyword">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>ActorDAO.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActorDAO</span> <span class="keyword">extends</span> <span class="title">BasicDAO</span>&lt;<span class="title">Actor</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1. 包含 BasicDAO 的方法</span></span><br><span class="line">    <span class="comment">//2. 根据业务需求，可以编写特有的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TestDAO.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试 ActorDAO 对 actor 表 crud 操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testActorDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActorDAO actorDAO = <span class="keyword">new</span> ActorDAO();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 查询多行记录</span></span><br><span class="line">        List&lt;Actor&gt; actors = actorDAO.queryMulti(<span class="string">&quot;select * from actor where id &gt;= ?&quot;</span>, Actor.class, <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===查询结果===&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Actor actor : actors) &#123;</span><br><span class="line">            System.out.println(actor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 查询单行记录</span></span><br><span class="line">        Actor actor = actorDAO.querySingle(<span class="string">&quot;select * from actor where id = ?&quot;</span>, Actor.class, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====查询单行结果====&quot;</span>);</span><br><span class="line">        System.out.println(actor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 查询单行单列</span></span><br><span class="line">        Object o = actorDAO.queryScalar(<span class="string">&quot;select name from actor where id = ?&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====查询单行单列值===&quot;</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. dml 操作 insert ,update, delete</span></span><br><span class="line">        <span class="keyword">int</span> update = actorDAO.update(<span class="string">&quot;insert into actor values(null, ?, ?, ?, ?)&quot;</span>, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;2000-11-11&quot;</span>, <span class="string">&quot;999&quot;</span>);</span><br><span class="line">        System.out.println(update &gt; <span class="number">0</span> ? <span class="string">&quot;执行成功&quot;</span> : <span class="string">&quot;执行没有影响表&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="第二十六章-满汉楼"><a href="#第二十六章-满汉楼" class="headerlink" title="第二十六章 满汉楼"></a>第二十六章 满汉楼</h1><p>（略）</p>
<h1 id="第二十七章-正则表达式"><a href="#第二十七章-正则表达式" class="headerlink" title="第二十七章 正则表达式"></a>第二十七章 正则表达式</h1><h2 id="27-1-快速入门"><a href="#27-1-快速入门" class="headerlink" title="27.1 快速入门"></a>27.1 快速入门</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Regexp_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//1. 先创建一个 Pattern 对象， 模式对象, 可以理解成就是一个正则表达式对象</span></span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;[a-zA-Z]+&quot;</span>); <span class="comment">//单词</span></span><br><span class="line">        <span class="comment">//Pattern pattern = Pattern.compile(&quot;[0-9]+&quot;);  //数字</span></span><br><span class="line">        <span class="comment">//Pattern pattern = Pattern.compile(&quot;([0-9]+)|([a-zA-Z]+)&quot;); //数字和单词</span></span><br><span class="line">        <span class="comment">//Pattern pattern = Pattern.compile(&quot;&lt;a target=\&quot;_blank\&quot; title=\&quot;(\\S*)\&quot;&quot;); //百度热搜的标题</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 创建一个匹配器对象</span></span><br><span class="line">        Matcher matcher = pattern.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 循环匹配</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            <span class="comment">//匹配内容，放到 m.group(0)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;找到：&quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="27-2-正则表达式基本介绍"><a href="#27-2-正则表达式基本介绍" class="headerlink" title="27.2 正则表达式基本介绍"></a>27.2 正则表达式基本介绍</h2><ol>
<li>一个正则表达式，就是<strong>用某种模式去匹配字符串的一个公式</strong>.很多人因<br>为它们看上去比较古怪而且复杂所以不敢去使用，不过，经过练习后，<br>就觉得这些复杂的表达式写起来还是相当简单的，而且，一旦你弄懂它<br>们，你就能把数小时辛苦而且易错的文本处理工作缩短在几分钟(甚至<br>几秒钟)内完成</li>
</ol>
<h2 id="27-3-正则表达式底层实现（重要）"><a href="#27-3-正则表达式底层实现（重要）" class="headerlink" title="27.3 正则表达式底层实现（重要）"></a>27.3 正则表达式底层实现（重要）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegTheory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;1998 年 12 月 8 日，第二代 Java 平台的企业版 J2EE 发布。1999 年 6 月，Sun 公司发布了&quot;</span> +</span><br><span class="line">                <span class="string">&quot;第二代 Java 平台（简称为 Java2）的 3 个版本：J2ME（Java2 Micro Edition，Java2 平台的微型&quot;</span> +</span><br><span class="line">                <span class="string">&quot;版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2 平台的&quot;</span> +</span><br><span class="line">                <span class="string">&quot;标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2 平台的企业版），应&quot;</span> +</span><br><span class="line">                <span class="string">&quot;用 3443 于基于 Java 的应用服务器。Java 2 平台的发布，是 Java 发展过程中最重要的一个&quot;</span> +</span><br><span class="line">                <span class="string">&quot;里程碑，标志着 Java 的应用开始普及 9889 &quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//目标：匹配所有四个数字</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">// 1. \\d 表示一个任意的数字</span></span><br><span class="line">        String regStr = <span class="string">&quot;(\\d\\d)(\\d\\d)&quot;</span>;</span><br><span class="line">        <span class="comment">// 2. 创建模式对象[即正则表达式对象]</span></span><br><span class="line">        Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">        <span class="comment">//3. 创建匹配器</span></span><br><span class="line">        <span class="comment">//说明：创建匹配器 matcher， 按照 正则表达式的规则 去匹配 content 字符串</span></span><br><span class="line">        Matcher matcher = pattern.matcher(content);</span><br><span class="line">        <span class="comment">//4.开始匹配</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * matcher.find() 完成的任务 （考虑分组）</span></span><br><span class="line"><span class="comment">         * 什么是分组，比如 (\d\d)(\d\d) ,正则表达式中有() 表示分组, 第 1 个()表示第 1 组,第 2 个()表示第 2 组...</span></span><br><span class="line"><span class="comment">         * 1. 根据指定的规则 ,定位满足规则的子字符串(比如(19)(98))</span></span><br><span class="line"><span class="comment">         * 2. 找到后，</span></span><br><span class="line"><span class="comment">         *  2.1 将 子字符串的开始的索引 记录到 matcher对象的属性 int[] groups; groups[0] = 0 ,</span></span><br><span class="line"><span class="comment">         *      把 该子字符串的结束的索引+1 记录到 groups[1] = 4</span></span><br><span class="line"><span class="comment">         *  2.2 记录 1 组()匹配到的字符串 groups[2] = 0 groups[3] = 2</span></span><br><span class="line"><span class="comment">         *  2.3 记录 2 组()匹配到的字符串 groups[4] = 2 groups[5] = 4</span></span><br><span class="line"><span class="comment">         *  2.4.如果有更多的分组.....</span></span><br><span class="line"><span class="comment">         * 3. 同时记录 oldLast 的值为 子字符串的结束的索引+1, 即 4, 即下次执行 find 时，就从 4 开始匹配</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * matcher.group(0) 分析</span></span><br><span class="line"><span class="comment">         *  源码</span></span><br><span class="line"><span class="comment">         *  return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();</span></span><br><span class="line"><span class="comment">         *  1. 根据 groups[0]=0 和 groups[1]=4 的记录的位置，从 content 开始截取子字符串返回</span></span><br><span class="line"><span class="comment">         *     是 [0,4) 包含 0 但是不包含索引为 4 的位置</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果再次指向 find 方法.仍然安上面分析来执行</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            <span class="comment">//小结</span></span><br><span class="line">            <span class="comment">//1. 如果正则表达式有() 即分组</span></span><br><span class="line">            <span class="comment">//2. 取出匹配的字符串规则如下</span></span><br><span class="line">            <span class="comment">//3. group(0) 表示匹配到的子字符串</span></span><br><span class="line">            <span class="comment">//4. group(1) 表示匹配到的子字符串的第一组字串</span></span><br><span class="line">            <span class="comment">//5. group(2) 表示匹配到的子字符串的第 2 组字串</span></span><br><span class="line">            <span class="comment">//6. ... 但是分组的数不能越界.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;找到: &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第 1 组()匹配到的值=&quot;</span> + matcher.group(<span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 组()匹配到的值=&quot;</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="27-4-正则表达式语法"><a href="#27-4-正则表达式语法" class="headerlink" title="27.4 正则表达式语法"></a>27.4 正则表达式语法</h2><h3 id="27-4-1-基本介绍"><a href="#27-4-1-基本介绍" class="headerlink" title="27.4.1 基本介绍"></a>27.4.1 基本介绍</h3><p>元字符按照功能大致分为：</p>
<ul>
<li>限定符</li>
<li>选择匹配符</li>
<li>特殊字符</li>
<li>字符匹配符</li>
<li>定位符</li>
<li>分组组合和反向引用符</li>
</ul>
<h3 id="27-4-2-元字符-转义号"><a href="#27-4-2-元字符-转义号" class="headerlink" title="27.4.2 元字符 - 转义号 \\"></a>27.4.2 元字符 - 转义号 \\</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240223123953145.png" alt="image-20240223123953145"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240223124028575.png" alt="image-20240223124028575"></p>
<h3 id="27-6-3-元字符-字符匹配符"><a href="#27-6-3-元字符-字符匹配符" class="headerlink" title="27.6.3 元字符 - 字符匹配符"></a>27.6.3 元字符 - 字符匹配符</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240226102714593.png" alt="image-20240226102714593"></p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240226102725620.png" alt="image-20240226102725620"></p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th>含义</th>
<th>示例</th>
<th>说明</th>
<th>匹配输入</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[ ]</td>
<td>可接收的字符列表</td>
<td>[efgh]</td>
<td>e、f、g、h中的任意1个字符</td>
<td></td>
</tr>
<tr>
<td align="center">[ ^ ]</td>
<td>不可接收的字符列表</td>
<td>[^abc]</td>
<td>除a、b、c、之外的任意1个字符，包含数字和特殊符号</td>
<td></td>
</tr>
<tr>
<td align="center">-</td>
<td>连字符</td>
<td>A-Z</td>
<td>任意单个大写字母</td>
<td></td>
</tr>
<tr>
<td align="center">.</td>
<td>匹配除了\n以外的任何字符</td>
<td>a..b</td>
<td>以a开头，b结尾，中间包含2个任意字符的长度为4的字符串</td>
<td>aaab, aefb, a35b</td>
</tr>
<tr>
<td align="center">\\d</td>
<td>匹配单个数字字符，相当于[0-9]</td>
<td>\\d{3}(\\d)?</td>
<td>包含3个或4个数字的字符串</td>
<td>123, 9876</td>
</tr>
<tr>
<td align="center">\\D</td>
<td>匹配单个非数字字符，相当于[^ 0-9]</td>
<td>\\D(\\d)*</td>
<td>以单个非数字字符开头，后接任意个数字符串</td>
<td>a, A342</td>
</tr>
<tr>
<td align="center">\\w</td>
<td>匹配单个数字，大小写字母字符，相当于[0-9a-zA-Z]</td>
<td>\\d{3}\\w{4}</td>
<td>以3个数字开头的长度为7的数字字母字符串</td>
<td>234abcd, 12345pe</td>
</tr>
<tr>
<td align="center">\\W</td>
<td>匹配单个非数字、大小写字母字符，相当于[^0-9a-zA-Z]</td>
<td>\\W+\\d{2}</td>
<td>以至少1个非数字字母字符开头，2个数字字符结尾的字符串</td>
<td>#29, #?@10</td>
</tr>
<tr>
<td align="center">\\s</td>
<td>匹配任何空白字符(空格,制表符等)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">\\S</td>
<td>匹配任何非空白字符</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String content = <span class="string">&quot;a11c8abc _ABCy @&quot;</span>;</span><br><span class="line"><span class="comment">//String regStr = &quot;[a-z]&quot;;//匹配 a-z 之间任意一个字符</span></span><br><span class="line"><span class="comment">//String regStr = &quot;[A-Z]&quot;;//匹配 A-Z 之间任意一个字符</span></span><br><span class="line"><span class="comment">//String regStr = &quot;abc&quot;;//匹配 abc 字符串[默认区分大小写]</span></span><br><span class="line"><span class="comment">//String regStr = &quot;(?i)abc&quot;;//匹配 abc 字符串[不区分大小写]</span></span><br><span class="line"><span class="comment">//String regStr = &quot;[0-9]&quot;;//匹配 0-9 之间任意一个字符</span></span><br><span class="line"><span class="comment">//String regStr = &quot;[^a-z]&quot;;//匹配 不在 a-z 之间任意一个字符</span></span><br><span class="line"><span class="comment">//String regStr = &quot;[^0-9]&quot;;//匹配 不在 0-9 之间任意一个字符</span></span><br><span class="line"><span class="comment">//String regStr = &quot;[abcd]&quot;;//匹配 在 abcd 中任意一个字符</span></span><br><span class="line"><span class="comment">//String regStr = &quot;\\D&quot;;//匹配 不在 0-9 的任意一个字符</span></span><br><span class="line"><span class="comment">//String regStr = &quot;\\w&quot;;//匹配 大小写英文字母, 数字，下划线</span></span><br><span class="line"><span class="comment">//String regStr = &quot;\\W&quot;;//匹配 等价于 [^a-zA-Z0-9_]</span></span><br><span class="line"><span class="comment">//\\s 匹配任何空白字符(空格,制表符等)</span></span><br><span class="line"><span class="comment">//String regStr = &quot;\\s&quot;;</span></span><br><span class="line"><span class="comment">//\\S 匹配任何非空白字符 ,和\\s 刚好相反</span></span><br><span class="line"><span class="comment">//String regStr = &quot;\\S&quot;;</span></span><br><span class="line"><span class="comment">//. 匹配出 \n 之外的所有字符,如果要匹配.本身则需要使用 \\.</span></span><br><span class="line"><span class="comment">//String regStr = &quot;.&quot;;</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 当创建 Pattern 对象时，指定 Pattern.CASE_INSENSITIVE, 表示匹配是不区分字母大小写.</span></span><br><span class="line">Pattern pattern = Pattern.compile(regStr, Pattern.CASE_INSENSITIVE);</span><br><span class="line">Matcher matcher = pattern.matcher(content);</span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;找到 &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27-6-4-元字符-选择匹配符"><a href="#27-6-4-元字符-选择匹配符" class="headerlink" title="27.6.4 元字符 - 选择匹配符"></a>27.6.4 元字符 - 选择匹配符</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240223133731633.png" alt="image-20240223133731633"></p>
<h3 id="27-6-5-元字符-限定符"><a href="#27-6-5-元字符-限定符" class="headerlink" title="27.6.5 元字符 - 限定符"></a>27.6.5 元字符 - 限定符</h3><p>用于指定其前面的字符和组合项连续出现多少次</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240223133756832.png" alt="image-20240223133756832"></p>
<h3 id="27-6-6-元字符-定位符"><a href="#27-6-6-元字符-定位符" class="headerlink" title="27.6.6 元字符 - 定位符"></a>27.6.6 元字符 - 定位符</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240223134820741.png" alt="image-20240223134820741"></p>
<h3 id="27-6-7-分组"><a href="#27-6-7-分组" class="headerlink" title="27.6.7 分组"></a>27.6.7 分组</h3><ul>
<li>捕获分组</li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240223150323017.png" alt="image-20240223150323017"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//非命名分组</span></span><br><span class="line">String regStr = <span class="string">&quot;(\\d\\d)(\\d\\d)&quot;</span>;<span class="comment">//匹配 4 个数字的字符串</span></span><br><span class="line"><span class="comment">//命名分组： 即可以给分组取名</span></span><br><span class="line">String regStr1 = <span class="string">&quot;(?&lt;g1&gt;\\d\\d)(?&lt;g2&gt;\\d\\d)&quot;</span>;<span class="comment">//匹配 4 个数字的字符串</span></span><br><span class="line">Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">Matcher matcher = pattern.matcher(content);</span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;找到=&quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;第 1 个分组内容=&quot;</span> + matcher.group(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;第 1 个分组内容[通过组名]=&quot;</span> + matcher.group(<span class="string">&quot;g1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;第 2 个分组内容=&quot;</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;第 2 个分组内容[通过组名]=&quot;</span> + matcher.group(<span class="string">&quot;g2&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非捕获分组</li>
</ul>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240223151121978.png" alt="image-20240223151121978"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String content = <span class="string">&quot;hello 韩顺平教育 jack 韩顺平老师 韩顺平同学 hello 韩顺平学生&quot;</span>;</span><br><span class="line"><span class="comment">// 找到 韩顺平教育 、韩顺平老师、韩顺平同学 子字符串</span></span><br><span class="line"><span class="comment">//String regStr = &quot;韩顺平教育|韩顺平老师|韩顺平同学&quot;;</span></span><br><span class="line"><span class="comment">//上面的写法可以等价非捕获分组, 注意：不能 matcher.group(1)</span></span><br><span class="line">String regStr = <span class="string">&quot;韩顺平(?:教育|老师|同学)&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到 韩顺平 这个关键字,但是要求只是查找韩顺平教育和 韩顺平老师 中包含有的韩顺平</span></span><br><span class="line"><span class="comment">//下面也是非捕获分组，不能使用 matcher.group(1)</span></span><br><span class="line">String regStr1 = <span class="string">&quot;韩顺平(?=教育|老师)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到 韩顺平 这个关键字,但是要求只是查找 不是 (韩顺平教育 和 韩顺平老师) 中包含有的韩顺平</span></span><br><span class="line"><span class="comment">//下面也是非捕获分组，不能使用 matcher.group(1)</span></span><br><span class="line">String regStr2 = <span class="string">&quot;韩顺平(?!教育|老师)&quot;</span>;</span><br><span class="line"></span><br><span class="line">Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">Matcher matcher = pattern.matcher(content);</span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;找到: &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="27-5-应用实例"><a href="#27-5-应用实例" class="headerlink" title="27.5 应用实例"></a>27.5 应用实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String content = <span class="string">&quot;13588889999&quot;</span>;</span><br><span class="line"><span class="comment">// 汉字</span></span><br><span class="line"><span class="comment">//String regStr = &quot;^[\u0391-\uffe5]+$&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邮政编码</span></span><br><span class="line"><span class="comment">// 要求：1.是 1-9 开头的一个六位数. 比如：123890</span></span><br><span class="line"><span class="comment">//String regStr = &quot;^[1-9]\\d&#123;5&#125;$&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// QQ 号码</span></span><br><span class="line"><span class="comment">// 要求: 是 1-9 开头的一个(5 位数-10 位数) 比如: 12389 , 1345687 , 187698765</span></span><br><span class="line"><span class="comment">//String regStr = &quot;^[1-9]\\d&#123;4,9&#125;$&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机号码</span></span><br><span class="line"><span class="comment">// 要求: 必须以 13,14,15,18 开头的 11 位数 , 比如 13588889999</span></span><br><span class="line">String regStr = <span class="string">&quot;^1[3|4|5|8]\\d&#123;9&#125;$&quot;</span>;</span><br><span class="line"></span><br><span class="line">Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">Matcher matcher = pattern.matcher(content);</span><br><span class="line"><span class="keyword">if</span>(matcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;满足格式&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不满足格式&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//网址</span></span><br><span class="line"><span class="comment">//String content = &quot;https://www.bilibili.com/video/BV1fh411y7R8?from=search&amp;seid=1831060912083761326&quot;;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路</span></span><br><span class="line"><span class="comment">* 1. 先确定 url 的开始部分 https:// | http://</span></span><br><span class="line"><span class="comment">* 2.然后通过 ([\w-]+\.)+[\w-]+ 匹配 www.bilibili.com</span></span><br><span class="line"><span class="comment">* 3. (\/[\w-?=&amp;/%.#]*)? 匹配/video/BV1fh411y7R8?from=sear </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String regStr1 = <span class="string">&quot;^((http|https)://)?([\\w-]+\\.)+[\\w-]+(\\/[\\w-?=&amp;/%.#]*)?$&quot;</span>;<span class="comment">//注意：[. ? *]表示匹配就是.本身</span></span><br></pre></td></tr></table></figure>



<h2 id="27-6-正则表达式三个常用类"><a href="#27-6-正则表达式三个常用类" class="headerlink" title="27.6 正则表达式三个常用类"></a>27.6 正则表达式三个常用类</h2><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240223154309577.png" alt="image-20240223154309577"></p>
<ul>
<li>常用方法<ul>
<li>boolean Pattern.maches(regStr, content) 整体匹配</li>
<li>boolean Macher.maches() 整体匹配</li>
<li>int Macher.start()     int Macher.end() 返回匹配的索引</li>
<li>String Macher.replaceAll(String s) 替换匹配的子串</li>
</ul>
</li>
</ul>
<h2 id="27-8-分组、捕获、反向引用"><a href="#27-8-分组、捕获、反向引用" class="headerlink" title="27.8 分组、捕获、反向引用"></a>27.8 分组、捕获、反向引用</h2><h3 id="27-8-1-提出需求"><a href="#27-8-1-提出需求" class="headerlink" title="27.8.1 提出需求"></a>27.8.1 提出需求</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240226100609246.png" alt="image-20240226100609246"></p>
<h3 id="27-8-2-介绍"><a href="#27-8-2-介绍" class="headerlink" title="27.8.2 介绍"></a>27.8.2 介绍</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240226100742475.png" alt="image-20240226100742475"></p>
<h3 id="27-8-3-看几个小案例"><a href="#27-8-3-看几个小案例" class="headerlink" title="27.8.3 看几个小案例"></a>27.8.3 看几个小案例</h3><p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240226101541332.png" alt="image-20240226101541332"></p>
<h3 id="27-8-4-经典的结巴程序"><a href="#27-8-4-经典的结巴程序" class="headerlink" title="27.8.4 经典的结巴程序"></a>27.8.4 经典的结巴程序</h3><p>把 类似 : “我….我要….学学学学….编程 java!”; 通过正则表达式 修改成 “我要学编程 java” </p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240226103540076.png" alt="image-20240226103540076"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;我....我要....学学学学....编程 java!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 去掉所有的.</span></span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(content);</span><br><span class="line">        <span class="comment">//注意：返回的字符串才是替换后的字符串 原来的 content 不变化</span></span><br><span class="line">        content = matcher.replaceAll(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;newContent=&quot;</span> + content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 去掉重复的字 我我要学学学学编程 java</span></span><br><span class="line">        <span class="comment">// 思路</span></span><br><span class="line">        <span class="comment">//(1) 使用 (.)\\1+ 匹配到 (我)我 (学)学学学</span></span><br><span class="line">        <span class="comment">//(2) 使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">        <span class="comment">// 注意：因为正则表达式变化，所以需要重置 matcher</span></span><br><span class="line">        pattern = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>);<span class="comment">//分组的捕获内容记录到$1</span></span><br><span class="line">        matcher = pattern.matcher(content);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到=&quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">        content = matcher.replaceAll(<span class="string">&quot;$1&quot;</span>); <span class="comment">//用(我)替换(我)我；(学)替换(学)学学学</span></span><br><span class="line">        System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 使用一条语句 去掉重复的字 我我要学学学学编程 java!</span></span><br><span class="line">        content = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>).matcher(content).replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="27-9-String-类中使用正则表达式"><a href="#27-9-String-类中使用正则表达式" class="headerlink" title="27.9 String 类中使用正则表达式"></a>27.9 String 类中使用正则表达式</h2><h3 id="27-9-1-替换功能"><a href="#27-9-1-替换功能" class="headerlink" title="27.9.1 替换功能"></a>27.9.1 替换功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String content = <span class="string">&quot;2000 年 5 月，JDK1.3、JDK1.4 和 J2SE1.3 相继发布，几周后其&quot;</span> +</span><br><span class="line">                <span class="string">&quot;获得了 Apple 公司 Mac OS X 的工业标准的支持。2001 年 9 月 24 日，J2EE1.3 发				 布。2002 年 2 月 26 日，J2SE1.4 发布。自此 Java 的计算能力有了大幅提升&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用正则表达式方式，将 JDK1.3 和 JDK1.4 替换成 JDK</span></span><br><span class="line"><span class="comment">//content = content.replaceAll(&quot;JDK1\\.3|JDK1\\.4&quot;, &quot;JDK&quot;);</span></span><br><span class="line">content = content.replaceAll(<span class="string">&quot;JDK1(\\.3|\\.4)&quot;</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">System.out.println(content);</span><br></pre></td></tr></table></figure>



<h3 id="27-9-2-判断功能"><a href="#27-9-2-判断功能" class="headerlink" title="27.9.2 判断功能"></a>27.9.2 判断功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要求 验证一个 手机号， 要求必须是以 138 139 开头的</span></span><br><span class="line">content = <span class="string">&quot;13888889999&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (content.matches(<span class="string">&quot;1(38|39)\\d&#123;8&#125;&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;验证成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;验证失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27-9-3-分割功能"><a href="#27-9-3-分割功能" class="headerlink" title="27.9.3 分割功能"></a>27.9.3 分割功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要求按照 # 或者 - 或者 ~ 或者 数字 来分割字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">content = <span class="string">&quot;hello#abc-jack12smith~北京&quot;</span>;</span><br><span class="line">String[] split = content.split(<span class="string">&quot;#|-|~|\\d+&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="27-10-Homeworks"><a href="#27-10-Homeworks" class="headerlink" title="27.10 Homeworks"></a>27.10 Homeworks</h2><ul>
<li><p>Homework01</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240226113849814.png" alt="image-20240226113849814"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String content = <span class="string">&quot;1530268781@qq.com&quot;</span>;</span><br><span class="line">String regStr = <span class="string">&quot;^[\\w-]+@([a-zA-Z]+\\.)+[a-zA-Z]+$&quot;</span>;</span><br><span class="line"></span><br><span class="line">Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">Matcher matcher = pattern.matcher(content);</span><br><span class="line"><span class="keyword">boolean</span> matches = matcher.matches();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (content.matches(regStr)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;输入合法&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;输入不合法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Homework02</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240226113936314.png" alt="image-20240226113936314"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 要求验证是不是整数或者小数</span></span><br><span class="line"><span class="comment">* 要求考虑整数和负数 如123 -123 3.14 -3.14</span></span><br><span class="line"><span class="comment">* 思路：</span></span><br><span class="line"><span class="comment">* 先写出简单的正则表达式，再逐步完善</span></span><br><span class="line"><span class="comment">* 考虑 0012.3 不是规范的，0.3是规范的，将</span></span><br><span class="line"><span class="comment">* \\d+ 改成 [1-9]\\d*|0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String content = <span class="string">&quot;12.3&quot;</span>;</span><br><span class="line">String regStr = <span class="string">&quot;^[-+]?([1-9]\\d*|0)(\\.\\d+)?$&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (content.matches(regStr)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;匹配成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;匹配失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Homework03</p>
<p><img src="/2023/09/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240226114121201.png" alt="image-20240226114121201"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对一个url进行解析</span></span><br><span class="line"><span class="comment">* 协议 如 http: https:</span></span><br><span class="line"><span class="comment">* 域名 如 www.suhu.com</span></span><br><span class="line"><span class="comment">* 端口 如 8080</span></span><br><span class="line"><span class="comment">* 文件名 如 index.htm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String content = <span class="string">&quot;http://www.sohu.com:8080/abc/xxx/index.htm&quot;</span>;</span><br><span class="line">String regStr = <span class="string">&quot;^([a-zA-Z]+)://([a-zA-Z.]+):(\\d+)([\\w-/]*)/([\\w.]+)$&quot;</span>;</span><br><span class="line"></span><br><span class="line">Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">Matcher matcher = pattern.matcher(content);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;整体匹配=&quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;协议=&quot;</span> + matcher.group(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;域名=&quot;</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;端口=&quot;</span> + matcher.group(<span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;路径=&quot;</span> + matcher.group(<span class="number">4</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;文件名=&quot;</span> + matcher.group(<span class="number">5</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;匹配失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>《Java》</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用正则表达式</title>
    <url>/2024/02/26/Java%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一、校验数字的表达式"><a href="#一、校验数字的表达式" class="headerlink" title="一、校验数字的表达式"></a>一、校验数字的表达式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 数字：^[<span class="number">0</span>-<span class="number">9</span>]*$</span><br><span class="line"> n位的数字：^\d&#123;n&#125;$</span><br><span class="line"> 至少n位的数字：^\d&#123;n,&#125;$</span><br><span class="line"> m-n位的数字：^\d&#123;m,n&#125;$</span><br><span class="line"> 零和非零开头的数字：^(<span class="number">0</span>|[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*)$</span><br><span class="line"> 非零开头的最多带两位小数的数字：^([<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*)+(.[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line"> 带<span class="number">1</span>-<span class="number">2</span>位小数的正数或负数：^(\-)?\d+(\.\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line"> 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line"> 有两位小数的正实数：^[<span class="number">0</span>-<span class="number">9</span>]+(.[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">2</span>&#125;)?$</span><br><span class="line"> 有<span class="number">1</span>~<span class="number">3</span>位小数的正实数：^[<span class="number">0</span>-<span class="number">9</span>]+(.[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)?$</span><br><span class="line"> 非零的正整数：^[<span class="number">1</span>-<span class="number">9</span>]\d*$ 或 ^([<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;$ 或 ^\+?[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*$</span><br><span class="line"> 非零的负整数：^\-[<span class="number">1</span>-<span class="number">9</span>][]<span class="number">0</span>-<span class="number">9</span><span class="string">&quot;*$ 或 ^-[1-9]\d*$</span></span><br><span class="line"><span class="string"> 非负整数：^\d+$ 或 ^[1-9]\d*|0$</span></span><br><span class="line"><span class="string"> 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</span></span><br><span class="line"><span class="string"> 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</span></span><br><span class="line"><span class="string"> 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</span></span><br><span class="line"><span class="string"> 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span></span><br><span class="line"><span class="string"> 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span></span><br><span class="line"><span class="string">19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span></span><br></pre></td></tr></table></figure>



<h2 id="二、校验字符的表达式"><a href="#二、校验字符的表达式" class="headerlink" title="二、校验字符的表达式"></a>二、校验字符的表达式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 汉字：^[\u4e00-\u9fa5]&#123;<span class="number">0</span>,&#125;$</span><br><span class="line"><span class="number">2</span> 英文和数字：^[A-Za-z0-<span class="number">9</span>]+$ 或 ^[A-Za-z0-<span class="number">9</span>]&#123;<span class="number">4</span>,<span class="number">40</span>&#125;$</span><br><span class="line"><span class="number">3</span> 长度为<span class="number">3</span>-<span class="number">20</span>的所有字符：^.&#123;<span class="number">3</span>,<span class="number">20</span>&#125;$</span><br><span class="line"><span class="number">4</span> 由<span class="number">26</span>个英文字母组成的字符串：^[A-Za-z]+$</span><br><span class="line"><span class="number">5</span> 由<span class="number">26</span>个大写英文字母组成的字符串：^[A-Z]+$</span><br><span class="line"><span class="number">6</span> 由<span class="number">26</span>个小写英文字母组成的字符串：^[a-z]+$</span><br><span class="line"><span class="number">7</span> 由数字和<span class="number">26</span>个英文字母组成的字符串：^[A-Za-z0-<span class="number">9</span>]+$</span><br><span class="line"><span class="number">8</span> 由数字、<span class="number">26</span>个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;<span class="number">3</span>,<span class="number">20</span>&#125;$</span><br><span class="line"><span class="number">9</span> 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</span><br><span class="line"><span class="number">10</span> 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-<span class="number">9</span>]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-<span class="number">9</span>]&#123;<span class="number">2</span>,<span class="number">20</span>&#125;$</span><br><span class="line"><span class="number">11</span> 可以输入含有^%&amp;<span class="string">&#x27;,;=?$\&quot;等字符：[^%&amp;&#x27;</span>,;=?$\x22]+</span><br><span class="line"><span class="number">12</span> 禁止输入含有~的字符：[^~\x22]+</span><br></pre></td></tr></table></figure>



<h1 id="三、特殊需求表达式"><a href="#三、特殊需求表达式" class="headerlink" title="三、特殊需求表达式"></a>三、特殊需求表达式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line">域名：[a-zA-Z0-<span class="number">9</span>][-a-zA-Z0-<span class="number">9</span>]&#123;<span class="number">0</span>,<span class="number">62</span>&#125;(/.[a-zA-Z0-<span class="number">9</span>][-a-zA-Z0-<span class="number">9</span>]&#123;<span class="number">0</span>,<span class="number">62</span>&#125;)+/.?</span><br><span class="line">InternetURL：[a-zA-z]+:<span class="comment">//[^\s]* 或 ^https://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span></span><br><span class="line">手机号码：^(<span class="number">13</span>[<span class="number">0</span>-<span class="number">9</span>]|<span class="number">14</span>[<span class="number">5</span>|<span class="number">7</span>]|<span class="number">15</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>]|<span class="number">18</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>])\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line">电话号码(<span class="string">&quot;XXX-XXXXXXX&quot;</span>、<span class="string">&quot;XXXX-XXXXXXXX&quot;</span>、<span class="string">&quot;XXX-XXXXXXX&quot;</span>、<span class="string">&quot;XXX-XXXXXXXX&quot;</span>、<span class="string">&quot;XXXXXXX&quot;</span>和<span class="string">&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ </span></span><br><span class="line"><span class="string">国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span></span><br><span class="line"><span class="string">身份证号：</span></span><br><span class="line"><span class="string">	15或18位身份证：^\d&#123;15&#125;|\d&#123;18&#125;$</span></span><br><span class="line"><span class="string">	15位身份证：^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$</span></span><br><span class="line"><span class="string">	18位身份证：^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;4&#125;$</span></span><br><span class="line"><span class="string">短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$</span></span><br><span class="line"><span class="string">帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span></span><br><span class="line"><span class="string">密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$</span></span><br><span class="line"><span class="string">强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ </span></span><br><span class="line"><span class="string">日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span></span><br><span class="line"><span class="string">一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</span></span><br><span class="line"><span class="string">一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ </span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">钱的输入格式：</span></span><br><span class="line"><span class="string"> 1.有四种钱的表示形式我们可以接受:&quot;</span><span class="number">10000.00</span><span class="string">&quot; 和 &quot;</span><span class="number">10</span>,<span class="number">000.00</span><span class="string">&quot;, 和没有 &quot;</span>分<span class="string">&quot; 的 &quot;</span><span class="number">10000</span><span class="string">&quot; 和 &quot;</span><span class="number">10</span>,<span class="number">000</span><span class="string">&quot;：^[1-9][0-9]*$ </span></span><br><span class="line"><span class="string"> 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;</span><span class="number">0</span><span class="string">&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ </span></span><br><span class="line"><span class="string"> 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ </span></span><br><span class="line"><span class="string"> 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ </span></span><br><span class="line"><span class="string"> 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;</span><span class="number">10.</span><span class="string">&quot;是不通过的,但是 &quot;</span><span class="number">10</span><span class="string">&quot; 和 &quot;</span><span class="number">10.2</span><span class="string">&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ </span></span><br><span class="line"><span class="string"> 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ </span></span><br><span class="line"><span class="string"> 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ </span></span><br><span class="line"><span class="string"> 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ </span></span><br><span class="line"><span class="string"> 备注：这就是最终结果了,别忘了&quot;</span>+<span class="string">&quot;可以用&quot;</span>*<span class="string">&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</span></span><br><span class="line"><span class="string">中文字符的正则表达式：[\u4e00-\u9fa5]</span></span><br><span class="line"><span class="string">双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</span></span><br><span class="line"><span class="string">空白行的正则表达式：\n\s*\r (可以用来删除空白行)</span></span><br><span class="line"><span class="string">HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span></span><br><span class="line"><span class="string">首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span></span><br><span class="line"><span class="string">腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)</span></span><br><span class="line"><span class="string">中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)</span></span><br><span class="line"><span class="string">IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《Java》</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
