<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>网络实验四-DHCP动态分配IP</title>
    <url>/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/</url>
    <content><![CDATA[<h1 id="实验四-DHCP动态分配IP"><a href="#实验四-DHCP动态分配IP" class="headerlink" title="实验四 DHCP动态分配IP"></a>实验四 DHCP动态分配IP</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>掌握DHCP（动态主机配置协议）工作原理<br>启动路由器的DHCP服务为局域网中的机器分配IP地址<br>启动服务器的DHCP服务为局域网中的机器分配IP地址</p>
<h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p>Cisco Packet Tracer</p>
<h2 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h2><p>（1）新建Packet Tracer拓扑图（如图）；<br>（2）静态配置路由器的IP地址；<br>（3）左侧网络通过路由器DHCP动态分配各主机包括服务器的IP地址；<br>（4）右侧网络通过服务器DHCP动态分配各主机的IP地址。</p>
<h2 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h2><h3 id="1-新建packet-tracer网络拓扑图"><a href="#1-新建packet-tracer网络拓扑图" class="headerlink" title="1.新建packet tracer网络拓扑图"></a>1.新建packet tracer网络拓扑图</h3><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps7.jpg" alt="img" style="zoom: 80%;">



<h3 id="2-启动路由器DHCP服务"><a href="#2-启动路由器DHCP服务" class="headerlink" title="2.启动路由器DHCP服务"></a>2.启动路由器DHCP服务</h3><p>(config)#ip dhcp pool test1<br>(dhcp-config)#network 192.168.1.0 255.255.255.0<br>(dhcp-config)#dns-server 192.168.1.1    //设置默认DNS服务器<br>(dhcp-config)#exit</p>
<p>(config)#in f0/0<br>(config)#ip address 192.168.1.254 255.255.255.0<br>(config)#no shut</p>
<h3 id="3-启动服务器DHCP服务"><a href="#3-启动服务器DHCP服务" class="headerlink" title="3.启动服务器DHCP服务"></a>3.启动服务器DHCP服务</h3><ul>
<li>（1）先静态配置服务器的IP地址、子网掩码、默认网关和默认DNS服务器</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps8.jpg" alt="img"></p>
<ul>
<li>（2）再开启服务器DHCP服务</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps9.jpg" alt="img"></p>
<h2 id="五、运行结果"><a href="#五、运行结果" class="headerlink" title="五、运行结果"></a>五、运行结果</h2><p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps10.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps11.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps59-1621920521237.jpg" alt="img"></p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>DHCP是动态主机分配协议，是一个局域网的网络协议，使用UDP协议工作。</p>
<div class="note success modern"><p>主要有两个用途：<br>（1）用于内部网或网络服务供应商ISP自动分配IP地址；<br>（2）给用户用于内部网管理员作为对所有计算机作中央管理的手段。</p>
</div>

<div class="note success modern"><p>DHCP具有以下功能：<br>1、保证任何IP地址在同一时刻只能由一台DHCP客户机所使用。<br>2、DHCP应当可以给用户分配永久固定的IP地址。<br>3、DHCP应当可以同用其他方法获得IP地址的主机共存（如手工配置IP地址的主机）。<br>4、DHCP服务器应当向现有的BOOTP客户端提供服务。</p>
</div>]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>pictures</title>
    <url>/2021/05/22/pictures/</url>
    <content><![CDATA[<p><img src="/2021/05/22/pictures/2.png" alt="2"></p>
<p><img src="/2021/05/22/pictures/1.jpg" alt="3"></p>
<p><img src="/2021/05/22/pictures/3.png"></p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验六-FTP与Email服务</title>
    <url>/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>了解FTP（简单传送协议）的作用及基本原理<br>掌握服务器端FTP的配置<br>掌握服务器与客户端之间文件共享<br>掌握邮件服务器的配合，发送与接收邮件<br>了解TFTP文件共享基本原理</p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Cisco Packet Tracer    tftp32.exe</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>（1）新建Packet Tracer拓扑图（如图，以实验五为基础）；<br>（2）新增服务器Server1，作为Laptop1的DNS域名服务器；<br>（3）启动Server0和Server1的DNS服务，并配置DNS映射表；<br>（4）启动Server0的FTP服务，在Laptop1上访问并共享Server0上的文件；<br>（5）在PC0和Laptop1上配置邮件，包括姓名、邮件地址，邮件服务器等；<br>（6）启用服务器的EMail服务，并设置用户。<br>（7）测试在两台主机之间发送邮件    。  </p>
<h1 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h1><p>1.新建packet tracer网络拓扑图</p>
<p><img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185013306.png" alt="image-20210528185013306"></p>
<p>2.配置新增的服务器，并修改Laptop1的默认DNS为Server0的IP地址</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185024685.png" alt="image-20210528185024685" style="zoom: 67%;">



<p>3.启动两个服务器的DNS服务，并新增四条地址转换信息，如图</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185034976.png" alt="image-20210528185034976" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185054327.png" alt="image-20210528185054327" style="zoom:67%;">



<p>4.启动Server0的FTP服务，新增一个用户信息，包括用户名、密码以及权限</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185106041.png" alt="image-20210528185106041" style="zoom:67%;">



<p>5.在Laptop1上访问Server0上的FTP1，实现下载和上传文件</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185117275.png" alt="image-20210528185117275" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185125957.png" alt="image-20210528185125957" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185136089.png" alt="image-20210528185136089" style="zoom:50%;">



<p>6.在PC0和Laptop1上配置两个Email用户，如图</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185141602.png" alt="image-20210528185141602" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185146855.png" alt="image-20210528185146855" style="zoom:67%;">



<p>7.在对应邮件服务器上注册</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185156699.png" alt="image-20210528185156699" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185206053.png" alt="image-20210528185206053" style="zoom:67%;">

<p>8.收发邮件<br>–发送端</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185213776.png" alt="image-20210528185213776" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185219900.png" alt="image-20210528185219900" style="zoom:67%;">

<p>–接受端</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185224344.png" alt="image-20210528185224344" style="zoom:67%;">

<p>–回信</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185230738.png" alt="image-20210528185230738" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185239349.png" alt="image-20210528185239349" style="zoom:67%;">



<p>9.了解TFTP文件的收发</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185244592.png" alt="image-20210528185244592" style="zoom:67%;">



<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p> FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。<br>默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。</p>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验五-NAT地址转换</title>
    <url>/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="实验五-NAT地址转换"><a href="#实验五-NAT地址转换" class="headerlink" title="实验五 NAT地址转换"></a>实验五 NAT地址转换</h1><p>​                                             </p>
<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>了解NAT的作用及基本原理</p>
<p>掌握NAT常见应用场景及配置</p>
<p>掌握静态NAT的配置，实现局域网访问互联网</p>
<h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p>· Cisco Packet Tracer</p>
<h2 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h2><p>（1）新建Packet Tracer拓扑图（如图）；</p>
<p>（2）静态配置服务器的IP地址，子网掩码和默认网关（见实验四）；</p>
<p>（3）通过服务器DHCP动态分配各主机的IP地址；</p>
<p>（4）在Router0上配置动态NAT地址转换，建立（PC0，Laptop0本地和全局的）地址之间的临时映射关系（过一段时间没有数据就会删除映射关系）；</p>
<p>（5）在Router0上配置静态NAT地址转换，建立（服务器本地和全局的）地址之间的永久映射关系，对外提供服务。</p>
<p>（6）启用服务器的DNS服务，给服务器的内部全局地址分配一个域名，并测试能否访问成功。  </p>
<h2 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h2><h3 id="1-packet-tracer网络拓扑图"><a href="#1-packet-tracer网络拓扑图" class="headerlink" title="1. packet tracer网络拓扑图"></a><strong>1.</strong> packet tracer网络拓扑图</h3><p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps1.jpg" alt="img"> </p>
<h3 id="2-完成网络的基本配置"><a href="#2-完成网络的基本配置" class="headerlink" title="2. 完成网络的基本配置"></a><strong>2.</strong> 完成网络的基本配置</h3><p>包括各主句的IP地址、子网掩码、网关、默认DNS服务器等，以及路由表的配置，实现网络之间的连通。（略，见实验1-4）</p>
<h3 id="3-配置动态NAT"><a href="#3-配置动态NAT" class="headerlink" title="3. 配置动态NAT"></a><strong>3.</strong> 配置动态NAT</h3><ul>
<li><p>（1）定义NAT设备（路由器）的内外接口</p>
<p>—R0上</p>
<p>（config）int f0/0</p>
<p>（config-if）<font color="cornflowerblue">ip nat inside</font></p>
<p>（config）int f0/1</p>
<p>（config-if）<font color="cornflowerblue">ip nat outside</font></p>
</li>
<li><p>（2）定义NAT地址池</p>
<p>— ip nat pool pool-name start-ip  end-ip netmask 子网掩码</p>
<p>（config）<font color="cornflowerblue">ip nat pool</font> <font color="red">out</font> 202.106.0.4  202.106.0.24  <font color="cornflowerblue">netmask</font> 255.255.255.0</p>
</li>
<li><p>（3）利用ACL(地址控制列表Address Control List)定义允许转换的本地地址列表</p>
<p>—access-list ACL号 permit  &lt;网段&gt;  &lt;子网掩码反码&gt;</p>
<p>（config）<font color="cornflowerblue">access-list </font><font color="red">10</font> <font color="cornflowerblue">permit </font>192.168.0.0 0.0.0.255</p>
</li>
<li><p>（4）定义内部本地地址与内部全局地址的转换关系</p>
<p>（config<font color="cornflowerblue">）ip nat inside source list</font> <font color="red">10</font> <font color="cornflowerblue">pool </font><font color="red">out</font></p>
</li>
</ul>
<h3 id="4-配置静态NAT"><a href="#4-配置静态NAT" class="headerlink" title="4. 配置静态NAT"></a><strong>4.</strong> 配置静态NAT</h3><p>（config）<font color="cornflowerblue">ip nat inside source static</font> 192.168.0.1  202.106.0.3</p>
<p>（config）<font color="cornflowerblue">ip nat outside source static</font> 202.106.0.3 192.168.0.1</p>
<h3 id="5-启动DNS服务"><a href="#5-启动DNS服务" class="headerlink" title="5.启动DNS服务"></a>5.启动DNS服务</h3><p>给服务器的内部全局地址分配一个域名</p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps2.jpg" alt="img"> </p>
<h3 id="6-测试连通性"><a href="#6-测试连通性" class="headerlink" title="6. 测试连通性"></a><strong>6.</strong> 测试连通性</h3><p>测试Server0与Laptop1的连通性，并在Laptop1上访问第 5步的域名</p>
<h2 id="五、运行结果"><a href="#五、运行结果" class="headerlink" title="五、运行结果"></a>五、运行结果</h2><p>（1）NAT表</p>
<img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps3.jpg" alt="img" style="zoom:80%;"> 

 

<p>（2）连通性</p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps4.jpg" alt="img" style="zoom: 80%;"><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps5.jpg" alt="img" style="zoom:80%;"><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps6.jpg" alt="img" style="zoom:80%;"> </p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p> 1.NAT将网络划分为内部网络和外部网络两部分，局域网主机利用NAT访问网络时，是将局域网内部的本地地址转换为全局地址（互联网合法的IP地址）后转发数据包；</p>
<p> 2.NAT分为两种类型：NAT（网络地址转换）和NAPT（网络端口地址转换IP地址对应一个全局地址）。</p>
<p>（1）静态NAT：实现内部地址与外部地址一对一的映射。现实中，一般都用于服务器；</p>
<p>（2）动态NAT：定义一个地址池，自动映射，也是一对一的。现实中，用得比较少；</p>
<p>（3）NAPT：使用不同的端口来映射多个内网IP地址到一个指定的外网IP地址，多对一。</p>
<p>3.NAPT采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自Internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</p>
<p>4.<font color="red">区分 内部/外部 局部/全局：</font></p>
<p>—内部本地（局部）地址：转换前的主机（私有）地址。</p>
<p>—内部全局地址：内部主机与外部主机通信地址，通常为公有地址。</p>
<p>—外部本地（局部）地址：能够被内部主机识别的外部主机的地址，对内部主机可见的地址。</p>
<p>—外部全局地址：外部主机的真实地址，对内部主机是不可见的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inside localne内部本地  内部转换前地址</span><br><span class="line">inside global内部全局 本地转换后地址</span><br><span class="line">ip nat inside xx 内部本地 内部全局</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">outside global外部全局 外部转换前地址</span><br><span class="line">outside local外部本地  外部转换后地址</span><br><span class="line">ip nat outside xx 外部全局  外部本地</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps7.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验三-OSPF+RIP路由配置</title>
    <url>/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF-RIP%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>  掌握综合路由器的配置方法；<br>  掌握查看通过路由重分布学习产生的路由；<br>  熟悉广域网线缆的链接方式；</p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Cisco Packet Tracer</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>新建Packet Tracer拓扑图<br>（1）在实验二基础上新增一个路由器R5连接到R4，配置R4各个接口的IP地址即子网掩码；<br>（2）新增一个网段192.168.7.0，重新配置PC1的ip地址与默认网关；<br>（3）在路由器R4上左侧配置RIP V2路由协议；右侧配置OSPF协议。<br>（4）在R4路由进程中引入外部路由，进行路由重分布。<br>（5）在路由器R5上配置RIP路由协议；<br>（6）验证PC1、PC0主机之间可以互相通信；</p>
<h1 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h1><h2 id="1-新建packet-tracer网络拓扑图"><a href="#1-新建packet-tracer网络拓扑图" class="headerlink" title="1.新建packet tracer网络拓扑图"></a>1.新建packet tracer网络拓扑图</h2><p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF-RIP%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/wps5.jpg" alt="img"></p>
<h2 id="2-在路由器R4上左侧配置RIP-V2路由协议；右侧配置OSPF协议"><a href="#2-在路由器R4上左侧配置RIP-V2路由协议；右侧配置OSPF协议" class="headerlink" title="2.在路由器R4上左侧配置RIP V2路由协议；右侧配置OSPF协议"></a>2.在路由器R4上左侧配置RIP V2路由协议；右侧配置OSPF协议</h2><p>—-R4<br>(config) #router ospf 100<br>(config-router) #network 192.168.3.0 0.0.0.255 area 2<br>(config-router) #network 192.168.7.0 0.0.0.255 area 2<br>(config-router) #<font color="red">redistribute rip metric 10 subnets</font>  //将RIP路由重分布给OSPF路由协议<br>(config-router)#exit</p>
<p>(config) #router rip<br>(config-router) #network 192.168.7.0<br>(config-router) #ver 2<br>(config-router) #no auto-s<br>(config-router) #<font color="red">redistribute ospf 100 matric 10</font>    //将OSPF路由重分布给RIP路由协议</p>
<h2 id="3-在路由器R5上配置RIP路由协议"><a href="#3-在路由器R5上配置RIP路由协议" class="headerlink" title="3.在路由器R5上配置RIP路由协议"></a>3.在路由器R5上配置RIP路由协议</h2><p>router (config) #hostname R5<br>—-R5<br>(config)#router rip<br>(config-rout er)#network 192.168.7.0<br>(config-rout er)#network 192.168.2.0<br>(config-rout er)#ver 2<br>(config-rout er)#no auto-summary</p>
<h1 id="五、运行结果"><a href="#五、运行结果" class="headerlink" title="五、运行结果"></a>五、运行结果</h1><ul>
<li>（1）路由表</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF-RIP%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/wps6.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF-RIP%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/wps7.jpg" alt="img"></p>
<ul>
<li>（2）测试网络连通性，在PC1上ping PC0</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF-RIP%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/wps8.jpg" alt="img"></p>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>1.路由重分布：为了在同一个网络中有效地支持多种路由协议，必须在不同的路由协议之间共享路由信息。在不同的路由协议之间交换路由信息的过程称为路由重分布，它将一种路由选择协议获悉的路由信息告知给另一种路由选择协议。</p>
<p>2.为了支持本设备能够运行多个路由协议进程，系统软件提供了路由信息从一个路由进程重分布到另一个路由进程的功能。比如你可以将OSPF路由域的路由重新分布后通告RIP路由域中，也可以将RIP路由域的路由重新分布后通告到OSPF路由域中。路由的相互重分布可以在所有的IP路由协议之间进行。</p>
<p>3.命令格式：router(router-config)#redistribute  protocol [protocol-id]  {level-1 | level-2|level-1-2}<br>[metric metric-value]  [metric-type  type-value]<br>[match (internal | external 1 |external 2)]<br>[tag tag-value] [route-map map-tag] [weightweight] [subnets]</p>
<p>（1）protocol变量表示源路由协议。源路由指该路由协议的路由是那些将被翻译成另一种协议的路由，protocol变量的可用值有：BGP、EIGRP、IGRP、OSPF、STATIC[IP]、CONNECTED、RIP。其中STATIC[IP]用于重分布IP静态路由给ISIS，CONNECTED表示OSPF和IS-IS重分布这些路由作为到达AS的外部路由。</p>
<p>（2）protocol-id是AS的号码，level-1、level-2、level-1-2仅用于IS-IS。</p>
<p>（3）可选项metric后面跟着metric-value，以指定度量值，redistribute命令使用的metric  metric-value变量值优先于default-metric后面的缺省度量值。</p>
<p>（4）可选项metric-type type-value，当该关键字用于OSPF时，其变量缺省为一个type 2外部路由，并作为公布到OSPF AS中的默认路由。使用数值1表名缺省路由是一个type 1外部路由。</p>
<p>（5）可选关键字match和其参数internal、external 1、external 2专用于重分布到其他路由协议的OSPF路由。internal表示路由是AS的内部路由。external 1表示路由是type 1外部路由，external 2表示路由是type 2外部路由。</p>
<p>（6）可选项tag tag-value将一个32位的小数值赋给外部路由。tag-value不能用于OSPF路由协议但是可以供ASBR使用。如果tag标记没有定义，当重分布BGP路由时，所使用的缺省标记是来自BGP路由的远程AS号码。其他路由协议的缺省标记为0。</p>
<p>（7）router-map map-tag 将过滤器用于源路由协议导入的路由。不指定router-map，则允许所有的路由被重分布。</p>
<p>（8）weight weight给重分布到BGP中的路由指定一个0-65535的整数。BGP使用weight值确定多条路径中的最佳路径。</p>
<p>（9）subnets用于重分布路由到OSPF，启用粒度重分布或者汇总重分布。</p>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验二-OSPF动态配合路由</title>
    <url>/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>熟掌握OSPF协议的配置方法：<br>掌握查看通过动态路由协议OSPF学习产生的路由；<br>熟悉广域网线缆的链接方式。</p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Cisco Packet Tracer</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>（1）新建Packet Tracer拓扑图（如图）<br>（2）设置主机的IP地址及子网掩码；（同实验一）<br>（3）用命令行方式配置各个路由器各接口的IP地址及子网掩码；（同实验一）<br>（4）OSPF方式动态配置路由，实现两个网络连通并检验连通性。</p>
<h1 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h1><ul>
<li>1.新建packet tracer网络拓扑图</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202133291.png" alt="image-20210528202133291"></p>
<ul>
<li>2.设置各主机IP地址与子网掩码，分别为：</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202142464.png" alt="image-20210528202142464" style="zoom:67%;"><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202145959.png" alt="image-20210528202145959" style="zoom:67%;"></p>
<ul>
<li>3.选择命令行选项卡进入设备配置命令行界面（ＣＬＩ），用命令行方式配置路由器各个接口IP地址。（同实验一）<ul>
<li>(1)回车：进入非特权模式 &gt;</li>
<li>(2)&gt;enable:进入特权模式 Router#</li>
<li>(3)#configure terminal:进入配置状态模式 Router(config)#</li>
<li>(4)(config)#interface fastEthernet 0/1：进入接口配置状态Router(config-if)#</li>
<li>(5)配置接口IP地址<br>(config-if)#ip address  202.168.1.254  255.255.255.0</li>
</ul>
</li>
</ul>
<ul>
<li>4.OSPF动态配置路由<ul>
<li>(1)先进入配置状态模式(config)#    (同3)</li>
<li>(2)OSPF动态配置路由表<br>–R3<br>(config)#router OSPF 100        //100是进程ID<br>(config-router)#network  192.168.1.0  0.0.0.255  area  1<br>(config-router)#network  192.168.4.0  0.0.0.255  area  1<br>–R1<br>(config)#router OSPF 100<br>(config-router)#network  192.168.4.0  0.0.0.255  area  1<br>(config-router)#network  192.168.5.0  0.0.0.255  area  0<br>–R0<br>(config)#router OSPF 100<br>(config-router)#network  192.168.5.0  0.0.0.255  area 0<br>(config-router)#network  192.168.6.0  0.0.0.255  area 0<br>–R2<br>(config)#router OSPF 100<br>(config-router)#network  192.168.6.0  0.0.0.255  area 0<br>(config-router)#network  192.168.3.0  0.0.0.255  area 2<br>–R4<br>(config)#router OSPF 100<br>(config-router)#network 192.168.3.0  0.0.0.255  area 2<br>(config-router)#network 192.168.7.0  0.0.0.255  area 2</li>
<li>(3)测试主机与默认网关之间、两个局域网之间的连通性<br>ping IP地址</li>
</ul>
</li>
</ul>
<h1 id="五、运行结果"><a href="#五、运行结果" class="headerlink" title="五、运行结果"></a>五、运行结果</h1><ul>
<li>（1）OSPF动态路由配置（以router3为例）</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202233400.png" alt="image-20210528202233400"></p>
<p>路由表</p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202238003.png" alt="image-20210528202238003"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202247398.png"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202303263.png" alt="image-20210528202303263"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202316860.png" alt="image-20210528202316860"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202320527.png" alt="image-20210528202320527"></p>
<ul>
<li>（2）测试网络连通性，在PC0上ping PC1</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202325845.png" alt="image-20210528202325845"></p>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>OSPF开放式最短路径优先协议，是目前网路中应用最广泛的路由协议之一。<br>属于内部网管路由协议，能够适应各种规模的网络环境，是典型的链路状态协议。<br>OSPF路由协议通过向全网扩散（洪泛法）本设备的链路状态信息，使网络中每台设备最终同步一个具有全网链路状态的数据库，然后路由器采用SPF算法，以自己为根，计算到达其他网络的最短路径，最终形成全网路由信息。</p>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验一-静态配置路由+RIP动态配置路由</title>
    <url>/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>熟悉广域网线缆的链接方式；<br>掌握路由器和主机各接口IP地址的配置；<br>掌握静态路由的配置方法和技巧，实现网络的连通性；<br>掌握RIP动态路由的配置方法和技巧，实现网络的连通性。</p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Cisco Packet Tracer</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>（1）新建Packet Tracer拓扑图，三个局域网段通过两台路由器连接，两个网段分别有两台主机通过交换机与路由器相连；<br>（2）设置四台主机的IP地址及子网掩码；<br>（3）通过配置线连接主机与路由器，用命令行方式配置两台路由器各接口的IP地址及子网掩码；<br>（4）静态方式配置路由，实现两个网络连通并检验连通性；<br>（5）RIP方式动态配置路由，实现两个网络连通并检验连通性。</p>
<h1 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h1><ul>
<li>1.新建packet tracer网络拓扑图</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps1.jpg" alt="img"></p>
<ul>
<li>2.设置各主机IP地址与子网掩码，分别为：</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps2.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps3-1622204035658.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps4.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps5.jpg" alt="img"></p>
<ul>
<li><p>3.选择命令行选项卡进入设备配置命令行界面（ＣＬＩ），用命令行方式配置路由器各个接口IP地址。</p>
<ul>
<li><p>(1)回车：进入非特权模式 &gt;</p>
</li>
<li><p>(2)&gt;enable:进入特权模式 Router#</p>
</li>
<li><p>(3)#configure terminal:进入配置状态模式 Router(config)#</p>
<p>​    也可以输入conf t    (技巧：输入命令关键词可以只输入前面几个字母(只要这几个字母能跟别的命令区别开即可,即最小匹配)，不用输全。也可输入命令的一部分，再按Tab键，系统会自动补全命令单词。)</p>
</li>
<li><p>(4)(config)#interface fastEthernet 0/1：进入接口配置状态Router(config-if)#<br>也可以输入in f 0/1；Inter fast 0/1；Interface faste 0/1</p>
</li>
<li><p>(5)配置接口IP地址<br>(config-if)#ip address  202.168.1.254  255.255.255.0</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>4.静态方式配置路由</p>
<ul>
<li>(1)先进入配置状态模式(config)#    (同3)</li>
<li>(2)静态配置路由表<br>(config)#ip route &lt;网络号&gt; &lt;掩码&gt; &lt;下一跳&gt;<br>如ip route 202.168.2.0 255.255.255.0 202.168.3.1</li>
<li>（3）.测试主机与默认网关之间、两个局域网之间的连通性<br>ping IP地址<br>如在PC0的命令提示符界面输入 &gt;ping 202.168.2.1</li>
</ul>
</li>
<li><p>5.RIP动态配置路由</p>
<ul>
<li>(1)先进入配置状态模式(config)#    (同3)</li>
<li>(2)RIP动态配置路由表<br>(config)#router RIP<br>(config-router)#network 192.168.1.0<br>(config-router)#network 192.168.3.0<br>(config-router)#ver 2<br>(config-router)#no auto-summary</li>
<li>（3）.测试主机与默认网关之间、两个局域网之间的连通性<br>ping IP地址</li>
</ul>
</li>
</ul>
<h1 id="五、运行结果"><a href="#五、运行结果" class="headerlink" title="五、运行结果"></a>五、运行结果</h1><ul>
<li>（1）配置IP地址（以router0为例）</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps6.jpg" alt="img"></p>
<ul>
<li>（2）静态路由配置（以router0为例）</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps7.jpg" alt="img"></p>
<p>路由表</p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps8.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps9.jpg" alt="img"></p>
<ul>
<li>（3）测试两个局域网主机间的连通性</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps10.jpg" alt="img" style="zoom: 67%;"><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps11.jpg" alt="img" style="zoom: 67%;"></p>
<ul>
<li>（4）RIP动态路由配置（以router0为例）</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps12.jpg" alt="img"></p>
<p>路由表</p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps13.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps14.jpg" alt="img"></p>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><ul>
<li>（1）有些命令只能在特定模式下使用，注意命令提示符的变化；只有当路由器的路由表信息完成配置后，局域网之间才算真正的连通。</li>
<li>（2）路由器属于网络层设备，能够根据IP包头的信息，选择一条最佳路径，将数据包转发出去。实现不同网段的主机之间的互相访问。路由器是根据路由表进行选路和转发的。而路由表里就是由一条条路由信息组成。</li>
<li>（3）生成路由表主要有两种方法：手工配置和动态配置，即静态路由协议配置和动态路由协议配置。</li>
<li>（4）静态路由是指由网络管理员手工配置的路由信息。静态路由除了具有简单、高效、可靠的优点外，它的另一个好处是网络安全保密性高。缺省路由可以看做是静态路由的一种特殊情况。当数据在查找路由表时，没有找到和目标相匹配的路由表项时，为数据指定默认路由。</li>
<li>（5）RIP(Routing Information Protocols,路由信息协议)是应用较早、使用较普遍的IGP内部网管协议，适用于小型同类网络，是距离矢量协议；</li>
<li>（6）RIP协议通过跳数作为衡量路径开销的，RIP协议里规定最大跳数为15（超过为不可达），其优点是实现简单，开销较小，缺点是网络规模较小，“坏消息传的慢”；</li>
<li>（7）RIP协议有两个版本：RIPv1和RIPv2，RIPv1属于有类路由协议，不支持VLSM，以广播形式进行路由信息的更新，更新周期为30秒；RIPv2属于无类路由协议，支持VLSM，以组播形式进行路由更细。</li>
</ul>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>《第一行代码-笔记》</title>
    <url>/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    <content><![CDATA[<div class="note warning modern"><p><strong>前言：</strong>目录结构还有待优化，可直接ctrl+F搜索有无需要了解的内容<br>本笔记属于个人初学android过程时总结，如有错误或者图片缺失，还请留言指正，十分感谢！<br>仅供学习参考，如需转载请注明来自[Durango]: <a href="http://www.durango.cn/">www.durango.cn</a></p>
</div>




<h1 id="第一章-第一行代码"><a href="#第一章-第一行代码" class="headerlink" title="第一章     第一行代码"></a>第一章     <strong>第一行代码</strong></h1><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><h3 id="Linux内核层、系统运行库、应用架构层、应用层"><a href="#Linux内核层、系统运行库、应用架构层、应用层" class="headerlink" title="Linux内核层、系统运行库、应用架构层、应用层"></a>Linux内核层、系统运行库、应用架构层、应用层</h3><h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><h3 id="活动（Activity）、服务（Service）、广播接收器（Broadcast-Receiver）、-内容提供者（Content-Provider"><a href="#活动（Activity）、服务（Service）、广播接收器（Broadcast-Receiver）、-内容提供者（Content-Provider" class="headerlink" title="活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、        内容提供者（Content Provider)"></a>活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、        内容提供者（Content Provider)</h3><h2 id="APP目录"><a href="#APP目录" class="headerlink" title="APP目录"></a>APP目录</h2><ul>
<li>1.build: 一些编译时自动生成的文件</li>
</ul>
<h4 id="2-libs-第三方jar包"><a href="#2-libs-第三方jar包" class="headerlink" title="2.libs: 第三方jar包"></a>2.libs: 第三方jar包</h4><h4 id="3-androidTest-测试用例，自动化监测"><a href="#3-androidTest-测试用例，自动化监测" class="headerlink" title="3.androidTest: 测试用例，自动化监测"></a>3.androidTest: 测试用例，自动化监测</h4><h4 id="4-java-放置Java代码"><a href="#4-java-放置Java代码" class="headerlink" title="4.java: 放置Java代码"></a>4.<font color="red">java</font>: 放置Java代码</h4><h4 id="5-res-资源文件"><a href="#5-res-资源文件" class="headerlink" title="5.res: 资源文件"></a>5<font color="red">.res</font>: 资源文件</h4><p>​                drawable: 图片</p>
<p>​                layout: 布局文件</p>
<p>​                values: 字符串</p>
<h4 id="6-AndroidMainfest-xml-项目配置文件，四大活动必须在此注册！"><a href="#6-AndroidMainfest-xml-项目配置文件，四大活动必须在此注册！" class="headerlink" title="6.AndroidMainfest.xml: 项目配置文件，四大活动必须在此注册！"></a>6.AndroidMainfest.xml: 项目配置文件，四大活动必须在此注册！</h4><p>​    ……</p>
<h2 id="主活动"><a href="#主活动" class="headerlink" title="主活动"></a>主活动</h2><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200912223928217.png" alt="image-20200912223928217"></p>
<h2 id="引入布局"><a href="#引入布局" class="headerlink" title="引入布局"></a><font color="red">引入布局</font></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setContentView( R.layout.hello_world_layout)</span><br></pre></td></tr></table></figure>



<h2 id="资源的引用"><a href="#资源的引用" class="headerlink" title="资源的引用"></a><font color="red">资源的引用</font></h2><h4 id="1-代码中"><a href="#1-代码中" class="headerlink" title="1.代码中"></a>1.代码中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R.string.hello_world</span><br></pre></td></tr></table></figure>

<p>​        R .类型 .名称</p>
<h4 id="2-XML中"><a href="#2-XML中" class="headerlink" title="2.XML中"></a>2.XML中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@.string.hello_world</span><br></pre></td></tr></table></figure>

<p>​    @ .类型 .名称</p>
<h3 id="定义id-id-名称"><a href="#定义id-id-名称" class="headerlink" title="定义id: @+id/名称"></a>定义id: @+id/名称</h3><h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><h4 id="（p26）"><a href="#（p26）" class="headerlink" title="（p26）"></a>（p26）</h4><h1 id="第二章-探究活动"><a href="#第二章-探究活动" class="headerlink" title="第二章 探究活动"></a>第二章 探究活动</h1><h2 id="活动是什么"><a href="#活动是什么" class="headerlink" title="活动是什么"></a>活动是什么</h2><h2 id="活动的基本用法"><a href="#活动的基本用法" class="headerlink" title="活动的基本用法"></a>活动的基本用法</h2><h3 id="一、手动创建活动"><a href="#一、手动创建活动" class="headerlink" title="一、手动创建活动"></a>一、手动创建活动</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172254284.png" alt="image-20200913172254284"></p>
<h3 id="二、创建和加载布局"><a href="#二、创建和加载布局" class="headerlink" title="二、创建和加载布局"></a>二、创建和加载布局</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172406723.png" alt="image-20200913172406723"></p>
<p>​                                                                                    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172431922.png" alt="image-20200913172431922"></p>
<h4 id="添加按钮："><a href="#添加按钮：" class="headerlink" title="添加按钮："></a><font color="orange">添加按钮：</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">	android:id=&quot;@+id/button_1&quot;</span><br><span class="line">	android:layout_width=&quot;match_parent&quot;</span><br><span class="line">	android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">	android:text=&quot;Button 1&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="加载布局："><a href="#加载布局：" class="headerlink" title="加载布局："></a><font color="orange">加载布局：</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setContentView(R.layout.布局文件名)</span><br></pre></td></tr></table></figure>

<h3 id="三、在AndroidManifest文件中注册"><a href="#三、在AndroidManifest文件中注册" class="headerlink" title="三、在AndroidManifest文件中注册"></a>三、在AndroidManifest文件中注册</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174606232.png" alt="image-20200913174606232"></p>
<h3 id="四、在活动中使用Toast提醒"><a href="#四、在活动中使用Toast提醒" class="headerlink" title="四、在活动中使用Toast提醒"></a>四、在活动中使用Toast提醒</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174713039.png" alt="image-20200913174713039"></p>
<h3 id="五、在活动中使用Menu"><a href="#五、在活动中使用Menu" class="headerlink" title="五、在活动中使用Menu"></a>五、在活动中使用Menu</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174848093.png" alt="image-20200913174848093"></h4><p>2.然后在main.xml文件中添加(创建两个菜单项)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;item</span><br><span class="line">	android:id=&quot;@+id/add_itme&quot;</span><br><span class="line">	android:title=&quot;Add&quot;/&gt;</span><br><span class="line">&lt;item</span><br><span class="line">	android:id=&quot;@+id/remove_itme&quot;</span><br><span class="line">	android:title=&quot;Remove&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-重写onCreateOptionMenu（）方法"><a href="#3-重写onCreateOptionMenu（）方法" class="headerlink" title="3.重写onCreateOptionMenu（）方法"></a>3.重写<font color="orange">onCreateOptionMenu（）</font>方法</h4><h4 id="在Java代码中使用快捷键-”Ctrl-O“"><a href="#在Java代码中使用快捷键-”Ctrl-O“" class="headerlink" title="在Java代码中使用快捷键 ”Ctrl+O“"></a>在Java代码中使用快捷键 ”Ctrl+O“</h4><p>​                                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913175533827.png" alt="image-20200913175533827"></p>
<h4 id="4-重写onOptionsItemSelected"><a href="#4-重写onOptionsItemSelected" class="headerlink" title="4.重写onOptionsItemSelected"></a>4.重写<font color="orange">onOptionsItemSelected</font></h4><p>​                                    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913180038921.png" alt="image-20200913180038921"></p>
<h3 id="六、摧毁一个活动"><a href="#六、摧毁一个活动" class="headerlink" title="六、摧毁一个活动"></a>六、摧毁一个活动</h3><h4 id="stop"><a href="#stop" class="headerlink" title="stop();"></a><font color="orange">stop();</font></h4><h2 id="使用Intent（意图）在活动之间穿梭"><a href="#使用Intent（意图）在活动之间穿梭" class="headerlink" title="使用Intent（意图）在活动之间穿梭"></a>使用Intent（意图）在活动之间穿梭</h2><h3 id="一、使用显式的Intent"><a href="#一、使用显式的Intent" class="headerlink" title="一、使用显式的Intent"></a>一、使用显式的Intent</h3><h4 id><a href="#" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913212452461.png" alt="image-20200913212452461"></h4><h4 id="首先构建一个Intent，传入FirstActivity-this作为上下文，传入SecondActicity-class作为目标活动，然后通过startActivity（）方法来执行这个Intent。"><a href="#首先构建一个Intent，传入FirstActivity-this作为上下文，传入SecondActicity-class作为目标活动，然后通过startActivity（）方法来执行这个Intent。" class="headerlink" title="首先构建一个Intent，传入FirstActivity.this作为上下文，传入SecondActicity.class作为目标活动，然后通过startActivity（）方法来执行这个Intent。"></a>首先构建一个Intent，传入FirstActivity.this作为<font color="orange">上下文</font>，传入SecondActicity.class作为<font color="orange">目标活动</font>，然后通过startActivity（）方法来执行这个Intent。</h4><h3 id="二、使用隐式的Intent（意图过滤器intent-filter"><a href="#二、使用隐式的Intent（意图过滤器intent-filter" class="headerlink" title="二、使用隐式的Intent（意图过滤器intent-filter)"></a>二、使用隐式的Intent（意图过滤器<font color="red">intent-filter</font>)</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913213406302.png" alt="image-20200913213406302"></h4><h4 id="-1"><a href="#-1" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913213734619.png" alt="image-20200913213734619"></h4><h4 id="2-DEFAULT是一种默认的category，在调用startActicity-方法时会自动将这个category添加到Intent中。"><a href="#2-DEFAULT是一种默认的category，在调用startActicity-方法时会自动将这个category添加到Intent中。" class="headerlink" title="2.DEFAULT是一种默认的category，在调用startActicity()方法时会自动将这个category添加到Intent中。"></a>2.DEFAULT是一种默认的category，在调用startActicity()方法时会自动将这个category添加到Intent中。</h4><h4 id="3-每个Intent只能指定一个action，却能指定多个category，这样增加："><a href="#3-每个Intent只能指定一个action，却能指定多个category，这样增加：" class="headerlink" title="3.每个Intent只能指定一个action，却能指定多个category，这样增加："></a>3.每个Intent只能指定一个action，却能指定多个category，这样增加：</h4><h4 id="intent-addCategory-“com-example-activity-MY-CATEGORY”-；"><a href="#intent-addCategory-“com-example-activity-MY-CATEGORY”-；" class="headerlink" title="intent.addCategory(“com.example.activity.MY_CATEGORY”)；"></a>intent.<font color="red">addCategory(“com.example.activity.MY_CATEGORY”)</font>；</h4><h4 id="4-然后在活动二的intent-filter中添加声明："><a href="#4-然后在活动二的intent-filter中添加声明：" class="headerlink" title="4.然后在活动二的intent-filter中添加声明："></a>4.然后在活动二的intent-filter中添加声明：</h4><h4 id="lt-category-android-name-”com-example-activity-MY-CATEGORY”"><a href="#lt-category-android-name-”com-example-activity-MY-CATEGORY”" class="headerlink" title="&lt;category android:name=”com.example.activity.MY_CATEGORY”"></a><font color="red">&lt;category android:name=”com.example.activity.MY_CATEGORY”</font></h4><h4 id="5-只有-lt-action-gt-和-lt-category-gt-同时匹配上-Intent中指定的-action-和-category-时，这个活动才能响应该Intent"><a href="#5-只有-lt-action-gt-和-lt-category-gt-同时匹配上-Intent中指定的-action-和-category-时，这个活动才能响应该Intent" class="headerlink" title="5.只有&lt;action&gt;和&lt;category&gt;同时匹配上 Intent中指定的 action 和 category 时，这个活动才能响应该Intent"></a>5.<font color="orange">只有&lt;action&gt;和&lt;category&gt;同时匹配上 Intent中指定的 action 和 category 时，这个活动才能响应该Intent</font></h4><h3 id="三、更多隐式的Intent"><a href="#三、更多隐式的Intent" class="headerlink" title="三、更多隐式的Intent"></a>三、更多隐式的Intent</h3><h4 id="1-使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动"><a href="#1-使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动" class="headerlink" title="1.使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动"></a>1.使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动</h4><p>​            <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913220158511.png" alt="image-20200913220158511"></p>
<h5 id="（1）这里我们首先指定了Intent的action是Intent-ACTION-VIEW，这是一个Android系统内置的动作，其常量值为-android-intent-action-VIEW。"><a href="#（1）这里我们首先指定了Intent的action是Intent-ACTION-VIEW，这是一个Android系统内置的动作，其常量值为-android-intent-action-VIEW。" class="headerlink" title="（1）这里我们首先指定了Intent的action是Intent.ACTION_VIEW，这是一个Android系统内置的动作，其常量值为                android.intent.action.VIEW。"></a>（1）这里我们首先指定了Intent的action是<font color="red">Intent.ACTION_VIEW</font>，这是一个Android系统内置的动作，其常量值为                android.intent.action.VIEW。</h5><h5 id="（2）然后通过Uri-parse-方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData-方法将这个uri对象-传递进去。"><a href="#（2）然后通过Uri-parse-方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData-方法将这个uri对象-传递进去。" class="headerlink" title="（2）然后通过Uri.parse()方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData()方法将这个uri对象                传递进去。"></a>（2）然后通过<font color="red">Uri.parse()</font>方法，将一个网址字符串解析成一个Uri对象，再调用Intent的<font color="red">setData()</font>方法将这个uri对象                传递进去。</h5><h5 id="（3）可能你会对setData-部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，-主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri-parse-方法中解析产生的。"><a href="#（3）可能你会对setData-部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，-主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri-parse-方法中解析产生的。" class="headerlink" title="（3）可能你会对setData()部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，                主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri.parse()方法中解析产生的。"></a>（3）可能你会对<font color="red">setData()</font>部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，                主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri.parse()方法中解析产生的。</h5><h4 id="2-与此对应，我们还可以在-lt-intent-filter-gt-标签中再配置一个-lt-data-gt-标签，用于更精确地"><a href="#2-与此对应，我们还可以在-lt-intent-filter-gt-标签中再配置一个-lt-data-gt-标签，用于更精确地" class="headerlink" title="2.与此对应，我们还可以在&lt;intent-filter&gt;标签中再配置一个&lt;data&gt;标签，用于更精确地"></a>2.与此对应，我们还可以在&lt;intent-filter&gt;标签中再配置一个&lt;<font color="red">data</font>&gt;标签，用于更精确地</h4><pre><code>            指定当前活动能够响应什么类型的数据。\&lt;data&gt;标签中主要可以配置以下内容。
            android:scheme。用于指定数据的协议部分，如上例中的http部分。
            android:host。用于指定数据的主机名部分，如上例中的www.baidu.com部分。
            android:port。用于指定数据的端口部分，一般紧随在主机名之后。
            android:path。用于指定主机名和端口之后的部分,如一段网址中跟在域名之后的内容。
            android:mimeType。用于指定可以处理的数据类型,允许使用通配符的方式进行指定。
</code></pre>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><h5 id="这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了"><a href="#这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了" class="headerlink" title="这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了"></a>这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了</h5><h3 id="四、向下一个活动传递数据"><a href="#四、向下一个活动传递数据" class="headerlink" title="四、向下一个活动传递数据"></a>四、<font color="red">向下一个活动传递数据</font></h3><h4 id="1-通过Intent的putExtra-方法携带数据"><a href="#1-通过Intent的putExtra-方法携带数据" class="headerlink" title="1.通过Intent的putExtra()方法携带数据"></a>1.通过Intent的<font color="orange">putExtra()</font>方法携带数据</h4><h4 id="-2"><a href="#-2" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915194843260.png" alt="image-20200915194843260"></h4><h6 id="putExtra-“extra-data”-data-第一个参数是“键”，第二个参数是“数据”"><a href="#putExtra-“extra-data”-data-第一个参数是“键”，第二个参数是“数据”" class="headerlink" title="*putExtra(“extra_data”, data)*第一个参数是“键”，第二个参数是“数据”"></a>*<font color="orange">putExtra(“extra_data”, data)</font>*第一个参数是<strong>“键”</strong>，第二个参数是“数据”</h6><h4 id="2-通过Intent的getStringExtra-键-获取数据"><a href="#2-通过Intent的getStringExtra-键-获取数据" class="headerlink" title="2.通过Intent的getStringExtra(键)获取数据"></a>2.通过Intent的<font color="orange">getStringExtra(键)</font>获取数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915200007173.png" alt="image-20200915200007173"></p>
<h5 id="getStringExtra-getIntExtra-getBooleanExtra"><a href="#getStringExtra-getIntExtra-getBooleanExtra" class="headerlink" title="getStringExtra() / getIntExtra() / getBooleanExtra()"></a><font color="orange">getStringExtra() / getIntExtra() / getBooleanExtra()</font></h5><h3 id="五、返回数据给上一个活动"><a href="#五、返回数据给上一个活动" class="headerlink" title="五、返回数据给上一个活动"></a>五、<font color="red">返回数据给上一个活动</font></h3><h4 id="1-通过startActivityForResult（）来启动SecondActivity"><a href="#1-通过startActivityForResult（）来启动SecondActivity" class="headerlink" title="1.通过startActivityForResult（）来启动SecondActivity"></a>1.通过<font color="orange">startActivityForResult（）</font>来启动SecondActivity</h4><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915213454637.png" alt="image-20200915213454637"></p>
<h4 id="2-使用setResult（）返回数据"><a href="#2-使用setResult（）返回数据" class="headerlink" title="2.使用setResult（）返回数据"></a>2.使用<font color="orange">setResult（）</font>返回数据</h4><p>​                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915213859847.png" alt="image-20200915213859847"></p>
<h4 id="3-在FirstActivity中重写-onActivityResult（）"><a href="#3-在FirstActivity中重写-onActivityResult（）" class="headerlink" title="3.在FirstActivity中重写 onActivityResult（）"></a>3.在FirstActivity中重写<font color="orange"> onActivityResult（）</font></h4><p>​                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915214529345.png" alt="image-20200915214529345"></p>
<ol>
<li>首先通过检查requCode来判断数据来源，（FirstActivity可能调用startActivityForResult()去启动很多不同的活动，每个活动都会回调到活动的onActivityResult()中）。</li>
<li>然后通过resultCode来判断处理结果是否成功（RESULT_OK|RESULT_CANCELED）</li>
<li>最后通过 getStringExtra(键)来获取data携带的数据。</li>
</ol>
<h3 id="六、Bundle与Intent结合传递大量数据"><a href="#六、Bundle与Intent结合传递大量数据" class="headerlink" title="六、Bundle与Intent结合传递大量数据"></a>六、<font color="cornflowerblue">Bundle与Intent结合传递大量数据</font></h3><h4 id="1-传数据"><a href="#1-传数据" class="headerlink" title="1,传数据"></a>1,传数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">bundle.putString(&quot;date_string&quot;,&quot;some thing you just typed&quot;);</span><br><span class="line">bundle.putInt(&quot;data_Int&quot;,256);</span><br><span class="line">Intent intent = new Intent(...);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h4 id="2-取数据"><a href="#2-取数据" class="headerlink" title="2.取数据"></a>2.取数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intent  intent = getIntent();</span><br><span class="line">Bundle bundle = indent.getExtres();</span><br><span class="line">String str = bundle.getString(&quot;data_string&quot;);</span><br><span class="line">int in = bundle.getInt(&quot;data_Int&quot;);</span><br></pre></td></tr></table></figure>



<h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><h3 id="一、返回栈"><a href="#一、返回栈" class="headerlink" title="一、返回栈"></a>一、返回栈</h3><p>其实Android是使用任务(Task）来管理活动的，一个任务就是一组存放在栈里的活动的集其实Android是使用任务(Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈(Back Stack )。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中人栈，并处于栈顶的位置。而每当我们按下Back键或调用finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个人栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。</p>
<h3 id="二、活动状态"><a href="#二、活动状态" class="headerlink" title="二、活动状态"></a>二、活动状态</h3><h4 id="1-运行状态"><a href="#1-运行状态" class="headerlink" title="1.运行状态"></a>1.<font color="cornflowerblue">运行状态</font></h4><h5 id="当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。"><a href="#当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。" class="headerlink" title="当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。"></a>当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。</h5><h4 id="2-暂停状态"><a href="#2-暂停状态" class="headerlink" title="2.暂停状态"></a>2.<font color="cornflowerblue">暂停状态</font></h4><h5 id="当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。"><a href="#当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。" class="headerlink" title="当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。"></a>当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。</h5><h4 id="3-停止状态"><a href="#3-停止状态" class="headerlink" title="3.停止状态"></a>3.<font color="cornflowerblue">停止状态</font></h4><h5 id="当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保-存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可-能会被系统回收。"><a href="#当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保-存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可-能会被系统回收。" class="headerlink" title="当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保    存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可    能会被系统回收。"></a>当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保    存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可    能会被系统回收。</h5><h4 id="4-摧毁状态"><a href="#4-摧毁状态" class="headerlink" title="4.摧毁状态"></a>4.<font color="cornflowerblue">摧毁状态</font></h4><h5 id="当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证-手机的内存充足。"><a href="#当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证-手机的内存充足。" class="headerlink" title="当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证    手机的内存充足。"></a>当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证    手机的内存充足。</h5><h3 id="三、活动的生存期"><a href="#三、活动的生存期" class="headerlink" title="三、活动的生存期"></a>三、活动的生存期</h3><h4 id="1-oncCreat-活动第一次被创建时调用"><a href="#1-oncCreat-活动第一次被创建时调用" class="headerlink" title="1.oncCreat(): 活动第一次被创建时调用"></a>1.oncCreat(): 活动第一次被创建时调用</h4><h4 id="2-onStart-在活动由不可见变为可见时调用"><a href="#2-onStart-在活动由不可见变为可见时调用" class="headerlink" title="2.onStart(): 在活动由不可见变为可见时调用"></a>2.onStart(): 在活动由不可见变为可见时调用</h4><h4 id="3-onResume-在活动准备好和用户进行交互时调用"><a href="#3-onResume-在活动准备好和用户进行交互时调用" class="headerlink" title="3.onResume(): 在活动准备好和用户进行交互时调用"></a>3.onResume(): 在活动准备好和用户进行交互时调用</h4><h4 id="4-onPause-在系统准备启动或者恢复另一个活动时调用"><a href="#4-onPause-在系统准备启动或者恢复另一个活动时调用" class="headerlink" title="4.onPause(): 在系统准备启动或者恢复另一个活动时调用"></a>4.onPause(): 在系统准备启动或者恢复另一个活动时调用</h4><h4 id="5-onStop-在活动完全不可见时调用"><a href="#5-onStop-在活动完全不可见时调用" class="headerlink" title="5.onStop(): 在活动完全不可见时调用"></a>5.onStop(): 在活动完全不可见时调用</h4><h4 id="6-onDestory-在活动被销毁时调用"><a href="#6-onDestory-在活动被销毁时调用" class="headerlink" title="6.onDestory(): 在活动被销毁时调用"></a>6.onDestory(): 在活动被销毁时调用</h4><h4 id="7-onRestart-在活动由停止状态变为运行状态时调用"><a href="#7-onRestart-在活动由停止状态变为运行状态时调用" class="headerlink" title="7.onRestart(): 在活动由停止状态变为运行状态时调用"></a>7.onRestart(): 在活动由停止状态变为运行状态时调用</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200919221411685.png" alt="image-20200919221411685" style="zoom: 67%;">

<p>​    完整生存期：onCreate() → onDestory()</p>
<p>​    可见生存期：onStart() → onStop()</p>
<p>​    前台生存期：onResume() → onPause()</p>
<h3 id="四、体验活动的生命周期"><a href="#四、体验活动的生命周期" class="headerlink" title="四、体验活动的生命周期"></a>四、体验活动的生命周期</h3><h4 id="1-新建两个活动分别为-NormalActicity-和-DialogActivity"><a href="#1-新建两个活动分别为-NormalActicity-和-DialogActivity" class="headerlink" title="1.新建两个活动分别为 NormalActicity 和 DialogActivity"></a>1.新建两个活动分别为 NormalActicity 和 DialogActivity</h4><h4 id="2-修改对话框活动的主题："><a href="#2-修改对话框活动的主题：" class="headerlink" title="2.修改对话框活动的主题："></a>2.修改对话框活动的主题：</h4><ol>
<li><h5 id="AppCompatActivity-android-theme-”-style-Theme-AppCompat-Dialog”"><a href="#AppCompatActivity-android-theme-”-style-Theme-AppCompat-Dialog”" class="headerlink" title="AppCompatActivity: android:theme=”@style/Theme.AppCompat.Dialog”"></a><font color="red">AppCompatActivity</font>: <strong>android:theme=”@style/Theme.AppCompat.Dialog”</strong></h5></li>
<li><h5 id="Activity-android-theme-”-android-style-Theme-Dialog”"><a href="#Activity-android-theme-”-android-style-Theme-Dialog”" class="headerlink" title="Activity:android:theme=”@android:style/Theme.Dialog”"></a><font color="red">Activity:android</font>:<strong>theme=”@android:style/Theme.Dialog”</strong></h5></li>
</ol>
<h4 id="3-在主活动中打印日志（充分利用日志过滤器）"><a href="#3-在主活动中打印日志（充分利用日志过滤器）" class="headerlink" title="3.在主活动中打印日志（充分利用日志过滤器）"></a>3.在主活动中打印日志（充分利用日志过滤器）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200919222550069.png" alt="image-20200919222550069"></p>
<h5 id="（1）可以看到，MainActivity-第一次被创建时会依次执行-onCreate-、onStart-和-onResume-方法；"><a href="#（1）可以看到，MainActivity-第一次被创建时会依次执行-onCreate-、onStart-和-onResume-方法；" class="headerlink" title="（1）可以看到，MainActivity 第一次被创建时会依次执行 onCreate()、onStart() 和 onResume()方法；"></a>（1）可以看到，MainActivity 第一次被创建时会依次执行 onCreate()、onStart() 和 onResume()方法；</h5><h5 id="（2）启动NormalActivity-会执行-onPause-和-onStop-因为NormalActivity已经完全遮住MainActivity了；"><a href="#（2）启动NormalActivity-会执行-onPause-和-onStop-因为NormalActivity已经完全遮住MainActivity了；" class="headerlink" title="（2）启动NormalActivity,会执行 onPause() 和 onStop(),因为NormalActivity已经完全遮住MainActivity了；"></a>（2）启动NormalActivity,会执行 onPause() 和 onStop(),因为NormalActivity已经完全遮住MainActivity了；</h5><h5 id="（3）返回MainActivity，会执行-onRestart-、onStart-和onResume"><a href="#（3）返回MainActivity，会执行-onRestart-、onStart-和onResume" class="headerlink" title="（3）返回MainActivity，会执行 onRestart()、onStart()和onResume();"></a>（3）返回MainActivity，会执行 onRestart()、onStart()和onResume();</h5><h5 id="（4）启动DialogActivity-只会执行onPause-方法，因为此时MainActivity没有完全遮住；"><a href="#（4）启动DialogActivity-只会执行onPause-方法，因为此时MainActivity没有完全遮住；" class="headerlink" title="（4）启动DialogActivity,只会执行onPause()方法，因为此时MainActivity没有完全遮住；"></a>（4）启动DialogActivity,只会执行onPause()方法，因为此时MainActivity没有完全遮住；</h5><h5 id="（5）返回MainActivity-只会执行onResume。"><a href="#（5）返回MainActivity-只会执行onResume。" class="headerlink" title="（5）返回MainActivity,只会执行onResume。"></a>（5）返回MainActivity,只会执行onResume。</h5><h3 id="五、活动被回收了怎么办"><a href="#五、活动被回收了怎么办" class="headerlink" title="五、活动被回收了怎么办"></a>五、活动被回收了怎么办</h3><h4 id="1-问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate-创建一个新的实例，造成数据的丢失。"><a href="#1-问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate-创建一个新的实例，造成数据的丢失。" class="headerlink" title="1.问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate()创建一个新的实例，造成数据的丢失。"></a>1.问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate()创建一个新的实例，造成数据的丢失。</h4><h4 id="2-通过onSaveInstanceState-回调方法保存数据"><a href="#2-通过onSaveInstanceState-回调方法保存数据" class="headerlink" title="2.通过onSaveInstanceState()回调方法保存数据"></a>2.通过<font color="red">onSaveInstanceState()</font>回调方法保存数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@0verride</span><br><span class="line">protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">	super.onSaveInstancestate(outState);</span><br><span class="line">	string tempData - &quot;Something you just typed&quot;;</span><br><span class="line">	outState.putString( &quot;data_key&quot; , tempData) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="-3"><a href="#-3" class="headerlink" title></a></h4><h4 id="3-在onCreate-中取值"><a href="#3-在onCreate-中取值" class="headerlink" title="3.在onCreate()中取值"></a>3.在onCreate()中取值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (savedInstancestate != null)&#123;</span><br><span class="line">	String tempData = savedInstanceState.getString(&quot;data_key&quot;);</span><br><span class="line">	Log.d(TAG,tempData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="活动的启动模式-（launchMode"><a href="#活动的启动模式-（launchMode" class="headerlink" title="活动的启动模式 （launchMode)"></a>活动的启动模式 （launchMode)</h2><h3 id="一、standard"><a href="#一、standard" class="headerlink" title="一、standard"></a>一、standard</h3><h4 id="1-standard是活动默认的启动模式"><a href="#1-standard是活动默认的启动模式" class="headerlink" title="1.standard是活动默认的启动模式"></a>1.standard是活动默认的启动模式</h4><p>​        每当启动一个新的活动，它就会在返回栈中人栈，并处于栈顶的位置。对于使用standard模式的活动，</p>
<p>​        系统不会在乎这个活动是否已经在返回栈中存在<font color="red">，每次启动都会创建该活动的一个新的实例</font>。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131226413.png" alt="image-20200922131226413" style="zoom: 67%;"></h4><h3 id="二、singleTop"><a href="#二、singleTop" class="headerlink" title="二、singleTop"></a>二、singleTop</h3><h4 id="1-当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。"><a href="#1-当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。" class="headerlink" title="1.当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。"></a>1.当活动的启动模式指定为singleTop，在启动活动时如果发现<font color="red">返回栈的栈顶已经是该活动</font>，则认为可以<font color="red">直接使用</font>它，不会再创建新的活动实例。</h4><h4 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131614840.png" alt="image-20200922131614840" style="zoom: 67%;"></h4><h3 id="三、singleTask"><a href="#三、singleTask" class="headerlink" title="三、singleTask"></a>三、singleTask</h3><h4 id="1-当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。"><a href="#1-当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。" class="headerlink" title="1.当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。"></a>1.当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则<font color="red">直接使用该实例，并把在这个活动之上的所有活动统统出栈</font>，如果没有发现就会创建一个新的活动实例。</h4><h4 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131805919.png" alt="image-20200922131805919" style="zoom: 67%;"></h4><h3 id="四、singleInstance"><a href="#四、singleInstance" class="headerlink" title="四、singleInstance"></a>四、singleInstance</h3><h4 id="1-指定为singleInstance的活动会启动一个新的返回栈，"><a href="#1-指定为singleInstance的活动会启动一个新的返回栈，" class="headerlink" title="1.指定为singleInstance的活动会启动一个新的返回栈，"></a>1.指定为singleInstance的活动会启动一个新的返回栈，</h4><p>在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了<font color="red">共享活动实例</font>的问题。</p>
<h4 id="2-3"><a href="#2-3" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922132137611.png" alt="image-20200922132137611" style="zoom:67%;"></h4><h2 id="活动的最佳实践"><a href="#活动的最佳实践" class="headerlink" title="活动的最佳实践"></a>活动的最佳实践</h2><h1 id="第三章-UI开发的点点滴滴"><a href="#第三章-UI开发的点点滴滴" class="headerlink" title="第三章 UI开发的点点滴滴"></a>第三章 UI开发的点点滴滴</h1><h2 id="如何编写程序界面"><a href="#如何编写程序界面" class="headerlink" title="如何编写程序界面"></a>如何编写程序界面</h2><h2 id="常用控件的使用方法"><a href="#常用控件的使用方法" class="headerlink" title="常用控件的使用方法"></a>常用控件的使用方法</h2><h3 id="一、TextView"><a href="#一、TextView" class="headerlink" title="一、TextView"></a>一、<font color="cornflowerblue">TextView</font></h3><h4 id="1-文本对齐方式-gravity"><a href="#1-文本对齐方式-gravity" class="headerlink" title="1.文本对齐方式(gravity)"></a>1.文本对齐方式(<font color="red">gravity</font>)</h4><h5 id="android-gravity-”center-top-bottom-left-right”"><a href="#android-gravity-”center-top-bottom-left-right”" class="headerlink" title="android: gravity=”center|top|bottom|left|right”"></a>android: gravity=”center|top|bottom|left|right”</h5><h4 id="2-文本颜色，大小（textColor、textSize）"><a href="#2-文本颜色，大小（textColor、textSize）" class="headerlink" title="2.文本颜色，大小（textColor、textSize）"></a>2.文本颜色，大小（<font color="red">textColor、textSize</font>）</h4><h5 id="字体以“sp”为单位"><a href="#字体以“sp”为单位" class="headerlink" title="字体以“sp”为单位"></a>字体以“sp”为单位</h5><h4 id="3-文本标签TextView其它的XML文件元素"><a href="#3-文本标签TextView其它的XML文件元素" class="headerlink" title="3.文本标签TextView其它的XML文件元素"></a>3.文本标签TextView其它的XML文件元素</h4><table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:autoLink</td>
<td>设置是否当文本为URL链接/email/电话号码/map时，文本显示为可单击的链接。可选值(none/web/email/phone/map/all)</td>
</tr>
<tr>
<td>android:autoText</td>
<td>如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。</td>
</tr>
<tr>
<td>android:linksClickable</td>
<td>设置链接是否单击连接，即使设置了autoLink。</td>
</tr>
<tr>
<td>android:maxLength</td>
<td>限制显示的文本长度，超出部分不显示。</td>
</tr>
<tr>
<td>android:lines</td>
<td>设置文本的行数，设置两行就显示两行，即使第二行没有数据。</td>
</tr>
<tr>
<td>android:maxLines</td>
<td>设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。</td>
</tr>
<tr>
<td>android:minLines</td>
<td>设置文本的最小行数，与lines类似。</td>
</tr>
<tr>
<td>android:lineSpacingExtra</td>
<td>设置行间距。</td>
</tr>
<tr>
<td>android:lineSpacingMultiplier</td>
<td>设置行间距的倍数。如”1.2”</td>
</tr>
<tr>
<td>android:textColor</td>
<td>设置文本颜色</td>
</tr>
<tr>
<td>android:textColorLink</td>
<td>文字链接的颜色.</td>
</tr>
<tr>
<td>android:textStyle</td>
<td>设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开</td>
</tr>
<tr>
<td>android:maxHeight</td>
<td>设置文本区域的最大高度</td>
</tr>
<tr>
<td>android:minHeight</td>
<td>设置文本区域的最小高度</td>
</tr>
<tr>
<td>android:minWidth</td>
<td>设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。</td>
</tr>
<tr>
<td>android:maxWidth</td>
<td>设置文本区域的最大宽度</td>
</tr>
</tbody></table>
<h3 id="二、Button"><a href="#二、Button" class="headerlink" title="二、Button"></a>二、<font color="cornflowerblue">Button</font></h3><h4 id="1-自动进行大小写转换（textAllCaps"><a href="#1-自动进行大小写转换（textAllCaps" class="headerlink" title="1.自动进行大小写转换（textAllCaps)"></a>1.自动进行大小写转换（<font color="red">textAllCaps</font>)</h4><h5 id="android-textALlCaps-”false-true”"><a href="#android-textALlCaps-”false-true”" class="headerlink" title="android: textALlCaps:”false|true”"></a>android: textALlCaps:”false|true”</h5><h4 id="2-4种事件监听器的注册方式"><a href="#2-4种事件监听器的注册方式" class="headerlink" title="2. 4种事件监听器的注册方式"></a>2. 4种事件监听器的注册方式</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141303023.png" alt="image-20200923141303023" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141336930.png" alt="image-20200923141336930" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141506965.png" alt="image-20200923141506965" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141521823.png" alt="image-20200923141521823" style="zoom:67%;">



<h3 id="三、EditText"><a href="#三、EditText" class="headerlink" title="三、EditText"></a>三、<font color="cornflowerblue">EditText</font></h3><h4 id="1-提示性文字（hint"><a href="#1-提示性文字（hint" class="headerlink" title="1.提示性文字（hint)"></a>1.提示性文字（<font color="red">hint</font>)</h4><h4 id="2-最大行数（maxLines）"><a href="#2-最大行数（maxLines）" class="headerlink" title="2.最大行数（maxLines）"></a>2.最大行数（<font color="red">maxLines</font>）</h4><h4 id="3-密码框（android-inputType-”TextPassword”）"><a href="#3-密码框（android-inputType-”TextPassword”）" class="headerlink" title="3.密码框（android: inputType=”TextPassword”）"></a>3.密码框（<font color="red">android: inputType=”TextPassword”</font>）</h4><h4 id="4-获取文本内容（-getText-toString-）"><a href="#4-获取文本内容（-getText-toString-）" class="headerlink" title="4.获取文本内容（,,, .getText().toString( )  ）"></a>4.获取文本内容（<font color="red">,,, .getText().toString( )</font>  ）</h4><h4 id="5-输入框EditText-其它的XML文件元素"><a href="#5-输入框EditText-其它的XML文件元素" class="headerlink" title="5.输入框EditText 其它的XML文件元素"></a>5.输入框EditText 其它的XML文件元素</h4><table>
<thead>
<tr>
<th><strong>属性名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>android:<strong>imeOptions</strong></td>
<td><strong>设置软键盘的<strong><strong>Enter</strong></strong>键</strong>。有如下值可设置：normal，actionUnspecified，actionNone，actionGo，actionSearch，actionSend，actionNext，actionDone，flagNoExtractUi，flagNoAccessoryAction，flagNoEnterAction。可用’|’设置多个。这里仅设置显示图标之用。</td>
</tr>
<tr>
<td>android:imeActionId</td>
<td>设置IME动作ID，在onEditorAction中捕获判断进行逻辑操作。</td>
</tr>
<tr>
<td>android:imeActionLabel</td>
<td>设置IME动作标签。但是不能保证一定会使用，猜想在输入法扩展的时候应该有用。</td>
</tr>
<tr>
<td>android:<strong>singleLine</strong></td>
<td>设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=”test_ singleLine “ android:singleLine=”true” android:layout_width=”20dp” 将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行</td>
</tr>
<tr>
<td>android:<strong>maxlines</strong></td>
<td>指定 EditText 的最大行数，当输入的内容超过指定最大行数时，文本就会向上滚动，而不继续拉伸EditText</td>
</tr>
</tbody></table>
<h3 id="四、ImageView"><a href="#四、ImageView" class="headerlink" title="四、ImageView"></a>四、<font color="cornflowerblue">ImageView</font></h3><h4 id="1-android-src"><a href="#1-android-src" class="headerlink" title="1.android:src"></a>1.android:src</h4><h4 id="2-android-background"><a href="#2-android-background" class="headerlink" title="2. android:background"></a>2. android:background</h4><h4 id="3-setImageResource-方法"><a href="#3-setImageResource-方法" class="headerlink" title="3.setImageResource()方法"></a>3.setImageResource()方法</h4><h3 id="五、ProgressBar-进度条"><a href="#五、ProgressBar-进度条" class="headerlink" title="五、ProgressBar (进度条)"></a>五、<font color="cornflowerblue">ProgressBar </font>(进度条)</h3><h4 id="1-（控件通用属性）visibility-”visiblle-invisible-gone”"><a href="#1-（控件通用属性）visibility-”visiblle-invisible-gone”" class="headerlink" title="1.（控件通用属性）visibility=”visiblle|invisible|gone”"></a>1.（控件通用属性）<font color="red">visibility</font>=”visiblle|invisible|gone”</h4><h4 id="2-代码中获取-控制控件可见性"><a href="#2-代码中获取-控制控件可见性" class="headerlink" title="2.代码中获取/控制控件可见性"></a>2.代码中获取/控制控件可见性</h4><p>​            获取：getVisibility()</p>
<p>​            设置：setVisibility(<font color="red">View.VISIBLE|View.INVISIBLE|View.GONE</font>)</p>
<h4 id="3-水平进度条"><a href="#3-水平进度条" class="headerlink" title="3.水平进度条"></a>3.水平进度条</h4><h5 id="（1）style-”-android-attr-progressBarStyleHorizontal”-类别"><a href="#（1）style-”-android-attr-progressBarStyleHorizontal”-类别" class="headerlink" title="（1）style=”?android:attr/progressBarStyleHorizontal”    //类别"></a>（1）style=”?android:attr/progressBarStyleHorizontal”    //类别</h5><h5 id="android-max-”100”-进度条最大值"><a href="#android-max-”100”-进度条最大值" class="headerlink" title="android:max=”100”    //进度条最大值"></a>android:max=”100”    //进度条最大值</h5><h5 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922172028074.png" alt="image-20200922172028074" style="zoom:50%;"></h5><h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><h4 id="-4"><a href="#-4" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141825784.png" alt="image-20200923141825784" style="zoom:50%;"></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141850913.png" alt="image-20200923141850913" style="zoom:50%;">

<h3 id="六、AlterDialog（对话框）"><a href="#六、AlterDialog（对话框）" class="headerlink" title="六、AlterDialog（对话框）"></a>六、<font color="cornflowerblue">AlterDialog</font>（对话框）</h3><h4 id="1-AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog-一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示"><a href="#1-AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog-一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示" class="headerlink" title="1.AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示:"></a>1.AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示:</h4><h4 id="2-4"><a href="#2-4" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922172454707.png" alt="image-20200922172454707" style="zoom:67%;"></h4><p>​            首先通过<font color="red">AlertDialog.Builder</font>创建一个AlertDialog 的实例,然后可以为这个对话框设置标题、<br>​    内容、可否取消等属性，接下来调用<font color="red">setPositiveButton()</font>方法为对话框设置确定按钮的点击<br>​    事件，调用<font color="red">setNegativeButton()</font>方法设置取消按钮的点击事件，最后调用<font color="red">show()</font>方法将对话<br>​    框显示出来。</p>
<h3 id="七、ProgressDialog-带进度条的提示框"><a href="#七、ProgressDialog-带进度条的提示框" class="headerlink" title="七、ProgressDialog(带进度条的提示框)"></a>七、<font color="cornflowerblue">ProgressDialog</font>(带进度条的提示框)</h3><h4 id="1-ProgressDialog-和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog-会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog-也比较相似"><a href="#1-ProgressDialog-和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog-会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog-也比较相似" class="headerlink" title="1.ProgressDialog 和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog 也比较相似"></a>1.ProgressDialog 和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog 也比较相似</h4><h4 id="2-5"><a href="#2-5" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922173459763.png" alt="image-20200922173459763" style="zoom:67%;"></h4><p>注意，如果在<font color="red">setCancelable()中传人了false</font>，表示ProgressDialog是不能通过Back键<br>取消掉的，这时你就一定要在代码中做好控制，当数据加载完成后必须要调用ProgressDialog 的<br>dismiss()方法来关闭对话框，否则ProgressDialog将会一直存在。</p>
<h3 id="八、RadioButton-单选按钮-和-Checkbox-复选框"><a href="#八、RadioButton-单选按钮-和-Checkbox-复选框" class="headerlink" title="八、RadioButton(单选按钮) 和 Checkbox(复选框)"></a>八、<font color="cornflowerblue">RadioButton(单选按钮) 和 Checkbox(复选框)</font></h3><h3 id="九、Spinner-下拉框"><a href="#九、Spinner-下拉框" class="headerlink" title="九、Spinner (下拉框)"></a>九、<font color="cornflowerblue">Spinner (下拉框)</font></h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142240994.png" alt="image-20200923142240994" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142315034.png" alt="image-20200923142315034" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142334764.png" alt="image-20200923142334764" style="zoom:67%;">



<h2 id="详解4种基本布局"><a href="#详解4种基本布局" class="headerlink" title="详解4种基本布局"></a>详解4种基本布局</h2><h3 id="一、线性布局（LinearLayout）"><a href="#一、线性布局（LinearLayout）" class="headerlink" title="一、线性布局（LinearLayout）"></a>一、线性布局（<font color="cornflowerblue">LinearLayout</font>）</h3><h4 id="1-排列方向orientation"><a href="#1-排列方向orientation" class="headerlink" title="1.排列方向orientation"></a>1.排列方向<font color="red">orientation</font></h4><h5 id="1-horizontal-2-vertical"><a href="#1-horizontal-2-vertical" class="headerlink" title="(1)horizontal        (2)vertical"></a>(1)horizontal        (2)vertical</h5><p>​    </p>
<h4 id="2-对齐方式"><a href="#2-对齐方式" class="headerlink" title="2.对齐方式"></a>2.对齐方式</h4><h5 id="（1）gravity-文字在控件中的对齐方式"><a href="#（1）gravity-文字在控件中的对齐方式" class="headerlink" title="（1）gravity: 文字在控件中的对齐方式"></a>（1）gravity: <font color="orange">文字在控件中</font>的对齐方式</h5><h5 id="（2）layout-gravity-控件在布局中的对齐方式"><a href="#（2）layout-gravity-控件在布局中的对齐方式" class="headerlink" title="（2）layout_gravity: 控件在布局中的对齐方式"></a>（2）<font color="red">layout_gravity</font>: <font color="orange">控件在布局中</font>的对齐方式</h5><p>​                top、bottom、left、right、center_vertical、center_horizontal</p>
<p>​        <strong>！注意</strong>：LinearLayout的排列方向是horizontal时，只有垂直方向上的对齐方式才会生效，因为此时    水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式。同样的道理，当LinearLayout的排列方向是vertical时，只有水平方向上的对齐方式才会生效。</p>
<h4 id="3-重要属性-layout-weight"><a href="#3-重要属性-layout-weight" class="headerlink" title="3.重要属性 layout_weight"></a>3.重要属性 <font color="red">layout_weight</font></h4><h5 id="1-允许我们使用比例的方式来指定控件的大小-它在手机屏幕的适配性方面可以起到非常重要"><a href="#1-允许我们使用比例的方式来指定控件的大小-它在手机屏幕的适配性方面可以起到非常重要" class="headerlink" title="(1)允许我们使用比例的方式来指定控件的大小,它在手机屏幕的适配性方面可以起到非常重要"></a>(1)允许我们使用<font color="red">比例的方式</font>来指定控件的大小,它在手机屏幕的适配性方面可以起到非常重要</h5><h5 id="2-定义水平-垂直方向的比例时，需要指定layout-width-”0dp”-layout-height-”0dp”"><a href="#2-定义水平-垂直方向的比例时，需要指定layout-width-”0dp”-layout-height-”0dp”" class="headerlink" title="(2)定义水平/垂直方向的比例时，需要指定layout_width=”0dp”/layout_height=”0dp”"></a>(2)定义水平/垂直方向的比例时，需要指定<font color="red">layout_width=”0dp”/layout_height=”0dp”</font></h5><h5 id="-5"><a href="#-5" class="headerlink" title></a></h5><h3 id="二、相对布局"><a href="#二、相对布局" class="headerlink" title="二、相对布局"></a>二、相对布局</h3><h4 id="1-相对于父布局进行定位"><a href="#1-相对于父布局进行定位" class="headerlink" title="1.相对于父布局进行定位"></a>1.相对于<font color="red">父布局</font>进行定位</h4><table>
<thead>
<tr>
<th align="left"><strong>属性声明</strong></th>
<th align="center"><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>android:layout_alignParentLeft</strong></td>
<td align="center">是否跟父布局左对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentRight</strong></td>
<td align="center">是否跟父布局右对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentTop</strong></td>
<td align="center">是否跟父布局顶部对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentBottom</strong></td>
<td align="center">是否跟父布局底部对齐</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerHorizontal</strong></td>
<td align="center">在父布局中水平居中</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerVertical</strong></td>
<td align="center">在父布局中垂直居中</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerInParent</strong></td>
<td align="center">在父布局的中间位置</td>
</tr>
</tbody></table>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922224343384.png" alt="image-20200922224343384" style="zoom: 33%;">



<h4 id="2-相对于兄弟组件定位"><a href="#2-相对于兄弟组件定位" class="headerlink" title="2.相对于兄弟组件定位"></a>2.相对于<font color="red">兄弟组件</font>定位</h4><p>​        </p>
<table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>android:layout_toRightOf</strong>=“控件id”</td>
<td>在指定控件右边</td>
</tr>
<tr>
<td><strong>android:layout_toLeftOf</strong>=“控件id”</td>
<td>在指定控件左边</td>
</tr>
<tr>
<td><strong>android:layout_above</strong>=“控件id”</td>
<td>在指定控件上边</td>
</tr>
<tr>
<td><strong>android:layout_below=“控件id”</strong></td>
<td>在指定控件下边</td>
</tr>
<tr>
<td><strong>android:layout_alignBaseline</strong>=“控件id”</td>
<td>与指定控件水平对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignLeft</strong>=“控件id”</td>
<td>与指定控件左对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignRight</strong>=“控件id”</td>
<td>与指定控件右对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignTop</strong>=“控件id”</td>
<td>与指定控件顶部对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignBottom</strong>=“控件id”</td>
<td>与指定控件底部对齐</td>
</tr>
</tbody></table>
<h4 id="3-margin-偏移-：设置组件与相对于的边距"><a href="#3-margin-偏移-：设置组件与相对于的边距" class="headerlink" title="3. margin(偏移)：设置组件与相对于的边距"></a>3.<font color="red"> margin(偏移)</font>：设置组件与相对于的边距</h4><table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>layout_margin</strong></td>
<td>设置组件上下左右的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginLeft</strong></td>
<td>设置组件离左边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginRight</strong></td>
<td>设置组件离右边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginTop</strong></td>
<td>设置组件离上边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginBottom</strong></td>
<td>设置组件离下边的偏移量</td>
</tr>
</tbody></table>
<h4 id="4-padding-填充-：设置组件内部元素间的边距"><a href="#4-padding-填充-：设置组件内部元素间的边距" class="headerlink" title="4.padding(填充)：设置组件内部元素间的边距"></a>4.<font color="red">padding(填充)</font>：设置组件内部元素间的边距</h4><table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>padding</strong></td>
<td>设置组件上下左右的偏移量</td>
</tr>
<tr>
<td><strong>paddingLeft</strong></td>
<td>设置组件离左边的偏移量</td>
</tr>
<tr>
<td><strong>paddingRight</strong></td>
<td>设置组件离右边的偏移量</td>
</tr>
<tr>
<td><strong>paddingTop</strong></td>
<td>设置组件离上边的偏移量</td>
</tr>
<tr>
<td><strong>paddingBottom</strong></td>
<td>设置组件离下边的偏移量</td>
</tr>
</tbody></table>
<h5 id="！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。"><a href="#！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。" class="headerlink" title="！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。"></a>！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。</h5><h3 id="三、帧布局"><a href="#三、帧布局" class="headerlink" title="三、帧布局"></a>三、帧布局</h3><h3 id="四、百分百布局"><a href="#四、百分百布局" class="headerlink" title="四、百分百布局"></a>四、百分百布局</h3><h4 id="1-percentFrameLayout-继承了FrameLayout的全部特性"><a href="#1-percentFrameLayout-继承了FrameLayout的全部特性" class="headerlink" title="1.percentFrameLayout: 继承了FrameLayout的全部特性"></a>1.<font color="red">percentFrameLayout</font>: 继承了FrameLayout的全部特性</h4><h4 id="percentRelativeLayout-继承了RelativeLayout的全部特性"><a href="#percentRelativeLayout-继承了RelativeLayout的全部特性" class="headerlink" title="percentRelativeLayout: 继承了RelativeLayout的全部特性"></a><font color="red">percentRelativeLayout</font>: 继承了RelativeLayout的全部特性</h4><h4 id="2-设置组件的宽高"><a href="#2-设置组件的宽高" class="headerlink" title="2.设置组件的宽高"></a>2.设置组件的宽高</h4><h5 id="app-layout-widthPercent-”-”"><a href="#app-layout-widthPercent-”-”" class="headerlink" title="app: layout_widthPercent=”..%”"></a>app: <font color="red">layout_widthPercent</font>=”..%”</h5><h5 id="app-layout-heightPercent-“-”"><a href="#app-layout-heightPercent-“-”" class="headerlink" title="app: layout_heightPercent=“..%”"></a>app: layout_heightPercent=“..%”</h5><h4 id="3-在项目的build-gradle中添加百分比布局库的依赖-保证百分比布局在Android所有系统版本上的兼容性"><a href="#3-在项目的build-gradle中添加百分比布局库的依赖-保证百分比布局在Android所有系统版本上的兼容性" class="headerlink" title="3.在项目的build.gradle中添加百分比布局库的依赖,保证百分比布局在Android所有系统版本上的兼容性"></a>3.在项目的build.gradle中添加百分比布局库的依赖,保证百分比布局在Android所有系统版本上的兼容性</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922230757044.png" alt="image-20200922230757044"></p>
<h4 id="4-使用百分比布局"><a href="#4-使用百分比布局" class="headerlink" title="4.使用百分比布局"></a>4.使用百分比布局</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922230933563.png" alt="image-20200922230933563"></p>
<h2 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h2><h3 id="1-引入布局"><a href="#1-引入布局" class="headerlink" title="1.引入布局"></a>1.引入布局</h3><h4 id="（1）创建一个标题栏布局title-xml文件"><a href="#（1）创建一个标题栏布局title-xml文件" class="headerlink" title="（1）创建一个标题栏布局title.xml文件"></a>（1）创建一个标题栏布局title.xml文件</h4><h4 id="（2）在活动中引用-lt-include-layout-“-layout-title”-gt"><a href="#（2）在活动中引用-lt-include-layout-“-layout-title”-gt" class="headerlink" title="（2）在活动中引用  &lt;include layout = “@layout/title”/ &gt;"></a>（2）在活动中引用  <font color="red">&lt;include layout = “@layout/title”/ &gt;</font></h4><h4 id="3-隐藏系统自带的标题栏"><a href="#3-隐藏系统自带的标题栏" class="headerlink" title="(3) 隐藏系统自带的标题栏"></a>(3) 隐藏系统自带的标题栏</h4><h4 id="ActionBar-actionbar-getSupportActionBar"><a href="#ActionBar-actionbar-getSupportActionBar" class="headerlink" title="ActionBar actionbar = getSupportActionBar("></a><font color="red">ActionBar actionbar = getSupportActionBar(</font></h4><pre><code>    &lt;font color=&#39;red&#39;&gt;if (actionbar !=null) &#123;&lt;/font&gt;
        &lt;font color=&#39;red&#39;&gt;actionbar.hide( );&lt;/font&gt;
    &lt;font color=&#39;red&#39;&gt;&#125;&lt;/font&gt;
</code></pre>
<h3 id="2-创建自定义控件（布局）"><a href="#2-创建自定义控件（布局）" class="headerlink" title="2.创建自定义控件（布局）"></a>2.创建自定义控件（布局）</h3><h4 id="（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题-但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。"><a href="#（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题-但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。" class="headerlink" title="（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题,但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。"></a>（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题,但是如果布局中有一些控件<font color="red">要求能够响应事件</font>，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用<font color="red">自定义控件</font>的方式来解决。</h4><h4 id="（2）创建一个自定义布局类-TitleLayout-包含组件的响应事件"><a href="#（2）创建一个自定义布局类-TitleLayout-包含组件的响应事件" class="headerlink" title="（2）创建一个自定义布局类 TitleLayout(包含组件的响应事件)"></a>（2）创建一个自定义布局类 TitleLayout(包含组件的响应事件)</h4><p>public class TitleLayout extends LinearLayout {</p>
<p>​    public TitleLayout(Context context，AttributeSet attrs) {<br>​            super(context,attrs);<br>​            <font color="red">LayoutInflater.from(context).inflate(R.layout.title, this);</font>    //动态加载布局文件</p>
<p>​                                                                        //布局id， 父布局</p>
<p>​            Button titleBack = (Button) findViewById(R.id.title_back);<br>​            Button titleEdit = (Button) findViewById(R.id.title_edit);<br>​            titleBack.setOnclickListener(new onclickListener(){<br>​                @override<br>​                public void onclick(View v) {<br>​                        <font color="red">( (Activity) getContext()).finish();</font>    //结束此次活动<br>​                }<br>​            });<br>​            titleEdit.setonclickListener(new OnclickListener() {<br>​                @override<br>​                public void onclick(View v){<br>​                Toast.makeText(getContext()，”You clicked Edit button”,<br>​                Toast.LENGTH_SHORT).show();<br>​                });</p>
<p>​        }</p>
<p>}</p>
<h4 id="3-在布局文件中添加这个自定义控件"><a href="#3-在布局文件中添加这个自定义控件" class="headerlink" title="3.在布局文件中添加这个自定义控件"></a>3.在布局文件中添加这个自定义控件</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200930140657613.png" alt="image-20200930140657613"></p>
<h5 id="添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我"><a href="#添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我" class="headerlink" title="添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我"></a>添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我</h5><pre><code>们需要指明&lt;font color=&#39;red&#39;&gt;控件的完整类名&lt;/font&gt;，&lt;font color=&#39;red&#39;&gt;包名在这里是不可以省略的&lt;/font&gt;。
</code></pre>
<h2 id="最常用和最难用的控件——ListView"><a href="#最常用和最难用的控件——ListView" class="headerlink" title="最常用和最难用的控件——ListView"></a>最常用和最难用的控件——ListView</h2><h3 id="一、ListView的简单用法"><a href="#一、ListView的简单用法" class="headerlink" title="一、ListView的简单用法"></a>一、ListView的简单用法</h3><h4 id="1-在布局中加入ListView控件"><a href="#1-在布局中加入ListView控件" class="headerlink" title="1.在布局中加入ListView控件"></a>1.在布局中加入ListView控件</h4><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193319537.png" alt="image-20201001193319537" style="zoom:67%;"></p>
<h4 id="2-准备数据（M）"><a href="#2-准备数据（M）" class="headerlink" title="2.准备数据（M）"></a>2.准备数据（M）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193518241.png" alt="image-20201001193518241"></p>
<h4 id="3-准备视图（V）"><a href="#3-准备视图（V）" class="headerlink" title="3.准备视图（V）"></a>3.准备视图（V）</h4><h5 id="ListView-listView-ListView-findViewById-R-id-list-view"><a href="#ListView-listView-ListView-findViewById-R-id-list-view" class="headerlink" title="ListView listView = (ListView) findViewById(R.id.list_view);"></a>ListView listView = (ListView) findViewById(R.id.list_view);</h5><h4 id="4-准备适配器-C"><a href="#4-准备适配器-C" class="headerlink" title="4.准备适配器(C)"></a>4.准备适配器(C)</h4><h5 id="ArrayAdapter-lt-String-gt-adapter-new-ArrayAdapter-lt-String-gt-MainActivity-this，-android-R-layout-simple-list-item-1-data"><a href="#ArrayAdapter-lt-String-gt-adapter-new-ArrayAdapter-lt-String-gt-MainActivity-this，-android-R-layout-simple-list-item-1-data" class="headerlink" title="ArrayAdapter&lt; String &gt;  adapter = new ArrayAdapter&lt; String&gt;(MainActivity.this，            android.R.layout.simple_list_item_1, data);"></a>ArrayAdapter&lt; String &gt;  adapter = new ArrayAdapter&lt; String&gt;(MainActivity.this，            android.R.layout.simple_list_item_1, data);</h5><ul>
<li>​    <font color="red">参数一：当前活动上下文</font></li>
<li>​    <font color="red">参数二：子项布局ID</font></li>
<li>​    <font color="red">参数三：数据数组</font></li>
</ul>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193946230.png" alt="image-20201001193946230" style="zoom:67%;">



<h3 id="二、定制ListView的界面"><a href="#二、定制ListView的界面" class="headerlink" title="二、定制ListView的界面"></a>二、定制ListView的界面</h3><h4 id="1-新建一个Fruit类，作为适配器的适配类型"><a href="#1-新建一个Fruit类，作为适配器的适配类型" class="headerlink" title="1.新建一个Fruit类，作为适配器的适配类型"></a>1.新建一个Fruit类，作为适配器的<font color="cornflowerblue">适配类型</font></h4><p>​    public class Fruit {<br>​            private String name;<br>​            private int imageId;</p>
<p>​            public Fruit(String name，int imageId) {<br>​                    this.name = name;<br>​                    this.imageId = imageId;<br>​            }<br>​            public String getName( ) {<br>​                    return name;</p>
<p>​            }</p>
<p>​            public int getImageId( ) {<br>​                    return imageId;</p>
<p>​            }</p>
<p>​    }</p>
<h4 id="2-自定义子项布局fruit-item-xml"><a href="#2-自定义子项布局fruit-item-xml" class="headerlink" title="2.自定义子项布局fruit_item.xml"></a>2.<font color="cornflowerblue">自定义子项布局</font>fruit_item.xml</h4><h5 id="-6"><a href="#-6" class="headerlink" title></a></h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201001194813625.png" alt="image-20201001194813625" style="zoom:67%;">



<h4 id="3-自定义适配器MyAdapter"><a href="#3-自定义适配器MyAdapter" class="headerlink" title="3.自定义适配器MyAdapter"></a>3.<font color="cornflowerblue">自定义适配器</font>MyAdapter</h4><p>​    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001195642103.png" alt="image-20201001195642103"></p>
<p>​    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001195931382.png" alt="image-20201001195931382"></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200025598.png" alt="image-20201001200025598" style="zoom:67%;">

<h4 id="-7"><a href="#-7" class="headerlink" title></a></h4><h4 id="4-初始化数据，创建数据列表"><a href="#4-初始化数据，创建数据列表" class="headerlink" title="4.初始化数据，创建数据列表"></a>4.初始化数据，创建数据列表</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200303132.png" alt="image-20201001200303132" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200312627.png" alt="image-20201001200312627" style="zoom: 80%;">



<h3 id="四、提升ListView的运行效率"><a href="#四、提升ListView的运行效率" class="headerlink" title="四、提升ListView的运行效率"></a>四、提升ListView的运行效率</h3><h4 id="1-重用convertView"><a href="#1-重用convertView" class="headerlink" title="1.重用convertView"></a>1.重用<font color="red">convertView</font></h4><h3 id="-8"><a href="#-8" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201004105237701.png" alt="image-20201004105237701" style="zoom: 80%;"></h3><h4 id="2-内部类ViewHolder对控件实例进行缓存"><a href="#2-内部类ViewHolder对控件实例进行缓存" class="headerlink" title="2.内部类ViewHolder对控件实例进行缓存"></a>2.内部类ViewHolder对控件实例进行缓存</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004105406460.png" alt="image-20201004105406460" style="zoom:80%;">

<h2 id="更强大的滚轮控件——RecyclerView"><a href="#更强大的滚轮控件——RecyclerView" class="headerlink" title="更强大的滚轮控件——RecyclerView"></a>更强大的滚轮控件——RecyclerView</h2><h3 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h3><h4 id="1-首先需要在项目的build-gradle中添加相应的依赖库"><a href="#1-首先需要在项目的build-gradle中添加相应的依赖库" class="headerlink" title="1.首先需要在项目的build.gradle中添加相应的依赖库"></a>1.首先需要在项目的build.gradle中添加相应的<font color="red">依赖库</font></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004130717161.png" alt="image-20201004130717161" style="zoom:80%;">

<h4 id="2-在布局中引用"><a href="#2-在布局中引用" class="headerlink" title="2.在布局中引用"></a>2.在布局中引用</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004130855069.png" alt="image-20201004130855069" style="zoom:80%;">



<h4 id="3-准备Fruit类、fruit-item-xml、"><a href="#3-准备Fruit类、fruit-item-xml、" class="headerlink" title="3.准备Fruit类、fruit_item.xml、"></a>3.准备Fruit类、fruit_item.xml、</h4><h4 id="4-为RecycleView准备一个适配器FruitAdapter-继承自RecyclerView-Adapter-并将泛型指定为FruitAdapter-ViewHolder"><a href="#4-为RecycleView准备一个适配器FruitAdapter-继承自RecyclerView-Adapter-并将泛型指定为FruitAdapter-ViewHolder" class="headerlink" title="4.为RecycleView准备一个适配器FruitAdapter,继承自RecyclerView.Adapter,并将泛型指定为FruitAdapter.ViewHolder"></a>4.为RecycleView准备一个适配器<font color="red">FruitAdapter</font>,继承自<font color="cornflowerblue">RecyclerView.Adapter,</font>并将泛型指定为<font color="cornflowerblue">FruitAdapter.ViewHolder</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004132129131.png" alt="image-20201004132129131"></p>
<h4 id="5-在活动中使用RecyclerView"><a href="#5-在活动中使用RecyclerView" class="headerlink" title="5.在活动中使用RecyclerView"></a>5.在活动中使用RecyclerView</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004160217803.png" alt="image-20201004160217803" style="zoom:80%;">

<h3 id="二、实现横向滚动和瀑布流布局"><a href="#二、实现横向滚动和瀑布流布局" class="headerlink" title="二、实现横向滚动和瀑布流布局"></a>二、实现横向滚动和瀑布流布局</h3><h4 id="1-横向滚动"><a href="#1-横向滚动" class="headerlink" title="1.横向滚动"></a>1.横向滚动</h4><h5 id="layoutManager-setOrientation-LineatLayoutManager-HORIZONTAL"><a href="#layoutManager-setOrientation-LineatLayoutManager-HORIZONTAL" class="headerlink" title="layoutManager.setOrientation(LineatLayoutManager.HORIZONTAL);"></a>layoutManager.<font color="red">setOrientation(LineatLayoutManager.HORIZONTAL);</font></h5><h4 id="2-瀑布流布局-StaggeredGridLayoutManager"><a href="#2-瀑布流布局-StaggeredGridLayoutManager" class="headerlink" title="2.瀑布流布局 StaggeredGridLayoutManager"></a>2.瀑布流布局 <font color="cornflowerblue">StaggeredGridLayoutManager</font></h4><h5 id="StaggeredGridLayoutManager-layoutManager-new-StaggeredGridLayoutManager-3-StaggeredGridLayoutManager-VERTICAL"><a href="#StaggeredGridLayoutManager-layoutManager-new-StaggeredGridLayoutManager-3-StaggeredGridLayoutManager-VERTICAL" class="headerlink" title="StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager (3, StaggeredGridLayoutManager.VERTICAL);"></a>StaggeredGridLayoutManager layoutManager = new <font color="red">StaggeredGridLayoutManager (3, StaggeredGridLayoutManager.VERTICAL)</font>;</h5><h5 id="recycleView-setLayoutManager-layoutManager"><a href="#recycleView-setLayoutManager-layoutManager" class="headerlink" title="recycleView.setLayoutManager(layoutManager);"></a>recycleView.setLayoutManager(layoutManager);</h5><p>​        </p>
<p>​    小技巧：设置不同长度文本</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004161014946.png" alt="image-20201004161014946" style="zoom:80%;">



<h3 id="三、RecyclerView的点击事件"><a href="#三、RecyclerView的点击事件" class="headerlink" title="三、RecyclerView的点击事件"></a>三、RecyclerView的点击事件</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004161141203.png" alt="image-20201004161141203"></p>
<h1 id="第四章-探究碎片"><a href="#第四章-探究碎片" class="headerlink" title="第四章 探究碎片"></a>第四章 探究碎片</h1><h2 id="碎片是什么"><a href="#碎片是什么" class="headerlink" title="碎片是什么"></a>碎片是什么</h2><h2 id="碎片的使用方式"><a href="#碎片的使用方式" class="headerlink" title="碎片的使用方式"></a>碎片的使用方式</h2><h3 id="一、静态使用Fragment"><a href="#一、静态使用Fragment" class="headerlink" title="一、静态使用Fragment"></a>一、<font color="cornflowerblue">静态使用</font>Fragment</h3><h4 id="1-这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。"><a href="#1-这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。" class="headerlink" title="1. 这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。"></a>1. 这是使用Fragment最简单的一种方式，把Fragment当成<font color="red">普通的控件</font>，直接写在Activity的布局文件中。</h4><h4 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h4><h5 id="（1）创建碎片布局文件-fragment-master-xml"><a href="#（1）创建碎片布局文件-fragment-master-xml" class="headerlink" title="（1）创建碎片布局文件 fragment_master.xml"></a>（1）创建碎片布局文件 <font color="orange">fragment_master.xml</font></h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153418988.png" alt="image-20201013153418988" style="zoom:80%;">

<h5 id="（2）创建碎片类MasterFragment-Java"><a href="#（2）创建碎片类MasterFragment-Java" class="headerlink" title="（2）创建碎片类MasterFragment.Java"></a>（2）创建碎片类<font color="orange">MasterFragment.Java</font></h5><p>​        使用inflater.inflate适配布局。实际应用中，也可以添加动态获取信息，绑定到布局控件中。</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153554997.png" alt="image-20201013153554997" style="zoom:80%;">

<p>​        ！补充：（1）（2）也可以通过<font color="red">向导新建</font>来实现</p>
<h5 id="（3）在布局文件中直接用创建好的Fragment控件"><a href="#（3）在布局文件中直接用创建好的Fragment控件" class="headerlink" title="（3）在布局文件中直接用创建好的Fragment控件"></a>（3）在布局文件中直接用创建好的Fragment控件</h5><p>​        要通过android:name 属性来显示的<font color="red">指明要添加的碎片类名</font></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153856622.png" alt="image-20201013153856622" style="zoom:80%;">



<h3 id="二、动态添加Fragment"><a href="#二、动态添加Fragment" class="headerlink" title="二、动态添加Fragment"></a>二、<font color="cornflowerblue">动态添加</font>Fragment</h3><h4 id="1-程序运行时根据具体情况，动态地添加Fragment到Activity活动中。"><a href="#1-程序运行时根据具体情况，动态地添加Fragment到Activity活动中。" class="headerlink" title="1.程序运行时根据具体情况，动态地添加Fragment到Activity活动中。"></a>1.程序运行时根据具体情况，<font color="red">动态地添加</font>Fragment到Activity活动中。</h4><h4 id="2-Fragment事务："><a href="#2-Fragment事务：" class="headerlink" title="2.Fragment事务："></a>2.<font color="orange">Fragment事务</font>：</h4><h5 id="（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。"><a href="#（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。" class="headerlink" title="（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。"></a>（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。</h5><pre><code>    （2）Android提供了&lt;font color=&#39;pink&#39;&gt;FragmentManager类&lt;/font&gt;管理Fragment：
    在Activity运行过程中，通过FragmentManager开启事务，通过调用&lt;font color=&#39;red&#39;&gt;add()，remove(), replace()&lt;/font&gt;实        现动态添加、删除、替换Fragement。
    FragmentManager使用&lt;font color=&#39;pink&#39;&gt;FragmentTransaction类&lt;/font&gt;来管理事务
</code></pre>
<h4 id="3-实现步骤"><a href="#3-实现步骤" class="headerlink" title="3.实现步骤"></a>3.实现步骤</h4><h5 id="（1）在上例基础上，新建一个碎片布局-fragment-another-xml及其类AnotherFragment-java"><a href="#（1）在上例基础上，新建一个碎片布局-fragment-another-xml及其类AnotherFragment-java" class="headerlink" title="（1）在上例基础上，新建一个碎片布局 fragment_another.xml及其类AnotherFragment.java"></a>（1）在上例基础上，新建一个碎片布局 fragment_another.xml及其类AnotherFragment.java</h5><h5 id="（2）修改MainActivity的布局文件acitivty-main-xml"><a href="#（2）修改MainActivity的布局文件acitivty-main-xml" class="headerlink" title="（2）修改MainActivity的布局文件acitivty_main.xml:"></a>（2）修改MainActivity的布局文件acitivty_main.xml:</h5><p>​            将右侧碎片替换成一个<font color="red">FrameLayout</font>布局。<br>​            <font color="orange">动态加载碎片时需要指定容器，一般使用FrameLayout。</font><br>​            随后可在代码中向FrameLayout中动态地添加碎片，在第一次运行时加载DetailFragement，单击按            钮后加载AnotherFragment</p>
<p>​        </p>
<h5 id="（3）在代码证动态加载碎片控件"><a href="#（3）在代码证动态加载碎片控件" class="headerlink" title="（3）在代码证动态加载碎片控件"></a>（3）在代码证动态加载碎片控件</h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155307418.png" alt="image-20201013155307418" style="zoom: 67%;">



<p>​        或者</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155506638.png" alt="image-20201013155506638" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155515431.png" alt="image-20201013155515431" style="zoom:80%;">

<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013160047336.png" alt="image-20201013160047336"></p>
<h4 id="4-在碎片中模拟返回栈"><a href="#4-在碎片中模拟返回栈" class="headerlink" title="4.在碎片中模拟返回栈"></a>4.在碎片中模拟返回栈</h4><h5 id="addToBackStack-用于将一个事务添加到返回栈"><a href="#addToBackStack-用于将一个事务添加到返回栈" class="headerlink" title="addToBackStack()用于将一个事务添加到返回栈"></a><font color="red">addToBackStack()</font>用于将一个事务添加到返回栈</h5><h4 id="5-碎片和活动之间进行通信"><a href="#5-碎片和活动之间进行通信" class="headerlink" title="5.碎片和活动之间进行通信"></a>5.碎片和活动之间进行通信</h4><h5 id="（1）在活动中获取碎片实例："><a href="#（1）在活动中获取碎片实例：" class="headerlink" title="（1）在活动中获取碎片实例："></a>（1）<font color="cornflowerblue">在活动中获取碎片实例：</font></h5><p>FramengtManager fm = getSupportFramengtManager();<br>DetailFragment frag = (DetailFragment)fm.<font color="red">findFragmentById</font>(R.id.fragment_detail);</p>
<h5 id="（2）在碎片中访问活动中的方法："><a href="#（2）在碎片中访问活动中的方法：" class="headerlink" title="（2）在碎片中访问活动中的方法："></a>（2）<font color="cornflowerblue">在碎片中访问活动中的方法：</font></h5><p>在碎片中直接通过调用getActivity()方法获得和当前碎片相关联的活动实例，例如：<br>MainActivity activity = (MainActivity)<font color="red">getActivity()</font>;</p>
<h2 id="碎片的生命周期"><a href="#碎片的生命周期" class="headerlink" title="碎片的生命周期"></a>碎片的生命周期</h2><h3 id="一、碎片的状态"><a href="#一、碎片的状态" class="headerlink" title="一、碎片的状态"></a>一、碎片的状态</h3><h4 id="1-运行状态："><a href="#1-运行状态：" class="headerlink" title="1.运行状态："></a>1.运行状态：</h4><p>当嵌入该Fragment的Activity是处于运行状态的，并且该Fragment是可见的，那么该Fragment是处于运行状态的。</p>
<h4 id="2-暂停状态："><a href="#2-暂停状态：" class="headerlink" title="2.暂停状态："></a>2.暂停状态：</h4><p>当嵌入该Fragment的Activity是处于暂停状态时，那么该Fragment也是处于暂停状态的。</p>
<h4 id="3-停止状态："><a href="#3-停止状态：" class="headerlink" title="3.停止状态："></a>3.停止状态：</h4><p>当嵌入该Fragment的Activity是处于停止状态时，那么该Fragment也会进入停止状态。<br>或者通过调用FragmentTransation的remove()、replace()方法将Fragment从Activity中移除，但如果在事务提交前调用addToBackStack()方法添加到返回栈，这时的碎片进入到停止状态。进入停止状态的碎片有可能被系统回收。但在回收前如果又被置于前台(从返回栈中返回)，将不需要被创建。</p>
<h4 id="4-销毁状态："><a href="#4-销毁状态：" class="headerlink" title="4.销毁状态："></a>4.销毁状态：</h4><p>当嵌入该Fragment的Activity是被销毁时，该Fragment进入到销毁状态。<br>或者通过调用FragmentTransation的remove()、replace()方法将Fragment从Activity中移除，但在事务提交前没有调用addToBackStack()方法添加到返回栈，这时的碎片进行到销毁状态。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194148649.png" alt="image-20201014194148649" style="zoom: 50%;"><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194253899.png" alt="image-20201014194253899" style="zoom: 67%;"></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194329244.png" alt="image-20201014194329244" style="zoom:67%;">



<h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><h3 id="layout-large-文件夹"><a href="#layout-large-文件夹" class="headerlink" title="layout - large 文件夹"></a>layout <font color="red">- large</font> 文件夹</h3><h3 id="layout-sw600dp文件夹"><a href="#layout-sw600dp文件夹" class="headerlink" title="layout - sw600dp文件夹"></a>layout<font color="red"> - sw600dp</font>文件夹</h3><h2 id="简易版的新闻应用"><a href="#简易版的新闻应用" class="headerlink" title="简易版的新闻应用"></a>简易版的新闻应用</h2><h3 id="一、准备一个新闻实体类-News-java"><a href="#一、准备一个新闻实体类-News-java" class="headerlink" title="一、准备一个新闻实体类 News.java"></a>一、准备一个新闻实体类 <font color="cornflowerblue">News.java</font></h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201014194855870.png" alt="image-20201014194855870" style="zoom:67%;">

<h3 id="二、接着新建布局文件news-content-frag-xml，用于作为内容碎片类的布局"><a href="#二、接着新建布局文件news-content-frag-xml，用于作为内容碎片类的布局" class="headerlink" title="二、接着新建布局文件news_content_frag.xml，用于作为内容碎片类的布局"></a>二、接着新建布局文件<font color="cornflowerblue">news_content_frag.xml</font>，用于作为<font color="cornflowerblue">内容碎片类</font>的布局</h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195315804.png" alt="image-20201014195315804" style="zoom:67%;">



<h3 id="三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment"><a href="#三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment" class="headerlink" title="三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment"></a>三、然后再新建一个<font color="cornflowerblue">内容碎片类NewsContentFragment</font>，继承自Fragment</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195546698.png" alt="image-20201014195546698"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195955104.png" alt="image-20201014195955104"></p>
<h3 id="四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击-com-example-fragmentbestpractice"><a href="#四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击-com-example-fragmentbestpractice" class="headerlink" title="四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击 com.example.fragmentbestpractice"></a>四、这样我们就把<font color="cornflowerblue">新闻内容的碎片和布局都创建好了</font>，但是它们都是在双页模式中使用的，如果<font color="red">想在单页模式中使用</font>的话，我们还需要再创建一个活动。右击 com.example.fragmentbestpractice</h3><p>包→New→Activity-→Empty Activity，新建一个NewsContentActivity，并将布局名指定成<br>news_content，然后修改news_content.xml中的代码，如下所示:</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014200437146.png" alt="image-20201014200437146"></p>
<h3 id="五、然后修改NewsContentActivity中的代码，如下所示"><a href="#五、然后修改NewsContentActivity中的代码，如下所示" class="headerlink" title="五、然后修改NewsContentActivity中的代码，如下所示:"></a>五、然后修改<font color="cornflowerblue">NewsContentActivity</font>中的代码，如下所示:</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014201305152.png" alt="image-20201014201305152"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014201739780.png" alt="image-20201014201739780"></p>
<h3 id="六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news-title-frag-xml"><a href="#六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news-title-frag-xml" class="headerlink" title="六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news title frag.xml"></a>六、接下来还需要再创建一个用于显示<font color="cornflowerblue">新闻列表碎片类的布局</font>，新建<font color="cornflowerblue">news title frag.xml</font></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202002701.png" alt="image-20201014202002701"></p>
<h3 id="七、新建news-item-xml作为RecyclerView子项的布局"><a href="#七、新建news-item-xml作为RecyclerView子项的布局" class="headerlink" title="七、新建news_item.xml作为RecyclerView子项的布局"></a>七、新建<font color="cornflowerblue">news_item.xml</font>作为RecyclerView子项的布局</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202257283.png" alt="image-20201014202257283"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202303375.png" alt="image-20201014202303375"></p>
<h3 id="八、既然新闻列表和子项的布局都已经创建好了-那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示"><a href="#八、既然新闻列表和子项的布局都已经创建好了-那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示" class="headerlink" title="八、既然新闻列表和子项的布局都已经创建好了,那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示:"></a>八、既然新闻列表和子项的布局都已经创建好了,那么接下来我们就需要一个用于展示新闻列表的地方。这里新建<font color="cornflowerblue">NewsTitleFragment</font>作为<font color="cornflowerblue">新闻列表的碎片类</font>，代码如下所示:</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014203519438.png" alt="image-20201014203519438"></p>
<h3 id="九、创建两个模式的主活动布局"><a href="#九、创建两个模式的主活动布局" class="headerlink" title="九、创建两个模式的主活动布局"></a>九、创建两个模式的<font color="cornflowerblue">主活动布局</font></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014203644781.png" alt="image-20201014203644781"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014204051184.png" alt="image-20201014204051184"></p>
<h3 id="十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示"><a href="#十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示" class="headerlink" title="十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示:"></a>十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中<font color="cornflowerblue">新建一个内部类NewsAdapter</font>来作为RecyclerView的<font color="cornflowerblue">适配器</font>，如下所示:</h3><h4 id="（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）"><a href="#（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）" class="headerlink" title="（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）"></a><font color="red">（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）</font></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014205746854.png" alt="image-20201014205746854" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210158025.png" alt="image-20201014210158025" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210210198.png" alt="image-20201014210210198" style="zoom:67%;">



<h3 id="十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示"><a href="#十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示" class="headerlink" title="十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示:"></a>十一、现在还剩最后一步收尾工作，就是向RecyclerView中<font color="cornflowerblue">填充数据</font>了。修改NewsTitle-Fragment中的代码，如下所示:</h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210535588.png" alt="image-20201014210535588" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210606503.png" alt="image-20201014210606503" style="zoom:67%;">







<h1 id="第五章-全局大喇叭——详解广播机制"><a href="#第五章-全局大喇叭——详解广播机制" class="headerlink" title="第五章 全局大喇叭——详解广播机制"></a>第五章 全局大喇叭——详解广播机制</h1><h2 id="广播机制简介"><a href="#广播机制简介" class="headerlink" title="广播机制简介"></a>广播机制简介</h2><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117133937067.png" alt="image-20201117133937067"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117134653797.png" alt="image-20201117134653797"></p>
<h3 id="一、一种传输信息的机制"><a href="#一、一种传输信息的机制" class="headerlink" title="一、一种传输信息的机制"></a>一、一种传输信息的机制</h3><h4 id="广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。"><a href="#广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。" class="headerlink" title="广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。"></a>广播消息可以是<font color="red">应用程序的数据信息</font>，也可以是<font color="red">Android的系统消息</font>，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。</h4><h4 id="Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。"><a href="#Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。" class="headerlink" title="Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。"></a>Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。</h4><h4 id="接收广播需要专门的广播接收器（Broadcast-Reciever）。"><a href="#接收广播需要专门的广播接收器（Broadcast-Reciever）。" class="headerlink" title="接收广播需要专门的广播接收器（Broadcast Reciever）。"></a>接收广播需要专门的广播接收器（Broadcast Reciever）。</h4><h4 id="广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。"><a href="#广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。" class="headerlink" title="广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。"></a>广播接收器通过<font color="red">设置好的过滤器</font>监听特定的广播消息然后进行响应。</h4><h3 id="二、广播的类型"><a href="#二、广播的类型" class="headerlink" title="二、广播的类型"></a>二、广播的类型</h3><h4 id="1-标准广播"><a href="#1-标准广播" class="headerlink" title="1.标准广播"></a>1.<font color="cornflowerblue">标准广播</font></h4><p>​        异步执行。在广播发出之后，所有的广播接收器都会在同一时刻接收到这条广播消息。</p>
<h4 id="2-有序广播"><a href="#2-有序广播" class="headerlink" title="2.有序广播"></a>2.有序广播</h4><h5 id="同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。"><a href="#同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。" class="headerlink" title="同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。"></a>同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。</h5><h5 id="广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。"><a href="#广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。" class="headerlink" title="广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。"></a>广播接收器是有先后顺序，<font color="red">优先级</font>高的广播接收器就可以先收到广播消息。</h5><h5 id="优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。"><a href="#优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。" class="headerlink" title="优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。"></a>优先级高的广播接收器可以<font color="red">截断</font>正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。</h5><h2 id="BroadcastReceiver介绍"><a href="#BroadcastReceiver介绍" class="headerlink" title="BroadcastReceiver介绍"></a>BroadcastReceiver介绍</h2><h3 id="一、BroadcastReceiver"><a href="#一、BroadcastReceiver" class="headerlink" title="一、BroadcastReceiver"></a>一、BroadcastReceiver</h3><h4 id="1-本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。"><a href="#1-本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。" class="headerlink" title="1.本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。"></a>1.本质上是一种<font color="red">全局监听器</font>，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。</h4><h4 id="2-BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如："><a href="#2-BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如：" class="headerlink" title="2. BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如："></a>2. BroadcastReceiver用于<font color="red">接收指定的广播</font>，通过<font color="red">设置过滤器</font>监听感兴趣的广播消息后进行响应，例如：</h4><p>启动Activity作为响应，或者通过NotificationManager提醒用户，或者启动Service等等。<br>自身并不实现图形用户界面。</p>
<h3 id="二、Broadcast开发过程"><a href="#二、Broadcast开发过程" class="headerlink" title="二、Broadcast开发过程"></a>二、Broadcast开发过程</h3><h4 id="1-定义广播接收器"><a href="#1-定义广播接收器" class="headerlink" title="1.定义广播接收器"></a>1.<font color="cornflowerblue">定义广播接收器</font></h4><h5 id="继承BroadcastReceiver基类，实现onReceiver方法："><a href="#继承BroadcastReceiver基类，实现onReceiver方法：" class="headerlink" title="继承BroadcastReceiver基类，实现onReceiver方法："></a>继承BroadcastReceiver基类，实现onReceiver方法：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135128320.png" alt="image-20201117135128320"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135631266.png" alt="image-20201117135631266"></p>
<h4 id="2-注册广播接收器"><a href="#2-注册广播接收器" class="headerlink" title="2.注册广播接收器"></a>2.<font color="cornflowerblue">注册广播接收器</font></h4><h5 id="（1）静态注册："><a href="#（1）静态注册：" class="headerlink" title="（1）静态注册："></a>（1）<font color="red">静态注册</font>：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135302391.png" alt="image-20201117135302391"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140345059.png" alt="image-20201117140345059"></p>
<h5 id="（2）动态注册：（可定义为内部类）"><a href="#（2）动态注册：（可定义为内部类）" class="headerlink" title="（2）动态注册：（可定义为内部类）"></a>（2）<font color="red">动态注册</font>：（可定义为内部类）</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135729313.png" alt="image-20201117135729313"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140330496.png" alt="image-20201117140330496"></p>
<h4 id="3-BroadcastReceiver响应"><a href="#3-BroadcastReceiver响应" class="headerlink" title="3.BroadcastReceiver响应"></a>3.BroadcastReceiver响应</h4><h5 id="（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive-方法，onReceive-方法执行完后，BroadcastReceiver的实例就会被销毁。"><a href="#（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive-方法，onReceive-方法执行完后，BroadcastReceiver的实例就会被销毁。" class="headerlink" title="（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive()方法，onReceive()方法执行完后，BroadcastReceiver的实例就会被销毁。"></a>（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并<font color="orange">自动触发它的onReceive()方法</font>，onReceive()方法执行完后，BroadcastReceiver的实例就会<font color="orange">被销毁</font>。</h5><h5 id="（2）-如果BroadcastReceiver的onReceive-方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive-方法里执行一些耗时的操作，否则会弹出ANR（Application-No-Response）对话框。"><a href="#（2）-如果BroadcastReceiver的onReceive-方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive-方法里执行一些耗时的操作，否则会弹出ANR（Application-No-Response）对话框。" class="headerlink" title="（2） 如果BroadcastReceiver的onReceive()方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive()方法里执行一些耗时的操作，否则会弹出ANR（Application No Response）对话框。"></a>（2） 如果BroadcastReceiver的onReceive()方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive()方法里执行一些耗时的操作，否则会弹出ANR（Application No Response）对话框。</h5><h2 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h2><h3 id="一、标准广播："><a href="#一、标准广播：" class="headerlink" title="一、标准广播："></a>一、标准广播：</h3><h4 id="1-是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast-Intent的传播。"><a href="#1-是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast-Intent的传播。" class="headerlink" title="1.是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播。"></a>1.是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播。</h4><h4 id="2-Intent-intent-new-Intent-“com-example-broadcasttest-MY-BROADCAST”"><a href="#2-Intent-intent-new-Intent-“com-example-broadcasttest-MY-BROADCAST”" class="headerlink" title="2. Intent intent = new Intent(“com.example.broadcasttest.MY_BROADCAST”);"></a>2. Intent intent = new Intent(“com.example.broadcasttest.MY_BROADCAST”);</h4><h4 id="sendBroadcast-intent"><a href="#sendBroadcast-intent" class="headerlink" title="sendBroadcast(intent);"></a><font color="red">sendBroadcast(intent);</font></h4><p>​            </p>
<h3 id="二、有序广播："><a href="#二、有序广播：" class="headerlink" title="二、有序广播："></a>二、有序广播：</h3><h4 id="1-该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast-方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras-Bundle-bundle-方法）。"><a href="#1-该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast-方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras-Bundle-bundle-方法）。" class="headerlink" title="1.该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast()方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras(Bundle bundle)方法）。"></a>1.该广播的接收者将<font color="red">按预先声明的优先级</font>依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast()方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras(Bundle bundle)方法）。</h4><h4 id="2-Intent-intent-new-Intent-“iet-jxufe-cn-android-OrderedBroadcastTest”"><a href="#2-Intent-intent-new-Intent-“iet-jxufe-cn-android-OrderedBroadcastTest”" class="headerlink" title="2. Intent intent=new Intent(“iet.jxufe.cn.android.OrderedBroadcastTest”);"></a>2. Intent intent=new Intent(“iet.jxufe.cn.android.OrderedBroadcastTest”);</h4><pre><code>        &lt;font color=&#39;red&#39;&gt;endOrderedBroadcast(intent,null);&lt;/font&gt;
    3.优先级设置
</code></pre>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140951277.png" alt="image-20201117140951277"></p>
<h2 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h2><h3 id="一、Android本地广播机制："><a href="#一、Android本地广播机制：" class="headerlink" title="一、Android本地广播机制："></a>一、Android本地广播机制：</h3><h4 id="广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播"><a href="#广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播" class="headerlink" title="广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播"></a>广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播</h4><h4 id="方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。"><a href="#方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。" class="headerlink" title="方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。"></a>方法：使用<font color="cornflowerblue">LocalBroadcastManager</font>对广播进行管理，对发送广播和注册广播接收器进行管理。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117141401456.png" alt="image-20201117141401456"></p>
<h1 id="第六章-数据存储全方案–持久化技术"><a href="#第六章-数据存储全方案–持久化技术" class="headerlink" title="第六章 数据存储全方案–持久化技术"></a>第六章 数据存储全方案–持久化技术</h1><h2 id="持久化技术简介"><a href="#持久化技术简介" class="headerlink" title="持久化技术简介"></a>持久化技术简介</h2><h3 id="1-数据存储方式"><a href="#1-数据存储方式" class="headerlink" title="1.数据存储方式"></a>1.数据存储方式</h3><ul>
<li><font color="red">文件存储</font></li>
<li><font color="red">SharedPreferences</font></li>
<li><font color="red">SQLite数据库</font></li>
</ul>
<h3 id="2-Android内部存储和外部存储"><a href="#2-Android内部存储和外部存储" class="headerlink" title="2.Android内部存储和外部存储"></a>2.Android内部存储和外部存储</h3><h4 id="（1）内存（Memory）："><a href="#（1）内存（Memory）：" class="headerlink" title="（1）内存（Memory）："></a>（1）内存（Memory）：</h4><p>​            RAM，类似于PC的内存条</p>
<h4 id="（2）内部存储（Internal-Storage）："><a href="#（2）内部存储（Internal-Storage）：" class="headerlink" title="（2）内部存储（Internal Storage）："></a>（2）内部存储（Internal Storage）：</h4><p>​            机身固有存储，类似于PC的硬盘 </p>
<h4 id="（3）外部存储（External-Storage）："><a href="#（3）外部存储（External-Storage）：" class="headerlink" title="（3）外部存储（External Storage）："></a>（3）外部存储（External Storage）：</h4><p>​                早期的Android设备(4.4之前) 指SDCard(扩展卡)，类似于PC上的U盘。</p>
<p>​        之后随着技术的进步，机身存储得到了快速增大(8G以上)，此时的外部存储是<font color="orange">概念级别的“外部存储”</font>，机        身<font color="red">固有的存储</font>有一部分被划分为“内部存储”，另一部分被划分为“外部存储”，但其实都是机身固有存储。        后期的外部存储也包括了SDCard。<br>​        所以不管Android手机是否有可移动的SDCard，他们总是有外部存储和内部存储。</p>
<h3 id="3-几个重要文件夹"><a href="#3-几个重要文件夹" class="headerlink" title="3.几个重要文件夹"></a>3.几个重要文件夹</h3><h4 id="打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹"><a href="#打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹" class="headerlink" title="打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：data文件夹、mnt文件夹、sdcard 文件夹、storage文件夹"></a>打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：<font color="red">data</font>文件夹、<font color="red">mnt</font>文件夹、<font color="red">sdcard</font> 文件夹、<font color="red">storage</font>文件夹</h4><h3 id="4-内部存储data"><a href="#4-内部存储data" class="headerlink" title="4.内部存储data"></a>4.<font color="cornflowerblue">内部存储data</font></h3><h4 id="1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："><a href="#1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：" class="headerlink" title="(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："></a>(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：</h4><ul>
<li><h5 id="文件夹app：存放着我们所有安装的app的apk文件"><a href="#文件夹app：存放着我们所有安装的app的apk文件" class="headerlink" title="文件夹app：存放着我们所有安装的app的apk文件"></a>文件夹<font color="red">app</font>：存放着我们所有安装的app的apk文件</h5></li>
<li><h5 id="文件夹data：一些包名，展开后，"><a href="#文件夹data：一些包名，展开后，" class="headerlink" title="文件夹data：一些包名，展开后，"></a>文件夹<font color="red">data</font>：一些包名，展开后，</h5><p>data/data/包名/<font color="orange">shared_prefs</font>(SharedPreference存储方式)</p>
<pre><code>data/data/包名/&lt;font color=&#39;orange&#39;&gt;databases&lt;/font&gt;（数据库存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;files&lt;/font&gt;（文件存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;cache&lt;/font&gt;
</code></pre>
</li>
</ul>
<h4 id="（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data"><a href="#（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data" class="headerlink" title="（2）路径的访问：Environment.getDataDirectory()获取内部存储根路径。/data"></a>（2）路径的访问：<font color="red">Environment.getDataDirectory()</font>获取内部存储根路径。/data</h4><h4 id="3-几点："><a href="#3-几点：" class="headerlink" title="(3)几点："></a>(3)几点：</h4><ol>
<li><h4 id="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"><a href="#系统默认只在内部存储中创建cache目录，并且此时cache目录是空的" class="headerlink" title="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"></a>系统默认<font color="orange">只在内部存储中创建cache目录</font>，并且此时cache目录是空的</h4></li>
<li><h4 id="此外，还可以根据需要自动创建：shared-prefs，databases，files目录"><a href="#此外，还可以根据需要自动创建：shared-prefs，databases，files目录" class="headerlink" title="此外，还可以根据需要自动创建：shared_prefs，databases，files目录"></a>此外，还可以根据需要<font color="orange">自动创建</font>：shared_prefs，databases，files目录</h4><p>但files可以<font color="orange">手动创建</font>，而shared_prefs，databases不能</p>
</li>
<li><h4 id="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"><a href="#别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。" class="headerlink" title="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"></a>别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。</h4></li>
</ol>
<h4 id="（4）内部存储的API"><a href="#（4）内部存储的API" class="headerlink" title="（4）内部存储的API"></a>（4）内部存储的API</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028153632199.png" alt="image-20201028153632199" style="zoom:80%;">





<h3 id="5-外部存储storage"><a href="#5-外部存储storage" class="headerlink" title="5.外部存储storage"></a>5.<font color="cornflowerblue">外部存储storage</font></h3><h4 id="1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"><a href="#1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。" class="headerlink" title="(1)一般是/storage/emulated/0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"></a>(1)一般是<font color="red">/storage/emulated/0</font>也有可能是其它文件夹，不同厂家不同版本有可能不一样。</h4><h4 id="storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy"><a href="#storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy" class="headerlink" title="/storage/sdcard0，/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy"></a><font color="red">/storage/sdcard0，</font>/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy</h4><ul>
<li><h5 id="公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等"><a href="#公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等" class="headerlink" title="公有目录：10大类，比如DCIM,Download等这些系统创建的文件夹。storage/emulated/0/Download等"></a><font color="red">公有目录</font>：10大类，比如DCIM,Download等这些系统创建的文件夹。<font color="orange">storage/emulated/0/Download</font>等</h5></li>
<li><h5 id="私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。"><a href="#私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。" class="headerlink" title="私有目录：Android文件夹，打开后有data文件夹。storage/emulated/0/Android/data/包名 文件夹：里面包含了许多包名组成的文件夹。"></a><font color="red">私有目录</font>：Android文件夹，打开后有<font color="red">data</font>文件夹。<font color="orange">storage/emulated/0/Android/data/包名 文件夹</font>：里面包含了许多包名组成的文件夹。</h5><h4 id="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"><a href="#（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。" class="headerlink" title="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"></a>（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的<font color="green">数据会一并删除</font>。</h4><p>如果直接在<font color="red">根目录</font>（<font color="orange">/storage/emulated/0</font>）下创建一个应用的文件夹，这样当该应用被卸载后，这些数据还保留在外部存储中，<font color="green">留下垃圾数据</font>。</p>
</li>
</ul>
<h4 id="（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。"><a href="#（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。" class="headerlink" title="（3）路径的访问：Environment.getExternalStorageDirectory()：获取机身存储的外部存储根路径。"></a>（3）路径的访问：<font color="red">Environment.getExternalStorageDirectory()</font>：获取机身存储的外部存储根路径。</h4><h4 id="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"><a href="#（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录" class="headerlink" title="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"></a>（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要<font color="red">手动创建私有目录</font></h4><h5 id="context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件"><a href="#context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件" class="headerlink" title="context.getExternalFilesDir(…)：在storage/emulated/0/Android/data/包名/files 中创建文件"></a>context.<font color="orange">getExternalFilesDir(…)</font>：在storage/emulated/0/Android/data/包名/files 中创建文件</h5><p>​    context.<font color="orange">getExternalCacheDir() </font>：在storage/emulated/0/Android/data/包名/cache 中创建文件</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028154738508.png" alt="image-20201028154738508" style="zoom:80%;">

<h3 id="6-内部存储与外部存储比较"><a href="#6-内部存储与外部存储比较" class="headerlink" title="6.内部存储与外部存储比较"></a>6.内部存储与外部存储比较</h3><p>​        外部存储目录空间较大，而内部存储空间有限<br>​        部分目录不会被自动创建，需要手动创建<br>​        两者<font color="red">都不需要权限</font><br>​        两者<font color="red">都会随着App的卸载而会自动被删除</font><br>​        对于内部存储，<font color="orange">只有</font>本App才可以访问<br>​        对于外部私有目录，本App可以直接访问，而其它App在自 Android 7.0 开始，系统对应用私有目录的访问权限进一步限制。其他 App 无法通过 file:// 这种形式的 Uri 直接读写该目录下的文件内容，而是通过 FileProvider 访问。<br>​        需要注意的是：由于用户可以直接查看并操作外部私有存储目录，那么也就意味着我们在操作这个目录下的文件的时候一定要做好异常和判空处理。</p>
<h3 id="7-数据存储与清除"><a href="#7-数据存储与清除" class="headerlink" title="7.数据存储与清除"></a>7.数据存储与清除</h3><h4 id="（1）数据存储："><a href="#（1）数据存储：" class="headerlink" title="（1）数据存储："></a>（1）数据存储：</h4><ul>
<li><p>默认情况下，存储在<font color="red">内部存储</font>：<br><font color="orange">data/app</font>：用户APP安装目录，存放apk；</p>
<p><font color="orange">data/data/包名/</font>：存放应用程序的数据</p>
</li>
<li><p>数据可以存放到指定的<font color="red">外部存储</font>：</p>
<p><font color="orange">/storage/sdcard</font>（共有目录）</p>
<p><font color="orange">/storage/sdcard0/Android/data/包名/</font>（私有目录）</p>
<h4 id="（2）清除数据："><a href="#（2）清除数据：" class="headerlink" title="（2）清除数据："></a>（2）清除数据：</h4></li>
</ul>
<h5 id="删除对应包中的cache，files，lib，shared-prefs，datbBases等等"><a href="#删除对应包中的cache，files，lib，shared-prefs，datbBases等等" class="headerlink" title="删除对应包中的cache，files，lib，shared_prefs，datbBases等等"></a>删除<font color="red">对应包中的</font><font color="cornflowerblue">cache</font>，files，lib，shared_prefs，datbBases等等</h5><p>​        （清除<font color="red">data/data/packagename中的</font>cache，files，lib， databases，shared_prefs等等）</p>
<p>​        （清除<font color="red">storage/emulated/0/Android/data/packagenam中的</font>文件）</p>
<h4 id="3-清除缓存："><a href="#3-清除缓存：" class="headerlink" title="(3) 清除缓存："></a>(3) 清除缓存：</h4><h5 id="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"><a href="#删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。" class="headerlink" title="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"></a>删除的是App运行过程中所产生的<font color="red">临时数据</font>，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在<font color="red">内存</font>中。</h5><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1.内部存储"></a>1.内部存储</h3><h4 id="（1）存："><a href="#（1）存：" class="headerlink" title="（1）存："></a>（1）存：</h4><p>方法1：使用 context.getFilesDir() 获取内部存储data/data/包名/files目录，然后创建文件，最后利用文件(全路径)新建FileOutputStream对象进行文件写入。<br>FileOutputStream fileOutputStream = new FileOutputStream(filePathName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160019136.png" alt="image-20201028160019136" style="zoom:80%;">

<p>方法2：直接使用Context.openFileOutput()方法(只需要文件名)获取FileOutputStream对象，进行文件写入。</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201028160258040.png" alt="image-20201028160258040" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160348975.png" alt="image-20201028160348975" style="zoom:80%;">

<h4 id="（2）取："><a href="#（2）取：" class="headerlink" title="（2）取："></a>（2）取：</h4><p>方法1：使用context.getFilesDir() 获取内部存储data/data/包名/files目录，然后利用文件(全路径)创建FileInputStream对象，进行内容读取。<br>FileInputStream fileInputStream = new FileInputStream(filePathName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/myBlog\source\_posts\安卓数据存储之文件存储\3.png" alt="image-20201028160834999" style="zoom:80%;">

<p>方法2：直接使用Context. openFileInput()方法(只需要文件名)获取FileInputStream对象，进行文件内容读取。<br>FileInputStream fileInputStream = openFileInput(fileName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160853113.png" alt="image-20201028160853113" style="zoom:80%;">

<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20210531224957336.png" alt="image-20210531224957336"></p>
<h3 id="2-外部存储"><a href="#2-外部存储" class="headerlink" title="2.外部存储"></a>2.外部存储</h3><h4 id="（1）外部根目录："><a href="#（1）外部根目录：" class="headerlink" title="（1）外部根目录："></a>（1）外部根目录：</h4><p>使用 <font color="red">Environment.getExternalStorageDirectory()</font> 获取</p>
<p>一般是/storage/emulated/0</p>
<h4 id="（2）外部公有目录："><a href="#（2）外部公有目录：" class="headerlink" title="（2）外部公有目录："></a>（2）外部公有目录：</h4><p>使用<font color="red">Environment.getExternalStoragePublicDirectory</font>获取</p>
<p>/storage/emulated/0/Music</p>
<p>针对外部<font color="red">共有目录、根目录</font>等位置的存取需要<font color="orange">添加权限</font>，Android 6.0 之后还需要做运行时权限申请。针对外部<font color="red">私有目录</font>的存取则<font color="orange">不需要添加权限</font>。<br>默认情况下，Android系统<font color="red">不会</font>为我们的App在外部存储中创建私有路径，需要<font color="red">手动创建</font>。<br>外部私有目录在App卸载时同步删除。</p>
<p>​    </p>
<h4 id="（3）获取外部私有目录"><a href="#（3）获取外部私有目录" class="headerlink" title="（3）获取外部私有目录"></a>（3）获取外部私有目录</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162002693.png" alt="image-20201028162002693" style="zoom:80%;">





<h4 id="（4）存："><a href="#（4）存：" class="headerlink" title="（4）存："></a>（4）存：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162420940.png" alt="image-20201028162420940"></p>
<h4 id="（5）取："><a href="#（5）取：" class="headerlink" title="（5）取："></a>（5）取：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162532386.png" alt="image-20201028162532386"></p>
<h2 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h2><h3 id="1-获取SharedPreferences对象"><a href="#1-获取SharedPreferences对象" class="headerlink" title="1.获取SharedPreferences对象"></a>1.获取<font color="cornflowerblue">SharedPreferences对象</font></h3><h4 id="1-Context-getSharedPreferences-方法"><a href="#1-Context-getSharedPreferences-方法" class="headerlink" title="(1) Context . getSharedPreferences()方法 "></a>(1) <font color="red">Context . getSharedPreferences()方法 </font></h4><p>​        此方法接受两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个。SharedPreferences 文件都是存放在 /data/data/&lt;包名&gt;/shared_prefs/ 目录下的。<br>​        第二个参数用于<font color="orange">指定操作模式</font>，主要为 MODE_PRIVATE（默认操作模式） 和 MODE_MULTI_PROCESS（多进程读写） 。</p>
<h4 id="2-Activity-类中的-getPreferences-方法"><a href="#2-Activity-类中的-getPreferences-方法" class="headerlink" title="(2)Activity 类中的 getPreferences() 方法"></a>(2)<font color="red">Activity 类中的 getPreferences() 方法</font></h4><p>这个方法和 Context 中的 getSharedPreferences() 方法类似，不过它只接收一个操作模式参数，使用这个方法时<font color="orange">会自动将当前活动的类名作为 SharedPreferences 的文件名</font>。</p>
<h4 id="3-PreferenceManager-类中的-getDefaultSharedPreferences-方法"><a href="#3-PreferenceManager-类中的-getDefaultSharedPreferences-方法" class="headerlink" title="(3) PreferenceManager 类中的 getDefaultSharedPreferences() 方法"></a>(3)<font color="red"> PreferenceManager 类中的 getDefaultSharedPreferences() 方法</font></h4><p>这是一个<font color="orange">静态方法</font>，它接收一个 Context 参数，并自动<font color="orange">使用当前应用程序的包名作为前缀</font>来命名 SharedPreferences 文件。</p>
<h3 id="2-通过SharedPreferences对象获取到Editor对象存数据"><a href="#2-通过SharedPreferences对象获取到Editor对象存数据" class="headerlink" title="2.通过SharedPreferences对象获取到Editor对象存数据"></a>2.通过SharedPreferences对象获取到<font color="cornflowerblue">Editor对象</font>存数据</h3><h4 id="（1）SharePreferences-Editor-editor-shared-edit"><a href="#（1）SharePreferences-Editor-editor-shared-edit" class="headerlink" title="（1）SharePreferences.Editor  editor = shared.edit();"></a>（1）SharePreferences.Editor  editor = shared.<font color="red">edit();</font></h4><p>调用 SharedPreferences 对象的 edit() 方法来获取一个 SharePreferences.Editor 对象。</p>
<h4 id="（2）editor-putString"><a href="#（2）editor-putString" class="headerlink" title="（2）editor.putString( )"></a>（2）editor<font color="red">.putString( )</font></h4><p>向 SharedPreferences.Editor 对象中添加数据，如果添加一个字符串则使用 editor.putString() 方法，以此类推。</p>
<h4 id="（3）editor-commit-editor-apply"><a href="#（3）editor-commit-editor-apply" class="headerlink" title="（3）editor.commit()  editor.apply()"></a>（3）<font color="red">editor.commit()  editor.apply()</font></h4><p>调用 editor.commit() 方法或者editor.apply()方法将添加的数据提交，从而完成数据存储操作。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164007127.png" alt="image-20201028164007127"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164138241.png" alt="image-20201028164138241"></p>
<h3 id="3-SharePreferences读取与删除数据"><a href="#3-SharePreferences读取与删除数据" class="headerlink" title="3.SharePreferences读取与删除数据"></a>3.SharePreferences<font color="cornflowerblue">读取与删除</font>数据</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164251857.png" alt="image-20201028164251857"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164334426.png" alt="image-20201028164334426"></p>
<h2 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h2><h3 id="一、创建数据库"><a href="#一、创建数据库" class="headerlink" title="一、创建数据库"></a>一、创建数据库</h3><h4 id="1-SQLiteOpenHelper-帮助类"><a href="#1-SQLiteOpenHelper-帮助类" class="headerlink" title="1.  SQLiteOpenHelper 帮助类"></a>1. <font color="cornflowerblue"> SQLiteOpenHelper</font> 帮助类</h4><ul>
<li><p>重写onCreate() 和 onUpgrade() 方法，分别在这两个方法实现创建、更新数据库的逻辑；</p>
</li>
<li><p>两个重要的实例方法：getReadableDatabase() 和 getWritableDatabese() ,这两个方法都可以创建或打开一个现有数据库（不存在则创建），并且返回一个可对数据库进行读/写操作的SQLiteDatabase对象</p>
</li>
<li><p>SQLiteOpenHelper构造方法（context, name, factory, version）</p>
<p>​        参数一：Context；    参数二：数据库名；    参数三：Cursor游标（null）    参数四：版本号</p>
<h4 id="2-新建-MyDatabaseHelper-继承自SQLiteOpenHelper"><a href="#2-新建-MyDatabaseHelper-继承自SQLiteOpenHelper" class="headerlink" title="2. 新建 MyDatabaseHelper 继承自SQLiteOpenHelper"></a>2. 新建 <font color="cornflowerblue">MyDatabaseHelper</font> 继承自SQLiteOpenHelper</h4><h5 id="重写oncreate"><a href="#重写oncreate" class="headerlink" title="重写oncreate()"></a>重写<font color="orange">oncreate()</font></h5></li>
</ul>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031132951195.png" alt="image-20201031132951195"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031133055726.png" alt="image-20201031133055726"></p>
<h4 id="3-创建数据库"><a href="#3-创建数据库" class="headerlink" title="3. 创建数据库"></a>3. 创建数据库</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031133544744.png" alt="image-20201031133544744"></p>
<h3 id="二、升级数据库"><a href="#二、升级数据库" class="headerlink" title="二、升级数据库"></a>二、升级数据库</h3><h4 id="1-在初始化时新执行一条SQL语句，新建一个Category表格"><a href="#1-在初始化时新执行一条SQL语句，新建一个Category表格" class="headerlink" title="1.在初始化时新执行一条SQL语句，新建一个Category表格"></a>1.在初始化时新执行一条SQL语句，新建一个Category表格</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134002931.png" alt="image-20201031134002931"></p>
<h4 id="2-重写onUpgrade"><a href="#2-重写onUpgrade" class="headerlink" title="2.重写onUpgrade()"></a>2.重写<font color="orange">onUpgrade()</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134120838.png" alt="image-20201031134120838"></p>
<p>​    升级时，如果表格存在，先删除掉再调用onCreate()重写创建</p>
<h4 id="3-更新数据库"><a href="#3-更新数据库" class="headerlink" title="3. 更新数据库"></a>3. 更新数据库</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134454199.png" alt="image-20201031134454199"></p>
<h3 id="三、添加数据-insert"><a href="#三、添加数据-insert" class="headerlink" title="三、添加数据 insert()"></a>三、添加数据 <font color="cornflowerblue">insert()</font></h3><h4 id="1-参数"><a href="#1-参数" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二：用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL，一般我们用不到这个功能，直接传入null即可</li>
<li>参数三：<font color="orange">ContentValues</font>对象，它提供了一系列的<font color="orange">put()</font>方法重载，用于向Contentvalues中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。</li>
</ul>
<h4 id="2-添加数据"><a href="#2-添加数据" class="headerlink" title="2.添加数据"></a>2.添加数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031140101787.png" alt="image-20201031140101787"></p>
<h3 id="四、更新数据-updata"><a href="#四、更新数据-updata" class="headerlink" title="四、更新数据 updata()"></a>四、更新数据 <font color="cornflowerblue">updata()</font></h3><h4 id="1-参数-1"><a href="#1-参数-1" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二：<font color="orange">ContentValues</font>对象，组装更新的数据</li>
<li>参数三、参数四：约束更新某一行或某几行的数据</li>
</ul>
<h4 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2.更新数据"></a>2.更新数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031140634673.png" alt="image-20201031140634673"></p>
<h5 id="更新Book表格中，name为“The-Da-Vinci-Code”-的价格为10-99"><a href="#更新Book表格中，name为“The-Da-Vinci-Code”-的价格为10-99" class="headerlink" title="更新Book表格中，name为“The Da Vinci Code” 的价格为10.99"></a>更新Book表格中，name为“The Da Vinci Code” 的价格为10.99</h5><h3 id="五、删除数据-delete"><a href="#五、删除数据-delete" class="headerlink" title="五、删除数据 delete()"></a>五、删除数据 <font color="cornflowerblue">delete()</font></h3><h4 id="1-参数-2"><a href="#1-参数-2" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二、参数三：约束删除某一行或某几行的数据</li>
</ul>
<h4 id="2-删除数据"><a href="#2-删除数据" class="headerlink" title="2.删除数据"></a>2.删除数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141159367.png" alt="image-20201031141159367"></p>
<h5 id="删除Book表格中，Pages大于500页的数据"><a href="#删除Book表格中，Pages大于500页的数据" class="headerlink" title="删除Book表格中，Pages大于500页的数据"></a>删除Book表格中，Pages大于500页的数据</h5><h3 id="六、查询数据-query"><a href="#六、查询数据-query" class="headerlink" title="六、查询数据 query()"></a>六、查询数据 <font color="cornflowerblue">query()</font></h3><h4 id="1-参数-3"><a href="#1-参数-3" class="headerlink" title="1.参数"></a>1.参数</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141347771.png" alt="image-20201031141347771"></p>
<h4 id="2-查询数据"><a href="#2-查询数据" class="headerlink" title="2.查询数据"></a>2.查询数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141717750.png" alt="image-20201031141717750"></p>
<h5 id="通过返回的Cursor对象来获取数据，moveToFirst-将游标移动到第一行位置；-getColunmIndex-获取某一列的位置索引"><a href="#通过返回的Cursor对象来获取数据，moveToFirst-将游标移动到第一行位置；-getColunmIndex-获取某一列的位置索引" class="headerlink" title="通过返回的Cursor对象来获取数据，moveToFirst():将游标移动到第一行位置； getColunmIndex():获取某一列的位置索引"></a>通过返回的Cursor对象来获取数据，<font color="orange">moveToFirst()</font>:将游标移动到第一行位置；<font color="orange"> getColunmIndex()</font>:获取某一列的位置索引</h5><h1 id="第七章-跨程序共享数据——探究内容提供器"><a href="#第七章-跨程序共享数据——探究内容提供器" class="headerlink" title="第七章 跨程序共享数据——探究内容提供器"></a>第七章 跨程序共享数据——探究内容提供器</h1><h2 id="内容提供器简介"><a href="#内容提供器简介" class="headerlink" title="内容提供器简介"></a>内容提供器简介</h2><h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><h3 id="一、危险权限"><a href="#一、危险权限" class="headerlink" title="一、危险权限"></a>一、危险权限</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201109144301759.png" alt="image-20201109144301759"></p>
<p>危险权限需要进行运行时权限处理，普通权限只要在AndroidMainfest.xml清单文件中添加一下权限声明就行</p>
<h3 id="二、运行时权限处理步骤"><a href="#二、运行时权限处理步骤" class="headerlink" title="二、运行时权限处理步骤"></a>二、<font color="cornflowerblue">运行时权限处理步骤</font></h3><h4 id="1-第一步：判断用户是否已经授权"><a href="#1-第一步：判断用户是否已经授权" class="headerlink" title="1. 第一步：判断用户是否已经授权"></a>1. <font color="pink">第一步</font>：判断用户是否已经授权</h4><h5 id="（1）ContextCompat-checkSelfPermission-MainActivity-this-Manifest-permission-READ-CONTACTS"><a href="#（1）ContextCompat-checkSelfPermission-MainActivity-this-Manifest-permission-READ-CONTACTS" class="headerlink" title="（1）ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_CONTACTS)"></a>（1）<font color="red">ContextCompat.checkSelfPermission</font>(MainActivity.this, Manifest.permission.READ_CONTACTS)</h5><h5 id="（2）参数一：Context；-参数二：权限名"><a href="#（2）参数一：Context；-参数二：权限名" class="headerlink" title="（2）参数一：Context； 参数二：权限名"></a>（2）参数一：Context； 参数二：权限名</h5><h5 id="（3）将其返回值与PackageManager-PERMISSION-GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。"><a href="#（3）将其返回值与PackageManager-PERMISSION-GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。" class="headerlink" title="（3）将其返回值与PackageManager.PERMISSION_GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。"></a>（3）将其返回值与<font color="red">PackageManager.PERMISSION_GRANTED</font>做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。</h5><h4 id="2-第二步：如果未授权，申请授权"><a href="#2-第二步：如果未授权，申请授权" class="headerlink" title="2.第二步：如果未授权，申请授权"></a>2.<font color="pink">第二步</font>：如果未授权，申请授权</h4><h5 id="（1）ActivityCompat-requestPermissions-MainActivity-this-new-String-Manifest-permission-READ-CONTACTS-1"><a href="#（1）ActivityCompat-requestPermissions-MainActivity-this-new-String-Manifest-permission-READ-CONTACTS-1" class="headerlink" title="（1）ActivityCompat.requestPermissions(MainActivity.this, new String[]{ Manifest.permission. READ_CONTACTS }, 1);"></a>（1）<font color="red">ActivityCompat.requestPermissions</font>(MainActivity.this, new String[]{ Manifest.permission. READ_CONTACTS }, 1);</h5><h5 id="（2）参数一：Activity的实例；-参数二：权限名的String数组；"><a href="#（2）参数一：Activity的实例；-参数二：权限名的String数组；" class="headerlink" title="（2）参数一：Activity的实例；    参数二：权限名的String数组；"></a>（2）参数一：Activity的实例；    参数二：权限名的String数组；</h5><h5 id="权限三：请求码，唯一即可"><a href="#权限三：请求码，唯一即可" class="headerlink" title="权限三：请求码，唯一即可"></a>权限三：请求码，唯一即可</h5><h5 id="（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult-方法，对授权结果进行处理。"><a href="#（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult-方法，对授权结果进行处理。" class="headerlink" title="（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult()方法，对授权结果进行处理。"></a>（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult()方法，对授权结果进行处理。</h5><h4 id="3-第三步：处理用户授权结果"><a href="#3-第三步：处理用户授权结果" class="headerlink" title="3.第三步：处理用户授权结果"></a>3.<font color="pink">第三步</font>：处理用户授权结果</h4><h5 id="（1）-onRequestPermissionsResult-方法中，用户授权的结果封装在grantResults参数当中"><a href="#（1）-onRequestPermissionsResult-方法中，用户授权的结果封装在grantResults参数当中" class="headerlink" title="（1） onRequestPermissionsResult()方法中，用户授权的结果封装在grantResults参数当中"></a>（1）<font color="red"> onRequestPermissionsResult()</font>方法中，用户授权的结果封装在grantResults参数当中</h5><h5 id="（2）grantResults-length-gt-0-amp-amp-grantResults-0-PackageManager-PERMISSION-GRANTED说明用户允许授权"><a href="#（2）grantResults-length-gt-0-amp-amp-grantResults-0-PackageManager-PERMISSION-GRANTED说明用户允许授权" class="headerlink" title="（2）grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED说明用户允许授权"></a>（2）grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED说明用户允许授权</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111130523831.png" alt="image-20201111130523831"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111130532512.png" alt="image-20201111130532512"></p>
<h2 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h2><h3 id="一、应用程序间的数据共享"><a href="#一、应用程序间的数据共享" class="headerlink" title="一、应用程序间的数据共享"></a>一、应用程序间的数据共享</h3><h4 id="1-三个重要类"><a href="#1-三个重要类" class="headerlink" title="1.三个重要类"></a>1.三个重要类</h4><h5 id="（1）ContentProvider：内容提供者。"><a href="#（1）ContentProvider：内容提供者。" class="headerlink" title="（1）ContentProvider：内容提供者。"></a>（1）<font color="cornflowerblue">ContentProvider</font>：内容提供者。</h5><p>内容提供者的用法一般有两种：<br>一种是使用<font color="orange">现有的</font>内容提供器来读取和操作相应程序中的数据。<br>另一种是<font color="orange">创建自己的</font>内容提供器对其数据提供外部访问接口。</p>
<h5 id="（2）ContentResolver：内容访问者"><a href="#（2）ContentResolver：内容访问者" class="headerlink" title="（2）ContentResolver：内容访问者"></a>（2）<font color="cornflowerblue">ContentResolver</font>：内容访问者</h5><p>提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作。</p>
<h5 id="（3）Uri："><a href="#（3）Uri：" class="headerlink" title="（3）Uri："></a>（3）<font color="cornflowerblue">Uri</font>：</h5><p>不同于SQLiteDatabase， ContentResolver中增删改查方法不接收表名参数，而是使用一个Uri参数代替，这个参数称为内容Uri。</p>
<p>格式：<font color="red">scheme:/ /Authority / path / id</font></p>
<ul>
<li>scheme： content://是一个标准的前缀，表明了这个数据被内容提供者管理，它不会修改。</li>
<li>authority：用于唯一标识一个ContentProvider，外部调用者可以根据此标识访问该ContentProvider。通常可将Authority设置为包名和类名的全称，以保证唯一性。例如包名是com.example.app，则authority可以命名为com.example.app.provider。</li>
<li>path：用于对同一应用程序的不同的数据进行区分，通常添加到authority的后面，例如/table1, /table2。</li>
<li>id：数据集中的每一条记录都有一个唯一的id。如果Uri中包含需要获取的记录的id，则只对该记录进行操作；如果Uri中没有id，则表示操作数据集中的所有记录。</li>
<li><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132317186.png" alt="image-20201111132317186"></li>
</ul>
<h4 id="2-使用ContentResolver访问共享数据"><a href="#2-使用ContentResolver访问共享数据" class="headerlink" title="2.使用ContentResolver访问共享数据"></a>2.使用ContentResolver访问共享数据</h4><h5 id="ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作"><a href="#ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作" class="headerlink" title="ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作"></a>ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行<font color="red">CRUD</font>操作</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132443856.png" alt="image-20201111132443856"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132412264.png" alt="image-20201111132412264"></p>
<h4 id="3-查询-获取-内容提供者中指定的数据"><a href="#3-查询-获取-内容提供者中指定的数据" class="headerlink" title="3. 查询(获取)内容提供者中指定的数据"></a>3. <font color="cornflowerblue">查询</font>(获取)内容提供者中指定的数据</h4><h5 id="（1）首先，确定访问目标"><a href="#（1）首先，确定访问目标" class="headerlink" title="（1）首先，确定访问目标"></a>（1）首先，确定访问目标</h5><h5 id="Uri-uri-Uri-parse-“content-com-example-app-provider-table1”"><a href="#Uri-uri-Uri-parse-“content-com-example-app-provider-table1”" class="headerlink" title="Uri uri = Uri.parse(“content://com.example.app.provider/table1”);"></a>Uri uri = Uri.parse(“content://com.example.app.provider/table1”);</h5><p>（2）然后，查询：<br>获取ContentResolver，将Uri对象作为参数，调用query()方法得到一个cursor对象</p>
<h5 id="Cursor-cursor-getContentResolver-query-uri-projection-selection-selectionArgs-sortOrder"><a href="#Cursor-cursor-getContentResolver-query-uri-projection-selection-selectionArgs-sortOrder" class="headerlink" title="Cursor  cursor = getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder);"></a><font color="red">Cursor  cursor = getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder);</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132642375.png" alt="image-20201111132642375"></p>
<h5 id="（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。"><a href="#（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。" class="headerlink" title="（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。"></a>（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133026107.png" alt="image-20201111133026107"></p>
<h4 id="4-向内容提供者共享的table1中添加数据"><a href="#4-向内容提供者共享的table1中添加数据" class="headerlink" title="4. 向内容提供者共享的table1中添加数据"></a>4. 向内容提供者共享的table1中<font color="cornflowerblue">添加</font>数据</h4><h5 id="将待添加的数据组装到ContentValues，然后调用ContentResolver类insert-方法，将uri和ContentValues作为参数传入。"><a href="#将待添加的数据组装到ContentValues，然后调用ContentResolver类insert-方法，将uri和ContentValues作为参数传入。" class="headerlink" title="将待添加的数据组装到ContentValues，然后调用ContentResolver类insert()方法，将uri和ContentValues作为参数传入。"></a>将待添加的数据组装到ContentValues，然后调用ContentResolver类insert()方法，将uri和ContentValues作为参数传入。</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133121157.png" alt="image-20201111133121157"></p>
<h4 id="5-向内容提供者共享的table1中更新数据"><a href="#5-向内容提供者共享的table1中更新数据" class="headerlink" title="5. 向内容提供者共享的table1中更新数据"></a>5. 向内容提供者共享的table1中<font color="cornflowerblue">更新</font>数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133151906.png" alt="image-20201111133151906"></p>
<h4 id="6-向内容提供者共享的table1中删除数据"><a href="#6-向内容提供者共享的table1中删除数据" class="headerlink" title="6.向内容提供者共享的table1中删除数据"></a>6.向内容提供者共享的table1中<font color="cornflowerblue">删除</font>数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133224468.png" alt="image-20201111133224468"></p>
<h2 id="创建自己的内容提供器-（P260）"><a href="#创建自己的内容提供器-（P260）" class="headerlink" title="创建自己的内容提供器*（P260）"></a>创建自己的内容提供器*（P260）</h2><h3 id="一、重写其中6个抽象方法"><a href="#一、重写其中6个抽象方法" class="headerlink" title="一、重写其中6个抽象方法"></a>一、重写其中6个抽象方法</h3><h4 id="1-public-boolean-onCreate-：ContentProvider创建时调用。"><a href="#1-public-boolean-onCreate-：ContentProvider创建时调用。" class="headerlink" title="1.public boolean onCreate()：ContentProvider创建时调用。"></a>1.public boolean <font color="cornflowerblue">onCreate()</font>：ContentProvider创建时调用。</h4><h4 id="2-public-int-delete-…-：根据传入的Uri删除指定条件下的数据。"><a href="#2-public-int-delete-…-：根据传入的Uri删除指定条件下的数据。" class="headerlink" title="2. public int delete(…)：根据传入的Uri删除指定条件下的数据。"></a>2. public int <font color="cornflowerblue">delete(…)</font>：根据传入的Uri删除指定条件下的数据。</h4><h4 id="3-public-Uri-insert-…-：根据传入的Uri插入数据。"><a href="#3-public-Uri-insert-…-：根据传入的Uri插入数据。" class="headerlink" title="3.public Uri insert(…)：根据传入的Uri插入数据。"></a>3.public Uri <font color="cornflowerblue">insert(…)</font>：根据传入的Uri插入数据。</h4><h4 id="4-public-Cursor-query-…-：根据传入的Uri查询指定的数据。"><a href="#4-public-Cursor-query-…-：根据传入的Uri查询指定的数据。" class="headerlink" title="4. public Cursor query(…)：根据传入的Uri查询指定的数据。"></a>4. public Cursor <font color="cornflowerblue">query(…)</font>：根据传入的Uri查询指定的数据。</h4><h4 id="5-public-int-update-…-：根据传入的Uri更新指定的数据。"><a href="#5-public-int-update-…-：根据传入的Uri更新指定的数据。" class="headerlink" title="5.public int update(…)：根据传入的Uri更新指定的数据。"></a>5.public int <font color="cornflowerblue">update(…)</font>：根据传入的Uri更新指定的数据。</h4><h4 id="6-getType"><a href="#6-getType" class="headerlink" title="6.getType()"></a>6.<font color="red">getType()</font></h4><h3 id="二、Uri参数：确定调用方希望访问的数据或表"><a href="#二、Uri参数：确定调用方希望访问的数据或表" class="headerlink" title="二、Uri参数：确定调用方希望访问的数据或表"></a>二、Uri参数：确定调用方希望访问的数据或表</h3><h4 id="表：content-com-example-app-privder-table1"><a href="#表：content-com-example-app-privder-table1" class="headerlink" title="表：content://com.example.app.privder/table1/"></a>表：content://com.example.app.privder/table1/</h4><h4 id="数据：content-com-example-app-privder-table1"><a href="#数据：content-com-example-app-privder-table1" class="headerlink" title="数据：content://com.example.app.privder/table1/#"></a>数据：content://com.example.app.privder/table1/#</h4><h3 id="三、通过UriMatcher类解析Uri参数，确定调用的数据或表"><a href="#三、通过UriMatcher类解析Uri参数，确定调用的数据或表" class="headerlink" title="三、通过UriMatcher类解析Uri参数，确定调用的数据或表"></a>三、通过UriMatcher类解析Uri参数，确定调用的数据或表</h3><h4 id="首先将需要共享的数据或数据表的内容URI用addURI-方法添加到自定义的内容提供器中"><a href="#首先将需要共享的数据或数据表的内容URI用addURI-方法添加到自定义的内容提供器中" class="headerlink" title="首先将需要共享的数据或数据表的内容URI用addURI()方法添加到自定义的内容提供器中"></a>首先将需要共享的数据或数据表的内容URI用<font color="red">addURI()方法</font>添加到自定义的内容提供器中</h4><h4 id="然后，在query-方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。"><a href="#然后，在query-方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。" class="headerlink" title="然后，在query()方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。"></a>然后，在query()方法中调用UriMatcher的<font color="red">match方法</font>对传入的Uri对象进行解析，<font color="orange">返回某个能匹配这个Uri对象的自定义代码</font>，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117132442004.png" alt="image-20201117132442004"></p>
<h3 id="四、getType-方法"><a href="#四、getType-方法" class="headerlink" title="四、getType()方法"></a>四、getType()方法</h3><p>一个内容URI所对应的MIME字符串由3部分组成：    </p>
<ul>
<li>以vnd开头</li>
<li>如果内容URI以路径结尾，则后接android.cursor.<font color="red">dir</font>/，如果内容URI以id结尾，则后接android.cursor<font color="red">.item</font>/</li>
<li>最后接上vnd.<authority>.<path></path></authority></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;<span class="comment">//教材265页</span></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Implement this to handle requests for the MIME type of the data</span></span><br><span class="line">       <span class="comment">// at the given URI.</span></span><br><span class="line">       <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">           <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.book&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.category&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.category&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="内容观察者ContentObersver"><a href="#内容观察者ContentObersver" class="headerlink" title="内容观察者ContentObersver"></a>内容观察者ContentObersver</h2><h3 id="一、ContentObserver（内容观察者）"><a href="#一、ContentObserver（内容观察者）" class="headerlink" title="一、ContentObserver（内容观察者）"></a>一、ContentObserver（内容观察者）</h3><h4 id="1-目的是观察-捕捉-特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器-Trigger-，当ContentObserver所观察的Uri发生变化时，便会触发它。"><a href="#1-目的是观察-捕捉-特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器-Trigger-，当ContentObserver所观察的Uri发生变化时，便会触发它。" class="headerlink" title="1.目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它。"></a>1.目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它。</h4><h4 id="2-触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri-MIME-Type有关的。"><a href="#2-触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri-MIME-Type有关的。" class="headerlink" title="2.触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri MIME Type有关的。"></a>2.触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri MIME Type有关的。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117133208124.png" alt="image-20201117133208124"></p>
<h4 id="3-当A应用程序的数据发生变化时，A应用程序调用notifyChange-方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange-方法。"><a href="#3-当A应用程序的数据发生变化时，A应用程序调用notifyChange-方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange-方法。" class="headerlink" title="3.当A应用程序的数据发生变化时，A应用程序调用notifyChange()方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange()方法。"></a>3.当A应用程序的数据发生变化时，A应用程序调用notifyChange()方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange()方法。</h4><h3 id="二、ContentObserver的几个常用的方法"><a href="#二、ContentObserver的几个常用的方法" class="headerlink" title="二、ContentObserver的几个常用的方法"></a>二、ContentObserver的几个常用的方法</h3><h4 id="1-构造方法-public-void-ContentObserver-Handler-handler"><a href="#1-构造方法-public-void-ContentObserver-Handler-handler" class="headerlink" title="1.构造方法 public void ContentObserver(Handler handler)"></a>1.构造方法 public void<font color="cornflowerblue"> ContentObserver(Handler handler)</font></h4><p>​        所有ContentObserver的派生类都需要调用该构造方法.<br>参数：handler，Handler对象。可以是主线程Handler(这时候可以更新UI )，也可以是任何Handler对象。</p>
<h4 id="2-void-onChange-boolean-selfChange"><a href="#2-void-onChange-boolean-selfChange" class="headerlink" title="2.void onChange(boolean selfChange)"></a>2.void <font color="cornflowerblue">onChange(boolean selfChange)</font></h4><p>​        观察到的Uri发生变化时，回调该方法去处理。<br>所有ContentObserver的派生类都需要重载该方法去处理逻辑。</p>
<h1 id="第八章-丰富你的程序——运用手机多媒体"><a href="#第八章-丰富你的程序——运用手机多媒体" class="headerlink" title="第八章 丰富你的程序——运用手机多媒体"></a>第八章 丰富你的程序——运用手机多媒体</h1><h2 id="播放多媒体文件"><a href="#播放多媒体文件" class="headerlink" title="播放多媒体文件"></a>播放多媒体文件</h2><h3 id="一、播放音频"><a href="#一、播放音频" class="headerlink" title="一、播放音频"></a>一、播放音频</h3><h4 id="1-MediaPlayer类"><a href="#1-MediaPlayer类" class="headerlink" title="1.MediaPlayer类"></a>1.<font color="cornflowerblue">MediaPlayer</font>类</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124130455169.png" alt="image-20201124130455169"></p>
<h4 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2.工作流程"></a>2.工作流程</h4><ul>
<li><h5 id="创建MediaPlayer对象；"><a href="#创建MediaPlayer对象；" class="headerlink" title="创建MediaPlayer对象；"></a>创建MediaPlayer对象；</h5></li>
<li><h5 id="初始化设置音频文件路径：setDataSource"><a href="#初始化设置音频文件路径：setDataSource" class="headerlink" title="初始化设置音频文件路径：setDataSource()"></a>初始化设置音频文件路径：setDataSource()</h5></li>
<li><h5 id="使MediaPlayer进入准备状态：pepare"><a href="#使MediaPlayer进入准备状态：pepare" class="headerlink" title="使MediaPlayer进入准备状态：pepare()"></a>使MediaPlayer进入准备状态：pepare()</h5></li>
<li><h5 id="开始播放音频：start"><a href="#开始播放音频：start" class="headerlink" title="开始播放音频：start()"></a>开始播放音频：start()</h5></li>
<li><h5 id="暂停播放音频：pause"><a href="#暂停播放音频：pause" class="headerlink" title="暂停播放音频：pause()"></a>暂停播放音频：pause()</h5></li>
<li><h5 id="停止播放音频：reset-setDataSource-pepare"><a href="#停止播放音频：reset-setDataSource-pepare" class="headerlink" title="停止播放音频：reset(), setDataSource(), pepare()"></a>停止播放音频：reset(), setDataSource(), pepare()</h5></li>
</ul>
<h1 id="第九章-看看精彩的技术——使用网络技术"><a href="#第九章-看看精彩的技术——使用网络技术" class="headerlink" title="第九章 看看精彩的技术——使用网络技术"></a>第九章 看看精彩的技术——使用网络技术</h1><h2 id="Android常见的网络通信方式"><a href="#Android常见的网络通信方式" class="headerlink" title="Android常见的网络通信方式"></a>Android常见的网络通信方式</h2><h3 id="一、基于TCP协议"><a href="#一、基于TCP协议" class="headerlink" title="一、基于TCP协议"></a>一、基于TCP协议</h3><p>（1）针对TCP的 Socket、ServerSocket<br>（2）针对UDP的DatagramSocket、DatagramPackage<br>（3）Apache Mina框架</p>
<h3 id="二、基于Http协议"><a href="#二、基于Http协议" class="headerlink" title="二、基于Http协议"></a>二、基于Http协议</h3><p>HttpURLConnection、HttpClient、AsyncHttpClient框架等</p>
<h3 id="三、直接使用-WebKit-访问网络"><a href="#三、直接使用-WebKit-访问网络" class="headerlink" title="三、直接使用 WebKit 访问网络"></a>三、直接使用 WebKit 访问网络</h3><h3 id="四、使用网络通信框架"><a href="#四、使用网络通信框架" class="headerlink" title="四、使用网络通信框架"></a>四、使用网络通信框架</h3><p>OkHttp，Volley，Retrofit</p>
<h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><h3 id="一、通信协议"><a href="#一、通信协议" class="headerlink" title="一、通信协议"></a>一、通信协议</h3><h4 id="1-计算机网络实现通信必须遵循守一些约定。核心要素包括："><a href="#1-计算机网络实现通信必须遵循守一些约定。核心要素包括：" class="headerlink" title="1.计算机网络实现通信必须遵循守一些约定。核心要素包括："></a>1.计算机网络实现通信必须遵循守一些约定。核心要素包括：</h4><h5 id="（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；"><a href="#（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；" class="headerlink" title="（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；"></a>（1）<font color="cornflowerblue">语义</font>：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；</h5><h5 id="（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；"><a href="#（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；" class="headerlink" title="（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；"></a>（2）<font color="cornflowerblue">语法</font>：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；</h5><h5 id="（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。"><a href="#（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。" class="headerlink" title="（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。"></a>（3）<font color="cornflowerblue">时序</font>：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。</h5><h4 id="2-常见的通信协议"><a href="#2-常见的通信协议" class="headerlink" title="2.常见的通信协议"></a>2.常见的通信协议</h4><ul>
<li>TCP/IP, IPX/SPX, NetBEUI, RS-232-C等</li>
<li>TCP/IP 是最基本的通信协议。</li>
<li>TCP/IP是一组协议的集合，是一组协议集合的简称。</li>
</ul>
<h3 id="二、TCP-IP-协议集"><a href="#二、TCP-IP-协议集" class="headerlink" title="二、TCP/IP 协议集"></a>二、TCP/IP 协议集</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214220514420.png" alt="image-20201214220514420"></p>
<h4 id="1-以QQ数据传输为例"><a href="#1-以QQ数据传输为例" class="headerlink" title="1.以QQ数据传输为例"></a>1.以QQ数据传输为例</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214220704145.png" alt="image-20201214220704145"></p>
<h4 id="2-TCP与UDP，传输层"><a href="#2-TCP与UDP，传输层" class="headerlink" title="2.TCP与UDP，传输层"></a>2.TCP与UDP，传输层</h4><h5 id="1、TCP面向连接（如打电话要先拨号建立连接）-UDP是无连接的，即发送数据之前不需要建立连接。"><a href="#1、TCP面向连接（如打电话要先拨号建立连接）-UDP是无连接的，即发送数据之前不需要建立连接。" class="headerlink" title="1、TCP面向连接（如打电话要先拨号建立连接）; UDP是无连接的，即发送数据之前不需要建立连接。"></a>1、<font color="red">TCP面向连接</font>（如打电话要先拨号建立连接）;<font color="red"> UDP是无连接的</font>，即发送数据之前不需要建立连接。</h5><h5 id="2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达-UDP尽最大努力交付，即不保证可靠交付。"><a href="#2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达-UDP尽最大努力交付，即不保证可靠交付。" class="headerlink" title="2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保证可靠交付。"></a>2、<font color="red">TCP提供可靠的服务</font>。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; <font color="red">UDP尽最大努力交付，即不保证可靠交付</font>。</h5><h5 id="3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流-UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。"><a href="#3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流-UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。" class="headerlink" title="3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。"></a>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</h5><h5 id="4、每一条TCP连接只能是点到点的-UDP支持一对一，一对多，多对一和多对多的交互通信。"><a href="#4、每一条TCP连接只能是点到点的-UDP支持一对一，一对多，多对一和多对多的交互通信。" class="headerlink" title="4、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信。"></a>4、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信。</h5><h5 id="5、TCP首部开销20字节-UDP的首部开销小，只有8个字节。"><a href="#5、TCP首部开销20字节-UDP的首部开销小，只有8个字节。" class="headerlink" title="5、TCP首部开销20字节;UDP的首部开销小，只有8个字节。"></a>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节。</h5><h5 id="6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。"><a href="#6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。" class="headerlink" title="6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。"></a>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</h5><h4 id="3-HTTP，应用层"><a href="#3-HTTP，应用层" class="headerlink" title="3.HTTP，应用层"></a>3.HTTP，应用层</h4><h5 id="（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。"><a href="#（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。" class="headerlink" title="（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。"></a>（1）Http是一个基于<font color="red">请求与响应，无状态的，应用层的</font>协议，常基于<font color="red">TCP</font>协议传输数据。</h5><h5 id="（2）用于定义Web浏览器与Web服务器之间交换数据的过程。"><a href="#（2）用于定义Web浏览器与Web服务器之间交换数据的过程。" class="headerlink" title="（2）用于定义Web浏览器与Web服务器之间交换数据的过程。"></a>（2）用于定义Web浏览器与Web服务器之间交换数据的过程。</h5><h5 id="（3）四个基于：请求与响应、无状态、应用层、TCP"><a href="#（3）四个基于：请求与响应、无状态、应用层、TCP" class="headerlink" title="（3）四个基于：请求与响应、无状态、应用层、TCP"></a>（3）四个基于：请求与响应、无状态、应用层、TCP</h5><h2 id="基于TCP协议的网络通信"><a href="#基于TCP协议的网络通信" class="headerlink" title="基于TCP协议的网络通信"></a>基于TCP协议的网络通信</h2><h3 id="一、IP地址、端口"><a href="#一、IP地址、端口" class="headerlink" title="一、IP地址、端口"></a>一、IP地址、端口</h3><h4 id="1-IP地址"><a href="#1-IP地址" class="headerlink" title="1.IP地址"></a>1.<font color="cornflowerblue">IP地址</font></h4><h5 id="IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192-168-0-0-1。"><a href="#IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192-168-0-0-1。" class="headerlink" title="IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192.168.0.0.1。"></a>IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192.168.0.0.1。</h5><h4 id="2-端口"><a href="#2-端口" class="headerlink" title="2.端口"></a>2.<font color="cornflowerblue">端口</font></h4><h5 id="端口号用来标记一台电脑中的不同应用程序。"><a href="#端口号用来标记一台电脑中的不同应用程序。" class="headerlink" title="端口号用来标记一台电脑中的不同应用程序。"></a>端口号用来标记一台电脑中的不同应用程序。</h5><h5 id="端口号范围是0-65535，其中0-1023是系统专用"><a href="#端口号范围是0-65535，其中0-1023是系统专用" class="headerlink" title="端口号范围是0-65535，其中0~1023是系统专用"></a>端口号范围是0-<font color="orange">65535</font>，其中0~1023是系统专用</h5><h3 id="二、Socket编程"><a href="#二、Socket编程" class="headerlink" title="二、Socket编程"></a>二、Socket编程</h3><p>略</p>
<h2 id="基于Http协议的网络通信"><a href="#基于Http协议的网络通信" class="headerlink" title="基于Http协议的网络通信"></a>基于Http协议的网络通信</h2><h3 id="一、HTTP协议工作原理"><a href="#一、HTTP协议工作原理" class="headerlink" title="一、HTTP协议工作原理"></a>一、HTTP协议工作原理</h3><h4 id="1-建立连接："><a href="#1-建立连接：" class="headerlink" title="1.建立连接："></a>1.<font color="cornflowerblue">建立连接</font>：</h4><p>客户机与服务器建立连接。输入网址、打开网页或单击超级链接。</p>
<h4 id="2-发送请求："><a href="#2-发送请求：" class="headerlink" title="2.发送请求："></a>2.<font color="cornflowerblue">发送请求</font>：</h4><p>客户机向服务器发送请求，格式为：<strong>统一资源标识符</strong>（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p>
<h4 id="3-响应请求："><a href="#3-响应请求：" class="headerlink" title="3.响应请求："></a>3.<font color="cornflowerblue">响应请求</font>：</h4><p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
<h4 id="4-接收响应："><a href="#4-接收响应：" class="headerlink" title="4.接收响应："></a>4.<font color="cornflowerblue">接收响应</font>：</h4><p>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后与服务器断开连接。</p>
<h3 id="二、HTTP请求报文"><a href="#二、HTTP请求报文" class="headerlink" title="二、HTTP请求报文"></a>二、HTTP<strong>请求报文</strong></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215125047712.png" alt="image-20201215125047712"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215124600803.png" alt="image-20201215124600803"></p>
<h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.<font color="cornflowerblue">请求行</font></h4><h5 id="（1）请求方法"><a href="#（1）请求方法" class="headerlink" title="（1）请求方法"></a>（1）请求方法</h5><p>HTTP/1.1 定义的请求方法有8种，最常的两种GET和POST。</p>
<h5 id="（2）请求地址"><a href="#（2）请求地址" class="headerlink" title="（2）请求地址"></a>（2）请求地址</h5><p>URL:<font color="orange">统一资源定位符</font>，是一种资源位置的抽象唯一识别方法。<br>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;<br>端口和路径有时可以省略（HTTP默认端口号是80），有时会带参数，GET请求</p>
<h5 id="（3）版本协议"><a href="#（3）版本协议" class="headerlink" title="（3）版本协议"></a>（3）版本协议</h5><p>格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p>
<h4 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2.请求头部"></a>2.<font color="cornflowerblue">请求头部</font></h4><h5 id="（1）由键值对组成，每行一对，关键字和值用英文冒号“-”分隔。"><a href="#（1）由键值对组成，每行一对，关键字和值用英文冒号“-”分隔。" class="headerlink" title="（1）由键值对组成，每行一对，关键字和值用英文冒号“:”分隔。"></a>（1）由<font color="red">键值对</font>组成，每行一对，关键字和值用英文冒号“:”分隔。</h5><h5 id="（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有："><a href="#（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有：" class="headerlink" title="（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有："></a>（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215125315165.png" alt="image-20201215125315165"></p>
<h5 id="（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。"><a href="#（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。" class="headerlink" title="（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。"></a>（3）请求头部的最后<font color="red">会有一个空行，表示请求头部结束</font>，接下来为请求数据，这一行非常重要，必不可少。</h5><h4 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3.请求数据"></a>3.<font color="cornflowerblue">请求数据</font></h4><h5 id="（1）可选部分，比如GET请求就没有请求数据。"><a href="#（1）可选部分，比如GET请求就没有请求数据。" class="headerlink" title="（1）可选部分，比如GET请求就没有请求数据。"></a>（1）可选部分，比如GET请求就没有请求数据。</h5><h5 id="（2）HTTP的请求方式包括GET-POST-PUT-HEAD-DELETE-TRACE-CONNECT-OPTIONS等，最常用的发送请求的方式主要有-get-和-post两种"><a href="#（2）HTTP的请求方式包括GET-POST-PUT-HEAD-DELETE-TRACE-CONNECT-OPTIONS等，最常用的发送请求的方式主要有-get-和-post两种" class="headerlink" title="（2）HTTP的请求方式包括GET,POST, PUT ,HEAD, DELETE, TRACE, CONNECT, OPTIONS等，最常用的发送请求的方式主要有 get 和 post两种"></a>（2）HTTP的请求方式包括GET,POST, PUT ,HEAD, DELETE, TRACE, CONNECT, OPTIONS等，最常用的发送请求的方式主要有 get 和 post两种</h5><h4 id="4-GET与POST"><a href="#4-GET与POST" class="headerlink" title="4. GET与POST"></a>4. GET与POST</h4><h5 id="（1）get"><a href="#（1）get" class="headerlink" title="（1）get"></a>（1）get</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215130633494.png" alt="image-20201215130633494"></p>
<h5 id="（2）post"><a href="#（2）post" class="headerlink" title="（2）post"></a>（2）post</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111436244.png" alt="image-20201216111436244"></p>
<h5 id="3-注意"><a href="#3-注意" class="headerlink" title="(3)注意"></a>(3)注意</h5><ul>
<li>GET 和 POST 两种请求方式都可以发送数据的，只是<font color="orange">发送机制</font>font&gt;不一样。</li>
<li>另外GET安全性非常低，Post<font color="orange">安全性较高</font>， 但是GET<font color="orange">执行效率</font>却比Post方法好。</li>
<li>一般<font color="orange">查询</font>的时候我们用<font color="orange">GET</font>，数据<font color="orange">增删改</font>的时候用<font color="orange">POST</font>。</li>
</ul>
<h5 id="4-其他区别"><a href="#4-其他区别" class="headerlink" title="(4)其他区别"></a>(4)其他区别</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111723498.png" alt="image-20201216111723498"></p>
<h3 id="三、HTTP响应报文"><a href="#三、HTTP响应报文" class="headerlink" title="三、HTTP响应报文"></a>三、HTTP响应报文</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111852290.png" alt="image-20201216111852290"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111859563.png" alt="image-20201216111859563"></p>
<h4 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1.状态行"></a>1.状态行</h4><h5 id="（1）由3部分组成，分别为：协议版本，状态码，状态码描述）"><a href="#（1）由3部分组成，分别为：协议版本，状态码，状态码描述）" class="headerlink" title="（1）由3部分组成，分别为：协议版本，状态码，状态码描述）"></a>（1）由3部分组成，分别为：协议版本，<font color="red">状态码</font>，状态码描述）</h5><h5 id="（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述"><a href="#（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述" class="headerlink" title="（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述"></a>（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述</h5><h5 id="（3）常见状态码"><a href="#（3）常见状态码" class="headerlink" title="（3）常见状态码"></a>（3）常见状态码</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112057996.png" alt="image-20201216112057996"></p>
<h5 id="2-响应头部"><a href="#2-响应头部" class="headerlink" title="2.响应头部"></a>2.响应头部</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112237974.png" alt="image-20201216112237974"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112254577.png" alt="image-20201216112254577"></p>
<h3 id="四、基于HTTP的网络编程"><a href="#四、基于HTTP的网络编程" class="headerlink" title="四、基于HTTP的网络编程"></a>四、基于HTTP的网络编程</h3><p>（HyperText Transfer protocol）<font color="cornflowerblue">超文本传输协议</font></p>
<h4 id="1-通过URL获取网络资源"><a href="#1-通过URL获取网络资源" class="headerlink" title="1.通过URL获取网络资源"></a>1.通过URL获取网络资源</h4><h5 id="（1）URL（Unifrom-Resource-Locator）统一资源定位器"><a href="#（1）URL（Unifrom-Resource-Locator）统一资源定位器" class="headerlink" title="（1）URL（Unifrom Resource Locator）统一资源定位器"></a>（1）URL（Unifrom Resource Locator）<font color="cornflowerblue">统一资源定位器</font></h5><p>可以定位到互联网的资源上。如果用户已经知道网络上某个资源的URL(如图片、音乐和视频文件等)，那么就可以直接通过使用URL来进行网络连接，获得资源</p>
<h5 id="（2）资源获取过程："><a href="#（2）资源获取过程：" class="headerlink" title="（2）资源获取过程："></a>（2）资源获取过程：</h5><ol>
<li>创建URL对象。</li>
<li>调用常用的方法来获取对应的资源。例如，使用<font color="red">openStream()</font>方法，打开与此URL的连接，并返回读取到的数据流。</li>
<li>将获得的数据流进行处理。例如，显示到ImageView上。</li>
</ol>
<p>说明：openStream() 实际是通过<font color="red">openConnection()</font>方法获取URLConnection对象，然后调用<font color="red">getInputStream()</font>方法，这个方法会隐式的调用connect() 方法发送连接请求。</p>
<p>URL url = new URL( “ …”);</p>
<p>HttpURLConnection connection = (HttpURLConnection) url.openConnection();</p>
<p>InputStream in = connection.getInputStream();</p>
<p>等加于</p>
<p>URL url = new URL( “ …”);</p>
<p>InputStream in = url.openStream();</p>
<h5 id="3-URL类常用的方法"><a href="#3-URL类常用的方法" class="headerlink" title="(3)URL类常用的方法"></a>(3)URL类常用的方法</h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216113912830.png" alt="image-20201216113912830">

<h5 id="（4）案例：图片资源获取并显示"><a href="#（4）案例：图片资源获取并显示" class="headerlink" title="（4）案例：图片资源获取并显示"></a>（4）案例：图片资源获取并显示</h5><p>1.布局文件：新建项目URLDemo，在布局文件中，准备一个ImageView控件。</p>
<p>2.初始化并准备异步任务类。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216114237925.png" alt="image-20201216114237925"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216114246080.png" alt="image-20201216114246080"></p>
<p>3.<strong>获取网络资源</strong>：在doInBackground()方法中执行联网以获取网络资源，获取到的图片信息作为返回结果，传给onPostExecute()中的参数</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216120334545.png" alt="image-20201216120334545"></p>
<p>4.<strong>资源显示</strong>：在onPostExecute()方法中进行图片显示。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216120421728.png" alt="image-20201216120421728"></p>
<p>5.增加上网权限。</p>
<p>&lt;uses-permission android:”android.permission.INTERNET”/&gt;</p>
<h4 id="2-通过URLConnection获取网络资源"><a href="#2-通过URLConnection获取网络资源" class="headerlink" title="2.通过URLConnection获取网络资源"></a>2.通过URLConnection获取网络资源</h4><h5 id="（1）URL-对象提供了openConnection-方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。"><a href="#（1）URL-对象提供了openConnection-方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。" class="headerlink" title="（1）URL 对象提供了openConnection()方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。"></a>（1）URL 对象提供了<font color="cornflowerblue">openConnection()</font>方法返回一个<font color="cornflowerblue">URLConnection</font>对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。</h5><h5 id="（2）实现步骤"><a href="#（2）实现步骤" class="headerlink" title="（2）实现步骤"></a>（2）实现步骤</h5><ol>
<li>创建<font color="orange">URL对象</font>。</li>
<li>建立与URL的连接：由于<font color="orange">URLConnection</font>为抽象类，其对象不能直接实例化，通常通过<font color="orange">openConnection</font>方法获得。</li>
<li>获取返回的<font color="orange">InputStream</font>。</li>
<li>将InputStream进行处理：例如，显示到相应的控件上。</li>
<li>关闭流操作</li>
</ol>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217124051779.png" alt="image-20201217124051779"></p>
<h5 id="（3）URLConnection常用方法"><a href="#（3）URLConnection常用方法" class="headerlink" title="（3）URLConnection常用方法"></a>（3）URLConnection常用方法</h5><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public int <font color="red">getContentLength</font>()</td>
<td>获得文件的长度</td>
</tr>
<tr>
<td>public String getContentType()</td>
<td>获得文件的类型</td>
</tr>
<tr>
<td>public long getDate()</td>
<td>获得文件创建的时间</td>
</tr>
<tr>
<td>public long getLastModified()</td>
<td>获得文件最后修改的时间</td>
</tr>
<tr>
<td>public InputStream <font color="red">getInputStream()</font></td>
<td>获得输入流，以便读取文件的数据</td>
</tr>
<tr>
<td>public OutputStream getOutputStream()</td>
<td>获得输出流，以便输出数据</td>
</tr>
<tr>
<td>public void <font color="red">setRequestProperty(String key,String value)</font></td>
<td>设置请求属性值</td>
</tr>
<tr>
<td>connect()</td>
<td>打开到此URL引用的资源的通信连接(如果尚未建立连接)，如果已打开连接(此时connected()为true)，则忽略该调用</td>
</tr>
</tbody></table>
<h4 id="3-使用HttpURLConnection获取网络资源"><a href="#3-使用HttpURLConnection获取网络资源" class="headerlink" title="3.使用HttpURLConnection获取网络资源"></a>3.使用HttpURLConnection获取网络资源</h4><h5 id="（1）HttpURLConnection常用方法"><a href="#（1）HttpURLConnection常用方法" class="headerlink" title="（1）HttpURLConnection常用方法"></a>（1）HttpURLConnection常用方法</h5><p>HttpURLConnection是URLConnection的子类</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>InputStream <font color="red">getInputStream()</font></td>
<td>返回从此处打开的连接读取的输入流</td>
</tr>
<tr>
<td>OutputStream getOutputStream()</td>
<td>返回写入到此连接的输出流</td>
</tr>
<tr>
<td>String <font color="red">getRequestMethod()</font></td>
<td>获取请求方法</td>
</tr>
<tr>
<td>int getResponseCode()</td>
<td>获取状态码</td>
</tr>
<tr>
<td>void setRequestMethod(String method)</td>
<td>设置URL请求的方法</td>
</tr>
<tr>
<td>void setDoInput(boolean doinput)</td>
<td>设置输入流</td>
</tr>
<tr>
<td>void setDoOutput(boolean dooutput)</td>
<td>设置输出流</td>
</tr>
<tr>
<td>void setUseCaches(boolean usecaches)</td>
<td>设置连接是否使用任何可用的缓存</td>
</tr>
<tr>
<td>void disconnect()</td>
<td>关闭连接</td>
</tr>
</tbody></table>
<h5 id="（2）GET方式：将参数放在url后一起传递"><a href="#（2）GET方式：将参数放在url后一起传递" class="headerlink" title="（2）GET方式：将参数放在url后一起传递"></a>（2）GET方式：将参数放在url后一起传递</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125144443.png" alt="image-20201217125144443"></p>
<h5 id="（2）POST方法"><a href="#（2）POST方法" class="headerlink" title="（2）POST方法"></a>（2）POST方法</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125444529.png" alt="image-20201217125444529"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125635416.png" alt="image-20201217125635416"></p>
<h2 id="使用WebView控件"><a href="#使用WebView控件" class="headerlink" title="使用WebView控件"></a>使用WebView控件</h2><h3 id="1-Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个-控件"><a href="#1-Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个-控件" class="headerlink" title="1.Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个 控件"></a>1.Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个 控件</h3><h3 id="2-WebView-网页视图-常用方法"><a href="#2-WebView-网页视图-常用方法" class="headerlink" title="2.WebView(网页视图)常用方法"></a>2.WebView(<font color="cornflowerblue">网页视图</font>)常用方法</h3><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>loadUrl(String url)</td>
<td>打开一个指定的Web资源页面</td>
</tr>
<tr>
<td>loadData(String data, StringmimeType,String encoding)</td>
<td>显示HTML格式的网页内容</td>
</tr>
<tr>
<td>getSettings()</td>
<td>获取WebView的设置对象</td>
</tr>
<tr>
<td>addJavascriptInterface()</td>
<td>将一个对象添加到JavaScript的全局对象Window中</td>
</tr>
<tr>
<td>clearCache()</td>
<td>清除缓存</td>
</tr>
<tr>
<td>destory()</td>
<td>销毁WebView</td>
</tr>
</tbody></table>
<h3 id="3-在应用中嵌入浏览器展示网页，并进行解析"><a href="#3-在应用中嵌入浏览器展示网页，并进行解析" class="headerlink" title="3.在应用中嵌入浏览器展示网页，并进行解析"></a>3.在应用中嵌入浏览器展示网页，并进行解析</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217130452896.png" alt="image-20201217130452896"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217130553473.png" alt="image-20201217130553473"></p>
<h2 id="使用OKHttp获取网络资源"><a href="#使用OKHttp获取网络资源" class="headerlink" title="使用OKHttp获取网络资源"></a>使用OKHttp获取网络资源</h2><h3 id="1-GET请求"><a href="#1-GET请求" class="headerlink" title="1.GET请求"></a>1.GET请求</h3><h4 id="（1）添加依赖"><a href="#（1）添加依赖" class="headerlink" title="（1）添加依赖"></a>（1）添加依赖</h4><h4 id="implementation-‘com-squareup-okhttp3-okhttp-3-10-0’"><a href="#implementation-‘com-squareup-okhttp3-okhttp-3-10-0’" class="headerlink" title="implementation ‘com.squareup.okhttp3:okhttp:3.10.0’"></a><font color="pink">implementation ‘com.squareup.okhttp3:okhttp:3.10.0’</font></h4><h4 id="（2）声明访问Internet的权限"><a href="#（2）声明访问Internet的权限" class="headerlink" title="（2）声明访问Internet的权限"></a>（2）声明访问Internet的权限</h4><h4 id="-9"><a href="#-9" class="headerlink" title></a><font color="red"><uses-permission android:name="android.permission.INTERNET"></uses-permission></font></h4><p>在application标签中添加<font color="red"> android:usesCleartextTraffic=”true”</font></p>
<h4 id="（3）创建-OkHttpClient实例"><a href="#（3）创建-OkHttpClient实例" class="headerlink" title="（3）创建 OkHttpClient实例"></a>（3）创建 OkHttpClient实例</h4><p><font color="red">OkHttpClient okHttpClient = new OkHttpClient();</font></p>
<h4 id="（4）构造Request对象。"><a href="#（4）构造Request对象。" class="headerlink" title="（4）构造Request对象。"></a>（4）构造Request对象。</h4><p><font color="red">final Request request = new Request.Builder() .url(url).get() </font>   //默认</p>
<p>就是GET请求，可以不写 .build();</p>
<h4 id="（5）构建Call对象"><a href="#（5）构建Call对象" class="headerlink" title="（5）构建Call对象"></a>（5）构建Call对象</h4><p><font color="red">Call call = okHttpClient.newCall(request);</font></p>
<h4 id="（6）-发送请求并获取服务器返回的数据。"><a href="#（6）-发送请求并获取服务器返回的数据。" class="headerlink" title="（6） 发送请求并获取服务器返回的数据。"></a>（6） 发送请求并获取服务器返回的数据。</h4><ul>
<li><h5 id="同步Get方法："><a href="#同步Get方法：" class="headerlink" title="同步Get方法："></a>同步Get方法：</h5></li>
</ul>
<h5 id="通过Call-execute-方法提交请求，放在子线程中执行，或者使用异步任务的方式"><a href="#通过Call-execute-方法提交请求，放在子线程中执行，或者使用异步任务的方式" class="headerlink" title="通过Call.execute()方法提交请求，放在子线程中执行，或者使用异步任务的方式"></a>通过<font color="red">Call.execute()</font>方法提交请求，放在<font color="orange">子线程</font>中执行，或者使用异步任务的方式</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217131925515.png" alt="image-20201217131925515"></p>
<ul>
<li><h5 id="异步Get方法："><a href="#异步Get方法：" class="headerlink" title="异步Get方法："></a>异步Get方法：</h5></li>
</ul>
<h5 id="通过Call-enqueue-Callback-方法来提交异步请求"><a href="#通过Call-enqueue-Callback-方法来提交异步请求" class="headerlink" title="通过Call.enqueue(Callback)方法来提交异步请求"></a>通过<font color="red">Call.enqueue(Callback)</font>方法来提交异步请求</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132051946.png" alt="image-20201217132051946"></p>
<h3 id="2-POST请求"><a href="#2-POST请求" class="headerlink" title="2.POST请求"></a>2.POST请求</h3><h4 id="（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如："><a href="#（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如：" class="headerlink" title="（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如："></a>（1）与上述GET请求相比，需要先构造一个<font color="red">RequestBody对象</font>用来存放待提交的数据，例如：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132351988.png" alt="image-20201217132351988"></p>
<h4 id="（2）然后在Request-Builder中调用一下post-方法，并将RequestBody对象传入："><a href="#（2）然后在Request-Builder中调用一下post-方法，并将RequestBody对象传入：" class="headerlink" title="（2）然后在Request.Builder中调用一下post()方法，并将RequestBody对象传入："></a>（2）然后在Request.Builder中调用一下post()方法，并将RequestBody对象传入：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132423939.png" alt="image-20201217132423939"></p>
<h4 id="（3）登录案例"><a href="#（3）登录案例" class="headerlink" title="（3）登录案例"></a>（3）登录案例</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133135117.png" alt="image-20201217133135117"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133213142.png" alt="image-20201217133213142"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133219867.png" alt="image-20201217133219867"></p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="一、JSON数据"><a href="#一、JSON数据" class="headerlink" title="一、JSON数据"></a>一、JSON数据</h3><h4 id="1-JSON-JavaScript-Object-Notation-是JavaScript的一个子集，是一种轻量级的数据交换格式。"><a href="#1-JSON-JavaScript-Object-Notation-是JavaScript的一个子集，是一种轻量级的数据交换格式。" class="headerlink" title="1.JSON(JavaScript Object Notation) 是JavaScript的一个子集，是一种轻量级的数据交换格式。"></a>1.JSON(JavaScript Object Notation) 是JavaScript的一个子集，是一种<font color="cornflowerblue">轻量级的数据交换格式</font>。</h4><h4 id="2-JSON的结构基于以下两点："><a href="#2-JSON的结构基于以下两点：" class="headerlink" title="2.JSON的结构基于以下两点："></a>2.JSON的结构基于以下两点：</h4><h5 id="（1）”名称-值”对的集合-：不同语言中，它被理解为对象-object-，记录-record-，结构-struct-，字典-dictionary-，哈希表-hash-table-，键列表-keyed-list-等。"><a href="#（1）”名称-值”对的集合-：不同语言中，它被理解为对象-object-，记录-record-，结构-struct-，字典-dictionary-，哈希表-hash-table-，键列表-keyed-list-等。" class="headerlink" title="（1）”名称/值”对的集合 ：不同语言中，它被理解为对象(object)，记录(record)，结构(struct)，字典(dictionary)，哈希表(hash table)，键列表(keyed list)等。"></a>（1）”名称/值”对的集合 ：不同语言中，它被理解为对象(object)，记录(record)，结构(struct)，字典(dictionary)，哈希表(hash table)，键列表(keyed list)等。</h5><h5 id="（2）值的有序列表：-多数语言中被理解为数组-array-。"><a href="#（2）值的有序列表：-多数语言中被理解为数组-array-。" class="headerlink" title="（2）值的有序列表： 多数语言中被理解为数组(array)。"></a>（2）值的有序列表： 多数语言中被理解为数组(array)。</h5><h4 id="3-JSON的形式主要有以下两种："><a href="#3-JSON的形式主要有以下两种：" class="headerlink" title="3.JSON的形式主要有以下两种："></a>3.JSON的形式主要有以下两种：</h4><h5 id="（1）对象"><a href="#（1）对象" class="headerlink" title="（1）对象"></a>（1）<font color="red">对象</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093521448.png" alt="image-20201219093521448"></p>
<h5 id="（2）数组"><a href="#（2）数组" class="headerlink" title="（2）数组"></a>（2）<font color="red">数组</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093539871.png" alt="image-20201219093539871"></p>
<h3 id="二、使用JSONObject解析JSON数据"><a href="#二、使用JSONObject解析JSON数据" class="headerlink" title="二、使用JSONObject解析JSON数据"></a>二、使用JSONObject解析JSON数据</h3><h4 id="1-案例：CityCodeDemo"><a href="#1-案例：CityCodeDemo" class="headerlink" title="1. 案例：CityCodeDemo"></a>1. 案例：CityCodeDemo</h4><p>通过Spinner控件，读取中国的城市名称，并通过选择获得该城市对应的编码值。</p>
<h5 id="1-准备JSON数据-创建assets目录"><a href="#1-准备JSON数据-创建assets目录" class="headerlink" title="(1)准备JSON数据,创建assets目录"></a>(1)准备JSON数据,创建assets目录</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093921547.png" alt="image-20201219093921547"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094342080.png" alt="image-20201219094342080"></p>
<h5 id="2-布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。"><a href="#2-布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。" class="headerlink" title="(2)布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。"></a>(2)布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。</h5><h5 id="3-启动异步任务，进行文件读取"><a href="#3-启动异步任务，进行文件读取" class="headerlink" title="(3)启动异步任务，进行文件读取"></a>(3)启动异步任务，进行文件读取</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094525406.png" alt="image-20201219094525406"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219095314825.png" alt="image-20201219095314825"></p>
<h5 id="（4）定义实体类。装载JSON的解析结果"><a href="#（4）定义实体类。装载JSON的解析结果" class="headerlink" title="（4）定义实体类。装载JSON的解析结果"></a>（4）定义实体类。装载JSON的解析结果</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094831461.png" alt="image-20201219094831461"></p>
<h5 id="（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表"><a href="#（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表" class="headerlink" title="（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表"></a>（5）<font color="red">解析JSON内容。将字符串转换为对应的CityCode实体对象列表</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219095531426.png" alt="image-20201219095531426"></p>
<h5 id="（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听"><a href="#（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听" class="headerlink" title="（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听"></a>（6）绑定界面控件。将解析得到的List<CityCode>通过适配器，绑定到spinner控件上，并设置子项监听</CityCode></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219100105438.png" alt="image-20201219100105438"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219100112597.png" alt="image-20201219100112597"></p>
<h4 id="2-安卓的资源文件assets"><a href="#2-安卓的资源文件assets" class="headerlink" title="2.安卓的资源文件assets"></a>2.安卓的资源文件assets</h4><h5 id="（1）Android资源文件的存放位置有三种："><a href="#（1）Android资源文件的存放位置有三种：" class="headerlink" title="（1）Android资源文件的存放位置有三种："></a>（1）Android资源文件的存放位置有三种：</h5><ul>
<li><h5 id="res目录下存放的可编译的资源文件；"><a href="#res目录下存放的可编译的资源文件；" class="headerlink" title="res目录下存放的可编译的资源文件；"></a><font color="orange">res</font>目录下存放的<font color="orange">可编译的资源文件</font>；</h5></li>
<li><h5 id="assets目录下存放的原生资源文件；"><a href="#assets目录下存放的原生资源文件；" class="headerlink" title="assets目录下存放的原生资源文件；"></a><font color="orange">assets</font>目录下存放的<font color="orange">原生资源文件</font>；</h5></li>
<li><h5 id="res-raw目录下存放的原生资源文件"><a href="#res-raw目录下存放的原生资源文件" class="headerlink" title="res/raw目录下存放的原生资源文件"></a><font color="orange">res/raw</font>目录下存放的<font color="orange">原生资源文件</font></h5></li>
</ul>
<h5 id="（2）assets与res-raw相同之处"><a href="#（2）assets与res-raw相同之处" class="headerlink" title="（2）assets与res/raw相同之处"></a>（2）assets与res/raw<font color="cornflowerblue">相同</font>之处</h5><ol>
<li>都可以用于放置APP所需的固定文件</li>
<li>该文件被打包到APK中时，不会被编码到二进制文件</li>
</ol>
<h5 id="（3）assets与res-raw不同之处"><a href="#（3）assets与res-raw不同之处" class="headerlink" title="（3）assets与res/raw不同之处"></a>（3）assets与res/raw<font color="cornflowerblue">不同</font>之处</h5><ol>
<li>assets目录不会被映射到R中，因此，资源无法通过R.id方式获取，必须要通过AssetManager进行操作与获取；res/raw目录下的资源会被映射到R中，可以通过getResource()方法获取资源。</li>
<li>多级目录：assets下可以有多级目录，res/raw下不可以有多级目录。</li>
</ol>
<h3 id="三、使用Goole-Gson解析JSON数据"><a href="#三、使用Goole-Gson解析JSON数据" class="headerlink" title="三、使用Goole Gson解析JSON数据"></a>三、使用Goole Gson解析JSON数据</h3><h4 id="1-Gson概述"><a href="#1-Gson概述" class="headerlink" title="1.Gson概述"></a>1.Gson概述</h4><h5 id="（1）Gson的解析非常简单-必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。"><a href="#（1）Gson的解析非常简单-必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。" class="headerlink" title="（1）Gson的解析非常简单:必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。"></a>（1）Gson的解析非常简单:必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。</h5><h5 id="（2）Gson有两个重要的方法"><a href="#（2）Gson有两个重要的方法" class="headerlink" title="（2）Gson有两个重要的方法"></a>（2）Gson有两个重要的方法</h5><p><font color="red">toJson（）</font>：序列化Java对象成JSON字符串</p>
<p><font color="red">fromJson()</font>：反序列化对象成Java对象</p>
<h4 id="2-解析Json数据"><a href="#2-解析Json数据" class="headerlink" title="2.解析Json数据"></a>2.解析Json数据</h4><h5 id="（1）准备一个Person类"><a href="#（1）准备一个Person类" class="headerlink" title="（1）准备一个Person类"></a>（1）准备一个Person类</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101538843.png" alt="image-20201219101538843"></p>
<h5 id="（2））toJson-方法用于将bean对象换为Json数据"><a href="#（2））toJson-方法用于将bean对象换为Json数据" class="headerlink" title="（2））toJson()方法用于将bean对象换为Json数据"></a>（2））toJson()方法用于将bean对象换为Json数据</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101558372.png" alt="image-20201219101558372"></p>
<h5 id="（3）fromJson-方法用于将Json数据转换为bean对象"><a href="#（3）fromJson-方法用于将Json数据转换为bean对象" class="headerlink" title="（3）fromJson()方法用于将Json数据转换为bean对象"></a>（3）fromJson()方法用于将Json数据转换为bean对象</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101620318.png" alt="image-20201219101620318"></p>
<h2 id="网络通信框架Volley"><a href="#网络通信框架Volley" class="headerlink" title="网络通信框架Volley"></a>网络通信框架Volley</h2><h3 id="一、Volley概述"><a href="#一、Volley概述" class="headerlink" title="一、Volley概述"></a>一、Volley概述</h3><h4 id="1-Volley特别适合数据量不大但通信频繁的场景"><a href="#1-Volley特别适合数据量不大但通信频繁的场景" class="headerlink" title="1.Volley特别适合数据量不大但通信频繁的场景"></a>1.Volley特别适合<font color="cornflowerblue">数据量不大但通信频繁</font>的场景</h4><h4 id="2-不使用Volley，从网上下载资源的步骤大致如下："><a href="#2-不使用Volley，从网上下载资源的步骤大致如下：" class="headerlink" title="2.不使用Volley，从网上下载资源的步骤大致如下："></a>2.不使用Volley，从网上下载资源的步骤大致如下：</h4><h5 id="（1）首先，在AsyncTask的doInBackground-中，使用HttpURLConnection从服务器获取相关资源。"><a href="#（1）首先，在AsyncTask的doInBackground-中，使用HttpURLConnection从服务器获取相关资源。" class="headerlink" title="（1）首先，在AsyncTask的doInBackground()中，使用HttpURLConnection从服务器获取相关资源。"></a>（1）首先，在AsyncTask的doInBackground()中，使用HttpURLConnection从服务器获取相关资源。</h5><h5 id="（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute-里设置到相应的控件中。"><a href="#（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute-里设置到相应的控件中。" class="headerlink" title="（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute()里设置到相应的控件中。"></a>（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute()里设置到相应的控件中。</h5><h5 id="而在Volley下，上述只需要一个函数就可以完成上述步骤"><a href="#而在Volley下，上述只需要一个函数就可以完成上述步骤" class="headerlink" title="而在Volley下，上述只需要一个函数就可以完成上述步骤"></a>而在Volley下，上述只需要一个函数就可以完成上述步骤</h5><h3 id="二、Volley的使用步骤"><a href="#二、Volley的使用步骤" class="headerlink" title="二、Volley的使用步骤"></a>二、Volley的使用步骤</h3><h4 id="1-声明RequestQueue"><a href="#1-声明RequestQueue" class="headerlink" title="1.声明RequestQueue"></a>1.声明<font color="cornflowerblue">RequestQueue</font></h4><h4 id="2-为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象"><a href="#2-为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象" class="headerlink" title="2.为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象"></a>2.为了获得请求的响应，我们需要根据响应的结果，<font color="cornflowerblue">调用不同的Request对象</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102328576.png" alt="image-20201219102328576"></p>
<h3 id="三、通过Volley获取字符串"><a href="#三、通过Volley获取字符串" class="headerlink" title="三、通过Volley获取字符串"></a>三、通过Volley获取字符串</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102423614.png" alt="image-20201219102423614"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102436859.png" alt="image-20201219102436859"></p>
<h3 id="四、通过Volley获取JSON数据"><a href="#四、通过Volley获取JSON数据" class="headerlink" title="四、通过Volley获取JSON数据"></a>四、通过Volley获取JSON数据</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102603231.png" alt="image-20201219102603231"></p>
<h3 id="五、通过Volley获取图片资源"><a href="#五、通过Volley获取图片资源" class="headerlink" title="五、通过Volley获取图片资源"></a>五、通过Volley获取图片资源</h3><h4 id="1-ImageRequest"><a href="#1-ImageRequest" class="headerlink" title="1.ImageRequest"></a>1.ImageRequest</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102644623.png" alt="image-20201219102644623"></p>
<h4 id="2-ImageLoader"><a href="#2-ImageLoader" class="headerlink" title="2.ImageLoader"></a>2.ImageLoader</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102720895.png" alt="image-20201219102720895"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102741316.png" alt="image-20201219102741316"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102801828.png" alt="image-20201219102801828"></p>
<h1 id="第十章-后台默默劳动者——服务"><a href="#第十章-后台默默劳动者——服务" class="headerlink" title="第十章 后台默默劳动者——服务"></a>第十章 后台默默劳动者——服务</h1><h2 id="Android多线程编程"><a href="#Android多线程编程" class="headerlink" title="Android多线程编程"></a>Android多线程编程</h2><h3 id="一、线程概述"><a href="#一、线程概述" class="headerlink" title="一、线程概述"></a>一、线程概述</h3><h4 id="1-Android系统中，App运行后默认创建一个线程，即主线程。"><a href="#1-Android系统中，App运行后默认创建一个线程，即主线程。" class="headerlink" title="1.Android系统中，App运行后默认创建一个线程，即主线程。"></a>1.Android系统中，App运行后默认创建一个线程，即<font color="red">主线程</font>。</h4><p>​        ——Activity、Service和BroadcastReceiver都是工作在主线程上。</p>
<h4 id="2-主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。"><a href="#2-主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。" class="headerlink" title="2.主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。"></a>2.主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做<font color="red">UI线程</font>。</h4><pre><code> 主线程中任何耗时的操作都会的降低用户界面的响应速度，甚至导致用户界面失去响应。
</code></pre>
<p>例如，发起一条网络请求时，考虑到网速等其他原因，服务器未必会立刻响应我们的请求</p>
<p>​    较好的解决方法是<font color="orange">将耗时的处理过程转移到子线程上</font>，这样可以避免负责界面更新的主线程（UI线程）无法处理界面事件，从而避免用户界面长时间失去响应。</p>
<h3 id="二、主线程和子线程"><a href="#二、主线程和子线程" class="headerlink" title="二、主线程和子线程"></a>二、主线程和子线程</h3><h4 id="1-主线程"><a href="#1-主线程" class="headerlink" title="1.主线程"></a>1.主线程</h4><ul>
<li><p>UI线程，负责处理与UI相关的事件，并把事件分发到对应的组件进行处理。</p>
</li>
<li><p>应用首次启动时，Android会启动一个Linux进程和一个主线程。</p>
</li>
<li><p>Android <font color="red">UI操作必须在UI线程中执行</font>。由于Android的UI是单线程(Single-threaded)的，当其任务繁重时，则需要其他线程来进行配合工作。</p>
</li>
</ul>
<h4 id="2-子线程"><a href="#2-子线程" class="headerlink" title="2.子线程"></a>2.子线程</h4><ul>
<li>非UI线程即为子线程，子线程一般都是<font color="red">后台线程</font>。</li>
<li>运用子线程的场合：进行数据、系统等其他非UI的操作或者把所有运行慢的、耗时的操作移出主线程，放到子线程中。</li>
<li>通常，子线程需要开发人员对其进行定义、启动、终止等操作控制。</li>
</ul>
<h3 id="三、同步与异步"><a href="#三、同步与异步" class="headerlink" title="三、同步与异步"></a>三、同步与异步</h3><h4 id="1-同步：需要等待放回结果"><a href="#1-同步：需要等待放回结果" class="headerlink" title="1.同步：需要等待放回结果"></a>1.同步：需要等待放回结果</h4><h4 id="异步：不需要等待返回结果"><a href="#异步：不需要等待返回结果" class="headerlink" title="异步：不需要等待返回结果"></a>异步：不需要等待返回结果</h4><h4 id="2-无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。"><a href="#2-无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。" class="headerlink" title="2.无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。"></a>2.无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要<font color="red">线程间通讯</font>的方法来实现在其他线程中发消息给主线程处理（更新UI）。</h4><h3 id="四、线程间通讯"><a href="#四、线程间通讯" class="headerlink" title="四、线程间通讯"></a>四、线程间通讯</h3><h4 id="1-Activity-runOnUiThread-Runnable"><a href="#1-Activity-runOnUiThread-Runnable" class="headerlink" title="1) Activity.runOnUiThread(Runnable)"></a>1) Activity.runOnUiThread(Runnable)</h4><h4 id="2-View-post-Runnable-View-postDelay-Runnable-long"><a href="#2-View-post-Runnable-View-postDelay-Runnable-long" class="headerlink" title="2) View.post(Runnable) ;View.postDelay(Runnable , long)"></a>2) View.post(Runnable) ;View.postDelay(Runnable , long)</h4><h4 id="3-Handler"><a href="#3-Handler" class="headerlink" title="3) Handler"></a>3) <font color="red">Handler</font></h4><h4 id="post-postDelay"><a href="#post-postDelay" class="headerlink" title="post, postDelay"></a><font color="red">post, postDelay</font></h4><h4 id="sendMessage-handleMessage"><a href="#sendMessage-handleMessage" class="headerlink" title="sendMessage, handleMessage"></a><font color="red">sendMessage, handleMessage</font></h4><h4 id="4-AsyncTask"><a href="#4-AsyncTask" class="headerlink" title="4) AsyncTask"></a>4) <font color="red">AsyncTask</font></h4><h4 id="5-广播"><a href="#5-广播" class="headerlink" title="5) 广播"></a>5) <font color="cornflowerblue">广播</font></h4><h3 id="五、线程的状态和生命周期"><a href="#五、线程的状态和生命周期" class="headerlink" title="五、线程的状态和生命周期"></a>五、线程的状态和生命周期</h3><ol>
<li><h4 id="创建状态"><a href="#创建状态" class="headerlink" title="创建状态"></a>创建状态</h4><p>用new运算符创建一个Thread类或子类的<font color="orange">实例对象</font>，但此时还未对这个线程分配任何资源</p>
</li>
<li><h4 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h4><p>分配系统资源，由<font color="orange">start()启动</font>方法来完成</p>
</li>
<li><h4 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h4><p>当可运行状态的线程被调度并获得CPU等资源。<font color="orange">进入run()</font>方法。</p>
</li>
<li><h4 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h4><p>由于人为或系统的原因，线程必须停止运行，以后还可以恢复运行的状态称为阻塞状态。</p>
</li>
<li><h4 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h4><p>run()方法完成或调用<font color="orange">stop()</font>或<font color="orange">destroy()</font>方法，不能继续运行。</p>
</li>
</ol>
<h3 id="六、线程的基本用法"><a href="#六、线程的基本用法" class="headerlink" title="六、线程的基本用法"></a>六、线程的基本用法</h3><h4 id="1-创建线程的方法"><a href="#1-创建线程的方法" class="headerlink" title="1. 创建线程的方法"></a>1. 创建线程的方法</h4><h5 id="（1）方法一：通过继承Thread类创建线程"><a href="#（1）方法一：通过继承Thread类创建线程" class="headerlink" title="（1）方法一：通过继承Thread类创建线程"></a>（1）方法一：通过<font color="red">继承Thread类</font>创建线程</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124132913675.png" alt="image-20201124132913675"></p>
<h5 id="（2）方法二：通过实现Runnable接口来创建线程"><a href="#（2）方法二：通过实现Runnable接口来创建线程" class="headerlink" title="（2）方法二：通过实现Runnable接口来创建线程"></a>（2）方法二：通过<font color="red">实现Runnable接口</font>来创建线程</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124133310441.png" alt="image-20201124133310441"></p>
<h5 id="（3）方法三：不实现Runnable接口，直接使用匿名类的方式"><a href="#（3）方法三：不实现Runnable接口，直接使用匿名类的方式" class="headerlink" title="（3）方法三：不实现Runnable接口，直接使用匿名类的方式"></a>（3）方法三：不实现Runnable接口，直接<font color="red">使用匿名类</font>的方式</h5><h5 id="（方式二的简化）"><a href="#（方式二的简化）" class="headerlink" title="（方式二的简化）"></a>（方式二的简化）</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124133439513.png" alt="image-20201124133439513"></p>
<h4 id="2-线程的运行与停止"><a href="#2-线程的运行与停止" class="headerlink" title="2.线程的运行与停止"></a>2.线程的运行与停止</h4><h5 id="（1）myThread-interrupt"><a href="#（1）myThread-interrupt" class="headerlink" title="（1）myThread. interrupt ();"></a>（1）myThread<font color="cornflowerblue">. interrupt ();</font></h5><p>​        线程启动后并获得资源后，即可进入运行状态，执行run()方法中的业务逻辑。<br>在run()方法返回后，线程<font color="orange">自动终止</font>。</p>
<p>或者由主线程通知子线程终止，一般<font color="orange">调用interrupt()方法</font>通告线程准备终止</p>
<h5 id="（2）Thread-interrupted"><a href="#（2）Thread-interrupted" class="headerlink" title="（2）Thread.interrupted()"></a>（2）Thread.<font color="cornflowerblue">interrupted()</font></h5><p>​        interrupt()方法改变了线程内部的一个布尔值，可在run()方法检测到这个布尔值的改变，从而<font color="orange">在适当的时候释放资源和终止</font>线程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">run</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">while</span>(!Thread.<span class="built_in">interrupted</span>())&#123;</span><br><span class="line">         ...	<span class="comment">//未调用myThread.interrupt()时循环执行</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="七、异步消息处理机制（Handler-Message）"><a href="#七、异步消息处理机制（Handler-Message）" class="headerlink" title="七、异步消息处理机制（Handler + Message）"></a>七、异步消息处理机制（Handler + Message）</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140620842.png" alt="image-20201124140620842"></p>
<h4 id="1-异步消息处理流程"><a href="#1-异步消息处理流程" class="headerlink" title="1.异步消息处理流程"></a>1.异步消息处理流程</h4><h5 id="（1）主线程：创建Handler对象，重写handleMessage方法"><a href="#（1）主线程：创建Handler对象，重写handleMessage方法" class="headerlink" title="（1）主线程：创建Handler对象，重写handleMessage方法"></a>（1）主线程：创建Handler对象，重写handleMessage方法</h5><h5 id="（2）子线程：创建Message对象，发送消息"><a href="#（2）子线程：创建Message对象，发送消息" class="headerlink" title="（2）子线程：创建Message对象，发送消息"></a>（2）子线程：创建Message对象，发送消息</h5><p>​                当子线程需要进行UI操作时，就<font color="orange">创建Message</font>对象，并通过Handler的            <font color="orange">sendMessage()方法</font>（参数是Message对象），将将这条消息发送出去。            这条待处理的消息会被 添加到主线程的<font color="orange">MessageQueue</font>中。</p>
<h5 id="（3）主线程：处理消息，回调handleMessage"><a href="#（3）主线程：处理消息，回调handleMessage" class="headerlink" title="（3）主线程：处理消息，回调handleMessage"></a>（3）主线程：处理消息，回调handleMessage</h5><p>​            主线程通过<font color="orange">Looper管理</font>MessageQueue，不断地尝试从消息队列中取出    待处理消息进行处理，取出消息时就会回调 Handler的<font color="orange">handlerMessage()</font>方法</p>
<p>​        </p>
<h4 id="2-Hander类"><a href="#2-Hander类" class="headerlink" title="2.Hander类"></a>2.<font color="cornflowerblue">Hander</font>类</h4><p>使用Hnadler类的sendMessage()方法把一个包含消息数据的Message对象压入到消息队列。其它可选方法还包括：<br>sendEmptyMessage(int)<br>sendMessage(Message)<br>sendMessageAtTime(Message,long)<br>sendMessageDelayed(Message,long)</p>
<h4 id="3-Message类"><a href="#3-Message类" class="headerlink" title="3.Message类"></a>3.<font color="cornflowerblue">Message</font>类</h4><h5 id="（1）Message对象："><a href="#（1）Message对象：" class="headerlink" title="（1）Message对象："></a>（1）Message对象：</h5><p>推荐使用<font color="red">Message.obtain()</font> 静态方法从消息池中获取一个Message对象。<br>如果消息池为空， 将使用构造方法实例化一个新Message，以利于消息资源的利用。<br>一般并不推荐直接使用它的构造方法</p>
<h5 id="（2）用来封装所发送消息的值："><a href="#（2）用来封装所发送消息的值：" class="headerlink" title="（2）用来封装所发送消息的值："></a>（2）用来封装所发送消息的值：</h5><p>int arg1：参数一，用于传递不复杂的数据，复杂数据使用setData()传递。<br>int arg2：参数二，用于传递不复杂的数据，复杂数据使用setData()传递。<br>Object obj：传递一个任意的对象。<br>int what：定义的消息码，一般用于设定消息的标志。</p>
<h5 id="3-传递复杂数据-setData"><a href="#3-传递复杂数据-setData" class="headerlink" title="(3)传递复杂数据 setData()"></a>(3)传递复杂数据 setData()</h5><p>​    –void setData( Bundle bundle)</p>
<p>​    –Bundle getData()</p>
<h4 id="2-案例实现：幸运大抽奖（方式一）"><a href="#2-案例实现：幸运大抽奖（方式一）" class="headerlink" title="2.案例实现：幸运大抽奖（方式一）"></a>2.案例实现：幸运大抽奖（方式一）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140746244.png" alt="image-20201124140746244"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140752579.png" alt="image-20201124140752579"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140759685.png" alt="image-20201124140759685"></p>
<h3 id="八、异步消息处理机制（Handler-Post）"><a href="#八、异步消息处理机制（Handler-Post）" class="headerlink" title="八、异步消息处理机制（Handler + Post）"></a>八、异步消息处理机制（Handler + Post）</h3><h4 id="1-Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。-在主线程中执行"><a href="#1-Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。-在主线程中执行" class="headerlink" title="1. Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。(在主线程中执行)"></a>1. Handler也可以把一个<font color="cornflowerblue">Runnable对象</font>压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。(<font color="red">在主线程中执行</font>)</h4><h5 id="（1）把一个Runnable对象入队到消息队列-方法有："><a href="#（1）把一个Runnable对象入队到消息队列-方法有：" class="headerlink" title="（1）把一个Runnable对象入队到消息队列,方法有："></a>（1）把一个Runnable对象入队到消息队列,方法有：</h5><ul>
<li><p><font color="red">post</font>(Runnable)</p>
</li>
<li><p>postAtTime(Runnable,long)</p>
</li>
<li><p>postDelayed(Runnable,long)</p>
</li>
</ul>
<h5 id="2-从消息队列中移除一个Runnable对象"><a href="#2-从消息队列中移除一个Runnable对象" class="headerlink" title="(2)从消息队列中移除一个Runnable对象"></a>(2)从消息队列中移除一个Runnable对象</h5><p>​            void <font color="red">removeCallbacks</font>(Runnable r)</p>
<h4 id="2-对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run-方法。一般在这个run-方法中写入需要在UI线程上的操作。"><a href="#2-对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run-方法。一般在这个run-方法中写入需要在UI线程上的操作。" class="headerlink" title="2.对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run()方法。一般在这个run()方法中写入需要在UI线程上的操作。"></a>2.对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，<font color="red">重写run()方法</font>。一般在这个run()方法中写入<font color="red">需要在UI线程上的操作</font>。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201130202655320.png" alt="image-20201130202655320"></p>
<h4 id="3-案例实现：幸运大抽奖（方式二）"><a href="#3-案例实现：幸运大抽奖（方式二）" class="headerlink" title="3. 案例实现：幸运大抽奖（方式二）"></a>3. 案例实现：幸运大抽奖（方式二）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201130203252201.png" alt="image-20201130203252201"></p>
<h2 id="服务的原理和用途"><a href="#服务的原理和用途" class="headerlink" title="服务的原理和用途"></a>服务的原理和用途</h2><h3 id="一、启动服务的两种状态"><a href="#一、启动服务的两种状态" class="headerlink" title="一、启动服务的两种状态"></a>一、启动服务的两种状态</h3><h4 id="1-启动状态：通过Context的startService-启动service"><a href="#1-启动状态：通过Context的startService-启动service" class="headerlink" title="1.启动状态：通过Context的startService()启动service"></a>1.<font color="cornflowerblue">启动状态</font>：通过Context的<font color="red">startService()</font>启动service</h4><h5 id="一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService-或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁"><a href="#一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService-或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁" class="headerlink" title="一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService()或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁"></a>一旦启动，服务即<font color="orange">可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响</font>，除非手动调用stopService()或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁</h5><h4 id="2-绑定状态：通过Context的bindService-绑定Service"><a href="#2-绑定状态：通过Context的bindService-绑定Service" class="headerlink" title="2.绑定状态：通过Context的bindService()绑定Service"></a>2.<font color="cornflowerblue">绑定状态</font>：通过Context的<font color="red">bindService()</font>绑定Service</h4><p>​        <font color="orange">绑定服务提供了一个客户端-服务器接口，允许调用方与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。</font> 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个调用方可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁</p>
<h3 id="二、在清单文件中的声明"><a href="#二、在清单文件中的声明" class="headerlink" title="二、在清单文件中的声明"></a>二、在清单文件中的声明</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201125094605395.png" alt="image-20201125094605395"></p>
<h3 id="四、使用Service"><a href="#四、使用Service" class="headerlink" title="四、使用Service"></a>四、使用Service</h3><h4 id="1-首先要创建服务，必须创建-Service-的子类（或使用它的一个现有子类如IntentService）。"><a href="#1-首先要创建服务，必须创建-Service-的子类（或使用它的一个现有子类如IntentService）。" class="headerlink" title="1.首先要创建服务，必须创建 Service 的子类（或使用它的一个现有子类如IntentService）。"></a>1.首先要创建服务，必须<font color="red">创建 Service 的子类</font>（或使用它的一个现有子类如IntentService）。</h4><h4 id="2-类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。"><a href="#2-类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。" class="headerlink" title="2.类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。"></a>2.类似Activity，Service有自己的生命周期，因此在实现中需要<font color="red">重写一些回调方法</font>，以处理服务生命周期的某些关键过程。</h4><h4 id="3-随后，组件-例如活动-以启动或者绑定方式启动服务，服务开始其生命过程"><a href="#3-随后，组件-例如活动-以启动或者绑定方式启动服务，服务开始其生命过程" class="headerlink" title="3.随后，组件(例如活动)以启动或者绑定方式启动服务，服务开始其生命过程"></a>3.随后，组件(例如活动)以<font color="red">启动或者绑定方式启动服务</font>，服务开始其生命过程</h4><h3 id="五、Service中常用回调方法"><a href="#五、Service中常用回调方法" class="headerlink" title="五、Service中常用回调方法"></a>五、Service中常用回调方法</h3><h4 id="1-abstract-IBinder-onBind-Intent-intent"><a href="#1-abstract-IBinder-onBind-Intent-intent" class="headerlink" title="1.abstract IBinder onBind(Intent intent)"></a>1.abstract IBinder <font color="cornflowerblue">onBind</font>(Intent intent)</h4><p>该方法是一个抽象方法，所有Service子类必须实现该方法。该方法将返回一个IBinder对象，应用程序可<font color="red">通过该对象与Service组件通信</font>；</p>
<h4 id="2-void-onCreate"><a href="#2-void-onCreate" class="headerlink" title="2.void onCreate()"></a>2.void <font color="cornflowerblue">onCreate()</font></h4><p>当Service<font color="red">第一次被创建时</font>，将立即回调该方法；</p>
<h4 id="3-void-onDestroy"><a href="#3-void-onDestroy" class="headerlink" title="3.void onDestroy()"></a>3.void <font color="cornflowerblue">onDestroy()</font></h4><p>当Service<font color="red">被关闭之前</font>，将回调该方法</p>
<h4 id="4-void-onStartCommand-Intent-intent-int-flags-int-startId"><a href="#4-void-onStartCommand-Intent-intent-int-flags-int-startId" class="headerlink" title="4.void onStartCommand(Intent intent,int flags,int startId)"></a>4.void <font color="cornflowerblue">onStartCommand(Intent intent,int flags,int startId)</font></h4><p>每次客户端调用startService(Intent intent)方法<font color="red">启动</font>该Service时<font color="red">都会回调</font>onStartCommand()方法</p>
<h4 id="5-boolean-onUnbind-Intent-intent"><a href="#5-boolean-onUnbind-Intent-intent" class="headerlink" title="5.boolean onUnbind(Intent intent)"></a>5.boolean <font color="cornflowerblue">onUnbind(Intent intent)</font></h4><p>当该Service上绑定的所有客户端都<font color="red">断开连接</font>时将会回调该方法。</p>
<h3 id="六、活动的生命周期"><a href="#六、活动的生命周期" class="headerlink" title="六、活动的生命周期"></a>六、活动的生命周期</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201125095321429.png" alt="image-20201125095321429"></p>
<h2 id="启动方式启动服务"><a href="#启动方式启动服务" class="headerlink" title="启动方式启动服务"></a>启动方式启动服务</h2><h3 id="一、StartService生命周期及进程相关"><a href="#一、StartService生命周期及进程相关" class="headerlink" title="一、StartService生命周期及进程相关"></a>一、StartService生命周期及进程相关</h3><h4 id="1-对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。"><a href="#1-对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。" class="headerlink" title="1.对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。"></a>1.对于同一类型的Service，<font color="red">Service实例永远只存在一个</font>，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。</h4><h4 id="2-以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService-或服务本身调用stopSelf-才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service"><a href="#2-以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService-或服务本身调用stopSelf-才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service" class="headerlink" title="2.以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService(..)或服务本身调用stopSelf(..)才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service"></a>2.以启动方式运行的服务，其<font color="red">生命周期是独立的，与Client本身的生命周期没有任何关系</font>，只有Client调用stopService(..)或服务本身调用stopSelf(..)才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service</h4><h4 id="3-Client-A-通过startService-启动Service后-可以在其他Client（如Client-B、Client-C）通过调用stopService-结束此Service"><a href="#3-Client-A-通过startService-启动Service后-可以在其他Client（如Client-B、Client-C）通过调用stopService-结束此Service" class="headerlink" title="3.Client A 通过startService(..)启动Service后,可以在其他Client（如Client B、Client C）通过调用stopService(..)结束此Service"></a>3.Client A 通过<font color="red">startService(..)</font>启动Service后,可以在其他Client（如Client B、Client C）通过调用<font color="red">stopService(..)结束</font>此Service</h4><h4 id="4-Client调用stopService-时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService-无需做当前Service是否有效的判断。"><a href="#4-Client调用stopService-时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService-无需做当前Service是否有效的判断。" class="headerlink" title="4.Client调用stopService(..)时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService(..)无需做当前Service是否有效的判断。"></a>4.Client调用stopService(..)时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService(..)<font color="red">无需做当前Service是否有效的判断。</font></h4><h4 id="5-startService-Intent-serviceIntent-，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。"><a href="#5-startService-Intent-serviceIntent-，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。" class="headerlink" title="5.startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。"></a>5.startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用<font color="red">显示Intent</font>。当处于不同App时，只能使用隐式Intent。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111515792.png" alt="image-20201214111515792"></p>
<h3 id="二、Client与Service通信相关"><a href="#二、Client与Service通信相关" class="headerlink" title="二、Client与Service通信相关"></a>二、Client与Service通信相关</h3><h4 id="1-启动Service时"><a href="#1-启动Service时" class="headerlink" title="1.启动Service时"></a>1.启动Service时</h4><h5 id="当Client调用startService-Intent-serviceIntent-启动Service时，Client可以将参数通过Intent直接传递给Service。"><a href="#当Client调用startService-Intent-serviceIntent-启动Service时，Client可以将参数通过Intent直接传递给Service。" class="headerlink" title="当Client调用startService(Intent serviceIntent)启动Service时，Client可以将参数通过Intent直接传递给Service。"></a>当Client调用startService(Intent serviceIntent)<font color="red">启动Service</font>时，Client可以<font color="red">将参数通过Intent直接传递</font>给Service。</h5><h4 id="2-Service执行过程中"><a href="#2-Service执行过程中" class="headerlink" title="2.Service执行过程中"></a>2.Service执行过程中</h4><h5 id="Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。"><a href="#Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。" class="headerlink" title="Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。"></a><font color="red">Service执行过程</font>中，如果需要将参数传递给Client，一般可以通过<font color="red">借助于发送广播</font>的方式（此时，Client需要注册此广播）。</h5><h2 id="绑定方式启动服务"><a href="#绑定方式启动服务" class="headerlink" title="绑定方式启动服务"></a>绑定方式启动服务</h2><h3 id="一、三个基本特征"><a href="#一、三个基本特征" class="headerlink" title="一、三个基本特征"></a>一、三个基本特征</h3><h4 id="1-C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器"><a href="#1-C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器" class="headerlink" title="1.C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器"></a>1.<font color="cornflowerblue">C-S模式</font>：绑定状态的服务代表着客户端-服务器接口中的<font color="orange">服务器</font></h4><h4 id="2-交互与通信：当其他组件（如-Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信-。"><a href="#2-交互与通信：当其他组件（如-Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信-。" class="headerlink" title="2.交互与通信：当其他组件（如 Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信 。"></a>2.<font color="cornflowerblue">交互与通信</font>：当其他组件（如 Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，<font color="orange">或者调用Service（服务端）的方法</font>，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信 。</h4><h4 id="3-生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件-如Activity-服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主-如Activity-解除绑定后，绑定服务就会被销毁。"><a href="#3-生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件-如Activity-服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主-如Activity-解除绑定后，绑定服务就会被销毁。" class="headerlink" title="3.生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主(如Activity)解除绑定后，绑定服务就会被销毁。"></a>3.<font color="cornflowerblue">生命周期</font>：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说所有<font color="orange">宿主(如Activity)解除绑定后，绑定服务就会被销毁</font>。</h4><h3 id="二、BindService生命周期"><a href="#二、BindService生命周期" class="headerlink" title="二、BindService生命周期"></a>二、BindService生命周期</h3><h4 id="1-onBind方法只被调用一次。（当调用bindService-方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind-方法。"><a href="#1-onBind方法只被调用一次。（当调用bindService-方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind-方法。" class="headerlink" title="1.onBind方法只被调用一次。（当调用bindService()方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind()方法。"></a>1.onBind方法只被调用一次。（当调用<font color="orange">bindService()</font>方法是）Service第一次被创建时会执行<font color="red">onCreate</font>方法，之后自动调用<font color="red">onBind()</font>方法。</h4><h4 id="2-当调用unBindService-方法时，Service会依次执行onUnbind-、onDestroy-方法结束生命周期"><a href="#2-当调用unBindService-方法时，Service会依次执行onUnbind-、onDestroy-方法结束生命周期" class="headerlink" title="2.当调用unBindService()方法时，Service会依次执行onUnbind()、onDestroy()方法结束生命周期"></a>2.当调用<font color="orange">unBindService()</font>方法时，Service会依次执行<font color="red">onUnbind()</font>、<font color="red">onDestroy()</font>方法结束生命周期</h4><h4 id="3-如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService-解除绑定。"><a href="#3-如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService-解除绑定。" class="headerlink" title="3.如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService()解除绑定。"></a>3.如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService()解除绑定。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/577f98926daf5.jpg" alt="img"></p>
<h3 id="三、一般流程！！！"><a href="#三、一般流程！！！" class="headerlink" title="三、一般流程！！！"></a>三、一般流程！！！</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111833380.png" alt="image-20201214111833380"></p>
<h4 id="1-服务端，Service中"><a href="#1-服务端，Service中" class="headerlink" title="1.服务端，Service中"></a>1.服务端，Service中</h4><h5 id="（1）创建Binder子类，返回服务实例对象"><a href="#（1）创建Binder子类，返回服务实例对象" class="headerlink" title="（1）创建Binder子类，返回服务实例对象"></a>（1）<font color="cornflowerblue">创建Binder子类，返回服务实例对象</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110207275.png" alt="image-20201214110207275"></p>
<h5 id="（2）在onBind-中返回Mybinder的实例对象iBinder"><a href="#（2）在onBind-中返回Mybinder的实例对象iBinder" class="headerlink" title="（2）在onBind()中返回Mybinder的实例对象iBinder"></a>（2）<font color="cornflowerblue">在onBind()中返回Mybinder的实例对象iBinder</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110333487.png" alt="image-20201214110333487"></p>
<h4 id="2-客户端，Activity中"><a href="#2-客户端，Activity中" class="headerlink" title="2.客户端，Activity中"></a>2.客户端，Activity中</h4><h5 id="（1）创建ServiceConnection实例，在onServiceConnected-中接收返回的Binder-实例，通过Binder实例的getService-方法获取服务实例myService"><a href="#（1）创建ServiceConnection实例，在onServiceConnected-中接收返回的Binder-实例，通过Binder实例的getService-方法获取服务实例myService" class="headerlink" title="（1）创建ServiceConnection实例，在onServiceConnected 中接收返回的Binder 实例，通过Binder实例的getService()方法获取服务实例myService"></a>（1）<font color="cornflowerblue">创建ServiceConnection实例，在onServiceConnected 中接收返回的Binder 实例，通过Binder实例的getService()方法获取服务实例myService</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110911643.png" alt="image-20201214110911643"></p>
<h5 id="2-绑定之后可以通过myService方法调用服务中的方法"><a href="#2-绑定之后可以通过myService方法调用服务中的方法" class="headerlink" title="(2)绑定之后可以通过myService方法调用服务中的方法"></a>(2)<font color="cornflowerblue">绑定之后可以通过myService方法调用服务中的方法</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111553877.png" alt="image-20201214111553877"></p>
<h5 id="（3）解除绑定"><a href="#（3）解除绑定" class="headerlink" title="（3）解除绑定"></a>（3）<font color="cornflowerblue">解除绑定</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111631223.png" alt="image-20201214111631223"></p>
<p><font color="red">注：也可以将服务中的方法写在内部类mybinder中，在活动的ServiceConnect实例的onServiceConnected()中获取myBinder实例，通过这个实例调用服务中的方法。（不推荐）</font></p>
<h2 id="混合使用启动方式和绑定方式"><a href="#混合使用启动方式和绑定方式" class="headerlink" title="混合使用启动方式和绑定方式"></a>混合使用启动方式和绑定方式</h2><h3 id="一、混合开启服务"><a href="#一、混合开启服务" class="headerlink" title="一、混合开启服务"></a>一、混合开启服务</h3><p>既然<font color="red">start开启的服务不能调用方法，bind方式开启的服务生命力又很弱</font>，那么能否两种方式的有点么？答案当然是肯定的，否则服务的应用能力就太弱了。</p>
<ol>
<li><h4 id="通过startService-方式开启服务-只能通过调用stopService停止"><a href="#通过startService-方式开启服务-只能通过调用stopService停止" class="headerlink" title="通过startService()方式开启服务(只能通过调用stopService停止)"></a>通过startService()方式开启服务(只能通过调用stopService停止)</h4></li>
<li><h4 id="通过bindService进行绑定，以进行服务的方法调用-当需要的时候"><a href="#通过bindService进行绑定，以进行服务的方法调用-当需要的时候" class="headerlink" title="通过bindService进行绑定，以进行服务的方法调用(当需要的时候)"></a>通过bindService进行绑定，以进行服务的方法调用(当需要的时候)</h4></li>
<li><h4 id="通过unbindService进行解绑-不需要调用方法了，在UI线程被销毁之前解绑"><a href="#通过unbindService进行解绑-不需要调用方法了，在UI线程被销毁之前解绑" class="headerlink" title="通过unbindService进行解绑(不需要调用方法了，在UI线程被销毁之前解绑)"></a>通过unbindService进行解绑(不需要调用方法了，在UI线程被销毁之前解绑)</h4></li>
<li><h4 id="通过stopService停止服务"><a href="#通过stopService停止服务" class="headerlink" title="通过stopService停止服务"></a>通过stopService停止服务</h4></li>
</ol>
<p>这样我们就可以灵活的使用Service，<font color="red">当需要的时候可以随时进行调用，不要的时候又可以长期运行于后台而不用保留UI线程</font>。这也是服务最常见的用法。</p>
<h3 id="二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。"><a href="#二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。" class="headerlink" title="二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。"></a>二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。</h3><h3 id="三、如果想停止服务，必须调用stopService，并且所有调用-bindService-的-Context调用unbindService解绑-或者之前调用-bindService-的-Context-不存在了。"><a href="#三、如果想停止服务，必须调用stopService，并且所有调用-bindService-的-Context调用unbindService解绑-或者之前调用-bindService-的-Context-不存在了。" class="headerlink" title="三、如果想停止服务，必须调用stopService，并且所有调用 bindService 的 Context调用unbindService解绑,或者之前调用 bindService 的 Context 不存在了。"></a>三、如果想停止服务，必须<font color="cornflowerblue">调用stopService</font>，并且所有调用 bindService 的 Context调用<font color="cornflowerblue">unbindService</font><font color="orange">解绑</font>,或者之前调用 bindService 的 Context<font color="orange"> 不存在</font>了。</h3><h2 id="服务的更多使用技巧"><a href="#服务的更多使用技巧" class="headerlink" title="服务的更多使用技巧"></a>服务的更多使用技巧</h2><h3 id="一、使用前台服务"><a href="#一、使用前台服务" class="headerlink" title="一、使用前台服务"></a>一、使用前台服务</h3><h4 id="1-服务运行在后台，优先级低，系统内存不足时，可能会被回收。"><a href="#1-服务运行在后台，优先级低，系统内存不足时，可能会被回收。" class="headerlink" title="1.服务运行在后台，优先级低，系统内存不足时，可能会被回收。"></a>1.服务运行在后台，优先级低，系统内存不足时，<font color="red">可能会被回收</font>。</h4><p>如果希望服务<font color="red">可以一直保持运行状态</font>，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台服务。</p>
<h4 id="2-与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。"><a href="#2-与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。" class="headerlink" title="2.与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。"></a>2.<font color="cornflowerblue">与普通服务相比</font>：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。</h4><h4 id="3-startForeground-和stopForeground-方法"><a href="#3-startForeground-和stopForeground-方法" class="headerlink" title="3.startForeground()和stopForeground()方法"></a>3.<font color="cornflowerblue">startForeground()</font>和<font color="cornflowerblue">stopForeground()</font>方法</h4><p>startForeground(1,notification);</p>
<h3 id="二、使用IntentService"><a href="#二、使用IntentService" class="headerlink" title="二、使用IntentService"></a>二、使用IntentService</h3><p>（未完待续……）</p>
]]></content>
      <categories>
        <category>《 Android基础》</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>《Android小菜》</title>
    <url>/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/</url>
    <content><![CDATA[<div class="note success modern"><p><strong>前言：</strong>目录结构还有待优化，可直接ctrl+F搜索有无需要了解的内容<br>本笔记属于个人初学android过程时总结，如有错误或者图片缺失，还请留言指正，十分感谢！<br>仅供学习参考，如需转载请注明来自[Durango]: <a href="http://www.durango.cn/">www.durango.cn</a></p>
</div>



<h1 id="第一章-控件与布局"><a href="#第一章-控件与布局" class="headerlink" title="第一章 控件与布局"></a>第一章 控件与布局</h1><h2 id="一、界面的美化-Shape和Selector例举"><a href="#一、界面的美化-Shape和Selector例举" class="headerlink" title="一、界面的美化(Shape和Selector例举)"></a>一、界面的美化(Shape和Selector例举)</h2><h3 id="1-背景颜色的渐变"><a href="#1-背景颜色的渐变" class="headerlink" title="1.背景颜色的渐变"></a>1.背景颜色的<font color="cornflowerblue">渐变</font></h3><h4 id="res-rawable-background-login-xml-整个布局的背景，渐变背景"><a href="#res-rawable-background-login-xml-整个布局的背景，渐变背景" class="headerlink" title="res/ rawable/ background_login.xml, 整个布局的背景，渐变背景"></a>res/ rawable/ background_login.xml, 整个布局的背景，渐变背景</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line"> &lt;gradient</span><br><span class="line"> android:angle=&quot;90&quot;</span><br><span class="line"> android:endColor=&quot;#FF72CAE1&quot;</span><br><span class="line"> android:startColor=&quot;#FFACDAE5&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-单色填充带圆角-按钮、局部的布局"><a href="#2-单色填充带圆角-按钮、局部的布局" class="headerlink" title="2.单色填充带圆角(按钮、局部的布局)"></a>2.单色填充带<font color="cornflowerblue">圆角</font>(按钮、局部的布局)</h3><h4 id="res-rawable-background-login-div-xml-登录框部分的背景，单色填充，带圆角"><a href="#res-rawable-background-login-div-xml-登录框部分的背景，单色填充，带圆角" class="headerlink" title="res/ rawable/background_login_div.xml, 登录框部分的背景，单色填充，带圆角"></a><strong>res/ rawable/background_login_div.xml,</strong> 登录框部分的背景，单色填充，带圆角</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line"> &lt;solid android:color=&quot;#55FFFFFF&quot; /&gt;</span><br><span class="line"> &lt;corners</span><br><span class="line"> android:bottomLeftRadius=&quot;10dp&quot;</span><br><span class="line"> android:bottomRightRadius=&quot;10dp&quot;</span><br><span class="line"> android:topLeftRadius=&quot;10dp&quot;</span><br><span class="line"> android:topRightRadius=&quot;10dp&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>



<h3 id="3-文本框不同状态的背景设置"><a href="#3-文本框不同状态的背景设置" class="headerlink" title="3.文本框不同状态的背景设置"></a>3.文本框<font color="cornflowerblue">不同状态的背景</font>设置</h3><h4 id="res-drawable-edit-login-xml-两个编辑输入框的背景，edit-login-是一个-selector，针对正在输入和其它状态设-置不同的背景图片，login-input-和-input-over-是-res-drawable-目录下的两张-png-图片-Educoder-平台已经共享-，名-字分别是-input-over-9-png-和-input-input-9-png"><a href="#res-drawable-edit-login-xml-两个编辑输入框的背景，edit-login-是一个-selector，针对正在输入和其它状态设-置不同的背景图片，login-input-和-input-over-是-res-drawable-目录下的两张-png-图片-Educoder-平台已经共享-，名-字分别是-input-over-9-png-和-input-input-9-png" class="headerlink" title="res/drawable/edit_login.xml**, 两个编辑输入框的背景，edit_login 是一个 selector，针对正在输入和其它状态设 置不同的背景图片，login_input 和 input_over 是 res/drawable 目录下的两张 png 图片(Educoder 平台已经共享)，名 字分别是 input_over.9.png 和 input_input.9.png"></a>res/drawable/edit_login.xml**, 两个编辑输入框的背景，edit_login 是一个 selector，针对正在输入和其它状态设 置不同的背景图片，login_input 和 input_over 是 res/drawable 目录下的两张 png 图片(Educoder 平台已经共享)，名 字分别是 input_over.9.png 和 input_input.9.png</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;item </span><br><span class="line">	 android:state_enabled=&quot;false&quot;</span><br><span class="line"> 	android:drawable=&quot;@drawable/login_input&quot;/&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:state_focused=&quot;true&quot;</span><br><span class="line"> 	android:drawable=&quot;@drawable/input_over&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>



<h3 id="4-按钮不同状态的文字颜色"><a href="#4-按钮不同状态的文字颜色" class="headerlink" title="4.按钮不同状态的文字颜色"></a>4.按钮<font color="cornflowerblue">不同状态的文字颜色</font></h3><h4 id="res-drawable-text-btn-selector-xml-两个按钮的-textColor-属性，这是按钮的文本颜色，这是一个-selector，使得按钮在不同状态下的文字颜色显示不同。"><a href="#res-drawable-text-btn-selector-xml-两个按钮的-textColor-属性，这是按钮的文本颜色，这是一个-selector，使得按钮在不同状态下的文字颜色显示不同。" class="headerlink" title="res/drawable/text_btn_selector.xml, 两个按钮的 textColor 属性，这是按钮的文本颜色，这是一个 selector，使得按钮在不同状态下的文字颜色显示不同。"></a><strong>res/drawable/text_btn_selector.xml</strong>, 两个按钮的 textColor 属性，这是按钮的文本颜色，这是一个 selector，使得按钮在不同状态下的文字颜色显示不同。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"> 		&lt;!-- 当前窗口失去焦点时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/black&quot; </span><br><span class="line"> 	android:state_window_focused=&quot;false&quot; /&gt;</span><br><span class="line">		 &lt;!-- 不可用时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/background_light&quot; 				  			android:state_enabled=&quot;false&quot; /&gt;</span><br><span class="line"> 		 &lt;!-- 按压时 --&gt;</span><br><span class="line"> &lt;item android:color=&quot;@android:color/holo_blue_light&quot;  		           		    	   android:state_pressed=&quot;true&quot; /&gt;</span><br><span class="line"> 		&lt;!-- 被选中时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/holo_green_dark&quot;</span><br><span class="line"> 	android:state_selected=&quot;true&quot; /&gt;</span><br><span class="line"> 		&lt;!-- 被激活时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/holo_green_light&quot; 	</span><br><span class="line"> 	android:state_activated=&quot;true&quot; /&gt;</span><br><span class="line">		&lt;!-- 默认时 --&gt;</span><br><span class="line"> &lt;item android:color=&quot;@android:color/white&quot; /&gt;</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>



<h2 id="二、Shape"><a href="#二、Shape" class="headerlink" title="二、Shape"></a>二、Shape</h2><h3 id="1-Shape可以画四种图形"><a href="#1-Shape可以画四种图形" class="headerlink" title="1.Shape可以画四种图形"></a>1.Shape可以画四种图形</h3><h4 id="矩形（rectangle）、椭圆（oval）、线（line）、圆环（ring）。"><a href="#矩形（rectangle）、椭圆（oval）、线（line）、圆环（ring）。" class="headerlink" title="矩形（rectangle）、椭圆（oval）、线（line）、圆环（ring）。"></a>矩形（<font color="red">rectangle</font>）、椭圆（<font color="red">oval</font>）、线（<font color="red">line</font>）、圆环（<font color="red">ring</font>）。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shape xmIns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">	android:shape=&quot;rectangle&quot;&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-五种效果（利用-xml-文件描述，作为一种资源，放于drawable目-录。）"><a href="#2-五种效果（利用-xml-文件描述，作为一种资源，放于drawable目-录。）" class="headerlink" title="2.五种效果（利用 xml 文件描述，作为一种资源，放于drawable目                        录。）"></a>2.五种效果（利用 xml 文件描述，作为一种<font color="orange">资源</font>，放于drawable目                        录。）</h3><h4 id="（1）solid：填充"><a href="#（1）solid：填充" class="headerlink" title="（1）solid：填充"></a>（1）<font color="red">solid</font>：填充</h4><pre><code>                        android:color指定填充的颜色；
</code></pre>
<h4 id="（2）-gradient：渐变"><a href="#（2）-gradient：渐变" class="headerlink" title="（2） gradient：渐变"></a>（2） <font color="red">gradient</font>：渐变</h4><ul>
<li><h4 id="android-startColor和android-endColor-分别为起始和结束颜色"><a href="#android-startColor和android-endColor-分别为起始和结束颜色" class="headerlink" title="android:startColor和android:endColor 分别为起始和结束颜色"></a>android:startColor和android:endColor 分别为起始和结束颜色</h4></li>
<li><h4 id="android-angle-是渐变角度，必须为45的整数倍。"><a href="#android-angle-是渐变角度，必须为45的整数倍。" class="headerlink" title="android:angle 是渐变角度，必须为45的整数倍。"></a>android:angle 是渐变角度，必须为45的整数倍。</h4></li>
<li><h4 id="android-type-”linear”，线性渐变-默认"><a href="#android-type-”linear”，线性渐变-默认" class="headerlink" title="android:type=”linear”，线性渐变(默认)"></a>android:type=”linear”，线性渐变(默认)</h4></li>
<li><h4 id="android-type-”radial”，径向渐变"><a href="#android-type-”radial”，径向渐变" class="headerlink" title="android:type=”radial”，径向渐变"></a>android:type=”radial”，径向渐变</h4></li>
<li><h4 id="android-gradientRadius-”50”，径向渐变需要指定半径"><a href="#android-gradientRadius-”50”，径向渐变需要指定半径" class="headerlink" title="android:gradientRadius=”50”，径向渐变需要指定半径"></a>android:gradientRadius=”50”，径向渐变需要指定半径</h4></li>
</ul>
<h4 id="（3）-stroke：描边"><a href="#（3）-stroke：描边" class="headerlink" title="（3） stroke：描边"></a>（3）<font color="red"> stroke</font>：描边</h4><ul>
<li><h4 id="android-width-”2dp”-描边的宽度"><a href="#android-width-”2dp”-描边的宽度" class="headerlink" title="android:width=”2dp”  描边的宽度"></a>android:width=”2dp”  描边的宽度</h4></li>
<li><h4 id="android-color-描边的颜色"><a href="#android-color-描边的颜色" class="headerlink" title="android:color  描边的颜色"></a>android:color  描边的颜色</h4></li>
<li><h4 id="还可以把描边为虚线的形式，设置方式为："><a href="#还可以把描边为虚线的形式，设置方式为：" class="headerlink" title="还可以把描边为虚线的形式，设置方式为："></a>还可以把描边为<font color="orange">虚线</font>的形式，设置方式为：</h4><p>android:dashWidth=”5dp”<br>android:dashGap=”3dp”</p>
</li>
</ul>
<h4 id="（4）corners：圆角"><a href="#（4）corners：圆角" class="headerlink" title="（4）corners：圆角"></a>（4）<font color="red">corners</font>：圆角</h4><ul>
<li><h4 id="android-Radius-”20dp”-设置四个角的半径"><a href="#android-Radius-”20dp”-设置四个角的半径" class="headerlink" title="android:Radius=”20dp”               设置四个角的半径"></a>android:Radius=”20dp”               设置四个角的半径</h4></li>
<li><h4 id="android-topLeftRadius-”20dp”-设置左上角的半径"><a href="#android-topLeftRadius-”20dp”-设置左上角的半径" class="headerlink" title="android:topLeftRadius=”20dp”         设置左上角的半径"></a>android:topLeftRadius=”20dp”         设置左上角的半径</h4></li>
<li><h4 id="android-topRightRadius-”20dp”-设置右上角的半径"><a href="#android-topRightRadius-”20dp”-设置右上角的半径" class="headerlink" title="android:topRightRadius=”20dp”        设置右上角的半径"></a>android:topRightRadius=”20dp”        设置右上角的半径</h4></li>
<li><h4 id="android-bottomLeftRadius-”20dp”-设置右下角的半径"><a href="#android-bottomLeftRadius-”20dp”-设置右下角的半径" class="headerlink" title="android:bottomLeftRadius=”20dp”      设置右下角的半径"></a>android:bottomLeftRadius=”20dp”      设置右下角的半径</h4></li>
<li><h4 id="android-bottomRightRadius-”20dp”-设置左下角的半径"><a href="#android-bottomRightRadius-”20dp”-设置左下角的半径" class="headerlink" title="android:bottomRightRadius=”20dp”     设置左下角的半径"></a>android:bottomRightRadius=”20dp”     设置左下角的半径</h4></li>
</ul>
<h4 id="（5）padding：间隔"><a href="#（5）padding：间隔" class="headerlink" title="（5）padding：间隔"></a>（5）<font color="red">padding</font>：间隔</h4><h5 id="可以设置上下左右四个方向的间隔。"><a href="#可以设置上下左右四个方向的间隔。" class="headerlink" title="可以设置上下左右四个方向的间隔。"></a>可以设置上下左右四个方向的间隔。</h5><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200922232849670.png" alt="image-20200922232849670"></p>
<h2 id="三、Selector"><a href="#三、Selector" class="headerlink" title="三、Selector"></a>三、Selector</h2><h3 id="1-以Button为例，关键状态属性如下："><a href="#1-以Button为例，关键状态属性如下：" class="headerlink" title="1.以Button为例，关键状态属性如下："></a>1.以Button为例，关键状态属性如下：</h3><table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>android:<strong>state_selected</strong></td>
<td>设置是否选中状态，true表示已选中，false表示未选中</td>
</tr>
<tr>
<td>android:<strong>state_focused</strong></td>
<td>设置是否获得焦点状态，true表示获得焦点，默认为false，表示未获得焦点</td>
</tr>
<tr>
<td>android:<strong>state_pressed</strong></td>
<td>设置是否按压状态，一般在true时设置该属性，表示已按压状态，默认为false</td>
</tr>
<tr>
<td>android:<strong>state_enabled</strong></td>
<td>设置是否响应事件,指所有事件；一般只在false时设置该属性，表示不可用状态</td>
</tr>
<tr>
<td>android:<strong>state_activated</strong>:</td>
<td>设置是否被激活状态，true表示被激活，false表示未激活，API Level 11及以上才支持，可通过代码调用控件的setActivated(boolean)方法设置是否激活该控件</td>
</tr>
</tbody></table>
<h3 id="2-示例：text-btn-selector-xml的代码，用于按钮的文本颜色t"><a href="#2-示例：text-btn-selector-xml的代码，用于按钮的文本颜色t" class="headerlink" title="2.示例：text_btn_selector.xml的代码，用于按钮的文本颜色t"></a>2.示例：text_btn_selector.xml的代码，用于按钮的文本颜色t</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- 不可用时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/background_light&quot;</span><br><span class="line">    	android:state_enabled=&quot;false&quot; /&gt;</span><br><span class="line">    &lt;!-- 按压时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/holo_blue_light&quot; </span><br><span class="line">    	android:state_pressed=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;!-- 被选中时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/holo_green_dark&quot;</span><br><span class="line">    	android:state_selected=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;!-- 被激活时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/holo_green_light&quot;</span><br><span class="line">    	android:state_activated=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;!-- 默认时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/white&quot; /&gt;</span><br><span class="line">&lt;/selector&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="在控件中引用-android-background-”-drawable-bg-btn-selector”"><a href="#在控件中引用-android-background-”-drawable-bg-btn-selector”" class="headerlink" title="在控件中引用 android:background=”@drawable/bg_btn_selector”"></a>在控件中引用 <font color="red">android:background=”@drawable/bg_btn_selector”</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Button </span><br><span class="line">    android:id=&quot;@+id/btn_default&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_margin=&quot;8dp&quot;</span><br><span class="line">    android:background=&lt;Button </span><br><span class="line">    android:id=&quot;@+id/btn_default&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_margin=&quot;8dp&quot;</span><br><span class="line">    android:background=&quot;@drawable/bg_btn_selector&quot;</span><br><span class="line">    android:text=&quot;默认按钮&quot;</span><br><span class="line">    android:textColor=&quot;@color/text_btn_selector&quot; /&gt;</span><br><span class="line">&quot;</span><br><span class="line">    android:text=&quot;默认按钮&quot;</span><br><span class="line">    android:textColor=&quot;@color/text_btn_selector&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923134625276.png" alt="image-20200923134625276" style="zoom: 80%;">



<h2 id="四、登录布局和背景优化"><a href="#四、登录布局和背景优化" class="headerlink" title="四、登录布局和背景优化"></a>四、登录布局和背景优化</h2><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135110680.png" alt="image-20200923135110680"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135119943.png" alt="image-20200923135119943"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135127485.png" alt="image-20200923135127485"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135145022.png" alt="image-20200923135145022"></p>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135612629.png" alt="image-20200923135612629" style="zoom:50%;">





<h2 id="五、View概念"><a href="#五、View概念" class="headerlink" title="五、View概念"></a>五、View概念</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul>
<li><h4 id="多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。"><a href="#多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。" class="headerlink" title="多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。"></a>多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。</h4></li>
<li><h4 id="Android应用的界面都是由View和ViewGroup对象构建的，"><a href="#Android应用的界面都是由View和ViewGroup对象构建的，" class="headerlink" title="Android应用的界面都是由View和ViewGroup对象构建的，"></a>Android应用的界面都是由View和ViewGroup对象构建的，</h4></li>
<li><h4 id="ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。"><a href="#ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。" class="headerlink" title="ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。"></a>ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。</h4></li>
</ul>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923140230137.png" alt="image-20200923140230137" style="zoom: 67%;">



<h3 id="2-View类的常用属性与方法"><a href="#2-View类的常用属性与方法" class="headerlink" title="2.View类的常用属性与方法"></a>2.View类的常用属性与方法</h3><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923140315637.png" alt="image-20200923140315637"></p>
<h3 id="3-用户界面组件包widget"><a href="#3-用户界面组件包widget" class="headerlink" title="3.用户界面组件包widget"></a>3.用户界面组件包widget</h3><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923140439546.png" alt="image-20200923140439546" style="zoom:80%;">





<h1 id="第二章-Android-列表"><a href="#第二章-Android-列表" class="headerlink" title="第二章 Android 列表"></a>第二章 Android 列表</h1><h2 id="一、AdapterView及其子类"><a href="#一、AdapterView及其子类" class="headerlink" title="一、AdapterView及其子类"></a>一、AdapterView及其子类</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002124214084.png" alt="image-20201002124214084" style="zoom: 50%;"></h3><h3 id="2-AdapterView子类"><a href="#2-AdapterView子类" class="headerlink" title="2.AdapterView子类"></a>2.AdapterView子类</h3><ul>
<li><h4 id="ListView：列表，通常含有一个TextView控件。"><a href="#ListView：列表，通常含有一个TextView控件。" class="headerlink" title="ListView：列表，通常含有一个TextView控件。"></a>ListView：列表，通常含有一个TextView控件。</h4></li>
<li><h4 id="Spinner：下拉列表，给用户提供选择。"><a href="#Spinner：下拉列表，给用户提供选择。" class="headerlink" title="Spinner：下拉列表，给用户提供选择。"></a>Spinner：下拉列表，给用户提供选择。</h4></li>
<li><h4 id="Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。"><a href="#Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。" class="headerlink" title="Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。"></a>Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。</h4></li>
<li><h4 id="GridView：网格图，以表格形式显示资源，可以左右滑动的。"><a href="#GridView：网格图，以表格形式显示资源，可以左右滑动的。" class="headerlink" title="GridView：网格图，以表格形式显示资源，可以左右滑动的。"></a>GridView：网格图，以表格形式显示资源，可以左右滑动的。</h4></li>
</ul>
<h2 id="二、ListView"><a href="#二、ListView" class="headerlink" title="二、ListView"></a>二、ListView</h2><h3 id="1-XML属性"><a href="#1-XML属性" class="headerlink" title="1.XML属性"></a>1.XML属性</h3><table>
<thead>
<tr>
<th><strong>XML****属性</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>android:divider</strong></td>
<td>设置分割条样式（颜色或者Drawable对象）</td>
</tr>
<tr>
<td><strong>android:dividerHeight</strong></td>
<td>设置分割条高度</td>
</tr>
<tr>
<td><font color="red">android:entries（数据源）</font></td>
<td>指定一个数组资源，用来填充ListView项</td>
</tr>
<tr>
<td><strong>android:footerDividersEnabled</strong></td>
<td>设置为false，则不在footer view之前绘制分割条</td>
</tr>
<tr>
<td><strong>android:headerDividersEnabled</strong></td>
<td>设置为false，则不在header view之后绘制分割条</td>
</tr>
<tr>
<td><strong>android:scrollbars</strong></td>
<td>设置是否显示滚动条</td>
</tr>
<tr>
<td><strong>android:fadingEdge</strong></td>
<td>设置是否去除ListView滑到顶部和底部时边缘的黑色阴影</td>
</tr>
<tr>
<td><strong>android:listSelector</strong></td>
<td>设置是否去除点击颜色</td>
</tr>
<tr>
<td><strong>android:cacheColorHint</strong></td>
<td>设置ListView去除滑动颜色</td>
</tr>
</tbody></table>
<h3 id="2-最简单的用法"><a href="#2-最简单的用法" class="headerlink" title="2.最简单的用法"></a>2.最简单的用法</h3><h4 id="布局文件中添加LsitView组件，然后在values-strings-xml文件中填加string-array的数组元素。然后通过android-entries调用加载数组资源，填充ListView项。"><a href="#布局文件中添加LsitView组件，然后在values-strings-xml文件中填加string-array的数组元素。然后通过android-entries调用加载数组资源，填充ListView项。" class="headerlink" title="布局文件中添加LsitView组件，然后在values/ strings.xml文件中填加string-array的数组元素。然后通过android:entries调用加载数组资源，填充ListView项。"></a>布局文件中添加LsitView组件，然后在values/ strings.xml文件中填加<font color="red">string-array</font>的数组元素。然后通过<font color="red">android:entries</font>调用加载数组资源，填充ListView项。</h4><h3 id="3-M-V-C原理"><a href="#3-M-V-C原理" class="headerlink" title="3.M-V-C原理"></a>3.M-V-C原理</h3><h4 id="（1）数据模型M-Model）存放数据-来自数组、列表、数据库-，利用控制器C（Controller）将数据显示在视图V（View）上。"><a href="#（1）数据模型M-Model）存放数据-来自数组、列表、数据库-，利用控制器C（Controller）将数据显示在视图V（View）上。" class="headerlink" title="（1）数据模型M(Model）存放数据(来自数组、列表、数据库)，利用控制器C（Controller）将数据显示在视图V（View）上。"></a>（1）数据模型M(Model）存放数据(来自数组、列表、数据库)，利用控制器C（Controller）将数据显示在视图V（View）上。</h4><h4 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点:"></a>（2）特点:</h4><ul>
<li><h4 id="将前端显示和后端数据分离"><a href="#将前端显示和后端数据分离" class="headerlink" title="将前端显示和后端数据分离"></a>将前端显示和后端数据分离</h4></li>
<li><h4 id="内容不能通过-ListView-add的形式添加列表项，需指定一个Adapter对象，-通过它获得显示数据"><a href="#内容不能通过-ListView-add的形式添加列表项，需指定一个Adapter对象，-通过它获得显示数据" class="headerlink" title="内容不能通过 ListView.add的形式添加列表项，需指定一个Adapter对象，    通过它获得显示数据"></a>内容不能通过 ListView.add的形式添加列表项，需指定一个Adapter对象，    通过它获得显示数据</h4></li>
<li><h4 id="数据源相当于-MVC-框架中的M（模型）"><a href="#数据源相当于-MVC-框架中的M（模型）" class="headerlink" title="数据源相当于 MVC 框架中的M（模型）"></a>数据源相当于 MVC 框架中的<font color="red">M</font>（模型）</h4></li>
<li><h4 id="ListView-相当于-MVC-框架中的V（视图）"><a href="#ListView-相当于-MVC-框架中的V（视图）" class="headerlink" title="ListView 相当于 MVC 框架中的V（视图）"></a>ListView 相当于 MVC 框架中的<font color="red">V</font>（视图）</h4></li>
<li><h4 id="Adapter-相当于-MVC-框架中的C（控制器）"><a href="#Adapter-相当于-MVC-框架中的C（控制器）" class="headerlink" title="Adapter 相当于 MVC 框架中的C（控制器）"></a>Adapter 相当于 MVC 框架中的<font color="red">C</font>（控制器）</h4></li>
</ul>
<h2 id="三、Adapter接口"><a href="#三、Adapter接口" class="headerlink" title="三、Adapter接口"></a>三、Adapter接口</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002125728655.png" alt="image-20201002125728655" style="zoom:50%;"></h3><h3 id="2-Adapter常用的实现类如下："><a href="#2-Adapter常用的实现类如下：" class="headerlink" title="2.Adapter常用的实现类如下："></a>2.Adapter常用的实现类如下：</h3><h4 id="1-ArrayAdapter：支持泛型操作，最为简单，一般用于将字符串数组或者任意对象-toString-数组绑定为列表项的数据源。"><a href="#1-ArrayAdapter：支持泛型操作，最为简单，一般用于将字符串数组或者任意对象-toString-数组绑定为列表项的数据源。" class="headerlink" title="(1)ArrayAdapter：支持泛型操作，最为简单，一般用于将字符串数组或者任意对象(toString)数组绑定为列表项的数据源。"></a>(1)ArrayAdapter：支持<font color="red">泛型</font>操作，最为简单，一般用于将<font color="red">字符串数组</font>或者任意对象(toString)数组绑定为列表项的数据源。</h4><h4 id="2-SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的列表项视图组件上，可以自定义出各种效果。"><a href="#2-SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的列表项视图组件上，可以自定义出各种效果。" class="headerlink" title="(2)SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的列表项视图组件上，可以自定义出各种效果。"></a>(2)SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的<font color="red">列表项</font>视图组件上，可以自定义出各种效果。</h4><h4 id="3-SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。"><a href="#3-SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。" class="headerlink" title="(3)SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。"></a>(3)SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。</h4><h4 id="4-BaseAdapter：是一个抽象类，继承它需要实现一些方法，具有较高的灵活性"><a href="#4-BaseAdapter：是一个抽象类，继承它需要实现一些方法，具有较高的灵活性" class="headerlink" title="(4)BaseAdapter：是一个抽象类，继承它需要实现一些方法，具有较高的灵活性"></a>(4)BaseAdapter：是一个<font color="red">抽象类</font>，继承它需要实现一些方法，具有较高的<font color="red">灵活性</font></h4><h2 id="四、ArrayAdapter"><a href="#四、ArrayAdapter" class="headerlink" title="四、ArrayAdapter"></a>四、ArrayAdapter</h2><h3 id="1-实现步骤："><a href="#1-实现步骤：" class="headerlink" title="1.实现步骤："></a>1.实现步骤：</h3><h4 id="（1）创建新项目：项目名称ArrayAdapterDemo。"><a href="#（1）创建新项目：项目名称ArrayAdapterDemo。" class="headerlink" title="（1）创建新项目：项目名称ArrayAdapterDemo。"></a>（1）创建新项目：项目名称ArrayAdapterDemo。</h4><h4 id="（2）在string-xml创建一个string-array，存储栏目信息。-M"><a href="#（2）在string-xml创建一个string-array，存储栏目信息。-M" class="headerlink" title="（2）在string.xml创建一个string-array，存储栏目信息。(M)"></a>（2）在string.xml创建一个<font color="red">string-array</font>，存储栏目信息。(M)</h4><h4 id="（3）在布局中添加ListView控件。-V"><a href="#（3）在布局中添加ListView控件。-V" class="headerlink" title="（3）在布局中添加ListView控件。(V)"></a>（3）在布局中添加ListView控件。(V)</h4><h4 id="（4）在MainActivity-Java设置布局中ListView的Adapter-C"><a href="#（4）在MainActivity-Java设置布局中ListView的Adapter-C" class="headerlink" title="（4）在MainActivity.Java设置布局中ListView的Adapter:(C)"></a>（4）在MainActivity.Java设置布局中ListView的Adapter:(C)</h4><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><h5 id="视图-M"><a href="#视图-M" class="headerlink" title="//视图  M"></a>//视图  M</h5><h4 id="ListView-listView-ListView-findViewById-R-id-news-category"><a href="#ListView-listView-ListView-findViewById-R-id-news-category" class="headerlink" title="ListView listView = (ListView) findViewById(R.id.news_category);"></a>ListView listView = (ListView) findViewById(R.id.news_category);</h4><h5 id="数据：strings-xml-V"><a href="#数据：strings-xml-V" class="headerlink" title="//数据：strings.xml  V"></a>//数据：strings.xml  V</h5><h4 id="String-mData-getResources-getStringArray-R-array-news-category"><a href="#String-mData-getResources-getStringArray-R-array-news-category" class="headerlink" title="String [ ] mData = getResources().getStringArray(R.array.news_category);"></a>String [ ] mData = <font color="orange">getResources().getStringArray(R.array.news_category);</font></h4><h5 id="桥接：Adapter-C"><a href="#桥接：Adapter-C" class="headerlink" title="//桥接：Adapter  C"></a>//桥接：Adapter  C</h5><h4 id="ArrayAdapter-adapter-new-ArrayAdapter-lt-gt-this-android-R-layout-simple-list-item-1-mData"><a href="#ArrayAdapter-adapter-new-ArrayAdapter-lt-gt-this-android-R-layout-simple-list-item-1-mData" class="headerlink" title="ArrayAdapter adapter = new ArrayAdapter&lt;&gt;(this, android.R.layout.simple_list_item_1, mData);"></a>ArrayAdapter<String> adapter = new ArrayAdapter&lt;&gt;(this, android.R.layout.simple_list_item_1, mData);</String></h4><h4 id="listView-setAdapter-adapter"><a href="#listView-setAdapter-adapter" class="headerlink" title="listView.setAdapter(adapter);"></a>listView.setAdapter(adapter);</h4><p>​    </p>
<h3 id="3-监听器"><a href="#3-监听器" class="headerlink" title="3.监听器"></a>3.监听器</h3><p>、<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002130844609.png" alt="image-20201002130844609"></p>
<h2 id="五、SimpleAdapter"><a href="#五、SimpleAdapter" class="headerlink" title="五、SimpleAdapter"></a>五、SimpleAdapter</h2><h3 id="1-实现步骤：-1"><a href="#1-实现步骤：-1" class="headerlink" title="1.实现步骤："></a>1.实现步骤：</h3><h4 id="（1）创建新项目：项目名称SimpleAdapterDemo。"><a href="#（1）创建新项目：项目名称SimpleAdapterDemo。" class="headerlink" title="（1）创建新项目：项目名称SimpleAdapterDemo。"></a>（1）创建新项目：项目名称SimpleAdapterDemo。</h4><h4 id="（2）ListView的子项布局："><a href="#（2）ListView的子项布局：" class="headerlink" title="（2）ListView的子项布局："></a>（2）ListView的<font color="red">子项布局</font>：</h4><h4 id="用来显示列表的每一行内容的xml文件。自定义一个布局-listview-item-xml。"><a href="#用来显示列表的每一行内容的xml文件。自定义一个布局-listview-item-xml。" class="headerlink" title="用来显示列表的每一行内容的xml文件。自定义一个布局:listview_item.xml。"></a>用来显示列表的每一行内容的xml文件。<font color="orange">自定义一个布局:listview_item.xml。</font></h4><h4 id="（3）数据准备"><a href="#（3）数据准备" class="headerlink" title="（3）数据准备"></a>（3）数据准备</h4><h4 id="一般使用HashMap构成的List，List的每一个元素（map）用于填充ListView-的一个item。HashMap的每个键值数据映射到布局文件中对应id的组件上。"><a href="#一般使用HashMap构成的List，List的每一个元素（map）用于填充ListView-的一个item。HashMap的每个键值数据映射到布局文件中对应id的组件上。" class="headerlink" title="一般使用HashMap构成的List，List的每一个元素（map）用于填充ListView    的一个item。HashMap的每个键值数据映射到布局文件中对应id的组件上。"></a>一般使用<font color="orange">HashMap构成的List</font>，List的每一个元素（map）用于填充ListView    的一个item。HashMap的每个键值数据<font color="orange">映射</font>到布局文件中对应id的组件上。</h4><h4 id="（4）数据适配：创建SimpleAdapter并设置"><a href="#（4）数据适配：创建SimpleAdapter并设置" class="headerlink" title="（4）数据适配：创建SimpleAdapter并设置"></a>（4）数据适配：创建SimpleAdapter并设置</h4><h4 id="参数依次是：this，getData-，子项布局文件的ID，HashMap的键值数组，布局文件的组件id。"><a href="#参数依次是：this，getData-，子项布局文件的ID，HashMap的键值数组，布局文件的组件id。" class="headerlink" title="参数依次是：this，getData()，子项布局文件的ID，HashMap的键值数组，布局文件的组件id。"></a>参数依次是：<font color="orange">this，getData()，子项布局文件的ID，HashMap的键值数组，布局文件的组件id</font>。</h4><h4 id="第4个参数的键值序列与第5个参数的组件id序列一一对应。"><a href="#第4个参数的键值序列与第5个参数的组件id序列一一对应。" class="headerlink" title="第4个参数的键值序列与第5个参数的组件id序列一一对应。"></a>第4个参数的键值序列与第5个参数的组件id序列一一对应。</h4><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><h4 id="子项布局"><a href="#子项布局" class="headerlink" title="子项布局"></a>子项布局</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002131857410.png" alt="image-20201002131857410"></p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132023296.png" alt="image-20201002132023296"></p>
<h4 id="数据适配"><a href="#数据适配" class="headerlink" title="数据适配"></a>数据适配</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132215242.png" alt="image-20201002132215242"></p>
<h3 id="3-子项点击事件"><a href="#3-子项点击事件" class="headerlink" title="3.子项点击事件"></a>3.子项点击事件</h3><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132331890.png" alt="image-20201002132331890">

<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132425472.png" alt="image-20201002132425472">



<h2 id="六、BaseAdapter"><a href="#六、BaseAdapter" class="headerlink" title="六、BaseAdapter"></a>六、BaseAdapter</h2><h3 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h3><h4 id="（1）创建新项目：项目名称BaseAdapterDemo。"><a href="#（1）创建新项目：项目名称BaseAdapterDemo。" class="headerlink" title="（1）创建新项目：项目名称BaseAdapterDemo。"></a>（1）创建新项目：项目名称BaseAdapterDemo。</h4><h4 id="（2）ListView的子项布局：-listview-item-bt-xml"><a href="#（2）ListView的子项布局：-listview-item-bt-xml" class="headerlink" title="（2）ListView的子项布局： listview_item_bt.xml"></a>（2）ListView的子项布局： listview_item_bt.xml</h4><p>​        一个ImageView，两个TextView和一个ImageButton。</p>
<h4 id="（3）设置自定义适配器MyAdapter"><a href="#（3）设置自定义适配器MyAdapter" class="headerlink" title="（3）设置自定义适配器MyAdapter"></a>（3）设置自定义适配器<font color="red">MyAdapter</font></h4><p>​        <font color="cornflowerblue">MyAdapter继承BaseAdapter</font>，需要重写<font color="orange">getCount(), getView()</font>等方法。<br>​                ListView在绘制的时候，系统首先调用getCount()函数，根据返回值得到ListView的长度，然后根据            这个长度调用getView()逐一绘制每一行。<br>​        在getView中使用了<font color="cornflowerblue">ViewHolder类</font>和对象。<br>​                使用ViewHolder可以进行性能优化，对控件实例进行缓存。ViewHolder是一个内部类，其中包含了单个项目布局中的各个控件。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002133333488.png" alt="image-20201002133333488"></h3><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002133841796.png" alt="image-20201002133841796"></p>
<h4 id="mInflater-LayoutInflater-from-getContext"><a href="#mInflater-LayoutInflater-from-getContext" class="headerlink" title="mInflater = LayoutInflater.from( getContext() )"></a><font color="cornflowerblue">mInflater = LayoutInflater.from( getContext() )</font></h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134333722.png" alt="image-20201002134333722"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134657576.png" alt="image-20201002134657576"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134926677.png" alt="image-20201002134926677"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135612766.png" alt="image-20201002135612766"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134944464.png" alt="image-20201002134944464"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135159245.png" alt="image-20201002135159245"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135718003.png" alt="image-20201002135718003"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135725265.png" alt="image-20201002135725265"></p>
<h2 id="七、RecyclerView-补充"><a href="#七、RecyclerView-补充" class="headerlink" title="七、RecyclerView(补充)"></a>七、RecyclerView(补充)</h2><h3 id="1-定义子项布局：采用CardView布局进行美化。"><a href="#1-定义子项布局：采用CardView布局进行美化。" class="headerlink" title="1.定义子项布局：采用CardView布局进行美化。"></a>1.定义子项布局：采用CardView布局进行美化。</h3><h4 id="（1）新建cardview-bt-xml（类似于前一例中的listview-item-bt-xml）"><a href="#（1）新建cardview-bt-xml（类似于前一例中的listview-item-bt-xml）" class="headerlink" title="（1）新建cardview_bt.xml（类似于前一例中的listview_item_bt.xml）"></a>（1）新建cardview_bt.xml（类似于前一例中的listview_item_bt.xml）</h4><p>定义cardCornerRadius=”5dp”, elevation = “1dp”<br>CardView 继承于Framelayout，不能直接放置各类控件，否则各类控件将会重叠在一起，因此一般在CardView布局中嵌套其它布局，在其中放置放置其它控件</p>
<h4 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201009121547035.png" alt="image-20201009121547035"></h4><h3 id="2-getAdapterPosition-获取当前点击项的position序号"><a href="#2-getAdapterPosition-获取当前点击项的position序号" class="headerlink" title="2.getAdapterPosition(); 获取当前点击项的position序号"></a>2.<font color="cornflowerblue">getAdapterPosition()</font>; 获取当前点击项的position序号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">holder.fruitItemView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        int position=holder.getAdapterPosition();   //获取当前点击项的position序号</span><br><span class="line">        Fruit fruit=mFruitList.get(position);       //获取当前点击项的Fruit实例</span><br><span class="line">        new AlertDialog.Builder(parent.getContext()).setTitle(&quot;营养价值：&quot;)</span><br><span class="line">                .setMessage(fruit.nutrition)</span><br><span class="line">                .setPositiveButton(&quot;ok&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-定位子项到第一项"><a href="#3-定位子项到第一项" class="headerlink" title="3.定位子项到第一项"></a>3.定位子项到第一项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int positions=fruitList.indexOf(fruit); //获取对象序号</span><br><span class="line">recyclerView.scrollToPosition(positions);</span><br><span class="line">LinearLayoutManager layoutManager1=(LinearLayoutManager)recyclerView.getLayoutManager();</span><br><span class="line">layoutManager1.scrollToPositionWithOffset(positions,0);     //对象定位到第一项</span><br></pre></td></tr></table></figure>



<h3 id="4-List按某个属性重新排序"><a href="#4-List按某个属性重新排序" class="headerlink" title="4.List按某个属性重新排序"></a>4.List按某个属性重新排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case R.id.like_order_up:</span><br><span class="line">    Collections.sort(fruitList, new Comparator&lt;Fruit&gt;() &#123;       //按喜爱度升序排序</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Fruit o1, Fruit o2) &#123;</span><br><span class="line">            return o1.likeNumber.compareTo(o2.likeNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    adapter.notifyDataSetChanged();     //刷新适配器</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case R.id.like_order_down:</span><br><span class="line">    Collections.sort(fruitList, new Comparator&lt;Fruit&gt;() &#123;       //按喜爱度降序排序</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Fruit o1, Fruit o2) &#123;</span><br><span class="line">            return o2.likeNumber.compareTo(o1.likeNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    adapter.notifyDataSetChanged();     //刷新适配器</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>





<h1 id="第三章-数据存储"><a href="#第三章-数据存储" class="headerlink" title="第三章 数据存储"></a>第三章 数据存储</h1><h2 id="一、数据持久化"><a href="#一、数据持久化" class="headerlink" title="一、数据持久化"></a>一、数据持久化</h2><h3 id="1-数据存储方式"><a href="#1-数据存储方式" class="headerlink" title="1.数据存储方式"></a>1.数据存储方式</h3><ul>
<li><font color="red">文件存储</font></li>
<li><font color="red">SharedPreferences</font></li>
<li><font color="red">SQLite数据库</font></li>
</ul>
<h3 id="2-Android内部存储和外部存储"><a href="#2-Android内部存储和外部存储" class="headerlink" title="2.Android内部存储和外部存储"></a>2.Android内部存储和外部存储</h3><h4 id="（1）内存（Memory）："><a href="#（1）内存（Memory）：" class="headerlink" title="（1）内存（Memory）："></a>（1）内存（Memory）：</h4><p>​            RAM，类似于PC的内存条</p>
<h4 id="（2）内部存储（Internal-Storage）："><a href="#（2）内部存储（Internal-Storage）：" class="headerlink" title="（2）内部存储（Internal Storage）："></a>（2）内部存储（Internal Storage）：</h4><p>​            机身固有存储，类似于PC的硬盘 </p>
<h4 id="（3）外部存储（External-Storage）："><a href="#（3）外部存储（External-Storage）：" class="headerlink" title="（3）外部存储（External Storage）："></a>（3）外部存储（External Storage）：</h4><p>​                早期的Android设备(4.4之前) 指SDCard(扩展卡)，类似于PC上的U盘。</p>
<p>​        之后随着技术的进步，机身存储得到了快速增大(8G以上)，此时的外部存储是<font color="orange">概念级别的“外部存储”</font>，机        身<font color="red">固有的存储</font>有一部分被划分为“内部存储”，另一部分被划分为“外部存储”，但其实都是机身固有存储。        后期的外部存储也包括了SDCard。<br>​        所以不管Android手机是否有可移动的SDCard，他们总是有外部存储和内部存储。</p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20210601224438335.png" alt="image-20210601224438335"></p>
<h3 id="3-几个重要文件夹"><a href="#3-几个重要文件夹" class="headerlink" title="3.几个重要文件夹"></a>3.几个重要文件夹</h3><h4 id="打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹"><a href="#打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹" class="headerlink" title="打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：data文件夹、mnt文件夹、sdcard 文件夹、storage文件夹"></a>打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：<font color="red">data</font>文件夹、<font color="red">mnt</font>文件夹、<font color="red">sdcard</font> 文件夹、<font color="red">storage</font>文件夹</h4><h3 id="4-内部存储data"><a href="#4-内部存储data" class="headerlink" title="4.内部存储data"></a>4.<font color="cornflowerblue">内部存储data</font></h3><h4 id="1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："><a href="#1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：" class="headerlink" title="(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："></a>(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：</h4><ul>
<li><h5 id="文件夹app：存放着我们所有安装的app的apk文件"><a href="#文件夹app：存放着我们所有安装的app的apk文件" class="headerlink" title="文件夹app：存放着我们所有安装的app的apk文件"></a>文件夹<font color="red">app</font>：存放着我们所有安装的app的apk文件</h5></li>
<li><h5 id="文件夹data：一些包名，展开后，"><a href="#文件夹data：一些包名，展开后，" class="headerlink" title="文件夹data：一些包名，展开后，"></a>文件夹<font color="red">data</font>：一些包名，展开后，</h5><p>data/data/包名/<font color="orange">shared_prefs</font>(SharedPreference存储方式)</p>
<pre><code>data/data/包名/&lt;font color=&#39;orange&#39;&gt;databases&lt;/font&gt;（数据库存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;files&lt;/font&gt;（文件存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;cache&lt;/font&gt;
</code></pre>
</li>
</ul>
<h4 id="（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data"><a href="#（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data" class="headerlink" title="（2）路径的访问：Environment.getDataDirectory()获取内部存储根路径。/data"></a>（2）路径的访问：<font color="red">Environment.getDataDirectory()</font>获取内部存储根路径。/data</h4><h4 id="3-几点："><a href="#3-几点：" class="headerlink" title="(3)几点："></a>(3)几点：</h4><ol>
<li><h4 id="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"><a href="#系统默认只在内部存储中创建cache目录，并且此时cache目录是空的" class="headerlink" title="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"></a>系统默认<font color="orange">只在内部存储中创建cache目录</font>，并且此时cache目录是空的</h4></li>
<li><h4 id="此外，还可以根据需要自动创建：shared-prefs，databases，files目录"><a href="#此外，还可以根据需要自动创建：shared-prefs，databases，files目录" class="headerlink" title="此外，还可以根据需要自动创建：shared_prefs，databases，files目录"></a>此外，还可以根据需要<font color="orange">自动创建</font>：shared_prefs，databases，files目录</h4><p>但files可以<font color="orange">手动创建</font>，而shared_prefs，databases不能</p>
</li>
<li><h4 id="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"><a href="#别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。" class="headerlink" title="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"></a>别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。</h4></li>
</ol>
<h4 id="（4）内部存储的API"><a href="#（4）内部存储的API" class="headerlink" title="（4）内部存储的API"></a>（4）内部存储的API</h4><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028153632199.png" alt="image-20201028153632199" style="zoom:80%;">





<h3 id="5-外部存储storage"><a href="#5-外部存储storage" class="headerlink" title="5.外部存储storage"></a>5.<font color="cornflowerblue">外部存储storage</font></h3><h4 id="1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"><a href="#1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。" class="headerlink" title="(1)一般是/storage/emulated/0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"></a>(1)一般是<font color="red">/storage/emulated/0</font>也有可能是其它文件夹，不同厂家不同版本有可能不一样。</h4><h4 id="storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy"><a href="#storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy" class="headerlink" title="/storage/sdcard0，/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy"></a><font color="red">/storage/sdcard0，</font>/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy</h4><ul>
<li><h5 id="公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等"><a href="#公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等" class="headerlink" title="公有目录：10大类，比如DCIM,Download等这些系统创建的文件夹。storage/emulated/0/Download等"></a><font color="red">公有目录</font>：10大类，比如DCIM,Download等这些系统创建的文件夹。<font color="orange">storage/emulated/0/Download</font>等</h5></li>
<li><h5 id="私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。"><a href="#私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。" class="headerlink" title="私有目录：Android文件夹，打开后有data文件夹。storage/emulated/0/Android/data/包名 文件夹：里面包含了许多包名组成的文件夹。"></a><font color="red">私有目录</font>：Android文件夹，打开后有<font color="red">data</font>文件夹。<font color="orange">storage/emulated/0/Android/data/包名 文件夹</font>：里面包含了许多包名组成的文件夹。</h5><h4 id="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"><a href="#（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。" class="headerlink" title="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"></a>（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的<font color="green">数据会一并删除</font>。</h4><p>如果直接在<font color="red">根目录</font>（<font color="orange">/storage/emulated/0</font>）下创建一个应用的文件夹，这样当该应用被卸载后，这些数据还保留在外部存储中，<font color="green">留下垃圾数据</font>。</p>
</li>
</ul>
<h4 id="（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。"><a href="#（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。" class="headerlink" title="（3）路径的访问：Environment.getExternalStorageDirectory()：获取机身存储的外部存储根路径。"></a>（3）路径的访问：<font color="red">Environment.getExternalStorageDirectory()</font>：获取机身存储的外部存储根路径。</h4><h4 id="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"><a href="#（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录" class="headerlink" title="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"></a>（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要<font color="red">手动创建私有目录</font></h4><h5 id="context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件"><a href="#context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件" class="headerlink" title="context.getExternalFilesDir(…)：在storage/emulated/0/Android/data/包名/files 中创建文件"></a>context.<font color="orange">getExternalFilesDir(…)</font>：在storage/emulated/0/Android/data/包名/files 中创建文件</h5><p>​    context.<font color="orange">getExternalCacheDir() </font>：在storage/emulated/0/Android/data/包名/cache 中创建文件</p>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028154738508.png" alt="image-20201028154738508" style="zoom:80%;">

<h3 id="6-内部存储与外部存储比较"><a href="#6-内部存储与外部存储比较" class="headerlink" title="6.内部存储与外部存储比较"></a>6.内部存储与外部存储比较</h3><p>​        外部存储目录空间较大，而内部存储空间有限<br>​        部分目录不会被自动创建，需要手动创建<br>​        两者<font color="red">都不需要权限</font><br>​        两者<font color="red">都会随着App的卸载而会自动被删除</font><br>​        对于内部存储，<font color="orange">只有</font>本App才可以访问<br>​        对于外部私有目录，本App可以直接访问，而其它App在自 Android 7.0 开始，系统对应用私有目录的访问权限进一步限制。其他 App 无法通过 file:// 这种形式的 Uri 直接读写该目录下的文件内容，而是通过 FileProvider 访问。<br>​        需要注意的是：由于用户可以直接查看并操作外部私有存储目录，那么也就意味着我们在操作这个目录下的文件的时候一定要做好异常和判空处理。</p>
<h3 id="7-数据存储与清除"><a href="#7-数据存储与清除" class="headerlink" title="7.数据存储与清除"></a>7.数据存储与清除</h3><h4 id="（1）数据存储："><a href="#（1）数据存储：" class="headerlink" title="（1）数据存储："></a>（1）数据存储：</h4><ul>
<li><p>默认情况下，存储在<font color="red">内部存储</font>：<br><font color="orange">data/app</font>：用户APP安装目录，存放apk；</p>
<p><font color="orange">data/data/包名/</font>：存放应用程序的数据</p>
</li>
<li><p>数据可以存放到指定的<font color="red">外部存储</font>：</p>
<p><font color="orange">/storage/sdcard</font>（共有目录）</p>
<p><font color="orange">/storage/sdcard0/Android/data/包名/</font>（私有目录）</p>
<h4 id="（2）清除数据："><a href="#（2）清除数据：" class="headerlink" title="（2）清除数据："></a>（2）清除数据：</h4></li>
</ul>
<h5 id="删除对应包中的cache，files，lib，shared-prefs，datbBases等等"><a href="#删除对应包中的cache，files，lib，shared-prefs，datbBases等等" class="headerlink" title="删除对应包中的cache，files，lib，shared_prefs，datbBases等等"></a>删除<font color="red">对应包中的</font><font color="cornflowerblue">cache</font>，files，lib，shared_prefs，datbBases等等</h5><p>​        （清除<font color="red">data/data/packagename中的</font>cache，files，lib， databases，shared_prefs等等）</p>
<p>​        （清除<font color="red">storage/emulated/0/Android/data/packagenam中的</font>文件）</p>
<h4 id="3-清除缓存："><a href="#3-清除缓存：" class="headerlink" title="(3) 清除缓存："></a>(3) 清除缓存：</h4><h5 id="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"><a href="#删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。" class="headerlink" title="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"></a>删除的是App运行过程中所产生的<font color="red">临时数据</font>，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在<font color="red">内存</font>中。</h5><h2 id="二、文件存储"><a href="#二、文件存储" class="headerlink" title="二、文件存储"></a>二、文件存储</h2><h3 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1.内部存储"></a>1.内部存储</h3><h4 id="（1）存："><a href="#（1）存：" class="headerlink" title="（1）存："></a>（1）存：</h4><ul>
<li>方法1：使用 context.getFilesDir() 获取内部存储data/data/包名/files目录，然后创建文件，最后利用文件(全路径)新建FileOutputStream对象进行文件写入。<br>FileOutputStream fileOutputStream = new FileOutputStream(filePathName);</li>
</ul>
<img src="《Android小菜》//image-20201028160019136.png" alt="image-20201028160019136" style="zoom:80%;">

<ul>
<li>方法2：直接使用Context.openFileOutput()方法(只需要文件名)获取FileOutputStream对象，进行文件写入。</li>
</ul>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028160258040.png" alt="image-20201028160258040" style="zoom:80%;">

<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028160348975.png" alt="image-20201028160348975" style="zoom:80%;">

<h4 id="（2）取："><a href="#（2）取：" class="headerlink" title="（2）取："></a>（2）取：</h4><ul>
<li>方法1：使用context.getFilesDir() 获取内部存储data/data/包名/files目录，然后利用文件(全路径)创建FileInputStream对象，进行内容读取。<br>FileInputStream fileInputStream = new FileInputStream(filePathName);</li>
</ul>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20210601224213396.png" alt="image-20210601224213396"></p>
<ul>
<li>方法2：直接使用Context. openFileInput()方法(只需要文件名)获取FileInputStream对象，进行文件内容读取。<br>FileInputStream fileInputStream = openFileInput(fileName);</li>
</ul>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028160853113.png" alt="image-20201028160853113" style="zoom:80%;">

<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20210601224250308.png" alt="image-20210601224250308"></p>
<h3 id="2-外部存储"><a href="#2-外部存储" class="headerlink" title="2.外部存储"></a>2.外部存储</h3><h4 id="（1）外部根目录："><a href="#（1）外部根目录：" class="headerlink" title="（1）外部根目录："></a>（1）外部根目录：</h4><p>使用 <font color="red">Environment.getExternalStorageDirectory()</font> 获取</p>
<p>一般是/storage/emulated/0</p>
<h4 id="（2）外部公有目录："><a href="#（2）外部公有目录：" class="headerlink" title="（2）外部公有目录："></a>（2）外部公有目录：</h4><p>使用<font color="red">Environment.getExternalStoragePublicDirectory</font>获取</p>
<p>/storage/emulated/0/Music</p>
<p>针对外部<font color="red">共有目录、根目录</font>等位置的存取需要<font color="orange">添加权限</font>，Android 6.0 之后还需要做运行时权限申请。针对外部<font color="red">私有目录</font>的存取则<font color="orange">不需要添加权限</font>。<br>默认情况下，Android系统<font color="red">不会</font>为我们的App在外部存储中创建私有路径，需要<font color="red">手动创建</font>。<br>外部私有目录在App卸载时同步删除。</p>
<p>​    </p>
<h4 id="（3）获取外部私有目录"><a href="#（3）获取外部私有目录" class="headerlink" title="（3）获取外部私有目录"></a>（3）获取外部私有目录</h4><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028162002693.png" alt="image-20201028162002693" style="zoom:80%;">





<h4 id="（4）存："><a href="#（4）存：" class="headerlink" title="（4）存："></a>（4）存：</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028162420940.png" alt="image-20201028162420940"></p>
<h4 id="（5）取："><a href="#（5）取：" class="headerlink" title="（5）取："></a>（5）取：</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028162532386.png" alt="image-20201028162532386"></p>
<h2 id="二、SharedPreferences存储"><a href="#二、SharedPreferences存储" class="headerlink" title="二、SharedPreferences存储"></a>二、SharedPreferences存储</h2><h3 id="1-获取SharedPreferences对象"><a href="#1-获取SharedPreferences对象" class="headerlink" title="1.获取SharedPreferences对象"></a>1.获取<font color="cornflowerblue">SharedPreferences对象</font></h3><h4 id="1-Context-getSharedPreferences-方法"><a href="#1-Context-getSharedPreferences-方法" class="headerlink" title="(1) Context . getSharedPreferences()方法 "></a>(1) <font color="red">Context . getSharedPreferences()方法 </font></h4><p>​        此方法接受两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个。SharedPreferences 文件都是存放在 /data/data/&lt;包名&gt;/shared_prefs/ 目录下的。<br>​        第二个参数用于<font color="orange">指定操作模式</font>，主要为 MODE_PRIVATE（默认操作模式） 和 MODE_MULTI_PROCESS（多进程读写） 。</p>
<h4 id="2-Activity-类中的-getPreferences-方法"><a href="#2-Activity-类中的-getPreferences-方法" class="headerlink" title="(2)Activity 类中的 getPreferences() 方法"></a>(2)<font color="red">Activity 类中的 getPreferences() 方法</font></h4><p>这个方法和 Context 中的 getSharedPreferences() 方法类似，不过它只接收一个操作模式参数，使用这个方法时<font color="orange">会自动将当前活动的类名作为 SharedPreferences 的文件名</font>。</p>
<h4 id="3-PreferenceManager-类中的-getDefaultSharedPreferences-方法"><a href="#3-PreferenceManager-类中的-getDefaultSharedPreferences-方法" class="headerlink" title="(3) PreferenceManager 类中的 getDefaultSharedPreferences() 方法"></a>(3)<font color="red"> PreferenceManager 类中的 getDefaultSharedPreferences() 方法</font></h4><p>这是一个<font color="orange">静态方法</font>，它接收一个 Context 参数，并自动<font color="orange">使用当前应用程序的包名作为前缀</font>来命名 SharedPreferences 文件。</p>
<h3 id="2-通过SharedPreferences对象获取到Editor对象存数据"><a href="#2-通过SharedPreferences对象获取到Editor对象存数据" class="headerlink" title="2.通过SharedPreferences对象获取到Editor对象存数据"></a>2.通过SharedPreferences对象获取到<font color="cornflowerblue">Editor对象</font>存数据</h3><h4 id="（1）SharePreferences-Editor-editor-shared-edit"><a href="#（1）SharePreferences-Editor-editor-shared-edit" class="headerlink" title="（1）SharePreferences.Editor  editor = shared.edit();"></a>（1）SharePreferences.Editor  editor = shared.<font color="red">edit();</font></h4><p>调用 SharedPreferences 对象的 edit() 方法来获取一个 SharePreferences.Editor 对象。</p>
<h4 id="（2）editor-putString"><a href="#（2）editor-putString" class="headerlink" title="（2）editor.putString( )"></a>（2）editor<font color="red">.putString( )</font></h4><p>向 SharedPreferences.Editor 对象中添加数据，如果添加一个字符串则使用 editor.putString() 方法，以此类推。</p>
<h4 id="（3）editor-commit-editor-apply"><a href="#（3）editor-commit-editor-apply" class="headerlink" title="（3）editor.commit()  editor.apply()"></a>（3）<font color="red">editor.commit()  editor.apply()</font></h4><p>调用 editor.commit() 方法或者editor.apply()方法将添加的数据提交，从而完成数据存储操作。</p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164007127.png" alt="image-20201028164007127"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164138241.png" alt="image-20201028164138241"></p>
<h3 id="3-SharePreferences读取与删除数据"><a href="#3-SharePreferences读取与删除数据" class="headerlink" title="3.SharePreferences读取与删除数据"></a>3.SharePreferences<font color="cornflowerblue">读取与删除</font>数据</h3><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164251857.png" alt="image-20201028164251857"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164334426.png" alt="image-20201028164334426">****</p>
]]></content>
      <categories>
        <category>《 Android基础》</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验七-Telnet与EIGRP</title>
    <url>/2021/06/04/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Telnet%E4%B8%8EEIGRP/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>了解Telnet与EIGRP（增强内部网关路由协议）基本原理；</p>
<p>掌握路由器Telnet远程登录的配置以及主机访问远程虚拟终端的方法；</p>
<p>掌握EIGRP路由协议的基本配置；</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>· Cisco Packet Tracer    </p>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>（1）新建Packet Tracer拓扑图（如图）；</p>
<p>（2）配置路由器启动Telnet服务；</p>
<p>（3）通过主机远程登录路由器；</p>
<p>（4）远程登录并配置路由器的EIGRP协议，实现网络连通。</p>
<h1 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h1><p>1.新建packet tracer网络拓扑图</p>
<p><img src="/2021/06/04/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Telnet%E4%B8%8EEIGRP/wps1.jpg" alt="img"> </p>
<p>2.配置路由器启动Telnet服务的基本流程</p>
<p>（通过配置线连接PC主机RS232和路由器console接口进行配置）</p>
<p>（1）设置“特权模式”使能加密密码：</p>
<p>Router(config)#enable secret 123</p>
<p>（2）设置控制台（console配置线）密码：</p>
<p>Router(config)#line console 0</p>
<p>Router(config-line)#password 456</p>
<p>Router(config-line)#login</p>
<p>Router(config-line)#exit</p>
<p>（3）设置远程登陆密码：</p>
<p>Router(config)#line vty 0 4</p>
<p>Router(config-line)#password 789</p>
<p>Router(config-line)#login</p>
<p>Router(config-line)#exit</p>
<p>3通过PC主机远程登录到路由器</p>
<p>PC&gt;telnet 202.192.0.254</p>
<p>Password: 789</p>
<p>Router&gt;enable</p>
<p>Password: 123</p>
<p>Router#</p>
<p>4.远程登录并配置路由器的EIGRP协议</p>
<p>Router#conf t</p>
<p>Router(config)#router eigrp 100                            //启动EIGRP路由协议</p>
<p>Router(config-router)#network 202.192.0.0        //宣告直连主类网络号</p>
<p>Router(config-router)#network 202.192.1.0</p>
<h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p>（1）远程登录并配置配置EIGRP协议</p>
<p><img src="/2021/06/04/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Telnet%E4%B8%8EEIGRP/wps2.jpg" alt="img"> </p>
<p>（2）配置完成后的路由表</p>
<p><img src="/2021/06/04/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Telnet%E4%B8%8EEIGRP/wps3.jpg" alt="img"> </p>
<p>（3）测试连通性</p>
<p><img src="/2021/06/04/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Telnet%E4%B8%8EEIGRP/wps4.jpg" alt="img"> </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>Telnet协议是<a href="https://baike.baidu.com/item/TCP/IP%E5%8D%8F%E8%AE%AE">TCP/IP协议</a>族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>工作的能力。在<a href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF/1903878">终端</a>使用者的电脑上使用telnet程序，用它连接到<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>。<a href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF/1903878">终端</a>使用者可以在telnet程序中输入命令，这些命令会在<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>。要开始一个telnet会话，必须输入用户名和密码来登录<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>。Telnet是常用的<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/934368">远程控制</a>Web<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>的方法。</p>
</li>
<li><p>EIGRP:Enhanced Interior Gateway Routing Protocol 即增强内部<a href="https://baike.baidu.com/item/%E7%BD%91%E5%85%B3">网关</a><a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1">路由</a>协议。也翻译为 加强型<a href="https://baike.baidu.com/item/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/234910">内部网关路由协议</a>。 EIGRP是Cisco公司的私有协议（2013年已经公有化）。 EIGRP结合了链路状态和<a href="https://baike.baidu.com/item/%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F">距离矢量</a>型<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/5569697">路由选择协议</a>的Cisco专用协议，采用弥散修正算法（DUAL）来实现<a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%94%B6%E6%95%9B/6202142">快速收敛</a>，可以不发送定期的路由更新<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF/111163">信息</a>以减少<a href="https://baike.baidu.com/item/%E5%B8%A6%E5%AE%BD/266879">带宽</a>的占用，支持Appletalk、IP、Novell和NetWare等多种网络层协议。</p>
</li>
<li><p>EIGRP优点：快速收敛、部分更新、支持多种网络层协议、使用组播和单播、支持变长子网掩码（VLSM）和CIDR、无缝连接数据链路层协议和拓扑结构、配置简单</p>
</li>
</ol>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>标签外挂</title>
    <url>/2021/06/09/%E6%A0%87%E7%AD%BE%E5%A4%96%E6%8C%82/</url>
    <content><![CDATA[<h1 id="Note-Bootstrap-Callout"><a href="#Note-Bootstrap-Callout" class="headerlink" title="Note (Bootstrap Callout)"></a>Note (Bootstrap Callout)</h1><h2 id="用法一："><a href="#用法一：" class="headerlink" title="用法一："></a>用法一：</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">名称</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">class</td>
<td>【可选】标识，不同的标识有不同的配色（ default / primary / success / info / warning / danger ）</td>
</tr>
<tr>
<td align="center">no-icon</td>
<td>【可选】不显示 icon</td>
</tr>
<tr>
<td align="center">style</td>
<td>【可选】可以覆盖配置中的 style（simple/modern/flat/disabled）</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="simple"><a href="#simple" class="headerlink" title="simple"></a>simple</h3></li>
</ul>
<div class="note simple"><p>默认 提示块标签</p>
</div>

<div class="note default simple"><p>default 提示块标签</p>
</div>

<div class="note primary simple"><p>primary 提示块标签</p>
</div>

<div class="note success simple"><p>success 提示块标签</p>
</div>

<div class="note info simple"><p>info 提示块标签</p>
</div>

<div class="note warning simple"><p>warning 提示块标签</p>
</div>

<div class="note danger simple"><p>danger 提示块标签</p>
</div>



<ul>
<li><h3 id="modern"><a href="#modern" class="headerlink" title="modern"></a>modern</h3></li>
</ul>
<div class="note modern"><p>默认 提示块标签</p>
</div>

<div class="note default modern"><p>default 提示块标签</p>
</div>

<div class="note primary modern"><p>primary 提示块标签</p>
</div>

<div class="note success modern"><p>success 提示块标签</p>
</div>

<div class="note info modern"><p>info 提示块标签</p>
</div>

<div class="note warning modern"><p>warning 提示块标签</p>
</div>

<div class="note danger modern"><p>danger 提示块标签</p>
</div>



<ul>
<li><h3 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h3></li>
</ul>
<div class="note flat"><p>默认 提示块标签</p>
</div>

<div class="note default flat"><p>default 提示块标签</p>
</div>

<div class="note primary flat"><p>primary 提示块标签</p>
</div>

<div class="note success flat"><p>success 提示块标签</p>
</div>

<div class="note info flat"><p>info 提示块标签</p>
</div>

<div class="note warning flat"><p>warning 提示块标签</p>
</div>

<div class="note danger flat"><p>danger 提示块标签</p>
</div>



<ul>
<li><h3 id="disabled"><a href="#disabled" class="headerlink" title="disabled"></a>disabled</h3></li>
</ul>
<div class="note disabled"><p>默认 提示块标签</p>
</div>

<div class="note default disabled"><p>default 提示块标签</p>
</div>

<div class="note primary disabled"><p>primary 提示块标签</p>
</div>

<div class="note success disabled"><p>success 提示块标签</p>
</div>

<div class="note info disabled"><p>info 提示块标签</p>
</div>

<div class="note warning disabled"><p>warning 提示块标签</p>
</div>

<div class="note danger disabled"><p>danger 提示块标签</p>
</div>



<h2 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>【可选】顔色(default / blue / pink / red / purple / orange / green)</td>
</tr>
<tr>
<td>icon</td>
<td>【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td>
</tr>
<tr>
<td>style</td>
<td>【可选】可以覆盖配置中的 style<br>（simple/modern/flat/disabled）</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="simple-1"><a href="#simple-1" class="headerlink" title="simple"></a>simple</h3></li>
</ul>
<div class="note icon simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="modern-1"><a href="#modern-1" class="headerlink" title="modern"></a>modern</h3></li>
</ul>
<div class="note icon modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="flat-1"><a href="#flat-1" class="headerlink" title="flat"></a>flat</h3></li>
</ul>
<div class="note icon flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="disabled-1"><a href="#disabled-1" class="headerlink" title="disabled"></a>disabled</h3></li>
</ul>
<div class="note icon disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="no-icon"><a href="#no-icon" class="headerlink" title="no-icon"></a>no-icon</h3></li>
</ul>
<div class="note no-icon simple"><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue no-icon simple"><p>2021年快到了….</p>
</div>

<div class="note pink no-icon simple"><p>小心开车 安全至上</p>
</div>

<div class="note red no-icon simple"><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange no-icon simple"><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple no-icon simple"><p>剪刀石头布</p>
</div>

<div class="note green no-icon simple"><p>前端最讨厌的浏览器</p>
</div>

]]></content>
      <categories>
        <category>《hexo》</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Android进阶-RecyclerView</title>
    <url>/2021/06/09/Android%E8%BF%9B%E9%98%B6-RecyclerView/</url>
    <content><![CDATA[<div class="note green icon flat"><i class="note-icon fab fa-android"></i><p>前言：RecyclerView是Android5.0的一个新特性，包含在support-v7包中，用来替代ListView和GridView，是一个强大的滑动组件，而且可以实现瀑布流布局，它具有更加高度的解耦性、异常的灵活性和更高的效率，可以通过设置LayoutManager，ItemDecoration，ItemAnimator实现你想要的效果。</p>
</div>

<h2 id="配置build-gradle"><a href="#配置build-gradle" class="headerlink" title="配置build.gradle"></a>配置build.gradle</h2><ul>
<li>添加依赖包</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	...</span><br><span class="line">    implementation &#x27;androidx.appcompat:appcompat:1.2.0&#x27;</span><br><span class="line">    implementation &#x27;androidx.recyclerview:recyclerview:1.1.0&#x27;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用RecyclerView"><a href="#使用RecyclerView" class="headerlink" title="使用RecyclerView"></a>使用RecyclerView</h2><ul>
<li>布局文件中引入</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/id_recyclerview&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>活动中配置RecyclerView</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">mRecyclerView=(RecyclerView) findViewById(R.id.id_recyclerview);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置布局管理器</span></span><br><span class="line">mRecyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置item增加和删除时的动画</span></span><br><span class="line">mRecyclerView.setItemAnimator(<span class="keyword">new</span> DefaultItemAnimator());</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置适配器</span></span><br><span class="line">mList=createList();</span><br><span class="line">mHomeAdapter=<span class="keyword">new</span> HomeAdapter(mList, <span class="keyword">this</span>);</span><br><span class="line">mRecyclerView.setAdapter(mHomeAdapter);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建自定义适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">HomeAdapter</span>.<span class="title">MyViewHolder</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; mList;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeAdapter</span><span class="params">(List&lt;String&gt; mList, Context mContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mList = mList;</span><br><span class="line">        <span class="keyword">this</span>.mContext = mContext;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//删除条目信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeData</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        mList.remove(position);</span><br><span class="line">        notifyItemRemoved(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建自定义MyViewHolder</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyViewHolder <span class="title">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取条目（子项）布局的View对象</span></span><br><span class="line">        View view = LayoutInflater.from(mContext).inflate(R.layout.item_recycler, parent, <span class="keyword">false</span>);	</span><br><span class="line">        MyViewHolder holder = <span class="keyword">new</span> MyViewHolder(view);</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过创建的MyViewHolder实例，绑定（设置）子项布局各个组件上的数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="keyword">final</span> MyViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        holder.tv.setText(mList.get(position));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取子项的个数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        TextView tv;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyViewHolder</span><span class="params">(<span class="meta">@NonNull</span> View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            <span class="comment">//获取子项布局的各个组件</span></span><br><span class="line">            tv = (TextView) itemView.findViewById(R.id.tv_item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="设置分割线"><a href="#设置分割线" class="headerlink" title="设置分割线"></a>设置分割线</h2><ul>
<li>继承RecyclerView.ItemDecoration来自定义分割线</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DividerItemDecoration</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ItemDecoration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] ATTRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">            android.R.attr.listDivider              </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HORINZONTAL_LIST = LinearLayoutManager.HORIZONTAL;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERTICAL_LIST = LinearLayoutManager.VERTICAL;</span><br><span class="line">    <span class="keyword">private</span> Drawable mDivider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mOrientation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DividerItemDecoration</span><span class="params">(Context context, <span class="keyword">int</span> orientation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(ATTRS);     <span class="comment">//？？？？</span></span><br><span class="line">        mDivider = a.getDrawable(<span class="number">0</span>);</span><br><span class="line">        a.recycle();</span><br><span class="line">        setOrientation(orientation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOrientation</span><span class="params">(<span class="keyword">int</span> orientation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (orientation != HORINZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid orientation!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mOrientation = orientation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(<span class="meta">@NonNull</span> Canvas c, <span class="meta">@NonNull</span> RecyclerView parent, <span class="meta">@NonNull</span> RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(c, parent, state);</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL_LIST) &#123;</span><br><span class="line">            drawVertical(c, parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            drawHorinzontal(c, parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawHorinzontal</span><span class="params">(Canvas c, RecyclerView parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = parent.getPaddingLeft();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> right = parent.getWidth() - parent.getPaddingRight();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = parent.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = parent.getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = child.getBottom() + params.bottomMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> bottom = top + mDivider.getIntrinsicHeight();</span><br><span class="line">            mDivider.setBounds(left, top, right, bottom);</span><br><span class="line">            mDivider.draw(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawVertical</span><span class="params">(Canvas c, RecyclerView parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = parent.getPaddingTop();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = parent.getHeight() - parent.getPaddingBottom();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = parent.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = parent.getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = child.getRight() + params.rightMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> right = left + mDivider.getIntrinsicWidth();</span><br><span class="line">            mDivider.setBounds(left, top, right, bottom);</span><br><span class="line">            mDivider.draw(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffsets</span><span class="params">(<span class="meta">@NonNull</span> Rect outRect, <span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> RecyclerView parent, <span class="meta">@NonNull</span> RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.getItemOffsets(outRect, view, parent, state);</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL_LIST) &#123;</span><br><span class="line">            outRect.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, mDivider.getIntrinsicHeight());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outRect.set(<span class="number">0</span>, <span class="number">0</span>, mDivider.getIntrinsicWidth(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加分割线</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mRecyclerView.addItemDecoration(<span class="keyword">new</span> DividerItemDecoration(MainActivity.<span class="keyword">this</span>,DividerItemDecoration.HORINZONTAL_LIST));</span><br></pre></td></tr></table></figure>



<h2 id="自定义点击事件"><a href="#自定义点击事件" class="headerlink" title="自定义点击事件"></a>自定义点击事件</h2><div class="note info simple"><p>整体思路：</p>
<p>（1）在适配器在中创建一个自定义点击事件接听接口，声明一个接听接口变量，定义一个实例化该接口变量的函数；</p>
<p>（2）在主函数中，实例化一个自定义监听接口，并实现其中未定义的抽象方法（点击时的效果），并传给适配器；</p>
<p>（3）回到适配器其中，在回调的onClick()方法中，只有接听接口变量实例化了，才会调用其中实现了的抽象方法；</p>
<p>这种做法好处是：将接口定义与实现的分离，将点击事件定义的具体实现交给了主活动，在具体需要用到该适配器的时候才实现点击效果，这样，该自定义适配器类可以适用于多个不同点击效果的RecyclerView，只需要调用适配器的接口变量实例化函数。</p>
<p>这种设计思路是“接口的回调机制”<br><a href="https://blog.csdn.net/u012966861/article/details/52778841?utm_source=itdadao&amp;utm_medium=referral">https://blog.csdn.net/u012966861/article/details/52778841?utm_source=itdadao&amp;utm_medium=referral</a></p>
</div>

<ul>
<li>在HomeAdapter自定义OnItemClickListener接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   OnItemClickListener mOnItemClickListener;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnItemClickListener</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">onItemLongClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">……</span><br><span class="line">   <span class="comment">//实例化监听接口</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnItemClickListener</span><span class="params">(OnItemClickListener onItemClickListener)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.mOnItemClickListener = onItemClickListener;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主函数中，实现自定义监听接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//想要有不同的点击效果，可以定义多个setListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//实现按钮点击事件的自定义监听接口</span></span><br><span class="line">        mHomeAdapter.setOnItemClickListener(<span class="keyword">new</span> HomeAdapter.OnItemClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;点击了第&quot;</span>+(position+<span class="number">1</span>)+<span class="string">&quot;条&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemLongClick</span><span class="params">(View view, <span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>)</span><br><span class="line">                        .setTitle(<span class="string">&quot;确认要删除吗？&quot;</span>)</span><br><span class="line">                        .setNegativeButton(<span class="string">&quot;取消&quot;</span>,<span class="keyword">null</span>)</span><br><span class="line">                        .setPositiveButton(<span class="string">&quot;确认&quot;</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                                mHomeAdapter.removeData(position);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在适配器中调用接口中的方法</p>
<p>需要适配器类implements View.OnClickListener, View.OnLongClickListener</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MyViewHolder <span class="title">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        view.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        view.setOnLongClickListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mOnItemClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mOnItemClickListener.onItemClick(v, (<span class="keyword">int</span>) v.getTag());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLongClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mOnItemClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mOnItemClickListener.onItemLongClick(v, (<span class="keyword">int</span>) v.getTag());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《Android进阶》</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像复习笔记</title>
    <url>/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><ul>
<li><p>1.数字图像：<br>一幅图像可定义为一个二维函数f(x,y),其中x和y是<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间(平面)坐标</span></span>,而在任何一对空间坐标(x, y)处的幅值f称为图像在该点处的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">强度或灰度</span></span>。当x, y和灰度值f是有限的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">离散数值</span></span>时，我们称该图像为数字图像。</p>
</li>
<li><p>2.数字图像处理：<br>是指借助于<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数字计算机</span></span>来处理数字图像。</p>
</li>
<li><p>3.像素：<br>数字图像是由有限数量的（二维的）元素组成的，每个元素都有一个特定的位置(x,y)和幅值f(x,y)。这些元素称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图画元素、图像元素或像素</span></span>。</p>
</li>
<li><p>4.图像增强：<br>对一幅图像进行某种操作，使其结果在特定应用中比原始图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">更适合</span></span>进行处理</p>
</li>
<li><p>5.图像复原：<br>图像复原也是改进图像外观的一个处理领域。然而，与图像增强不同，图像增强是<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">主观的</span></span>，而图像复原是<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">客观的;</span></span>;在某种意义上说，复原技术倾向于以<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像退化的数学或概率模型</span></span>为基础。另一方面，增强以<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">什么是好的增强效果</span></span>这种人的主观偏爱为基础。</p>
</li>
<li><p>6.图像处理系统基本组成结构：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数字化</span></span>设备（数码相机、数码摄像机）、图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">处理</span></span>设备（计算机和存储系统）、图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">输出</span></span>设备（打印机）</p>
</li>
<li><p>7.图像存储系统：<br>（1）图像文件格式体系：<br>互联网用：GIF、JPG<br>印 刷 用：TIF、JPG、TAG 、PCX<br>国际标准：TIF、JPG、BMP<br>（2）图像存储体系：(分级存储)<br>内存存储： 处理时使用<br>硬盘存储：处理、备份时用<br>备份存储：光盘、磁带<br>网络存储：SAN、 NAS</p>
</li>
<li><p>8.数字图像处理应用领域：传统领域（医学、地理学、生物学、军事）；最新领域（指纹识别、人脸识别、图像检索等）</p>
</li>
</ul>
<h1 id="第二章-数值图像基础"><a href="#第二章-数值图像基础" class="headerlink" title="第二章 数值图像基础"></a>第二章 数值图像基础</h1><div class="note info blue modern"><p><strong>两个名词解释</strong></p>
</div>

<ul>
<li><p>1.为了产生一幅数字图像，需要把连续的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">感知数据</span></span>转化为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数字形式</span></span>，这包括两种处理：取样和量化</p>
</li>
<li><p>2.取样：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间坐标</span></span>的数字化；(对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">坐标值</span></span>进行数字化)<br>量化：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">函数值（灰度值</span></span>的数字化；（对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">幅值</span></span>进行数字化）</p>
</li>
<li><p>3.非统一的图像的采样<br>在灰级变化<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">尖锐的</span></span>区域，用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">细腻的</span></span>采样，<br>在灰度级比较<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">平滑的</span></span>区域，用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">粗糙的</span></span>采样</p>
</li>
<li><p>4.非统一的图像的量化<br>✓ 在<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">边界附近</span></span>（灰度级变化尖锐）使用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">较少</span></span>的灰度级。剩余的灰度级可用于灰度级变化比较<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">平滑</span></span>的区域<br>✓ 避免或减少由于量化的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">太粗糙</span></span>，在灰度级变化比较平滑的区域出现<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">假轮廓</span></span>的现象</p>
</li>
<li><p>5.通常，图像在任何坐标(x,y)处的值记为f(x,y)，其中x和y都是整数。由一幅图像的坐标张成的实平面部分称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间域</span></span>，x和 y称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间变量或空间坐标</span></span>。</p>
</li>
<li><p>6.灰度跨越的值域非正式地称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">动态范围</span></span>。</p>
</li>
<li><p>7.空间分别率：图像中可辨别的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">最小细节</span></span>的度量，其中每单位<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">距离线对数</span></span>和每单位<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">距离点数</span></span>（像素数）都是最通用的度量。<br>灰度分别率：可分辨的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">最小灰度级</span></span>变化。</p>
</li>
<li><p>8.数字图像的表示包括：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">描述信息</span></span>（如图像高度和宽度）、图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: 查看答案">查看答案
  </button><span class="hide-content">数据</span></span>（顺序存放的连续数据）</p>
</li>
<li><p>9.图像的质量包括：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">层次、对比度、清晰度</span></span><br>(1)层次：图像实际拥有的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">灰度级</span></span>的数量（灰度级：表示像素<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">明暗程度</span></span>的整数量） 图像的实际层次越多，视觉效果就越好。<br>(2)对比度：一幅图像中<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">灰度反差</span></span>的大小（对比度=最大亮度/最小亮度）<br>(3)与清晰度相关的主要因素：亮度、对比度、尺寸大小、细微层次、颜色饱和度</p>
</li>
<li><p>10.4邻域：像素p(x,y)的4邻域是： (x+1,y)；(x-1,y)；(x,y+1)；(x,y-1)。用N4(p)表示像素p的4邻域 </p>
<p>D邻域定义：像素p(x,y)的D邻域是对角上的点 (x+1,y+1)；(x+1,y-1)；(x-<br>1,y+1)；(x-1,y-1)<br>用ND(p)表示像素p的D邻域</p>
<p>8邻域定义：像素p(x,y)的8邻域是：<br>4邻域的点 ＋ D邻域的点<br>用N8(p)表示像素p的8邻域。 N<del>8</del>(p) = N<del>4</del>(p) + N<del>D</del>(p) </p>
</li>
<li><p>10.连通性：是描述区域和边界的重要概念。<br>两个像素连通的两个必要条件是：（1）两个像素<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">位置是否相邻</span></span>；（2）两个像素的灰度值是否满足<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">特定的相似性准则</span></span>（或者是否相等）</p>
</li>
<li><p>11.像素的连通性：<br>(1)4连通：对于具有值V的像素p和q，如果q在集合N4(p)中，则称这两个像素是4 连通的<br>(2)8连通：对于具有值V的像素p和q，如果q在 集 合N8(p)中，则称这两个像素是8连通的<br>(3)对 于 具 有 值 V 的 像 素 p 和 q ，<br>如 果<br>I.q在集合N4(p)中，或<br>II. q在集合ND(p)中，并且N4(p)与N4(q)的交集为空（没有值V的像素） 则称这两个像素是m连通的，即4连通和D连通的混合连通。</p>
</li>
<li><p>12.像素p(x,y)和q(s,t)间的欧式距离:<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623151831018.png" alt="image-20210623151831018"></p>
</li>
</ul>
<p>  对于这个距离计算法，具有与(x,y) 距离小于等于某个值r的像素是：包含在以(x,y)为圆心，以r为半径的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">圆平面</span></span></p>
<ul>
<li><p>13.像素p(x,y)和q(s,t)之间的D4距离(城市距离、街区距离)：<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620200645833.png" alt="image-20210620200645833"><br>具有与(x,y)距离小于等于某个值r的那些像素形成一个<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">菱形</span></span></p>
</li>
<li><p>14.q(s,t)之间的D8距离（棋盘距离）：<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620200655280.png" alt="image-20210620200655280"><br>具有与(x,y)距离小于等于某个值r的那些像素形成一个<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">正方形</span></span></p>
</li>
</ul>
<h1 id="第三章-灰度变换和空间滤波"><a href="#第三章-灰度变换和空间滤波" class="headerlink" title="第三章 灰度变换和空间滤波"></a>第三章 灰度变换和空间滤波</h1><div class="note info blue modern"><p><strong>两个名词解释+一个简答 +程序</strong></p>
</div>

<ul>
<li><p>1.图像增强分为两类：<br>(1)空间域处理：对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像像素</span></span>直接处理<br>(2)频率域处理：修改图像的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">傅里叶变换</span></span><br>2.灰度变换函数:g(x,y)=T[f(x,y)] 或 s = T(r)</p>
</li>
<li><p>3.一些基本的灰度变换函数：<br>（1）反转变换：<font color="red">s = (L-1) - r</font><br>作用：黑的变白，白的变黑（特别适合用于增强嵌入在一幅图像暗区域中的白色或灰色细节，特别是当黑色面积在尺寸上占主导时）<br>（2）对数变换：<font color="red">s = c log(1+r)</font><br>有时原图的动态范围太大，超出某些显示设备的允许动态范围，如直接使用原图，则一部分细节可能丢失, 解决办法是对原图进行灰度压缩，如对数变换</p>
<p>作用：灰度压缩/扩展，对数函数有个重要特征，即它能压缩像素值变化较大的图像的动态范围。</p>
</li>
</ul>
<p>（3）幂次变换：<font color="red">s = c ^r^  </font></p>
<p>  γ&lt;1 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">提高灰度级</span></span>，在正比函数上方，使图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">变亮 </span></span><br>  γ&gt;1 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">降低灰度级</span></span>，在正比函数下方，使图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">变暗</span></span></p>
<ul>
<li><p>4.直方图的定义：h(r<del>k</del>)= n<del>k</del>    p(r<del>k</del>)= n<del>k</del>/n<br>第二种定义的好处：<br>✓ 使函数值正则化到[0,1]区间，成为实数函数 ；<br>✓ 函数值的范围与像素的总数无关 ；<br>✓ 给出灰度级rk在图像中出现的概率密度统计</p>
</li>
<li><p>补充：</p>
<ul>
<li>暗图像：直方图的分量集中在灰度级的低端</li>
<li>亮图像：直方图的分量集中在灰度级的高端</li>
<li>低对比度图像：具有较窄的直方图，且集中在灰度级的中部</li>
<li>高对比度图像：具有较宽的直方图，直方图的分量覆盖了很宽的灰度级范围，且像素没有分布不均匀</li>
</ul>
</li>
<li><p>5.直方图的均衡化：基本思想是把原始图的直方图变换为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">均匀分布</span></span>的形式，这样就增加了像素灰度值的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">动态范围</span></span>，从而达到增强图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">整体对比度</span></span>的效果 </p>
</li>
<li><p>6.直方图均衡化公式：s=T(r)    0&lt;=r&lt;=1<br>T(r)满足下列两个条件：<br>（1）T(r)在区间0≤r≤1中为单值且单调递增<br>（2）当0≤r≤1时,0≤T(r)≤1</p>
<p>条件（1）保证输出灰度不少于相应的输入灰度，防止灰度反变换时产生的人为缺陷</p>
<p>条件（2）保证灰度的输出范围与输入范围一致，且是一对一的映射关系，防止二义性</p>
</li>
<li><p>7.对于连续灰度值：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201010302.png" alt="image-20210620201010302"><br>对于离散灰度值:<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201019248.png" alt="image-20210620201019248"><br>(P76 【例3.5】！)</p>
</li>
<li><p>8.直方图规定化：希望处理后的图像具有<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">规定的直方图形状</span></span>，这种用于产生处理后有特殊直方图的方法，称为直方图匹配或直方图规定化。<br>（P80 【例 3.8】）</p>
</li>
<li><p>9.镜头检测方法：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">连续帧相减、直方图相减、时空切片分析</span></span></p>
</li>
<li><p>10.镜头：是指一系列连续记录的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像帧</span></span>，用于表示一个时间段或相同地点连续的动作。</p>
</li>
<li><p>11.连续帧相减：<br>(1)算法原理：计算相邻两帧<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">像素</span></span>变化的数目。当超过设定的阈值时，即找到镜头的边缘。<br>(2)缺点：对摄像机运动敏感，如放缩、平移<br>(3)解决办法：通过滤波器的使用来降低。在比较一帧的每个像素前，用它的邻近区域的平均值来代替，这也就过滤了输入图像的一些噪声。</p>
</li>
<li><p>12.直方图相减<br>(1)算法原理：统计相邻两帧中所有像素在不同灰度上的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">分布差异</span></span>，当差异的累加值超过阈值T时，即检测到镜头边缘。<br>(2)优点：对对象运动不敏感，因为直方图忽略了帧内的空间变化。<br>(3)缺点：可能两个图像有类似的直方图但却是完全不同的内容。然而这种事件概率是足够低的。</p>
</li>
<li><p>13.空间滤波和空间滤波器的定义 使用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间模板</span></span>进行的图像处理，被称为 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间滤波</span></span>。模板本身被称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间滤波器</span></span>（空间滤波器：邻域与预操作的集合）</p>
</li>
<li><p>14.<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201142147.png" alt="image-20210620201142147"></p>
</li>
</ul>
<p>其中w是滤波器系数，z是该系数对应的图像灰度值。</p>
<ul>
<li><p>15.平滑空间滤波器：<br>（1）线性滤波器：均值滤波器<br>（2）非线性滤波器：最大值滤波器、中值滤波器、最小值滤波器</p>
</li>
<li><p>16.均值滤波器：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">包含在滤波器邻域内像素的平均值</span></span> （用像素领域内的平均值代替该像素）<br>作用：减小图像灰度的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">“尖锐”</span></span>变化，减小<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">噪声</span></span>；边缘模糊<br>公式：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201443661.png" alt="image-20210620201443661"></p>
</li>
</ul>
<ul>
<li>17.统计排序滤波器：<br>是一种非线性滤波器，基于滤波器所在图像区域中<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">像素的排序</span></span>，由 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">排序结果决定的值</span></span>代替中心像素的值</li>
</ul>
<p>（1）中值滤波器：用像素领域内的中间值代替该像素<br>①用途：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">去除噪声</span></span><br>②公式：R = mid {zk | k = 1,2,…,n}<br>③<br>特点：在去除噪音的同时，可以比较好地保留<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">边的锐度</span></span>和<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像的细节</span></span>（优于均值滤波器）<br>能够有效去除<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">脉冲噪声</span></span>：以黑白点叠加在图像上</p>
<p>（2）最大值滤波器：用像素领域内的最大值代替该像素<br>①用途：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">寻找最亮点</span></span><br>②公式：R = max {zk | k = 1,2,…,n} </p>
<p>（3）最小值滤波器：用像素领域内的最小值代替该像素<br>①用途：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">寻找最暗点</span></span><br>②公式：R = min {zk | k = 1,2,…,n}</p>
<ul>
<li><p>18.锐化滤波器的应用：<br>突出图像中的细节，增强被模糊了的细节<br>✓ 印刷中的细微层次强调。弥补扫描对图像的钝化<br>✓ 超声探测成像，分辨率低，边缘模糊，通过锐化来改善<br>✓ 图像识别中，分割前的边缘提取<br>✓ 锐化处理恢复过度钝化、暴光不足的图像<br>✓ 尖端武器的目标识别、定位</p>
</li>
<li><p>19.二阶微分滤波器–拉普拉斯算子<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps1.jpg" alt="img"><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps2.jpg" alt="img"></p>
</li>
<li><p>20.一阶微分滤波器–梯度算子</p>
</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps3.jpg" alt="img"></p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps4.jpg" alt="img"></p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps5.jpg" alt="img"></p>
<h1 id="第六章-彩色图像处理"><a href="#第六章-彩色图像处理" class="headerlink" title="第六章 彩色图像处理"></a>第六章 彩色图像处理</h1><ul>
<li><p>1.为什么要研究彩色图像处理？<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">符合人类视觉特点：人类可以辨别几千种彩色色调和亮度；但相比之下只能辨别几十种灰度层次</span></span><br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">强有力的描绘子：常常可以简化从场景中提取和识别目标</span></span></p>
</li>
<li><p>2.彩色图像处理分为：全彩色图像处理、伪彩色图像处理</p>
</li>
<li><p>3.三原色：红、绿、蓝<br>二次色:    红+蓝=<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">深红M</span></span>        红+绿=<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">黄Y</span></span>        绿+蓝=<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">青色C</span></span></p>
</li>
<li><p>4.描述彩色光源质量的三个基本量：<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">辐射</span></span>（率）：从光源流出能量的总和，用瓦特（W）度量<br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">光强</span></span>：观察者从光源感知的（接收的）能量总和，用流明来度量<br>(3)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">亮度</span></span>：主观描绘子。实际上是不可能度量的，用来表示无色的强度概念。</p>
</li>
<li><p>5.用于区分不同颜色特性的基本量：<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">亮度</span></span>：具体表达了无色的强度概念<br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">色调</span></span>：是混合光波中与主波长有关的属性，表明观察者感知的主要颜色<br>(3)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">饱和度</span></span>：指的是相对纯净度，或一种颜色混合白光的数量。纯谱色是全饱和的。</p>
</li>
<li><p>6.彩色模型（彩色空间、彩色系统）<br>在某些标准下，用通常可以接收的方式方便地对彩色加以说明。本质上是对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">坐标系统</span></span>和<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">子空间</span></span>的说明。</p>
<p>现在大多数的彩色模型不是面向硬件的，就是面向应用的。</p>
</li>
<li><p>7.RGB（红绿蓝模型）<br>(1)用于彩色监视器和一大类彩色视频摄像机；<br>(2)是图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">成像、显示、打印</span></span>等设备的基础<br>(3)面向硬件</p>
</li>
<li><p>8.CMY和CMYK（青、深红、黄、黑）<br>(1)用于彩色<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">打印机</span></span>和<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">复印机</span></span><br>(2)为什么用CMYK：等量的CMY原色产生黑色，但不纯</p>
</li>
<li><p>9.HSI（色调、饱和度、亮度）<br>(1)特点：<br>①I（亮度）分量与图像的彩色信息无关（解除分量中灰度I和颜色HS的联系）<br>②H和S分量与人感受颜色的方式是紧密联系的<br>(2)应用于计算机视觉、图像检索、视频检索</p>
</li>
<li><p>10.彩色空间转换</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623221945843.png" alt="image-20210623221945843"></p>
</li>
<li><p>11.什么叫伪彩色图像处理？</p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">也叫假彩色图像处理，根据一定的准则对灰度值赋予彩色的处理</span></span>



<p>为什么需要伪彩色图像处理？</p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">人类可以辨别几千种彩色色调和亮度；但相比之下只能辨别几十种灰度层次</span></span></li>
<li><p>12.怎样进行伪彩色图像处理？</p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">强度（强度）分层技术</span></span>、<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">灰度级到彩色的转换</span></span></li>
<li><p>13.全彩色图像处理分类<br>(1)分别处理每一分量，然后合成彩色图像<br>(2)直接对彩色像素处理</p>
</li>
<li><p>14补色：在彩色环上，与一种的色调H<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">直接相对立</span></span>的另外一种色调</p>
</li>
</ul>
<h1 id="第八章-图像压缩"><a href="#第八章-图像压缩" class="headerlink" title="第八章 图像压缩"></a>第八章 图像压缩</h1><ul>
<li><p>1.为什么需要图像压缩？<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像的数据量通常很大，对存储、处理和传输带来许多问题</span></span><br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">不断扩大的图像应用</span></span></p>
</li>
<li><p>2.图像压缩分类<br>(1)无损压缩：在压缩和解压缩过程中没有信息损失<br>(2)有损压缩：能取得较高的压缩率，但压缩后不能通过解压缩恢复原状</p>
</li>
<li><p>3.压缩方法：预测编码方法、变换编码方法</p>
</li>
<li><p>4.数据冗余：<br>数据是用来表示信息的。如果不同的方法为表示给定量的信息使用了不同的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数据量</span></span>，那么使用较多数据量的方法中，有些数据必然是代表了无 用的信息，或者是重复地表示了其它数据已表示的信息，这就是数据冗余的概念</p>
</li>
<li><p>5.公式（相对数据冗余与压缩率的关系）</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps6.jpg" alt="img"><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps7.jpg" alt="img"></p>
</li>
<li><p>6.三种基本的数据冗余<br>（1）编码冗余<br>如果一个图像的灰度级编码，使用了多于<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">实际需要的编码符号</span></span>，就称该图像包含了编码冗余<br>（2）像素间冗余<br>对于一幅图像，很多<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">单个像素对视觉的贡献</span></span>是冗余的。它的值可以通过与它相邻的像素值为基础进行预测<br>（3）心理视觉冗余<br>有些信息在<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">通常的视觉过程中</span></span>通常的视觉过程中与另外一些信息相比并不那么重要，这些信息被认为是心理 视觉冗余的，去除这些信息并不会明显降低图像质量</p>
</li>
<li><p>7.保真度准则：<br>图像压缩可能会导致信息损失，需要有<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">评价信息损失</span></span>的测度，以描述解码图像相<br>对于原始图像的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">偏离程度</span></span>，这些测度称为保真度准则（量化信息丢失的本质的方法）<br>（1）均方根误差</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps8.jpg" alt="img"></p>
<p>（2）均方信噪比</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps9.jpg" alt="img"></p>
</li>
<li><p>8.图像压缩系统的功能流程图</p>
</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps10.jpg" alt="img"></p>
<ul>
<li>9.图像压缩系统模型（简）</li>
</ul>
<p>编码器：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps11.jpg" alt="img"></p>
<p>解码器：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps12.jpg" alt="img"></p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">转换器</span></span>（映射器）：减少像素间冗余
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">量化器</span></span>：减少心理视觉冗余，该步操作不可逆
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">符号编码器</span></span>：减少编码冗余
<p>（进行无损压缩时，去掉量化器）</p>
<ul>
<li>10.信源的熵：<br>每个信源输出的平均信息。</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps13.jpg" alt="img"></p>
<ul>
<li><p>11.变长编码：<br>(1)减少编码冗余<br>(2)变长编码，即把<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">最短的码字</span></span>赋予给<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">出现概率最大</span></span>的灰度级</p>
</li>
<li><p>12.霍夫曼编码（步骤）<br>(1)第一步：将所有需要考虑的符号进行概率排序，并将最低概率的符号合并为一个符号来替代下次信源化简过程中的符号，从而创建一个信源化简系统；<br>(2)第二步：对每个化简后的信源进行编码，从小的信源开始一直编码到原始信源。<br>(3)P346 【例】</p>
</li>
<li><p>13.LZW编码（消除像素间冗余/空间冗余）<br>将原始数据中的重复字符串建立一个字串表，然后用该重复字串在字串表中的索引替代原始数据达到压缩的目的。<br>P351</p>
</li>
</ul>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><ul>
<li>补色和反色</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">im = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">im_converted_mat = np.zeros_like(im, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(im.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(im.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="comment"># 补色公式max(r,g,b)+min(r,g,b)-[r,g,b]</span></span><br><span class="line">        maxrgb = im[x][y].<span class="built_in">max</span>()</span><br><span class="line">        minrgb = im[x][y].<span class="built_in">min</span>()</span><br><span class="line">        im_converted_mat[x][y] = (<span class="built_in">int</span>(maxrgb) + <span class="built_in">int</span>(minrgb)) * np.ones(<span class="number">3</span>) - im[x][y]</span><br><span class="line"></span><br><span class="line"><span class="comment">#反色公式[255,255,255]-[r,g,b]</span></span><br><span class="line">im_converted_mat2 = np.ones_like(im) * <span class="number">255</span> - im</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;ori&#x27;</span>, im)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;buse&#x27;</span>, im_converted_mat)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;fanse&#x27;</span>, im_converted_mat2)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;buse.jpg&#x27;</span>, im_converted_mat)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;fanse.jpg&#x27;</span>, im_converted_mat2)</span><br><span class="line">cv2.waitKey()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<ul>
<li>直方图均衡化Histogram</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img=cv.imread(<span class="string">&quot;his.jpg&quot;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">gray_static=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">width,height=np.shape(img) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        gray_static[img[i,j]]+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">n=width*height</span><br><span class="line"></span><br><span class="line"><span class="comment">#pdf（概率密度函数）用来存储每个灰度值出现的概率（比例），像素个数/总像素个数</span></span><br><span class="line">pdf=[i/n <span class="keyword">for</span> i <span class="keyword">in</span> gray_static]</span><br><span class="line"></span><br><span class="line"><span class="comment">#cdf（累计分布函数），用来存储每个灰度值的累计分布函数值</span></span><br><span class="line">cdf=pdf</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    cdf[i]=cdf[i]+cdf[i-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#直方图均衡化转化</span></span><br><span class="line">img_t=np.copy(img)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):   </span><br><span class="line">        img_t[i,j]=<span class="number">255</span>*cdf[img[i,j]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制并显示直方图</span></span><br><span class="line">plt.hist(img.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"><span class="comment">#plt.show()</span></span><br><span class="line">plt.hist(img_t.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;img&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;img_t&#x27;</span>,img_t)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<ul>
<li>均值滤波</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps14.jpg" alt="img"></p>
<ul>
<li>中值滤波</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps15.jpg" alt="img"></p>
<ul>
<li><p>锐化滤波</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps16.jpg" alt="img"></p>
</li>
</ul>
<ul>
<li><p>图像的熵</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps17.jpg" alt="img"></p>
</li>
</ul>
<ul>
<li>LZW-encode</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623235657253.png" alt="image-20210623235657253"></p>
<ul>
<li>LZW-decode</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623235728790.png" alt="image-20210623235728790"></p>
]]></content>
      <categories>
        <category>《数字图像处理》</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程并发</title>
    <url>/2021/06/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>问题描述：1个父线程，并发生成N（N作为参数传入）个子线程。设定全局变量 g_sum=0，每个子进程在 0至200中随机选择一个数；</p>
<p>若子线程的进程ID是奇数则g_sum=g_sum-随机数，<br>若子线程的进程ID是偶数则g_sum=g_sum+随机数，</p>
<p>每个子线程对g_sum操作完成后都要通知父线程，父线程收到通知后输出“子线程{进程ID}对g_sum进行了[加/减]{随机数}操作，当前g_sum={新值}”，父进程将每次g_sum的新值进行记录，并对已记录的数组进行升序排列，每次重新排列后进行一次输出。</p>
</div>



<h1 id="想法一-回调方式"><a href="#想法一-回调方式" class="headerlink" title="想法一  回调方式"></a>想法一  回调方式</h1><ul>
<li><h2 id="ThreadTest-java"><a href="#ThreadTest-java" class="headerlink" title="ThreadTest.java"></a>ThreadTest.java</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> g_sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; g_sumList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Object o= <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.g_sumList.add(g_sum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *子线程回调函数 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> id 进程id</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> num 加或减的数值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> flag	加或减的标志</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callBack</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> num, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">		String mark = flag == <span class="number">1</span> ? <span class="string">&quot;加&quot;</span> : <span class="string">&quot;减&quot;</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;子线程&quot;</span> + id + <span class="string">&quot;:对g_num进行了&quot;</span> + mark + <span class="string">&quot;&quot;</span> + num + <span class="string">&quot;操作，当前g_sum=&quot;</span> + g_sum);</span><br><span class="line">		<span class="comment">//将值记录到列表并排序，输出</span></span><br><span class="line">		g_sumList.add(g_sum);</span><br><span class="line">		Collections.sort(g_sumList);</span><br><span class="line">		SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();		<span class="comment">// 格式化时间 </span></span><br><span class="line">        sdf.applyPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss a&quot;</span>);			<span class="comment">// a为am/pm的标记  </span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();								<span class="comment">// 获取当前时间 </span></span><br><span class="line">		System.out.println(sdf.format(date)+<span class="string">&quot; g_sum历史值升序为：&quot;</span>);</span><br><span class="line">		System.out.println(g_sumList);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建N个子线程</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">generateThreads</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> randomNum;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> id = <span class="number">1</span>; id &lt;= N; id++) &#123;</span><br><span class="line">			randomNum = (<span class="keyword">int</span>) (Math.random() * <span class="number">200</span>);</span><br><span class="line">			<span class="comment">//通过自定义的Runnable类创建线程</span></span><br><span class="line">			MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable(id, randomNum);</span><br><span class="line">			Thread t=<span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadTest test = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">		test.generateThreads(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="MyRunnable-java"><a href="#MyRunnable-java" class="headerlink" title="MyRunnable.java"></a>MyRunnable.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> randomNum;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> randomNum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.randomNum = randomNum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (ThreadTest.o) &#123;	<span class="comment">//加同步锁，防止多个线程对g_sum操作造成脏读</span></span><br><span class="line">			<span class="keyword">if</span> (id % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				ThreadTest.g_sum += randomNum;</span><br><span class="line">				ThreadTest.callBack(id, randomNum, <span class="number">1</span>);				</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ThreadTest.g_sum -= randomNum;</span><br><span class="line">				ThreadTest.callBack(id, randomNum, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2></li>
</ul>
<img src="/2021/06/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/image-20210623000217372.png" alt="image-20210623000217372" style="zoom:80%;">

<div class="note warning simple"><p>子线程和父线程之间其实并没有进行通信，打印信息的静态回调方法callBack()虽然是在主类中定义，但是却是在子线程中调用的，而不是子线程将信息传递并通知给主线程，然后主线程打印。</p>
</div>



<h1 id="想法二-消息队列"><a href="#想法二-消息队列" class="headerlink" title="想法二  消息队列"></a>想法二  消息队列</h1><ul>
<li><h2 id="ThreadTest-java-1"><a href="#ThreadTest-java-1" class="headerlink" title="ThreadTest.java"></a>ThreadTest.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> g_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Deque&lt;Message&gt; messageDeque = <span class="keyword">new</span> ArrayDeque();</span><br><span class="line"> 	<span class="keyword">public</span>  List&lt;Integer&gt; g_sumList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> Object lock= <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">super</span>();</span><br><span class="line"> 		<span class="keyword">this</span>.g_sumList.add(g_sum);</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">//N个子线程并发创建执行</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">generateThreads</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">int</span> randomNum;</span><br><span class="line"> 		<span class="keyword">for</span> (<span class="keyword">int</span> id = <span class="number">1</span>; id &lt;= N; id++) &#123;</span><br><span class="line"> 			randomNum = (<span class="keyword">int</span>) (Math.random() * <span class="number">200</span>);</span><br><span class="line"> 			<span class="comment">//通过自定义的Runnable类创建线程</span></span><br><span class="line"> 			MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable(id, randomNum);</span><br><span class="line"> 			Thread t=<span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line"> 			t.start();</span><br><span class="line"> 		&#125;		</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> 		System.out.print(<span class="string">&quot;请输入问题规模：&quot;</span>);</span><br><span class="line"> 		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> 		<span class="keyword">int</span> N = in.nextInt();</span><br><span class="line"> 		ThreadTest test = <span class="keyword">new</span> ThreadTest();</span><br><span class="line"> 		<span class="keyword">synchronized</span> (lock) &#123;						<span class="comment">//加同步锁</span></span><br><span class="line"> 			test.generateThreads(N);				<span class="comment">//在主线程中并发创建N个进程</span></span><br><span class="line"> 			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"> 				<span class="keyword">if</span>(messageDeque.isEmpty()) &#123;</span><br><span class="line"> 					lock.wait();					<span class="comment">//消息队列为空时，主线程阻塞等待，等待lock解锁</span></span><br><span class="line"> 				&#125;												</span><br><span class="line"> 				<span class="keyword">while</span>(!messageDeque.isEmpty()) &#123;		</span><br><span class="line"> 					<span class="comment">//主线程从消息队列中取出消息并打印</span></span><br><span class="line"> 					Message mess = messageDeque.pop();</span><br><span class="line"> 					System.out.println(<span class="string">&quot;子线程&quot;</span>+mess.tid+<span class="string">&quot;进行了&quot;</span>+mess.op+<span class="string">&quot;&quot;</span>+mess.randomNum+<span class="string">&quot;操作，当前g_sum=&quot;</span>+mess.g_sum);</span><br><span class="line"> 					<span class="comment">//将g_sum的历史值记录到列表并排序</span></span><br><span class="line"> 					test.g_sumList.add(mess.g_sum);</span><br><span class="line"> 					Collections.sort(test.g_sumList);</span><br><span class="line"> 					<span class="comment">//打印g_sum的历史值列表</span></span><br><span class="line"> 					System.out.println(mess.opeTime+<span class="string">&quot; g_sum历史值升序为：&quot;</span>);</span><br><span class="line"> 					System.out.println(test.g_sumList);</span><br><span class="line"> 					System.out.println();</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="MyRunnable-java-1"><a href="#MyRunnable-java-1" class="headerlink" title="MyRunnable.java"></a>MyRunnable.java</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tid;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> randomNum;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> randomNum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.tid = id;</span><br><span class="line">		<span class="keyword">this</span>.randomNum = randomNum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (ThreadTest.lock) &#123;						<span class="comment">//加同步锁，防止多个线程同时（并发）对g_sum操作造成脏读</span></span><br><span class="line">			SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();		<span class="comment">// 格式化时间 </span></span><br><span class="line">	        sdf.applyPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss a&quot;</span>);			<span class="comment">// a为am/pm的标记  								</span></span><br><span class="line">	        String opeTime = sdf.format(<span class="keyword">new</span> Date());			<span class="comment">// 获取当前时间 </span></span><br><span class="line">	        </span><br><span class="line">			<span class="keyword">if</span> (tid % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				ThreadTest.g_sum += randomNum;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//创建一个消息，并添加到消息队列</span></span><br><span class="line">				Message message = <span class="keyword">new</span> Message(tid, <span class="string">&quot;加&quot;</span>, randomNum,ThreadTest.g_sum,opeTime);</span><br><span class="line">				ThreadTest.messageDeque.add(message);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//解锁，唤醒主线程，可以从消息队列取消息啦</span></span><br><span class="line">				ThreadTest.lock.notifyAll();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ThreadTest.g_sum -= randomNum;</span><br><span class="line">							</span><br><span class="line">				Message message = <span class="keyword">new</span> Message(tid, <span class="string">&quot;减&quot;</span>, randomNum,ThreadTest.g_sum,opeTime);</span><br><span class="line">				ThreadTest.messageDeque.add(message);</span><br><span class="line">				</span><br><span class="line">				ThreadTest.lock.notifyAll();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> sleepTime = (<span class="keyword">int</span>)(Math.random() * <span class="number">500</span>);			<span class="comment">//让线程随机休眠一定时间</span></span><br><span class="line">				Thread.sleep(sleepTime);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//子线程传递给父线程的消息类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> tid;				<span class="comment">//子线程id</span></span><br><span class="line">		<span class="keyword">public</span> String op;			<span class="comment">//加或减操作</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> randomNum;		<span class="comment">//随机数</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> g_sum;			<span class="comment">//操作后的g_sum</span></span><br><span class="line">		<span class="keyword">public</span> String opeTime;		<span class="comment">//操作时的时间</span></span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> tid, String op, <span class="keyword">int</span> randomNum,<span class="keyword">int</span> g_sum ,String time)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.tid = tid;</span><br><span class="line">			<span class="keyword">this</span>.op = op;</span><br><span class="line">			<span class="keyword">this</span>.randomNum = randomNum;</span><br><span class="line">			<span class="keyword">this</span>.g_sum = g_sum;</span><br><span class="line">	        <span class="keyword">this</span>.opeTime=time;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2></li>
</ul>
<img src="/2021/06/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/image-20210623081306586.png" alt="image-20210623081306586" style="zoom: 80%;">

<div class="note success simple"><p>主线程并发创建N个子线程后，转为阻塞等待状态，等待lock解锁获得执行权且消息队列非空，然后一次性打印消息队列中已经存放的消息。</p>
<p>子线程在进行“加减”操作完成后，创建一个消息（包含线程id、随机数、操作类型、操作结果、操作时间信息），并把这个消息添加到消息队列（一个静态全局的队列），然后Notifiy（通知）唤醒主线程，通知它消息队列有消息可以打印了。</p>
</div>]]></content>
      <tags>
        <tag>多线程</tag>
        <tag>JAVA</tag>
        <tag>同步锁</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验八-无线路由器配置</title>
    <url>/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>掌握无线路由器的配置</p>
<p>掌握WireShake网络抓包和分析</p>
<p>掌握开启电脑IIS</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>· Cisco Packet Tracer     WireShake</p>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>（1）无线路由器的配置，包括设置SSID，密码，加密类型等信息</p>
<p>（2）WireShake网络抓包，分析账号和密码等数据信息</p>
<p>（3）开启电脑网络信息服务，搭建一个简单的网站，并测试访问 </p>
<h1 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h1><ul>
<li>1.掌握无线路由器配置    </li>
</ul>
<p>（1）新建packet tracer网络拓扑图（实验二为基础）</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps1.jpg" alt="img"> </p>
<p>（2）新增一个服务器和无线路由器，配置器基本信息，包括IP地址、子网掩码和默认网关</p>
<p>（3）通过一台主机Laptop2的WEB浏览器访问无线路由器的IP地址，授权登录（用户名和密码都是：admin）,登录到无线路由器的配置页面。在此可以完成路由器的一些配置，包括SSID，密码，网络模式，安全模式，管理者账号密码等。</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps2.jpg" alt="img">    <img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps3.jpg" alt="img"></p>
<p>（4）增加两台移动设备，连接WiFi，测试访问服务器</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps4.jpg" alt="img">    <img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps5.jpg" alt="img"></p>
<ul>
<li>2.网络抓包和分析</li>
</ul>
<p>（1）选择网络接口和过滤器，开始抓包</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps6.jpg" alt="img"> </p>
<p>（2）在浏览器中登录到教务系统</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps7.jpg" alt="img"> </p>
<p>（3）通过过滤器查找自己感兴趣的数据</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps8.jpg" alt="img"> </p>
<ul>
<li>3.开启电脑IIS</li>
</ul>
<p>（1）在控制面板–程序–启用或关闭Windows功能中开启IIS</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps9.jpg" alt="img"> </p>
<p>（2）在计算机管理中找到IIS服务，新建一个网站，选定好网站的物理路径，并将自己准备好的网站文件放入到该物理路径的文件夹下。</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps10.jpg" alt="img"> </p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps11.jpg" alt="img"> </p>
<p>（3）测试能否访问，在浏览器输入本机IPv4地址：172.19.160.1</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps12.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络实验总结</title>
    <url>/2021/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><div class="tabs" id="基本命令"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#基本命令-1">基本命令</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="基本命令-1"><ul>
<li>回车：进入非特权模式 &gt;</li>
<li>enable: 进入特权模式 Router#</li>
<li>configure terminal: 进入配置状态模式Router(config)#</li>
<li>interface fastEthernet 0/1：进入接口配置状态Router(config-if)#</li>
<li>ip address  202.168.1.254  255.255.255.0：配置接口IP地址</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h1><div class="tabs" id="配置路由器"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#配置路由器-1">静态配置</button></li><li class="tab"><button type="button" data-href="#配置路由器-2">RIP</button></li><li class="tab"><button type="button" data-href="#配置路由器-3">OSPF</button></li><li class="tab"><button type="button" data-href="#配置路由器-4">OSPF+RIP</button></li><li class="tab"><button type="button" data-href="#配置路由器-5">EIGRP</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="配置路由器-1"><ul>
<li><p>静态配置：(config)#ip route &lt;网络号&gt; &lt;掩码&gt; &lt;下一跳&gt;</p>
</li>
<li><p>RIP：</p>
<ul>
<li>(config)#router RIP<br>(config-router)#network 192.168.1.0<br>(config-router)#network 192.168.3.0<br>(config-router)#ver 2<br>(config-router)#no auto-summary</li>
</ul>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-2"><ul>
<li>RIP：<ul>
<li>(config)#router RIP<br>(config-router)#network 192.168.1.0<br>(config-router)#network 192.168.3.0<br>(config-router)#ver 2<br>(config-router)#no auto-summary</li>
</ul>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-3"><ul>
<li>–R3<br> (config)#router OSPF 100        //100是进程ID<br> (config-router)#network  192.168.1.0  0.0.0.255  area  1<br> (config-router)#network  192.168.4.0  0.0.0.255  area  1<br> （特别注意area不要弄错！！！）</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-4"><ul>
<li>在路由器R4上左侧配置RIP V2路由协议；右侧配置OSPF协议<br> —-R4<br> (config) #router ospf 100<br> (config-router) #network 192.168.3.0 0.0.0.255 area 2<br> (config-router) #network 192.168.7.0 0.0.0.255 area 2<br> (config-router) #redistribute rip metric 10 subnets  //将RIP路由重分布给OSPF路由协议<br> (config-router)#exit<br> (config) #router rip<br> (config-router) #network 192.168.7.0<br> (config-router) #ver 2<br> (config-router) #no auto-s<br> (config-router) #redistribute ospf 100 matric 10    //将OSPF路由重分布给RIP路由协议</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-5"><ul>
<li>Router#conf t<br> Router(config)#router eigrp 100                        //启动EIGRP路由协议<br> Router(config-router)#network 202.192.0.0        //宣告直连主类网络号<br> Router(config-router)#network 202.192.1.0</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="NAT地址转换"><a href="#NAT地址转换" class="headerlink" title="NAT地址转换"></a>NAT地址转换</h1><div class="tabs" id="nat地址转换"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#nat地址转换-1">NAT地址转换</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="nat地址转换-1"><ul>
<li>（1）定义NAT设备（路由器）的内外接口<br>  （config）int f0/0<br>  （config-if）ip nat inside<br>  （config）int f0/1<br>  （config-if）ip nat outside </li>
<li>（2）定义NAT地址池<br>  — ip nat pool pool-name start-ip  end-ip netmask 子网掩码<br>  （config）ip nat pool out 202.106.0.4  202.106.0.24 netmask 255.255.255.0  </li>
<li>（3）利用ACL(地址控制列表Address Control List)定义允许转换的本地地址列表<br>  — access-list ACL号 permit  &lt;网段&gt;  &lt;子网掩码反码&gt;<br>  （config）access-list 10 permit 192.168.0.0 0.0.0.255</li>
<li>（4）定义内部本地地址与内部全局地址的转换关系<br>  （config）ip nat inside source list 10 pool out</li>
<li>（5） 配置静态地址转换<br>  （config）ip nat inside source static 192.168.0.1  202.106.0.3<br>  （config）ip nat outside source static 202.106.0.3 192.168.0.1 </li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="FTP服务"><a href="#FTP服务" class="headerlink" title="FTP服务"></a>FTP服务</h1><div class="tabs" id="ftp服务"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ftp服务-1">FTP服务</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ftp服务-1"><ul>
<li>ftp FTP服务器域名</li>
<li>Username：</li>
<li>Password:</li>
<li>dir:查看文件</li>
<li>get 文件名：下载文件</li>
<li>put 文件名：上传文件</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="Telnet远程登录"><a href="#Telnet远程登录" class="headerlink" title="Telnet远程登录"></a>Telnet远程登录</h1><div class="tabs" id="telnet远程登录"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#telnet远程登录-1">Telnet远程登录</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="telnet远程登录-1"><ul>
<li><p>1.配置路由器启动Telnet服务的基本流程<br>（通过配置线连接PC主机RS232和路由器console接口进行配置）</p>
<p>（1）设置“特权模式”使能加密密码：<br>Router(config)#enable secret 123</p>
<p>（2）设置控制台（console配置线）密码：<br>Router(config)#line console 0<br>Router(config-line)#password 456<br>Router(config-line)#login<br>Router(config-line)#exit</p>
<p>（3）设置远程登陆密码：<br>Router(config)#line vty 0 4<br>Router(config-line)#password 789<br>Router(config-line)#login<br>Router(config-line)#exit</p>
</li>
<li><p>2.通过PC主机远程登录到路由器<br>PC&gt;telnet 202.192.0.254<br>Password: 789<br>Router&gt;enable<br>Password: 12<br>Router#</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnGitBranch</title>
    <url>/2021/07/10/LearnGitBranch/</url>
    <content><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="Git-commit-提交"><a href="#Git-commit-提交" class="headerlink" title="Git commit(提交)"></a>Git commit(提交)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210707180217632.png" alt="image-20210707180217632"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180229217.png" alt="image-20210707180229217"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180240632.png" alt="image-20210707180240632"></p>
<h2 id="Git-Branch-分支"><a href="#Git-Branch-分支" class="headerlink" title="Git Branch(分支)"></a>Git Branch(分支)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210707180311964.png" alt="image-20210707180311964"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180321593.png" alt="image-20210707180321593"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180338498.png" alt="image-20210707180338498"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180354850.png" alt="image-20210707180354850"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180409051.png" alt="image-20210707180409051"></p>
<p><font color="red">git checkout -b bugFix</font></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708092926600.png" alt="image-20210708092926600"></p>
<h2 id="Git-Merge-合并1"><a href="#Git-Merge-合并1" class="headerlink" title="Git Merge(合并1)"></a>Git Merge(合并1)</h2><p>把<youBranch>合并到当前分支</youBranch></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180502520.png" alt="image-20210707180502520"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180520116.png" alt="image-20210707180520116"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180535801.png" alt="image-20210707180535801"></p>
<h2 id="Git-Rebase-合并2"><a href="#Git-Rebase-合并2" class="headerlink" title="Git Rebase(合并2)"></a>Git Rebase(合并2)</h2><p>把当前分支里的工作合并（复制）到<youbranch></youbranch></p>
<p>git rebase branch1 branch2：将分支2的提交合并到分支1</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180641790.png" alt="image-20210707180641790"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180657215.png" alt="image-20210707180657215"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180715217.png" alt="image-20210707180715217"></p>
<h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="Git-checkout-在提交树上移动"><a href="#Git-checkout-在提交树上移动" class="headerlink" title="Git checkout(在提交树上移动)"></a>Git checkout(在提交树上移动)</h2><p>HEAD:是对当前提交记录的符号引用</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707181102379.png" alt="image-20210707181102379"></p>
<p>通过指定提交记录哈希值（如C1 C2）的方式在 Git 中移动</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182107038.png" alt="image-20210707182107038"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182131190.png" alt="image-20210707182131190"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182148057.png" alt="image-20210707182148057"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182202895.png" alt="image-20210707182202895"></p>
<h2 id="相对引用1（-）"><a href="#相对引用1（-）" class="headerlink" title="相对引用1（^）"></a>相对引用1（^）</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210707182718057.png" alt="image-20210707182718057"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182755760.png" alt="image-20210707182755760"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182857052.png" alt="image-20210707182857052"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182916539.png" alt="image-20210707182916539"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182947454.png" alt="image-20210707182947454"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707183002457.png" alt="image-20210707183002457"></p>
<h2 id="相对引用2（-）"><a href="#相对引用2（-）" class="headerlink" title="相对引用2（~）"></a>相对引用2（~）</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708094914804.png" alt="image-20210708094914804"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708094927037.png" alt="image-20210708094927037"></p>
<p>强制修改分支位置:git branch -f <yourbranch> <yourdestination></yourdestination></yourbranch></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708094944297.png" alt="image-20210708094944297"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708094957557.png" alt="image-20210708094957557"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708095006899.png" alt="image-20210708095006899"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708095740561.png" alt="image-20210708095740561"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708095752419.png" alt="image-20210708095752419"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -f main c6</span><br><span class="line">git checkout HEAD^</span><br><span class="line">git branch -f bugFix HEAD^</span><br></pre></td></tr></table></figure>



<h2 id="Git-reset-Git-revert-撤销变更"><a href="#Git-reset-Git-revert-撤销变更" class="headerlink" title="Git reset|Git revert(撤销变更)"></a>Git reset|Git revert(撤销变更)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708100028520.png" alt="image-20210708100028520"></p>
<ul>
<li>git Reset:用于本地</li>
</ul>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100107026.png" alt="image-20210708100107026"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100127317.png" alt="image-20210708100127317"></p>
<ul>
<li>git revert:用于远程，将记录的撤销（回退）记录加到当前分支记录</li>
</ul>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100137372.png" alt="image-20210708100137372"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100205219.png" alt="image-20210708100205219"></p>
<h1 id="移动提交记录"><a href="#移动提交记录" class="headerlink" title="移动提交记录"></a>移动提交记录</h1><h2 id="Git-cherry-pick-整理提交记录"><a href="#Git-cherry-pick-整理提交记录" class="headerlink" title="Git cherry-pick(整理提交记录)"></a>Git cherry-pick(整理提交记录)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708101132784.png" alt="image-20210708101132784"></p>
<p>把一些提交号复制到当前位置</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101213736.png" alt="image-20210708101213736"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101302552.png" alt="image-20210708101302552"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101313112.png" alt="image-20210708101313112"></p>
<h2 id="Git-rebase-i-交互式的-rebase"><a href="#Git-rebase-i-交互式的-rebase" class="headerlink" title="Git rebase -i (交互式的 rebase)"></a>Git rebase -i (交互式的 rebase)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708101514919.png" alt="image-20210708101514919"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101619930.png" alt="image-20210708101619930"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101644114.png" alt="image-20210708101644114"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101657579.png" alt="image-20210708101657579"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101750066.png" alt="image-20210708101750066"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101847656.png" alt="image-20210708101847656"></p>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708102217807.png" alt="image-20210708102217807"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708102740387.png" alt="image-20210708102740387"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708102759444.png" alt="image-20210708102759444"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708102807847.png" alt="image-20210708102807847"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line"></span><br><span class="line">git cherry-pick c5 或 git cherry-pick bugFix</span><br></pre></td></tr></table></figure>



<h2 id="提交的技巧-1"><a href="#提交的技巧-1" class="headerlink" title="提交的技巧 #1"></a>提交的技巧 #1</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708103425969.png" alt="image-20210708103425969"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708103558144.png" alt="image-20210708103558144"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708104016852.png" alt="image-20210708104016852"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708104024797.png" alt="image-20210708104024797"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br><span class="line">调整C2 C3</span><br><span class="line">//进行一些小修改</span><br><span class="line">git commit --amend</span><br><span class="line">git rebase -i HEAD~2</span><br><span class="line">调整C2&#x27;&#x27; C3</span><br><span class="line">//将main移动到修改的最前端</span><br><span class="line">git rebase caption main</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/10/LearnGitBranch/image-20210708104217724.png" alt="image-20210708104217724"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105041296.png" alt="image-20210708105041296"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105110953.png" alt="image-20210708105110953"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105235499.png" alt="image-20210708105235499"></p>
<h2 id="提交的技巧-2"><a href="#提交的技巧-2" class="headerlink" title="提交的技巧 #2"></a>提交的技巧 #2</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708105329986.png" alt="image-20210708105329986"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105350522.png" alt="image-20210708105350522"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105409069.png" alt="image-20210708105409069"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105427238.png" alt="image-20210708105427238"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git cherry-pick C2</span><br><span class="line">git commit --amend</span><br><span class="line">git cherry-pick C3</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/10/LearnGitBranch/image-20210708110350766.png" alt="image-20210708110350766"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110400360.png" alt="image-20210708110400360"></p>
<h2 id="Git-Tags"><a href="#Git-Tags" class="headerlink" title="Git Tags"></a>Git Tags</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708110500402.png" alt="image-20210708110500402"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110931071.png" alt="image-20210708110931071"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110943859.png" alt="image-20210708110943859"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110956301.png" alt="image-20210708110956301"></p>
<h2 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708111252981.png" alt="image-20210708111252981"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708111345615.png" alt="image-20210708111345615"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708111406212.png" alt="image-20210708111406212"></p>
<h1 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h1><h2 id="多分支-rebase"><a href="#多分支-rebase" class="headerlink" title="多分支 rebase"></a>多分支 rebase</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708113031307.png" alt="image-20210708113031307"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708113047650.png" alt="image-20210708113047650"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708113057624.png" alt="image-20210708113057624"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase main bugFix</span><br><span class="line">git rebase bugFIx side</span><br><span class="line">git rebase side another</span><br><span class="line">git rebase another main</span><br></pre></td></tr></table></figure>



<h2 id="选择父提交记录"><a href="#选择父提交记录" class="headerlink" title="选择父提交记录"></a>选择父提交记录</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708122019936.png" alt="image-20210708122019936"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122034460.png" alt="image-20210708122034460"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122053452.png" alt="image-20210708122053452"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122106658.png" alt="image-20210708122106658"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122508583.png" alt="image-20210708122508583"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122747166.png" alt="image-20210708122747166"></p>
<p>^num是横向移动；~num是纵向移动</p>
<h2 id="纠缠不清的分支"><a href="#纠缠不清的分支" class="headerlink" title="纠缠不清的分支"></a>纠缠不清的分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708124214014.png" alt="image-20210708124214014"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708125303011.png" alt="image-20210708125303011"><img src="/2021/07/10/LearnGitBranch/image-20210708125313507.png" alt="image-20210708125313507"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick C4 C3 C2</span><br><span class="line">git checkout two</span><br><span class="line">git cherry-pick C5 C4 C3 C2</span><br><span class="line">git branch -f three C2</span><br></pre></td></tr></table></figure>



<h1 id="Push-amp-Pull-——-Git-远程仓库！"><a href="#Push-amp-Pull-——-Git-远程仓库！" class="headerlink" title="Push &amp; Pull —— Git 远程仓库！"></a>Push &amp; Pull —— Git 远程仓库！</h1><h2 id="Git-clone"><a href="#Git-clone" class="headerlink" title="Git clone"></a>Git clone</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708131220533.png" alt="image-20210708131220533"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131436712.png" alt="image-20210708131436712"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131503803.png" alt="image-20210708131503803"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131528770.png" alt="image-20210708131528770"></p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708131730919.png" alt="image-20210708131730919"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131814248.png" alt="image-20210708131814248"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131823958.png" alt="image-20210708131823958"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131851696.png" alt="image-20210708131851696"></p>
<h2 id="Git-Fetch-抓取"><a href="#Git-Fetch-抓取" class="headerlink" title="Git Fetch(抓取)"></a>Git Fetch(抓取)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708132039850.png" alt="image-20210708132039850"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132118768.png" alt="image-20210708132118768"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132146200.png" alt="image-20210708132146200"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132156470.png" alt="image-20210708132156470"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132324194.png" alt="image-20210708132324194"></p>
<h2 id="Git-Pull（拉取-抓取-合并）"><a href="#Git-Pull（拉取-抓取-合并）" class="headerlink" title="Git Pull（拉取=抓取+合并）"></a>Git Pull（拉取=抓取+合并）</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708132614877.png" alt="image-20210708132614877"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132632183.png" alt="image-20210708132632183"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132732130.png" alt="image-20210708132732130"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132745265.png" alt="image-20210708132745265"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132847811.png" alt="image-20210708132847811"></p>
<p>git pull=git fetch + git merge</p>
<h2 id="模拟团队合作"><a href="#模拟团队合作" class="headerlink" title="模拟团队合作"></a>模拟团队合作</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708133042614.png" alt="image-20210708133042614"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133055142.png" alt="image-20210708133055142"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133104029.png" alt="image-20210708133104029"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133141450.png" alt="image-20210708133141450"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133506924.png" alt="image-20210708133506924"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133517625.png" alt="image-20210708133517625"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone</span><br><span class="line">git fakeTeamwork 2 </span><br><span class="line">git commit </span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>



<h2 id="Git-Push-推送"><a href="#Git-Push-推送" class="headerlink" title="Git Push(推送)"></a>Git Push(推送)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708133828791.png" alt="image-20210708133828791"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133844106.png" alt="image-20210708133844106"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133914152.png" alt="image-20210708133914152"></p>
<h2 id="偏离的工作"><a href="#偏离的工作" class="headerlink" title="偏离的工作"></a>偏离的工作</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708134026480.png" alt="image-20210708134026480"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134033083.png" alt="image-20210708134033083"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134200396.png" alt="image-20210708134200396"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134240816.png" alt="image-20210708134240816"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134253823.png" alt="image-20210708134253823"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134308393.png" alt="image-20210708134308393"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134516265.png" alt="image-20210708134516265"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134544127.png" alt="image-20210708134544127"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134640963.png" alt="image-20210708134640963"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134741663.png" alt="image-20210708134741663"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134812644.png" alt="image-20210708134812644"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134828932.png" alt="image-20210708134828932"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708135720602.png" alt="image-20210708135720602"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull = git fetch + git merge</span><br><span class="line"></span><br><span class="line">git pull --rebase = git fetch + git rebase</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/10/LearnGitBranch/image-20210708140648399.png" alt="image-20210708140648399"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708140710442.png" alt="image-20210708140710442"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708140725614.png" alt="image-20210708140725614"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141024342.png" alt="image-20210708141024342"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141038183.png" alt="image-20210708141038183"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fake&#x27; Teamwork</span><br><span class="line">objective</span><br><span class="line">git commit</span><br><span class="line">git pull --rebase</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h2 id="远程服务器拒绝-Remote-Rejected"><a href="#远程服务器拒绝-Remote-Rejected" class="headerlink" title="远程服务器拒绝!(Remote Rejected)"></a>远程服务器拒绝!(Remote Rejected)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708141215295.png" alt="image-20210708141215295"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141250110.png" alt="image-20210708141250110"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141325847.png" alt="image-20210708141325847"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142008765.png" alt="image-20210708142008765"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142015998.png" alt="image-20210708142015998"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard o/main</span><br><span class="line">➊在本程序中默认的行为是--hard 硬重置，可</span><br><span class="line">以尽情省略掉那个选项以避免麻烦!但是要记录</span><br><span class="line">Git中默认的是--mixed。</span><br><span class="line">$ git checkout -b feature C2</span><br><span class="line">$ git push origin feature</span><br><span class="line">0 local branch &quot;feature&quot; set to track</span><br><span class="line">remote branch &quot;o/ feature&quot;</span><br></pre></td></tr></table></figure>



<h1 id="关于-origin-和它的周边-——-Git-远程仓库高级操作"><a href="#关于-origin-和它的周边-——-Git-远程仓库高级操作" class="headerlink" title="关于 origin 和它的周边 —— Git 远程仓库高级操作"></a>关于 origin 和它的周边 —— Git 远程仓库高级操作</h1><h2 id="合并特性分支"><a href="#合并特性分支" class="headerlink" title="合并特性分支"></a>合并特性分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708142416567.png" alt="image-20210708142416567"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142507101.png" alt="image-20210708142507101"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142610921.png" alt="image-20210708142610921"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142622769.png" alt="image-20210708142622769"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708143546325.png" alt="image-20210708143546325"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708143555630.png" alt="image-20210708143555630"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git rebase o/main side1</span><br><span class="line">$ git rebase side1 side2</span><br><span class="line">$ git rebase side2 side3</span><br><span class="line">$ git rebase side3 main</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>



<h2 id="合并远程仓库"><a href="#合并远程仓库" class="headerlink" title="合并远程仓库"></a>合并远程仓库</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708144023265.png" alt="image-20210708144023265"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144057908.png" alt="image-20210708144057908"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144131116.png" alt="image-20210708144131116"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144802230.png" alt="image-20210708144802230"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144811391.png" alt="image-20210708144811391"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull</span><br><span class="line">git merge side1</span><br><span class="line">git merge side2</span><br><span class="line">git merge side3</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h2 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708145247050.png" alt="image-20210708145247050"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145254765.png" alt="image-20210708145254765"></p>
<h3 id="1-git-checkout-b-foo-o-main"><a href="#1-git-checkout-b-foo-o-main" class="headerlink" title="1. git checkout -b foo o/main"></a>1. git checkout -b foo o/main</h3><p><img src="/2021/07/10/LearnGitBranch/image-20210708145407891.png" alt="image-20210708145407891"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145459743.png" alt="image-20210708145459743"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145531527.png" alt="image-20210708145531527"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145546365.png" alt="image-20210708145546365"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145612482.png" alt="image-20210708145612482"></p>
<h3 id="2-git-branch-u-o-main-foo"><a href="#2-git-branch-u-o-main-foo" class="headerlink" title="2.git branch -u o/main foo"></a>2.git branch -u o/main foo</h3><p><img src="/2021/07/10/LearnGitBranch/image-20210708145630700.png" alt="image-20210708145630700"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145825968.png" alt="image-20210708145825968"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708150403153.png" alt="image-20210708150403153"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708150412005.png" alt="image-20210708150412005"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b side o/main</span><br><span class="line">git commit</span><br><span class="line">git pull --rebase</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h2 id="Git-Push-的参数"><a href="#Git-Push-的参数" class="headerlink" title="Git Push 的参数"></a>Git Push 的参数</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708150947720.png" alt="image-20210708150947720"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151031205.png" alt="image-20210708151031205"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151130836.png" alt="image-20210708151130836"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151209286.png" alt="image-20210708151209286"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151219562.png" alt="image-20210708151219562"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151234915.png" alt="image-20210708151234915"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151308955.png" alt="image-20210708151308955"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151359962.png" alt="image-20210708151359962"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151407109.png" alt="image-20210708151407109"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin main</span><br><span class="line">git push origin foo</span><br></pre></td></tr></table></figure>



<h2 id="lt-place-gt-参数详解"><a href="#lt-place-gt-参数详解" class="headerlink" title="&lt;place&gt;参数详解"></a><code>&lt;place&gt;</code>参数详解</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708151517814.png" alt="image-20210708151517814"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151558370.png" alt="image-20210708151558370"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151630372.png" alt="image-20210708151630372"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151713402.png" alt="image-20210708151713402"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151724079.png" alt="image-20210708151724079"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152005397.png" alt="image-20210708152005397"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152017612.png" alt="image-20210708152017612"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin main^:foo</span><br><span class="line">git push origin foo:main</span><br></pre></td></tr></table></figure>



<h2 id="Git-fetch-的参数"><a href="#Git-fetch-的参数" class="headerlink" title="Git fetch 的参数"></a>Git fetch 的参数</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708152517963.png" alt="image-20210708152517963"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152526401.png" alt="image-20210708152526401"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152550967.png" alt="image-20210708152550967"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152623538.png" alt="image-20210708152623538"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152648161.png" alt="image-20210708152648161"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152724640.png" alt="image-20210708152724640"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152754538.png" alt="image-20210708152754538"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152807081.png" alt="image-20210708152807081"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152821953.png" alt="image-20210708152821953"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152832652.png" alt="image-20210708152832652"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152844370.png" alt="image-20210708152844370"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152855544.png" alt="image-20210708152855544"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708153609012.png" alt="image-20210708153609012"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708153618871.png" alt="image-20210708153618871"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin main~1:foo</span><br><span class="line">git fetch origin foo:main</span><br><span class="line">git checkout foo</span><br><span class="line">git merge main</span><br></pre></td></tr></table></figure>



<h2 id="古怪的-lt-source-gt"><a href="#古怪的-lt-source-gt" class="headerlink" title="古怪的 &lt;source&gt;"></a>古怪的 <code>&lt;source&gt;</code></h2><p> <img src="/2021/07/10/LearnGitBranch/image-20210708154016519.png" alt="image-20210708154016519"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154055142.png" alt="image-20210708154055142"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154118967.png" alt="image-20210708154118967"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154128060.png" alt="image-20210708154128060"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154143579.png" alt="image-20210708154143579"></p>
<h2 id="Git-pull-参数"><a href="#Git-pull-参数" class="headerlink" title="Git pull 参数"></a>Git pull 参数</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708154252617.png" alt="image-20210708154252617"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154310504.png" alt="image-20210708154310504"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154322563.png" alt="image-20210708154322563"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154340066.png" alt="image-20210708154340066"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154417895.png" alt="image-20210708154417895"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154431000.png" alt="image-20210708154431000"></p>
]]></content>
      <categories>
        <category>《Git》</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>图解</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础篇</title>
    <url>/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​        数据库是一个按<font color="red">数据结构</font>来存储和管理数据的计算机软件系统。数据库的概念实际包括两层意思：</p>
<p>​    （1）数据库是一个实体，它是能够合理保管数据的“仓库”，用户在该“仓库”中存放要管理的事务数据，“数据”和“库”两个概念结合成为数据库。</p>
<p>​    （2）数据库是数据管理的新方法和技术，它能更合适的组织数据、更方便的维护数据、更严密的控制数据和更有效的利用数据。</p>
<h3 id="2-数据库管理系统"><a href="#2-数据库管理系统" class="headerlink" title="2.数据库管理系统"></a>2.数据库管理系统</h3><p>​        数据库管理系统是数据库系统的核心组成部分，主要完成对数据库的操作与管理功能，实现数据库对象的创建、数据库存储数据的<font color="red">（CRUD）查询、添加、修改与删除</font>操作和数据库的用户管理、权限管理等。它的安全直接关系到整个数据库系统的安全。</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210715161617639-1626619077152.png" alt="image-20210715161617639"></p>
<h3 id="3-关系型数据库-VS-非关系型数据库（NoSQL）"><a href="#3-关系型数据库-VS-非关系型数据库（NoSQL）" class="headerlink" title="3.关系型数据库 VS 非关系型数据库（NoSQL）"></a>3.关系型数据库 VS 非关系型数据库（NoSQL）</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">关系型数据库</th>
<th align="center">非关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td align="center">举例</td>
<td align="center">Mysql、SqlServer</td>
<td align="center">Redis、Memcache、MongoDB</td>
</tr>
<tr>
<td align="center">语言</td>
<td align="center">SQL</td>
<td align="center">没有统一标准</td>
</tr>
<tr>
<td align="center">存储方式</td>
<td align="center">行列表</td>
<td align="center">键值对、图、文档等</td>
</tr>
<tr>
<td align="center">存储结构</td>
<td align="center">结构化</td>
<td align="center">动态结构</td>
</tr>
<tr>
<td align="center">扩展方式</td>
<td align="center">纵向扩展能力</td>
<td align="center">横向扩展能力</td>
</tr>
</tbody></table>
<h3 id="4-结构化查询语言SQL"><a href="#4-结构化查询语言SQL" class="headerlink" title="4.结构化查询语言SQL"></a>4.结构化查询语言SQL</h3><ul>
<li><p>专门用来和数据库通信的语言</p>
</li>
<li><p>优点</p>
<ul>
<li>不是特定数据库提供商专有的，几乎所有的DBMS都支持SQL</li>
<li>简单易学</li>
<li>使用灵活</li>
</ul>
</li>
<li><p>类型</p>
<ul>
<li><p>DML（Data Manipulation Language):数据<font color="red">操纵</font>语句，用于CRUD数据库记录，并检查数据完整性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>：	添加数据到数据库中</span><br><span class="line">UPDATE：	修改数据库中的数据</span><br><span class="line"><span class="keyword">DELETE</span>：	删除数据库中的数据</span><br><span class="line"><span class="keyword">SELECT</span>：	选择（查询）数据</span><br></pre></td></tr></table></figure></li>
<li><p>DDL（Data Definition Language):数据<font color="red">定义</font>语句，用于库和表的创建、修改、删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>：创建数据库表</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>：更改表结构、添加、删除、修改列长度</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>：删除表</span><br><span class="line"><span class="keyword">CREATE</span> INDEX：在表上建立索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX：删除索引</span><br></pre></td></tr></table></figure></li>
<li><p>DCL（Data Control Language):数据<font color="red">控制</font>语句，用于定义用户的访问权限和安全级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>：授予访问权限</span><br><span class="line"><span class="keyword">REVOKE</span>：撤销访问权限</span><br><span class="line"><span class="keyword">COMMIT</span>：提交事务处理</span><br><span class="line"><span class="keyword">ROLLBACK</span>：事务处理回退</span><br><span class="line"><span class="keyword">SAVEPOINT</span>：设置保存点</span><br><span class="line">LOCK：对数据库的特定部分进行锁定</span><br></pre></td></tr></table></figure></li>
<li><p>TCL（Transaction Control Language）：<font color="red">事务控制</font>font&gt;语言</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>	事务提交</span><br><span class="line"><span class="keyword">rollback</span> 事务回滚</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716155635092-1626619077153.png" alt="image-20210716155635092"></p>
<h3 id="1-介绍与安装"><a href="#1-介绍与安装" class="headerlink" title="1.介绍与安装"></a>1.介绍与安装</h3><p>MySQL是一款流行的开源数据库。它也是一个关系型数据库管理系统，2008年，mysql被sun公司收购，2009年sun公司被oracle公司收购，自此两个主流的数据库都归Oracle公司收购。</p>
<ul>
<li><p>MySQL的主要优势如下：</p>
<ol>
<li>运行速度快。mysql 体积小，命令执行速度快。</li>
<li>使用成本低。mysql是开源的，且提供免费版本，对大多数用户来说大大降低了使用成本。</li>
<li>容易使用。与其他大型数据库的设置和管理相比，其复杂程度较低，易于使用。</li>
<li>可移植性。MySQL 能够运行于多种系统平台上，如window，linux，unix等。</li>
<li>适用更多用户。mysql支持最常用的数据管理功能，适用于中小型企业甚至大型</li>
</ol>
</li>
<li><p>[安装]: <a href="https://blog.csdn.net/qq_38269362/article/details/107283338">https://blog.csdn.net/qq_38269362/article/details/107283338</a></p>
</li>
</ul>
<h3 id="2-MySQL服务的启动和停止"><a href="#2-MySQL服务的启动和停止" class="headerlink" title="2.MySQL服务的启动和停止"></a>2.MySQL服务的启动和停止</h3><p>所谓MySQL服务是指一系列关于MySQL软件的后台进程，只有启动了MySQL服务才能对mysql软件进行操作。</p>
<ul>
<li><p>方式一：右击计算机图标，在’管理’命令中打开计算机管理,选择服务和应用程序，点击服务节点。选择MySQL。</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716143306352-1626619077153.png" alt="image-20210716143306352"></p>
</li>
<li><p>方式二：通过dos窗口命令行（管理员身份运行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br><span class="line">net stop mysql</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-MySQL服务的登录和退出"><a href="#3-MySQL服务的登录和退出" class="headerlink" title="3.MySQL服务的登录和退出"></a>3.MySQL服务的登录和退出</h3><ul>
<li><p>方式一：通过mysql自带的客户端（MySQL 5.5 Command Line Client 仅限于root用户）</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716144530148-1626619077153.png" alt="image-20210716144530148"></p>
</li>
<li><p>方式二：通过Windows自带的客户端</p>
<ul>
<li><p>登录：<font color="red">mysql 【-h 主机名 -P 端口号 】-u 用户名 -p【密码】</font></p>
</li>
<li><p>退出：<font color="red">exit 或ctrl+C</font></p>
</li>
</ul>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716145007179-1626619077153.png" alt="image-20210716145007179"></p>
</li>
</ul>
<h3 id="4-MySQL常见命令"><a href="#4-MySQL常见命令" class="headerlink" title="4.MySQL常见命令"></a>4.MySQL常见命令</h3><p>​    注：sql命令以分号结尾</p>
<ul>
<li><h4 id="查看当前所有的数据库"><a href="#查看当前所有的数据库" class="headerlink" title="查看当前所有的数据库"></a>查看当前所有的数据库</h4><p><font color="red">show databases;</font></p>
</li>
<li><h4 id="打开指定的库"><a href="#打开指定的库" class="headerlink" title="打开指定的库"></a>打开指定的库</h4><p><font color="red">use 库名;</font></p>
</li>
<li><h4 id="查看当前库的所有表"><a href="#查看当前库的所有表" class="headerlink" title="查看当前库的所有表"></a>查看当前库的所有表</h4><p><font color="red">show tables;</font></p>
</li>
<li><h4 id="查看其它库的所有表"><a href="#查看其它库的所有表" class="headerlink" title="查看其它库的所有表"></a>查看其它库的所有表</h4><p><font color="red">show tables from 库名;</font></p>
</li>
<li><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p><font color="red">create table 表名(</font></p>
<p><font color="red">列名 列类型,</font><br><font color="red">列名 列类型，</font><br><font color="red">…    …);&lt;/</font></p>
</li>
<li><h4 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h4><p><font color="red">desc 表名;</font>font&gt;</p>
</li>
<li><h4 id="查看sql服务器版本"><a href="#查看sql服务器版本" class="headerlink" title="查看sql服务器版本"></a>查看sql服务器版本</h4><ul>
<li>sql命令:select version();</li>
<li>dos命令:mysql –version 或 mysql –V</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看当前所有数据库</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#打开指定数据库</span><br><span class="line">mysql<span class="operator">&gt;</span> use information_schema;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">#查看当前库中所有表</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_information_schema          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> CHARACTER_SETS                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> COLLATIONS                            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> COLLATION_CHARACTER_SET_APPLICABILITY <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> COLUMNS                               <span class="operator">|</span></span><br><span class="line">......</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="number">37</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#查看指定库中所有表</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables <span class="keyword">from</span> mysql;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_mysql           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> columns_priv              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> db                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> event                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> func                      <span class="operator">|</span></span><br><span class="line">......</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">24</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.06</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use test;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#在当前库创建表</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> stu_info(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="type">int</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> name <span class="type">varchar</span>(<span class="number">20</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_test <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> stu_info       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#查看指定表的表结构</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">#查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">#插入</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> stu_info (id,name) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;zlx&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> stu_info (id,name) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;zzx&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> frome stu_info;</span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;frome stu_info&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> zzx  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">mysql<span class="operator">&gt;</span> update stu_info <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;lili&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> lili <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> stu_info <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> version();</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> version() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5.5</span><span class="number">.15</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> exit</span><br><span class="line">Bye</span><br><span class="line"></span><br><span class="line">C:\Windows\system32<span class="operator">&gt;</span>mysql <span class="comment">--version</span></span><br><span class="line">mysql  Ver <span class="number">14.14</span> Distrib <span class="number">5.5</span><span class="number">.15</span>, <span class="keyword">for</span> Win32 (x86)</span><br></pre></td></tr></table></figure>



<h3 id="5-MySQL语法规范"><a href="#5-MySQL语法规范" class="headerlink" title="5.MySQL语法规范"></a>5.MySQL语法规范</h3><ul>
<li>1.不区分大小写,但建议关键字大写，表名、列名小写</li>
<li>2.每条命令最好用分号结尾（\g也可以）<br>3.每条命令根据需要，可以进行缩进 或换行（建议关键字单独一行）</li>
<li>4.注释<pre><code>单行注释：#注释文字
  单行注释：-- 注释文字
  多行注释：/* 注释文字  */
</code></pre>
</li>
</ul>
<h2 id="DQL语言"><a href="#DQL语言" class="headerlink" title="DQL语言"></a>DQL语言</h2><p>数据库结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(myemployees) --&gt;B[departments]</span><br><span class="line">  A --&gt; C[employees]</span><br><span class="line">  A --&gt; D[jobs]</span><br><span class="line">  A --&gt; E[locations]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h3><ul>
<li><font color="red">select  要查询的字段|表达式|常量值|函数  from  表名;</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语法：select 要查询的字段|表达式|常量值|函数 from 表名;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#(<span class="number">1</span>)查询表中单个字段</span><br><span class="line"><span class="keyword">SELECT</span> `last_name` <span class="keyword">FROM</span> employees ;</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)查询表中多个字段</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  `last_name`,</span><br><span class="line">  `salary`,</span><br><span class="line">  `email` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">#(<span class="number">3</span>)查询所有字段 </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#(<span class="number">4</span>)查询常量值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">#(<span class="number">5</span>)查询表达式</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">%</span><span class="number">98</span></span><br><span class="line"></span><br><span class="line">#(<span class="number">6</span>)查询函数</span><br><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"></span><br><span class="line">#(<span class="number">7</span>)为字段起别名</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-便于理解</span></span><br><span class="line"><span class="comment">-如果要查询的字段有重名的情况，使用别名可以区分开来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#方式<span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">%</span><span class="number">98</span> <span class="keyword">AS</span> 结果</span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> 姓,first_name <span class="keyword">AS</span> 名 <span class="keyword">FROM</span> employees</span><br><span class="line">#方式<span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name 姓, first_name 名 <span class="keyword">FROM</span> employees</span><br><span class="line">#别名中含特殊符号(用双引号)</span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">AS</span> &quot;out put&quot; <span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#(<span class="number">8</span>)去重(关键字：<span class="keyword">distinct</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#（<span class="number">9</span>）<span class="operator">+</span>号的作用</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">select 100+90;两个操作数都为数值型，则做加法运算</span></span><br><span class="line"><span class="comment">其中一方为字符型，试图将字符型转换为数值型</span></span><br><span class="line"><span class="comment">select &#x27;100&#x27;+90;	=190</span></span><br><span class="line"><span class="comment">select &#x27;John&#x27;+90;	=0+90=90</span></span><br><span class="line"><span class="comment">select null+90;只要其中一方为null,则结果肯定为null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#(<span class="number">10</span>)拼接(关键字：concat)</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(last_name,first_name) <span class="keyword">AS</span> 姓名 <span class="keyword">FROM</span> employees</span><br></pre></td></tr></table></figure>



<h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h3><ul>
<li><p><font color="red">语法：select  查询字段  from  表名  while 筛选条件;  </font></p>
</li>
<li><p>条件表达式：&gt;  &lt;  &gt;=  &lt;=  =  !=  &lt;&gt;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按条件表达式筛选</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例一：查询工资<span class="operator">&gt;</span><span class="number">12000</span>的员工信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	salary<span class="operator">&gt;</span><span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line">#案例二：查询部门编号不等于<span class="number">90</span>的员工名和部门编号</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	department_id</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	department_id<span class="operator">&lt;&gt;</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>逻辑表达式：</p>
<ul>
<li><p>and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false</p>
</li>
<li><p>or(||)：两个条件只要有一个成立，结果为true，否则为false</p>
</li>
<li><p>not(!)：如果条件成立，则not后为false，否则为true</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按逻辑表达式筛选</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例一：查询工资在<span class="number">10000</span>到<span class="number">20000</span>之间的员工名、工资以及奖金</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span> 	</span><br><span class="line">	salary<span class="operator">&gt;=</span><span class="number">10000</span> <span class="keyword">AND</span> salary<span class="operator">&lt;=</span><span class="number">20000</span>;</span><br><span class="line">	</span><br><span class="line">#案例二：查询部门编号不是在<span class="number">90</span>到<span class="number">110</span>之间，或者工资高于<span class="number">15000</span>的员工信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">NOT</span>(department_id<span class="operator">&gt;=</span><span class="number">90</span> <span class="keyword">AND</span> department_id<span class="operator">&lt;=</span><span class="number">110</span>) <span class="keyword">OR</span> salary<span class="operator">&gt;</span><span class="number">15000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>模糊查询：</p>
<ul>
<li><p>like</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">-------like</span></span><br><span class="line">#案例一：查询员工名字以s开头的员工信息（通配符：<span class="operator">%</span>任意多个字符，_任意单个字符）</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	last_name <span class="keyword">LIKE</span> <span class="string">&#x27;s%&#x27;</span></span><br><span class="line"></span><br><span class="line">#案例二：查询员工名字中第三个字符为i,第四个字符为e的员工名和工资</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	last_name <span class="keyword">LIKE</span> <span class="string">&#x27;__i_e%&#x27;</span> </span><br><span class="line">	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">转义字符 \</span></span><br><span class="line"><span class="comment">自定义转义字符 &#x27;$&#x27; ESCAPE &#x27;$&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>between and</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">--------between and（可以替换 &lt;  and  &gt;）</span></span><br><span class="line">#案例：查询员工号在<span class="number">100</span>到<span class="number">120</span>之间的员工信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	employee_id <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">120</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>in</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">------in（可以替换 = or = or = ……）</span></span><br><span class="line">#案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个的员工名和工种编号</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	job_id<span class="operator">=</span><span class="string">&#x27;IT_PROG&#x27;</span> <span class="keyword">OR</span> job_id<span class="operator">=</span><span class="string">&#x27;AD_VP&#x27;</span> <span class="keyword">OR</span> job_id<span class="operator">=</span><span class="string">&#x27;AD_PRES&#x27;</span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	job_id <span class="keyword">IN</span> (<span class="string">&#x27;IT_PROG&#x27;</span>,<span class="string">&#x27;AD_VP&#x27;</span>,<span class="string">&#x27;AD_PRES&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>is null | is not null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">----is （not）null</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断null值不能用 = 和 &lt;&gt;,而要用 is 和 is not</span></span><br><span class="line"><span class="comment">也可以用安全等于 &lt;=&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例一：查询没有奖金的员工名和奖金率</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span></span><br><span class="line">	</span><br><span class="line">#案例二：查询有奖金的员工名和奖金率</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">	</span><br><span class="line">#案例三：查询员工号为<span class="number">176</span>的姓名、部门号和年薪</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">年薪=salary*12*(1+年薪率)</span></span><br><span class="line"><span class="comment">年薪率可能为NULL，为NULL时当作0</span></span><br><span class="line"><span class="comment">年薪=salary*12*(1+IFNULL(commission_pct,0))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	department_id,</span><br><span class="line">	salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">AS</span> 年薪</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3.排序查询"></a>3.排序查询</h3><ul>
<li><p><font color="red">语法：select  要查询的东西  from  表 【where 条件】 order by 排序的字段|表达式|别名|函数 【asc|desc】</font>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语法:</span></span><br><span class="line"><span class="comment">select 要查询的东西</span></span><br><span class="line"><span class="comment">from 表</span></span><br><span class="line"><span class="comment">【where 条件】</span></span><br><span class="line"><span class="comment">order by 排序的字段|表达式|别名|函数 【asc|desc】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#案例一：查询员工信息，要求按工资从高到低排序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">#案例二：查询部门编号<span class="operator">&gt;=</span><span class="number">90</span>的员工信息，按入职时间的先后排序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&gt;=</span> <span class="number">90</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hiredate <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">#案例三：按年薪高低显示员工的信息和年薪【按表达式<span class="operator">|</span>别名排序】</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#案例四：按姓名的长度显示员工信姓名和工资【按函数排序】</span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(last_name) 姓名长度,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> LENGTH(last_name) <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#案例五：查询员工信息，要求先按工资升序排序，如果工资相同，再按员工编号降序排序【按多个字段排序】</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>,employee_id <span class="keyword">DESC</span>;			</span><br></pre></td></tr></table></figure>

<p>​                       </p>
</li>
</ul>
<h3 id="4-单行函数"><a href="#4-单行函数" class="headerlink" title="4.单行函数"></a>4.单行函数</h3><ul>
<li>字符函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#(<span class="number">1</span>)length()：获取参数值的字节个数(汉字占<span class="number">3</span>个字节)</span><br><span class="line"><span class="keyword">select</span> length(<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> length(<span class="string">&#x27;张三丰&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)concat():拼接字符串</span><br><span class="line"><span class="keyword">select</span> concat(last_name,<span class="string">&#x27;_&#x27;</span>,first_name) <span class="keyword">from</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">3</span>)<span class="built_in">upper</span>()、<span class="built_in">lower</span>():转换为大<span class="operator">/</span>小写</span><br><span class="line"><span class="keyword">select</span> concat(<span class="built_in">upper</span>(last_name),<span class="built_in">lower</span>(first_name)) 姓名 <span class="keyword">from</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">4</span>)substr():截取字符串	注意：索引从<span class="number">1</span>开始</span><br><span class="line">#<span class="comment">--截取从指定索引处开始后面所有字符</span></span><br><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;李莫愁爱上了陆展元&#x27;</span>,<span class="number">7</span>) output;</span><br><span class="line"></span><br><span class="line">#<span class="comment">--截取从指定索引处开始指定长度字符</span></span><br><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;李莫愁爱上了陆展元&#x27;</span>,<span class="number">1</span>,<span class="number">3</span>) output;</span><br><span class="line"></span><br><span class="line">#案例：姓名中首字符大写，其他字符小写，用—连接，显示处理</span><br><span class="line"><span class="keyword">select</span> concat(<span class="built_in">upper</span>(substr(last_name,<span class="number">1</span>,<span class="number">1</span>)),substr(last_name,<span class="number">2</span>),<span class="string">&#x27;-&#x27;</span>,<span class="built_in">lower</span>(first_name))</span><br><span class="line"><span class="keyword">as</span> 姓名 <span class="keyword">from</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">5</span>)instr():返回字串第一次出现的索引，如果找不到则返回<span class="number">0</span></span><br><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;杨不悔爱上了殷六侠&#x27;</span>,<span class="string">&#x27;爱上&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">6</span>)<span class="built_in">trim</span>():去除字符串前后空格或指定字符</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27;     张翠山     &#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;aaaaaaa张aaa翠山aaaaa&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">7</span>)lpad():用指定字符串左填充到指定长度</span><br><span class="line"><span class="keyword">select</span> lpad(<span class="string">&#x27;殷素素&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;&amp;&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">8</span>)rpad():用指定字符串右填充到指定长度</span><br><span class="line"><span class="keyword">select</span> rpad(<span class="string">&#x27;殷素素&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;$&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">9</span>)replace():替换字符串</span><br><span class="line"><span class="keyword">select</span> replace(<span class="string">&#x27;张无忌爱上了周芷若周芷若&#x27;</span>,<span class="string">&#x27;周芷若&#x27;</span>,<span class="string">&#x27;赵敏&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>数学函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#(<span class="number">1</span>)round:四舍五入</span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.55</span>);</span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.235</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)ceil:向上取整,返回<span class="operator">&gt;=</span>该参数的最小整数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">-2.1</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">3</span>)floor:向下取整，返回<span class="operator">&lt;=</span>该参数的最大整</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">-9.99</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">4</span>)<span class="keyword">truncate</span>:截断</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">-1.2234</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">5</span>)mod:取余函数</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">取余原理：</span></span><br><span class="line"><span class="comment">mod(a,b):= a-(a/b)*b</span></span><br><span class="line"><span class="comment">mod(-10,-3)=-10-(-10/-3)*(-3)=-10-(-9)=-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">10</span>,<span class="number">-3</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>日期函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#now 返回当前系统日期<span class="operator">+</span>时间</span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"></span><br><span class="line">#curdate 返回当前日期</span><br><span class="line"><span class="keyword">SELECT</span> CURDATE();</span><br><span class="line"></span><br><span class="line">#curtime 返回当前时间</span><br><span class="line"><span class="keyword">SELECT</span> CURTIME();</span><br><span class="line"></span><br><span class="line">#获取指定部分的年、月、日、小时、分、秒</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW()) 年;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="string">&#x27;1999-10-10&#x27;</span>) 年;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(NOW()) 月;</span><br><span class="line"><span class="keyword">SELECT</span> MONTHNAME(NOW()) 月名;</span><br><span class="line"></span><br><span class="line">#将字符串转换为日期</span><br><span class="line"><span class="keyword">SELECT</span> STR_TO_DATE(<span class="string">&#x27;3-3-1999&#x27;</span>,<span class="string">&#x27;%c-%d-%Y&#x27;</span>) <span class="keyword">AS</span> out_put</span><br><span class="line"></span><br><span class="line">#将日期转换为字符</span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(hiredate,<span class="string">&#x27;%m月/%d日 %y年&#x27;</span>) <span class="keyword">AS</span> out_put</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>流程控制函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#(<span class="number">1</span>)if函数：if <span class="keyword">else</span> 效果</span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">10</span><span class="operator">&lt;</span><span class="number">5</span>,<span class="string">&#x27;小&#x27;</span>,<span class="string">&#x27;大&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct,</span><br><span class="line">	IF(commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span>,<span class="string">&#x27;没有奖金&#x27;</span>,<span class="string">&#x27;有奖金&#x27;</span>) <span class="keyword">AS</span> 备注</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)<span class="keyword">case</span>函数：作为一个新字段，与前面字段用逗号隔开</span><br><span class="line">#<span class="comment">--switch case的效果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">case 要判断的表达式</span></span><br><span class="line"><span class="comment">when 常量1 then 要显示的值1或语句1；</span></span><br><span class="line"><span class="comment">when 常量2 then 要显示的值2或语句2；</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">else 要显示的值n或语句n;</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="comment">部门号=30，显示工资1.1倍</span></span><br><span class="line"><span class="comment">部门号=40，显示工资1.2倍</span></span><br><span class="line"><span class="comment">部门号=50，显示工资1.3倍</span></span><br><span class="line"><span class="comment">其他部门，显示原工资</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">AS</span> 原始工资,department_id,</span><br><span class="line"><span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">30</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">40</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">50</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.3</span></span><br><span class="line"><span class="keyword">ELSE</span> salary</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">AS</span> 新工资</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="comment">--多重if的效果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">case </span></span><br><span class="line"><span class="comment">when 表达式1 then 要显示的值1或语句1；</span></span><br><span class="line"><span class="comment">when 表达式2 then 要显示的值2或语句2；</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">else 要显示的值n或语句n;</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例：查询工资级别，要求</span></span><br><span class="line"><span class="comment">工资&gt;20000,显示A级别</span></span><br><span class="line"><span class="comment">工资&gt;15000，显示B级别</span></span><br><span class="line"><span class="comment">工资&lt;15000,显示C级别</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,</span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">20000</span> <span class="keyword">THEN</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> 工资级别</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br></pre></td></tr></table></figure>



<h3 id="5-分组函数"><a href="#5-分组函数" class="headerlink" title="5.分组函数"></a>5.分组函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：做统计使用，又称为聚合函数、统计函数或组函数</span></span><br><span class="line"><span class="comment">sum 求和、avg 平均值、max 最大值、min 最小值、count 计算个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#<span class="number">1.</span>简单使用</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">AS</span> 工资总和 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> 最高工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) <span class="keyword">AS</span> 最低工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> 平均工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(salary) <span class="keyword">AS</span> 有工资的人数 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary)<span class="operator">/</span><span class="built_in">COUNT</span>(salary) <span class="keyword">AS</span> 平均工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>参数支持那些类型</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sum,avg 一般处理数值型；</span></span><br><span class="line"><span class="comment">max,min,count 可以处理任何类型；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(last_name),<span class="built_in">AVG</span>(last_name) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(last_name),<span class="built_in">MIN</span>(last_name) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>以上分组函数都忽略<span class="keyword">null</span>值；</span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="built_in">COUNT</span>(commission_pct)<span class="operator">-</span><span class="built_in">COUNT</span>(salary)<span class="operator">&lt;&gt;</span><span class="number">0</span>,<span class="string">&#x27;不相等&#x27;</span>,<span class="string">&#x27;相等&#x27;</span>) </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span>和<span class="keyword">distinct</span>搭配</span><br><span class="line">#查看有几种工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> salary) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">5.</span>count函数的详细介绍</span><br><span class="line">#统计表的行数（不忽略<span class="keyword">null</span>值）</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> employees;	#除了<span class="number">1</span>可以是任意常量值</span><br><span class="line"></span><br><span class="line">#<span class="number">6.</span>和分组函数一同查询的字段要求是<span class="keyword">group</span> <span class="keyword">by</span>后的字段</span><br></pre></td></tr></table></figure>

<p>​        </p>
<h3 id="6-分组查询"><a href="#6-分组查询" class="headerlink" title="6.分组查询"></a>6.分组查询</h3><ul>
<li><p>语法：</p>
<p> <font color="red">select column,group_function(column)</font><br> <font color="red">from table</font></p>
<pre><code>       &lt;font color=&#39;red&#39;&gt; [where condition]&lt;/font&gt;
        &lt;font color=&#39;red&#39;&gt;[group by group_by_expression]&lt;/font&gt;
     &lt;font color=&#39;red&#39;&gt;[order by column]&lt;/font&gt;
        &lt;font color=&#39;red&#39;&gt;[having condition]&lt;/font&gt; 
</code></pre>
</li>
<li><p>tip:</p>
<ul>
<li>查询列表比较特殊，要求是分组函数和group by后出现的字段(每个…)；</li>
<li>先按照where筛选条件进行分组，然后根据分组函数查询对应的值,最后进行having筛选</li>
</ul>
</li>
<li><p>简单的分组查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询每个部门的平均工资</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) 平均工资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(salary) <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询每个工种的最高工资</span><br><span class="line"><span class="keyword">SELECT</span> job_id,<span class="built_in">MAX</span>(salary) 最高工资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"></span><br><span class="line">#案例<span class="number">3</span>：查询每个位置上的部门个数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),location_id</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> location_id</span><br></pre></td></tr></table></figure>

<p>​        </p>
</li>
<li><p>where筛选条件：先where筛选再分组，where筛选是在未分组的原始表上进行的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#案例1：查询邮箱中包含a字符，每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE email LIKE &#x27;%a%&#x27;</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">#案例2：查询每个领导手下有奖金的员工的最高工资</span><br><span class="line">SELECT MAX(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager_id;</span><br></pre></td></tr></table></figure></li>
<li><p>having筛选条件：先查询在having筛选，having筛选是在查询结果集上进行的    </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询哪个部门的员工个数大于<span class="number">2</span></span><br><span class="line">#错误写法：<span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span>是筛选的整个原始表</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) 员工个数</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line">#正确写法：（<span class="number">1</span>）先分组查询每个部门的员工个数；（<span class="number">2</span>）根据结果再过滤查询员工个数大于<span class="number">2</span>的部门</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) 员工个数</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>混合筛选条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询每个工种&quot;有奖金的&quot;员工的&quot;最高工资&gt;12000的&quot;工种编号和最高工资</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">筛选条件1：有奖金的</span></span><br><span class="line"><span class="comment">筛选条件2：最高工资&gt;12000</span></span><br><span class="line"><span class="comment">分组条件：每个工种</span></span><br><span class="line"><span class="comment">思路：先筛选出有奖金的项，按照工种分组，查询出每个分组的最高工资和工种编号，最后从结果集筛选出最高工资大于12000的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> job_id,<span class="built_in">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span><span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询“领导编号<span class="operator">&gt;</span><span class="number">102</span>的“每个领导手下的”最低工资<span class="operator">&gt;</span><span class="number">5000</span>的“领导编号以及最低工资</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">筛选条件1：领导编号&gt;102</span></span><br><span class="line"><span class="comment">筛选条件2：最低工资&gt;5000</span></span><br><span class="line"><span class="comment">分组条件：每个领导</span></span><br><span class="line"><span class="comment">思路：先筛选领导编号&gt;102的项，按照领导编号分组，查询出领导编号和最低工资，最后从结果集筛选出最低工资&lt;5000的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> manager_id,<span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id<span class="operator">&gt;</span><span class="number">102</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary)<span class="operator">&gt;</span><span class="number">5000</span>；</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-连接查询"><a href="#7-连接查询" class="headerlink" title="7.连接查询"></a>7.连接查询</h3><h4 id="（1）分类："><a href="#（1）分类：" class="headerlink" title="（1）分类："></a>（1）分类：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按年代分类：</span><br><span class="line">	sq129标准：仅支持内连接（等值、非等值、自连接）</span><br><span class="line">	sql199标准【推荐】支持内连接+外连接（左外连接、右外连接）+交叉连接</span><br><span class="line">	</span><br><span class="line">按功能分：</span><br><span class="line">	内连接：</span><br><span class="line">		等值连接</span><br><span class="line">		非等职连接</span><br><span class="line">		自连接</span><br><span class="line">	外连接：</span><br><span class="line">		左外连接</span><br><span class="line">		右外连接</span><br><span class="line">		全外连接</span><br><span class="line">	交叉连接</span><br></pre></td></tr></table></figure>



<h4 id="（2）SQL192标准"><a href="#（2）SQL192标准" class="headerlink" title="（2）SQL192标准"></a>（2）SQL192标准</h4><ul>
<li>等值连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询女生名对应的男生名</span><br><span class="line"><span class="keyword">SELECT</span> `name`,boyName <span class="keyword">FROM</span> beauty,boys</span><br><span class="line"><span class="keyword">WHERE</span> beauty.boyfriend_id <span class="operator">=</span> boys.id;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询员工名和对应的部门名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.`department_id`<span class="operator">=</span>departments.`department_id`;</span><br><span class="line"></span><br><span class="line">#为表名起别名</span><br><span class="line">#案例<span class="number">1</span>：查询员工号、工种号、工种名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,employees.job_id,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees,jobs</span><br><span class="line"><span class="keyword">WHERE</span> employees.`job_id`<span class="operator">=</span>jobs.`job_id`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,e.job_id,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e,jobs <span class="keyword">AS</span> j</span><br><span class="line"><span class="keyword">WHERE</span> e.`job_id`<span class="operator">=</span>j.`job_id`;</span><br><span class="line"></span><br><span class="line">#加筛选条件</span><br><span class="line">#案例<span class="number">1</span>：查询有奖金的员工们和部门名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`commission_pct` <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; </span><br></pre></td></tr></table></figure>



<ul>
<li>非等值连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询员工的工资和工资级别</span><br><span class="line"><span class="keyword">SELECT</span> salary,grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees,job_grades g</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> g.`lowest_sal` <span class="keyword">AND</span> `highest_salary`;</span><br></pre></td></tr></table></figure>



<ul>
<li>自连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">3.</span>自连接</span><br><span class="line">#案例<span class="number">1</span>：查询员工名和上级的名称</span><br><span class="line"><span class="keyword">SELECT</span> e1.last_name 员工名,e2.last_name 领导名</span><br><span class="line"><span class="keyword">FROM</span> employees e1,employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.manager_id <span class="operator">=</span> e2.employee_id</span><br></pre></td></tr></table></figure>



<h4 id="（3）SQL199标准"><a href="#（3）SQL199标准" class="headerlink" title="（3）SQL199标准"></a>（3）SQL199标准</h4><ul>
<li><p>语法：</p>
<pre><code>select 查询列表
  from 表1 别名 【连接类型】
  join 表2 别名
  on 连接条件
  【where 筛选条件】
  【group by 分组】
  【having 筛选条件】
  【order by 排序列表】
</code></pre>
</li>
<li><p>分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分类：</span><br><span class="line">	内连接：inner</span><br><span class="line">	外连接：</span><br><span class="line">		左外：left 【outer】</span><br><span class="line">		右外：right 【outer】</span><br><span class="line">		全外：full 【outer】</span><br><span class="line">	交叉连接：cross</span><br></pre></td></tr></table></figure></li>
<li><p>内连接</p>
<ul>
<li>语法<pre><code>select 查询列表
  from 表1 别名
  inner join 表2 别名
  On 连接条件
</code></pre>
</li>
<li>等值连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#（<span class="number">1</span>）等值连接</span><br><span class="line">#案例<span class="number">1</span>：查询员工名和对应的部门名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询有奖金的员工们和部门名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`commission_pct` <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>非等值连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#（<span class="number">2</span>）非等值连接</span><br><span class="line">#案例<span class="number">1</span>：查询员工的工资和工资级别</span><br><span class="line"><span class="keyword">SELECT</span> salary,grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> e.salary <span class="keyword">BETWEEN</span> g.`lowest_sal` <span class="keyword">AND</span> `highest_salary`;</span><br></pre></td></tr></table></figure>

<ul>
<li>子连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#（<span class="number">3</span>）自连接</span><br><span class="line">#案例<span class="number">1</span>：查询员工名和上级的名称</span><br><span class="line"><span class="keyword">SELECT</span> e1.last_name 员工名,e2.last_name 领导名</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> employees e2</span><br><span class="line"><span class="keyword">ON</span> e1.manager_id <span class="operator">=</span> e2.employee_id</span><br></pre></td></tr></table></figure></li>
<li><p>外连接</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">应用场景：一个表中有，另外一个表没有的记录</span></span><br><span class="line"><span class="comment">1.外连接查询结果为主表中的所有记录</span></span><br><span class="line"><span class="comment">	如果从表中有和它匹配的，则显示匹配的值</span></span><br><span class="line"><span class="comment">	如果没有和它匹配的，则显示null</span></span><br><span class="line"><span class="comment">	外连接查询结果=内连接结果+主表中有而从表中没有的记录</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">2.left join:左边是主表</span></span><br><span class="line"><span class="comment">right join:右边是主表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例<span class="number">1</span>：查询男朋友不在男生表中女生名</span><br><span class="line"><span class="keyword">select</span> be.name,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> beauty be</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> boys bo</span><br><span class="line"><span class="keyword">on</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"><span class="keyword">where</span> bo.`id` <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询哪个部门没有员工</span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span>,e.employee_id</span><br><span class="line"><span class="keyword">from</span> departments d</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> employees e</span><br><span class="line"><span class="keyword">on</span> d.`department_id` <span class="operator">=</span> e.`department_id`</span><br><span class="line"><span class="keyword">where</span> e.`employee_id` <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>



<ul>
<li>交叉连接</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#交叉连接（笛卡尔乘积）</span><br><span class="line"><span class="keyword">SELECT</span> be.<span class="operator">*</span>,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> beauty be</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> boys bo;</span><br></pre></td></tr></table></figure>



<h3 id="8-子查询"><a href="#8-子查询" class="headerlink" title="8.子查询"></a>8.子查询</h3><ul>
<li>说明：当一个查询语句中又嵌套了另外一个select语句，则倍嵌套的select语句称为子查询或内查询           </li>
<li>分类：  <ol>
<li>select后面：<pre><code>要求：子查询的结果为单行多列（标量子查询）
</code></pre>
</li>
<li>from后面<pre><code>要求：子查询的结果可以为多行多列
</code></pre>
</li>
<li>where或having后面<pre><code>要求：子查询的结果必须为单列
       单行子查询
       多行子查询
</code></pre>
</li>
<li>exists后面<pre><code>要求：子查询结果必须为单列（相关子查询）
</code></pre>
</li>
</ol>
</li>
<li>特点：<pre><code>子查询要包含在括号中；
  子查询放在比较条件右侧
  子查询的查询优先于主查询
  单行子查询对应了 单行操作符：&gt; &lt; &lt;= &gt;= = &lt;&gt;
  多行子查询对应了 多行操作符：any/some  all in
</code></pre>
</li>
</ul>
<ul>
<li><p>单行子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1.</span>查询和Zlotkey相同部门的员工姓名和工资名</span><br><span class="line">#(<span class="number">1</span>)查询Zlotkey的部门编号</span><br><span class="line"><span class="keyword">SELECT</span> department_id </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Zlotkey&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)查询department_id<span class="operator">=</span>(<span class="number">1</span>)的员工工资和姓名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> department_id </span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Zlotkey&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2.</span>查询工资比公司平均工资高的员工姓名和工资</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;=</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>多行子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">in:判断某字段是否在列表内</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">any/some:判断某字段的值是否满足任意一个</span></span><br><span class="line"><span class="comment">x&gt;any() &lt;=&gt; x&gt;min()</span></span><br><span class="line"><span class="comment">x=any() &lt;=&gt; x in ()</span></span><br><span class="line"><span class="comment">x&lt;any() &lt;=&gt; x&lt;max()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">all:判断某字段的值是否满足所有</span></span><br><span class="line"><span class="comment">x&gt;all() &lt;=&gt; x&gt;max()</span></span><br><span class="line"><span class="comment">x&lt;all() &lt;=&gt; x&lt;max()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例<span class="number">1</span>：返回location_id是<span class="number">1400</span>或<span class="number">1700</span>的部门中的所有员工姓名</span><br><span class="line"><span class="keyword">SELECT</span> last_name	</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> departments</span><br><span class="line">	<span class="keyword">WHERE</span> location_id <span class="keyword">IN</span> (<span class="number">1400</span>,<span class="number">1700</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：返回其他部门中比job_id为IT_PROG部门中任意工资低的员工号、姓名、job_id、salary</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="keyword">ANY</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">) <span class="keyword">AND</span> job_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> (</span><br><span class="line">	<span class="keyword">SELECT</span>  <span class="built_in">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">) <span class="keyword">AND</span> job_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;IT_PROG&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>放在from后面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：查询每个部门的平均工资的工资级别</span><br><span class="line">#（<span class="number">1</span>）每个部门的平均工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)连接：查询平均工资的工资级别</span><br><span class="line"><span class="keyword">SELECT</span> dep_ag.department_id,dep_ag.ag,g.grade</span><br><span class="line"><span class="keyword">FROM</span> sal_grade g</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) ag,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) dep_ag <span class="keyword">ON</span> dep_ag.ag <span class="keyword">BETWEEN</span> g.min_salary <span class="keyword">AND</span> g.max_salary;</span><br></pre></td></tr></table></figure></li>
<li><p>放在exists后面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：查询有无名字叫“张三丰”的员工</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;张三丰&#x27;</span></span><br><span class="line">) 有无;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-分页查询"><a href="#9-分页查询" class="headerlink" title="9.分页查询"></a>9.分页查询</h3><ul>
<li><p>语法：</p>
<p>select 查询列表<br>from 表1 别名<br>join 表2 别名<br>where 筛选条件<br>group by 分组<br>having 分组后筛选<br>order by 排序列表<br>limit 起始条目索引(默认0)，显示的条目数</p>
</li>
<li><p>执行顺序：</p>
<p>1.from<br>2.join<br>3.on<br>4.where<br>5.group by<br>6.having<br>7.select<br>8.order by<br>9.limit</p>
</li>
<li><p>公式：</p>
<p>如果要显示的页数是page,每页显示的条目数是size</p>
<p>*<em>select *<br>from employees<br>limit (page-1)<em>size,size;</em></em></p>
<table>
<thead>
<tr>
<th>page</th>
<th>size=10</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>limit 0,10</td>
</tr>
<tr>
<td>2</td>
<td>limit 10,10</td>
</tr>
<tr>
<td>3</td>
<td>limit 20,10</td>
</tr>
<tr>
<td>4</td>
<td>limit 30,10</td>
</tr>
</tbody></table>
</li>
<li><p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询员工信息的前五条</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">5</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">0</span>,<span class="number">5</span></span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询有奖金的，员工工资较高的第<span class="number">11</span>名到第<span class="number">20</span>名</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">10</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-union联合查询"><a href="#10-union联合查询" class="headerlink" title="10.union联合查询"></a>10.union联合查询</h3><ul>
<li><p>说明：查询结果之间没有关联，这个时候往往使用联合查询（union查询）</p>
</li>
<li><p>语法：</p>
<p>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】<br>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】<br>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】<br>…..<br>select 字段|常量|表达式|函数 【from 表】 【where 条件】</p>
</li>
<li><p>注意：</p>
<ul>
<li>要求列数相等</li>
<li>union自动去重/union all 支持重复项</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：</span><br><span class="line"><span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> beauty</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> `boyname` <span class="keyword">FROM</span> boys</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="1-插入insert"><a href="#1-插入insert" class="headerlink" title="1.插入insert"></a>1.插入insert</h3><h4 id="（1）方式一"><a href="#（1）方式一" class="headerlink" title="（1）方式一"></a>（1）方式一</h4><ul>
<li><p>语法：</p>
<p><font color="red">insert into 表名(列名1，…) </font></p>
<p><font color="red">values(值1，…)，values(值1，…)，…</font></p>
</li>
<li><p>插入的值的类型要与列的类型一致,且一一对应</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">&#x27;唐艺昕&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>可以为null的列如何插入值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式一(对应值写<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">&#x27;唐艺昕&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">#方式二（不写列名）</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(id,NAME,sex,borndate,phone,boyfriend_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">14</span>,<span class="string">&#x27;金星&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>列的顺序可以调换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(NAME,sex,phone,id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;蒋欣&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1235677764&#x27;</span>,<span class="number">15</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>可以省略列名，默认所有列，且列的顺序和表中列的顺序一致</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">16</span>,<span class="string">&#x27;张飞&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;119&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）方式二"><a href="#（2）方式二" class="headerlink" title="（2）方式二"></a>（2）方式二</h4><ul>
<li><p>语法：</p>
<p><font color="red">insert into 表名</font></p>
<p><font color="red">set 列名1=值1，列名2=值2，…</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">SET</span> id<span class="operator">=</span><span class="number">17</span>,NAME<span class="operator">=</span><span class="string">&#x27;刘涛&#x27;</span>,phone<span class="operator">=</span><span class="string">&#x27;1928384940984&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）两者对比"><a href="#（3）两者对比" class="headerlink" title="（3）两者对比"></a>（3）两者对比</h4><ul>
<li><p>方式一支持插入多行，方式二不支持</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">18</span>,<span class="string">&#x27;唐艺昕&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">19</span>,<span class="string">&#x27;唐艺昕&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">20</span>,<span class="string">&#x27;唐艺昕&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1990-4-23&#x27;</span>,<span class="string">&#x27;19822223333&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>方式一支持子查询，方式二不支持</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(id,NAME,phone)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">21</span>,<span class="string">&#x27;宋茜&#x27;</span>,<span class="string">&#x27;123478583493&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-修改update"><a href="#2-修改update" class="headerlink" title="2.修改update"></a>2.修改update</h3><h4 id="（1）修改单表"><a href="#（1）修改单表" class="headerlink" title="（1）修改单表"></a>（1）修改单表</h4><ul>
<li><p>语法：</p>
<p><font color="red">update 表名</font></p>
<p><font color="red">set 列=新值，列=新值</font></p>
<p><font color="red">where 筛选条件;</font></p>
</li>
<li><p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：修改beauty表中姓唐的电话为<span class="number">000000000</span></span><br><span class="line">UPDATE beauty</span><br><span class="line"><span class="keyword">SET</span> phone<span class="operator">=</span><span class="string">&#x27;000000000&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;唐%&#x27;</span></span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：修改boys表中id为<span class="number">2</span>的名称为张飞，魅力值为<span class="number">10</span></span><br><span class="line">UPDATE boys</span><br><span class="line"><span class="keyword">SET</span> boyname<span class="operator">=</span><span class="string">&#x27;张飞&#x27;</span>,userCP<span class="operator">=</span><span class="number">10</span></span><br><span class="line"><span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）修改多表"><a href="#（2）修改多表" class="headerlink" title="（2）修改多表"></a>（2）修改多表</h4><ul>
<li><p>语法：</p>
<ul>
<li><p>SQL192语法：</p>
<p><font color="red">update 表1 别名，表2 别名</font></p>
<p><font color="red">set 列=值，…</font></p>
<p><font color="red">where 连接条件</font></p>
<p><font color="red">and 筛选条件</font></p>
</li>
<li><p>SQL199语法：【推荐】</p>
<p><font color="red">update 表1 别名</font></p>
<p><font color="red">inner|left|right join 表2 别名</font></p>
<p><font color="red">on 连接条件</font></p>
<p><font color="red">set 列=值，…</font></p>
<p><font color="red">where 筛选条件</font></p>
</li>
</ul>
</li>
<li><p>案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：修改张无忌的女朋友的手机号为<span class="number">11111111</span></span><br><span class="line">UPDATE boys bo</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty be </span><br><span class="line"><span class="keyword">ON</span> bo.`id`<span class="operator">=</span>be.`boyfriend_id`</span><br><span class="line"><span class="keyword">SET</span> phone<span class="operator">=</span><span class="string">&#x27;1111111111&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.boyName<span class="operator">=</span><span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：修改没有男朋友的女生的男朋友编号都为<span class="number">2</span></span><br><span class="line">#(<span class="number">1</span>)左外连接</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span></span><br><span class="line">beauty be <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> boys bo</span><br><span class="line"><span class="keyword">ON</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"></span><br><span class="line">UPDATE beauty be</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> boys bo </span><br><span class="line"><span class="keyword">ON</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"><span class="keyword">SET</span> boyfriend_id<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> boyfriend_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)右外连接</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span></span><br><span class="line">boys bo <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> beauty be</span><br><span class="line"><span class="keyword">ON</span> bo.`id`<span class="operator">=</span>be.`boyfriend_id`</span><br><span class="line"></span><br><span class="line">UPDATE boys bo </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> beauty be</span><br><span class="line"><span class="keyword">ON</span> bo.`id`<span class="operator">=</span>be.`boyfriend_id`</span><br><span class="line"><span class="keyword">SET</span> boyfriend_id<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> boyfriend_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-删除delete"><a href="#3-删除delete" class="headerlink" title="3.删除delete"></a>3.删除delete</h3><h4 id="（1）单表的删除"><a href="#（1）单表的删除" class="headerlink" title="（1）单表的删除"></a>（1）单表的删除</h4><ul>
<li><p>语法：<font color="red">delete from 表名 where 筛选条件</font></p>
</li>
<li><p>案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：删除手机号以<span class="number">9</span>结尾的女神信息</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> beauty <span class="keyword">WHERE</span> phone <span class="keyword">LIKE</span> <span class="string">&#x27;%9&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）多表的删除"><a href="#（2）多表的删除" class="headerlink" title="（2）多表的删除"></a>（2）多表的删除</h4><ul>
<li><p>语法：</p>
<ul>
<li><p>SQL192标准</p>
<p>​        delete 表1的别名，表2的别名 （要删除哪个表的记录就写哪个表别名）<br>​        from 表1 别名，表2 别名<br>​        where 连接条件<br>​        and 筛选条件</p>
</li>
<li><p>SQL199标准【推荐】</p>
<p>​        <font color="red">delete 表1的别名，表2的别名</font><br>​        <font color="red">from 表1 别名</font><br>​        <font color="red">inner|left|right| join 表2 别名</font><br>​        <font color="red">on 连接条件</font><br>​        <font color="red">where 筛选条件</font></p>
</li>
</ul>
</li>
<li><p>案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：删除张无忌女朋友的信息</span><br><span class="line"><span class="keyword">DELETE</span> be</span><br><span class="line"><span class="keyword">FROM</span> boys bo </span><br><span class="line"><span class="keyword">JOIN</span> beauty be</span><br><span class="line"><span class="keyword">ON</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"><span class="keyword">WHERE</span> bo.`boyName`<span class="operator">=</span><span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#案例：删除黄晓明及其女朋友的信息</span><br><span class="line"><span class="keyword">DELETE</span> be,bo</span><br><span class="line"><span class="keyword">FROM</span> boys bo </span><br><span class="line"><span class="keyword">JOIN</span> beauty be</span><br><span class="line"><span class="keyword">ON</span> be.`boyfriend_id`<span class="operator">=</span>bo.`id`</span><br><span class="line"><span class="keyword">WHERE</span> bo.`boyName`<span class="operator">=</span><span class="string">&#x27;黄晓明&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）truncate"><a href="#（3）truncate" class="headerlink" title="（3）truncate"></a>（3）truncate</h4><ul>
<li>语法：<font color="red">truncate table 表名；</font></li>
<li>truncate table boys 与 delete from boys 对比 【<font color="red">面试题</font>】<ul>
<li>1.都能清空表数据</li>
<li>2.truncate删除效率稍微高一点点</li>
<li>3.用delete删除在插入数据，自增长序列的值从断点开始；用truncate删除再插入数据，自增长序列的值从1开始</li>
<li>4.delete删除有返回值；truncate删除没有返回值</li>
<li>5.truncate删除后不能回滚，delete删除可以回滚</li>
</ul>
</li>
</ul>
<h2 id="DDL语言"><a href="#DDL语言" class="headerlink" title="DDL语言"></a>DDL语言</h2><h3 id="1-库的管理"><a href="#1-库的管理" class="headerlink" title="1.库的管理"></a>1.库的管理</h3><h4 id="（1）库的创建"><a href="#（1）库的创建" class="headerlink" title="（1）库的创建"></a>（1）库的创建</h4><ul>
<li><p>语法：<font color="red">create database 库名</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE books;</span><br><span class="line">#如果库不存在则创建</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> books;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）库的修改"><a href="#（2）库的修改" class="headerlink" title="（2）库的修改"></a>（2）库的修改</h4><ul>
<li>语法：rename datebase 库名 to 新库名;【不安全，已废弃】</li>
</ul>
<h4 id="（3）库的删除"><a href="#（3）库的删除" class="headerlink" title="（3）库的删除"></a>（3）库的删除</h4><ul>
<li><p>语法：<font color="red">drop database 库名</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE books;</span><br><span class="line">#如果存在则删除</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> books;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-表的管理"><a href="#2-表的管理" class="headerlink" title="2.表的管理"></a>2.表的管理</h3><h4 id="（1）表的创建"><a href="#（1）表的创建" class="headerlink" title="（1）表的创建"></a>（1）表的创建</h4><ul>
<li><p>语法：</p>
<p><font color="red">create table 表名(</font>    列名 列的类型 [(长度) 约束],<br><font color="red">    列名 列的类型 [(长度) 约束],</font></p>
<p><font color="red">    列名 列的类型 [(长度) 约束],</font></p>
<p>​    <font color="red">…</font><br>​    <font color="red">列名 列的类型 [(长度) 约束],</font></p>
</li>
<li><p>案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例：创建表book</span><br><span class="line">USE books;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> book(</span><br><span class="line">	id <span class="type">INT</span>,#编号</span><br><span class="line">	bName <span class="type">VARCHAR</span>(<span class="number">20</span>),#书名</span><br><span class="line">	price <span class="keyword">DOUBLE</span>,#价格</span><br><span class="line">	author <span class="type">VARCHAR</span>(<span class="number">20</span>),#作者编号</span><br><span class="line">	pulishDate DATETIME#出版日期</span><br><span class="line">);</span><br><span class="line"><span class="keyword">DESC</span> book;</span><br><span class="line"></span><br><span class="line">#案例：创建表author</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> author(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	au_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	nation <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">DESC</span> author;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）表的修改"><a href="#（2）表的修改" class="headerlink" title="（2）表的修改"></a>（2）表的修改</h4><ul>
<li><p>语法：<font color="red">alter table 表名 add|drop|modify|change column</font></p>
</li>
<li><p>修改列名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book CHANGE <span class="keyword">COLUMN</span> publishDate pubData DATETIME;</span><br></pre></td></tr></table></figure></li>
<li><p>修改列的类型或约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book MODIFY <span class="keyword">COLUMN</span> pubData <span class="type">TIMESTAMP</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>添加新列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> annual <span class="keyword">DOUBLE</span>; #年薪</span><br></pre></td></tr></table></figure></li>
<li><p>删除列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> annual;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> annual;</span><br></pre></td></tr></table></figure></li>
<li><p>修改表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author RENAME <span class="keyword">TO</span> book_author;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）表的复制"><a href="#（3）表的复制" class="headerlink" title="（3）表的复制"></a>（3）表的复制</h4><ul>
<li><p>仅复制表的结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">copy</span> <span class="keyword">LIKE</span> author;</span><br></pre></td></tr></table></figure></li>
<li><p>复制表的结构+数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy1 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> author;</span><br></pre></td></tr></table></figure></li>
<li><p>仅复制部分数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CRATE <span class="keyword">TABLE</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy2</span><br><span class="line"><span class="keyword">SELECT</span> id,au_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> nation<span class="operator">=</span><span class="string">&#x27;中国&#x27;</span>;copy1 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> author;</span><br></pre></td></tr></table></figure></li>
<li><p>仅复制部分结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy3</span><br><span class="line"><span class="keyword">SELECT</span> id,au_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>; #恒不成立，没有数据</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（4）表的删除"><a href="#（4）表的删除" class="headerlink" title="（4）表的删除"></a>（4）表的删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> book_author;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> book_author;</span><br></pre></td></tr></table></figure>



<h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><h4 id="（1）整型"><a href="#（1）整型" class="headerlink" title="（1）整型"></a>（1）整型</h4><ul>
<li><table>
<thead>
<tr>
<th align="center">整型类型</th>
<th align="center">字节</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tinyint</td>
<td align="center">1</td>
<td align="center">有符号：-128<del>127   无符号：0</del>255</td>
</tr>
<tr>
<td align="center">smallint</td>
<td align="center">2</td>
<td align="center">有符号：-32768<del>32767   无符号：0</del>65535</td>
</tr>
<tr>
<td align="center">mediumint</td>
<td align="center">3</td>
<td align="center">有符号：-8388608<del>8388607    无符号：0</del>1677215</td>
</tr>
<tr>
<td align="center">int\integer</td>
<td align="center">4</td>
<td align="center">有符号：- 2147483648<del>2147483647 无符号：0</del>4294967295</td>
</tr>
<tr>
<td align="center">bigint</td>
<td align="center">8</td>
<td align="center">有符号：-9223372036854775808<del>9223372036854775807 无符号：0</del>9223372036854775807*2+1</td>
</tr>
</tbody></table>
</li>
<li><p>特点：</p>
<ul>
<li>a.默认是有符号，如果要设置无符号，需要添加关键字unsigned</li>
<li>b.如果插入的数值超出了整型的范围，会报out of range异常，并且插入临界值<br>c.如果不设置长度，会有默认长度。</li>
<li>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用</li>
</ul>
</li>
<li><p>如何设置无符号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_int(</span><br><span class="line">	t1 <span class="type">INT</span>,</span><br><span class="line">	t2 <span class="type">INT</span> UNSIGNED,</span><br><span class="line">	t3 <span class="type">INT</span>(<span class="number">8</span>) ZEROFILL</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）小数"><a href="#（2）小数" class="headerlink" title="（2）小数"></a>（2）小数</h4><ul>
<li><table>
<thead>
<tr>
<th align="center">浮点数类型</th>
<th align="center">字节</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">±1.75494351E-38~±3.402823466E+38</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">±2.2250738585072014E-308~±1.7976931348623157E+308</td>
</tr>
<tr>
<td align="center">定点数类型</td>
<td align="center">字节</td>
<td align="center">范围</td>
</tr>
<tr>
<td align="center">dec(M,D)    decimal(M,D)</td>
<td align="center">M+2</td>
<td align="center">最大取值范围与double相同，给定decimal的有效取值范围由M和D</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="（3）字符型"><a href="#（3）字符型" class="headerlink" title="（3）字符型"></a>（3）字符型</h4><ul>
<li>char和varchar</li>
</ul>
<table>
<thead>
<tr>
<th align="center">写法</th>
<th align="center">M的意思</th>
<th align="center">特点</th>
<th align="center">空间消耗</th>
<th align="center">效率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char(M)</td>
<td align="center">最大字符数，可以省略默认为1</td>
<td align="center">固定长度的字符</td>
<td align="center">比较耗费</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">varchar(M)</td>
<td align="center">最大字符数，不可用省略</td>
<td align="center">可变长度的字符</td>
<td align="center">比较节省</td>
<td align="center">低</td>
</tr>
</tbody></table>
<p>​    当存储的字段的字符数固定时用char;当存储的字段的字符数变化时用varchar</p>
<ul>
<li><p>enum 枚举型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_char(</span><br><span class="line">	c1 ENUM(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_char <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>),(<span class="string">&#x27;b&#x27;</span>),(<span class="string">&#x27;c&#x27;</span>),(<span class="string">&#x27;d&#x27;</span>),(<span class="string">&#x27;A&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>set 集合型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_set(</span><br><span class="line">	c1 <span class="keyword">set</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_set <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>),(<span class="string">&#x27;A,b&#x27;</span>),(<span class="string">&#x27;a,c&#x27;</span>),(<span class="string">&#x27;a,b,c&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（4）日期型"><a href="#（4）日期型" class="headerlink" title="（4）日期型"></a>（4）日期型</h4><table>
<thead>
<tr>
<th align="center">日期和时间类型</th>
<th align="center">字节</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">date</td>
<td align="center">4</td>
<td align="center">1000-01-01</td>
<td align="center">9999-12-31</td>
</tr>
<tr>
<td align="center">datetime</td>
<td align="center">8</td>
<td align="center">1000-01-01 00:00:00</td>
<td align="center">9999-12-31 23:59:59</td>
</tr>
<tr>
<td align="center">timestamp</td>
<td align="center">4</td>
<td align="center">19700101080001</td>
<td align="center">2038年的某个时刻</td>
</tr>
<tr>
<td align="center">time</td>
<td align="center">3</td>
<td align="center">-838:59:59</td>
<td align="center">838:59:59</td>
</tr>
<tr>
<td align="center">year</td>
<td align="center">1</td>
<td align="center">1901</td>
<td align="center">2155</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_date(</span><br><span class="line">	t1 DATETIME,</span><br><span class="line">	t2 <span class="type">TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_date <span class="keyword">VALUES</span>(NOW(),NOW());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tab_date;</span><br><span class="line">#改时区</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;time_zone&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> time_zone<span class="operator">=</span><span class="string">&#x27;+9:00&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="4-常见约束"><a href="#4-常见约束" class="headerlink" title="4.常见约束"></a>4.常见约束</h3><h4 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><ul>
<li><p>含义：一种限制，用于限制表中的数据，为了保证表中数据的准确可靠性</p>
</li>
<li><p>分类：六大约束</p>
<ul>
<li>NOT NULL：非空。用于保证该字段非空（如姓名、学号）</li>
<li>DEFAULT：默认。用于保证该字段有默认值（如姓名）</li>
<li>PRIMARY KEY：主键。用于保证该字段唯一且非空（如学号、员工编号）</li>
<li>UNIQUE：唯一。用于保证该字段的值唯一性，可以为空（如座位号）</li>
<li>CHECK：检查【mysql不支持】。（如年龄、性别）</li>
<li>FOREIGIN KEY：外键。用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值。在从表中添加外键约束，用于引用主表中某列的值（比如学生表的专业编号，员工表的部门编号，员工表的工种编号）</li>
</ul>
</li>
<li><p>添加约束的时机：</p>
<pre><code>1.创建表时
  2.修改表时
</code></pre>
</li>
<li><p>约束的添加分类：</p>
<pre><code>列级约束（六大约束都支持，但foreign key没有效果
  表级约束（除了&lt;font color=&#39;red&#39;&gt;非空、默认&lt;/font&gt;，其他都支持）
</code></pre>
</li>
</ul>
<h4 id="（2）创建表时添加约束"><a href="#（2）创建表时添加约束" class="headerlink" title="（2）创建表时添加约束"></a>（2）创建表时添加约束</h4><ul>
<li><p>1.添加列级约束</p>
<ul>
<li><p>语法：</p>
<p><font color="red">create table 表名(</font>    </p>
<p>​    <font color="red">字段名 字段类型 列级约束，</font><br>​    <font color="red">字段名 字段类型 列级约束，</font><br>​    <font color="red">…</font><br><font color="red">)</font></p>
</li>
<li><p>举例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE students;</span><br><span class="line">USE students;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> major(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	marjorName <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, 		  #主键</span><br><span class="line">	stuName <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, #非空</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span>(gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">OR</span> gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),#检查</span><br><span class="line">	seat <span class="type">INT</span> <span class="keyword">UNIQUE</span>, 	#唯一</span><br><span class="line">	age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>, #默认</span><br><span class="line">	marjorId <span class="type">INT</span> <span class="keyword">REFERENCES</span> major(id) #外键：引用marjor表中的id为外键</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查看约束信息</span><br><span class="line"><span class="keyword">DESC</span> stuinfo;</span><br><span class="line">#查看stuinfo表中所有的索引，包括主键、外键、唯一</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> stuinfo;</span><br></pre></td></tr></table></figure></li>
<li><p>2.添加表级约束</p>
<ul>
<li><p>语法：</p>
<p><font color="red">create table 表名(</font>    </p>
<p>​    <font color="red">字段名 字段类型,</font><br>​    <font color="red">字段名 字段类型,</font><br>​    <font color="red">…</font><br>​    <font color="red">constraint [约束名] 约束类型（字段名，</font><br>​    <font color="red">constraint [约束名] 约束类型（字段名）</font><br>​    <font color="red">…</font><br><font color="red">)</font></p>
</li>
<li><p>举例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> stuinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	stuName <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	seat <span class="type">INT</span>,</span><br><span class="line">	majorId <span class="type">INT</span>,</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> pk <span class="keyword">PRIMARY</span> KEY(id), #主键</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> uq <span class="keyword">UNIQUE</span>(seat),	   #唯一</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> ck <span class="keyword">CHECK</span>(gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">OR</span> gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),#检查</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> KEY(majorid) <span class="keyword">REFERENCES</span> major(id)#外键</span><br><span class="line">); </span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>3.通用的写法（表级约束写外键约束）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> studinfo(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	stuName <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span>(gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">OR</span> gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">	age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>,</span><br><span class="line">	seat <span class="type">INT</span> UNICODE,</span><br><span class="line">	marjorId <span class="type">INT</span>,</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> KEY(majorId) <span class="keyword">REFERENCES</span> major(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>4.primary key VS unique</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>保证唯一性</th>
<th>是否允许为空</th>
<th>一个表中可有几个</th>
</tr>
</thead>
<tbody><tr>
<td>PRIMARY KEY</td>
<td>√</td>
<td>×</td>
<td>一个</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>√</td>
<td>√</td>
<td>多个</td>
</tr>
</tbody></table>
<ul>
<li>5.foreign key<br>​    1.要求在从表设置外键关系<br>​    2.从表中外键列的类型和主表的关联列的类型要求一致或兼容，名称可以不一样<br>​    3.要求主表中的关联列必须是一个key(主键或唯一键）<br>​    4.插入数据时，先插入主表，再插入从表；删除数据时，先删除从表，再删除主表</li>
</ul>
<h4 id="3-修改表时添加约束"><a href="#3-修改表时添加约束" class="headerlink" title="(3)修改表时添加约束"></a>(3)修改表时添加约束</h4><ul>
<li><p>语法：</p>
<p>添加列级约束：</p>
<pre><code>&lt;font color=&#39;red&#39;&gt;alter table 表名 modify column 字段名 字段类型 新约束;&lt;/font&gt;
</code></pre>
<p>添加表级约束：</p>
<pre><code>&lt;font color=&#39;red&#39;&gt;alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】 &lt;/font&gt;
</code></pre>
</li>
<li><p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span>添加非空约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFIER <span class="keyword">COLUMN</span> stuName <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>添加默认约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>添加主键</span><br><span class="line">#（<span class="number">1</span>）列级约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFIER <span class="keyword">COLUMN</span> id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line">#（<span class="number">2</span>）表级约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(id);</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span>添加唯一键</span><br><span class="line">#（<span class="number">1</span>）列级约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> id <span class="type">INT</span> <span class="keyword">UNIQUE</span>;</span><br><span class="line">#（<span class="number">2</span>）表级约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(seat);</span><br><span class="line"></span><br><span class="line">#<span class="number">5.</span>添加外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(majorId) <span class="keyword">REFERENCES</span> major(id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_sutinfo_major <span class="keyword">FOREIGN</span> KEY(majorId) <span class="keyword">REFERENCES</span> major(id);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（4）修改表时删除约束"><a href="#（4）修改表时删除约束" class="headerlink" title="（4）修改表时删除约束"></a>（4）修改表时删除约束</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span>删除非空约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> stuName <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>删除默认约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFIER <span class="keyword">COLUMN</span> age <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>删除主键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo MODIFY <span class="keyword">COLUMN</span> id <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span>删除唯一键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> INDEX seat;</span><br><span class="line"></span><br><span class="line">#<span class="number">5.</span>删除外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_stuinfo_major;</span><br></pre></td></tr></table></figure>



<h3 id="5-标识列"><a href="#5-标识列" class="headerlink" title="5.标识列"></a>5.标识列</h3><ul>
<li><p>含义：又称为自增长列。可以不用手动的插入值，系统提供默认的序列值</p>
</li>
<li><p>特点：</p>
<pre><code>1.标识列要求是一个key
  2.一个表中最多有一个标识列
  3.标识列的类型只能是数值型：int float double
  4.表示列可以通过SET auto_increment_increment=3设置步长；通过插入值设置初始值
</code></pre>
</li>
<li><p>创建表时设置标识列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_indentity(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> tab_indentity;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_indentity(NAME) <span class="keyword">VALUES</span>(<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_indentity <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;lucy&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#查看自增长变量</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%auto_increment%&#x27;</span>;</span><br><span class="line">#修改自增长步长</span><br><span class="line"><span class="keyword">SET</span> auto_increment_increment<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>修改表时设置标识列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_indentity MODIFIER <span class="keyword">COLUMN</span> id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT;</span><br><span class="line"></span><br><span class="line">#修改表时删除标识列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_indentity MODIFIER <span class="keyword">COLUMN</span> id <span class="type">INT</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TCL语言"><a href="#TCL语言" class="headerlink" title="TCL语言"></a>TCL语言</h2><p>Transaction Control Language 事务控制语言</p>
<h3 id="1-事务的概念"><a href="#1-事务的概念" class="headerlink" title="1.事务的概念"></a>1.事务的概念</h3><p>事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。</p>
<h3 id="3-事务的ACID属性【面试题】"><a href="#3-事务的ACID属性【面试题】" class="headerlink" title="3.事务的ACID属性【面试题】"></a>3.事务的ACID属性【面试题】</h3><ul>
<li>原子性（Atomicity）</li>
</ul>
<p>事务是一个<font color="orange">不可分割</font>的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<ul>
<li>一致性（Consistency）</li>
</ul>
<p>事务必须使数据库从一个<font color="orange">一致性状态</font>变换到另外一个一致性状态（一致性：可靠+完整）</p>
<ul>
<li>隔离性（Isolation）</li>
</ul>
<p>一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间<font color="orange">不能互相干扰</font>。</p>
<ul>
<li>持久性（Durability）</li>
</ul>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的<font color="orange">改变就是永久性的</font>，接下来的其他操作和数据库故障不应该对其有任何影响</p>
<h3 id="4-编写事务的步骤"><a href="#4-编写事务的步骤" class="headerlink" title="4.编写事务的步骤"></a>4.编写事务的步骤</h3><ul>
<li><p>步骤一：开启事务<br>set autocommit=0;    #设置自动提交功能为禁用<br>start transaction;    [可选]</p>
</li>
<li><p>步骤二：编写事务中的sql语句(select insert update delete)<br>语句1；<br>语句2；<br>…</p>
</li>
<li><p>步骤三：结束事务（提交或回滚）<br>commit；提交事务<br>rollback; 回滚事务</p>
</li>
</ul>
<h3 id="5-事务的隔离级别"><a href="#5-事务的隔离级别" class="headerlink" title="5.事务的隔离级别"></a>5.事务的隔离级别</h3><h4 id="（1）并发带来的问题【面试题】"><a href="#（1）并发带来的问题【面试题】" class="headerlink" title="（1）并发带来的问题【面试题】"></a>（1）并发带来的问题【面试题】</h4><ul>
<li><p><font color="red">脏读</font>：<font color="orange"> 一个事务读取了另一个事务未提交的数据</font>。</p>
<ul>
<li><p>对于两个事务 T1, T2。 T1 读取了已经被 T2 更新但还没有被提交的字段.</p>
<p>之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</p>
</li>
<li><p>解决方法：脏读本质上是读写操作的冲突，解决办法是写完之后再读。</p>
</li>
<li><p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/30adcbef76094b367e38bab5accc7cd98c109dc4" alt="img"></p>
</li>
</ul>
</li>
<li><p><font color="red">不可重复读</font>：<font color="orange">一个事务两次读取同一个数据，两次读取的数据不一致</font>。</p>
<ul>
<li> 对于两个事务T1, T2,。T1 读取了一个字段, 然后 T2 更新了该字段.之后, T1再次读取同一个字段, 值就不同了。</li>
<li> 解决方法：不可重复读本质上是读写操作的冲突，解决办法是读完再写。</li>
<li> <img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/48540923dd54564e92c34561bcde9c82d0584fc7" alt="img"></li>
</ul>
</li>
<li><p><font color="red">幻读</font>：<font color="orange">一个事务两次读取一个范围的记录，两次读取的记录数不一致</font>。</p>
<ul>
<li>对于两个事务T1, T2。T1 从一个表中读取了一个字段, 然后 T2 在该表中插 入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行</li>
<li>解决方法：幻象读本质上是读写操作的冲突，解决办法是读完再写。</li>
<li><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/29381f30e924b899d124d96061061d950a7bf64a" alt="img"></li>
</ul>
</li>
<li><p><font color="red">更新丢失</font>：<font color="orange">一个事务的更新覆盖了另一个事务的更新</font>。</p>
<ul>
<li>对于两个事务T1，T2。T1和T2读取同一个字段后，都进行了修改，但是后面修改的数据结果会覆盖前面修改的数据结果。</li>
<li>更新丢失本质上是写操作的冲突，解决办法是一个一个地写。</li>
<li><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/32fa828ba61ea8d3f299d55c980a304e251f582a" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="（2）事务隔离级别"><a href="#（2）事务隔离级别" class="headerlink" title="（2）事务隔离级别"></a>（2）事务隔离级别</h4><table>
<thead>
<tr>
<th>隔离级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED（读未提交数据）</td>
<td>允许事务读取未被其他事务提交的变更。脏读、不可重复读、幻读</td>
</tr>
<tr>
<td>READ COMMITTED（读已提交数据）</td>
<td>只允许事务读取已经被其他事务提交的变更，可以避免脏读，但不可重复读和幻读的问题任然存在</td>
</tr>
<tr>
<td>REPEATBLE READ（可重复读）</td>
<td>确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复度，但幻读问题依然存在</td>
</tr>
<tr>
<td>SERIALIZABLE（串行化）</td>
<td>确保事务可以从一个表中读取相同的行，再这个事务持续期间，禁止其他事务执行插入、更新、删除操作，所有并发问题都可以避免，但性能十分低下。</td>
</tr>
</tbody></table>
<ul>
<li>Oracle 支持的2 种事务隔离级别：READ COMMITED,  SERIALIZABLE。Oracle 默认的事务隔离级别为: READ  COMMITED  Mysql 支持4 种事务隔离级别. Mysql 默认的事务隔离级别为: <font color="red">REPEATABLE READ</font></li>
<li>Mysql 支持4 种事务隔离级别. Mysql 默认的事务隔离级别为: <font color="red">REPEATABLE READ</font></li>
</ul>
<h4 id="（3）设置事务的隔离级别"><a href="#（3）设置事务的隔离级别" class="headerlink" title="（3）设置事务的隔离级别"></a>（3）设置事务的隔离级别</h4><ul>
<li><p>查看当前的隔离级别：</p>
<p>​    <font color="red">SELECT @@tx_isolation;</font></p>
</li>
<li><p>设置当前MySQL连接会话的隔离级别：</p>
<p>​    <font color="red">set session transaction isolation level 隔离级别类型;</font>该命令只对当前会话生效，不影响其他会话和全局的事务隔离级别配置。</p>
</li>
<li><p>设置下一次事务的事务隔离级别：</p>
<p>​    <font color="red">set transaction isolation level 隔离级别类型；</font>该命令只对下一次事务生效，不会影响会话本身设置的事务隔离级别。</p>
</li>
<li><p>设置数据库系统的全局的隔离级别：</p>
<p>​    <font color="red">set global transaction isolation level 隔离级别类型;</font>该命令不会影响当前已连接的会话的事务隔离级别，对于以后的连接会话生效。</p>
</li>
</ul>
<h4 id="（4）举例"><a href="#（4）举例" class="headerlink" title="（4）举例"></a>（4）举例</h4><ul>
<li><p>read uncommitted (脏读，不可重复读，幻读，更新丢失 都不能解决)</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823152455209.png" alt="image-20210823152455209"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823152945662.png" alt="image-20210823152945662"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823153532343.png" alt="image-20210823153532343"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823154321948.png" alt="image-20210823154321948"></p>
</li>
</ul>
<ul>
<li><p>read committed (解决脏读，不可重复读，幻读，更新丢失仍存在)</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823160252930.png" alt="image-20210823160252930"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823160729970.png" alt="image-20210823160729970"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823161335871.png" alt="image-20210823161335871"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823162011169.png" alt="image-20210823162011169"></p>
</li>
</ul>
<ul>
<li><p>repeatable read （解决脏读、不可重复读，未解决幻读、丢失更新）</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210823163921044.png" alt="image-20210823163921044"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210824153058925.png" alt="image-20210824153058925"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210824153530697-1639382732842.png" alt="image-20210824153530697"></p>
</li>
</ul>
<ul>
<li><p>serializable（四种并发问题都能解决）</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210824154220383-1639382732842.png" alt="image-20210824154220383"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210824155313404-1639382732842.png" alt="image-20210824155313404"></p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210824160049809-1639382732842.png" alt="image-20210824160049809"></p>
</li>
</ul>
<h4 id="（5）设置回滚点"><a href="#（5）设置回滚点" class="headerlink" title="（5）设置回滚点"></a>（5）设置回滚点</h4><p>语法：回滚到point a，操作1仍然会提交，只有操作2会回滚</p>
<p>​        set autocommit=0;</p>
<p>​        start transaction;</p>
<p>​        [操作1]</p>
<p>​        savepoint a;</p>
<p>​        [操作2]</p>
<p>​        rollback to a;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">start</span> transaction;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> balance;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span> money <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> zzx  <span class="operator">|</span>  <span class="number">1100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> ddj  <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> zii  <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> zij  <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> balance <span class="keyword">where</span> id<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">5.62</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">savepoint</span> a;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> balance <span class="keyword">where</span> id<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">rollback</span> <span class="keyword">to</span> a;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> balance;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span> money <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> zzx  <span class="operator">|</span>  <span class="number">1100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> ddj  <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> zij  <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>



<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="1-视图的概念"><a href="#1-视图的概念" class="headerlink" title="1.视图的概念"></a>1.视图的概念</h3><p>（1）MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。</p>
<p>（2）应用场景</p>
<ul>
<li>多个地方用到同样的查询结果</li>
<li>该查询结果使用的sql语句较为复杂</li>
</ul>
<h3 id="2-创建视图"><a href="#2-创建视图" class="headerlink" title="2.创建视图"></a>2.创建视图</h3><p>（1）语法</p>
<p>​    create view 视图名</p>
<p>​    as 查询语句;</p>
<p>（2）举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#案例一：创建视图查询每个部门的平均工资</span><br><span class="line">CREATE VIEW my_view1</span><br><span class="line">AS</span><br><span class="line">SELECT AVG(salary) ag,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br></pre></td></tr></table></figure>



<h3 id="3-删除视图"><a href="#3-删除视图" class="headerlink" title="3.删除视图"></a>3.删除视图</h3><p>drop view 视图名1，视图名2,….；</p>
<h3 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4.查看视图"></a>4.查看视图</h3><p>（1）DESC 视图名；</p>
<p>（2）SHOW CREATE VIEW 视图名\G；</p>
<h3 id="5-视图更新"><a href="#5-视图更新" class="headerlink" title="5.视图更新"></a>5.视图更新</h3><p>​    以下操作会修改原始表</p>
<p>（1）插入数据</p>
<p>​    insert into 视图名 values(…)</p>
<p>（2）更改数据</p>
<p>​    update 视图名 set …</p>
<p>（3）删除数据</p>
<p>​    delete from 视图名 where …</p>
<p>（4）视图的可更新性和视图中查询的定义有关系，以下类型的视图是不能更新的：</p>
<ul>
<li>包含以下关键字的sql语句：分组函数、distinct、group、by、having、union或者union all</li>
<li>常量视图</li>
<li>select中包含子查询</li>
<li>from一个不能更新的视图</li>
<li>where子句的子查询引用了from子句中的表</li>
</ul>
<h3 id="6-视图VS表"><a href="#6-视图VS表" class="headerlink" title="6.视图VS表"></a>6.视图VS表</h3><table>
<thead>
<tr>
<th></th>
<th>创建语法关键字</th>
<th>是否实际占用物理空间</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>create view</td>
<td>只是保存了sql逻辑</td>
<td>增删该查，一般不能</td>
</tr>
<tr>
<td>表</td>
<td>create table</td>
<td>保存了数据</td>
<td>增删改查</td>
</tr>
</tbody></table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>系统变量：全局变量，会话变量</p>
<p>自定义变量：用户变量，局部变量</p>
<h3 id="1-系统变量"><a href="#1-系统变量" class="headerlink" title="1.系统变量"></a>1.系统变量</h3><p>说明：变量由系统提供，不是用户定义，属于服务器层面</p>
<h4 id="（1）相关命令"><a href="#（1）相关命令" class="headerlink" title="（1）相关命令"></a>（1）相关命令</h4><ul>
<li><p>（1）查看所有的系统变量</p>
<p>​    show global| 【session】 variables;</p>
</li>
<li><p>（2）查看满足条件的部分系统变量</p>
<p>​    show global | 【session】 variables like ‘%char%’;</p>
</li>
<li><p>（3）查看指定的某个系统变量的值</p>
<p>​    select @@global|【session】.系统变量名；</p>
</li>
<li><p>（4）为某个系统变量赋值</p>
<p>​    方式一：set global|【session】 系统变量名 = 值；</p>
<p>​    方式二：set @@global|【session】.系统变量名 = 值；</p>
</li>
</ul>
<p>注意：如果是全局级别的系统变量，需要加global；如果是会话级别的系统变量，需要加session；不加默认为会话级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL VARIABLES\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: auto_increment_increment</span><br><span class="line">        Value: 1</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: auto_increment_offset</span><br><span class="line">        Value: 1</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">Variable_name: autocommit</span><br><span class="line">        Value: ON</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">Variable_name: automatic_sp_privileges</span><br><span class="line">        Value: ON</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">Variable_name: back_log</span><br><span class="line">        Value: 50</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">Variable_name: basedir</span><br><span class="line">        Value: C:/Program Files (x86)/MySQL/MySQL Server 5.5/</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">Variable_name: big_tables</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">Variable_name: binlog_cache_size</span><br><span class="line">        Value: 32768</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line">Variable_name: binlog_direct_non_transactional_updates</span><br><span class="line">        Value: OFF</span><br><span class="line">*************************** 10. row ***************************</span><br><span class="line">Variable_name: binlog_format</span><br></pre></td></tr></table></figure>

<h4 id="（2）全局变量"><a href="#（2）全局变量" class="headerlink" title="（2）全局变量"></a>（2）全局变量</h4><ul>
<li>作用域：服务器每次启动将所有的全局变量赋初始值，针对于所有的会话（连接）有效，但不能跨重启</li>
</ul>
<h4 id="（3）会话变量"><a href="#（3）会话变量" class="headerlink" title="（3）会话变量"></a>（3）会话变量</h4><ul>
<li>作用域：仅仅针对于当前会话（连接）有效</li>
</ul>
<h3 id="2-自定义变量"><a href="#2-自定义变量" class="headerlink" title="2.自定义变量"></a>2.自定义变量</h3><p>说明：变量由用户自定义</p>
<h4 id="（1）用户变量"><a href="#（1）用户变量" class="headerlink" title="（1）用户变量"></a>（1）用户变量</h4><ul>
<li><p>作用域：针对于当前会话（连接）有效，同于会话变量作用域</p>
</li>
<li><p>声明并初始化：</p>
<ul>
<li>方式一：set @用户变量名 = 值；</li>
<li>方式二：set @用户变量名 := 值；</li>
<li>方式三：select @用户变量名 := 值；</li>
</ul>
</li>
<li><p>赋值（更新）</p>
<ul>
<li><p>方式一：(set或select)</p>
<ul>
<li>set @用户变量名 = 值；</li>
<li>set @用户变量名 := 值；</li>
<li>select @用户变量名 := 值；</li>
</ul>
</li>
<li><p>方式二：（select into）</p>
<p>​    select 字段 into @变量名 from 表；</p>
<p>​    要求查询出的是一个值</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @name=&#x27;john&#x27;;</span><br><span class="line">set @age:=32;</span><br><span class="line">select @count=1;</span><br><span class="line"></span><br><span class="line">select count(*) into @count</span><br><span class="line">from employee;</span><br><span class="line"></span><br><span class="line">select @count;</span><br></pre></td></tr></table></figure></li>
<li><p>查看</p>
<p>select @变量名</p>
</li>
</ul>
<h4 id="（2）局部变量"><a href="#（2）局部变量" class="headerlink" title="（2）局部变量"></a>（2）局部变量</h4><ul>
<li><p>作用域：仅仅在定义它的begin end中有效，定义应为begin end中的第一句话</p>
</li>
<li><p>声明（并初始化）</p>
<ul>
<li><font color="red">declare</font> 变量名 <font color="red"> 类型</font>；</li>
<li>declare 变量名 类型 default 值；</li>
</ul>
</li>
<li><p>赋值</p>
<ul>
<li><p>方式一：(set或select)</p>
<ul>
<li>set 局部变量名 = 值；</li>
<li>set 局部变量名 := 值；</li>
<li>select @局部变量名 := 值；</li>
</ul>
</li>
<li><p>方式二：（select into）</p>
<p>​    select 字段 into 变量名 from 表；</p>
</li>
</ul>
</li>
<li><p>查看</p>
<p>select 局部变量名；</p>
</li>
</ul>
<h4 id="（3）对比"><a href="#（3）对比" class="headerlink" title="（3）对比"></a>（3）对比</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">作用域</th>
<th align="center">定义和使用位置</th>
<th align="center">语法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">用户变量</td>
<td align="center">当前会话</td>
<td align="center">会话中任何地方</td>
<td align="center">必须加@符号</td>
</tr>
<tr>
<td align="center">局部变量</td>
<td align="center">begin end中</td>
<td align="center">只能在begin end中，且为第一句话</td>
<td align="center">一般不用加@符号，需要限定类型</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用户变量</span><br><span class="line">mysql&gt; SET @m=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SET @n=2;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SET @sum=@m+@n;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @sum;</span><br><span class="line">+------+</span><br><span class="line">| @sum |</span><br><span class="line">+------+</span><br><span class="line">|    3 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><p>好处：</p>
<p>1.提高代码的重用性</p>
<p>2.简化操作</p>
<h3 id="1-存储过程"><a href="#1-存储过程" class="headerlink" title="1.存储过程"></a>1.存储过程</h3><h4 id="（1）含义"><a href="#（1）含义" class="headerlink" title="（1）含义"></a>（1）含义</h4><p>​    一组预先编译好的SQL语句的集合，可理解成批处理语句</p>
<h4 id="（2）好处"><a href="#（2）好处" class="headerlink" title="（2）好处"></a>（2）好处</h4><p>​    1.提高代码的重用性</p>
<p>​    2.简化操作</p>
<p>​    3.减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>
<h4 id="（3）语法"><a href="#（3）语法" class="headerlink" title="（3）语法"></a>（3）语法</h4><ul>
<li><p>创建</p>
<ul>
<li><p>语法</p>
<p>create <font color="red">procedure</font> 存储过程名(参数列表)</p>
<p>begin</p>
<p>​        方法体</p>
<p>end</p>
</li>
<li><p>参数列表包含三部分：</p>
<p>​    参数模式 参数名 参数类型</p>
<p>​    例如：in stuname varchar(20)</p>
</li>
<li><p>参数模式：</p>
<ul>
<li>in：该参数可以作为输入，也就是说该参数需要调用方传入值</li>
<li>out：该参数可以作为输出，也就是说该参数可以作为返回值</li>
<li>inout：该参数既可以作为输入，又可以作为输出，也就是该参数急需要传入值，有可以返回值</li>
</ul>
</li>
<li><p>如果方法体只有一句话，则begin end可以省略；存储过程中的每条SQL语句的结尾都要求必须加分号；存储过程的结尾可以使用delimiter重新设置</p>
<ul>
<li>delimiter 结束标记    如delimiter $</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>调用<ul>
<li><font color="red">call</font> 存储过程名(实参列表)；</li>
</ul>
</li>
</ul>
<h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h3><h4 id="（1）函数与存储过程区别"><a href="#（1）函数与存储过程区别" class="headerlink" title="（1）函数与存储过程区别"></a>（1）函数与存储过程区别</h4><ul>
<li>存储过程：可以有0个返回，也可以有过个返回；适合做批量插入、批量更新</li>
<li>函数：有且仅有1个返回；适合做处理数据后返回一个结果的情况</li>
</ul>
<h4 id="（2）语法"><a href="#（2）语法" class="headerlink" title="（2）语法"></a>（2）语法</h4><ul>
<li><p>创建</p>
<ul>
<li><p>语法</p>
<p>create function 函数名(参数列表)  returns 返回类型</p>
<p>begin</p>
<p>​        函数体</p>
<p>end</p>
</li>
<li><p>参数列表包含两部分</p>
<ul>
<li>参数名 参数类型</li>
</ul>
</li>
<li><p>函数体</p>
<ul>
<li>肯定有return语句</li>
</ul>
</li>
<li><p>如果函数体只有一句话，则begin end可以省略；存储过程中的每条SQL语句的结尾都要求必须加分号；存储过程的结尾可以使用delimiter重新设置</p>
<ul>
<li>delimiter 结束标记    如delimiter </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>调用</p>
<ul>
<li><font color="red">select</font> 函数名(参数列表)</li>
</ul>
</li>
<li><p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.无参有返回</span><br><span class="line"># 案例：返回公司员工个数</span><br><span class="line">CREATE FUNCTION myf!() RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE c INT DEFAULT 0; #定义变量</span><br><span class="line">	SELECT COUNT(*) INTO c;		#赋值</span><br><span class="line">	RETURN c;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf!()$	#调用</span><br><span class="line"></span><br><span class="line">#2.有参有返回</span><br><span class="line"># 案例：更加员工名返回工资</span><br><span class="line">CREATE FUNCTION myf@(empName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">	SET @sal=0;    #定义用户变量</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name = empName;</span><br><span class="line">	RETURN @sal;</span><br><span class="line">END $</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）查看和删除函数"><a href="#（3）查看和删除函数" class="headerlink" title="（3）查看和删除函数"></a>（3）查看和删除函数</h4><ul>
<li><p>查看函数定义</p>
<ul>
<li>show create function 函数名；</li>
</ul>
</li>
<li><p>删除函数</p>
<ul>
<li>drop function 函数名；</li>
</ul>
</li>
</ul>
<h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1.分支结构"></a>1.分支结构</h3><h4 id="（1）if函数"><a href="#（1）if函数" class="headerlink" title="（1）if函数"></a>（1）if函数</h4><ul>
<li>功能：实现简单的双分支</li>
<li>语法：<ul>
<li>if（表达式1，表达式2，表达式3）</li>
</ul>
</li>
<li>执行顺序：<ul>
<li>如果表达式1成了，返回表达式2的值，否则返回表达式3的值</li>
</ul>
</li>
</ul>
<h4 id="（2）case结构"><a href="#（2）case结构" class="headerlink" title="（2）case结构"></a>（2）case结构</h4><ul>
<li><p>功能：</p>
<ul>
<li>情况1：类似java中的switch语句，一般用于实现等值判断</li>
<li>情况2：类似java中的多重if语句，一般用户实现区间判断</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><p>情况1：</p>
<p>case 变量|表达式|字段</p>
<p>when 要判断的值1 then 返回的值1或语句1；</p>
<p>when 要判断的值1 then 返回的值2或语句2;</p>
<p>…</p>
<p>else 返回的值n或语句n;</p>
<p>end case;</p>
</li>
<li><p>情况2：</p>
<p>case</p>
<p>when 要判断的条件1 then 返回的值1或语句1；</p>
<p>when 要判断的条件2 then 返回的值2或语句2；</p>
<p>…</p>
<p>else 返回的值n或语句n;</p>
<p>end case;</p>
</li>
</ul>
</li>
</ul>
<h4 id="（3）if结构"><a href="#（3）if结构" class="headerlink" title="（3）if结构"></a>（3）if结构</h4><ul>
<li><p>语法：</p>
<ul>
<li><p>if 条件1 then 语句1；</p>
<p>elseif 条件2 then 语句2；</p>
<p>…</p>
<p>else 语句n</p>
<p>end if</p>
</li>
<li><p>应用：只能应用在begin end中</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2.循环结构"></a>2.循环结构</h3><p>（1）循环控制</p>
<ul>
<li>iterate：类似continue</li>
<li>leave：类型break</li>
</ul>
<p>（2）语法</p>
<ul>
<li>while</li>
</ul>
<p>​    【标签：】while 循环条件 do</p>
<p>​                            循环体；</p>
<p>​                        end while 【标签】；</p>
<ul>
<li><p>loop</p>
<p>【标签：】loop</p>
<p>​                    循环体；</p>
<p>​                    end loop 【标签】；</p>
</li>
<li><p>repeat</p>
<p>【标签：】repeat</p>
<p>​                    循环体；</p>
<p>​                    until 结束循环的条件</p>
<p>​                    end repeat 【标签】；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>《MySQL》</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第三章-Linux的目录结构"><a href="#第三章-Linux的目录结构" class="headerlink" title="第三章 Linux的目录结构"></a><strong>第三章 Linux的目录结构</strong></h2><h4 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1 基本介绍"></a><strong>3.1 基本介绍</strong></h4><ul>
<li><strong>在 Linux 世界里，<font color="orange">一切皆文件</font></strong></li>
<li><strong>linux 的文件系统是采用级层式的<font color="orange">树状目录结构</font>，在此结构中的最上层是根目录</strong></li>
</ul>
<p><strong>“/”，然后在此目录下再创建其他的目录。</strong></p>
<ul>
<li><p><strong>结构图：</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="img"></strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210720151643657.png" alt="image-20210720151643657"></strong></p>
</li>
</ul>
<h4 id="3-2-目录介绍"><a href="#3-2-目录介绍" class="headerlink" title="3.2 目录介绍"></a><strong>3.2 目录介绍</strong></h4><ul>
<li><p><strong>/bin：(usr/bin)<font color="red">[重点]</font></strong><br><strong>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最<font color="orange">经常使用的命令</font>。</strong></p>
</li>
<li><p><strong>/boot：</strong><br><strong>这里存放的是启动 Linux 时使用的一些核心文件，包括一些<font color="orange">链接文件</font>以及<a href="https://zhidao.baidu.com/question/383464901.html">镜像文件</a>。</strong></p>
</li>
<li><p><strong>/dev ：</strong><br><strong>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的(一切皆是文件)。</strong></p>
</li>
<li><p><strong>/etc：<font color="red">[重点]</font></strong><br><strong>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的<font color="orange">系统管理</font>所需要的配置文件和子目录。</strong></p>
</li>
<li><p><strong>/home：<font color="red">[重点]</font></strong><br><strong>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</strong></p>
</li>
<li><p><strong>/lib：</strong><br><strong>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的<font color="orange">动态连接共享库</font>，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库</strong></p>
</li>
<li><p><strong>/lost+found：</strong><br><strong>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</strong></p>
</li>
<li><p><strong>/mnt：<font color="red">[重点]</font></strong><br><strong>系统提供该目录是为了让用户<font color="orange">临时挂载别的文件系统</font>的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</strong></p>
</li>
<li><p><strong>/opt：<font color="red">[重点]</font></strong><br><strong>opt 是 optional(可选) 的缩写，这是给主机<font color="orange">额外安装软件</font>所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</strong></p>
</li>
<li><p><strong>/proc：</strong><br><strong>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是<font color="orange">当前内核运行状态</font>的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</strong><br><strong>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all  </span><br></pre></td></tr></table></figure></li>
<li><p><strong>/root：<font color="red">[重点]</font></strong><br><strong>该目录为系统管理员，也称作超级权限者的用户主目录</strong></p>
</li>
<li><p><strong>/run：</strong><br><strong>是一个临时文件系统，<font color="orange">存储系统启动以来的信息</font>。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</strong></p>
</li>
<li><p><strong>/sbin：</strong><br><strong>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的<font color="orange">系统管理程序</font>。</strong></p>
</li>
<li><p><strong>/srv：</strong><br><strong>该目录存放一些服务启动之后需要提取的数据。</strong></p>
</li>
<li><p><strong>/sys：</strong></p>
<p><strong>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</strong></p>
<p><strong>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</strong></p>
<p><strong>该文件系统是内核设备树的一个直观反映。</strong></p>
<p><strong>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</strong></p>
</li>
<li><p><strong>/tmp：</strong><br><strong>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</strong></p>
</li>
<li><p><strong>/usr：</strong><br><strong>usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，<font color="orange">用户的很多应用程序和文件</font>都放在这个目录下，类似于 windows 下的 program files 目录。</strong></p>
<ul>
<li><p><strong>/usr/bin：</strong><br><strong>系统用户使用的应用程序。</strong></p>
</li>
<li><p><strong>/usr/sbin：</strong><br><strong>超级用户使用的比较高级的管理程序和系统守护程序。</strong></p>
</li>
<li><p><strong>/usr/src：</strong><br><strong>内核源代码默认的放置目录。</strong></p>
</li>
<li><p><strong>/usr/local：<font color="red">[重点]</font></strong></p>
<p><strong>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</strong></p>
</li>
</ul>
</li>
<li><p><strong>/var：<font color="red">[重点]</font></strong><br><strong>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</strong></p>
</li>
<li><p><strong>/media：<font color="red">[重点]</font></strong><br><strong>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</strong></p>
</li>
<li><p><strong>/selinux：</strong><br><strong>这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</strong></p>
</li>
</ul>
<h4 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a><strong>3.3 总结</strong></h4><ol>
<li><strong>Linux有且只有一个根目录 /</strong></li>
<li><strong>Linux的各个目录的内容是规划好的，不要乱放文件</strong></li>
<li><strong>Linux以文件形式管理我们的设备，一切皆文件</strong></li>
<li><strong>几个特殊目录的标识：</strong><ul>
<li><strong>根目录：/</strong> </li>
<li><strong>当前目录：. or ./</strong></li>
<li><strong>上一级目录：.. or ../</strong></li>
<li><strong>家目录：~ or ~/</strong></li>
</ul>
</li>
</ol>
<h2 id="第四章-Linux常用命令"><a href="#第四章-Linux常用命令" class="headerlink" title="第四章 Linux常用命令"></a><strong>第四章 Linux常用命令</strong></h2><h3 id="4-1-文件处理命令"><a href="#4-1-文件处理命令" class="headerlink" title="4.1 文件处理命令"></a><strong>4.1 文件处理命令</strong></h3><h4 id="4-1-0-通配符与命令格式"><a href="#4-1-0-通配符与命令格式" class="headerlink" title="4.1.0 通配符与命令格式"></a><strong>4.1.0 通配符与命令格式</strong></h4><h5 id="1-通配符"><a href="#1-通配符" class="headerlink" title="(1)通配符"></a><strong>(1)通配符</strong></h5><ul>
<li>*<strong>：匹配0或多个任意字符</strong></li>
<li><strong>？：匹配单个任意字符</strong></li>
<li><strong>[ ]：匹配一组字符中的单个，如[1-5] [a-f]</strong></li>
</ul>
<h5 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="(2)命令格式"></a><strong>(2)命令格式</strong></h5><p>​    <strong>命令格式 ：命令 [-选项] [参数]</strong> </p>
<p>​    <strong>例 ： ls -la /etc</strong> </p>
<p>​    <strong>说明：1）个别命令使用不遵循此格式</strong></p>
<p>​               <strong>2）当有多个选项时，可以写在一起</strong></p>
<p>​               <strong>3）简化选项与完整选项-a 等于 –all</strong></p>
<h4 id="4-1-1-文件处理命令ls"><a href="#4-1-1-文件处理命令ls" class="headerlink" title="4.1.1 文件处理命令ls"></a><strong>4.1.1 文件处理命令ls</strong></h4><h5 id="1-ls"><a href="#1-ls" class="headerlink" title="(1) ls"></a><strong>(1) <font color="red">ls</font></strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">l</font>i<font color="orange">s</font>t</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/ls</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>功能描述：显示目录文件</strong></p>
</li>
<li><p><strong>语法：<font color="orange">ls 选项[-ald] [文件或目录] </font></strong></p>
<ul>
<li><strong><font color="orange">-a </font>（–all）显示所有文件，包括隐藏文件</strong></li>
<li><strong><font color="orange">-l</font> (–list) 详细信息显示（权限，所有者等）</strong></li>
<li><strong>-m (–format=commas) 用逗号分隔的列表显示</strong></li>
<li><strong>-d 查看目录属性</strong></li>
<li><strong>-1（–format=single-column）用单独一列的方式查看结果</strong></li>
<li><strong>-r (–reverse) 以反序来显示</strong></li>
<li><strong>-X (–sort==extension) 根据文件扩展名进行字母顺序排序</strong></li>
<li><strong><font color="orange">-t</font> (–sort==time) 根据日期和时间排序</strong></li>
<li><strong>-<font color="orange">S</font> (–sort==size) 根据文件大小排序</strong></li>
<li><strong><font color="orange">-h</font> (–human-readable) 用 K M G 显示文件大小</strong></li>
<li><strong>-R （–recursive）递归遍历目录，显示该目录及其子目录的内容</strong></li>
<li><strong>-F (–classify) 显示文件的类型，*代表可执行文件，/代表目录</strong></li>
<li><strong>–color 用不同颜色显示文件类型，绿：可执行文件，蓝：文件夹，黑：普通</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">举例：</span></span><br><span class="line">ls -al		#显示所有文件详细信息</span><br><span class="line">ls -alh		#显示所有文件详细信息（包括文件大小）</span><br><span class="line">ls -alhS	#按文件大小排序显示所有文件详细信息</span><br></pre></td></tr></table></figure>

<p><strong>tip: 显示详细信息第一列字符 -rwxr-xr-x含义，分为四个字段- rwx r-x r-x</strong></p>
<ul>
<li><strong>第一个字段：- 表示二进制文件，d 表示目录，l 表示软链接文件</strong></li>
<li><strong>第二个字段：u所有者权限。r、w、x分别表示读、写、执行，- 表示无对应权限</strong></li>
<li><strong>第三个字段：g所属组权限</strong></li>
<li><strong>第四个字段：o其他人权限</strong></li>
</ul>
</li>
</ul>
<h4 id="4-1-2-目录处理命令"><a href="#4-1-2-目录处理命令" class="headerlink" title="4.1.2 目录处理命令"></a><strong>4.1.2 目录处理命令</strong></h4><h5 id="（1）mkdir"><a href="#（1）mkdir" class="headerlink" title="（1）mkdir"></a><strong>（1）<font color="red">mkdir</font></strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">m</font>a<font color="orange">k</font>e <font color="orange">dir</font>ectories</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/mkdir</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">mkdir -p  [目录名]</font></strong></p>
</li>
<li><p><strong>功能描述：创建新目录    -p 递归创建( -p 可以递归创建 在没有一级目录的情况下新创建二级目录)</strong></p>
</li>
<li><p><strong>tip：创建目录 在/tmp/目录下创建临时文件 只能创建/tmp/……二级目录</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p /tmp/Japan/boduo    <span class="comment">#(不存在Japan目录，所以要用-p递归创建)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir /tmp/Japan/longze /tmp/Japan/cangjing</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）rmdir"><a href="#（2）rmdir" class="headerlink" title="（2）rmdir"></a><strong>（2）<font color="red">rmdir</font></strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">r</font>emove e<font color="orange">m</font>pty <font color="orange">dir</font>ectories</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/rmdir</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">rmdir [目录名] </font>font&gt;</strong></p>
</li>
<li><p><strong>功能描述： 删除空目录，只能删除没有文件的空目录 （不经常使用）</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rmdir /tmp/Japan/boduo</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）cd"><a href="#（3）cd" class="headerlink" title="（3）cd"></a><strong>（3）<font color="red">cd</font></strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">c</font>hange <font color="orange">d</font>irectory</strong> </p>
</li>
<li><p><strong>命令所在路径：shell 内置</strong></p>
</li>
<li><p><strong>命令执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">cd [目录] </font></strong></p>
</li>
<li><p><strong>功能描述：切换目录</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /tmp/Japan/boduo <span class="comment">#切换到指定目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .. <span class="comment">#回到上一级目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> / <span class="comment">#回到根目录</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（4）pwd"><a href="#（4）pwd" class="headerlink" title="（4）pwd "></a><strong>（4）<font color="red">pwd </font></strong></h5><ul>
<li><strong>命令英文原意： <font color="orange">p</font>rint <font color="orange">w</font>orking <font color="orange">d</font>irectory</strong> </li>
<li><strong>命令所在路径：/bin/pwd</strong> </li>
<li><strong>执行权限：所有用户</strong></li>
<li><strong>语法：<font color="orange">pwd </font></strong></li>
<li><strong>功能描述：显示当前目录</strong></li>
<li><strong>范例：$ pwd</strong> </li>
</ul>
<h5 id="（5）cp"><a href="#（5）cp" class="headerlink" title="（5）cp"></a><strong>（5）<font color="red">cp</font></strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">c</font>o<font color="orange">p</font>y</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/cp</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">cp -rp [原文件或目录] [目标目录] </font></strong></p>
<ul>
<li><strong>-r 复制目录</strong></li>
<li><strong>-p 保留文件属性，比如保留创建时间，日志文件的复制需要用到</strong></li>
</ul>
</li>
<li><p><strong>功能描述：复制文件或目录</strong></p>
</li>
<li><p><strong>范例：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp -r /tmp/Japan/cangjing /root</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">将目录/tmp/Japan/cangjing 复制到目录/root 下</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -rp /tmp/Japan/boduo /tmp/Japan/longze /root</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">将/tmp/Japan 目录下的 boduo 和 longze 目录复制到/root 下，保持目录属性</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（6）rm"><a href="#（6）rm" class="headerlink" title="（6）rm"></a><strong>（6）<font color="red">rm</font></strong></h5><ul>
<li><strong>命令英文原意：<font color="orange">r</font>e<font color="orange">m</font>ove</strong> </li>
</ul>
<ul>
<li><strong>命令所在路径：/bin/rm</strong> </li>
</ul>
<ul>
<li><strong>执行权限：所有用户</strong></li>
</ul>
<ul>
<li><p><strong>语法：<font color="orange">rm -rf [文件或目录] </font>font&gt;</strong></p>
<ul>
<li><strong>-r 删除目录，一般是rm -rf 连着用</strong></li>
<li><strong>-f 强制执行，不在询问</strong></li>
</ul>
</li>
<li><p><strong>功能描述：删除文件或目录（-r）</strong></p>
</li>
</ul>
<ul>
<li><p><strong>范例：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm /tmp/yum.log</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">删除文件/tmp/yum.log</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf /tmp/Japan/longze</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">删除目录/tmp/Japan/longze</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-1-3-文件处理命令"><a href="#4-1-3-文件处理命令" class="headerlink" title="4.1.3 文件处理命令"></a><strong>4.1.3 文件处理命令</strong></h4><h5 id="1-touch"><a href="#1-touch" class="headerlink" title="(1) touch"></a><strong>(1) <font color="red">touch</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/touch</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">touch [文件名] 或 touch[绝对路径+文件名]</font></strong></p>
</li>
<li><p><strong>功能描述：创建空文件</strong></p>
</li>
<li><p><strong>范例： $ touch Japanlovestory.list</strong></p>
</li>
</ul>
<h5 id="2-cat"><a href="#2-cat" class="headerlink" title="(2) cat"></a><strong>(2) <font color="red">cat</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/cat</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">cat [文件名] </font></strong></p>
</li>
<li><p><strong>功能描述：显示文件内容</strong> </p>
<ul>
<li> <strong>-n 显示行号</strong></li>
<li> <strong>-A 显示隐藏字符</strong></li>
</ul>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><strong>$ cat /etc/issue</strong> </li>
<li><strong>$ cat -n /etc/services</strong></li>
</ul>
</li>
</ul>
<h5 id="3-more"><a href="#3-more" class="headerlink" title="(3) more"></a><strong>(3) <font color="red">more</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/more</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">more [文件名] </font></strong></p>
<ul>
<li> <strong>(空格) 或 f 翻页</strong> </li>
<li> <strong>(Enter) 换行</strong> </li>
<li> <strong>q 或 Q 退出</strong></li>
</ul>
</li>
<li><p><strong>功能描述：分页显示文件内容,合长的文件内容</strong></p>
</li>
<li><p><strong>范例： $ more /etc/services</strong></p>
</li>
</ul>
<h5 id="4-less"><a href="#4-less" class="headerlink" title="(4) less"></a><strong>(4) <font color="red">less</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/less 执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">less [文件名] </font></strong></p>
</li>
<li><p><strong>功能描述：分页显示文件内容（可向上翻页）</strong></p>
</li>
<li><p><strong>范例： $ less /etc/services</strong></p>
</li>
<li><p><strong>tips: 按下 / 后可以搜索,会反显高亮 按 q 退出（more 也可以）</strong></p>
</li>
</ul>
<h5 id="5-head"><a href="#5-head" class="headerlink" title="(5) head"></a><strong>(5) <font color="red">head</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/head</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">head [文件名] </font></strong></p>
</li>
<li><p><strong>功能描述：显示文件前面几行</strong> </p>
<ul>
<li><strong>-n 指定行数</strong></li>
</ul>
</li>
<li><p><strong>范例： $ head -n 20 /etc/services</strong></p>
</li>
</ul>
<h5 id="6-tail"><a href="#6-tail" class="headerlink" title="(6) tail"></a><strong>(6) <font color="red">tail</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/tail</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">tail [文件名] </font></strong></p>
</li>
<li><p><strong>功能描述：显示文件后面几行</strong> </p>
<ul>
<li> <strong>-n 指定行数</strong> </li>
<li> <strong>-f 动态显示文件末尾内容</strong></li>
</ul>
</li>
<li><p><strong>范例： $ tail -n 18 /etc/services</strong></p>
</li>
</ul>
<h4 id="4-1-4-文件链接命令"><a href="#4-1-4-文件链接命令" class="headerlink" title="4.1.4 文件链接命令"></a><strong>4.1.4 文件链接命令</strong></h4><h5 id="（5）ln"><a href="#（5）ln" class="headerlink" title="（5）ln"></a><strong>（5）<font color="red">ln</font></strong></h5><ul>
<li><p><strong>命令英文原意：link</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/ln</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">ln -s [原文件] [目标文件] </font></strong></p>
<ul>
<li><strong>-s 创建软链接</strong></li>
</ul>
</li>
<li><p><strong>功能描述：生成链接文件</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ln -s /etc/issue /tmp/issue.soft</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建文件/etc/issue 的软链接/tmp/issue.soft</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln /etc/issue /tmp/issue.hard</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建文件/etc/issue 的硬链接/tmp/issue.hard</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>软链接</strong></p>
<ul>
<li><strong>软链接的作用和Windows中的快捷方式是差不多的。他只不过是指向源文件安装路径的符号链接，所以大小也很小</strong></li>
<li><strong>而且它的文件类型是lrwxrwxrwx 看似三种用户都可以拥有所有权限。其实，真正拥有的权限是源文件所决定的权限 ，所以这种显示也是软链接的一大特征之一。</strong></li>
</ul>
</li>
<li><p><strong>硬链接</strong></p>
<ul>
<li><strong>硬链接就是把源文件拷贝到目标位置，而他与cp -p 最大的一点区别就是他可以同步更新，源文件有变化硬链接文件也会同时发生变化，但是如果源文件丢失或者被删除，硬链接也并不会消失</strong></li>
<li><strong>可以通过i节点来区分，源文件和硬链接文件的<font color="orange">i节点是一样的</font>，所以他们会同步更新</strong></li>
<li><strong>但是他不能跨分区放置硬链接比如：/分区 硬链接 不能放到/boot 分区</strong> </li>
<li><strong>而且不能对目录使用</strong></li>
</ul>
</li>
</ul>
<h3 id="4-2-权限管理命令"><a href="#4-2-权限管理命令" class="headerlink" title="4.2 权限管理命令"></a><strong>4.2 权限管理命令</strong></h3><h4 id="4-2-1-权限管理命令-chmod"><a href="#4-2-1-权限管理命令-chmod" class="headerlink" title="4.2.1 权限管理命令 chmod"></a><strong>4.2.1 权限管理命令 <font color="red">chmod</font></strong></h4><h5 id="（1）chmod"><a href="#（1）chmod" class="headerlink" title="（1）chmod"></a><strong>（1）chmod</strong></h5><ul>
<li><p><strong>命令英文原意：<font color="orange">ch</font>ange the permissions <font color="orange">mod</font>e of a file</strong> </p>
</li>
<li><p><strong>命令所在路径：/bin/chmod</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">chmod [{ugoa}{+-=}{rwx}] [文件或目录] </font></strong></p>
<ul>
<li><p> <strong>-R 递归修改</strong></p>
</li>
<li><p><strong>u ：所有者    g ：所属组</strong><br><strong>o ：其他人    a ：所有用户</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod g+x,o+r /tmp/testfile</span><br><span class="line"><span class="meta">#</span><span class="bash">就是把testfile文件的所属组增加执行权限，其他人增加读权限</span></span><br><span class="line">chmod a=rwx /tmp/testfile</span><br><span class="line"><span class="meta">#</span><span class="bash">就是testfile文件的所有用户增加读写执行权限</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>功能描述：改变文件或目录的权限</strong></p>
</li>
<li><p><strong>权限的数字表示 ：chmod [rwx的和,rwx的和,rwx的和]] [文件或者目录]</strong></p>
<ul>
<li><p><strong>r —- 4  w —- 2  x —- 1</strong></p>
<p><strong>例如：rwxrw-r- - 它的权限位数字表示就是 764</strong><br><strong>具体算法：</strong><br><strong>r+w+x=4+2+1=7<br>r+w=4+2+0=6<br>r=4+0+0=4</strong></p>
</li>
</ul>
</li>
<li><p><strong>chmod -R [rwx的和,rwx的和,rwx的和] [文件或目录]</strong><br><strong>这条命令与mkdir -p递归创建目录一样 这个命令把一个目录下的所有子目录的操作权限全部修改为同样的</strong></p>
</li>
</ul>
<h5 id="（2）创建用户命令"><a href="#（2）创建用户命令" class="headerlink" title="（2）创建用户命令"></a><strong>（2）创建用户命令</strong></h5><ul>
<li><strong>useradd [用户名]     创建普通用户</strong></li>
<li><strong>passwd [用户名]      用户密码</strong></li>
<li><strong>su - [用户名]             切换普通用户</strong></li>
</ul>
<h5 id="（3）权限对文件和目录的含义"><a href="#（3）权限对文件和目录的含义" class="headerlink" title="（3）权限对文件和目录的含义"></a><strong>（3）权限对文件和目录的含义</strong></h5><table>
<thead>
<tr>
<th><strong>代表字符</strong></th>
<th><strong>权限</strong></th>
<th><strong>对文件的含义</strong></th>
<th><strong>对目录的含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>r</strong></td>
<td><strong>读权限</strong></td>
<td><strong>可以查看文件内容</strong></td>
<td><strong>可以cat/more/head/tail/less</strong></td>
</tr>
<tr>
<td><strong>w</strong></td>
<td><strong>写权限</strong></td>
<td><strong>可以修改文件内容 可以vim</strong></td>
<td><strong>可以在目录中创建，删除文件，可以touch/mkdir/rmdir/rm</strong></td>
</tr>
<tr>
<td><strong>x</strong></td>
<td><strong>执行权限</strong></td>
<td><strong>可以执行文件 可以script(脚本) command(命令)</strong></td>
<td><strong>可以进入目录 可以cd</strong></td>
</tr>
</tbody></table>
<h4 id="4-2-2-其他权限管理命令"><a href="#4-2-2-其他权限管理命令" class="headerlink" title="4.2.2 其他权限管理命令"></a><strong>4.2.2 其他权限管理命令</strong></h4><h5 id="（1）chown"><a href="#（1）chown" class="headerlink" title="（1）chown"></a><strong>（1）<font color="red">chown</font></strong></h5><ul>
<li><strong>命令英文原意：<font color="orange">ch</font>ange file <font color="orange">own</font>ership</strong></li>
</ul>
<ul>
<li><strong>命令所在路径：/bin/chown</strong> </li>
</ul>
<ul>
<li><strong>执行权限：所有用户</strong></li>
</ul>
<ul>
<li><strong>语法：<font color="orange">chown [用户] [文件或目录] </font></strong></li>
</ul>
<ul>
<li><strong>功能描述：改变文件或目录的所有者 范例：$ chown shenchao fengjie</strong> </li>
</ul>
<ul>
<li><strong>改变文件 fengjie 的所有者为 shenchao</strong></li>
</ul>
<h5 id="（2）chgrp"><a href="#（2）chgrp" class="headerlink" title="（2）chgrp "></a><strong>（2）<font color="red">chgrp </font></strong></h5><ul>
<li><strong>命令英文原意：change file group ownership</strong> </li>
</ul>
<ul>
<li><strong>命令所在路径：/bin/chgrp</strong></li>
</ul>
<ul>
<li><strong>执行权限：所有用户</strong></li>
</ul>
<ul>
<li><strong>语法：<font color="orange">chgrp [用户组] [文件或目录] </font></strong></li>
</ul>
<ul>
<li><strong>功能描述：改变文件或目录的所属组</strong></li>
</ul>
<ul>
<li><strong>范例：$ chgrp lampbrother fengjie</strong> </li>
</ul>
<p> <strong>改变文件 fengjie 的所属组为 lampbrother</strong></p>
<h5 id="（3）umask"><a href="#（3）umask" class="headerlink" title="（3）umask"></a><strong>（3）<font color="red">umask</font></strong></h5><ul>
<li><strong>命令英文原意：the user file-creation mask</strong> </li>
</ul>
<ul>
<li><strong>命令所在路径：Shell 内置命令</strong></li>
</ul>
<ul>
<li><strong>执行权限：所有用户</strong></li>
</ul>
<ul>
<li><strong>语法：<font color="orange">umask [-S] </font></strong></li>
</ul>
<ul>
<li><p><strong>-S 以 rwx 形式显示新建文件缺省权限</strong></p>
</li>
<li><p><strong>功能描述：显示、设置文件的缺省权限</strong></p>
</li>
</ul>
<ul>
<li><strong>范例： $ umask -S</strong></li>
</ul>
<p><strong>tips: 新建文件是默认没有 x 权限（比如：防止木马病毒攻击）</strong></p>
<h3 id="4-3-文件搜索命令"><a href="#4-3-文件搜索命令" class="headerlink" title="4.3 文件搜索命令"></a><strong>4.3 文件搜索命令</strong></h3><h4 id="4-3-1-文件搜索命令find"><a href="#4-3-1-文件搜索命令find" class="headerlink" title="4.3.1 文件搜索命令find"></a><strong>4.3.1 文件搜索命令<font color="red">find</font></strong></h4><h5 id="（0）find-搜索范围-匹配条件"><a href="#（0）find-搜索范围-匹配条件" class="headerlink" title="（0）find [搜索范围] [匹配条件]"></a><strong>（0）find [搜索范围] [匹配条件]</strong></h5><h5 id="（1）按关键字-name-iname"><a href="#（1）按关键字-name-iname" class="headerlink" title="（1）按关键字 -name | -iname"></a><strong>（1）按关键字 -name | -iname</strong></h5><ul>
<li><p><strong><font color="orange">find [搜索范围] -name [关键字]</font> 在特定路径下搜索文件名作为关键字的文件或者目录</strong></p>
</li>
<li><p><em><em>find [搜索范围] -name [关键字]</em> 这样为带有关键字开头的任何文件都可以被搜索出来</em>*</p>
</li>
<li><p><strong>find [搜索范围] -name * [关键字] * 这样为带有关键字的任何文件都可以被搜索出来</strong></p>
</li>
<li><p><strong>find [搜索范围] -name [关键字]??? 这样搜索的是关键字后带三个字符的 几个问号为几个字符</strong></p>
</li>
<li><p><strong>find [搜索范围] -iname [关键字] 不区分大小写搜索</strong></p>
</li>
<li><p>```shell<br>$ find /etc -name init<br>#在目录/etc 中查找文件 init<br>#-iname 不区分大小写<br>$ find /etc -name <em>init</em><br>#在目录/etc 中查找文件名包含 init<br>$ find /etc -name init??？<br>#在目录/etc 中查找文件名 init 开头并有 3 个字符的<br>$ find /etc -name init*<br>#在目录/etc 中查找文件名 init 开头的<br>#tips:* 匹配任意字符，?匹配单个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">##### **（2）按文件大小 -size**</span><br><span class="line"></span><br><span class="line">- **&lt;font color=&#x27;orange&#x27;&gt;find [搜索范围] -size [数据块] &lt;/font&gt;**</span><br><span class="line"></span><br><span class="line">- **数据块前面加+表示查找大于这个大小的文件，-表示查找小于这个大小的文件，不加表示查找等于这个大小的文件(一般不常用)**</span><br><span class="line"></span><br><span class="line">- **1个数据块=512字节=0.5KB （1KB=2个数据块）**</span><br><span class="line">  **size后接的数据只能为数据块需要换算，比如需要查找大于100MB的文件**</span><br><span class="line">  **100MB=102400KB=204800个数据块**</span><br><span class="line">  **find /etc -size +204800**</span><br><span class="line">  **数据块为Linux存储文件最小单位**</span><br><span class="line"></span><br><span class="line">- ```shell</span><br><span class="line">  $ find / -size +204800 </span><br><span class="line">  #在根目录下查找大于 100MB 的文件</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）按所有者-user"><a href="#（3）按所有者-user" class="headerlink" title="（3）按所有者 -user"></a><strong>（3）按所有者 -user</strong></h5><ul>
<li><strong>find [搜索范围] -user [所有者名]</strong></li>
</ul>
<h5 id="（4）按所属组-group"><a href="#（4）按所属组-group" class="headerlink" title="（4）按所属组 -group"></a><strong>（4）按所属组 -group</strong></h5><ul>
<li><strong>find [搜索范围] -group [所属组名]</strong> </li>
</ul>
<h5 id="（5）按时间-amin-cmin-mmin"><a href="#（5）按时间-amin-cmin-mmin" class="headerlink" title="（5）按时间 -amin|-cmin|-mmin"></a><strong>（5）按时间 -amin|-cmin|-mmin</strong></h5><ul>
<li><p><strong>按访问的时间：find [搜索范围] -amin [时间]    a:access</strong></p>
</li>
<li><p><strong>按修改属性的时间：find [搜索范围] -cmin [时间]    c:change</strong></p>
</li>
<li><p><strong>按修改内容的时间find [搜索范围] -mmin [时间]    m:modify</strong></p>
</li>
<li><p><strong>+：超过多长时间     -：多长时间以内</strong></p>
</li>
</ul>
<h5 id="（6）其他"><a href="#（6）其他" class="headerlink" title="（6）其他"></a><strong>（6）其他</strong></h5><ul>
<li><p><strong>find [搜索范围] -size [数据块] -a -size [数据块]</strong><br><strong>-a：两个条件同时满足</strong><br><strong>-o：两个条件满足任意一个即可</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /etc -size +163840 -a -size -204800</span><br><span class="line"><span class="meta">#</span><span class="bash">在/etc下查找大于80MB小于100MB的文件</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>find [搜索范围] -name [关键字] -a -type f</strong><br><strong>在特定路径下搜索文件名作为关键字的文件</strong><br><strong>-type 根据不同类型查找</strong><br><strong>f：文件</strong><br><strong>d：目录</strong><br><strong>l：软链接</strong></p>
</li>
<li><p><strong>-exec：查找到文件之后并且对其进行各种操作 {} \ ;不能丢</strong></p>
<p><strong>find [搜索范围] -name [关键字] -exec ls -l {} \ ;</strong><br><strong>查找到文件之后并且对其进行查看ls操作。</strong></p>
</li>
<li><p><strong>-ok：用于询问确认 一般在删除操作的时候使用，比如：</strong><br><strong>find -user yangyang -ok rm {} \ ;</strong><br><strong>删除yangyang用户的文件 他会挨个询问你是不是确定删除</strong></p>
</li>
<li><p><strong>find [搜索范围] -inum [i节点值] 根据i节点查询</strong><br><strong>find /etc -inum 12345 -exec rm {} \ ;</strong><br><strong>删除这个i节点文件 非常方便</strong><br><strong>也可以用来查询一个文件的硬链接</strong><br><strong>find /etc inum 12345 -exec ls -l {} \ ;</strong><br><strong>因为硬链接和文件肯定在同一个分区，并且i节点一样</strong></p>
</li>
</ul>
<h4 id="4-3-2-其他文件搜索命令"><a href="#4-3-2-其他文件搜索命令" class="headerlink" title="4.3.2 其他文件搜索命令"></a><strong>4.3.2 其他文件搜索命令</strong></h4><h5 id="（1）locate"><a href="#（1）locate" class="headerlink" title="（1）locate"></a><strong>（1）<font color="red">locate</font></strong></h5><ul>
<li><strong>命令名称：locate</strong><ul>
<li><strong>命令所在路径：/usr/bin/locate</strong> </li>
<li><strong>执行权限：所有用户</strong></li>
<li><strong>语法：<font color="orange">locate 文件名</font></strong></li>
<li><strong>参数：-i 不区分大小写</strong></li>
<li><strong>功能描述：在文件资料库中查找文件，速度更快。</strong></li>
<li><strong>范例：$ locate inittab</strong></li>
<li><strong>tips:</strong><ul>
<li><strong>新建文件 locate 不到，可以 updatedb,更新文件资料库后查找</strong></li>
<li><strong>/tmp 临时文件不在文件资料库内</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="（2）which"><a href="#（2）which" class="headerlink" title="（2）which"></a><strong>（2）<font color="red">which</font></strong></h5><ul>
<li><p><strong>命令名称：which</strong></p>
</li>
<li><p><strong>命令所在路径：/usr/bin/which</strong></p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">which 命令</font></strong></p>
</li>
<li><p><strong>功能描述：搜索命令所在目录及别名信息</strong></p>
</li>
<li><p><strong>范例：$ which ls</strong></p>
</li>
</ul>
<h5 id="（3）whereis"><a href="#（3）whereis" class="headerlink" title="（3）whereis"></a><strong>（3）<font color="red">whereis</font></strong></h5><ul>
<li><p><strong>命令名称：whereis</strong></p>
</li>
<li><p><strong>命令所在路径：/usr/bin/whereis</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">whereis [命令名称] </font></strong></p>
</li>
<li><p><strong>功能描述：搜索命令所在目录及帮助文档路径</strong></p>
</li>
<li><p><strong>范例：$ whereis ls</strong></p>
</li>
</ul>
<h5 id="（4）grep"><a href="#（4）grep" class="headerlink" title="（4）grep"></a><strong>（4）<font color="red">grep</font></strong></h5><ul>
<li><p><strong>命令名称：grep</strong></p>
</li>
<li><p><strong>命令所在路径：/bin/grep</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">grep -iv [指定字串] [文件] </font></strong></p>
</li>
<li><p><strong>功能描述：在文件中搜寻字串匹配的行并输出</strong> </p>
<ul>
<li><strong>-i 不区分大小写</strong></li>
<li><strong>-v 排除指定字串</strong></li>
</ul>
</li>
<li><p><strong>范例：</strong></p>
<ul>
<li> <strong>grep mysql /root/install.log</strong></li>
<li> <strong># grep -v ^# /etc/inittab 去除以#开头的所有行信息,^表示以 XXX 开头</strong></li>
</ul>
</li>
</ul>
<h3 id="4-4-帮助命令"><a href="#4-4-帮助命令" class="headerlink" title="4.4 帮助命令"></a><strong>4.4 帮助命令</strong></h3><h5 id="（1）man"><a href="#（1）man" class="headerlink" title="（1）man"></a><strong>（1）<font color="red">man</font></strong></h5><ul>
<li><p><strong>命令英文原意：manual</strong> </p>
</li>
<li><p><strong>命令所在路径：/usr/bin/man</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">man [命令或配置文件] </font></strong></p>
<ul>
<li> <strong>(空格) 或 f 翻页</strong> </li>
<li> <strong>(Enter) 换行</strong> </li>
<li> <strong>q 或 Q 退出</strong></li>
</ul>
</li>
<li><p><strong>功能描述：获得帮助信息</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><p><strong>$ man ls</strong> </p>
<p><strong>查看 ls 命令的帮助信息</strong> </p>
</li>
<li><p><strong>$ man services</strong> </p>
<p><strong>查看配置文件 services 的帮助信息</strong></p>
</li>
<li><p><strong>1 命令的帮助   5 配置文件的帮助</strong></p>
</li>
<li><p><strong>man 5 passwd -&gt; 查看配置文件的帮助</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（2）whatis"><a href="#（2）whatis" class="headerlink" title="（2）whatis"></a><strong>（2）<font color="red">whatis</font></strong></h5><ul>
<li><p><strong>语法：<font color="orange">whatis 命令</font></strong></p>
</li>
<li><p><strong>功能描述：获得命令的简单介绍信息</strong></p>
</li>
<li><p><strong>范例：whatis ls</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ whatis ls</span><br><span class="line">ls (1)               - list directory contents</span><br><span class="line">ls (1p)              - list directory contents</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）apropos"><a href="#（3）apropos" class="headerlink" title="（3）apropos"></a><strong>（3）<font color="red">apropos</font></strong></h5><ul>
<li><strong>语法：<font color="orange">apropos 配置文件名称</font></strong></li>
<li><strong>whatis 类似于精确查找</strong></li>
<li><strong>apropos 模糊查找关键字 [功能等于 man -k ] [可以 tab 快速补全]</strong></li>
</ul>
<h5 id="（3）help"><a href="#（3）help" class="headerlink" title="（3）help"></a><strong>（3）<font color="red">help</font></strong></h5><ul>
<li><p><strong>命令所在路径：Shell 内置命令</strong></p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>功能描述：获得 Shell 内置命令的帮助信息</strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><p><strong>$ help umask</strong> </p>
<p><strong>查看 umask 命令的帮助信息</strong></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ help umask</span><br><span class="line">umask: umask [-p] [-S] [模式]</span><br><span class="line">    显示或设定文件模式掩码。</span><br><span class="line">    </span><br><span class="line">    设定用户文件创建掩码为 MODE 模式。如果省略了 MODE，则</span><br><span class="line">    打印当前掩码的值。</span><br><span class="line">    </span><br><span class="line">    如果 MODE 模式以数字开头，则被当作八进制数解析；否则是一个</span><br><span class="line">    chmod(1) 可接收的符号模式串。</span><br><span class="line">    </span><br><span class="line">    选项：</span><br><span class="line">      -p	如果省略 MODE 模式，以可重用为输入的格式输入</span><br><span class="line">      -S	以符号形式输出，否则以八进制数格式输出</span><br><span class="line">    </span><br><span class="line">    退出状态：</span><br><span class="line">    返回成功，除非使用了无效的 MODE 模式或者选项。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-4-帮助命令-1"><a href="#4-4-帮助命令-1" class="headerlink" title="4.4 帮助命令"></a><strong>4.4 帮助命令</strong></h3><h5 id="（1）man-1"><a href="#（1）man-1" class="headerlink" title="（1）man"></a><strong>（1）<font color="red">man</font></strong></h5><ul>
<li><p><strong>命令英文原意：manual</strong> </p>
</li>
<li><p><strong>命令所在路径：/usr/bin/man</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">man [命令或配置文件] </font></strong></p>
<ul>
<li> <strong>(空格) 或 f 翻页</strong> </li>
<li> <strong>(Enter) 换行</strong> </li>
<li> <strong>q 或 Q 退出</strong></li>
</ul>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">获得帮助信息</font></strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><p><strong>$ man ls</strong> </p>
<p><strong>查看 ls 命令的帮助信息</strong> </p>
</li>
<li><p><strong>$ man services</strong> </p>
<p><strong>查看配置文件 services 的帮助信息</strong></p>
</li>
<li><p><strong>1 命令的帮助   5 配置文件的帮助</strong></p>
</li>
<li><p><strong>man 5 passwd -&gt; 查看配置文件的帮助</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（2）whatis-1"><a href="#（2）whatis-1" class="headerlink" title="（2）whatis"></a><strong>（2）<font color="red">whatis</font></strong></h5><ul>
<li><p><strong>语法：<font color="orange">whatis 命令</font></strong></p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">获得命令的简单介绍信息</font></strong></p>
</li>
<li><p><strong>范例：whatis ls</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ whatis ls</span><br><span class="line">ls (1)               - list directory contents</span><br><span class="line">ls (1p)              - list directory contents</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）apropos-1"><a href="#（3）apropos-1" class="headerlink" title="（3）apropos"></a><strong>（3）<font color="red">apropos</font></strong></h5><ul>
<li><strong>语法：<font color="orange">apropos 配置文件名称</font></strong></li>
<li><strong>whatis 类似于精确查找</strong></li>
<li><strong>apropos 模糊查找关键字 [功能等于 man -k ] [可以 tab 快速补全]</strong></li>
</ul>
<h5 id="（3）help-1"><a href="#（3）help-1" class="headerlink" title="（3）help"></a><strong>（3）<font color="red">help</font></strong></h5><ul>
<li><p><strong>命令所在路径：Shell 内置命令</strong></p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">获得 Shell 内置命令的帮助信息</font></strong></p>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><p><strong>$ help umask</strong> </p>
<p><strong>查看 umask 命令的帮助信息</strong></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ help umask</span><br><span class="line">umask: umask [-p] [-S] [模式]</span><br><span class="line">    显示或设定文件模式掩码。</span><br><span class="line">    </span><br><span class="line">    设定用户文件创建掩码为 MODE 模式。如果省略了 MODE，则</span><br><span class="line">    打印当前掩码的值。</span><br><span class="line">    </span><br><span class="line">    如果 MODE 模式以数字开头，则被当作八进制数解析；否则是一个</span><br><span class="line">    chmod(1) 可接收的符号模式串。</span><br><span class="line">    </span><br><span class="line">    选项：</span><br><span class="line">      -p	如果省略 MODE 模式，以可重用为输入的格式输入</span><br><span class="line">      -S	以符号形式输出，否则以八进制数格式输出</span><br><span class="line">    </span><br><span class="line">    退出状态：</span><br><span class="line">    返回成功，除非使用了无效的 MODE 模式或者选项。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-5-用户管理命令"><a href="#4-5-用户管理命令" class="headerlink" title="4.5 用户管理命令"></a><strong>4.5 用户管理命令</strong></h3><h5 id="（1）useradd"><a href="#（1）useradd" class="headerlink" title="（1）useradd"></a><strong>（1）<font color="red">useradd</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/sbin/useradd</strong> </p>
</li>
<li><p><strong>执行权限：root</strong> </p>
</li>
<li><p><strong>语法：<font color="orange">useradd 用户名</font></strong></p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">添加新用户</font></strong></p>
</li>
<li><p><strong>范例： $ useradd zlx</strong></p>
</li>
</ul>
<h5 id="（2）passwd"><a href="#（2）passwd" class="headerlink" title="（2）passwd"></a><strong>（2）<font color="red">passwd</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/passwd</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">passwd 用户名</font></strong></p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">设置用户密码</font></strong></p>
</li>
<li><p><strong>范例：$ passwd zlx</strong></p>
</li>
<li><p><strong>tips：普通用户只能更改自己密码，root 用户可以更好所有人密码</strong></p>
</li>
</ul>
<h5 id="（3）who"><a href="#（3）who" class="headerlink" title="（3）who"></a><strong>（3）<font color="red">who</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/who</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">who</font></strong> </p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">查看登录用户信息</font></strong></p>
</li>
<li><p><strong>范例： $ who</strong></p>
</li>
<li><p><strong>tips</strong></p>
<ul>
<li><strong>第一列 登陆用户名</strong></li>
<li><strong>第二列 登陆终端 【tty表示本地终端 pts表示远程登陆终端】</strong></li>
<li><strong>第三列 登陆时间</strong></li>
<li><strong>第四列 登陆主机的IP地址 【如果没有写表示本机登陆】</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost ~]$ who</span><br><span class="line">zlx      tty2         2021-08-15 15:07 (tty2)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（4）w"><a href="#（4）w" class="headerlink" title="（4）w"></a><strong>（4）<font color="red">w</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/w</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：<font color="orange">w </font></strong></p>
</li>
<li><p><strong>功能描述：<font color="cornflowerblue">查看登录用户详细信息</font></strong></p>
</li>
<li><p><strong>范例： $ w</strong></p>
</li>
<li><p><strong>第一行显示 “16:02:04 up 56 min,  1 user,  load average: 0.03, 0.05, 0.01”</strong>  </p>
<ul>
<li><strong>第一个 表示当前时间</strong></li>
<li><strong>第二个 表示服务区系统连续运行时间，没有重启或者关机，衡量服务区稳定性</strong></li>
<li><strong>第三个 表示当前总共有多少个用户登陆</strong></li>
<li><strong>第四个 表示负载均衡指数，分别记录了过去一分钟，五分钟，十五分钟系统的负载情况，加起来除以三就是平均负载指数，系统的负载情况主要是指 CPU和内存的负载情况，数字大表示负载严重</strong></li>
<li><strong>uptime命令也可以显示此项数据</strong></li>
</ul>
</li>
<li><p><strong>第二行显示 “USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT”</strong></p>
<ul>
<li><strong>IDLE：表示用户登录过来后空闲多久</strong></li>
<li><strong>JCPU：表示累计占用CPU时间</strong></li>
<li><strong>PCPU：表示用户登录后执行的操作占用的CPU时间</strong></li>
<li><strong>WHAT：表示执行的操作</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16:02:04 up 56 min,  1 user,  load average: 0.03, 0.05, 0.01</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">zlx      tty2     tty2             15:07   56:16  59.42s  0.15s /usr/libexec/gsd-disk-</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-6-压缩解压命令"><a href="#4-6-压缩解压命令" class="headerlink" title="4.6 压缩解压命令"></a><strong>4.6 压缩解压命令</strong></h3><h5 id="（1）gzip-和-gunzip"><a href="#（1）gzip-和-gunzip" class="headerlink" title="（1）gzip 和 gunzip"></a><strong>（1）<font color="red">gzip 和 gunzip</font></strong></h5><ul>
<li><strong>gzip [文件名] ： 压缩文件，只能压缩文件不能压缩目录，而且不保留原文件压缩后格式为：.gz</strong></li>
<li><strong>gunzip [压缩包名] ：解压缩.gz文件</strong></li>
<li><strong>gzip -d [压缩包名] ：解压缩.gz文件</strong></li>
</ul>
<h5 id="（2）tar"><a href="#（2）tar" class="headerlink" title="（2）tar"></a><strong>（2）<font color="red">tar</font></strong></h5><ul>
<li><strong>压缩 c：</strong><ul>
<li><strong><font color="orange">tar [选项] [压缩后文件名] [目录]</font></strong><ul>
<li><strong>-c 打包</strong></li>
<li><strong>-v 显示详细信息</strong></li>
<li><strong>-f 指定文件名</strong></li>
<li><strong>-z 打包同时压缩</strong></li>
</ul>
</li>
<li><strong>例子：</strong><ul>
<li><strong>tar -cfv Japan.tar Japan</strong><br><strong>打包目录Japan 并且以Japan.tar命名</strong></li>
<li><strong><font color="cornflowerblue">tar -zcfv Japan.tar.gz Japan</font></strong><br><strong>打包并且压缩 目录Japan 以Japan.tar.gz命名</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>解压缩 x：</strong><ul>
<li><strong>tar [选项] [压缩文件名] [目录]</strong><ul>
<li><strong>-x 解包</strong></li>
<li><strong>-v 显示详细信息</strong></li>
<li><strong>-f 指定解压文件名</strong></li>
<li><strong>-z 解压缩</strong></li>
</ul>
</li>
<li><strong>例子：</strong><ul>
<li><strong>tar -xfv Japan.tar Japan</strong><br><strong>解包目录Japan.tar并且以Japan命名</strong></li>
<li><strong><font color="cornflowerblue">tar -zxfv Japan.tar.gz</font></strong><br><strong>解压缩并且解包目录Japan.tar.gz以Japan命名</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="（3）zip-和-unzip"><a href="#（3）zip-和-unzip" class="headerlink" title="（3）zip 和 unzip"></a><strong>（3）<font color="red">zip 和 unzip</font></strong></h5><ul>
<li><strong>zip [选项] [压缩后文件或目录名] [文件或目录]：原文件会保留 而且提示压缩比 deflated</strong><br><strong>没有gzip压缩比大，不常用。</strong></li>
<li><strong>压缩后格式为：.zip    zip -r：压缩目录</strong></li>
<li><strong>unzip [压缩文件] ：解压zip文件</strong></li>
</ul>
<p><strong>#####</strong> </p>
<h5 id="（4）bzip2-和-bunzip2"><a href="#（4）bzip2-和-bunzip2" class="headerlink" title="（4）bzip2 和 bunzip2"></a><strong>（4）<font color="red">bzip2 和 bunzip2</font></strong></h5><ul>
<li><strong>bzip2 [选项] [文件名] ：压缩文件，大型文件一般用这个压缩</strong></li>
<li><strong>例子：</strong><ul>
<li><strong>bzip2 -k Japan</strong><br><strong>-k：保留原文件 如果不需保留可去掉。生成Japan.bz2压缩文件</strong></li>
<li><strong>他还可以与tar结合使用</strong><br><strong>tar -cjfv Japan.tar.bz2 Japan</strong></li>
</ul>
</li>
<li><strong>bunzip2 [选项] [压缩文件名]： 解压文件</strong><ul>
<li><strong>-k：保留压缩包</strong></li>
<li><strong>与tar结合使用</strong><br><strong>tar -xjfv Japan.tar.bz2 Japan</strong></li>
</ul>
</li>
</ul>
<h3 id="4-7-网络命令"><a href="#4-7-网络命令" class="headerlink" title="4.7 网络命令"></a><strong>4.7 网络命令</strong></h3><h5 id="（1）write"><a href="#（1）write" class="headerlink" title="（1）write"></a><strong>（1）<font color="red">write</font></strong></h5><ul>
<li><p><strong>指令所在路径：/usr/bin/write</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：write &lt;用户名&gt;</strong> </p>
</li>
<li><p><strong>功能描述：给用户发信息，以 Ctrl+D 保存结束</strong></p>
</li>
<li><p><strong>范例： # write linzhiling</strong></p>
</li>
<li><p><strong>tips:输入错误，control+delete 删除</strong> </p>
</li>
</ul>
<h5 id="（2）wall"><a href="#（2）wall" class="headerlink" title="（2）wall"></a><strong>（2）<font color="red">wall</font></strong></h5><ul>
<li><p><strong>命令英文原意：write all</strong> </p>
</li>
<li><p><strong>指令所在路径：/usr/bin/wall</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：wall [message]</strong> </p>
</li>
<li><p><strong>功能描述：发广播信息</strong></p>
</li>
<li><p><strong>范例： # wall ShenChao is a honest man!</strong></p>
</li>
</ul>
<h5 id="（3）ping"><a href="#（3）ping" class="headerlink" title="（3）ping"></a><strong>（3）<font color="red">ping</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/ping</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：ping 选项 IP 地址</strong> </p>
</li>
<li><p><strong>-c 指定发送次数</strong></p>
</li>
<li><p><strong>功能描述：测试网络连通性</strong></p>
</li>
<li><p><strong>范例： # ping 192.168.1.156</strong></p>
</li>
</ul>
<h5 id="（4）ifconfig"><a href="#（4）ifconfig" class="headerlink" title="（4）ifconfig"></a><strong>（4）<font color="red">ifconfig</font></strong></h5><ul>
<li><p><strong>命令所在路径：/sbin/ifconfig</strong> </p>
</li>
<li><p><strong>执行权限：root</strong> </p>
</li>
<li><p><strong>语法：ifconfig 网卡名称 IP 地址</strong></p>
</li>
<li><p><strong>功能描述：查看和设置网卡信息</strong></p>
</li>
<li><p><strong>范例：# ifconfig eth0 192.168.8.250</strong></p>
</li>
</ul>
<h5 id="（5）mail"><a href="#（5）mail" class="headerlink" title="（5）mail"></a><strong>（5）<font color="red">mail</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/mail 执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：mail [用户名]</strong> </p>
</li>
<li><p><strong>功能描述：查看发送电子邮件</strong></p>
</li>
<li><p><strong>范例：# mail root</strong></p>
</li>
</ul>
<h5 id="（6）last"><a href="#（6）last" class="headerlink" title="（6）last"></a><strong>（6）<font color="red">last</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/last</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：last</strong> </p>
</li>
<li><p><strong>功能描述：列出目前与过去登入系统的用户信息</strong></p>
</li>
<li><p><strong>范例：# last</strong></p>
</li>
</ul>
<h5 id="（7）lastlog"><a href="#（7）lastlog" class="headerlink" title="（7）lastlog"></a><strong>（7）<font color="red">lastlog</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/lastlog</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：lastlog</strong> </p>
</li>
<li><p><strong>功能描述：检查某特定用户上次登录的时间</strong></p>
</li>
<li><p><strong>范例：</strong></p>
<ul>
<li><strong>#lastlog</strong> </li>
<li><strong>#lastlog -u 502</strong></li>
</ul>
</li>
</ul>
<h5 id="（8）traceroute"><a href="#（8）traceroute" class="headerlink" title="（8）traceroute"></a><strong>（8）<font color="red">traceroute</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/traceroute 执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：traceroute</strong> </p>
</li>
<li><p><strong>功能描述：显示数据包到主机间的路径</strong></p>
</li>
<li><p><strong>范例：# traceroute <a href="http://www.lampbrother.net/">www.lampbrother.net</a></strong></p>
</li>
</ul>
<h5 id="（9）netstat"><a href="#（9）netstat" class="headerlink" title="（9）netstat"></a><strong>（9）<font color="red">netstat</font></strong></h5><ul>
<li><p><strong>命令所在路径：/bin/netstat</strong> </p>
</li>
<li><p><strong>执行权限：所有用户</strong></p>
</li>
<li><p><strong>语法：netstat [选项]</strong> </p>
</li>
<li><p><strong>功能描述：显示网络相关信息</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-t ： TCP 协议</strong> </li>
<li><strong>-u ： UDP 协议</strong> </li>
<li><strong>-l ： 监听</strong> </li>
<li><strong>-r ： 路由</strong> </li>
<li><strong>-n ： 显示 IP 地址和端口号</strong></li>
</ul>
</li>
<li><p><strong>范例：</strong> </p>
<ul>
<li><strong># netstat -tlun 查看本机监听的端口</strong></li>
<li><strong># netstat -an 查看本机所有的网络连接</strong> </li>
<li><strong># netstat -rn 查看本机路由表</strong></li>
<li><strong>查看某一端口是否被占用：netstat -tunlp |grep 2181</strong></li>
</ul>
</li>
</ul>
<h5 id="（10）setup"><a href="#（10）setup" class="headerlink" title="（10）setup"></a><strong>（10）<font color="red">setup</font></strong></h5><ul>
<li><p><strong>命令所在路径：/usr/bin/setup</strong> </p>
</li>
<li><p><strong>执行权限：root</strong> </p>
</li>
<li><p><strong>语法：setup</strong> </p>
</li>
<li><p><strong>功能描述：配置网络</strong></p>
</li>
<li><p><strong>范例：# setup</strong></p>
</li>
</ul>
<h3 id="4-8-挂载命令"><a href="#4-8-挂载命令" class="headerlink" title="4.8 挂载命令"></a><strong>4.8 挂载命令</strong></h3><h5 id="（1）mount"><a href="#（1）mount" class="headerlink" title="（1）mount"></a><strong>（1）<font color="red">mount</font></strong></h5><ul>
<li><strong>命令位置：/bin/mount</strong> </li>
<li><strong>执行权限：所有用户</strong></li>
<li><strong>命令语法：mount [-t 文件系统] 设备文件名 挂载点</strong></li>
<li><strong>范例：# mount -t iso9660 /dev/sr0 /mnt/cdrom</strong></li>
</ul>
<h5 id="（2）步骤分析"><a href="#（2）步骤分析" class="headerlink" title="（2）步骤分析"></a><strong>（2）步骤分析</strong></h5><ul>
<li><p><strong>第一步</strong></p>
<p><strong>放入光盘，虚拟机中放入，或者服务器下载ios文件</strong></p>
</li>
<li><p><strong>第二步</strong></p>
<p><strong>创建一个空目录，设为挂载点    mkdir /media/cdrom</strong> </p>
<p><strong>/media用来做光盘挂载的，/mnt 也可以</strong></p>
</li>
<li><p><strong>第三步</strong></p>
<p><strong>输入命令    mount -t iso9660 /dev/sr0 /media/cdrom</strong></p>
<p><strong>设备文件名默认就是/dev/sr0，文件系统为iso9660 它是国际标准的cd文件格式，它告诉mount命令，我要挂载的是一个标准的cd。</strong></p>
<p><strong>/dev/cdrom也可以写 /dev/sr0，/dev/cdrom是sr0的软链接</strong></p>
</li>
<li><p><strong>第四步</strong></p>
<p><strong>进入挂载后的盘符    cd /media/cdrom</strong></p>
</li>
<li><p><strong>第五步</strong></p>
<p><strong>卸载光盘</strong></p>
<p><strong>先退出/media/cdrom，输入命令：cd；然后再输入命令：umount /dev/sr0</strong></p>
<p><strong>注意：如果之前挂载过其他盘，需要卸载之后才能挂载，输入命令：<br>umount /dev/sr0</strong></p>
</li>
</ul>
<h3 id="4-9-关机重启命令"><a href="#4-9-关机重启命令" class="headerlink" title="4.9 关机重启命令"></a><strong>4.9 关机重启命令</strong></h3><h5 id="（1）shutdown"><a href="#（1）shutdown" class="headerlink" title="（1）shutdown"></a><strong>（1）<font color="red">shutdown</font></strong></h5><ul>
<li><p><strong>语法：shutdown [选项] 时间</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><p><strong>-c：取消前一个关机命令</strong><br><strong>-h：关机</strong><br><strong>-r：重启</strong></p>
</li>
<li><p><strong>时间选项</strong></p>
<p><strong>now 现在关机</strong><br><strong>20:30 八点半关机</strong></p>
</li>
</ul>
</li>
<li><p><strong>范例：</strong></p>
<ul>
<li><strong>shutdown -h now 关机</strong></li>
<li><strong>shutdown -c 取消上一次设定的关机时间</strong></li>
<li><strong>在服务器上重启需要谨慎，需要先停掉服务，否则物理内存会坏</strong><br><strong>而且远程服务器只能重启，关机后需要管理员手动开机</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）其他关机命令"><a href="#（2）其他关机命令" class="headerlink" title="（2）其他关机命令"></a><strong>（2）其他关机命令</strong></h5><ul>
<li><strong>halt</strong></li>
<li><strong>poweroff 相当于直接断电</strong></li>
<li><strong>init 0</strong></li>
<li><strong>推荐使用shutdown关机，会保存正在运行的服务</strong></li>
</ul>
<h5 id="（3）其他重启命令"><a href="#（3）其他重启命令" class="headerlink" title="（3）其他重启命令"></a><strong>（3）其他重启命令</strong></h5><ul>
<li><strong>reboot</strong></li>
<li><strong>init 6</strong></li>
</ul>
<h5 id="（3）系统的运行级别"><a href="#（3）系统的运行级别" class="headerlink" title="（3）系统的运行级别"></a><strong>（3）系统的运行级别</strong></h5><ul>
<li><p><strong>init 0-6</strong></p>
<ul>
<li><strong>0：关机</strong></li>
<li><strong>1：单用户 进入选项菜单 只有root用户登陆进去 相当于Windows安全模式F8，只不过没有图形界面</strong></li>
<li><strong>2：不完全多用户，不含NFS服务，没有图形界面 NFS网络文件系统，Linux之间文件传输共享方式，除了NFS服务，和3一样。</strong></li>
<li><strong>3：完全多用户，没有图形界面</strong></li>
<li><strong>4：未分配，没有图形界面</strong></li>
<li><strong>5：图形界面</strong></li>
<li><strong>6：重启</strong></li>
</ul>
</li>
<li><p><strong>查询系统运行级别：runlevel</strong></p>
</li>
<li><p><strong>退出登录命令：logout</strong></p>
<p><strong>注意：在服务器中一定要在操作完成之后退出登陆，否则其他人会直接进入你的服务器，造成非常大的损失。最基本的安全意识一定要有！！！</strong></p>
</li>
</ul>
<h2 id="第五章-文本编辑器vim"><a href="#第五章-文本编辑器vim" class="headerlink" title="第五章 文本编辑器vim"></a><strong>第五章 文本编辑器vim</strong></h2><h3 id="5-1-vim常用操作"><a href="#5-1-vim常用操作" class="headerlink" title="5.1 vim常用操作"></a><strong>5.1 vim常用操作</strong></h3><h4 id="5-1-1-vim简介"><a href="#5-1-1-vim简介" class="headerlink" title="5.1.1 vim简介"></a><strong>5.1.1 vim简介</strong></h4><ul>
<li><p><strong>Vim 是一个功能强大的全屏幕文本编辑器， 是 Linux/UNIX 上最常用的文本编辑器， 它的作用是建立、编辑、显示文本文件。</strong></p>
</li>
<li><p><strong>Vim 没有菜单，只有命令。</strong></p>
</li>
</ul>
<h4 id="5-1-2-vim工作模式"><a href="#5-1-2-vim工作模式" class="headerlink" title="5.1.2 vim工作模式"></a><strong>5.1.2 vim工作模式</strong></h4><p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210817092541707.png" alt="image-20210817092541707"></strong></p>
<h5 id="（1）三种模式"><a href="#（1）三种模式" class="headerlink" title="（1）三种模式"></a><strong>（1）三种模式</strong></h5><ul>
<li><p><strong>命令模式：vi/vim+文件名进入命令模式，不可以输入文字，只能识别命令</strong></p>
</li>
<li><p><strong>插入模式：按i/a/o命令进入，可继续输入文字，按Esc退出</strong></p>
</li>
<li><p><strong>编辑模式：在命令模式下按“：”，即可进入编辑模式，可以输入编辑命令，比如保持并退出。</strong></p>
</li>
</ul>
<h5 id="（2）插入命令"><a href="#（2）插入命令" class="headerlink" title="（2）插入命令"></a><strong>（2）插入命令</strong></h5><p>​    <strong>a i o</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>a</strong></td>
<td align="center"><strong>在光标所在<font color="cornflowerblue">字符后</font>插入</strong></td>
</tr>
<tr>
<td align="center"><strong>A</strong></td>
<td align="center"><strong>在光标所在行<font color="cornflowerblue">行尾</font>插入</strong></td>
</tr>
<tr>
<td align="center"><strong>i</strong></td>
<td align="center"><strong>在光标所在<font color="cornflowerblue">字符前</font>插入</strong></td>
</tr>
<tr>
<td align="center"><strong>I</strong></td>
<td align="center"><strong>在光标所在行<font color="cornflowerblue">行首</font>插入</strong></td>
</tr>
<tr>
<td align="center"><strong>o</strong></td>
<td align="center"><strong>在光标下插入新行</strong></td>
</tr>
<tr>
<td align="center"><strong>O</strong></td>
<td align="center"><strong>在光标上插入新行</strong></td>
</tr>
</tbody></table>
<h5 id="（3）定位命令"><a href="#（3）定位命令" class="headerlink" title="（3）定位命令"></a><strong>（3）定位命令</strong></h5><p>​    <strong>G</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>:set nu</strong></td>
<td align="center"><strong>设置行号</strong></td>
</tr>
<tr>
<td align="center"><strong>:set nonu</strong></td>
<td align="center"><strong>取消行号</strong></td>
</tr>
<tr>
<td align="center"><strong>gg</strong></td>
<td align="center"><strong>到第一行</strong></td>
</tr>
<tr>
<td align="center"><strong>G</strong></td>
<td align="center"><strong>到最后一行</strong></td>
</tr>
<tr>
<td align="center"><strong>nG</strong></td>
<td align="center"><strong>到第n行</strong></td>
</tr>
<tr>
<td align="center"><strong>: n</strong></td>
<td align="center"><strong>到第n行 和上面一样的格式</strong></td>
</tr>
<tr>
<td align="center"><strong>$</strong></td>
<td align="center"><strong>移动到行尾</strong></td>
</tr>
<tr>
<td align="center"><strong>0</strong></td>
<td align="center"><strong>移动到行首</strong></td>
</tr>
</tbody></table>
<h5 id="（4）删除命令"><a href="#（4）删除命令" class="headerlink" title="（4）删除命令"></a><strong>（4）删除命令</strong></h5><p>​    <strong>x d</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>x</strong></td>
<td align="center"><strong>删除光标所在处的字符</strong></td>
</tr>
<tr>
<td align="center"><strong>nx</strong></td>
<td align="center"><strong>删除光标所在处后n个字符</strong></td>
</tr>
<tr>
<td align="center"><strong>dd</strong></td>
<td align="center"><strong>删除光标所在行</strong></td>
</tr>
<tr>
<td align="center"><strong>ndd</strong></td>
<td align="center"><strong>删除下面n行</strong></td>
</tr>
<tr>
<td align="center"><strong>dG</strong></td>
<td align="center"><strong>删除光标所在行到文件末尾的内容</strong></td>
</tr>
<tr>
<td align="center"><strong>D</strong></td>
<td align="center"><strong>删除光标所在处到行尾内容</strong></td>
</tr>
<tr>
<td align="center"><strong>:m,nd</strong></td>
<td align="center"><strong>删除指定范围的行 m-n的行全部被删除</strong></td>
</tr>
</tbody></table>
<h5 id="（5）复制和剪切命令"><a href="#（5）复制和剪切命令" class="headerlink" title="（5）复制和剪切命令"></a><strong>（5）复制和剪切命令</strong></h5><p>​    <strong>yy dd p</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>yy</strong></td>
<td align="center"><strong>复制当前行</strong></td>
</tr>
<tr>
<td align="center"><strong>nyy</strong></td>
<td align="center"><strong>复制当前行以下n行</strong></td>
</tr>
<tr>
<td align="center"><strong>dd</strong></td>
<td align="center"><strong>剪切当前行</strong></td>
</tr>
<tr>
<td align="center"><strong>ndd</strong></td>
<td align="center"><strong>剪切当前行以下n行</strong></td>
</tr>
<tr>
<td align="center"><strong>p</strong></td>
<td align="center"><strong>粘贴在当前光标所在行下</strong></td>
</tr>
<tr>
<td align="center"><strong>P</strong></td>
<td align="center"><strong>粘贴在当前光标所在行上</strong></td>
</tr>
</tbody></table>
<h5 id="（6）替换和取消命令"><a href="#（6）替换和取消命令" class="headerlink" title="（6）替换和取消命令"></a><strong>（6）替换和取消命令</strong></h5><p>​    <strong>r R</strong></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>r</strong></td>
<td><strong>替换光标所在处字符</strong></td>
</tr>
<tr>
<td><strong>R</strong></td>
<td><strong>从光标所在处开始替换字符，按Esc结束</strong></td>
</tr>
<tr>
<td><strong>u</strong></td>
<td><strong>撤消上一操作</strong></td>
</tr>
</tbody></table>
<h5 id="（7）搜索和替换命令"><a href="#（7）搜索和替换命令" class="headerlink" title="（7）搜索和替换命令"></a><strong>（7）搜索和替换命令</strong></h5><ul>
<li><p><strong>/string 搜索指定字符串string，与less命令操作类似</strong></p>
<ul>
<li><strong>搜索时忽略大小写:set ic</strong></li>
<li><strong>搜索时不忽略大小写:set noic</strong></li>
<li><strong>n 搜索指定字符串的下一个出现位置</strong></li>
</ul>
</li>
<li><p><strong>:%s/oldString/newString/g   不询问,全文替换指定字符串</strong></p>
</li>
<li><p><strong>:%s/oldString/newString/c   询问确认，全文替换指定字符串</strong></p>
</li>
<li><p><strong>:m,ns/oldString/newString/g 在一定范围内替换指定字符串</strong></p>
</li>
</ul>
<h5 id="（8）保持和退出命令"><a href="#（8）保持和退出命令" class="headerlink" title="（8）保持和退出命令"></a><strong>（8）保持和退出命令</strong></h5><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>:w</strong></td>
<td><strong>保存修改</strong></td>
</tr>
<tr>
<td><strong>:w new_filename</strong></td>
<td><strong>另存为指定文件</strong></td>
</tr>
<tr>
<td><strong>:wq</strong></td>
<td><strong>保存修改并退出</strong></td>
</tr>
<tr>
<td><strong>ZZ</strong></td>
<td><strong>快捷键，保存修改退出</strong></td>
</tr>
<tr>
<td><strong>:q!</strong></td>
<td><strong>不保存修改退出</strong></td>
</tr>
<tr>
<td><strong>:wq!</strong></td>
<td><strong>保存修改并退出（所有者或root可用）</strong></td>
</tr>
</tbody></table>
<h3 id="5-2-vim使用技巧"><a href="#5-2-vim使用技巧" class="headerlink" title="5.2 vim使用技巧"></a><strong>5.2 vim使用技巧</strong></h3><ol>
<li><strong><font color="red">：r  !命令</font></strong><ul>
<li><strong>描述：在当前vim文档中，导入命令执行结果</strong></li>
<li><strong>例子：r !date 直接把当前时间导入当前的Vim文档</strong></li>
</ul>
</li>
<li><strong><font color="red">：map [快捷键] [触发命令] </font></strong><ul>
<li><strong>描述：定义快捷键</strong></li>
<li><strong>注意：其中快捷键需要按ctrl+v+需要设定的键位，设定好之后颜色会变，比如想设定ctrl p为快捷键那么就按ctrl+v+p 会出现^P ，不能按shift+6出现的^,这两个虽然看起来一样但是颜色不一样。触发命令按需要执行的命令的先后顺序来排列，比如给脚本加注释#键就可以把[触发命令]设为I#</strong></li>
<li><strong>例子：map ^P I#  给脚本行首加#注释</strong></li>
</ul>
</li>
<li><strong><font color="red">：m,ns/^/#/g </font></strong><ul>
<li><strong>描述：指定连续行注释</strong></li>
</ul>
</li>
<li><strong><font color="red">：m,ns/^#//g </font></strong><ul>
<li><strong>描述：取消连续行注释</strong></li>
</ul>
</li>
<li><strong><font color="red">：m,ns/^/ \ / \ //g </font></strong><ul>
<li><strong>描述：给连续行首加//</strong> </li>
<li><strong>注意//是//的转义</strong></li>
</ul>
</li>
<li><strong><font color="red">：ab [a内容][b内容]</font></strong><ul>
<li><strong>描述：替换，会自动把b内容替换成a</strong></li>
<li><strong>例子：ab mymail <a href="mailto:&#49;&#53;&#51;&#48;&#x32;&#x36;&#56;&#x37;&#56;&#x31;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;">&#49;&#53;&#51;&#48;&#x32;&#x36;&#56;&#x37;&#56;&#x31;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;</a>  当你在vim文档中输入mymail时按回车或者空格会自动变成<a href="mailto:&#x31;&#53;&#51;&#48;&#50;&#x36;&#x38;&#x37;&#56;&#49;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;">&#x31;&#53;&#51;&#48;&#50;&#x36;&#x38;&#x37;&#56;&#49;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;</a></strong></li>
</ul>
</li>
<li><strong>注意：定义的快捷键或ab的内容重启后会消失，这时需要我们在用户的家目录下写配置文件.vimrc，保持快捷键</strong><ul>
<li><strong>root用户在/root/.vimrc</strong></li>
<li><strong>其他用户在/home/username/.vimrc中编辑</strong></li>
</ul>
</li>
</ol>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vim%E9%94%AE%E7%9B%98%E5%9B%BE.gif" alt="vim键盘图"></strong></p>
<h2 id="第六章-软件包管理"><a href="#第六章-软件包管理" class="headerlink" title="第六章 软件包管理"></a><strong>第六章 软件包管理</strong></h2><h3 id="6-1-软件包管理简介"><a href="#6-1-软件包管理简介" class="headerlink" title="6.1 软件包管理简介"></a><strong>6.1 软件包管理简介</strong></h3><h4 id="6-1-1-源码包"><a href="#6-1-1-源码包" class="headerlink" title="6.1.1 源码包"></a><strong>6.1.1 源码包</strong></h4><p><strong>可以看到源代码，但是安装时间较慢；脚本安装包 类似Windows安装软件， 他是写了安装界面的源码包</strong></p>
<ul>
<li><strong>优点：</strong><ul>
<li><strong>1.开源，如果有足够的能力，可以修改源代码</strong></li>
<li><strong>2.可以自由选择所需的功能</strong></li>
<li><strong>3.软件是编译安装，所以更适合自己的系统，使用更加稳定也效率更高</strong></li>
<li><strong>4.卸载方便，直接删除安装目录</strong></li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>1.安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误</strong></li>
<li><strong>2.编译过程时间较长，安装比二进制安装时间长</strong></li>
<li><strong>3.因为是编译安装，安装过程中一旦报错新手很难解决</strong></li>
</ul>
</li>
</ul>
<h4 id="6-1-2-二进制包"><a href="#6-1-2-二进制包" class="headerlink" title="6.1.2 二进制包"></a><strong>6.1.2 二进制包</strong></h4><p><strong><font color="red">RPM包</font>，系统默认包，厂商已经进行了编译，看不到源代码，但是安装时间较快</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><strong>1.包管理系统简单，只通过几个命令就可以实现包的安装，升级，查询和卸载</strong></li>
<li><strong>2.安装速度比源码包安装快得多</strong></li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li><strong>1.经过编译，不再可以看到源代码</strong></li>
<li><strong>2.功能选择不如源码包灵活</strong></li>
<li><strong>3.<font color="orange">依赖性</font> ：依赖性指的是要想安装A包就得先安装B包，要想安装B包又得先安装C包，所以只能以CBA的顺序安装RPM包，删除的时候得按ABC顺序删除安装包，基本上所有的RPM包全有依赖性</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm 是由红帽公司开发的软件包管理方式，使用 rpm 我们可以方便的进行软件的安装、查询、卸载、升</span><br><span class="line">级等工作。但是 rpm 软件包之间的依赖性问题往往会很繁琐,尤其是软件由多个 rpm 包组成时。</span><br><span class="line">yum（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包</span><br><span class="line">管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关</span><br><span class="line">系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-2-rpm命令管理"><a href="#6-2-rpm命令管理" class="headerlink" title="6.2 rpm命令管理"></a><strong>6.2 rpm命令管理</strong></h3><h4 id="6-2-1-包命名与依赖性"><a href="#6-2-1-包命名与依赖性" class="headerlink" title="6.2.1 包命名与依赖性"></a><strong>6.2.1 包命名与依赖性</strong></h4><h5 id="（1）rpm包命名规则"><a href="#（1）rpm包命名规则" class="headerlink" title="（1）rpm包命名规则"></a><strong>（1）rpm包命名规则</strong></h5><p>​    <strong>Httpd-2.2.15.el6.centos.1.i686.rpm</strong></p>
<ul>
<li><strong>Httpd 软件包包名</strong></li>
<li><strong>2.2.15 软件版本</strong><br><strong>15 软件发布的次数</strong></li>
<li><strong>el6.centos 适合的Linux平台</strong></li>
<li><strong>i686 适合的硬件平台 noarch 表示任何硬件平台都可以安装</strong></li>
<li><strong>rpm rpm包扩展名</strong><br><strong>如果自己组建rpm包，都以rpm结尾，这样更加清晰，其他管理员可以明白</strong></li>
<li><strong>注意：Httpd-2.2.15.el6.centos.1.i686.rpm为包全名，Httpd 为包名是有区别的，Linux系统命令严格区分两者</strong></li>
</ul>
<h5 id="（2）依赖性"><a href="#（2）依赖性" class="headerlink" title="（2）依赖性"></a><strong>（2）依赖性</strong></h5><ul>
<li><strong>树形依赖：a→b→c</strong></li>
<li><strong>环形依赖：a→b→c→a</strong><br><strong>环形依赖需要把a,b,c三个同时安装</strong></li>
<li><strong>模块依赖：模块依赖查询网站：<a href="http://www.rpmfind.net/">www.rpmfind.net</a></strong><br><strong>如果安装时遇到问题，出现依赖性错误</strong><br><strong>被依赖文件以.so.[数字]结尾的为库依赖，需要直接安装这个软件，错误会自动解决</strong><br><strong>安装这个包时需要进入网站 <a href="http://www.rpmfind.net.查询被依赖文件/">www.rpmfind.net.查询被依赖文件</a></strong></li>
</ul>
<h4 id="6-2-2-安装、升级与卸载"><a href="#6-2-2-安装、升级与卸载" class="headerlink" title="6.2.2 安装、升级与卸载"></a><strong>6.2.2 安装、升级与卸载</strong></h4><h5 id="（1）包全名与包名"><a href="#（1）包全名与包名" class="headerlink" title="（1）包全名与包名"></a><strong>（1）包全名与包名</strong></h5><ul>
<li><strong>包全名：操作的包是没有安装的软件包时， 使用包全名。而且要注意路径</strong></li>
<li><strong>包名：：操作已经安装的软件包时，使用包名。是默认在搜索/var/lib/rpm中的数据库</strong></li>
</ul>
<h5 id="（2）rpm安装"><a href="#（2）rpm安装" class="headerlink" title="（2）rpm安装"></a><strong>（2）rpm安装</strong></h5><ul>
<li><p><strong>rpm –ivh 包全名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-i（install） 安装</strong> </li>
<li><strong>-v（verbose） 显示详细信息</strong> </li>
<li><strong>-h（hash） 显示进度</strong> </li>
<li><strong>–nodeps 不检测依赖性。 一般不用，安装时都得显示依赖性</strong></li>
</ul>
</li>
</ul>
<h5 id="（3）rpm包升级"><a href="#（3）rpm包升级" class="headerlink" title="（3）rpm包升级"></a><strong>（3）rpm包升级</strong></h5><ul>
<li><p><strong>rpm -Uvh 包全名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-U（upgrade） 升级</strong></li>
</ul>
</li>
</ul>
<h5 id="（4）rpm卸载"><a href="#（4）rpm卸载" class="headerlink" title="（4）rpm卸载"></a><strong>（4）rpm卸载</strong></h5><ul>
<li><p><strong>rpm -e 包名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-e（erase） 卸载</strong> </li>
<li><strong>–nodeps 不检查依赖性</strong></li>
</ul>
</li>
</ul>
<h4 id="6-2-3-查询"><a href="#6-2-3-查询" class="headerlink" title="6.2.3 查询"></a><strong>6.2.3 查询</strong></h4><h5 id="（1）查询是否安装"><a href="#（1）查询是否安装" class="headerlink" title="（1）查询是否安装"></a><strong>（1）查询是否安装</strong></h5><ul>
<li><p><strong>rpm -q 包名</strong></p>
<ul>
<li><strong>查询包是否安装</strong></li>
<li><strong>选项： -q 查询（query）</strong></li>
</ul>
</li>
<li><p><strong>rpm –qa</strong> </p>
<ul>
<li><strong>查询所有已经安装的 RPM <em>包</em></strong></li>
<li><strong>选项：-a 所有（all）</strong></li>
</ul>
</li>
<li><p><strong>rpm -qa | grep [关键字]</strong></p>
<ul>
<li><strong>查询所有含义关键字的包，| 为管道符 。作用是管道符左边命令的输出就会作为管道符右边命令的输入</strong></li>
<li><strong>注意：</strong><br><strong>1、管道命令只处理前一个命令正确输出，不处理错误输出。</strong><br><strong>2、管道命令右边命令，必须能够接收标准输入流命令才行。</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）查询软件包详细信息"><a href="#（2）查询软件包详细信息" class="headerlink" title="（2）查询软件包详细信息"></a><strong>（2）查询软件包详细信息</strong></h5><ul>
<li><p><strong>rpm –qi 包名</strong></p>
</li>
<li><p><strong>查询安装过的软件包的详细信息</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-i 查询软件信息（information）</strong> </li>
<li><strong>-p 查询未安装包信息（package）</strong></li>
</ul>
</li>
</ul>
<h5 id="（3）查询包中文件安装位置"><a href="#（3）查询包中文件安装位置" class="headerlink" title="（3）查询包中文件安装位置"></a><strong>（3）查询包中文件安装位置</strong></h5><ul>
<li><p><strong>rpm –ql 包名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-l 列表（list）</strong> </li>
<li><strong>-p 查询未安装包信息（package）</strong></li>
</ul>
</li>
</ul>
<h5 id="（4）查询系统文件属于哪个rpm包"><a href="#（4）查询系统文件属于哪个rpm包" class="headerlink" title="（4）查询系统文件属于哪个rpm包"></a><strong>（4）查询系统文件属于哪个rpm包</strong></h5><ul>
<li><p> <strong>rpm –qf 系统文件名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-f 查询系统文件属于哪个软件包（file）</strong></li>
</ul>
</li>
</ul>
<h5 id="（5）查询软件包的依赖性"><a href="#（5）查询软件包的依赖性" class="headerlink" title="（5）查询软件包的依赖性"></a><strong>（5）查询软件包的依赖性</strong></h5><ul>
<li><p><strong>rpm –qR 包名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-R 查询软件包的依赖性（requires）</strong> </li>
<li><strong>-p 查询未安装包信息（package）</strong></li>
</ul>
</li>
</ul>
<h4 id="6-2-4-校验和文件提取"><a href="#6-2-4-校验和文件提取" class="headerlink" title="6.2.4 校验和文件提取"></a><strong>6.2.4 校验和文件提取</strong></h4><h5 id="（1）rpm包校验"><a href="#（1）rpm包校验" class="headerlink" title="（1）rpm包校验"></a><strong>（1）rpm包校验</strong></h5><ul>
<li><p> <strong>rpm –V 已安装的包名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-V 校验指定 RPM 包中的文件（verify）</strong></li>
</ul>
</li>
<li><p><strong>验证内容中的 8 个信息的具体内容如下：</strong></p>
<ul>
<li><strong>S 文件大小是否改变</strong></li>
<li><strong>M 文件的类型或文件的权限（rwx）是否被改变</strong></li>
<li><strong>5 文件 MD5 校验和是否改变（可以看成文件内容是否改变）</strong></li>
<li><strong>D 设备的中，从代码是否改变</strong></li>
<li><strong>L 文件路径是否改变</strong></li>
<li><strong>U 文件的属主（所有者）是否改变</strong></li>
<li><strong>G 文件的属组是否改变</strong></li>
<li><strong>T 文件的修改时间是否改变</strong></li>
</ul>
</li>
<li><p><strong>文件类型</strong></p>
<ul>
<li><p><strong>c 配置文件（config file）</strong> </p>
</li>
<li><p><strong>d 普通文档（documentation）</strong> </p>
</li>
<li><p><strong>g “鬼”文件（ghost file），很少见，就是该文件不应该被这个RPM包包含</strong></p>
</li>
<li><p><strong>l 授权文件（license file）</strong> </p>
</li>
<li><p><strong>r 描述文件（read me）</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（2）rpm包中文件提取"><a href="#（2）rpm包中文件提取" class="headerlink" title="（2）rpm包中文件提取"></a><strong>（2）rpm包中文件提取</strong></h5><ul>
<li><strong>rpm2cpio 包全名 | cpio -idv .文件绝对路径</strong> <ul>
<li><strong>rpm2cpio ：将 rpm 包转换为 cpio 格式的命令</strong></li>
<li><strong>cpio ：是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件</strong></li>
</ul>
</li>
<li><strong>cpio 选项 &lt; [文件|设备]</strong> <ul>
<li><strong>选项：</strong> <ul>
<li><strong>-i：copy-in 模式，还原</strong> </li>
<li><strong>-d：还原时自动新建目录</strong> </li>
<li><strong>-v：显示还原过程</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-3-rpm包管理"><a href="#6-3-rpm包管理" class="headerlink" title="6.3 rpm包管理"></a><strong>6.3 rpm包管理</strong></h3><h4 id="6-3-1-IP地址配置和网络yum源"><a href="#6-3-1-IP地址配置和网络yum源" class="headerlink" title="6.3.1 IP地址配置和网络yum源"></a><strong>6.3.1 IP地址配置和网络yum源</strong></h4><h5 id="（1）IP地址配置"><a href="#（1）IP地址配置" class="headerlink" title="（1）IP地址配置"></a><strong>（1）IP地址配置</strong></h5><ul>
<li><p><strong>红帽使用<font color="orange">setup </font>命令配置IP，子网掩码，网关，DNS</strong><br><strong>然后<font color="orange">service network restart </font>重启网络服务</strong></p>
</li>
<li><p><strong>CentOS7使用<font color="orange">nmtui</font>命令配置IP，子网掩码，网关，DNS</strong><br><strong>然后service network restart 重启网络服务</strong></p>
</li>
<li><p><strong>启动网卡</strong></p>
<p> <strong>vi /etc/sysconfig/network-scripts/ifcfg-eth0</strong> </p>
<p><strong>把 ONBOOT=“no” 改为 ONBOOT=“yes“</strong> </p>
</li>
<li><p><strong>重启网络服务</strong></p>
<p><strong>service network restart</strong> </p>
</li>
</ul>
<h5 id="（2）网络yum源"><a href="#（2）网络yum源" class="headerlink" title="（2）网络yum源"></a><strong>（2）网络yum源</strong></h5><ul>
<li><p><strong><font color="red">vi /etc/yum.repos.d/CentOS-Base.repo</font></strong><br><strong>其中：</strong></p>
<ul>
<li><strong>CentOS-Base.repo为网络yum源</strong></li>
<li><strong>CentOS-Media.repo为本地磁盘yum源</strong></li>
</ul>
</li>
<li><p> <strong>进入yum内部配置文件中可以看到以下内容：</strong></p>
</li>
<li><p><strong>[base]：容器名称，一定要放在[]中</strong></p>
</li>
<li><p><strong>name：容器说明，可以自己随便写</strong></p>
</li>
<li><p><strong>mirrorlist：镜像站点，这个可以注释掉</strong></p>
</li>
<li><p><strong>baseurl：我们的yum源服务器的地址。默认是CentOS的官方的yum源服务器，是可以使用的，如果觉得慢可以改成你喜欢的yum镜像源地址</strong></p>
</li>
<li><p><strong>enabled：此容器是否生效</strong><br><strong>如果不写或者写成enable=1都是生效的，写成enable=0就是不生效</strong></p>
</li>
<li><p><strong>gpgcheck：如果1是指RPM的数字证书生效，如果是0则不生效</strong></p>
</li>
<li><p><strong>gpgkey：数字证书的公钥文件保存位置。不用修改</strong></p>
</li>
</ul>
<p>  <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211215145608598.png" alt="image-20211215145608598"></strong></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">镜像列表系统使用客户机的连接IP地址和每个镜像的更新状态来选择地理位置上的当前镜像接近客户。</span><br><span class="line">你应该在CentOS更新中使用这个，除非你手动选择其他镜像。</span><br><span class="line">如果镜像列表不适合您，您可以尝试注释掉的baseurl行。</span><br></pre></td></tr></table></figure>



<h4 id="6-3-2-yum命令"><a href="#6-3-2-yum命令" class="headerlink" title="6.3.2 yum命令"></a><strong>6.3.2 yum命令</strong></h4><h5 id="（1）常用yum命令"><a href="#（1）常用yum命令" class="headerlink" title="（1）常用yum命令"></a><strong>（1）常用yum命令</strong></h5><ul>
<li><p><strong>查询</strong></p>
<ul>
<li><strong>yum list      #查询所有可用软件包列表</strong> </li>
<li><strong>yum search 关键字     #搜索服务器上所有和关键字相关的包</strong></li>
</ul>
</li>
<li><p><strong>安装</strong></p>
<ul>
<li> <strong>yum –y install 包名</strong></li>
<li><strong>install 安装</strong></li>
<li><strong>-y 自动回答 yes</strong></li>
</ul>
</li>
<li><p><strong>升级</strong></p>
<ul>
<li><strong>yum -y update 包名、</strong></li>
<li><strong>update 升级</strong> </li>
<li><strong>-y 自动回答 yes</strong></li>
</ul>
<p><strong>==注意：yum -y update 后必须加包名，否则就是全盘更新，包括Linux内核也会更新，Linux内核在更新完成之后需要在本地进行配置，内核才可以启动，如果你是在服务器上跑这条命令，服务器直接崩溃，永远无法连接，再也不能启动！！！==</strong></p>
</li>
<li><p><strong>卸载</strong></p>
<ul>
<li> <strong>yum -y remove 包名</strong></li>
<li> <strong>remove 卸载</strong> </li>
<li><strong>-y 自动回答 yes</strong></li>
</ul>
<p><strong>==注意：yum -y remove卸载会把包所有的依赖包都会卸载，有时候会把系统文件也同时卸载，小心使用，尽量不要多用！==</strong></p>
</li>
<li><p><strong>Linux服务器安装软件包原则：</strong></p>
<p><strong>最小化安装，不安装多余软件，使用什么软件安装什么软件，手工装，尽量不卸载，尤其yum卸载尽量不要用！！！</strong></p>
</li>
</ul>
<h5 id="（2）yum软件组管理命令"><a href="#（2）yum软件组管理命令" class="headerlink" title="（2）yum软件组管理命令"></a><strong>（2）yum软件组管理命令</strong></h5><ul>
<li><p><strong>yum grouplist</strong></p>
<p><strong>#列出所有可用的软件组列表</strong> </p>
</li>
<li><p> <strong>yum groupinstall 软件组名</strong></p>
</li>
</ul>
<p>  <strong>#安装指定软件组，组名可以由 grouplist 查询出来</strong></p>
<ul>
<li><p><strong>yum groupremove 软件组名</strong></p>
<p><strong>#卸载指定软件组</strong></p>
</li>
<li><p><strong>tips:安装软件包组 有空格 用””括起来</strong></p>
</li>
</ul>
<h4 id="6-3-3-光盘yum源搭建"><a href="#6-3-3-光盘yum源搭建" class="headerlink" title="6.3.3 光盘yum源搭建"></a><strong>6.3.3 光盘yum源搭建</strong></h4><h5 id="（1）光盘yum源搭建"><a href="#（1）光盘yum源搭建" class="headerlink" title="（1）光盘yum源搭建"></a><strong>（1）光盘yum源搭建</strong></h5><ul>
<li><p><strong>第一步：挂载光盘</strong></p>
<pre><code> **mount /dev/cdrom /mnt/cdrom/** 
</code></pre>
</li>
<li><p><strong>第二步：让网络yum源失效</strong></p>
<p>​    <strong>把/etc/yum.repos.d/文件里除了CentOS-Media.repo文件的其他文件全部改名，把repo后缀改了，随便改一个，比如.bak</strong><br><strong>​    还可以让每个文件里面的enabled=0</strong></p>
</li>
</ul>
<p>​    <strong>改名具体命令： mv CentOS-Base.repo \ CentOS-Base.repo.bak</strong> </p>
<ul>
<li><p><strong>第三步：修改光盘yum源文件</strong></p>
<p>​     <strong>vim CentOS-Media.repo</strong> </p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[c6-media] 	#叫什么都可以</span><br><span class="line">name=CentOS-$releasever - Media 	# 名称叫什么都可以</span><br><span class="line">baseurl=file:///mnt/cdrom </span><br><span class="line"><span class="meta">#</span><span class="bash">地址为你自己的光盘挂载地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file:///media/cdrom/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file:///media/cdrecorder/</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">注释这两个不存在的地址 （ 不注释也没事，但是会显示报错）</span></span><br><span class="line">gpgcheck=1 </span><br><span class="line">enabled=1 </span><br><span class="line"><span class="meta">#</span><span class="bash">把 enabled=0 改为 enabled=1，让这个 yum 源配置文件生效</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure>



<h5 id="（2）Linux系统中挂载和使用光盘基本步骤"><a href="#（2）Linux系统中挂载和使用光盘基本步骤" class="headerlink" title="（2）Linux系统中挂载和使用光盘基本步骤"></a><strong>（2）Linux系统中挂载和使用光盘基本步骤</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建挂载点 </span><br><span class="line">mkdir /mnt/cdrom</span><br><span class="line">在 /mnt 目录下创建一个空文件夹 cdrom 作为光盘的挂载点（任何一个空目录都可以作为挂载点）。</span><br><span class="line"></span><br><span class="line">2. 打开光驱，放入光盘 </span><br><span class="line">如果用的是 VMware 中的虚拟机，进入虚拟机设置，选择“CD/DVD”硬件，勾选“已连接”和“启动时连接”，在连接处，选择“使用 ISO 映像文件”，浏览选择本地电脑中下载好的 ISO 光盘镜像文件，确定即可。</span><br><span class="line"></span><br><span class="line">3. 执行挂载命令</span><br><span class="line">mount -t iso9660 /dev/sr0 /mnt/cdrom</span><br><span class="line">或者</span><br><span class="line">mount /dev/sr0 /mnt/cdrom</span><br><span class="line">iso9660 是光盘的默认文件系统。</span><br><span class="line">由于 linux 系统可以自动识别光盘的文件系统，故“-t iso9660”也可以省略不写。</span><br><span class="line">光盘的设备文件名是固定的，一般为/dev/cdrom 或/dev/sr0。</span><br><span class="line">挂载成功后，就可以通过挂载点读取光盘里面的数据。</span><br><span class="line"></span><br><span class="line">4. 查看光盘中的数据</span><br><span class="line">cd /mnt/cdrom</span><br><span class="line">ls -l</span><br><span class="line">注意：操作完成之后，如果要取出光盘，必须解除挂载。</span><br><span class="line"></span><br><span class="line">5. 解除挂载</span><br><span class="line">不能在挂载点目录下解除挂载，必须先切换到其他目录（如用户家目录）。</span><br><span class="line">切换到用户家目录</span><br><span class="line">umount /dev/sr0</span><br><span class="line">或者</span><br><span class="line">umount /mnt/cdrom</span><br></pre></td></tr></table></figure>





<h3 id="6-4-源码包管理"><a href="#6-4-源码包管理" class="headerlink" title="6.4 源码包管理"></a><strong>6.4 源码包管理</strong></h3><h4 id="6-4-1-源码包和rpm包的区别"><a href="#6-4-1-源码包和rpm包的区别" class="headerlink" title="6.4.1 源码包和rpm包的区别"></a><strong>6.4.1 源码包和rpm包的区别</strong></h4><h5 id="（1）区别"><a href="#（1）区别" class="headerlink" title="（1）区别"></a><strong>（1）区别</strong></h5><p>​        <strong>安装之前的区别：概念上的区别</strong></p>
<p>​        <strong>安装之后的区别：安装位置不同</strong></p>
<h5 id="（2）rpm包安装位置"><a href="#（2）rpm包安装位置" class="headerlink" title="（2）rpm包安装位置"></a><strong>（2）rpm包安装位置</strong></h5><p>​    <strong>安装在默认位置中</strong></p>
<table>
<thead>
<tr>
<th><strong>默认安装路径</strong></th>
<th><strong>类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>/etc/</strong></td>
<td><strong>配置文件安装目录</strong></td>
</tr>
<tr>
<td><strong>/usr/bin/</strong></td>
<td><strong>可执行的命令安装目录</strong></td>
</tr>
<tr>
<td><strong>/usr/lib/</strong></td>
<td><strong>程序所使用的函数库保存位置</strong></td>
</tr>
<tr>
<td><strong>/usr/share/doc/</strong></td>
<td><strong>基本的软件使用手册保存位置</strong></td>
</tr>
<tr>
<td><strong>/usr/share/man/</strong></td>
<td><strong>帮助文件保存位置</strong></td>
</tr>
</tbody></table>
<h5 id="（3）源码包安装路径"><a href="#（3）源码包安装路径" class="headerlink" title="（3）源码包安装路径"></a><strong>（3）源码包安装路径</strong></h5><p>​    <strong>安装在指定位置中，一般是    /usr/local/软件名/</strong></p>
<h5 id="（4）安装位置不同带来的影响"><a href="#（4）安装位置不同带来的影响" class="headerlink" title="（4）安装位置不同带来的影响"></a><strong>（4）安装位置不同带来的影响</strong></h5><ul>
<li><p><strong>RPM 包安装的服务可以使用系统服务管理命令（service）来管理，例如 RPM 包安装的 apache 的启动方法是：</strong></p>
<ul>
<li><p><strong>/etc/rc.d/init.d/httpd start</strong> </p>
</li>
<li><p><strong>service httpd start</strong></p>
</li>
<li><p><strong>RPM包的启动文件全在/etc/rc.d/init.d/里，servic会搜索RPM包所有的安装路径，所以service才能启动RPM包软件，但是启动不了源码包软件，因为源码包在/usr/local里，和RPM包不一样</strong></p>
</li>
</ul>
</li>
<li><p><strong>而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如：</strong></p>
<ul>
<li><strong>/usr/local/apache2/bin/apachectl start</strong></li>
</ul>
</li>
</ul>
<h4 id="6-4-2-源码包安装过程"><a href="#6-4-2-源码包安装过程" class="headerlink" title="6.4.2 源码包安装过程"></a><strong>6.4.2 源码包安装过程</strong></h4><p><strong>以“安装Apache”为例说明</strong></p>
<h5 id="（1）安装准备"><a href="#（1）安装准备" class="headerlink" title="（1）安装准备"></a><strong>（1）安装准备</strong></h5><ul>
<li><p><strong>安装C语言编译器</strong></p>
<p><strong>yum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake</strong></p>
</li>
<li><p><strong>下载源码包</strong></p>
<p><strong><a href="http://mirror.bit.edu.cn/apache/httpd/">http://mirror.bit.edu.cn/apache/httpd/</a></strong></p>
<p><strong>选择任何版本，比如：httpd-2.4.43.tar.bz2 版本</strong></p>
</li>
</ul>
<h5 id="（2）注意事项"><a href="#（2）注意事项" class="headerlink" title="（2）注意事项"></a><strong>（2）注意事项</strong></h5><ul>
<li><p><strong>源码包保存位置：/usr/local/src</strong></p>
</li>
<li><p><strong>软件安装位置：/usr/local</strong></p>
</li>
<li><p><strong>如何确定安装过程报错：</strong></p>
<p><strong>安装过程停止，并出现error，warning或者no提示，即发生错误</strong></p>
</li>
<li><p><strong>把电脑下载好的源码包传输到Linux系统或者服务器上</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows下载WinSCP软件进行本机与虚拟机或者远程传输</span><br><span class="line"></span><br><span class="line">Mac连接远程阿里云服务器，终端使用命令 scp进行传输：</span><br><span class="line">scp -r localfile.txt username@192.168.0.1:/home/username/</span><br><span class="line">其中，</span><br><span class="line">１）scp是命令，-r是参数</span><br><span class="line">２）localfile.txt 是文件的路径和文件名</span><br><span class="line">３）username是服务器账号，一般为root</span><br><span class="line">４）192.168.0.1是要上传的服务器ip地址</span><br><span class="line">５）/home/username/是要拷入的文件夹路径，一般为/root 家目录</span><br><span class="line">例子：</span><br><span class="line">scp -r /Users/yangyangyang/Desktop/httpd-2.4.43.tar.bz2 root@47.95.5.171:/root</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）解压下载的源码包"><a href="#（3）解压下载的源码包" class="headerlink" title="（3）解压下载的源码包"></a><strong>（3）解压下载的源码包</strong></h5><ul>
<li><strong>bar.bz2压缩包：使用命令 tar -jxvf httpd-2.4.43.tar.bz2</strong></li>
<li><strong>tar.gz压缩包：使用命令tar -zxvf</strong> </li>
</ul>
<h5 id="（4）进入压缩目录"><a href="#（4）进入压缩目录" class="headerlink" title="（4）进入压缩目录"></a><strong>（4）进入压缩目录</strong></h5><ul>
<li><strong>输入命令：cd httpd-2.4.43</strong><ul>
<li><strong>INSTALL：安装说明</strong></li>
<li><strong>README：使用说明</strong></li>
</ul>
</li>
<li><strong>进入安装说明：vi INSTALL</strong><br><strong>$ ./configure –prefix=PREFIX 编译前准备</strong><br><strong>$ make 进行编译</strong><br><strong>$ make install 编译安装</strong><br><strong>$ PREFIX/bin/apachectl star 启动命令</strong></li>
<li><strong>这些为详细的安装步骤，其中：</strong><br><strong>./configure为软件配置与检查 我们也称编译前准备</strong><br><strong>1.定义需要的功能选项。</strong><br><strong>2.检测系统环境是否符合安装要求</strong><br><strong>3.把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。</strong></li>
</ul>
<h5 id="（5）定义安装路径"><a href="#（5）定义安装路径" class="headerlink" title="（5）定义安装路径"></a><strong>（5）定义安装路径</strong></h5><p>​    <strong>退出之后</strong><br><strong>​    输入命令：./configure –prefix=/usr/local/apache2</strong><br><strong>​    如果报错显示：</strong><br><strong>​    进以下网址寻求解决办法</strong><br><strong>​    <a href="http://www.cnblogs.com/yuzhaokai0523/p/4382974.html">http://www.cnblogs.com/yuzhaokai0523/p/4382974.html</a></strong></p>
<h5 id="（6）进行编译"><a href="#（6）进行编译" class="headerlink" title="（6）进行编译"></a><strong>（6）进行编译</strong></h5><p>​    <strong>输入命令：make 进行编译</strong></p>
<h5 id="（7）进行安装"><a href="#（7）进行安装" class="headerlink" title="（7）进行安装"></a><strong>（7）进行安装</strong></h5><p>​    <strong>输入命令：make install 编译安装</strong></p>
<h5 id="（8）启动"><a href="#（8）启动" class="headerlink" title="（8）启动"></a><strong>（8）启动</strong></h5><p>​    <strong>输入命令：/usr/local/apache2/bin/apachectl start</strong></p>
<p>​    <strong>$ PREFIX/bin/apachectl star中 $ PREFIX为软件安装路径</strong></p>
<h5 id="（9）启动apach遇到错误"><a href="#（9）启动apach遇到错误" class="headerlink" title="（9）启动apach遇到错误"></a><strong>（9）启动apach遇到错误</strong></h5><p>​    <strong>httpd: Could not reliably determine the server’s fully qualified domain name</strong></p>
<p>​    <strong>解决办法：</strong></p>
<p>​    <strong>1.cd /usr/local/apache2/conf</strong><br><strong>​    2.vi httpd.conf</strong><br><strong>​    找到#ServerName <a href="http://www.example.com/">www.example.com:80</a></strong><br><strong>​    并且在下面一行添加</strong><br><strong>​    ServerName localhost:80     # localhost可以换成阿里云的IP</strong><br><strong>​    3.保存并退出</strong><br><strong>​    4.再重新启动apache</strong><br><strong>​    /usr/local/apache2/bin/apachectl start</strong></p>
<h3 id="6-5-脚本包安装"><a href="#6-5-脚本包安装" class="headerlink" title="6.5 脚本包安装"></a><strong>6.5 脚本包安装</strong></h3><h4 id="6-5-1-脚本安装包"><a href="#6-5-1-脚本安装包" class="headerlink" title="6.5.1 脚本安装包"></a><strong>6.5.1 脚本安装包</strong></h4><ul>
<li><p><strong>脚本安装包并不是独立的软件包类型，常见安装的是源码包。</strong></p>
</li>
<li><p><strong>是人为把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装。</strong></p>
</li>
<li><p><strong>非常类似于 Windows 下软件的安装方式。</strong></p>
</li>
</ul>
<h4 id="6-5-2-Wemin"><a href="#6-5-2-Wemin" class="headerlink" title="6.5.2 Wemin"></a><strong>6.5.2 Wemin</strong></h4><h5 id="（1）Wemin的作用"><a href="#（1）Wemin的作用" class="headerlink" title="（1）Wemin的作用"></a><strong>（1）Wemin的作用</strong></h5><p>​    <strong>Webmin 是一个基于 Web 的 Linux 系统管理界面。您就可以通过图形化的方式设置用户帐号、Apache、DNS、文件共享等服务。</strong></p>
<h5 id="（2）安装过程"><a href="#（2）安装过程" class="headerlink" title="（2）安装过程"></a><strong>（2）安装过程</strong></h5><ul>
<li><p><strong>下载软件<a href="http://sourceforge.net/projects/webadmin/files/webmin/">http://sourceforge.net/projects/webadmin/files/webmin/</a></strong></p>
</li>
<li><p><strong>解压缩，并进入加压缩目录</strong></p>
</li>
<li><p><strong>执行安装脚本</strong></p>
</li>
</ul>
<h2 id="第七章-用户和用户组管理"><a href="#第七章-用户和用户组管理" class="headerlink" title="第七章 用户和用户组管理"></a><strong>第七章 用户和用户组管理</strong></h2><h3 id="7-1-用户配置文件"><a href="#7-1-用户配置文件" class="headerlink" title="7.1 用户配置文件"></a><strong>7.1 用户配置文件</strong></h3><h4 id="7-1-1-用户信息文件-etc-passwd"><a href="#7-1-1-用户信息文件-etc-passwd" class="headerlink" title="7.1.1 用户信息文件 /etc/passwd"></a><strong>7.1.1 用户信息文件 /etc/passwd</strong></h4><h5 id="（1）用户管理简介"><a href="#（1）用户管理简介" class="headerlink" title="（1）用户管理简介"></a><strong>（1）用户管理简介</strong></h5><ul>
<li><p><strong>越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范。</strong></p>
</li>
<li><p><strong>在 Linux 中主要是通过用户配置文件来查看和修改用户信息</strong></p>
</li>
<li><p><strong>通过命令：man 5 passwd 来查看passwd配置文件帮助信息 5代表配置文件</strong></p>
</li>
</ul>
<h5 id="（2）-etc-passwd-配置文件"><a href="#（2）-etc-passwd-配置文件" class="headerlink" title="（2）/etc/passwd 配置文件"></a><strong>（2）/etc/passwd 配置文件</strong></h5><ul>
<li><p><strong>第 1 字段：用户名称</strong></p>
</li>
<li><p><strong>第 2 字段：密码标志</strong></p>
</li>
<li><p><strong>第 3 字段：UID（用户 ID）</strong> </p>
<ul>
<li><strong>0： 超级用户</strong></li>
<li><strong>1-499： 系统用户（伪用户）</strong></li>
<li><strong>500-65535： 普通用户(centos7 从 1000 开始计算)</strong> </li>
</ul>
</li>
<li><p><strong>第 4 字段：GID（用户初始组 ID）[不推荐修改初始组]</strong> </p>
</li>
<li><p><strong>第 5 字段：用户说明</strong></p>
</li>
<li><p><strong>第 6 字段：家目录</strong></p>
<ul>
<li><strong>普通用户：/home/用户名/</strong> </li>
<li><strong>超级用户：/root/</strong> </li>
</ul>
</li>
<li><p><strong>第 7 字段：登录之后的 Shell</strong></p>
</li>
<li><p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211217154607305.png" alt="image-20211217154607305"></strong></p>
</li>
</ul>
<h5 id="（3）初始组和附加组"><a href="#（3）初始组和附加组" class="headerlink" title="（3）初始组和附加组"></a><strong>（3）初始组和附加组</strong></h5><ul>
<li><p> <strong>初始组：就是指用户一登录就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用户名相同的组名作为这个用户的初始组。</strong></p>
</li>
<li><p><strong>附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。</strong></p>
</li>
</ul>
<h5 id="（2）Shell是什么"><a href="#（2）Shell是什么" class="headerlink" title="（2）Shell是什么"></a><strong>（2）Shell是什么</strong></h5><ul>
<li><p><strong>Shell 就是 Linux 的命令解释器。</strong></p>
</li>
<li><p><strong>在/etc/passwd 当中，除了标准 Shell 是/bin/bash 之外，还可以是/sbin/nologin，/usr/bin/passwd 等。</strong></p>
</li>
<li><p><strong>tips:暂时禁用用户，可以把/bin/bash -&gt; /bin/nologin</strong></p>
</li>
</ul>
<h4 id="7-1-2-影子文件-etc-shadow"><a href="#7-1-2-影子文件-etc-shadow" class="headerlink" title="7.1.2 影子文件/etc/shadow"></a><strong>7.1.2 影子文件/etc/shadow</strong></h4><h5 id="（1）影子文件-etc-shadow"><a href="#（1）影子文件-etc-shadow" class="headerlink" title="（1）影子文件/etc/shadow"></a><strong>（1）影子文件/etc/shadow</strong></h5><ul>
<li><p><strong>第 1 字段：用户名</strong></p>
</li>
<li><p><strong>第 2 字段：加密密码</strong></p>
<ul>
<li><strong>加密算法升级为 SHA512 散列加密算法</strong></li>
<li><strong>如果密码位是“!!”或“*”代表没有密码，不能登录</strong></li>
</ul>
</li>
<li><p><strong>第 3 字段：密码最后一次修改日期</strong></p>
<ul>
<li><strong>使用 1970 年 1 月 1 日作为标准时间，每过一天时间戳加 1</strong> </li>
</ul>
</li>
<li><p><strong>第 4 字段：两次密码的修改间隔时间（和第 3 字段相比）</strong></p>
</li>
<li><p><strong>第 5 字段：密码有效期（和第 3 字段相比）</strong></p>
</li>
<li><p><strong>第 6 字段：密码修改到期前的警告天数（和第 5 字段相比）</strong></p>
</li>
<li><p><strong>第 7 字段：密码过期后的宽限天数（和第 5 字段相比）</strong></p>
<ul>
<li><strong>0：代表密码过期后立即失效</strong></li>
<li><strong>-1：则代表密码永远不会失效。</strong></li>
</ul>
</li>
<li><p> <strong>第 8 字段：账号失效时间</strong></p>
</li>
<li><p><strong>要用时间戳表示</strong></p>
</li>
<li><p><strong>第 9 字段：保留</strong></p>
</li>
</ul>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211217155913026.png" alt="image-20211217155913026"></strong></p>
<h5 id="（2）时间戳换算"><a href="#（2）时间戳换算" class="headerlink" title="（2）时间戳换算"></a><strong>（2）时间戳换算</strong></h5><ul>
<li><strong>把时间戳换算为日期</strong><ul>
<li><strong>date -d “1970-01-01 16066 days”</strong> </li>
</ul>
</li>
<li><strong>把日期换算为时间戳</strong><ul>
<li><strong>echo $(($(date –date=”2014/01/06” +%s)/86400+1))</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@iZwz9evxymdqdx2e88fv2sZ ~]# date -d &quot;1970-01-01 16066 days&quot;</span><br><span class="line">Fri Dec 27 00:00:00 CST 2013</span><br><span class="line">[root@iZwz9evxymdqdx2e88fv2sZ ~]# echo $(($(date --date=&quot;2014/01/06&quot; +%s)/86400+1))</span><br><span class="line">16076</span><br></pre></td></tr></table></figure>



<h4 id="7-1-3-组信息文件"><a href="#7-1-3-组信息文件" class="headerlink" title="7.1.3 组信息文件"></a><strong>7.1.3 组信息文件</strong></h4><h5 id="（1）组信息文件-etc-group"><a href="#（1）组信息文件-etc-group" class="headerlink" title="（1）组信息文件/etc/group"></a><strong>（1）组信息文件/etc/group</strong></h5><ul>
<li>​    <strong>第一字段：组名</strong></li>
<li>​    <strong>第二字段：组密码标志</strong></li>
<li>​    <strong>第三字段：GID</strong> </li>
<li>​    <strong>第四字段：组中附加用户</strong></li>
</ul>
<h4 id="7-1-4-组密码文件"><a href="#7-1-4-组密码文件" class="headerlink" title="7.1.4 组密码文件"></a><strong>7.1.4 组密码文件</strong></h4><h5 id="（1）组密码文件-etc-gshadow"><a href="#（1）组密码文件-etc-gshadow" class="headerlink" title="（1）组密码文件/etc/gshadow"></a><strong>（1）组密码文件/etc/gshadow</strong></h5><ul>
<li><strong>第一字段：组名</strong></li>
<li><strong>第二字段：组密码 (不推荐使用，可以理解为给组设置个小组长)</strong> </li>
<li><strong>第三字段：组管理员用户名</strong></li>
<li><strong>第四字段：组中附加用户</strong></li>
</ul>
<h3 id="7-2-用户管理相关文件"><a href="#7-2-用户管理相关文件" class="headerlink" title="7.2 用户管理相关文件"></a><strong>7.2 用户管理相关文件</strong></h3><h5 id="（1）-用户的家目录"><a href="#（1）-用户的家目录" class="headerlink" title="（1） 用户的家目录"></a><strong>（1） 用户的家目录</strong></h5><ul>
<li><p><strong>普通用户：/home/用户名/，所有者和所属组都是此用户，权限是 700</strong> </p>
</li>
<li><p><strong>超级用户：/root/，所有者和所属组都是 root 用户，权限是 550</strong> </p>
</li>
</ul>
<h5 id="（2）用户的邮箱"><a href="#（2）用户的邮箱" class="headerlink" title="（2）用户的邮箱"></a><strong>（2）用户的邮箱</strong></h5><ul>
<li><strong>/var/spool/mail/用户名/</strong> </li>
</ul>
<h5 id="（3）用户模板目录"><a href="#（3）用户模板目录" class="headerlink" title="（3）用户模板目录"></a><strong>（3）用户模板目录</strong></h5><ul>
<li><strong>/etc/skel/</strong></li>
</ul>
<h3 id="7-3-用户管理命令"><a href="#7-3-用户管理命令" class="headerlink" title="7.3 用户管理命令"></a><strong>7.3 用户管理命令</strong></h3><h4 id="7-3-1-用户添加命令-useradd"><a href="#7-3-1-用户添加命令-useradd" class="headerlink" title="7.3.1 用户添加命令 useradd"></a><strong>7.3.1 用户添加命令 useradd</strong></h4><h5 id="（1）useradd命令格式"><a href="#（1）useradd命令格式" class="headerlink" title="（1）useradd命令格式"></a><strong>（1）useradd命令格式</strong></h5><ul>
<li><p><strong>useradd [选项] 用户名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-u UID： 手工指定用户的 UID 号</strong> </li>
<li><strong>-d 家目录： 手工指定用户的家目录</strong> </li>
<li><strong>-c 用户说明： 手工指定用户的说明</strong> </li>
<li><strong>-g 组名： 手工指定用户的初始组</strong> </li>
<li><strong>-G 组名： 指定用户的附加组</strong> </li>
<li><strong>-s shell： 手工指定用户的登录 shell。默认是/bin/bash</strong> </li>
</ul>
</li>
</ul>
<h5 id="（2）添加默认用户"><a href="#（2）添加默认用户" class="headerlink" title="（2）添加默认用户"></a><strong>（2）添加默认用户</strong></h5><ul>
<li><p><strong>[root@localhost ~]# useradd lamp</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# grep “lamp” /etc/passwd l</strong></p>
</li>
<li><p><strong>[root@localhost ~]# grep “lamp” /etc/shadow</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# grep “lamp” /etc/group</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# grep “lamp” /etc/gshadow</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# ll -d /home/lamp/</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# ll /var/spool/mail/lamp</strong></p>
</li>
</ul>
<h5 id="（3）指定选项添加用户"><a href="#（3）指定选项添加用户" class="headerlink" title="（3）指定选项添加用户"></a><strong>（3）指定选项添加用户</strong></h5><ul>
<li><p><strong>groupadd lamp1</strong> </p>
</li>
<li><p><strong>useradd -u 550 -g lamp1 -G root -d /home/lamp1 \ -c “test user” -s /bin/bash lamp1、</strong></p>
</li>
</ul>
<h5 id="（4）用户默认值文件"><a href="#（4）用户默认值文件" class="headerlink" title="（4）用户默认值文件"></a><strong>（4）用户默认值文件</strong></h5><p>​    <strong>里面定义了建立用户的默认信息</strong></p>
<ul>
<li><p><strong>/etc/default/useradd</strong> </p>
<ul>
<li><p><strong>GROUP=100 #用户默认组</strong> </p>
</li>
<li><p><strong>HOME=/home #用户家目录</strong> </p>
</li>
<li><p><strong>INACTIVE=-1 #密码过期宽限天数（7）</strong> </p>
</li>
<li><p><strong>EXPIRE= #密码失效时间（8）</strong> </p>
</li>
<li><p><strong>SHELL=/bin/bash #默认 shell</strong> </p>
</li>
<li><p><strong>SKEL=/etc/skel #模板目录</strong></p>
</li>
<li><p><strong>CREATE_MAIL_SPOOL=yes #是否建立邮箱</strong></p>
</li>
</ul>
</li>
<li><p><strong>/etc/login.defs</strong> </p>
<ul>
<li><p><strong>PASS_MAX_DAYS 99999 #密码有效期（5）</strong> </p>
</li>
<li><p><strong>PASS_MIN_DAYS 0 #密码修改间隔（4）</strong> </p>
</li>
<li><p><strong>PASS_MIN_LEN 5 #密码最小 5 位（PAM）</strong> </p>
</li>
<li><p><strong>PASS_WARN_AGE 7 #密码到期警告（6）</strong> </p>
</li>
<li><p><strong>UID_MIN 500 #最小和最大 UID 范围</strong></p>
</li>
<li><p><strong>GID_MAX 60000</strong> </p>
</li>
<li><p><strong>ENCRYPT_METHOD SHA512 #加密模式</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="7-3-2-修改用户密码-passwd"><a href="#7-3-2-修改用户密码-passwd" class="headerlink" title="7.3.2 修改用户密码 passwd"></a><strong>7.3.2 修改用户密码 passwd</strong></h4><h5 id="（1）passwd-命令格式"><a href="#（1）passwd-命令格式" class="headerlink" title="（1）passwd 命令格式"></a><strong>（1）passwd 命令格式</strong></h5><ul>
<li><p><strong>passwd [选项] 用户名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-S 查询用户密码的密码状态。仅 root 用户可用。</strong></li>
<li><strong>-l 暂时锁定用户。仅 root 用户可用</strong> </li>
<li><strong>-u 解锁用户。仅 root 用户可用</strong> </li>
<li><strong>–stdin 可以通过管道符输出的数据作为用户的密码。</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）查看密码状态"><a href="#（2）查看密码状态" class="headerlink" title="（2）查看密码状态"></a><strong>（2）查看密码状态</strong></h5><ul>
<li><p><strong>passwd -S lamp</strong> </p>
</li>
<li><p><strong>lamp PS 2013-01-06 0 99999 7 -1</strong> </p>
<ul>
<li><p><strong>用户名 密码设定时间（2013-01-06） 密码修改间隔时间（0） 密码有效期（99999 ） 警告</strong></p>
<p><strong>时间（7） 密码不失效（-1）</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（3）锁定用户和解锁用户"><a href="#（3）锁定用户和解锁用户" class="headerlink" title="（3）锁定用户和解锁用户"></a><strong>（3）锁定用户和解锁用户</strong></h5><ul>
<li><p><strong>passwd -l lamp</strong> </p>
</li>
<li><p><strong>passwd -u lamp</strong> </p>
</li>
</ul>
<h5 id="（4）-使用字符串作为用户的密码"><a href="#（4）-使用字符串作为用户的密码" class="headerlink" title="（4） 使用字符串作为用户的密码"></a><strong>（4） 使用字符串作为用户的密码</strong></h5><ul>
<li><strong>echo “123” | passwd –stdin lamp（shell 脚本可能会用到）</strong></li>
</ul>
<h4 id="7-3-3-修改用户信息-usermod"><a href="#7-3-3-修改用户信息-usermod" class="headerlink" title="7.3.3 修改用户信息 usermod"></a><strong>7.3.3 修改用户信息 usermod</strong></h4><h5 id="（1）命令"><a href="#（1）命令" class="headerlink" title="（1）命令"></a><strong>（1）命令</strong></h5><ul>
<li><p><strong>usermod [选项] 用户名</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-u UID： 修改用户的 UID 号</strong> </li>
<li><strong>-c 用户说明： 修改用户的说明信息</strong></li>
<li><strong>-G 组名： 修改用户的附加组</strong></li>
<li><strong>-L： 临时锁定用户（Lock）</strong> </li>
<li><strong>-U： 解锁用户锁定（Unlock）</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）举例"><a href="#（2）举例" class="headerlink" title="（2）举例"></a><strong>（2）举例</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# usermod -c &quot;test user&quot; lamp</span><br><span class="line">修改用户的说明</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# usermod -G root lamp</span><br><span class="line">把 lamp 用户加入 root 组 </span><br><span class="line"></span><br><span class="line">[root@localhost ~]# usermod -L lamp</span><br><span class="line">锁定用户</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# usermod -U lamp</span><br><span class="line">解锁用户</span><br></pre></td></tr></table></figure>



<h4 id="7-3-4-修改用户密码状态-chage"><a href="#7-3-4-修改用户密码状态-chage" class="headerlink" title="7.3.4 修改用户密码状态 chage"></a><strong>7.3.4 修改用户密码状态 chage</strong></h4><h5 id="（1）命令-1"><a href="#（1）命令-1" class="headerlink" title="（1）命令"></a><strong>（1）命令</strong></h5><ul>
<li><p><strong>chage [选项] 用户名</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-l： 列出用户的详细密码状态</strong></li>
<li><strong>-d 日期： 修改密码最后一次更改日期（shadow3 字段）</strong></li>
<li> <strong>-m 天数： 两次密码修改间隔（4 字段）</strong></li>
<li><strong>-M 天数： 密码有效期（5 字段）</strong></li>
<li><strong>-W 天数： 密码过期前警告天数（6 字段）</strong></li>
<li><strong>-I 天数： 密码过后宽限天数（7 字段）</strong></li>
<li><strong>-E 日期： 账号失效时间（8 字段）</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）举例-1"><a href="#（2）举例-1" class="headerlink" title="（2）举例"></a><strong>（2）举例</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chage -d 0 lamp </span><br><span class="line">这个命令其实是把密码修改日期归 0 了（shadow 第 3 字段）#这样用户一登陆就要修改</span><br><span class="line">密码</span><br></pre></td></tr></table></figure>



<h4 id="7-3-4-删除用户-userdel"><a href="#7-3-4-删除用户-userdel" class="headerlink" title="7.3.4 删除用户 userdel"></a><strong>7.3.4 删除用户 userdel</strong></h4><h5 id="（1）删除用户-userdel"><a href="#（1）删除用户-userdel" class="headerlink" title="（1）删除用户 userdel"></a><strong>（1）删除用户 userdel</strong></h5><ul>
<li><p> <strong>userdel [-r] 用户名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-r 删除用户的同时删除用户家目录</strong> </li>
</ul>
</li>
</ul>
<h5 id="（2）查看用户ID"><a href="#（2）查看用户ID" class="headerlink" title="（2）查看用户ID"></a><strong>（2）查看用户ID</strong></h5><ul>
<li><strong>id 用户名</strong></li>
</ul>
<h4 id="7-3-5-切换用户-su"><a href="#7-3-5-切换用户-su" class="headerlink" title="7.3.5 切换用户 su"></a><strong>7.3.5 切换用户 su</strong></h4><ul>
<li><p> <strong>su [选项] 用户名</strong></p>
</li>
<li><p><strong>选项</strong></p>
<ul>
<li><p><strong>- ： 选项只使用“-”代表连带用户的环境变量一起切换 (env 命令查看当前环</strong></p>
<p><strong>境变量)</strong> </p>
</li>
<li><p><strong>-c  命令： 仅执行一次命令，而不切换用户身份</strong> </p>
</li>
<li><p><strong>例子</strong></p>
<ul>
<li><p><strong>$ su – root</strong> </p>
<p><strong>#切换成 root</strong> </p>
</li>
<li><p><strong>su - root -c “useradd user3”</strong> </p>
<p><strong>#不切换成 root，但是执行 useradd 命令添加 user1 用户</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-4-用户组管理命令"><a href="#7-4-用户组管理命令" class="headerlink" title="7.4 用户组管理命令"></a><strong>7.4 用户组管理命令</strong></h3><h5 id="（1）添加用户组"><a href="#（1）添加用户组" class="headerlink" title="（1）添加用户组"></a><strong>（1）添加用户组</strong></h5><ul>
<li><p><strong>groupadd [选项] 组名</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-g GID #指定组 ID</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）修改用户组"><a href="#（2）修改用户组" class="headerlink" title="（2）修改用户组"></a><strong>（2）修改用户组</strong></h5><ul>
<li><p><strong>groupmod [选项] 组名</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><p><strong>-g GID     #修改组 ID</strong></p>
</li>
<li><p><strong>-n 新组名     #修改组名</strong></p>
</li>
<li><p><strong>例：[root@localhost ~]# groupmod -n yxlm lol</strong></p>
<p><strong>#把组名 lol 修改为 yxlm</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（3）删除用户组"><a href="#（3）删除用户组" class="headerlink" title="（3）删除用户组"></a><strong>（3）删除用户组</strong></h5><ul>
<li><p><strong>groupdel [选项] 组名</strong></p>
</li>
<li><p><strong>tips:删除组的时候，组内不允许有初始用户存在。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> groupadd lol</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> useradd -g lol timo</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> useradd -G lol yasuo</span></span><br><span class="line"></span><br><span class="line">因为 timo 是初始组是 lol。删除 lol 会导致 timo 没有初始组。所以不可删。需要先删除用户。</span><br><span class="line">而 yasuo 是附加组。可删。</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（4）-把用户添加入组或从组中删除"><a href="#（4）-把用户添加入组或从组中删除" class="headerlink" title="（4） 把用户添加入组或从组中删除"></a><strong>（4） 把用户添加入组或从组中删除</strong></h5><ul>
<li><p><strong>groupdel [选项] 组名</strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-a 用户名： 把用户加入组</strong></li>
<li><strong>-d 用户名： 把用户从组中删除</strong></li>
</ul>
</li>
</ul>
<h2 id="第八章-权限管理"><a href="#第八章-权限管理" class="headerlink" title="第八章 权限管理"></a><strong>第八章 权限管理</strong></h2><h3 id="8-1-ACL权限"><a href="#8-1-ACL权限" class="headerlink" title="8.1 ACL权限"></a><strong>8.1 ACL权限</strong></h3><h4 id="8-1-1-ACL权限简介与开启"><a href="#8-1-1-ACL权限简介与开启" class="headerlink" title="8.1.1 ACL权限简介与开启"></a><strong>8.1.1 ACL权限简介与开启</strong></h4><h5 id="（1）ACL权限简介"><a href="#（1）ACL权限简介" class="headerlink" title="（1）ACL权限简介"></a><strong>（1）ACL权限简介</strong></h5><p>​        <strong>ACL 是 Access Control List 的缩写，主要的目的是在提供传统的 owner,group,others 的</strong></p>
<p>​    <strong>read,write,execute 权限之外的细部权限设定。ACL 可以针对单一使用者，单一文件或目录来进行</strong></p>
<p>​    <strong>r,w,x 的权限规范，对于需要特殊权限的使用状况非常有帮助。</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211221150819748.png" alt="image-20211221150819748"></strong></p>
<h5 id="（2）查看分区ACL权限是否开启"><a href="#（2）查看分区ACL权限是否开启" class="headerlink" title="（2）查看分区ACL权限是否开启"></a><strong>（2）查看分区ACL权限是否开启</strong></h5><ul>
<li><p><strong>dumpe2fs -h /dev/sda3</strong> </p>
<p><strong>#dumpe2fs 命令是查询指定分区详细文件系统信息的命令</strong></p>
</li>
<li><p><strong>选项： -h 仅显示超级块中信息，而不显示磁盘块组的详细信息</strong></p>
</li>
</ul>
<h5 id="（3）临时开启分区ACL权限"><a href="#（3）临时开启分区ACL权限" class="headerlink" title="（3）临时开启分区ACL权限"></a><strong>（3）临时开启分区ACL权限</strong></h5><ul>
<li><p><strong>mount -o remount,acl /</strong></p>
<p><strong>#重新挂载根分区，并挂载加入 acl 权限</strong> </p>
</li>
</ul>
<h5 id="（4）永久开启ACL权限"><a href="#（4）永久开启ACL权限" class="headerlink" title="（4）永久开启ACL权限"></a><strong>（4）永久开启ACL权限</strong></h5><ul>
<li><strong>vim /etc/fstab</strong><br><strong>显示：UUID=59d9ca7b-4f39-4c0c-9334-c56c182076b5 / ext4 defaults 1 1</strong></li>
<li><strong>在ext4后面的 defaults加,acl 成为</strong><br><strong>UUID=59d9ca7b-4f39-4c0c-9334-c56c182076b5 / ext4 defaults,acl 1 1</strong></li>
<li><strong>然后输入：mount -o remount /</strong><br><strong>重新挂载文件系统或重启系统，使修改生效</strong></li>
<li><strong>Linux现在一般所有分区全部默认开启ACL，不用修改配置</strong></li>
</ul>
<h4 id="8-1-2-ACL权限查看与设定"><a href="#8-1-2-ACL权限查看与设定" class="headerlink" title="8.1.2 ACL权限查看与设定"></a><strong>8.1.2 ACL权限查看与设定</strong></h4><h5 id="（1）查看ACL权限"><a href="#（1）查看ACL权限" class="headerlink" title="（1）查看ACL权限"></a><strong>（1）查看ACL权限</strong></h5><ul>
<li><p><strong>getfacl 文件名</strong> </p>
<p><strong>查看ACL命令 查看ACL权限</strong></p>
</li>
</ul>
<h5 id="（2）设定ACL权限"><a href="#（2）设定ACL权限" class="headerlink" title="（2）设定ACL权限"></a><strong>（2）设定ACL权限</strong></h5><ul>
<li><p><strong>setfacl [选项] 文件名</strong></p>
</li>
<li><p><strong>选型：</strong></p>
<ul>
<li><strong>-m：设定ACL权限</strong><br><strong>例子：</strong><ul>
<li><strong>setfacl -m u:st:rx /tmp/project 给用户st设定ACL权限读和操作</strong></li>
<li><strong>setfacl -m g:tg1:rwx /tmp/project 给用户组tg1设定ACL权限读，写和操作</strong><br><strong>-x：删除指定的ACL权限</strong></li>
</ul>
</li>
<li><strong>-b：删除所有的ACL权限</strong></li>
<li><strong>-d：设定默认的ACL权限</strong></li>
<li><strong>-k：删除默认ACL权限</strong></li>
<li><strong>-R：递归设定ACL权限</strong></li>
</ul>
</li>
<li><p><strong>举例</strong></p>
<ul>
<li><strong>给用户设定ACL权限</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# useradd zhangsan </span><br><span class="line">[root@localhost ~]# useradd lisi </span><br><span class="line">[root@localhost ~]# useradd st </span><br><span class="line">[root@localhost ~]# groupadd tgroup</span><br><span class="line">[root@localhost ~]# mkdir /project </span><br><span class="line">[root@localhost ~]# chown root:tgroup /project/ </span><br><span class="line">[root@localhost ~]# chmod 770 /project/ </span><br><span class="line">[root@localhost ~]# setfacl -m u:st:rx /project/ </span><br><span class="line"><span class="meta">#</span><span class="bash">给用户 st 赋予 r-x 权限，使用“u:用户名:权限”格式</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>给用户组设定ACL权限</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# groupadd tgroup2 </span><br><span class="line">[root@localhost /]# setfacl -m g:tgroup2:rwx project/ </span><br><span class="line"><span class="meta">#</span><span class="bash">为组 tgroup2 分配 ACl 权限。使用“g:组名:权限”格式</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-1-3-最大有效权限与删除ACL权限"><a href="#8-1-3-最大有效权限与删除ACL权限" class="headerlink" title="8.1.3 最大有效权限与删除ACL权限"></a><strong>8.1.3 最大有效权限与删除ACL权限</strong></h4><h5 id="（1）最大有效权限mask"><a href="#（1）最大有效权限mask" class="headerlink" title="（1）最大有效权限mask"></a><strong>（1）最大有效权限mask</strong></h5><ul>
<li><strong>mask是用来指导最大有效权限的。如果给用户赋予了ACL权限，是需要和mask 的权限“相与”才能得到用户的真正权限</strong></li>
<li><strong>setfscl -m m:rx 文件名</strong><br><strong>设定mask权限为r-x。使用“m:权限”格式</strong></li>
<li><strong>为了防止用户或者用户组给的权限过高，提前设定</strong></li>
</ul>
<h5 id="（2）权限删除"><a href="#（2）权限删除" class="headerlink" title="（2）权限删除"></a><strong>（2）权限删除</strong></h5><ul>
<li><strong>setfacl -x u:用户名 文件名    #删除指定用户的ACL权限</strong></li>
<li><strong>setfacl -x g:组名 文件名    #删除指定用户组的ACL权限</strong></li>
<li><strong>setfacl -b 文件名    #删除文件的所有ACL权限</strong></li>
</ul>
<h4 id="8-1-4-ACL权限递归与默认"><a href="#8-1-4-ACL权限递归与默认" class="headerlink" title="8.1.4 ACL权限递归与默认"></a><strong>8.1.4 ACL权限递归与默认</strong></h4><h5 id="（1）递归ACL权限"><a href="#（1）递归ACL权限" class="headerlink" title="（1）递归ACL权限"></a><strong>（1）递归ACL权限</strong></h5><ul>
<li><strong>递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限</strong></li>
<li><strong>命令：</strong><ul>
<li><strong>setfacl -m u:用户名:权限 -R 目录名</strong> </li>
<li><strong>-R必须在这个位置</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）默认ACL权限"><a href="#（2）默认ACL权限" class="headerlink" title="（2）默认ACL权限"></a><strong>（2）默认ACL权限</strong></h5><ul>
<li><strong>默认ACL权限的作用是，如果给父目录设定默认ACL权限，那么父目录中所有新建的子文件和子目录都会继承父目录的ACL权限</strong></li>
<li><strong>命令：</strong><ul>
<li><strong>Setfacl -m d:u:用户名:权限 目录名</strong> </li>
<li><strong>可以在权限后面加-R来进行递归</strong></li>
</ul>
</li>
</ul>
<p><strong>、</strong></p>
<h3 id="8-2-文件特殊权限"><a href="#8-2-文件特殊权限" class="headerlink" title="8.2 文件特殊权限"></a><strong>8.2 文件特殊权限</strong></h3><h4 id="8-2-1-SetUID"><a href="#8-2-1-SetUID" class="headerlink" title="8.2.1 SetUID"></a><strong>8.2.1 SetUID</strong></h4><h5 id="（1）SetUID的功能"><a href="#（1）SetUID的功能" class="headerlink" title="（1）SetUID的功能"></a><strong>（1）SetUID的功能</strong></h5><ul>
<li><p><strong>只有可以执行的<font color="red">二进制程序</font>才能设定 SUID 权限</strong></p>
</li>
<li><p><strong>命令执行者要对该程序拥有 x（执行）权限</strong></p>
</li>
<li><p><strong><font color="orange">命令执行者在执行该程序时获得该程序文件属主的身份</font>（在执行程序的过程中灵魂附体为文件的属主）</strong></p>
</li>
<li><p><strong>SetUID 权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效</strong> </p>
</li>
<li><p><strong>passwd 命令拥有 SetUID 权限，所以普通可以修改自己的密码</strong></p>
<ul>
<li><p><strong>[root@localhost ~]# ll /usr/bin/passwd</strong> </p>
<p><strong>-rw<font color="red">s</font>r-xr-x. 1 root root 25980 2 月 22 2012 /usr/bin/passwd</strong> </p>
</li>
</ul>
</li>
<li><p><strong>cat 命令没有 SetUID 权限，所以普通用户不能查看/etc/shadow 文件内容</strong></p>
<ul>
<li><strong>[root@localhost ~]# ll /bin/cat -rwxr-xr-x 1 root root 47976 6 月 22 2012 /bin/cat</strong></li>
</ul>
</li>
</ul>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211222132551724.png" alt="image-20211222132551724"></strong></p>
<h5 id="（2）设定SetUID的方法"><a href="#（2）设定SetUID的方法" class="headerlink" title="（2）设定SetUID的方法"></a><strong>（2）设定SetUID的方法</strong></h5><ul>
<li><strong>chmod 4755 文件名    # 4代表SUID</strong></li>
<li><strong>chmod u+s 文件名</strong></li>
</ul>
<h5 id="（3）取消SetUID的方法"><a href="#（3）取消SetUID的方法" class="headerlink" title="（3）取消SetUID的方法"></a><strong>（3）取消SetUID的方法</strong></h5><ul>
<li><strong>chmod 755 文件名</strong></li>
<li><strong>chmod u-s 文件名</strong></li>
</ul>
<h5 id="（4）危险的SetUID"><a href="#（4）危险的SetUID" class="headerlink" title="（4）危险的SetUID"></a><strong>（4）危险的SetUID</strong></h5><ul>
<li><strong>关键目录应严格控制写权限。比如“/”、“/usr”等</strong> </li>
<li><strong>用户的密码设置要严格遵守密码三原则</strong></li>
<li><strong>对系统中默认应该具有 SetUID 权限的文件作一列表，定时检查有没有这之外的文件被设置了 SetUID 权限</strong></li>
</ul>
<h4 id="8-2-2-SetGID"><a href="#8-2-2-SetGID" class="headerlink" title="8.2.2  SetGID"></a><strong>8.2.2  SetGID</strong></h4><h5 id="（1）SetGID-针对文件的作用"><a href="#（1）SetGID-针对文件的作用" class="headerlink" title="（1）SetGID 针对文件的作用"></a><strong>（1）SetGID 针对文件的作用</strong></h5><ul>
<li><p><strong>只有可执行的二进制程序才能设置 SGID 权限</strong></p>
</li>
<li><p><strong>命令执行者要对该程序拥有 x（执行）权限</strong> </p>
</li>
<li><p><strong>命令执行在执行程序的时候，组身份升级为该程序文件的属组</strong></p>
</li>
<li><p><strong>SetGID 权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效</strong></p>
<ul>
<li><p><strong>[root@localhost ~]# ll /usr/bin/locate</strong> </p>
<p><strong>-rwx–s–x 1 root slocate 35612 8 月 24 2010 /usr/bin/locate</strong> </p>
<p><strong>[root@localhost ~]# ll /var/lib/mlocate/mlocate.db</strong> </p>
<p><strong>-rw-r—– 1 root slocate 1838850 1 月 20 04:29 /var/lib/mlocate/mlocate.db</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（2）SetGID-针对目录的作用"><a href="#（2）SetGID-针对目录的作用" class="headerlink" title="（2）SetGID 针对目录的作用"></a><strong>（2）SetGID 针对目录的作用</strong></h5><ul>
<li><p><strong>普通用户必须对此目录拥有 r 和 x 权限，才能进入此目录</strong></p>
</li>
<li><p><strong>普通用户在此目录中的有效组会变成此目录的属组</strong></p>
</li>
<li><p><strong>若普通用户对此目录拥有 w 权限时，新建的文件的默认属组是这个目录</strong></p>
</li>
</ul>
<h5 id="（3）设定-SetGID"><a href="#（3）设定-SetGID" class="headerlink" title="（3）设定 SetGID"></a><strong>（3）设定 SetGID</strong></h5><ul>
<li><p><strong>chmod 2755 文件名    # 2 代表 SGID</strong></p>
</li>
<li><p><strong>chmod g+s 文件名</strong> </p>
</li>
</ul>
<h5 id="（4）-取消-SetGID"><a href="#（4）-取消-SetGID" class="headerlink" title="（4） 取消 SetGID"></a><strong>（4） 取消 SetGID</strong></h5><ul>
<li><p><strong>chmod 755 文件名</strong></p>
</li>
<li><p><strong>chmod g-s 文件名</strong></p>
</li>
</ul>
<h4 id="8-3-3-Sticky-BIT"><a href="#8-3-3-Sticky-BIT" class="headerlink" title="8.3.3 Sticky BIT"></a><strong>8.3.3 Sticky BIT</strong></h4><h5 id="（1）SBIT-粘着位作用"><a href="#（1）SBIT-粘着位作用" class="headerlink" title="（1）SBIT 粘着位作用"></a><strong>（1）SBIT 粘着位作用</strong></h5><ul>
<li><p><strong>粘着位目前只对目录有效</strong></p>
</li>
<li><p><strong>普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录拥有写入权限</strong> </p>
</li>
<li><p><strong>如果没有粘着位，因为普通用户拥有 w 权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。</strong></p>
</li>
<li><p><strong>一但赋予了粘着位，除了 root 可以删除所有文件，普通用户就算拥有 w 权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件 。</strong></p>
</li>
</ul>
<h5 id="（2）设置与取消粘着位"><a href="#（2）设置与取消粘着位" class="headerlink" title="（2）设置与取消粘着位"></a><strong>（2）设置与取消粘着位</strong></h5><ul>
<li><p><strong>设置粘着位</strong></p>
<ul>
<li><strong>chmod 1755 目录名    #1代表粘着位</strong></li>
<li><strong>chmod o+t 目录名</strong></li>
</ul>
</li>
<li><p><strong>取消粘着位</strong></p>
<ul>
<li><strong>chmod 777 目录名</strong></li>
<li><strong>chmod o-t 目录名</strong></li>
</ul>
</li>
</ul>
<h3 id="8-3-文件系统属性chattr权限"><a href="#8-3-文件系统属性chattr权限" class="headerlink" title="8.3 文件系统属性chattr权限"></a><strong>8.3 文件系统属性chattr权限</strong></h3><h5 id="（1）chattr命令格式"><a href="#（1）chattr命令格式" class="headerlink" title="（1）chattr命令格式"></a><strong>（1）chattr命令格式</strong></h5><ul>
<li><strong>chattr [+ - =] [选项] 文件名或者目录名</strong><br><strong>+：增加权限</strong><br><strong>-：删除权限</strong><br><strong>=：等于某权限</strong></li>
<li><strong>选项：</strong><ul>
<li><strong>i：如果对文件设置i属性，那么不允许对文件进行删除，改名，也不能添加和修改数据；如果对目录设置i属性,那么只能修改目录下文件的数据，但是不允许建立和删除文件</strong></li>
<li><strong>a：如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除或者修改数据；如果对目录设置a属性,那么只允许在目录中建立和修改文件，但是不允许删除文件</strong></li>
<li></li>
</ul>
</li>
</ul>
<h5 id="（2）查看文件系统属性"><a href="#（2）查看文件系统属性" class="headerlink" title="（2）查看文件系统属性"></a><strong>（2）查看文件系统属性</strong></h5><ul>
<li><strong>lsattr [选项] 文件名</strong><ul>
<li><strong>-a：显示所有文件和目录</strong></li>
<li><strong>-d：若目标是目录，仅列出目录本身的属性，而不是子文件的</strong></li>
</ul>
</li>
</ul>
<h3 id="8-4-系统命令sudo权限"><a href="#8-4-系统命令sudo权限" class="headerlink" title="8.4 系统命令sudo权限"></a><strong>8.4 系统命令sudo权限</strong></h3><h5 id="（1）sudo-权限"><a href="#（1）sudo-权限" class="headerlink" title="（1）sudo 权限"></a><strong>（1）sudo 权限</strong></h5><ul>
<li><strong>root 把本来只能超级用户执行的命令赋予普通用户执行。</strong></li>
<li><strong>sudo 的操作对象是系统命令</strong></li>
</ul>
<h5 id="（2）sudo-使用"><a href="#（2）sudo-使用" class="headerlink" title="（2）sudo 使用"></a><strong>（2）sudo 使用</strong></h5><ul>
<li><p><strong>visudo     #实际修改的是/etc/sudoers 文件</strong> </p>
</li>
<li><p>```shell<br>root ALL=(ALL) ALL<br>#用户名 被管理主机的地址=（可使用的身份） 授权命令（绝对路径）</p>
<p>%wheel ALL=(ALL) ALL<br>#%组名 被管理主机的地址=（可使用的身份） 授权命令（绝对路径）<br>#被管理主机的地址：本机IP或者ALL，限制的不是来源IP，而是访问IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **授权 sc 用户可以重启服务器**</span><br><span class="line"></span><br><span class="line">  ```shell</span><br><span class="line">  [root@localhost ~]# visudo </span><br><span class="line">  sc ALL= /sbin/shutdown –r now</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）其他"><a href="#（3）其他" class="headerlink" title="（3）其他"></a><strong>（3）其他</strong></h5><ul>
<li><p><strong>普通用户执行 sudo 赋予的命令</strong>    </p>
<p><strong>sudo [授权命令的绝对路径]</strong><br><strong>例子：</strong><br><strong>sudo /sbin/shutdown -r now</strong></p>
</li>
<li><p><strong>查看可用的sudo命令</strong></p>
<p><strong>sudo -l</strong> </p>
</li>
</ul>
<h2 id="第九章-文件系统管理"><a href="#第九章-文件系统管理" class="headerlink" title="第九章 文件系统管理"></a><strong>第九章 文件系统管理</strong></h2><h3 id="9-1-分区和文件系统"><a href="#9-1-分区和文件系统" class="headerlink" title="9.1 分区和文件系统"></a><strong>9.1 分区和文件系统</strong></h3><h5 id="（1）分区类型"><a href="#（1）分区类型" class="headerlink" title="（1）分区类型"></a><strong>（1）分区类型</strong></h5><ul>
<li><strong>主分区：总共最多只能分四个</strong></li>
<li><strong>扩展分区：只能有一个，也算作主分区的一种，也就是说主分区加扩展分区最多有四个。但是扩展分区不能存储数据和格式化，必须再划分成逻辑分区才能使用。</strong></li>
<li><strong>逻辑分区：逻辑分区是在扩展分区中划分的，如果是 IDE 硬盘，Linux 最多支持59 个逻辑分区，如果是 SCSI 硬盘 Linux 最多支持 11 个逻辑分区</strong></li>
</ul>
<h5 id="（2）分区的表示方法"><a href="#（2）分区的表示方法" class="headerlink" title="（2）分区的表示方法"></a><strong>（2）分区的表示方法</strong></h5><p>​    <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211223121525506.png" alt="image-20211223121525506"></strong></p>
<p>​    <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211223121533212.png" alt="image-20211223121533212"></strong></p>
<p>​    <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211223121538848.png" alt="image-20211223121538848"></strong></p>
<p>​    <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211223121543169.png" alt="image-20211223121543169"></strong></p>
<h5 id="（3）文件系统"><a href="#（3）文件系统" class="headerlink" title="（3）文件系统"></a><strong>（3）文件系统</strong></h5><ul>
<li><strong>ext2：是 ext 文件系统的升级版本，Red Hat Linux7.2 版本以前的系统默认都是ext2 文件系统。1993 年发布，最大支持 16TB 的分区和最大 2TB 的文件（1TB=1024GB=1024*1024KB）</strong></li>
<li><strong>ext3： ext3 文件系统是 ext2 文件系统的升级版本，最大的区别就是带日志功能，以在系统突然停止时提高文件系统的可靠性。支持最大 16TB 的分区和最大2TB 的文件</strong></li>
<li><strong>ext4：它是 ext3 文件系统的升级版。ext4 在性能、伸缩性和可靠性方面进行了大量改进。EXT4 的变化可以说是翻天覆地的，比如向下兼容 EXT3、最大 1EB 文件系统和 16TB 文件、无限数量子目录、Extents 连续数据块概念、多块分配、延迟分配、持久预分配、快速 FSCK、日志校验、无日志模式、在线碎片整理、inode 增强、默认启用 barrier 等。是 CentOS 6.3 的默认文件系统 （1EB=1024PB=1024*1024TB）</strong></li>
</ul>
<h3 id="9-2-文件系统常用命令"><a href="#9-2-文件系统常用命令" class="headerlink" title="9.2 文件系统常用命令"></a><strong>9.2 文件系统常用命令</strong></h3><h4 id="9-2-1-df-命令、du-命令、fsck-命令和-dump2fs-命令"><a href="#9-2-1-df-命令、du-命令、fsck-命令和-dump2fs-命令" class="headerlink" title="9.2.1 df 命令、du 命令、fsck 命令和 dump2fs 命令"></a><strong>9.2.1 df 命令、du 命令、fsck 命令和 dump2fs 命令</strong></h4><h5 id="（1）文件系统查看命令-df"><a href="#（1）文件系统查看命令-df" class="headerlink" title="（1）文件系统查看命令 df"></a><strong>（1）文件系统查看命令 df</strong></h5><ul>
<li><p> <strong>df [选项] [挂载点]</strong> </p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><p><strong>-a 显示所有的文件系统信息，包括特殊文件系统，如 /proc、/sysfs</strong> </p>
</li>
<li><p><strong>-h 使用习惯单位显示容量，如 KB，MB 或 GB 等</strong> </p>
</li>
<li><p><strong>-T 显示文件系统类型</strong> </p>
</li>
<li><p><strong>-m 以 MB 为单位显示容量</strong> </p>
</li>
<li><p><strong>-k 以 KB 为单位显示容量。默认就是以 KB 为单位</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（2）统计目录或文件大小-du"><a href="#（2）统计目录或文件大小-du" class="headerlink" title="（2）统计目录或文件大小 du"></a><strong>（2）统计目录或文件大小 du</strong></h5><ul>
<li><p><strong>du [选项] [目录或文件名]</strong> </p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><p><strong>-a 显示每个子文件的磁盘占用量。默认只统计 子目录的磁盘占用量</strong> </p>
</li>
<li><p><strong>-h 使用习惯单位显示磁盘占用量，如 KB，MB 或 GB 等</strong> </p>
</li>
<li><p><strong>-s 统计总占用量，而不列出子目录和子文件的 占用量</strong></p>
</li>
</ul>
</li>
<li><p><strong>du 命令和 df 命令的区别</strong></p>
<ul>
<li><p><strong>df 命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）</strong></p>
</li>
<li><p><strong>du 命令是面向文件的，只会计算文件或目录占用的空间</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="（3）文件系统修复命令-fsck"><a href="#（3）文件系统修复命令-fsck" class="headerlink" title="（3）文件系统修复命令 fsck"></a><strong>（3）文件系统修复命令 fsck</strong></h5><ul>
<li><p> <strong>fsck [选项] 分区设备文件名</strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><p><strong>-a： 不用显示用户提示，自动修复文件系统</strong> </p>
</li>
<li><p><strong>-y： 自动修复。和-a 作用一致，不过有些文件系统只支 持-y</strong> </p>
</li>
</ul>
</li>
<li><p><strong>注意：知道就行，不必操作，有可能弄崩溃系统</strong></p>
</li>
</ul>
<h5 id="（4）显示磁盘状态命令-dumpe2fs"><a href="#（4）显示磁盘状态命令-dumpe2fs" class="headerlink" title="（4）显示磁盘状态命令 dumpe2fs"></a><strong>（4）显示磁盘状态命令 dumpe2fs</strong></h5><ul>
<li> <strong>dumpe2fs 分区设备文件名</strong></li>
</ul>
<h4 id="9-2-2-挂载命令"><a href="#9-2-2-挂载命令" class="headerlink" title="9.2.2 挂载命令"></a><strong>9.2.2 挂载命令</strong></h4><h5 id="（1）查询与自动挂载"><a href="#（1）查询与自动挂载" class="headerlink" title="（1）查询与自动挂载"></a><strong>（1）查询与自动挂载</strong></h5><ul>
<li><p><strong>mount [-l]</strong> </p>
<p><strong>#查询系统中已经挂载的设备，-l 会显示卷标名称</strong> </p>
</li>
<li><p><strong>mount –a</strong> </p>
<p><strong>#依据配置文件/etc/fstab 的内容，自动挂载</strong> </p>
</li>
</ul>
<h5 id="（2）挂载命令格式"><a href="#（2）挂载命令格式" class="headerlink" title="（2）挂载命令格式"></a><strong>（2）挂载命令格式</strong></h5><ul>
<li><strong>mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</strong></li>
<li><strong>-t 文件系统:加入文件系统类型来指定挂载的类型，如果文件系统是硬盘，分区就写ext3、ext4 ，如果是光盘，就写iso9660</strong></li>
<li><strong>-L 卷标名: 挂载指定卷标的分区，而不是按照设备文件名挂载</strong></li>
<li><strong>-o 特殊选项:可以指定挂载的额外选项</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>atime/noatime</strong></td>
<td><strong>更新访问时间/不更新访问时间。访问分区文件时，是否更新文件 的访问时间，默认为更新</strong></td>
</tr>
<tr>
<td><strong>async/sync</strong></td>
<td><strong>异步/同步，默认为异步</strong></td>
</tr>
<tr>
<td><strong>auto/noauto</strong></td>
<td><strong>自动/手动，mount –a命令执行时，是否会自动安装/etc/fstab文件内容挂载，默认为自动</strong></td>
</tr>
<tr>
<td><strong>defaults</strong></td>
<td><strong>定义默认值，相当于rw,suid,dev,exec,auto,nouser,async这七个选项</strong></td>
</tr>
<tr>
<td><strong>exec/noexec</strong></td>
<td><strong>执行/不执行，设定是否允许在文件系统中执行可执行文件，默认 是exec允许</strong></td>
</tr>
<tr>
<td><strong>remount</strong></td>
<td><strong>重新挂载已经挂载的文件系统，一般用于指定修改特殊权限</strong></td>
</tr>
<tr>
<td><strong>rw/ro</strong></td>
<td><strong>读写/只读，文件系统挂载时，是否具有读写权限，默认是rw</strong></td>
</tr>
<tr>
<td><strong>suid/nosuid</strong></td>
<td><strong>具有/不具有SUID权限，设定文件系统是否具有SUID和SGID的权限，默认是具有</strong></td>
</tr>
<tr>
<td><strong>user/nouser</strong></td>
<td><strong>允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载 默认是不允许，只有root可以挂载分区</strong></td>
</tr>
<tr>
<td><strong>usrquota</strong></td>
<td><strong>写入代表文件系统支持用户磁盘配额，默认不支持</strong></td>
</tr>
<tr>
<td><strong>grpquota</strong></td>
<td><strong>写入代表文件系统支持组磁盘配额，默认不支持</strong></td>
</tr>
</tbody></table>
<p><strong>注意：针对的都是分区</strong></p>
<h4 id="9-2-3-挂载光盘与U盘"><a href="#9-2-3-挂载光盘与U盘" class="headerlink" title="9.2.3 挂载光盘与U盘"></a><strong>9.2.3 挂载光盘与U盘</strong></h4><h5 id="（1）挂载光盘"><a href="#（1）挂载光盘" class="headerlink" title="（1）挂载光盘"></a><strong>（1）挂载光盘</strong></h5><ul>
<li><p><strong>建立挂载点</strong></p>
<p><strong>mkdir /mnt/cdrom/</strong><br><strong>mount -t iso9660 /dev/cdrom /mnt/cdrom/</strong></p>
</li>
<li><p><strong>挂载光盘</strong></p>
<p><strong>mount /dev/sr0 /mnt/cdrom/</strong></p>
</li>
<li><p><strong>卸载命令</strong></p>
<p><strong>umount 设备文件名或挂载点</strong></p>
<p><strong>umount /mnt/cdrom</strong></p>
</li>
</ul>
<h5 id="（2）挂载U盘"><a href="#（2）挂载U盘" class="headerlink" title="（2）挂载U盘"></a><strong>（2）挂载U盘</strong></h5><ul>
<li><strong>fdisk –l    #查看U盘设备文件名</strong></li>
<li><strong>mount -t vfat /dev/sdb1 /mnt/usb/</strong></li>
<li><strong>卸载命令</strong><br><strong>umount 设备文件名或挂载点</strong></li>
</ul>
<h4 id="9-2-4-支持NTFS文件系统"><a href="#9-2-4-支持NTFS文件系统" class="headerlink" title="9.2.4 支持NTFS文件系统"></a><strong>9.2.4 支持NTFS文件系统</strong></h4><h5 id="（1）下载-NTFS-3G-插件"><a href="#（1）下载-NTFS-3G-插件" class="headerlink" title="（1）下载 NTFS-3G 插件"></a><strong>（1）下载 NTFS-3G 插件</strong></h5><p>​    <strong><a href="http://www.tuxera.com/community/ntfs-3g-">http://www.tuxera.com/community/ntfs-3g-</a> download/</strong> </p>
<h5 id="（2）安装-NTFS-3G"><a href="#（2）安装-NTFS-3G" class="headerlink" title="（2）安装 NTFS-3G"></a><strong>（2）安装 NTFS-3G</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tar -zxvf ntfs-3g_ntfsprogs-2013.1.13.tgz </span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cd ntfs-3g_ntfsprogs-2013.1.13 </span><br><span class="line"><span class="meta">#</span><span class="bash">进入解压目录</span></span><br><span class="line"></span><br><span class="line">[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# ./configure </span><br><span class="line"><span class="meta">#</span><span class="bash">编译器准备。没有指定安装目录，安装到默认位置中</span></span><br><span class="line"></span><br><span class="line">[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# make </span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line"></span><br><span class="line">[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# make install </span><br><span class="line"><span class="meta">#</span><span class="bash">编译安装</span></span><br></pre></td></tr></table></figure>



<h5 id="（3）-使用"><a href="#（3）-使用" class="headerlink" title="（3） 使用"></a><strong>（3） 使用</strong></h5><p>​    <strong>mount -t ntfs-3g 分区设备文件名 挂载点</strong></p>
<h3 id="9-3-fdisk分区"><a href="#9-3-fdisk分区" class="headerlink" title="9.3 fdisk分区"></a><strong>9.3 fdisk分区</strong></h3><h4 id="9-3-1-fdisk命令分区过程"><a href="#9-3-1-fdisk命令分区过程" class="headerlink" title="9.3.1 fdisk命令分区过程"></a><strong>9.3.1 fdisk命令分区过程</strong></h4><ul>
<li><p><strong>通过虚拟机加入新硬盘</strong></p>
<ul>
<li><strong>查看新硬盘</strong><br><strong>fdisk -l</strong></li>
</ul>
</li>
<li><p><strong>使用fdisk命令分区</strong><br><strong>fdisk /dev/sdb 后面不能加数字 因为此时硬盘还没有分区</strong><br><strong>通过交互进行分区，交互指令如下：</strong></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>a</strong></td>
<td><strong>设置可引导标记</strong></td>
</tr>
<tr>
<td><strong>b</strong></td>
<td><strong>编辑bsd磁盘标签</strong></td>
</tr>
<tr>
<td><strong>c</strong></td>
<td><strong>设置DOS操作系统兼容标记</strong></td>
</tr>
<tr>
<td><strong>d</strong></td>
<td><strong>删除一个分区</strong></td>
</tr>
<tr>
<td><strong>l</strong></td>
<td><strong>显示已知的文件系统类型。82为Linux swap分区，83为Linux分区</strong></td>
</tr>
<tr>
<td><strong>m</strong></td>
<td><strong>显示帮助菜单</strong></td>
</tr>
<tr>
<td><strong>n</strong></td>
<td><strong>新建分区</strong></td>
</tr>
<tr>
<td><strong>o</strong></td>
<td><strong>建立空白DOS分区表</strong></td>
</tr>
<tr>
<td><strong>p</strong></td>
<td><strong>显示分区列表</strong></td>
</tr>
<tr>
<td><strong>q</strong></td>
<td><strong>不保存退出</strong></td>
</tr>
<tr>
<td><strong>s</strong></td>
<td><strong>新建空白SUN磁盘标签</strong></td>
</tr>
<tr>
<td><strong>t</strong></td>
<td><strong>改变一个分区的系统ID</strong></td>
</tr>
<tr>
<td><strong>u</strong></td>
<td><strong>改变显示记录单位</strong></td>
</tr>
<tr>
<td><strong>v</strong></td>
<td><strong>验证分区表</strong></td>
</tr>
<tr>
<td><strong>w</strong></td>
<td><strong>保存退出</strong></td>
</tr>
<tr>
<td><strong>x</strong></td>
<td><strong>附加功能(仅专家)</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>重新读取分区表信息</strong></p>
<ul>
<li><strong>partprobe</strong></li>
</ul>
</li>
<li><p><strong>格式化分区</strong></p>
<ul>
<li><strong>mkfs -t ext4 /dev/sdb1</strong></li>
</ul>
</li>
<li><p><strong>建立挂载点并挂载</strong></p>
<ul>
<li><strong>mkdir /disk1</strong></li>
<li><strong>mkdir /disk5</strong></li>
<li><strong>mount /dev/sdb1 /disk1/</strong></li>
<li><strong>mount /dev/sdb5 /disk5/</strong></li>
</ul>
</li>
</ul>
<h4 id="9-3-2-分区自动挂载与fstab文件修复"><a href="#9-3-2-分区自动挂载与fstab文件修复" class="headerlink" title="9.3.2 分区自动挂载与fstab文件修复"></a><strong>9.3.2 分区自动挂载与fstab文件修复</strong></h4><ul>
<li><strong>上一节说的挂载操作在重启之后便会消失，每次重启都得重新挂载，使用我们需要把它写入系统挂载命令文件中，每次开机都会自动扫描挂载，使用/etc/fstab文件，将挂载信息写入文件</strong></li>
</ul>
<ul>
<li><p><strong>/etc/fstab文件</strong><br><strong>第一字段：分区设备文件名或UUID(硬盘通用唯一识别码)</strong><br><strong>第二字段：挂载点</strong><br><strong>第三字段:文件系统名称</strong><br><strong>第四字段:挂载参数</strong><br><strong>第五字段:指定分区是否被dump备份，0代表不备份，1 代表每天备份，2代表不定期备份</strong><br><strong>第六字段:指定分区是否被fsck检测，0代表不检测，其 他数字代表检测的优先级，那么当然1的优先级比2高</strong><br><strong>注意：在写入文件之后先不要着急重启，我们可以先用mount -a命令来实现系统自动重新挂载，如果出现错误会提示，不至于系统崩溃</strong></p>
</li>
<li><p><strong>/etc/fstab文件修复</strong><br><strong>如果一旦写错了，出现了报错，可以在开机显示之后出现一个让你输入root用户密码的界面，再输入密码之后，可以使用vim /etc/fstab进入fstab文件修改错误，如果出现文件只有只读权限，不能修改，强制保存也不行，退出文件输入命令：mount -o remount,rw / ，重新把根分区挂载读写权限，就可以保存了，而且只能在根分区没有错误，在本机登陆，不能使用服务器或者远程连接的情况下才能修复。</strong></p>
</li>
</ul>
<h3 id="9-4-新建swap分区"><a href="#9-4-新建swap分区" class="headerlink" title="9.4 新建swap分区"></a><strong>9.4 新建swap分区</strong></h3><ul>
<li><strong>swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。也就是说，当内存不够用时，我们使用 swap 分区来临时顶替。这种“拆东墙，补西墙”的方式应用于几乎所有的操作系统中。</strong></li>
</ul>
<ul>
<li><p><strong>free命令</strong></p>
<ul>
<li><strong>free 查看内存与swap分区使用状况</strong></li>
<li><strong>-m：按MB字节显示</strong></li>
</ul>
</li>
<li><p><strong>缓存与缓冲：</strong></p>
<ul>
<li><strong>cached(缓存):是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程</strong></li>
<li><strong>buffer(缓冲):是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘， 减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程</strong></li>
</ul>
</li>
<li><p><strong>新建swap分区</strong></p>
<p><strong>fdisk /dev/sdb</strong><br><strong>进行交互式操作</strong><br><strong>别忘记把分区ID改为82 ，记得保存，然后重启</strong></p>
</li>
<li><p><strong>格式化</strong><br><strong>分区完之后需要格式化</strong><br><strong>mkswap /dev/sdb1 这里不能使用mkfs进行格式化</strong></p>
</li>
</ul>
<ul>
<li><strong>加入swap分区</strong><br><strong>swapon /dev/sdb1 加入swap分区</strong></li>
</ul>
<ul>
<li><strong>如果不想用了使用以下命令取消：</strong><br><strong>swapoff /dev/sdb1 取消swap分区</strong></li>
</ul>
<ul>
<li><strong>swap分区开机自动挂载</strong><br><strong>vi /etc/fstab</strong><br><strong>/dev/sdb1 swap swap defaults 0 0</strong><br><strong>注意：swap前面没有/，他不是根分区下的</strong><br><strong>修改之后使用mount -a 命令来检测错误</strong></li>
</ul>
<h2 id="第十章-Shell基础"><a href="#第十章-Shell基础" class="headerlink" title="第十章 Shell基础"></a><strong>第十章 Shell基础</strong></h2><h3 id="10-1-Shell概述"><a href="#10-1-Shell概述" class="headerlink" title="10.1 Shell概述"></a><strong>10.1 Shell概述</strong></h3><h4 id="10-1-1-Shell是什么"><a href="#10-1-1-Shell是什么" class="headerlink" title="10.1.1 Shell是什么"></a><strong>10.1.1 Shell是什么</strong></h4><ul>
<li><p><strong>Shell是一个<font color="orange">命令行解释器</font>，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来 启动、挂起、停止甚至是编写一些程序。</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210721142803916.png" alt="image-20210721142803916" style="zoom:50%;"></strong></p>
</li>
<li><p><strong>Shell还是一个功能相当强大的<font color="orange">编程语言</font>， 易编写，易调试，灵活性较强。Shell是解释执行的<font color="orange">脚本语言</font>，在Shell中可以直接调用Linux系统命令。</strong></p>
</li>
</ul>
<h4 id="10-1-2-Shell的分类"><a href="#10-1-2-Shell的分类" class="headerlink" title="10.1.2 Shell的分类"></a><strong>10.1.2 Shell的分类</strong></h4><ul>
<li><p><strong><font color="orange">Bourne Shell</font>:从1979起Unix就开始使用 Bourne Shell，Bourne Shell的主文件名为 sh。</strong></p>
</li>
<li><p><strong><font color="orange">C Shell</font>: C Shell主要在BSD版的Unix系 统中使用，其语法和C语言相类似而得名</strong></p>
<p><strong>Shell的两种主要语法类型有Bourne和C， 这两种语法彼此不兼容。</strong></p>
<p><strong>Bourne家族主要 包括sh、ksh、Bash、psh、zsh;</strong></p>
<p><strong>C家族主 要包括:csh、tcsh</strong></p>
<p><strong>Bash: Bash与sh兼容，现在使用的Linux 就是使用Bash作为<font color="orange">用户的基本Shell</font>。</strong></p>
</li>
</ul>
<h4 id="10-1-3-Linux支持的Shell"><a href="#10-1-3-Linux支持的Shell" class="headerlink" title="10.1.3 Linux支持的Shell"></a><strong>10.1.3 Linux支持的Shell</strong></h4><p>  <strong>/etc/shells</strong><br>  <strong>会显示：/bin/sh、/bin/bash、/sbin/nologin、/bin/tcsh、/bin/csh</strong><br>  <strong>都是Linux支持的Shell</strong></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ cat /etc/shells</span><br><span class="line"><span class="meta">#</span><span class="bash"> Pathnames of valid login shells.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See shells(5) <span class="keyword">for</span> details.</span></span><br><span class="line"></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/bin/zsh</span><br><span class="line">/usr/bin/git-shell</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-2-Shell脚本的执行方式"><a href="#10-2-Shell脚本的执行方式" class="headerlink" title="10.2 Shell脚本的执行方式"></a><strong>10.2 Shell脚本的执行方式</strong></h3><h4 id="10-2-1-echo-输出命令"><a href="#10-2-1-echo-输出命令" class="headerlink" title="10.2.1 echo 输出命令"></a><strong>10.2.1 <font color="red">echo </font>输出命令</strong></h4><ul>
<li><p><strong>#echo [选项] [输出内容]</strong> </p>
</li>
<li><p><strong><font color="orange">-e</font>: 支持反斜线控制的转义字符</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>控制字符</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">*<em><strong>*</strong></em></td>
<td align="center"><strong>输出\本身</strong></td>
</tr>
<tr>
<td align="center"><strong>\a</strong></td>
<td align="center"><strong>输出警告音</strong></td>
</tr>
<tr>
<td align="center"><strong>\b</strong></td>
<td align="center"><strong>退格键，也就是向左删除键</strong></td>
</tr>
<tr>
<td align="center"><strong>\c</strong></td>
<td align="center"><strong>取消输出行末的换行符。和“-n”选项一致</strong></td>
</tr>
<tr>
<td align="center"><strong>\e</strong></td>
<td align="center"><strong>ESCAPE键</strong></td>
</tr>
<tr>
<td align="center"><strong>\f</strong></td>
<td align="center"><strong>换页符</strong></td>
</tr>
<tr>
<td align="center"><strong>\n</strong></td>
<td align="center"><strong>换行符</strong></td>
</tr>
<tr>
<td align="center"><strong>\r</strong></td>
<td align="center"><strong>回车键</strong></td>
</tr>
<tr>
<td align="center"><strong>\t</strong></td>
<td align="center"><strong>制表符，也就是Tab键</strong></td>
</tr>
<tr>
<td align="center"><strong>\v</strong></td>
<td align="center"><strong>垂直制表符</strong></td>
</tr>
<tr>
<td align="center"><strong>\0nnn</strong></td>
<td align="center"><strong>按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数</strong></td>
</tr>
<tr>
<td align="center"><strong>\xhh</strong></td>
<td align="center"><strong>按照十六进制ASCII码表输出字符。其中hh是两位十六进制数</strong></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>例子</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">\b退格删除左侧字符$ <span class="built_in">echo</span> -e <span class="string">&#x27;ab\bc&#x27;</span>ac<span class="comment">#\t制表符 \n换行符$ echo -e &#x27;a\tb\tc\nd\te\tf&#x27;a	b	cd	e	f#\x按照十六进制ASCII码表输出字符$ echo -e &#x27;\x61\t\x62\t\x63&#x27;a	b	c$ echo -e &#x27;\e[1;31m abcd \e[0m&#x27; abcd #因为\e[1; 表示开启颜色区别 \e[0m 表示结束颜色区别 31m表示红色 还有其他：#30m=黑色，31m=红色，32m=绿色，33m=黄色，34m=蓝色，35m=洋红，36m=青色，#37m=白色</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="10-2-2-第一个脚本"><a href="#10-2-2-第一个脚本" class="headerlink" title="10.2.2 第一个脚本"></a><strong>10.2.2 第一个脚本</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~$ ls公共  模板  视频  图片  文档  下载  音乐  桌面$ <span class="built_in">cd</span> 文档$ mkdir 脚本练习$ <span class="built_in">cd</span> 脚本练习$ vim hello.sh$ sh hello.shWelcome to linux world!hhh</span></span><br></pre></td></tr></table></figure>


<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash#This is my first program#Author:zlxecho -e &#x27;Welcome to linux world!\nhhh&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：在这一段脚本中，#!/bin/Bash这一句是个例外，他并不是注释，是标识，说明以下语句是Shell脚本，解释器是/bin/bash</strong></p>
<h4 id="10-2-3-执行脚本"><a href="#10-2-3-执行脚本" class="headerlink" title="10.2.3 执行脚本"></a><strong>10.2.3 执行脚本</strong></h4><ul>
<li><p><strong>赋予执行权限，直接运行</strong></p>
<ul>
<li><strong>chmod 755 hello.sh</strong></li>
<li><strong>./hello.sh</strong></li>
</ul>
</li>
<li><p><strong>通过Bash调用执行脚本</strong></p>
<ul>
<li><strong>bash hello.sh</strong></li>
<li><strong>或 sh hello.sh  (不需要执行权限就可以执行)</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ ./hello.shbash: ./hello.sh: 权限不够[zlx@zlx-vmwarevirtualplatform 脚本练习]$ chmod 755 hello.sh[zlx@zlx-vmwarevirtualplatform 脚本练习]$ ./hello.shWelcome to linux world!hh[zlx@zlx-vmwarevirtualplatform 脚本练习]$ sh hello.shWelcome to linux world!hh</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-3-Bash的基本功能"><a href="#10-3-Bash的基本功能" class="headerlink" title="10.3 Bash的基本功能"></a><strong>10.3 Bash的基本功能</strong></h3><h4 id="10-3-1-历史命令history与命令补全"><a href="#10-3-1-历史命令history与命令补全" class="headerlink" title="10.3.1 历史命令history与命令补全"></a><strong>10.3.1 历史命令<font color="red">history</font>与命令补全</strong></h4><ul>
<li><p><strong>历史命令</strong></p>
<ul>
<li><p><strong>history [选项] [历史命令保存文件]</strong> </p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><p><strong>-c： 清空历史命令</strong> </p>
</li>
<li><p><strong>-w： 把缓存中的历史命令写入历史命令保存文件 <font color="orange">~/.bash_history </font></strong></p>
<p><strong>历史命令默认会保存 1000 条,可以在环境变量配置文件/etc/profile 中进行修改</strong></p>
</li>
</ul>
</li>
<li><p><strong>历史命令的调用</strong></p>
<ul>
<li><p><strong>使用<font color="orange">上、下箭头</font>调用以前的历史命令</strong></p>
</li>
<li><p><strong>使用“<font color="orange">!n</font>”重复执行第 n 条历史命令</strong></p>
</li>
<li><p><strong>使用“<font color="orange">!!</font>”重复执行上一条命令</strong></p>
</li>
<li><p><strong>使用“<font color="orange">!字串</font>”重复执行最后一条以该字串开头的命令</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ ls公共  模板  视频  图片  文档  下载  音乐  桌面[zlx@zlx-vmwarevirtualplatform ~]$ !!ls公共  模板  视频  图片  文档  下载  音乐  桌面[zlx@zlx-vmwarevirtualplatform ~]$ !lls公共  模板  视频  图片  文档  下载  音乐  桌面</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>命令与文件补全</strong><ul>
<li> <strong>在 Bash 中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或文件时，按“Tab”键就会自动进行补全</strong></li>
</ul>
</li>
</ul>
<h4 id="10-3-2-命令别名alias与常用快捷键"><a href="#10-3-2-命令别名alias与常用快捷键" class="headerlink" title="10.3.2 命令别名alias与常用快捷键"></a><strong>10.3.2 命令别名<font color="red">alias</font>与常用快捷键</strong></h4><ul>
<li><p><strong>命令别名</strong></p>
<ul>
<li><strong>alias 别名=’原命令’         #设定命令别名</strong> </li>
<li><strong>alias        #查询命令别名</strong> </li>
</ul>
</li>
<li><p><strong>命令执行时顺序</strong></p>
<ul>
<li><strong>1 第一顺位执行用<font color="orange">绝对路径或相对路径</font>执行的命令。</strong></li>
<li><strong>2 第二顺位执行<font color="orange">别名</font>。</strong></li>
<li><strong>3 第三顺位执行 <font color="orange">Bash</font>font&gt; 的内部命令。</strong></li>
<li><strong>4 第四顺位执行按照<font color="orange">$PATH 环境变量定义的目录查找顺序</font>找到的第一个命令。</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ alias vi=&#x27;vim&#x27;[zlx@zlx-vmwarevirtualplatform ~]$ aliasalias cp=&#x27;cp -i&#x27;alias df=&#x27;df -h&#x27;alias egrep=&#x27;egrep --colour=auto&#x27;alias fgrep=&#x27;fgrep --colour=auto&#x27;alias free=&#x27;free -m&#x27;alias grep=&#x27;grep --colour=auto&#x27;alias home=&#x27;cd ~&#x27;alias ls=&#x27;ls --color=auto&#x27;alias more=&#x27;less&#x27;alias np=&#x27;nano -w PKGBUILD&#x27;alias vi=&#x27;vim&#x27;#再执行vi时不会调用PATH目录中命令，因为别名的优先级比PATH高#输出系统环境变量定义的目录[zlx@zlx-vmwarevirtualplatform ~]$ echo $PATH/home/zlx/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/var/lib/snapd/snap/bin#查询某条命令所在目录[zlx@zlx-vmwarevirtualplatform ~]$ whereis lsls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz[zlx@zlx-vmwarevirtualplatform ~]$ whereis vivi: /usr/bin/vi /usr/share/man/man1/vi.1.gz /usr/share/man/man1p/vi.1p.gz[zlx@zlx-vmwarevirtualplatform ~]$ whereis vimvim: /usr/bin/vim /usr/share/vim /usr/share/man/man1/vim.1.gz</span><br></pre></td></tr></table></figure></li>
<li><p><strong>让别名永久生效</strong></p>
<ul>
<li><strong>vim /root/.bashrc</strong></li>
</ul>
</li>
<li><p><strong>删除别名</strong></p>
<ul>
<li><strong>unalias 别名</strong></li>
</ul>
</li>
<li><p><strong>Bash 常用快捷键</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>快捷键</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+a</font></strong></td>
<td align="center"><strong>把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移 动到命令行开头时使用。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+e</font></strong></td>
<td align="center"><strong>把光标移动到命令行结尾。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+c</font></strong></td>
<td align="center"><strong>强制终止当前的命令。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+l</font></strong></td>
<td align="center"><strong>清屏，相当于clear命令。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+u</font></strong></td>
<td align="center"><strong>删除或<font color="red">剪切</font>光标之<font color="red">前</font>的命令。我输入了一行很长的命令，不用使用退 格键一个一个字符的删除，使用这个快捷键会更加方便</strong></td>
</tr>
<tr>
<td align="center"><strong>ctrl+k</strong></td>
<td align="center"><strong>删除或剪切光标之<font color="red">后</font>的内容。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+y</font></strong></td>
<td align="center"><strong><font color="red">粘贴</font> ctrl+U或ctrl+K剪切的内容。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+r</font></strong></td>
<td align="center"><strong>在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入 搜索内容，就会从历史命令中搜索。</strong></td>
</tr>
<tr>
<td align="center"><strong><font color="cornflowerblue">ctrl+d</font></strong></td>
<td align="center"><strong>退出当前终端。</strong></td>
</tr>
<tr>
<td align="center"><strong>ctrl+z</strong></td>
<td align="center"><strong>暂停，并放入后台。这个快捷键牵扯工作管理的内容，我们在系统管 理章节详细介绍。</strong></td>
</tr>
<tr>
<td align="center"><strong>ctrl+s</strong></td>
<td align="center"><strong>暂停屏幕输出。</strong></td>
</tr>
<tr>
<td align="center"><strong>ctrl+q</strong></td>
<td align="center"><strong>恢复屏幕输出。</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="10-3-3-输入输出重定向"><a href="#10-3-3-输入输出重定向" class="headerlink" title="10.3.3 输入输出重定向"></a><strong>10.3.3 输入输出重定向</strong></h4><ul>
<li><p><strong>标准输入输出</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210722132956166.png" alt="image-20210722132956166"></strong></p>
</li>
<li><p><strong><font color="red">输出重定向&gt;&gt;</font></strong></p>
<p><strong>就是改变输出方向，比如由屏幕输出到文件，非常有用</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>符号</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>标准输出重定向</strong></td>
<td><strong>命令 &gt; 文件</strong></td>
<td><strong>以<font color="red">覆盖</font>的方式，把命令的正确输出输出到指定的文件或设备当中。</strong></td>
</tr>
<tr>
<td><strong>标准输出重定向</strong></td>
<td><strong>命令 &gt;&gt; 文件</strong></td>
<td><strong>以<font color="red">追加</font>的方式，把命令的正确输出输出到指定的文 件或设备当中。</strong></td>
</tr>
<tr>
<td><strong>标准错误输出重定向</strong></td>
<td><strong>错误命令 2&gt;文件</strong></td>
<td><strong>以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。</strong></td>
</tr>
<tr>
<td><strong>标准错误输出重定向</strong></td>
<td><strong>错误命令 2&gt;&gt;文件</strong></td>
<td><strong>以追加的方式，把命令的错误输出输出到指定的文件或设备当中。</strong></td>
</tr>
</tbody></table>
<p><strong>tip:在输入报错文件中 2和&gt;&gt;必选<font color="red">连着写</font>,标准错误输出不常用</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>符号</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>正确输出和错误输出同时保存</strong></td>
<td><strong>命令 &gt; 文件 2&gt;&amp;1</strong></td>
<td><strong>以覆盖的方式，把正确输出和错误输出都保存到同 一个文件当中。</strong></td>
</tr>
<tr>
<td><strong>正确输出和错误输出同时保存</strong></td>
<td><strong>命令 &gt;&gt; 文件 2&gt;&amp;1</strong></td>
<td><strong>以追加的方式，把正确输出和错误输出都保存到同 一个文件当中。</strong></td>
</tr>
<tr>
<td><strong>正确输出和错误输出同时保存</strong></td>
<td><strong>命令 &amp;&gt; 文件</strong></td>
<td><strong>以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中</strong></td>
</tr>
<tr>
<td><strong>正确输出和错误输出同时保存</strong></td>
<td><strong>命令 &amp;&gt;&gt; 文件</strong></td>
<td><strong>以追加的方式，把正确输出和错误输出都保存到同一个文件当中。</strong></td>
</tr>
<tr>
<td><strong>正确输出和错误输出同时保存</strong></td>
<td><strong>命令 &gt;&gt; 文件1 2&gt;&gt;文件2</strong></td>
<td><strong>把正确的输出追加到文件1中，把错误的输出追加到文件2中。</strong></td>
</tr>
</tbody></table>
<p><strong>tip:命令 &gt;&gt; 文件 2&gt;&amp;1 ，命令 &amp;&gt;&gt;文件 两种保存都一样，只不过是格式不同</strong><br><strong>有一个用法：</strong><br><strong>命令 &amp;&gt;/dev/unll 不管命令是否正确，直接丢人这个文件夹，不保存任何数据，在写shell脚本时有用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ ls &gt;&gt; ./文档/cdx[zlx@zlx-vmwarevirtualplatform ~]$ cat ./文档/cdx公共模板视频图片文档下载音乐桌面[zlx@zlx-vmwarevirtualplatform ~]$ lstbash: lst：未找到命令[zlx@zlx-vmwarevirtualplatform ~]$ lst 2&gt;&gt; ./文档/cdx[zlx@zlx-vmwarevirtualplatform ~]$ cat ./文档/cdx公共模板视频图片文档下载音乐桌面bash: lst：未找到命令[zlx@zlx-vmwarevirtualplatform ~]$ ls &amp;&gt;&gt; ./文档/cdx1[zlx@zlx-vmwarevirtualplatform ~]$ lst &amp;&gt;&gt; ./文档/cdx1[zlx@zlx-vmwarevirtualplatform ~]$ cat ./文档/cdx1公共模板视频图片文档下载音乐桌面bash: lst：未找到命令</span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="red">输入重定向WC</font></strong></p>
<p><strong>不通过键盘输入，通过文件输入，在实际中用的不多，用在给源码包打补丁</strong></p>
<ul>
<li><p><strong>wc [选项] [文件名] :统计某个文件输入的行数、单词数、字节数</strong></p>
</li>
<li><p><strong>选项</strong></p>
<ul>
<li><strong>-c 统计字节数</strong></li>
<li><strong>-w 统计单词数</strong></li>
<li><strong>-l 统计行数</strong></li>
</ul>
</li>
<li><p><strong>用法：</strong><br><strong>命令 <font color="red">&lt; 文件</font> ：把文件作为命令的输入</strong><br><strong>命令<font color="red"> &lt;&lt; 标识符 内容  标识符</font>：把标识符之间内容作为命令的输入</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">统计行数、单词数、字符数[zlx@zlx-vmwarevirtualplatform ~]$ wcjdign ingjgidn ingd jiijijis9e      3       6      33<span class="comment">#统计输入文件[zlx@zlx-vmwarevirtualplatform ~]$ wc &lt; ./文档/cdx 9 10 84#统计输入文件行数[zlx@zlx-vmwarevirtualplatform ~]$ wc -l &lt; ./文档/cdx9#以quit为标识符，统计内容[zlx@zlx-vmwarevirtualplatform ~]$ wc &lt;&lt; quit&gt; jdig&gt; jidigj jidg&gt; jig&gt; quit      3       4      21</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="10-3-4-多命令顺序执行与管道符"><a href="#10-3-4-多命令顺序执行与管道符" class="headerlink" title="10.3.4 多命令顺序执行与管道符"></a><strong>10.3.4 多命令顺序执行与管道符</strong></h4><ul>
<li><strong>多命令顺序执行</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>多命令执行符</strong></th>
<th align="center"><strong>格式</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>；</strong></td>
<td align="center"><strong>命令1 ; 命令2</strong></td>
<td align="center"><strong>多个命令顺序执行，命令之间没有任何逻辑联系，就算第一条报错，第二条也会执行</strong></td>
</tr>
<tr>
<td align="center"><strong>&amp;&amp;</strong></td>
<td align="center"><strong>命令1 &amp;&amp; 命令2</strong></td>
<td align="center"><strong>逻辑与当命令1正确执行，则命令2才会执行 当命令1执行不正确，则命令2不会执行</strong></td>
</tr>
<tr>
<td align="center"><strong>||</strong></td>
<td align="center"><strong>命令1 || 命令2</strong></td>
<td align="center"><strong>逻辑或当命令1 执行不正确，则命令2才会执行 当命令1正确执行，则命令2不会执行</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>例子： [root@localhost ~]# ls ; date ; cd /user ; pwd</strong></li>
</ul>
<ul>
<li><p><strong>磁盘文件复制：</strong></p>
<ul>
<li><strong>dd if=输入文件 of=输出文件 bs=字节数 count=个数</strong> </li>
<li><strong>选项：</strong><ul>
<li><strong>if=输入文件  指定源文件或源设备</strong> </li>
<li><strong>of=输出文件  指定目标文件或目标设备</strong> </li>
<li><strong>bs=字节数  指定一次输入/输出多少字节，即把这些字节看做一个数据块</strong></li>
<li><strong>count=个数  指定输入/输出多少个数据块</strong> </li>
</ul>
</li>
<li><strong>例子：</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000 ; date</span><br></pre></td></tr></table></figure>

<p><strong>[root@localhost ~]# ls anaconda-ks.cfg &amp;&amp; echo yes</strong> </p>
<p><strong>[root@localhost ~]# ls /root/test || echo “no</strong> </p>
<p><strong>[root@localhost ~]# 命令 &amp;&amp; echo yes || echo no</strong></p>
</li>
</ul>
<ul>
<li><p><strong>管道符</strong></p>
<ul>
<li><strong>命令格式：命令 1 | 命令 2</strong> </li>
<li><strong>命令 1 的正确输出作为命令 2 的操作对象</strong></li>
<li><strong>例子：</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll -a /etc/ | more [root@localhost ~]# netstat -an | grep &quot;ESTABLISHED&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>[root@localhost ~]# grep [选项] “搜索内容” 文件名</strong></li>
<li><strong>选项：</strong> <ul>
<li><strong>-i： 忽略大小写</strong> </li>
<li><strong>-n： 输出行号</strong> </li>
<li><strong>-v： 反向查找</strong> </li>
<li><strong>–color=auto 搜索出的关键字用颜色显示</strong></li>
</ul>
</li>
</ul>
<h4 id="10-3-5-通配符与其他特殊符号"><a href="#10-3-5-通配符与其他特殊符号" class="headerlink" title="10.3.5 通配符与其他特殊符号"></a><strong>10.3.5 通配符与其他特殊符号</strong></h4><ul>
<li><p><strong>通配符</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210802142430007.png" alt="image-20210802142430007"></strong></p>
</li>
<li><p><strong>Bash中其他特殊符号</strong></p>
<p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210802142441259.png" alt="image-20210802142441259"></strong></p>
</li>
</ul>
<h3 id="10-4-Bash的变量"><a href="#10-4-Bash的变量" class="headerlink" title="10.4 Bash的变量"></a><strong>10.4 Bash的变量</strong></h3><h4 id="10-4-1-用户自定义的变量"><a href="#10-4-1-用户自定义的变量" class="headerlink" title="10.4.1 用户自定义的变量"></a><strong>10.4.1 用户自定义的变量</strong></h4><h5 id="（1）什么是变量："><a href="#（1）什么是变量：" class="headerlink" title="（1）什么是变量："></a><strong>（1）什么是变量：</strong></h5><p>​        <strong>变量是计算机内存的单元，其中存放的值可以改变。当Shell脚本需要保存一些信息 时，如一个文件名或是一个数字，就把它 存放在一个变量中。每个变量有一个名字 ，所以很容易引用它。使用变量可以保存 有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息。</strong></p>
<h5 id="（2）变量设置规则："><a href="#（2）变量设置规则：" class="headerlink" title="（2）变量设置规则："></a><strong>（2）变量设置规则：</strong></h5><ul>
<li><p><strong>变量名称可以由字母、数字和下划线组成 ，但是不能以数字开头。如果变量名是 “2name”则是错误的。</strong></p>
</li>
<li><p><strong>在Bash中，变量的默认类型都是字符串型 ，如果要进行数值运算，则必需指定变量类型为数值型。</strong></p>
</li>
<li><p><strong>默认变量类型全都是字符串型，和其他语言不太一样</strong></p>
</li>
<li><p><strong>变量用等号连接值，等号左右两侧不能有空格。变量的值如果有空格，需要使用单引号或双引号包括。</strong></p>
</li>
<li><p><strong>在变量的值中，可以使用“\”转义符。</strong></p>
</li>
<li><p><strong>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 “$变量名”或用${变量名}包含。</strong></p>
</li>
<li><p><strong>如果是把命令的结果作为变量值赋予变量 ，则需要使用反引号或$()包含命令。</strong><br><strong>环境变量名建议大写，便于区分。</strong></p>
</li>
</ul>
<h5 id="（3）变量的分类："><a href="#（3）变量的分类：" class="headerlink" title="（3）变量的分类："></a><strong>（3）变量的分类：</strong></h5><ul>
<li><p><strong>用户自定义变量（本地变量）</strong></p>
</li>
<li><p><strong>环境变量:这种变量中主要保存的是和系统操作环境相关的数据。</strong></p>
</li>
<li><p><strong>位置参数变量:这种变量主要是用来向脚本当 中传递参数或数据的，变量名不能自定义，变量作用是固定的。</strong></p>
</li>
<li><p><strong>预定义变量:是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</strong></p>
</li>
</ul>
<h5 id="（4）用户自定义变量"><a href="#（4）用户自定义变量" class="headerlink" title="（4）用户自定义变量"></a><strong>（4）用户自定义变量</strong></h5><ul>
<li><p>​    <strong>变量定义</strong><br><strong>​    例子：</strong><br><strong>​    name=“yang yang”</strong></p>
</li>
<li><p><strong>变量叠加</strong><br><strong>aa=123</strong><br><strong>aa=”$aa”456<br>aa=${aa}789</strong></p>
</li>
<li><p><strong>变量调用</strong><br><strong><font color="red">echo </font>$变量名</strong></p>
</li>
<li><p><strong>变量查看</strong><br><strong><font color="red">set    </font>查看当前系统全部变量</strong></p>
</li>
<li><p><strong>变量删除</strong><br><strong><font color="red">unset </font>变量名</strong></p>
</li>
<li><p>```shell<br>[zlx@zlx-vmwarevirtualplatform 桌面]$ name=’zlx’[zlx@zlx-vmwarevirtualplatform 桌面]$ name=”$name”666[zlx@zlx-vmwarevirtualplatform 桌面]$ name=${name}777[zlx@zlx-vmwarevirtualplatform 桌面]$ echo namename[zlx@zlx-vmwarevirtualplatform 桌面]$ echo $namezlx666777[zlx@zlx-vmwarevirtualplatform 桌面]$ unset name</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### **10.4.2 环境变量 PATH PS1**</span><br><span class="line"></span><br><span class="line">##### **（1）环境变量：**</span><br><span class="line"></span><br><span class="line">​	**用户自定义变量只在当前的Shell中生效， 而环境变量会在当前Shell和这个Shell的所 有子Shell当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的Shell中生效**</span><br><span class="line"></span><br><span class="line">​	**&lt;font color=&#x27;red&#x27;&gt;pstree&lt;/font&gt;:以树结构显示进程**</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ pstreesystemd─┬─ModemManager───2*[&#123;ModemManager&#125;]        ├─NetworkManager───2*[&#123;NetworkManager&#125;]        ├─accounts-daemon───2*[&#123;accounts-daemon&#125;]        ├─avahi-daemon───avahi-daemon        ├─blueman-tray───2*[&#123;blueman-tray&#125;]        ├─bluetoothd		……</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）设置环境变量："><a href="#（2）设置环境变量：" class="headerlink" title="（2）设置环境变量："></a><strong>（2）设置环境变量：</strong></h5><ul>
<li><p><strong><font color="orange">申明变量</font>：export 变量名=变量值</strong> </p>
</li>
<li><p><strong><font color="orange">查询变量</font>：env</strong></p>
</li>
<li><p><strong><font color="orange">变量调用</font>：echo $变量名</strong> </p>
</li>
<li><p><strong><font color="orange">删除变量</font>：unset 变量名</strong></p>
</li>
<li><p><strong>pstree 树形显示进程数</strong><br><strong>没有这条命令可以执行以下命令下载：</strong><br><strong>yum -y install psmisc</strong><br><strong>yum provides /命令 查看没有的命令的安装包 配合yum -y install使用</strong></p>
</li>
</ul>
<h5 id="（3）系统常见环境变量"><a href="#（3）系统常见环境变量" class="headerlink" title="（3）系统常见环境变量"></a><strong>（3）系统常见环境变量</strong></h5><ul>
<li><p><strong><font color="red">PATH</font>:系统查找命令的路径</strong><br><strong>这便是输入命令之前不用输入绝对路径的根本原因，系统会提前在PATH环境变量里的所有路径中查询一遍有没有你输入的命令，找到之后直接执行；</strong></p>
</li>
<li><p><strong>如果你想直接执行shell脚本，不加绝对路径，直接写入PATH环境变量，使用叠加</strong><br><strong>例子：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PATH#PATH变量叠加PATH=&quot;$PATH&quot;:/root/sh #此后，/root/sh路径里面的执行文件都可以在任意目录下直接执行，不过是临时生效</span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="red">PS1</font>：定义<font color="orange">系统提示符</font>的变量 用来改[root@localhost ~]# 这个显示</strong></p>
<ul>
<li><p><strong>\d:显示日期，格式为“星期 月 日”</strong></p>
</li>
<li><p><strong>\h:显示简写主机名。如默认主机名“localhost”</strong></p>
</li>
<li><p><strong>\t:显示24小时制时间，格式为“HH:MM:SS”</strong></p>
</li>
<li><p><strong>\T:显示12小时制时间，格式为“HH:MM:SS”</strong></p>
</li>
<li><p><strong>\A:显示24小时制时间，格式为“HH:MM”</strong></p>
</li>
<li><p><strong>\u:显示当前用户名</strong></p>
</li>
<li><p><strong>\w:显示当前所在目录的完整名称</strong></p>
</li>
<li><p><strong>\W:显示当前所在目录的最后一个目录</strong></p>
</li>
<li><p><strong>#:执行的第几个命令</strong></p>
</li>
<li><p><strong>$:提示符。如果是root用户会显示提示符为“#”，如果是普通用户 会显示提示符为“$”</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ echo $PS1\[\033[01;32m\][\u@\h\[\033[01;37m\] \W\[\033[01;32m\]]\$\[\033[00m\][zlx@zlx-vmwarevirtualplatform 桌面]$ PS1=&#x27;[\u@\t\w]\$&#x27;[zlx@00:16:25~/桌面]$PS1=&#x27;[\u@\@ \h \# \W]\$&#x27;[zlx@12:16 上午 zlx-vmwarevirtualplatform 4 桌面]$PS1=&#x27;[\u@\h \W]$&#x27;[zlx@zlx-vmwarevirtualplatform 桌面]$</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="10-4-3-位置参数变量-n"><a href="#10-4-3-位置参数变量-n" class="headerlink" title="10.4.3 位置参数变量 $n $ $@ $#*"></a><em><em>10.4.3 位置参数变量 $n $</em> $@ $#</em>*</h4><ul>
<li><strong>位置参数变量</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>变量</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>$n</strong></td>
<td><strong>n为数字，$0代表命令本身，$1-9 代 表 第 一 到 第 九 个 参 数 ， 十 以 上 的 参 数 需 要 用 大 括 号 包 含 ，如{10}.</strong></td>
</tr>
<tr>
<td align="center"><strong>$</strong>*</td>
<td>*<em>这个变量代表命令行中所有的参数，$<em>把所有的参数看成一个整体</em></em></td>
</tr>
<tr>
<td align="center"><strong>$@</strong></td>
<td><strong>这个变量也代表命令行中所有的参数，不过 $@把每个参数区分对待</strong></td>
</tr>
<tr>
<td align="center"><strong>$#</strong></td>
<td><strong>这个变量代表命令行中所有参数的个数</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong><font color="red">$n</font> 的例子</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ cat sum.sh#!/bin/bashnum1=$1num2=$2sum=$(($num1+$num2))#变量sum的和是num1+num2echo $sum#打印变量sum的值[zlx@zlx-vmwarevirtualplatform 脚本练习]$ bash sum.sh 2 35</span><br></pre></td></tr></table></figure>



<ul>
<li><em><em><font color="red">S# S</font></em> S@ 的例子</em>*</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ cat showParam.sh #!/bin/bashecho &quot;A total of $# parameters&quot;#使用$#代表所有参数的个数echo &quot;The parameters is:$*&quot;#使用$*代表所有参数echo &quot;The parameters is:$@&quot;#使用$@也代表所有参数[zlx@zlx-vmwarevirtualplatform 脚本练习]$ bash showParam.sh 11 23 45 66A total of 4 parametersThe parameters is:11 23 45 66The parameters is:11 23 45 66</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>S*和S@ 的区别</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ cat diffParam.sh #!/bin/bash#$*中所有的参数看成一个整体，所以这个for循环只会循环一次for i in &quot;$*&quot; do	echo &quot;The parameter is:$i&quot;done#$@中所有的参数都看成是独立的，所以”$@“中有几个参数，就会循环几次x=1for i in &quot;$@&quot;do	echo &quot;The parameter$x is:$i&quot;	x=$(($x+1))done[zlx@zlx-vmwarevirtualplatform 脚本练习]$ bash diffParam.sh 12 34 56 The parameter is:12 34 56The parameter1 is:12The parameter2 is:34The parameter3 is:56</span><br></pre></td></tr></table></figure>



<h4 id="10-4-4-预定义的变量"><a href="#10-4-4-预定义的变量" class="headerlink" title="10.4.4 预定义的变量 $? $$ $!"></a><strong>10.4.4 预定义的变量 $? $$ $!</strong></h4><ul>
<li><strong>预定义变量</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>变量</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>$?</strong></td>
<td><strong>最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行;如果 这个变量的值为非0(具体是哪个数，由命令自己来决定)，则证明上一个命令执行不正确 了。</strong></td>
</tr>
<tr>
<td><strong>$$</strong></td>
<td><strong>当前进程的进程号(PID)</strong></td>
</tr>
<tr>
<td><strong>$!</strong></td>
<td><strong>后台运行的最后一个进程的进程号(PID)</strong></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>例子：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ cat showPID.sh#!/bin/bashecho “The current process is $$”#输出当前进程的PID。#这个PID就是showPID.sh这个脚本执行时，生成的进程的PIDfind ./ -name hello.sh &amp;#使用find命令在root目录下查找hello.sh文件#符号&amp;的意思是把命令放入后台执行，工作管理在系统管理章节会详细介绍echo &quot;The last one Daemon process is $!&quot;[zlx@zlx-vmwarevirtualplatform 脚本练习]$ bash showPID.sh“The current process is 2798”The last one Daemon process is 2799[zlx@zlx-vmwarevirtualplatform 脚本练习]$ ./hello.sh[zlx@zlx-vmwarevirtualplatform 脚本练习]$ echo $?0</span><br></pre></td></tr></table></figure></li>
<li><p><strong>接受键盘输入</strong><br><strong>read [选项] [变量名]</strong></p>
<ul>
<li><strong>-p “提示信息”：在等待read输入时，输出提示信息</strong></li>
<li><strong>-t 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间</strong></li>
<li><strong>-n 字符数：read命令只接受指定的字符数，就会执行</strong></li>
<li><strong>-s: 隐藏输入的数据，适用于机密信息的输入</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ cat keyboard.sh #!/bin/bash #Author: shenchao （E-mail: shenchao@lampbrother.net）read -t 30 -p &quot;Please input your name: &quot; name #提示“请输入姓名”并等待 30 秒，把用户的输入保存入变量 name 中echo &quot;Name is $name &quot; read -s -t 30 -p &quot;Please enter your age: &quot; age #年龄是隐私，所以我们用“-s”选项隐藏输入echo -e &quot;\n&quot; echo &quot;Age is $age &quot; read -n 1 -t 30 -p &quot;Please select your gender[M/F]: &quot; gender#使用“-n 1”选项只接收一个输入字符就会执行（都不用输入回车）echo -e &quot;\n&quot; echo &quot;Sex is $gender&quot;[zlx@zlx-vmwarevirtualplatform 脚本练习]$ bash keyboard.sh Please input your name: zlxName is zlx Please enter your age: Age is 18 Please select your gender[M/F]: MSex is M</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-5-Bash的运算符"><a href="#10-5-Bash的运算符" class="headerlink" title="10.5 Bash的运算符"></a><strong>10.5 Bash的运算符</strong></h3><h4 id="10-5-1-数值运算与运算符"><a href="#10-5-1-数值运算与运算符" class="headerlink" title="10.5.1 数值运算与运算符"></a><strong>10.5.1 数值运算与运算符</strong></h4><h5 id="（1）declare-声明变量类型"><a href="#（1）declare-声明变量类型" class="headerlink" title="（1）declare 声明变量类型"></a><strong>（1）<font color="red">declare </font>声明变量类型</strong></h5><ul>
<li><p><strong><font color="orange">declare [+/-] [选项] 变量名</font></strong></p>
</li>
<li><p><strong>选项：</strong> </p>
<ul>
<li><strong>-： 给变量设定类型属性</strong> </li>
<li><strong>+：取消变量的类型属性</strong> </li>
<li><strong>-i：将变量声明为整数型（integer）</strong> </li>
<li><strong>-x：将变量声明为环境变量</strong> </li>
<li><strong>-p：显示指定变量的被声明的类型</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）数值运算"><a href="#（2）数值运算" class="headerlink" title="（2）数值运算"></a><strong>（2）数值运算</strong></h5><ul>
<li><p><strong>方法1：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> aa=11$ bb=22$ <span class="built_in">declare</span> -i cc=<span class="variable">$aa</span>+$bb$ <span class="built_in">echo</span> <span class="variable">$cc33</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>方法2：<font color="orange">expr </font>或 let 数值运算工具</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> aa=11$ bb=10$ dd=$(expr <span class="variable">$aa</span> + <span class="variable">$bb</span>)<span class="comment"># dd的值是aa和bb的和。注意“+”号左右两侧必须有空格。let和expr一样$ echo $dd21</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>方法3：<font color="orange">$((运算式)) 或 $[运算式]</font>（<font color="red">推荐</font>）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> aa=10$ bb=12$ ee=$((<span class="variable">$aa</span>+<span class="variable">$bb</span>))$ <span class="built_in">echo</span> $ee22$ ff=$[<span class="variable">$aa</span>+<span class="variable">$bb</span>+<span class="variable">$ee</span>]$ <span class="built_in">echo</span> <span class="variable">$ff44</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）运算符优先级"><a href="#（3）运算符优先级" class="headerlink" title="（3）运算符优先级"></a><strong>（3）运算符优先级</strong></h5><table>
<thead>
<tr>
<th align="center"><strong>优先级</strong></th>
<th align="center"><strong>运算符</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>13</strong></td>
<td align="center"><strong>-, +</strong></td>
<td align="center"><strong>单目负、单目正</strong></td>
</tr>
<tr>
<td align="center"><strong>12</strong></td>
<td align="center"><strong>!, ~</strong></td>
<td align="center"><strong>逻辑非、按位取反或补码</strong></td>
</tr>
<tr>
<td align="center"><strong>11</strong></td>
<td align="center">***,/, %    乘、除、取模**</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>+, -</strong></td>
<td align="center"><strong>加、减</strong></td>
</tr>
<tr>
<td align="center"><strong>9</strong></td>
<td align="center"><strong>&lt;&lt; , &gt;&gt;</strong></td>
<td align="center"><strong>按位左移、按位右移</strong></td>
</tr>
<tr>
<td align="center"><strong>8</strong></td>
<td align="center"><strong>&lt; =, &gt; =, &lt; , &gt;</strong></td>
<td align="center"><strong>小于或等于、大于或等于、小于、大于</strong></td>
</tr>
<tr>
<td align="center"><strong>7</strong></td>
<td align="center"><strong>== , !=</strong></td>
<td align="center"><strong>等于、不等于</strong></td>
</tr>
<tr>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>&amp;</strong></td>
<td align="center"><strong>按位与</strong></td>
</tr>
<tr>
<td align="center"><strong>5</strong></td>
<td align="center"><strong>^</strong></td>
<td align="center"><strong>按位异或</strong></td>
</tr>
<tr>
<td align="center"><strong>4</strong></td>
<td align="center"><strong>|</strong></td>
<td align="center"><strong>按位或</strong></td>
</tr>
<tr>
<td align="center"><strong>3</strong></td>
<td align="center"><strong>&amp;&amp;</strong></td>
<td align="center"><strong>逻辑与</strong></td>
</tr>
<tr>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>||</strong></td>
<td align="center"><strong>逻辑或</strong></td>
</tr>
<tr>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>=,+=,-=,*=,/=,%=,&amp;=, ^=,赋值、运算且赋值</strong></td>
<td align="center"><strong>=, &lt;&lt;=, &gt;&gt;=</strong></td>
</tr>
</tbody></table>
<h4 id="10-5-2-变量测试与内容替换"><a href="#10-5-2-变量测试与内容替换" class="headerlink" title="10.5.2 变量测试与内容替换"></a><strong>10.5.2 变量测试与内容替换</strong></h4><ul>
<li><strong>测试表</strong></li>
</ul>
<p>​        <strong>用来测试一个变量到底有没有设置</strong><br><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210803155541740.png" alt="image-20210803155541740"></strong></p>
<ul>
<li><p><strong>例子：</strong></p>
<ul>
<li><p><strong>测试x=${y-新值} 测试y变量存不存在</strong></p>
<p><strong>unset y 删除变量y</strong><br><strong>x=${y-new} 进行测试<br>echo $x</strong><br><strong>显示new，y变量不存在</strong><br><strong>因为变量y不存在，所以x=new</strong></p>
</li>
<li><p><strong>y=”” 给变量y赋值为空</strong><br><strong>x=${y-new} 进行测试<br>echo $x</strong><br><strong>显示空，y为空值</strong></p>
</li>
<li><p><strong>y=old 给变量y赋值</strong><br><strong>x=${y-new} 进行测试<br>echo $x</strong><br><strong>显示old ，y变量存在且有值</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="10-6-环境变量配置文件"><a href="#10-6-环境变量配置文件" class="headerlink" title="10.6 环境变量配置文件"></a><strong>10.6 环境变量配置文件</strong></h3><h4 id="10-6-1-环境变量配置文件简介"><a href="#10-6-1-环境变量配置文件简介" class="headerlink" title="10.6.1 环境变量配置文件简介"></a><strong>10.6.1 环境变量配置文件简介</strong></h4><h5 id="（1）source命令"><a href="#（1）source命令" class="headerlink" title="（1）source命令"></a><strong>（1）<font color="red">source</font>命令</strong></h5><ul>
<li> <strong>命令格式：source 配置文件  或  . 配置文件</strong> </li>
<li> <strong>功能描述：强制使配置文件在修改之后生效，不需要重启</strong></li>
</ul>
<h5 id="（2）简介"><a href="#（2）简介" class="headerlink" title="（2）简介"></a><strong>（2）简介</strong></h5><ul>
<li><p><strong>环境变量配置文件中主要是定义<font color="orange">对系统的操作环境生效的系统默认环境变量</font>，比如 PATH、HISTSIZE、PS1、HOSTNAME等 默认环境变量。</strong></p>
</li>
<li><p><strong>配置文件保持位置</strong></p>
<ul>
<li><p><strong>/etc/profile</strong> </p>
</li>
<li><p><strong>/etc/profile.d/*.sh</strong> </p>
</li>
<li><p><strong>~/.bash_profile</strong> </p>
</li>
<li><p><strong>~/.bashrc</strong> </p>
</li>
<li><p><strong>/etc/bashrc</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="10-6-2-环境变量配置文件作用"><a href="#10-6-2-环境变量配置文件作用" class="headerlink" title="10.6.2 环境变量配置文件作用"></a><strong>10.6.2 环境变量配置文件作用</strong></h4><h5 id="（1）主要的环境变量配置文件"><a href="#（1）主要的环境变量配置文件" class="headerlink" title="（1）主要的环境变量配置文件"></a><strong>（1）主要的环境变量配置文件</strong></h5><ul>
<li><strong>/etc/profile</strong></li>
<li><strong>/etc/profile.d/*.sh    指/etc/profile.d/下所有的.sh结尾的文件</strong></li>
<li><strong>~/.bash_profile</strong></li>
<li><strong>~/.bashrc</strong></li>
<li><strong>/etc/bashrc</strong></li>
<li><strong>tips:</strong><ul>
<li><strong>/etc 目录下的对所有用户都生效</strong></li>
<li><strong>~/.bash_profile 和 ~/.bashrc -&gt; 每个用户自己的配置文件，只对用户生效。</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）环境变量配置文件调用顺序流程图"><a href="#（2）环境变量配置文件调用顺序流程图" class="headerlink" title="（2）环境变量配置文件调用顺序流程图"></a><strong>（2）环境变量配置文件调用顺序流程图</strong></h5><p><strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210806105220081.png" alt="image-20210806105220081"></strong></p>
<ul>
<li><p><strong>上图从左到右如果没有叠加。后面的命令会覆盖前面的命令。 这些是在登陆的时候挨个调用，所以在这里面设置环境变量，登陆之后就会自动设置好</strong></p>
</li>
<li><p><strong>/etc/profile的作用：</strong></p>
<ul>
<li><strong>里面有USER变量、LOGNAME变量、MAIL变量、PATH变量HOSTNAME变量、HISTSIZE变量、umask等环境变量的配置；</strong></li>
<li><strong>调用/etc/profile.d/*.sh 文件</strong></li>
</ul>
</li>
<li><p><strong>~/.bash_profile的作用:</strong></p>
<ul>
<li><strong>调用了~/.bashrc文件。</strong></li>
<li><strong>在PATH变量后面加入了“:$HOME/bin” 这个目录</strong></li>
</ul>
</li>
<li><p><strong>~/.bashrc的作用:</strong></p>
<ul>
<li><strong>定义默认别名</strong></li>
<li><strong>调用/etc/bashrc</strong></li>
</ul>
</li>
<li><p><strong>/etc/bashrc的作用:</strong></p>
<ul>
<li><strong>PS1变量</strong></li>
<li><strong>umask</strong></li>
<li><strong>PATH变量</strong></li>
<li><strong>调用/etc/profile.d/*.sh文件</strong><br><strong>这一块就是进入界面以内，切换shell登陆方式，这种不需要密码，所以和前面的/etc/profile的作用不冲突</strong></li>
</ul>
</li>
</ul>
<h4 id="10-6-3-其他配置文件和登录信息"><a href="#10-6-3-其他配置文件和登录信息" class="headerlink" title="10.6.3 其他配置文件和登录信息"></a><strong>10.6.3 其他配置文件和登录信息</strong></h4><ul>
<li><p><strong>注销时生效的环境变量配置文件</strong></p>
<p><strong>~/.bash_logout ：注销登录时写入</strong></p>
</li>
<li><p><strong>其他配置文件</strong></p>
<p> <strong>~/bash_history：历史命令文件</strong></p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>Shell 登录信息</strong></p>
<ul>
<li><strong>本地终端欢迎信息： /etc/issue</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>转义符</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>\d</strong></td>
<td align="center"><strong>显示当前系统日期</strong></td>
</tr>
<tr>
<td align="center"><strong>\s</strong></td>
<td align="center"><strong>显示操作系统名称</strong></td>
</tr>
<tr>
<td align="center"><strong>\l</strong></td>
<td align="center"><strong>显示登录的终端号，这个比较常用。</strong></td>
</tr>
<tr>
<td align="center"><strong>\m</strong></td>
<td align="center"><strong>显示硬件体系结构，如i386、i686等</strong></td>
</tr>
<tr>
<td align="center"><strong>\n</strong></td>
<td align="center"><strong>显示主机名</strong></td>
</tr>
<tr>
<td align="center"><strong>\o</strong></td>
<td align="center"><strong>显示域名</strong></td>
</tr>
<tr>
<td align="center"><strong>\r</strong></td>
<td align="center"><strong>显示内核版本</strong></td>
</tr>
<tr>
<td align="center"><strong>\t</strong></td>
<td align="center"><strong>显示当前系统时间</strong></td>
</tr>
<tr>
<td align="center"><strong>\u</strong></td>
<td align="center"><strong>显示当前登录用户的序列号</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>远程终端欢迎信息： /etc/issue.net</strong> <ul>
<li><strong>转义符在/etc/issue.net 文件中不能使用</strong></li>
<li><strong>是否显示此欢迎信息，由 ssh 的配置文件/etc/ssh/sshd_config 决定，加入“Banner/etc/issue.net”行才能显示（记得重启 SSH 服务）</strong> </li>
</ul>
</li>
<li><strong>登陆后欢迎信息：/etc/motd , 不管是本地登录，还是远程登录，都可以显示此欢迎信息</strong></li>
</ul>
</li>
</ul>
<h2 id="第十一章-Shell编程"><a href="#第十一章-Shell编程" class="headerlink" title="第十一章 Shell编程"></a><strong>第十一章 Shell编程</strong></h2><h3 id="11-1-基础正则表达式"><a href="#11-1-基础正则表达式" class="headerlink" title="11.1 基础正则表达式"></a><strong>11.1 基础正则表达式</strong></h3><h4 id="11-1-1-正则表达式与通配符"><a href="#11-1-1-正则表达式与通配符" class="headerlink" title="11.1.1 正则表达式与通配符"></a><strong>11.1.1 正则表达式与通配符</strong></h4><ul>
<li><p><strong>正则表达式用来在文件中<font color="orange">匹配符合条件的字符串</font>，正则是<font color="red">包含匹配</font>。<font color="orange">grep、awk、sed </font>等命令可以支持正则表达式。</strong></p>
</li>
<li><p><strong>通配符用来<font color="orange">匹配符合条件的文件名</font>，通配符是<font color="red">完全匹配</font>。<font color="orange">ls、find、cp </font>这些命令不支持正则表达式，所以只能使用 shell 自己的通配符来进行匹配了。</strong></p>
</li>
</ul>
<h4 id="11-1-2-基础正则表达式"><a href="#11-1-2-基础正则表达式" class="headerlink" title="11.1.2 基础正则表达式"></a><strong>11.1.2 基础正则表达式</strong></h4><h5 id="（1）元字符及其作用"><a href="#（1）元字符及其作用" class="headerlink" title="（1）元字符及其作用"></a><strong>（1）<font color="red">元字符及其作用</font></strong></h5><table>
<thead>
<tr>
<th align="center"><strong>元字符</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">*****</td>
<td><strong>匹配前一个字符0次或任意多次。</strong></td>
</tr>
<tr>
<td align="center"><strong>.</strong></td>
<td><strong>匹配除了换行符外任意一个字符。</strong></td>
</tr>
<tr>
<td align="center"><strong>^</strong></td>
<td><strong>匹配行首。例如:^hello会匹配以hello开头的行。</strong></td>
</tr>
<tr>
<td align="center"><strong>$</strong></td>
<td><strong>匹配行尾。例如:hello&amp;会匹配以hello结尾的行。</strong></td>
</tr>
<tr>
<td align="center"><strong>[]</strong></td>
<td><strong>匹配中括号中指定的任意一个字符，只匹配一个字符。 例如:[aoeiu] 匹配任意一个元音字母，[0-9] 匹配任意一位 数字， [a-z] [0-9]匹配小写字和一位数字构成的两位字符。</strong></td>
</tr>
<tr>
<td align="center"><strong>[^]</strong></td>
<td><strong>匹配除中括号的字符以外的任意一个字符。例如:[^0-9] 匹配 任意一位非数字字符，[^a-z] 表示任意一位非小写字母。</strong></td>
</tr>
<tr>
<td align="center">*<em><strong>*</strong></em></td>
<td><strong>转义符。用于取消特殊符号的含义。</strong></td>
</tr>
<tr>
<td align="center"><strong>\{n\}</strong></td>
<td><strong>表示其前面的字符<font color="red">恰好出现</font>n次。例如:[0-9]{4} 匹配4位数字，[1] [3-8] [0-9]{9} 匹配手机号码</strong></td>
</tr>
<tr>
<td align="center"><strong>\{n,\}</strong></td>
<td><strong>表示其前面的字符<font color="red">至少出现</font>n次。例如: [0-9]{2,} 表示两位及以上的数字。</strong></td>
</tr>
<tr>
<td align="center"><strong>\{n,m\}</strong></td>
<td><strong>表示其前面的字符至少出现n次，最多出现m次。例如: [a- z]{6,8} 匹配6到8位的小写字母</strong></td>
</tr>
</tbody></table>
<h5 id="（2）举例【以下匹配均指包含匹配】"><a href="#（2）举例【以下匹配均指包含匹配】" class="headerlink" title="（2）举例【以下匹配均指包含匹配】"></a><strong>（2）举例【以下匹配均指<font color="red">包含匹配</font>】</strong></h5><ul>
<li><p><strong>“*”前一个字符匹配0次，或任意多次</strong></p>
<ul>
<li><p><strong>grep “a*” test_rule.txt</strong><br><strong>#匹配所有内容，包括空白行(匹配包含0个或任意多个a的行，包含0个a&lt;=&gt;所有内容)</strong></p>
</li>
<li><p><strong>grep “aa*” test_rule.txt</strong><br><strong>#匹配至少包含有一个a的行</strong></p>
</li>
<li><p><strong>grep “aaa*” test_rule.txt</strong><br><strong>#匹配最少包含两个连续a的字符串</strong></p>
</li>
</ul>
</li>
<li><p><strong>“.” 匹配除了换行符外任意一个字符</strong></p>
<ul>
<li><strong>grep “s..d” test_rule.txt</strong><br><strong>#“s..d”会匹配在s和d这两个字母之间有两个字符的单词</strong></li>
<li><strong>grep “s.*d” test_rule.txt</strong><br><strong>#匹配在s和d字母之间有任意(个数&gt;=0)字符 (.*等价于任意个数 .)</strong></li>
<li>*<em>grep “.<em>” test_rule.txt</em></em><br><strong>#匹配所有内容，包括空白行（匹配包含0个或任意多个任意字符的行&lt;=&gt;所有内容）</strong></li>
</ul>
</li>
<li><p><strong>“^”匹配行首，“$”匹配行尾</strong></p>
<ul>
<li><strong>grep “^M” test_rule.txt</strong><br><strong>#匹配以大写“M”开头的行</strong></li>
<li><strong>grep “n​$” test_rule.txt</strong><br><strong>#匹配以小写“n”结尾的行</strong></li>
<li><strong>grep -n “^$” test_rule.txt</strong><br><strong>#会匹配空白行</strong></li>
</ul>
</li>
<li><p><strong>“[]” 匹配中括号中指定的任意一个字符，只匹配一个字符</strong></p>
<ul>
<li><strong>grep “s[ao]id” test_rule.txt</strong><br><strong>#匹配s和i字母中，要不是a、要不是o的行</strong></li>
<li><strong>grep “[0-9]” test_rule.txt</strong><br><strong>#匹配任意一个数字</strong></li>
<li><strong>grep “^[a-z]” test_rule.txt</strong><br><strong>#匹配用小写字母开头的行</strong></li>
</ul>
</li>
<li><p><strong>“[^]” 匹配除中括号的字符以外的任意一个字符</strong></p>
<ul>
<li><strong>grep “^[^a-z]” test_rule.txt</strong><br><strong>#匹配不以小写字母开头的行</strong></li>
<li><strong>grep “^[^a-z A-Z]” test_rule.txt</strong><br><strong>#匹配不用字母开头的行</strong></li>
</ul>
</li>
<li><p><strong>“\” 转义符,用于取消特殊符号的含义</strong></p>
<ul>
<li><strong>grep “\.$” test_rule.txt</strong><br><strong>#匹配使用“.”结尾的行</strong></li>
</ul>
</li>
<li><p><strong>“\{n\}”表示其前面的字符恰好出现n次</strong></p>
<ul>
<li><strong>grep “a\{3\}” test_rule.txt</strong><br><strong>#匹配a字母连续出现三次的字符串,即包含aaa的字符串</strong></li>
<li><strong>grep “[0-9]\{3\}” test_rule.txt</strong><br><strong>#匹配包含连续的三个数字的字符串</strong></li>
</ul>
</li>
<li><p><strong>“\{n,\}”表示其前面的字符出现不小于n次</strong></p>
<ul>
<li><p><strong>grep “^[0-9]\{3,\}[a-z]” test_rule.txt</strong></p>
<p><strong>#匹配最少用连续三个数字开头且后跟一个字符的行</strong></p>
</li>
</ul>
</li>
<li><p><strong>“{n,m}”匹配其前面的字符至少出现n次， 最多出现m次</strong></p>
<ul>
<li><strong>grep “sa\{1,3\}i” test_rule.txt</strong><br><strong>#匹配在字母s和字母i之间有最少一个a，最多三个a</strong></li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost test]$ cat test_rule.txt </span><br><span class="line">18286486521</span><br><span class="line">18384681568</span><br><span class="line">18414568468</span><br><span class="line">1530268781@qq.com</span><br><span class="line">1530268781@gmail.com</span><br><span class="line">1530268781@163.com</span><br><span class="line">@qq.com</span><br><span class="line">a@163.com</span><br><span class="line">153@.com</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配包含以181、182、183、184开头的电话号码的行</span></span><br><span class="line">[zlx@localhost test]$ grep &quot;18[1-4][0-9]\&#123;8\&#125;&quot; test_rule.txt </span><br><span class="line">18286486521</span><br><span class="line">18384681568</span><br><span class="line">18414568468</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配包含qq邮箱xxx.qq.com的行</span></span><br><span class="line">[zlx@localhost test]$ grep &quot;.*@qq.com&quot; test_rule.txt 	#错误，.*匹配所有内容包含“空”</span><br><span class="line">1530268781@qq.com</span><br><span class="line">@qq.com</span><br><span class="line">[zlx@localhost test]$ grep &quot;..*@qq.com&quot; test_rule.txt #正确，..*匹配所有内容，且至少有一个字符</span><br><span class="line">1530268781@qq.com</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配包含邮箱 xxx.@xxx.com的行</span></span><br><span class="line">[zlx@localhost test]$ grep &quot;..*@..*\.com&quot; test_rule.txt </span><br><span class="line">1530268781@qq.com</span><br><span class="line">1530268781@gmail.com</span><br><span class="line">1530268781@163.com</span><br><span class="line">a@163.com</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配只有电话号码的行（以电话号码开头和结尾）</span></span><br><span class="line">[zlx@localhost test]$ grep &quot;^18[1-4][1-9]\&#123;8\&#125;&quot; test_rule.txt 	#错误</span><br><span class="line">18286486521jidng</span><br><span class="line">18384681568dg</span><br><span class="line">18414568468</span><br><span class="line">[zlx@localhost test]$ grep &quot;^18[1-4][1-9]\&#123;8\&#125;$&quot; test_rule.txt </span><br><span class="line">18414568468</span><br></pre></td></tr></table></figure>



<h3 id="11-2-字符截取命令"><a href="#11-2-字符截取命令" class="headerlink" title="11.2 字符截取命令"></a><strong>11.2 字符截取命令</strong></h3><h4 id="11-2-1-cut命令"><a href="#11-2-1-cut命令" class="headerlink" title="11.2.1 cut命令"></a><strong>11.2.1 <font color="red">cut</font>命令</strong></h4><ul>
<li><p><strong>命令格式：<font color="red">cut [选项] 文件名</font></strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong><font color="orange">-f</font> 列号： 提取第几列</strong> </li>
<li><strong><font color="orange">-d</font> 分隔符： 按照指定分隔符分割列</strong></li>
</ul>
</li>
<li><p><strong>tips:</strong></p>
<ul>
<li><strong>一般在使用cut命令的时候和管道符“|”连着使用</strong></li>
<li><strong>grep为提取行，cut提取列，而且cut提取的表格中，只能用制表符隔开不能用空格</strong></li>
</ul>
</li>
<li><p><strong>举例：</strong></p>
<ul>
<li><p><strong>[root@localhost ~]# cut -f 2 student.txt</strong> </p>
<p><strong>#提取第二列</strong></p>
</li>
<li><p><strong>[root@localhost ~]# cut -f 2,3 student.txt</strong> </p>
<p><strong>#提取第二第三列</strong></p>
</li>
<li><p><strong>[root@localhost ~]# cut -d “:” -f 1,3 /etc/passwd</strong></p>
<p><strong>#以：为分隔符提取第一第三列</strong></p>
</li>
</ul>
</li>
<li><p><strong>cut 命令的局限：</strong></p>
<p><strong>[root@localhost ~]# df -h | cut -d “ “ -f 1,3</strong></p>
<p><strong>#有空格时提取会出问题</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost 桌面]$ cat student.txt </span><br><span class="line">id	name	gender	mark</span><br><span class="line">1	Li		M		86</span><br><span class="line">2	Shen	M		90</span><br><span class="line">3	Gao		M		83</span><br><span class="line">[zlx@localhost 桌面]$ cut -f 2 student.txt</span><br><span class="line">name</span><br><span class="line">Li</span><br><span class="line">Shen</span><br><span class="line">Gao</span><br><span class="line">[zlx@localhost 桌面]$ cut -f 2,4 student.txt</span><br><span class="line">name	mark</span><br><span class="line">Li		86</span><br><span class="line">Shen	90</span><br><span class="line">Gao		83</span><br><span class="line"></span><br><span class="line">[zlx@localhost 桌面]$ cat student1.txt </span><br><span class="line">id:name:gender:mark</span><br><span class="line">1:Shen:M:90</span><br><span class="line">2:Li:M:86</span><br><span class="line">3:Gao:M:83</span><br><span class="line">[zlx@localhost 桌面]$ cut -d &quot;:&quot; -f 1,3 student1.txt</span><br><span class="line">id:gender</span><br><span class="line">1:M</span><br><span class="line">2:M</span><br><span class="line">3:M</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-2-2-printf命令"><a href="#11-2-2-printf命令" class="headerlink" title="11.2.2 printf命令"></a><strong>11.2.2 <font color="red">printf</font>命令</strong></h4><ul>
<li><p><strong>命令格式：<font color="red">printf  ‘输出类型|输出格式’  输出内容</font></strong></p>
</li>
<li><p><strong>输出类型：</strong> </p>
<ul>
<li><strong>%ns ： 输出字符串。n 是数字指代输出几个字符</strong> </li>
<li><strong>%ni ： 输出整数。n 是数字指代输出几个数字</strong> </li>
<li><strong>%m.nf ： 输出浮点数。m 和 n 是数字，指代输出整数的位数和小数位数。如%8.2f 代表共输出 8 位数， 其中 2 位是小数，6 位是整数。</strong></li>
</ul>
</li>
<li><p><strong>输出格式：</strong> </p>
<ul>
<li><strong>\a : 输出警告声音</strong> </li>
<li><strong>\b : 输出退格键，也就是 Backspace 键</strong> </li>
<li><strong>\f : 清除屏幕</strong> </li>
<li><strong>\n : 换行</strong> </li>
<li><strong>\r : 回车，也就是 Enter 键</strong> </li>
<li><strong>\t : 水平输出退格键，也就是 Tab 键</strong> </li>
<li><strong>\v : 垂直输出退格键，也就是 Tab 键</strong></li>
</ul>
</li>
<li><p><strong>tips：</strong></p>
<ul>
<li><strong>因为每有几个%s代表每几个字符输出一次</strong></li>
<li><strong>在与cat命令结合使用的时候，需要用<font color="orange">$()把cat命令扩起来</font>，使用这种命令赋予变量的方式，才能正确输出文件内容，但是具体格式还得用%s\t 或者%s\n控制</strong></li>
<li><strong>在awk命令的输出中支持print和printf命令,printf主要在awk命令编程中使用</strong><ul>
<li><strong>print:print会在每个输出之后自动加入一 个换行符(Linux默认没有print命令)</strong></li>
<li><strong>printf:printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>举例：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost 桌面]$ printf %s 1 2 3 4 5 6</span><br><span class="line">123456[zlx@localhost 桌面]$ printf %s %s %s 1 2 3 4 5 6</span><br><span class="line"><span class="meta">%</span><span class="bash">s%s123456[zlx@localhost 桌面]$ <span class="built_in">printf</span> <span class="string">&#x27;%s %s %s&#x27;</span> 1 2 3 4 5 6</span></span><br><span class="line">1 2 34 5 6[zlx@localhost 桌面]$ printf &#x27;%s%s%s&#x27; 1 2 3 4 5 6</span><br><span class="line">123456[zlx@localhost 桌面]$ printf &#x27;%s %s %s\n&#x27; 1 2 3 4 5 6</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">不调整格式输出</span></span><br><span class="line">[zlx@localhost 桌面]$ printf &#x27;%s&#x27; $(cat student.txt)</span><br><span class="line">idnamegendermark1LiM862ShenM903GaoM83</span><br><span class="line"><span class="meta">#</span><span class="bash">调整格式输出</span></span><br><span class="line">[zlx@localhost 桌面]$ printf &#x27;%s\t %s\t %s\t %s\t \n&#x27; $(cat student.txt)</span><br><span class="line">id	 name	 gender	 mark	 </span><br><span class="line">1	 Li	 	 M	 	86	 </span><br><span class="line">2	 Shen	 M	 	90	 </span><br><span class="line">3	 Gao	 M	 	83	</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-2-3-awk命令"><a href="#11-2-3-awk命令" class="headerlink" title="11.2.3 awk命令"></a><strong>11.2.3 awk命令</strong></h4><ul>
<li><p><strong>介绍：</strong></p>
<p><strong>awk命令也叫awk编程，可以<font color="orange">识别非制表符的空格</font>，用来解决cut命令解决不了的提取列工作，他是把需要提取的原文件一行一行扫描，扫描每一行中所需要点列，然后把它记录下来，在全部扫描完之后全部打印出来。</strong></p>
</li>
<li><p><strong>命令格式：<font color="red"> awk ‘条件1{动作 1} 条件2{动作 2}…’ 文件名</font></strong></p>
</li>
<li><p><strong>条件(pattern)：一般使用关系表达式作为条件。如x&gt;10</strong></p>
</li>
<li><p><strong>动作(action)：</strong></p>
<ul>
<li><strong>格式化输出</strong></li>
<li><strong>流程控制语句</strong></li>
</ul>
</li>
<li><p><strong>举例：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost 桌面]$ awk &#x27;&#123;printf $2 &quot;\t&quot; $3 &quot;\n&quot;&#125;&#x27; student.txt</span><br><span class="line">name	gender</span><br><span class="line">Li		M</span><br><span class="line">Shen	M</span><br><span class="line">Gao		M</span><br><span class="line">[zlx@localhost 桌面]$ </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@localhost 桌面]$ df -h</span><br><span class="line">文件系统             容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs             872M     0  872M    0% /dev</span><br><span class="line">tmpfs                901M     0  901M    0% /dev/shm</span><br><span class="line">tmpfs                901M   18M  883M    2% /run</span><br><span class="line">tmpfs                901M     0  901M    0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/cl-root   17G  4.3G   13G   26% /</span><br><span class="line">/dev/sda1            976M  193M  716M   22% /boot</span><br><span class="line">tmpfs                181M  1.2M  179M    1% /run/user/42</span><br><span class="line">tmpfs                181M  4.6M  176M    3% /run/user/1000</span><br><span class="line"><span class="meta">#</span><span class="bash">查看第一列与第5列</span></span><br><span class="line">[zlx@localhost 桌面]$ df -h | awk &#x27;&#123;printf $1 &quot;\t&quot; $5 &quot;\n&quot;&#125;&#x27; </span><br><span class="line">文件系统	已用%</span><br><span class="line">devtmpfs	0%</span><br><span class="line">tmpfs	0%</span><br><span class="line">tmpfs	2%</span><br><span class="line">tmpfs	0%</span><br><span class="line">/dev/mapper/cl-root	26%</span><br><span class="line">/dev/sda1	22%</span><br><span class="line">tmpfs	1%</span><br><span class="line">tmpfs	3%</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看cl-root文件系统的已用百分比（grep提取行，awk提取列）</span></span><br><span class="line">[zlx@localhost 桌面]$ df -h | grep cl-root | awk &#x27;&#123;printf $5 &quot;\n&quot;&#125;&#x27;</span><br><span class="line"><span class="meta">26%</span><span class="bash"></span></span><br><span class="line"><span class="bash"></span><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看cl-root文件系统已用百分比数值（grep提取行，awk提取列，cut进一步提取列</span></span><br><span class="line">[zlx@localhost 桌面]$ df -h | grep cl-root | awk &#x27;&#123;printf $5 &quot;\n&quot;&#125;&#x27; | cut -d &#x27;%&#x27; -f 1</span><br><span class="line">26</span><br><span class="line"><span class="meta">#</span><span class="bash">查看cl-root文件系统已用百分比数值（grep提取行，awk提取列后进一步提取列</span></span><br><span class="line">[zlx@localhost 桌面]$ df -h | grep cl-root | awk &#x27;&#123;printf $5 &quot;\n&quot;&#125;&#x27; | awk -F &quot;%&quot; &#x27;&#123;printf $1 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">26</span><br><span class="line">[zlx@localhost 桌面]$ </span><br></pre></td></tr></table></figure></li>
<li><p><strong>BEGION:</strong></p>
<p><strong>#awk ‘BEGIN{printf “This is a transcript \n” } {printf $2 “\t” $6 “\n”}’ student.txt</strong></p>
</li>
<li><p><strong>END:</strong> </p>
<p><strong>#awk ‘END{printf “The End \n” } {printf $2 “\t” $6 “\n”}’ student.txt</strong> </p>
</li>
<li><p><strong>FS:用来指定字段分隔符，写在BEGIN中</strong></p>
<p><strong>#cat /etc/passwd | grep “/bin/bash” | awk ‘BEGIN {FS=”:”} {printf $1 “\t” $3 “\n”}’</strong></p>
</li>
</ul>
<h4 id="10-2-4-sed命令"><a href="#10-2-4-sed命令" class="headerlink" title="10.2.4 sed命令"></a><strong>10.2.4 <font color="red">sed</font>命令</strong></h4><h5 id="（1）sed命令"><a href="#（1）sed命令" class="headerlink" title="（1）sed命令"></a><strong>（1）sed命令</strong></h5><ul>
<li><p><strong>sed 是一种几乎包括在所有 UNIX 平台（包括 Linux）的轻量级流编辑器。sed 主要是用来将数据进行<font color="orange">选取、替换、删除、新增</font>的命令。</strong></p>
</li>
<li><p><strong>命令格式：<font color="red">sed [选项] ‘[动作]’ 文件名</font></strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><p><strong>-n： 一般 sed 命令会把所有数据都输出到屏幕 ， 如果加入此选择，则只会把经过 sed 命令处理的行输出到屏幕。</strong></p>
</li>
<li><p><strong>-e： 允许对输入数据应用多条 sed 命令编辑</strong></p>
</li>
<li><p><strong>-i： 用 sed 的修改结果直接修改读取数据的文件，而不是由屏幕输出</strong></p>
</li>
</ul>
</li>
<li><p><strong>动作: 范围行+参数</strong></p>
<ul>
<li><strong>a : 追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用“\”代表数据未完结。</strong></li>
<li><strong>c : 行替换，用c后面的字符串替换原数据行。替换多行时，除最后一行外，每行末尾需用“\”代表数据未完结。</strong></li>
<li><strong>i : 插入，在当期行前插入一行或多行。插入多行时，除最后 一行外，每行末尾需要用“\”代表数据未完结。</strong></li>
<li><strong>d : 删除，删除指定的行。</strong></li>
<li><strong>p : 打印，输出指定的行。</strong></li>
<li><strong>s : 字串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字串/新字串/g”(和vim中的替换格式类似)。</strong></li>
</ul>
</li>
</ul>
<h5 id="（2）数据选取"><a href="#（2）数据选取" class="headerlink" title="（2）数据选取"></a><strong>（2）数据选取</strong></h5><ul>
<li><p><strong>sed ‘2p’ student.txt</strong> </p>
<p><strong>#打印第二行后打印全部数据。一般sed命令会把所有数据都输出到屏幕 ，只不过会先输出你想要的，这时候就需要-n配合</strong></p>
</li>
<li><p><strong>sed -n ‘2p’ student.txt</strong></p>
<p><strong>#打印第二行</strong></p>
</li>
<li><p><strong>sed -n ‘1,3p’ student.txt</strong></p>
<p><strong>#打印1-3行</strong></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ cat student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">2 	Sc		74	96		87		85.66</span><br><span class="line">3	Gao		99	83		93		91.66</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2p&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">2 	Sc		74	96		87		85.66</span><br><span class="line">3	Gao		99	83		93		91.66</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed -n &#x27;2p&#x27; student.txt </span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed -n &#x27;1,3p&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">2 	Sc		74	96		87		85.66</span><br></pre></td></tr></table></figure>



<h5 id="（3）数据追加"><a href="#（3）数据追加" class="headerlink" title="（3）数据追加"></a><strong>（3）数据追加</strong></h5><ul>
<li><p><strong>sed ‘2a hello’ student.txt</strong><br><strong>#在第二行后追加hello</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2a hello&#x27; student.txt </span><br><span class="line">ID	Name	PHP		Linux	MySQL	Average</span><br><span class="line">1	Liming	82		95		86		87.66</span><br><span class="line">hello</span><br><span class="line">2 	Sc		74		96		87		85.66  </span><br><span class="line">3	Gao		99		83		93		91.66</span><br><span class="line"></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2a hello \ world&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">hello  world</span><br><span class="line">2 	Sc		74	96		87		85.66</span><br><span class="line">3	Gao		99	83		93		91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（4）数据插入"><a href="#（4）数据插入" class="headerlink" title="（4）数据插入"></a><strong>（4）数据插入</strong></h5><ul>
<li><p><strong>sed ‘2i hello \ world’ student.txt</strong><br><strong>在第二行前插入两行数据</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2i hello&#x27; student.txt </span><br><span class="line">ID	Name	PHP		Linux	MySQL	Average</span><br><span class="line">hello</span><br><span class="line">1	Liming	82		95		86		87.66</span><br><span class="line">2 	Sc		74		96		87		85.66</span><br><span class="line">3	Gao		99		83		93		91.66</span><br><span class="line"></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2i hello \ world&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">hello  world</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">2 	Sc	74	96	87	85.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（5）数据删除"><a href="#（5）数据删除" class="headerlink" title="（5）数据删除"></a><strong>（5）数据删除</strong></h5><ul>
<li><p><strong>sed ‘1,3d’ student.txt</strong></p>
<p><strong>#删除1-3行数据后输出</strong></p>
</li>
<li><p><strong>sed -i ‘1,3d’student.txt</strong></p>
<p><strong>#删除1-3行数据（-i 修改数据文件）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;1,3d&#x27; student.txt </span><br><span class="line">3	Gao	99	83	93	91.66</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed -i &#x27;3d&#x27; student.txt </span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ cat student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（6）数据替换"><a href="#（6）数据替换" class="headerlink" title="（6）数据替换"></a><strong>（6）数据替换</strong></h5><ul>
<li><p><strong>行替换：sed ‘2c No such person’ student.txt</strong></p>
<p><strong>#将第二行替换为指定字符串</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;2c No such person&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">No such person</span><br><span class="line">2 	Sc	74	96	87	85.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>字符串替换</strong></p>
<p><strong>sed ‘行范围s/旧字符串/新字符串/g’ 文件名</strong></p>
<ul>
<li><strong>sed ‘3s/74/99/g’ student.txt</strong><br><strong>在第三行中，把74换成99</strong></li>
<li><strong>sed -i ‘3s/74/99/g’ student.txt</strong><br><strong>sed操作的数据直接写入文件</strong></li>
<li><strong>sed -e ‘s/Liming//g ; s/Gao//g’ student.txt</strong><br><strong>同时把“Liming”和“Gao”替换为空（-e 多条sed命令编辑）</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将第三行的99替换为95</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed &#x27;3s/99/95/g&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">3	Gao	95	83	93	91.66</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed -i &#x27;3s/99/95/g&#x27; student.txt </span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ cat student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">3	Gao		95	83	93	91.66</span><br><span class="line"><span class="meta">#</span><span class="bash">将Liming和Gao的成绩替换</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sed -e &#x27;2s/Liming/Gao/g;3s/Gao/Liming/g&#x27; student.txt </span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Gao	82	95	86	87.66</span><br><span class="line">3	Liming	95	83	93	91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-3-字符处理命令"><a href="#11-3-字符处理命令" class="headerlink" title="11.3 字符处理命令"></a><strong>11.3 字符处理命令</strong></h3><h4 id="11-3-1-sort排序命令"><a href="#11-3-1-sort排序命令" class="headerlink" title="11.3.1 sort排序命令"></a><strong>11.3.1 sort排序命令</strong></h4><ul>
<li><p><strong>命令格式： <font color="red">sort [选项] 文件名</font></strong></p>
</li>
<li><p><strong>选项：</strong></p>
<ul>
<li><strong>-f： 忽略大小写</strong> </li>
<li><strong>-n： 以数值型进行排序，默认使用字符串型排序</strong> </li>
<li><strong>-r： 反向排序</strong> </li>
<li><strong>-t： 指定分隔符，默认分隔符是制表符</strong> </li>
<li><strong>-k n[,m]： 按照指定的字段范围排序。从第 n 字段开始， m 字段结束（默认到行尾） （注意：-k 3表示用第3到最后的字段范围排序，-k 3,3 才表示用第三个字段排序）</strong></li>
</ul>
</li>
<li><p><strong>举列</strong></p>
<ul>
<li><p><strong>[root@localhost ~]# sort /etc/passwd</strong> </p>
<p><strong>#排序用户信息文件</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# sort -r /etc/passwd</strong> </p>
<p><strong>#反向排序</strong></p>
</li>
<li><p><strong>[root@localhost ~]# sort -t “:” -k 3,3 /etc/passwd</strong> </p>
<p><strong>#指定分隔符是“：”，用第三字段开头，第三字段结尾排序，就是只用第三字段排序</strong> </p>
</li>
<li><p><strong>[root@localhost ~]# sort -n -t “:” -k 3,3 /etc/passwd</strong> </p>
<p><strong>#指定分隔符是“：”，用第三个字段且以数值型进行排序</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ cat student.txt</span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">2	Sc		98	99		100		99</span><br><span class="line">3	Gao		95	83		93		91.66</span><br><span class="line"><span class="meta">#</span><span class="bash">按平均分从低到高排序</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sort -n -k 6,6 student.txt </span><br><span class="line">ID	Name	PHP		Linux	MySQL	Average</span><br><span class="line">1	Liming	82		95		86		87.66</span><br><span class="line">3	Gao		95		83		93		91.66</span><br><span class="line">2	Sc		98		99		100		99</span><br><span class="line"><span class="meta">#</span><span class="bash">按平均分从高到低排序</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ sort -r -n -k 6,6 student.txt </span><br><span class="line">2	Sc		98	99		100		99</span><br><span class="line">3	Gao		95	83		93		91.66</span><br><span class="line">1	Liming	82	95		86		87.66</span><br><span class="line">ID	Name	PHP	Linux	MySQL	Average</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="11-3-2-wc统计命令"><a href="#11-3-2-wc统计命令" class="headerlink" title="11.3.2 wc统计命令"></a><strong>11.3.2 wc统计命令</strong></h4><ul>
<li><p><strong>命令格式：<font color="red"> wc [选项] 文件名</font></strong></p>
</li>
<li><p><strong>选项：</strong> </p>
</li>
<li><ul>
<li><strong>-l： 只统计行数</strong></li>
<li><strong>-w： 只统计单词数</strong> </li>
<li><strong>-m： 只统计字符数</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ wc student.txt </span><br><span class="line"> 4 24 95 student.txt</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ wc -l student.txt </span><br><span class="line">4 student.txt</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ wc -w student.txt </span><br><span class="line">24 student.txt</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ wc -m student.txt </span><br><span class="line">95 student.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-4-条件判断"><a href="#11-4-条件判断" class="headerlink" title="11.4 条件判断"></a><strong>11.4 条件判断</strong></h3><h4 id="11-4-1-按照文件类型判断"><a href="#11-4-1-按照文件类型判断" class="headerlink" title="11.4.1 按照文件类型判断"></a><strong>11.4.1 按照文件类型判断</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>-b 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为 块设备文件(是块设备文件 为真) block</strong></td>
</tr>
<tr>
<td><strong>-c 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为字符设备文件(是字符设备 文件为真) char</strong></td>
</tr>
<tr>
<td><strong><font color="cornflowerblue">-d 文件</font></strong></td>
<td><strong>判断该文件是否存在，并且是否为目录文件(是目录为真) <font color="red">directory</font></strong></td>
</tr>
<tr>
<td><strong><font color="cornflowerblue">-e 文件</font></strong></td>
<td><strong>判断该文件是否存在(存在为真) <font color="red">exist</font></strong></td>
</tr>
<tr>
<td><strong><font color="cornflowerblue">-f 文件</font></strong></td>
<td><strong>判断该文件是否存在，并且是否为普通文件(是普通文件为真) <font color="red">file</font></strong></td>
</tr>
<tr>
<td><strong>-L 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为符号链接文件(是符号链接 文件为真) link</strong></td>
</tr>
<tr>
<td><strong>-p 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为管道文件(是管道文件为真)  pipe</strong></td>
</tr>
<tr>
<td><strong>-s 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为非空(非空为真)</strong></td>
</tr>
<tr>
<td><strong>-S 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为套接字文件(是套接字文件 为真) Socket</strong></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>两种判断格式：</strong></p>
<ul>
<li><p><strong><font color="red">test 参数 文件路径/文件名</font></strong></p>
<p><strong>#test -e /root/install.log    判断/root/install.log是否存在</strong></p>
</li>
<li><p><strong><font color="red">[ 参数 文件路径/文件名 ]</font>（括号内部左右有空格）</strong></p>
<ul>
<li><p><strong>#[ -e /root/install.log ]</strong></p>
</li>
<li><p><strong>#[ -d /root ] &amp;&amp; echo “yes” || echo “no”</strong> </p>
<p><strong>第一个判断命令如果正确执行，则打印“yes”，否则打印“no”</strong></p>
<p><strong>逻辑与：[ -d /root ]执行为true，echo “yes”才会执行</strong></p>
<p><strong>逻辑或：echo “yes”执行为false，echo “no” 才会执行</strong></p>
</li>
</ul>
</li>
<li><p><strong>举例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">判断是否存在</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> <span class="built_in">test</span> -e student.txt</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> <span class="built_in">test</span> -e student.txt &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> [ -e student.txt ]</span> </span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> [ -e student.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">判断是否存在，且是否为文件|文件夹</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> [ -f student.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> [ -d student.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">no</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="11-4-2-按照文件权限判断"><a href="#11-4-2-按照文件权限判断" class="headerlink" title="11.4.2 按照文件权限判断"></a><strong>11.4.2 按照文件权限判断</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><font color="blue">-r 文件</font></strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有读权限(有读 权限为真) <font color="red">read</font></strong></td>
</tr>
<tr>
<td><strong><font color="cornflowerblue">-w文件</font></strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有写权限(有写 权限为真) <font color="red">write</font></strong></td>
</tr>
<tr>
<td><strong><font color="cornflowerblue">-x 文件</font></strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有执行权限(有执行权限为真) <font color="red">execute</font></strong></td>
</tr>
<tr>
<td><strong>-u 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有SUID权限(有 SUID权限为真)</strong></td>
</tr>
<tr>
<td><strong>-g 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有SGID权限(有 SGID权限为真)</strong></td>
</tr>
<tr>
<td><strong>-k 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有SBit权限(有 SBit权限为真)</strong></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[zlx]$</span><span class="bash"> <span class="built_in">test</span> -r student.txt &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ [ -w sdudent.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform 桌面]$ [ -x sdudent.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash"> sudo su</span></span><br><span class="line">[sudo] zlx 的密码：</span><br><span class="line"><span class="meta">[zlx]#</span><span class="bash"> [ -w student.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"><span class="meta">[zlx]#</span><span class="bash"> [ -x student.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">no</span><br></pre></td></tr></table></figure>



<h4 id="11-4-3-两个文件之间进行比较"><a href="#11-4-3-两个文件之间进行比较" class="headerlink" title="11.4.3 两个文件之间进行比较"></a><strong>11.4.3 两个文件之间进行比较</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>文件1 -nt 文件2</strong></td>
<td><strong>判断文件1的修改时间是否比文件2的新(如果新则为真) <font color="red">new than</font></strong></td>
</tr>
<tr>
<td><strong>文件1 -ot 文件2</strong></td>
<td><strong>判断文件1的修改时间是否比文件2的旧(如果旧则为真) <font color="red">old than</font></strong></td>
</tr>
<tr>
<td><strong>文件1 -ef 文件2</strong></td>
<td><strong>判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法 <font color="red">equal than</font></strong></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ test1.sh -nt test.sh ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">no</span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ test1.sh -ot test.sh ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="11-4-4-两个整数之间进行比较"><a href="#11-4-4-两个整数之间进行比较" class="headerlink" title="11.4.4 两个整数之间进行比较"></a><strong>11.4.4 两个整数之间进行比较</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>整数1 <font color="cornflowerblue">-eq</font> 整数2</strong></td>
<td><strong>判断整数1是否和整数2相等(相等为真) equal</strong></td>
</tr>
<tr>
<td><strong>整数1 <font color="cornflowerblue">-ne</font> 整数2</strong></td>
<td><strong>判断整数1是否和整数2不相等(不相等位置)  not equal</strong></td>
</tr>
<tr>
<td><strong>整数1<font color="cornflowerblue"> -gt </font>整数2</strong></td>
<td><strong>判断整数1是否大于整数2(大于为真) greater than</strong></td>
</tr>
<tr>
<td><strong>整数1 <font color="cornflowerblue">-lt</font>  整数2</strong></td>
<td><strong>判断整数1是否小于整数2(小于位置) lower than</strong></td>
</tr>
<tr>
<td><strong>整数1 <font color="cornflowerblue">-ge</font> 整数2</strong></td>
<td><strong>判断整数1是否大于等于整数2(大于等于为真) greater  equal</strong></td>
</tr>
<tr>
<td><strong>整数1 <font color="cornflowerblue">-le</font> 整数2</strong></td>
<td><strong>判断整数1是否小于等于整数2(小于等于为真) low equal</strong></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">判断11是否大于等于12</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ 11 -ge 12 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">no</span><br><span class="line"><span class="meta">#</span><span class="bash">判断11是否小于等于12</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ 11 -le 12 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="11-4-5-字符串的判断"><a href="#11-4-5-字符串的判断" class="headerlink" title="11.4.5 字符串的判断"></a><strong>11.4.5 字符串的判断</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>-z 字符串</strong></td>
<td><strong>判断字符串是否为空(为空返回真) zero</strong></td>
</tr>
<tr>
<td><strong>-n 字符串</strong></td>
<td><strong>判断字符串是否为非空(非空返回真) not zero</strong></td>
</tr>
<tr>
<td><strong>字串1 == 字串2</strong></td>
<td><strong>判断字符串1是否和字符串2相等(相等返回真)  注意：==左右有空格</strong></td>
</tr>
<tr>
<td><strong>字串1 != 字串2</strong></td>
<td><strong>判断字符串1是否和字符串2不相等(不相等返回真) 注意：!=左右有空格</strong></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zlx]$name=&quot;balabala&quot;</span><br><span class="line">[zlx]$name1=&quot;labalaba&quot;</span><br><span class="line">[zlx]$[ $name == $name1 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line">[zlx]$[ $name != $name1 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="11-4-6-多重体条件判断"><a href="#11-4-6-多重体条件判断" class="headerlink" title="11.4.6 多重体条件判断"></a><strong>11.4.6 多重体条件判断</strong></h4><table>
<thead>
<tr>
<th><strong>测试选项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>判断1 -a 判断2</strong></td>
<td><strong>逻辑与，判断1和判断2都成立，最终的结果才为真 and</strong></td>
</tr>
<tr>
<td><strong>判断1 -o 判断2</strong></td>
<td><strong>逻辑或，判断1和判断2有一个成立，最终的结果就为真 or</strong></td>
</tr>
<tr>
<td><strong>!判断</strong></td>
<td><strong>逻辑非，使原始的判断式取反</strong></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[zlx]$</span><span class="bash">aa=11</span></span><br><span class="line"><span class="meta">#</span><span class="bash">判断变量aa是否为非空，且是否大于等于13</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ -n <span class="variable">$aa</span> -a <span class="variable">$aa</span> -gt 12 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">no</span><br><span class="line"><span class="meta">#</span><span class="bash">判断变量aa是否为非空，且是否小于等于13</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ -n <span class="variable">$aa</span> -a <span class="variable">$aa</span> -lt 12 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br><span class="line"><span class="meta">#</span><span class="bash">判断变量aa是否为非空，或是否大于等于13</span></span><br><span class="line"><span class="meta">[zlx]$</span><span class="bash">[ -n <span class="variable">$aa</span> -o <span class="variable">$aa</span> -gt 12 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span></span></span><br><span class="line">yes</span><br></pre></td></tr></table></figure>





<h3 id="11-5-流程控制"><a href="#11-5-流程控制" class="headerlink" title="11.5 流程控制"></a><strong>11.5 流程控制</strong></h3><h4 id="11-5-1-if语句"><a href="#11-5-1-if语句" class="headerlink" title="11.5.1 if语句"></a><strong>11.5.1 if语句</strong></h4><h5 id="（1）单分支if条件语句"><a href="#（1）单分支if条件语句" class="headerlink" title="（1）单分支if条件语句"></a><strong>（1）单分支if条件语句</strong></h5><ul>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">	程序</span><br><span class="line">fi </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">	then </span><br><span class="line">		程序 </span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li><p><strong>注意：</strong></p>
<ul>
<li><strong>fi：if语句使用fi结尾，和一般语言使用大括号{…}结尾不同</strong></li>
<li><strong>[ 条件判断式 ]：就是使用test命令判断，所以中括号和条件判断式之间必须有空格</strong></li>
<li><strong>then：后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割。也可以换行写入，就不需要“;”了</strong></li>
</ul>
</li>
<li><p><strong>例子：<font color="cornflowerblue">判断分区使用率</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash <span class="comment">#统计根分区使用率</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx</span></span><br><span class="line">rate=$(df -h | grep &quot;/dev/sda1&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f 1)</span><br><span class="line"><span class="meta">#</span><span class="bash">把根分区使用率作为变量值赋给变量rate</span></span><br><span class="line">if [ $rate -ge 80 ]</span><br><span class="line">	then</span><br><span class="line">		echo &quot;Warning! /dev/sda1 is full!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash <span class="comment">#统计根分区使用率</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx</span></span><br><span class="line">rate=$(df -h | grep &quot;/dev/sda1&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f 1)</span><br><span class="line"><span class="meta">#</span><span class="bash">把根分区使用率作为变量值赋给变量rate</span></span><br><span class="line">if [ $rate -ge 80 ];then</span><br><span class="line">	echo &quot;Warning! /dev/sda1 is full!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）双分支if条件语句"><a href="#（2）双分支if条件语句" class="headerlink" title="（2）双分支if条件语句"></a><strong>（2）双分支if条件语句</strong></h5><ul>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式];then </span><br><span class="line">	条件成立时，执行的程序 </span><br><span class="line">else </span><br><span class="line">	条件不成立时，执行的另一个程序</span><br><span class="line">fi </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式] </span><br><span class="line">	then </span><br><span class="line">		条件成立时，执行的程序 </span><br><span class="line">	else </span><br><span class="line">		条件不成立时，执行的另一个程序</span><br><span class="line">fi </span><br></pre></td></tr></table></figure></li>
<li><p><strong>举例</strong></p>
<ul>
<li><p><strong><font color="cornflowerblue">备份文件信息及文件  </font>(注：du -sh 文件 :获取文件夹大小)</strong></p>
<p><strong>备份文件：tar -zcf xxx.tar.gz 目标文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx</span></span><br><span class="line"><span class="meta">#</span><span class="bash">备份/home/zlx/桌面/shellPractice</span></span><br><span class="line">ntpdate asia.pool.ntp.org &amp;&gt; /dev/null #同步系统时间</span><br><span class="line">date=$(date +%y%m%d) #把当前系统时间按照“年月日”格式赋予变量date</span><br><span class="line">size=$(du -sh /home/zlx/桌面/shellPractice) #统计文件夹大小</span><br><span class="line">if [ -d /tmp/backup ] #如果目标存在且是文件夹</span><br><span class="line">	then	</span><br><span class="line">        #将文件夹大小以及备份时间存储到临时文件中</span><br><span class="line">        echo &quot;Date:$date&quot; &gt; /tmp/backup/shellinfo.txt #标准输出重定向（覆盖）</span><br><span class="line">        echo &quot;Size:$size&quot; &gt;&gt; /tmp/backup/shellinfo.txt  #标准输出重定向（追加）</span><br><span class="line">        cd /tmp/backup</span><br><span class="line">        tar -zcf /home/zlx/桌面/shellprac-$date.tar.gz /home/zlx/桌面/shellPractice shellinfo.txt &amp;&gt; /dev/null#打包压缩</span><br><span class="line">        rm -rf /tmp/backup/shellinfo.txt</span><br><span class="line">    else	</span><br><span class="line">        mkdir /tmp/backup</span><br><span class="line">        echo &quot;Data:$date&quot; &gt; /tmp/backup/shellinfo.txt</span><br><span class="line">        echo &quot;Size:$size&quot; &gt;&gt; /tmp/backup/shellinfo.txt</span><br><span class="line">        cd /tmp/backup</span><br><span class="line">        tar -zcf /home/zlx/桌面/shellprac-$date.tar.gz /home/zlx/桌面/shellPractice shellinfo.txt &amp;&gt; /dev/null</span><br><span class="line">        rm -rf /tmp/backup/shellinfo.txt</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="cornflowerblue">判断apache是否启动</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx 2021-08-11</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">apache所在机器ip地址（默认80端口）</span></span><br><span class="line">ipport=127.0.0.1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">获取apache是否是启动状态（通过-w全量匹配tcp的80端口）</span></span><br><span class="line">isopen=$(nmap -sT $ipport | grep -w 80/tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">if [ &quot;$isopen&quot; == &quot;open&quot; ]</span><br><span class="line">   then</span><br><span class="line">        echo &quot;$(date) httpd is ok!&quot; &gt;&gt; /tmp/apache.log</span><br><span class="line">   else</span><br><span class="line">        # 启动apache</span><br><span class="line">        /etc/rc.d/init.d/httpd start &amp;&gt;/dev/null</span><br><span class="line">        echo &quot;$(date) restart httpd!&quot; &gt;&gt; /tmp/apache-err.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><strong>tips：nmap 远程扫描，检查服务是否启动</strong></p>
<pre><code>    **nmap -sT 扫描指定服务器上开启的TCP端口**
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="（3）多分支if条件语句"><a href="#（3）多分支if条件语句" class="headerlink" title="（3）多分支if条件语句"></a><strong>（3）多分支if条件语句</strong></h5><ul>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式1 ];then </span><br><span class="line">	当条件判断式1成立时，执行程序1 </span><br><span class="line">elif [ 条件判断式2 ];then</span><br><span class="line">	当条件判断式2成立时，执行程序2</span><br><span class="line">...省略更多条件... </span><br><span class="line">else </span><br><span class="line">	当所有条件都不成立时，最后执行此程序</span><br><span class="line">fi </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式1 ] </span><br><span class="line">	then </span><br><span class="line">		当条件判断式1成立时，执行程序1 </span><br><span class="line">elif [ 条件判断式2 ] </span><br><span class="line">	then</span><br><span class="line">		当条件判断式2成立时，执行程序2</span><br><span class="line">...省略更多条件... </span><br><span class="line">else </span><br><span class="line">	当所有条件都不成立时，最后执行此程序</span><br><span class="line">fi </span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="cornflowerblue">判断输入的文件类型</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx 2021-08-14</span></span><br><span class="line"><span class="meta">#</span><span class="bash">description:judge file <span class="built_in">type</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">读取键盘输入，并赋给变量file</span></span><br><span class="line">read -p &quot;Please input a filename:&quot; file</span><br><span class="line">if [ -z &quot;$file&quot; ]	#判断输入是否为空</span><br><span class="line">    then</span><br><span class="line">	echo &quot;Error,please input a filename&quot;</span><br><span class="line">	exit 1</span><br><span class="line">elif [ ! -e &quot;$file&quot; ]	#判断输入文件是否存在</span><br><span class="line">    then </span><br><span class="line">	echo &quot;Your input is not a file&quot;</span><br><span class="line">	exit 2</span><br><span class="line">elif [ -f &quot;$file&quot; ]</span><br><span class="line">    then</span><br><span class="line">	echo &quot;$file is a regulare file!&quot;</span><br><span class="line">elif [ -d &quot;$file&quot; ]</span><br><span class="line">    then</span><br><span class="line">	echo &quot;$file is a directory!&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;$file is an other file!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-5-2-case语句"><a href="#11-5-2-case语句" class="headerlink" title="11.5.2 case语句"></a><strong>11.5.2 case语句</strong></h4><ul>
<li><p><strong>多分支case条件语句：case语句和if…elif…else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系（等于关系），而if语句可以判断多种条件关系。</strong></p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量名 in </span><br><span class="line">	&quot;值1&quot;)</span><br><span class="line">		如果变量的值等于值1，则执行程序1 </span><br><span class="line">	;; </span><br><span class="line">	&quot;值2&quot;) </span><br><span class="line">		如果变量的值等于值2，则执行程序2 </span><br><span class="line">	;; </span><br><span class="line">	...省略其他分支... </span><br><span class="line">		*) </span><br><span class="line">   		如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">	;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="cornflowerblue">判断用户输入</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx 2021-08-14</span></span><br><span class="line"><span class="meta">#</span><span class="bash">description:judge the input</span></span><br><span class="line">read -p &quot;Please choose yes/no:&quot; -t 10 choose</span><br><span class="line">case $choose in</span><br><span class="line">	&quot;yes&quot;)</span><br><span class="line">		echo &quot;Your choose is yes!&quot;</span><br><span class="line">	;;</span><br><span class="line">        &quot;no&quot;)</span><br><span class="line">		echo &quot;your choose is no!&quot;</span><br><span class="line">	;;</span><br><span class="line">        *)</span><br><span class="line">		echo &quot;Your choose is error!&quot;</span><br><span class="line">	;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-5-3-for循环"><a href="#11-5-3-for循环" class="headerlink" title="11.5.3 for循环"></a><strong>11.5.3 for循环</strong></h4><h5 id="（1）语法一"><a href="#（1）语法一" class="headerlink" title="（1）语法一"></a><strong>（1）语法一</strong></h5><ul>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3</span><br><span class="line">	do </span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure></li>
<li><p><strong>例子：输出时间</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx 2021-08-14</span></span><br><span class="line"></span><br><span class="line">for time in morning noon afternoon evening</span><br><span class="line">    do</span><br><span class="line">		echo &quot;This time is $time!&quot;</span><br><span class="line">    done</span><br></pre></td></tr></table></figure></li>
<li><p><strong>优点：这种方法看起来很笨，需要把循环次数写入for，但是在系统管理的时候，当我们不确定循环次数的时候，比如解压缩一个文件里所有的压缩包，他会自动加入新的压缩包，这个时候我就需要用这种笨办法，这种后面加次数的也有一个好处，就是循环变量只要是由空格，或者回车，或者tab键隔开的，都可以算在内，所以才<font color="orange">能和cat，ls等命令结合使用</font>，cat命令执行之后显示的结果就是由回车隔开的，都可以算成是循环变量。在加入或者减少压缩包的时候，不需要修改脚本。</strong></p>
</li>
<li><p><strong>例子：<font color="cornflowerblue">批量解压缩</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx 2021-08-14</span></span><br><span class="line"></span><br><span class="line">cd /lamp</span><br><span class="line">ls *.tar.gz &gt; ls.log	#列出所有压缩文件，覆盖重定向到ls.log</span><br><span class="line">for i in $(cat ls.log)	#循环遍历ls.log中每一个压缩文件的记录</span><br><span class="line">    do</span><br><span class="line">        tar -zxf $i &amp;&gt; /dev/null	#解压缩</span><br><span class="line">    done</span><br><span class="line">rm -rf /lamp/ls.log</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）语法二"><a href="#（2）语法二" class="headerlink" title="（2）语法二"></a><strong>（2）语法二</strong></h5><ul>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((初始值;循环控制调节;变量变化))</span><br><span class="line">   do</span><br><span class="line">   	程序</span><br><span class="line">   done</span><br></pre></td></tr></table></figure></li>
<li><p><strong>例子：计算1加到100</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#Author:zlx 2021-08-14</span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for ((i=1;i&lt;=100;i++))</span><br><span class="line">    do</span><br><span class="line">	#s=$(($s+$i))			#数值运算，详见10.5.1</span><br><span class="line">	#s=$[$s+$i]</span><br><span class="line">	#s=$(expr $s + $i)</span><br><span class="line">	let s=s+i</span><br><span class="line">    done</span><br><span class="line">echo &quot;The sum of 1+2+3+...+100 is $s!&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="cornflowerblue">批量创建用户</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zlx</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">批量添加新用户</span></span><br><span class="line">read -p &quot;Please input the number of users: &quot; -t 30 num  #输入创建用户个数</span><br><span class="line">read -p &quot;Please input user name: &quot; -t 30 name   #输入用户名</span><br><span class="line">read -p &quot;Please input the password of users: &quot; -t 30 pass   #输入用户密码</span><br><span class="line"></span><br><span class="line">if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot; -a ! -z &quot;$pass&quot; ]    #判断输入信息是否为空 </span><br><span class="line">    then</span><br><span class="line">    	y=$(echo $num | sed s/&#x27;^[0-9]*$&#x27;//g)    #这里是判断输入的用户个数是否为数字，sed后也可以把^[0-9]*$换为&#x27;s/[0-9]//g&#x27;</span><br><span class="line">        if [ -z &quot;$y&quot; ]  #如果上一条语句输出为空，就是输入的用户个数为数字</span><br><span class="line">            then</span><br><span class="line">                for ((i=1;i&lt;=$num;i++)) #开始循环</span><br><span class="line">                    do</span><br><span class="line">                    	/usr/sbin/useradd &quot;$name$i&quot; &amp;&gt;/dev/null #建立用户</span><br><span class="line">                        echo $pass | /usr/bin/passwd --stdin &quot;$name$i&quot; &amp;&gt;/dev/null      #设置用户密码，与用户名相同</span><br><span class="line">                    done</span><br><span class="line">                    echo &quot;Build seccees!&quot;</span><br><span class="line">        fi</span><br><span class="line">fi </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-5-4-while循环和until循环"><a href="#11-5-4-while循环和until循环" class="headerlink" title="11.5.4 while循环和until循环"></a><strong>11.5.4 while循环和until循环</strong></h4><h5 id="（1）while-循环"><a href="#（1）while-循环" class="headerlink" title="（1）while 循环"></a><strong>（1）while 循环</strong></h5><ul>
<li><p><strong>while循环是不定循环，也称作条件循环 。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。</strong></p>
</li>
<li><p><strong>语法</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ] </span><br><span class="line">	do </span><br><span class="line">		程序 </span><br><span class="line">	done </span><br></pre></td></tr></table></figure></li>
<li><p><strong>从1加到100</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash  </span><br><span class="line">#Author: zlx</span><br><span class="line">#从1加到100</span><br><span class="line"></span><br><span class="line">i=1 </span><br><span class="line">s=0 </span><br><span class="line">while [ $i -le 100 ] #如果变量i的值小于等于100，则执行循环 </span><br><span class="line">	do </span><br><span class="line">        s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+1 )) </span><br><span class="line">	done </span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）until循环"><a href="#（2）until循环" class="headerlink" title="（2）until循环"></a><strong>（2）until循环</strong></h5><ul>
<li><p><strong>until循环，和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。</strong></p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until [ 条件判断式 ] </span><br><span class="line">	do </span><br><span class="line">		程序 </span><br><span class="line">	done </span><br></pre></td></tr></table></figure></li>
<li><p><strong>从1加到100</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">Author: zlx</span></span><br><span class="line"><span class="meta">#</span><span class="bash">从1加到100</span></span><br><span class="line"></span><br><span class="line">i=1 </span><br><span class="line">s=0 </span><br><span class="line">until [ $i -gt 100 ] #循环直到变量i的值大于100，就停止循环 </span><br><span class="line">	do </span><br><span class="line">        s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+1 )) </span><br><span class="line">	done </span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第十二章-服务管理"><a href="#第十二章-服务管理" class="headerlink" title="第十二章 服务管理"></a><strong>第十二章 服务管理</strong></h2><h3 id="12-1服务简介与分类"><a href="#12-1服务简介与分类" class="headerlink" title="12.1服务简介与分类"></a><strong>12.1服务简介与分类</strong></h3><h5 id="（1）服务的分类"><a href="#（1）服务的分类" class="headerlink" title="（1）服务的分类"></a><strong>（1）服务的分类</strong></h5><p>​    <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20200529121600849.png" alt="服务的分类"></strong></p>
<h5 id="（2）启动与自启动"><a href="#（2）启动与自启动" class="headerlink" title="（2）启动与自启动"></a><strong>（2）启动与自启动</strong></h5><ul>
<li><strong>服务启动：就是在当前系统中让服务运行，并提供功能。</strong></li>
<li><strong>服务自启动：自启动是指让服务在系统开机或重启动之后，随着系统的启动而自动启动服务。</strong></li>
</ul>
<h5 id="（3）查询已安装的服务"><a href="#（3）查询已安装的服务" class="headerlink" title="（3）查询已安装的服务"></a><strong>（3）查询已安装的服务</strong></h5><ul>
<li><p><strong>RPM包安装的服务</strong></p>
<ul>
<li><p><strong><font color="red">chkconfig –list</font></strong></p>
<p><strong>查看服务自启动状态，可以看到所有RPM包安装的服务</strong></p>
</li>
<li><p><strong><font color="red">ps aux</font></strong></p>
<p><strong>查看启动服务的进程</strong></p>
</li>
</ul>
</li>
<li><p><strong>源码包安装的服务</strong></p>
<ul>
<li><strong>查看服务安装位置，一般是/usr/local/下</strong></li>
</ul>
</li>
<li><p><strong>RPM 安装服务和源码包安装服务的区别</strong></p>
<ul>
<li><strong>RPM 安装服务和源码包安装服务的区别就是安装位置的不同</strong></li>
<li><strong>源码包安装在指定位置，一般是/usr/local/</strong> </li>
<li><strong>RPM 包安装在默认位置中</strong></li>
</ul>
</li>
</ul>
<h3 id="12-2-rpm包安装服务的管理"><a href="#12-2-rpm包安装服务的管理" class="headerlink" title="12.2 rpm包安装服务的管理"></a><strong>12.2 rpm包安装服务的管理</strong></h3><h4 id="12-2-1-独立的服务管理"><a href="#12-2-1-独立的服务管理" class="headerlink" title="12.2.1 独立的服务管理"></a><strong>12.2.1 独立的服务管理</strong></h4><h5 id="（1）rpm包安装服务的位置"><a href="#（1）rpm包安装服务的位置" class="headerlink" title="（1）rpm包安装服务的位置"></a><strong>（1）rpm包安装服务的位置</strong></h5><ul>
<li><strong>RPM 安装服务和源码包安装服务的区别就是安装位置的不同</strong><ul>
<li><strong>源码包安装在指定位置，一般是/usr/local/</strong> </li>
<li><strong>RPM 包安装在默认位置中</strong></li>
</ul>
</li>
<li><strong>/etc/init.d/    #启动脚本位置</strong></li>
<li><strong>/etc/sysconfig/    #初始化环境配置文件位置</strong></li>
<li><strong>/etc/    #配置文件位置</strong></li>
<li><strong>/etc/xinetd.conf    #xinetd配置文件</strong></li>
<li><strong>/etc/xinetd.d/    #基于xinetd服务的启动脚本</strong></li>
<li><strong>/var/lib/    #服务产生的数据放在这里</strong></li>
<li><strong>/var/log/    #日志</strong></li>
</ul>
<h5 id="（2）独立服务的启动"><a href="#（2）独立服务的启动" class="headerlink" title="（2）独立服务的启动"></a><strong>（2）独立服务的启动</strong></h5><ul>
<li><strong>/etc/rc.d/init.d/独立服务名 start|stop|status|restart</strong></li>
<li><strong>service 独立服务名 start|stop|restart|status</strong></li>
<li><strong>service –status-all</strong> <ul>
<li><strong>查询服务器全部已经安装的RPM包的服务的运行状态</strong></li>
<li><strong>CentOS7为systemctl list-unit-files</strong></li>
</ul>
</li>
</ul>
<h5 id="（3）独立的服务自启动"><a href="#（3）独立的服务自启动" class="headerlink" title="（3）独立的服务自启动"></a><strong>（3）独立的服务自启动</strong></h5><ul>
<li><p><strong>chkconfig [–level 运行级别] [独立服务名] [on|off]</strong></p>
<ul>
<li><strong>chkconfig –level 2345 htttpd on  #下次开机自启动apache</strong></li>
<li><strong>chkconfig –level 2345 htttpd off  #下次开机不自启动apache</strong></li>
</ul>
</li>
<li><p><strong>修改/etc/rc.d/rc.local文件</strong></p>
<p><strong>把“/etc/rc.d/init.d/ 独立服务名 start ”写入文件</strong></p>
</li>
<li><p><strong>使用ntsysv命令管理自启动</strong></p>
<p><strong>如果没有ntsysv命令，yum -y install ntsysv下载即可，不过这个也是红帽专有的</strong></p>
</li>
<li><p><strong><font color="red">tips:service 和 chkconfig 命令的功能在 Centos7 中好像都被抛弃了。被 systemctl 取代。</font></strong></p>
<p><strong><a href="https://blog.csdn.net/cds86333774/article/details/51165361">参考博文：Centos7 下的 systemctl 命令与 service 和 chkconfig</a></strong></p>
</li>
</ul>
<h4 id="12-2-2-基于xinetd服务的管理"><a href="#12-2-2-基于xinetd服务的管理" class="headerlink" title="12.2.2 基于xinetd服务的管理"></a><strong>12.2.2 基于xinetd服务的管理</strong></h4><p>​    <strong>Xinetd：即 extended internet daemon，是新一代的网络守护进程服务程序，又叫超级 Internet 服</strong></p>
<p><strong>务器，常用来管理多种轻量级 Internet 服务。Xinetd 提供类似于 inetd+tcp_wrapper 的功能，但是更</strong></p>
<p><strong>加强大和安全</strong></p>
<p>​    <strong>Telnet协议是TCP/IP协议族中的一员，是Internet远程 登录服务的标准协议和主要方式。不过现在已经被ssh替代。</strong></p>
<h5 id="（1）安装-xinetd-与-telnet"><a href="#（1）安装-xinetd-与-telnet" class="headerlink" title="（1）安装 xinetd 与 telnet"></a><strong>（1）安装 xinetd 与 telnet</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# yum -y install xinetd </span><br><span class="line">[root@localhost ~]# yum -y install telnet-server</span><br></pre></td></tr></table></figure>



<h5 id="（2）xinetd服务的启动"><a href="#（2）xinetd服务的启动" class="headerlink" title="（2）xinetd服务的启动"></a><strong>（2）xinetd服务的启动</strong></h5><ul>
<li><strong>进入配置文件，把disable=yes改为no</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service telnet 	# 服务的名称为 telnet</span><br><span class="line">&#123; </span><br><span class="line">flags = REUSE 	# 标志为 REUSE，设定 TCP/IP socket 可重用</span><br><span class="line">socket_type = stream 	# 使用 TCP 协议数据包 </span><br><span class="line">wait = no 	# 允许多个连接同时连接 </span><br><span class="line">user = root	# 启动服务的用户为 root </span><br><span class="line">server = /usr/sbin/in.telnetd 	# 服务的启动程序 </span><br><span class="line">log_on_failure += USERID 	# 登陆失败后，记录用户的 ID </span><br><span class="line">disable = no 	# 服务不启动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>重启xinetd服务</strong></p>
<p><strong>service xinetd restart</strong></p>
</li>
</ul>
<h5 id="（3）xinetd服务的自启动"><a href="#（3）xinetd服务的自启动" class="headerlink" title="（3）xinetd服务的自启动"></a><strong>（3）xinetd服务的自启动</strong></h5><ul>
<li><p><strong>chkconfig telnet on</strong></p>
</li>
<li><p><strong>ntsysv</strong></p>
<p><strong>基于xinetd的服务自启动和启动是相通的，非常不适合做服务器管理，开启自启动，服务自动启动。关闭自启动，服务也关闭 。</strong></p>
</li>
</ul>
<h3 id="12-3-源码安装服务的管理"><a href="#12-3-源码安装服务的管理" class="headerlink" title="12.3 源码安装服务的管理"></a><strong>12.3 源码安装服务的管理</strong></h3><ul>
<li><p><strong>源码包安装服务的启动</strong><br><strong>使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法。</strong><br><strong>/usr/local/apache2/bin/apachectl start|stop</strong></p>
</li>
<li><p><strong>源码包服务的自启动</strong><br><strong>vi /etc/rc.d/rc.local</strong><br><strong>加入</strong><br><strong>/usr/local/apache2/bin/apachectl start</strong></p>
</li>
<li><p><strong>让源码包服务被服务管理命令识别</strong><br><strong>让源码包的apache服务能被service命令管理启动</strong><br><strong>ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache</strong></p>
</li>
<li><p><strong>让源码包的apache服务能被chkconfig与 ntsysv命令管理自启动</strong></p>
<ul>
<li><strong>在创建好软链接后，修改servic可以扫描的Apache文件</strong><br><strong>vi /etc/init.d/apache</strong><br><strong>#chkconfig: 35 86 76</strong><br><strong>#指定httpd脚本可以被chkconfig命令管理。格式是: chkconfig: 运行级别 启动顺序 关闭顺序</strong><br><strong>启动级别在/etc/rc.d/ 里面查看，rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d这六个就是0-6运行级别中文件的启动以及关闭顺序，启动顺序以S打头，关闭顺序以K打头，只需要找一个没有被占用的数字即可，不能和现有的顺序重叠。</strong><br><strong>#description: source package apache</strong><br><strong>#说明，内容随意</strong><br><strong>只需要写两句英文即可，两句都是注释，都得有#号，写在文件开始。</strong><br><strong>不太推荐修改，使用标准的启动方式就比较好</strong></li>
</ul>
</li>
</ul>
<h3 id="12-4-总结"><a href="#12-4-总结" class="headerlink" title="12.4 总结"></a><strong>12.4 总结</strong></h3><p> <strong><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20200529123748236.png" alt="img"></strong> </p>
<h2 id="第十三章-Linux系统管理"><a href="#第十三章-Linux系统管理" class="headerlink" title="第十三章 Linux系统管理"></a><strong>第十三章 Linux系统管理</strong></h2><h3 id="13-1-进程管理"><a href="#13-1-进程管理" class="headerlink" title="13.1 进程管理"></a><strong>13.1 进程管理</strong></h3><h4 id="13-1-1-进程查看"><a href="#13-1-1-进程查看" class="headerlink" title="13.1.1 进程查看"></a><strong>13.1.1 进程查看</strong></h4><h5 id="（1）进程简介"><a href="#（1）进程简介" class="headerlink" title="（1）进程简介"></a><strong>（1）进程简介</strong></h5><p>​    <strong>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。</strong></p>
<h5 id="（2）进程管理的作用"><a href="#（2）进程管理的作用" class="headerlink" title="（2）进程管理的作用"></a><strong>（2）进程管理的作用</strong></h5><ul>
<li><p><strong>判断服务器健康状态</strong></p>
</li>
<li><p><strong>查看系统中所有进程</strong></p>
</li>
<li><p><strong>杀死进程</strong></p>
</li>
</ul>
<h5 id="（3）查看系统中所有进程"><a href="#（3）查看系统中所有进程" class="headerlink" title="（3）查看系统中所有进程"></a><strong>（3）查看系统中所有进程</strong></h5><ul>
<li><p><strong>ps aux</strong><br><strong>查看系统中所有进程，使用BSD操作系统格式。(Unix)</strong></p>
</li>
<li><p><strong>ps -le</strong><br><strong>查看系统中所有进程，使用Linux标准命令格式。</strong></p>
</li>
<li><p><strong>ps aux 输出信息</strong></p>
<ul>
<li><strong>USER:该进程是由哪个用户产生的;</strong></li>
<li><strong>PID:进程的ID号;</strong></li>
<li><strong>%CPU:该进程占用CPU资源的百分比，占用越高，进程 越耗费资源;</strong></li>
<li><strong>%MEM:该进程占用物理内存的百分比，占用越高，进程 越耗费资源;</strong></li>
<li><strong>VSZ:该进程占用虚拟内存的大小，单位KB;</strong></li>
<li><strong>RSS:该进程占用实际物理内存的大小，单位KB;</strong></li>
<li><strong>TTY:该进程是在哪个终端中运行的。其中tty1-tty7代表 本地控制台终端，tty1-tty6是本地的字符界面终端，tty7是图形终端。pts/0-255代表虚拟终端。</strong></li>
<li><strong>STAT:进程状态。常见的状态有:R:运行、S:睡眠 、T:停止状态、s:包含子进程、+:位于后台</strong></li>
<li><strong>START:该进程的启动时间</strong></li>
<li><strong>TIME:该进程占用CPU的运算时间，注意不是系统时间</strong></li>
<li><strong>COMMAND:产生此进程的命令名</strong></li>
</ul>
</li>
<li><p><strong>查看系统健康状态</strong><br><strong>top [选项]</strong></p>
<ul>
<li><strong>-d 秒数: 指定top命令每隔几秒更新。默认是3秒 在top命令的交互模式当中可以执行的命令</strong></li>
<li><strong>?或h: 显示交互模式的帮助</strong></li>
<li><strong>P: 以CPU使用率排序，默认就是此项</strong></li>
<li><strong>M: 以内存的使用率排序</strong></li>
<li><strong>N: 以PID排序</strong></li>
<li><strong>q: 退出top</strong></li>
</ul>
</li>
</ul>
<p><strong>第一行信息为任务队列信息</strong> </p>
<table>
<thead>
<tr>
<th><strong>内容</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>12:26:46</strong></td>
<td><strong>系统当前时间</strong></td>
</tr>
<tr>
<td><strong>up 1 day, 13:32</strong></td>
<td><strong>系统的运行时间，本机已经运行1天 13小时32分钟</strong></td>
</tr>
<tr>
<td><strong>2 users</strong></td>
<td><strong>当前登录了两个用户</strong></td>
</tr>
<tr>
<td><strong>load average: 0.00, 0.00, 0.00</strong></td>
<td><strong>系统在之前1分钟，5分钟，15分钟 的平均负载。一般认为小于1时，负 载较小。如果大于1，系统已经超出 负荷。</strong></td>
</tr>
</tbody></table>
<p><strong>第二行为进程信息</strong></p>
<table>
<thead>
<tr>
<th><strong>内容</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Tasks: 95 total</strong></td>
<td><strong>系统中的进程总数</strong></td>
</tr>
<tr>
<td><strong>1 running</strong></td>
<td><strong>正在运行的进程数</strong></td>
</tr>
<tr>
<td><strong>94 sleeping</strong></td>
<td><strong>睡眠的进程</strong></td>
</tr>
<tr>
<td><strong>0 stopped</strong></td>
<td><strong>正在停止的进程</strong></td>
</tr>
<tr>
<td><strong>0 zombie</strong></td>
<td><strong>僵尸进程。如果不是0，需要手工检查僵尸进程</strong></td>
</tr>
</tbody></table>
<p><strong>第三行为CPU信息</strong></p>
<table>
<thead>
<tr>
<th><strong>内容</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cpu(s): 0.1%us</strong></td>
<td><strong>用户模式占用的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.1%sy</strong></td>
<td><strong>系统模式占用的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.0%ni</strong></td>
<td><strong>改变过优先级的用户进程占用的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>99.7%id</strong></td>
<td><strong>空闲CPU的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.1%wa</strong></td>
<td><strong>等待输入/输出的进程的占用CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.0%hi</strong></td>
<td><strong>硬中断请求服务占用的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.1%si</strong></td>
<td><strong>软中断请求服务占用的CPU百分比</strong></td>
</tr>
<tr>
<td><strong>0.0%st</strong></td>
<td><strong>st(Steal time)虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比。</strong></td>
</tr>
</tbody></table>
<p><strong>第四行为物理内存信息</strong></p>
<table>
<thead>
<tr>
<th><strong>内容</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mem: 625344k total</strong></td>
<td><strong>物理内存的总量，单位KB</strong></td>
</tr>
<tr>
<td><strong>571504k used</strong></td>
<td><strong>已经使用的物理内存数量</strong></td>
</tr>
<tr>
<td><strong>53840k free</strong></td>
<td><strong>空闲的物理内存数量，我们使用的是虚 拟机，总共只分配了628MB内存，所以 只有53MB的空闲内存了</strong></td>
</tr>
<tr>
<td><strong>65800k buffers</strong></td>
<td><strong>作为缓冲的内存数量</strong></td>
</tr>
</tbody></table>
<p><strong>第五行为交换分区(swap)信息</strong></p>
<table>
<thead>
<tr>
<th><strong>内容</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Swap: 524280k total</strong></td>
<td><strong>交换分区(虚拟内存)的总大小</strong></td>
</tr>
<tr>
<td><strong>0k used</strong></td>
<td><strong>已经使用的交互分区的大小</strong></td>
</tr>
<tr>
<td><strong>524280k free</strong></td>
<td><strong>空闲交换分区的大小</strong></td>
</tr>
<tr>
<td><strong>409280k cached</strong></td>
<td><strong>作为缓存的交互分区的大小</strong></td>
</tr>
</tbody></table>
<h5 id="（4）查看进程树"><a href="#（4）查看进程树" class="headerlink" title="（4）查看进程树"></a><strong>（4）查看进程树</strong></h5><ul>
<li><strong>pstree [选项]</strong><ul>
<li><strong>-p: 显示进程的PID</strong></li>
<li><strong>-u: 显示进程的所属用户</strong></li>
</ul>
</li>
</ul>
<h4 id="13-1-2-终止进程"><a href="#13-1-2-终止进程" class="headerlink" title="13.1.2 终止进程"></a><strong>13.1.2 终止进程</strong></h4><h5 id="（1）kill命令"><a href="#（1）kill命令" class="headerlink" title="（1）kill命令"></a><strong>（1）kill命令</strong></h5><ul>
<li><p><strong>kill [信号代号] PID</strong> </p>
</li>
<li><p> <strong>kill –l    # 查看可用的进程信号</strong> </p>
</li>
<li><p> <strong>常用进程信号表</strong> </p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>信号代号</strong></th>
<th><strong>信号名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><strong>SIGHUP</strong></td>
<td><strong>该信号让进程立即关闭，然后重新读取配置文件之后重启。</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>SIGINT</strong></td>
<td><strong>程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷 键。</strong></td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><strong>SIGFPE</strong></td>
<td><strong>在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。</strong></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td><strong>SIGKILL</strong></td>
<td><strong>用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。 一般用于强制终止进程。</strong></td>
</tr>
<tr>
<td><strong>14</strong></td>
<td><strong>SIGALRM</strong></td>
<td><strong>时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数 使用该信号。</strong></td>
</tr>
<tr>
<td><strong>15</strong></td>
<td><strong>SIGTERM</strong></td>
<td><strong>正常结束进程的信号，kill命令的默认信号。有时如果进程已 经发生问题，这个信号是无法正常终止进程的，我们才会尝 试SIGKILL信号，也就是信号9。</strong></td>
</tr>
<tr>
<td><strong>18</strong></td>
<td><strong>SIGCONT</strong></td>
<td><strong>该信号可以让暂停的进程恢复执行，本信号不能被阻断。</strong></td>
</tr>
<tr>
<td><strong>19</strong></td>
<td><strong>SIGSTOP</strong></td>
<td><strong>该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号 不能被阻断。</strong></td>
</tr>
</tbody></table>
<h5 id="（2）-killall命令"><a href="#（2）-killall命令" class="headerlink" title="（2） killall命令"></a><strong>（2） killall命令</strong></h5><ul>
<li><strong>killall [选项][信号代号] 进程名</strong><ul>
<li><strong>按照进程名杀死进程</strong></li>
<li><strong>-i: 交互式，询问是否要杀死某个进程</strong></li>
<li><strong>-I: 忽略进程名的大小写</strong><br><strong>和kill不一样，他加进程名</strong></li>
</ul>
</li>
</ul>
<h5 id="（3）-pkill命令"><a href="#（3）-pkill命令" class="headerlink" title="（3） pkill命令"></a><strong>（3） pkill命令</strong></h5><ul>
<li><p><strong>pkill [选项] [信号] 进程名</strong></p>
<ul>
<li><p><strong>按照进程名终止进程</strong></p>
</li>
<li><p><strong>-t 终端号: 按照终端号踢出用户</strong></p>
<p><strong>按照终端号踢出用户</strong></p>
<ul>
<li><strong>w</strong><br><strong>使用w命令查询本机已经登录的用户</strong></li>
<li><strong>pkill -t -9 pts/1</strong><br><strong>强制杀死从pts/1虚拟终端登录的进程</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-2-工作管理"><a href="#13-2-工作管理" class="headerlink" title="13.2 工作管理"></a><strong>13.2 工作管理</strong></h3><h4 id="13-2-1-把进程放入后台"><a href="#13-2-1-把进程放入后台" class="headerlink" title="13.2.1 把进程放入后台"></a><strong>13.2.1 把进程放入后台</strong></h4><ul>
<li><p> <strong>命令后面加&amp;</strong> </p>
</li>
<li><p><strong>例子：</strong><br><strong>tar -zcf etc.tar.gz /etc &amp; （后台运行）</strong><br><strong>但是像top，vim和用户交互的命令放在后台自动停止，不再运行</strong></p>
</li>
<li><p><strong>运行界面按按ctrl+z</strong></p>
<ul>
<li><strong>例子：</strong><br><strong>top</strong><br><strong>在top命令执行的过程中，按ctrl+z快捷键放入后台（后台暂停）</strong></li>
</ul>
</li>
</ul>
<h4 id="13-2-2-查看后台的工作"><a href="#13-2-2-查看后台的工作" class="headerlink" title="13.2.2 查看后台的工作"></a><strong>13.2.2 查看后台的工作</strong></h4><ul>
<li><strong>jobs [-l]</strong><ul>
<li><strong>-l 显示工作的PID</strong><br><strong>注意：“+”号代表最近一个放入后台的工作，也是工作恢复时，默认恢复的工作。“-”号代表倒数第二个放入后台的工作</strong></li>
</ul>
</li>
</ul>
<h4 id="13-2-3-将后台暂停的工作恢复到前台执行"><a href="#13-2-3-将后台暂停的工作恢复到前台执行" class="headerlink" title="13.2.3 将后台暂停的工作恢复到前台执行"></a><strong>13.2.3 将后台暂停的工作恢复到前台执行</strong></h4><ul>
<li><strong>fg %工作号</strong><br><strong>%工作号：%号可以省略，但是注意工作号和PID到区别</strong></li>
</ul>
<h4 id="13-2-4-把后台暂停的工作恢复到后台执行"><a href="#13-2-4-把后台暂停的工作恢复到后台执行" class="headerlink" title="13.2.4  把后台暂停的工作恢复到后台执行"></a><strong>13.2.4  把后台暂停的工作恢复到后台执行</strong></h4><ul>
<li><strong>bg %工作号</strong><br><strong>注意：后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行</strong></li>
</ul>
<h3 id="13-3-系统资源查看"><a href="#13-3-系统资源查看" class="headerlink" title="13.3 系统资源查看"></a><strong>13.3 系统资源查看</strong></h3><ul>
<li><p><strong>vmstat命令监控系统资源</strong><br><strong>vmstat [刷新延时 刷新次数]</strong><br><strong>例子：</strong><br><strong>vmstat 1 3</strong></p>
</li>
<li><p><strong>dmesg开机时内核检测信息</strong><br><strong>dmesg</strong><br><strong>例子：</strong></p>
<p><strong>dmesg | grep CPU</strong></p>
</li>
<li><p><strong>free命令查看内存使用状态</strong><br><strong>free [-b|-k|-m|-g]</strong></p>
<ul>
<li><strong>-b: 以字节为单位显示</strong><br><strong>-k: 以KB为单位显示，默认就是以KB为单位显示</strong><br><strong>-m: 以MB为单位显示</strong><br><strong>-g: 以GB为单位显示</strong></li>
</ul>
</li>
<li><p><strong>缓存和缓冲的区别</strong><br><strong>简单来说缓存(cache)是用来加速数据 从硬盘中“读取”的，而缓冲(buffer) 是用来加速数据“写入”硬盘的。</strong></p>
</li>
</ul>
<ul>
<li><strong>查看CPU信息</strong><br><strong>cat /proc/cpuinfo</strong></li>
</ul>
<ul>
<li><strong>uptime命令</strong><br><strong>uptime</strong><br><strong>显示系统的启动时间和平均负载，也就是top命令的第一行。w命令也可以看到这个数据。</strong></li>
</ul>
<ul>
<li><strong>查看系统与内核相关信息</strong><br><strong>uname [选项]</strong></li>
</ul>
<ul>
<li><strong>-a: 查看系统所有相关信息;</strong><br><strong>-r: 查看内核版本;</strong><br><strong>-s: 查看内核名称。</strong></li>
</ul>
<ul>
<li><strong>判断当前系统的位数</strong><br><strong>没有直接的命令可以查看</strong><br><strong>只能通过查看系统外部命令的文件类型，顺带写出位数</strong><br><strong>file /bin/ls</strong></li>
</ul>
<ul>
<li><strong>查询当前Linux系统的发行版本</strong><br><strong>lsb_release -a</strong></li>
</ul>
<ul>
<li><strong>列出进程打开或使用的文件信息</strong><br><strong>lsof [选项]</strong><br><strong>列出进程调用或打开的文件的信息</strong><ul>
<li><strong>-c 字符串: 只列出以字符串开头的进程打开的文件</strong></li>
<li><strong>-u 用户名: 只列出某个用户的进程打开的文件</strong></li>
<li><strong>-p pid: 列出某个PID进程打开的文件</strong></li>
</ul>
</li>
</ul>
<h3 id="13-4-系统定时任务"><a href="#13-4-系统定时任务" class="headerlink" title="13.4 系统定时任务"></a><strong>13.4 系统定时任务</strong></h3><ul>
<li><p>crond服务管理与访问控制</p>
<ul>
<li>service crond restart 启动</li>
<li>chkconfig crond on 自启动</li>
</ul>
</li>
<li><p>用户的crontab设置<br>crontab [选项]</p>
<ul>
<li><p>-e: 编辑crontab定时任务<br>-l: 查询crontab任务<br>-r: 删除当前用户所有的crontab 任务 ，如果想删一个，-e进去之后删除</p>
</li>
<li><p>crontab -e 标准格式<br>进入crontab编辑界面。会打开vim编辑你的工作。</p>
<p>*****执行的任务<br>其中*号代表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个“*”</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个“*”</td>
<td>一天当中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个“*”</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个“*”</td>
<td>一年当中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个“*”</td>
<td>一周当中的星期几</td>
<td>0-7(0和7都代表星期日)</td>
</tr>
</tbody></table>
<p> <strong>这个表可以配合特殊符号使用：</strong> </p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间。比如第一个“*”就代表一小时中 每分钟都执行一次的意思。</td>
</tr>
<tr>
<td>，</td>
<td>代表不连续的时间。比如“0 8,12,16 * * * 命令”， 就代表在每天的8点0分，12点0分，16点0分都执 行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间范围。比如“0 5 * * 1-6命令”， 代表在周一到周六的凌晨5点0分执行命令</td>
</tr>
<tr>
<td>*/n</td>
<td>代表每隔多久执行一次。比如“*/10 * * * * 命 令”，代表每隔10分钟就执行一遍命令</td>
</tr>
</tbody></table>
<p><strong>例子：</strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>45 22 * * *</td>
<td>命令 在22点45分执行命令</td>
</tr>
<tr>
<td>0 17 * * 1</td>
<td>命令 每周1 的17点0分执行命令</td>
</tr>
<tr>
<td>0 5 1,15 * *</td>
<td>命令 每月1号和15号的凌晨5点0分执行命 令</td>
</tr>
<tr>
<td>40 4 * * 1-5</td>
<td>命令 每周一到周五的凌晨4点40分执行命 令</td>
</tr>
<tr>
<td>*/10 4 * * *</td>
<td>命令 每天的凌晨4点，每隔10分钟执行一 次命令</td>
</tr>
<tr>
<td>0 0 1,15 * 1</td>
<td>命令 每月1号和15号，每周1的0点0分都会 执行命令。注意:星期几和几号最好 不要同时出现，因为他们定义的都是 天。非常容易让管理员混乱。</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="第十四章-日志管理"><a href="#第十四章-日志管理" class="headerlink" title="第十四章 日志管理"></a>第十四章 日志管理</h2><h3 id="14-1-日志管理简介"><a href="#14-1-日志管理简介" class="headerlink" title="14.1 日志管理简介"></a>14.1 日志管理简介</h3><h4 id="14-1-1-日志服务"><a href="#14-1-1-日志服务" class="headerlink" title="14.1.1 日志服务"></a>14.1.1 日志服务</h4><ul>
<li><p>在CentOS 6.x中日志服务已经由rsyslogd取代了原先的syslogd服务。rsyslogd日志服务更加先进，功能更多。但是不论该服务的使用，还是日志文件的格式其实都是和syslogd服务相兼容的，所以学习起来基本和syslogd服务一致。</p>
</li>
<li><p>rsyslogd的新特点:</p>
<ul>
<li>基于TCP网络协议传输日志信息;</li>
<li>更安全的网络传输方式;</li>
<li>有日志消息的及时分析框架;</li>
<li>后台数据库;</li>
<li>配置文件中可以写简单的逻辑判断;</li>
<li>与syslog配置文件相兼容。</li>
</ul>
</li>
<li><p>确定服务启动</p>
<ul>
<li>ps aux | grep rsyslogd<br>查看服务是否启动</li>
<li>chkconfig –list | grep rsyslog<br>查看服务是否自启动</li>
<li>CentOS 7 变为 systrmctl list-unit-files | grep rsyslog</li>
</ul>
</li>
</ul>
<h4 id="14-1-2常见日志的作用"><a href="#14-1-2常见日志的作用" class="headerlink" title="14.1.2常见日志的作用"></a>14.1.2常见日志的作用</h4><table>
<thead>
<tr>
<th>日志文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/var/log/cron</td>
<td>记录了系统定时任务相关的日志。</td>
</tr>
<tr>
<td>/var/log/cups/</td>
<td>记录打印信息的日志</td>
</tr>
<tr>
<td>/var/log/dmesg</td>
<td>记录了系统在开机时内核自检的信息。也可以使用 dmesg命令直接查看内核自检信息。</td>
</tr>
<tr>
<td>/var/log/btmp</td>
<td>记录错误登录的日志。这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看，命令如下: lastbroot tty1 Tue Jun 4 22:38 - 22:38 (00:00) 有人在6月4日22:38使用root用户，在本地终端1登录错误</td>
</tr>
<tr>
<td>/var/log/lastlog</td>
<td>记录系统中所有用户最后一次的登录时间的日志。这个文件也是二进制文件，不能直接vi，而要使用lastlog命令查看。</td>
</tr>
<tr>
<td>/var/log/mailog</td>
<td>记录邮件信息。</td>
</tr>
<tr>
<td>/var/log/message</td>
<td>记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件</td>
</tr>
<tr>
<td>/var/log/secure</td>
<td>记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录。 比如说系统的登录，ssh的登录，su切换用户，sudo授权，甚至添加 用户和修改用户密码都会记录在这个日志文件中。</td>
</tr>
<tr>
<td>/var/log/wtmp</td>
<td>永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、 关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需 要使用last命令来查看。</td>
</tr>
<tr>
<td>/var/run/utmp</td>
<td>记录当前已经登录的用户的信息。这个文件会随着用户的登录和注 销而不断变化，只记录当前登录用户的信息。同样这个文件不能直 接vi，而要使用w，who，users等命令来查询。</td>
</tr>
</tbody></table>
<p> <strong>除了系统默认的日志之外，采用RPM方 式安装的系统服务也会默认把日志记录在/var/log/目录中(源码包安装的服务日志 是在源码包指定目录中)。不过这些日志不是由rsyslogd服务来记录和管理的，而 是各个服务使用自己的日志管理文档来记录自身日志。</strong> </p>
<table>
<thead>
<tr>
<th>日志文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/var/log/httpd/</td>
<td>RPM包安装的apache服务的默认日志目录</td>
</tr>
<tr>
<td>/var/log/mail/</td>
<td>RPM包安装的邮件服务的额外日志目录</td>
</tr>
<tr>
<td>/var/log/samba/</td>
<td>RPM包安装的samba服务的日志目录</td>
</tr>
<tr>
<td>/var/log/sssd/</td>
<td>守护进程安全服务目录</td>
</tr>
</tbody></table>
<h3 id="14-2-rsyslogd-日志服务"><a href="#14-2-rsyslogd-日志服务" class="headerlink" title="14.2 rsyslogd 日志服务"></a>14.2 rsyslogd 日志服务</h3><h4 id="14-2-1-日志文件格式"><a href="#14-2-1-日志文件格式" class="headerlink" title="14.2.1 日志文件格式"></a>14.2.1 日志文件格式</h4><ul>
<li><p>基本日志格式包含以下四列:</p>
<ul>
<li>事件产生的时间;</li>
<li>发生事件的服务器的主机名;</li>
<li>产生事件的服务名或程序名;</li>
<li>事件的具体信息。</li>
</ul>
</li>
<li><p>/etc/rsyslog.conf配置文件<br>写入这个文件可以自定义需要记录日志的程序</p>
<ul>
<li>authpriv.* /var/log/secure</li>
<li>服务名称[连接符号]日志等级 日志记录位置<br>认证相关服务.所有日志等级记录在/var/log/secure日志中</li>
</ul>
</li>
<li><p>服务名称</p>
<table>
<thead>
<tr>
<th>服务名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>auth</td>
<td>安全和认证相关消息(不推荐使用authpriv替代)</td>
</tr>
<tr>
<td>authpriv</td>
<td>安全和认证相关消息(私有的)</td>
</tr>
<tr>
<td>cron</td>
<td>系统定时任务cront和at产生的日志</td>
</tr>
<tr>
<td>daemon</td>
<td>和各个守护进程相关的日志</td>
</tr>
<tr>
<td>ftp</td>
<td>ftp守护进程产生的日志</td>
</tr>
<tr>
<td>kern</td>
<td>内核产生的日志(不是用户进程产生的)</td>
</tr>
<tr>
<td>local0-local7</td>
<td>为本地使用预留的服务</td>
</tr>
<tr>
<td>lpr</td>
<td>打印产生的日志</td>
</tr>
<tr>
<td>mail</td>
<td>邮件收发信息</td>
</tr>
<tr>
<td>news</td>
<td>与新闻服务器相关的日志</td>
</tr>
<tr>
<td>syslog</td>
<td>有syslogd服务产生的日志信息(虽然服务名 称已经改为rsyslogd，但是很多配置都还是沿 用了syslogd的，这里并没有修改服务名)。</td>
</tr>
<tr>
<td>user</td>
<td>用户等级类别的日志信息</td>
</tr>
<tr>
<td>uucp</td>
<td>uucp子系统的日志信息，uucp是早期linux系</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>连接符号</p>
<ul>
<li>连接符号可以识别为:<ul>
<li>“*”代表所有日志等级，比如:“authpriv.*”代表authpriv认证信息服务产生的日志，所有的日志等级都记录</li>
<li>“.”代表只要比后面的等级高的(包含该等级)日志都记录下来。比如:“cron.info”代表cron服务产生的日志，只要日 志等级大于等于info级别，就记录</li>
<li>“.=”代表只记录所需等级的日志，其他等级的都不记录。比 如:“*.=emerg”代表人和日志服务产生的日志，只要等级是 emerg等级就记录。这种用法及少见，了解就好</li>
<li>“.!”代表不等于，也就是除了该等级的日志外，其他等级的 日志都记录。</li>
</ul>
</li>
</ul>
</li>
<li><p>日志等级</p>
<table>
<thead>
<tr>
<th>等级名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>debug</td>
<td>一般的调试信息说明</td>
</tr>
<tr>
<td>info</td>
<td>基本的通知信息</td>
</tr>
<tr>
<td>notice</td>
<td>普通信息，但是有一定的重要性</td>
</tr>
<tr>
<td>warning</td>
<td>警告信息，但是还不回影响到服务或系统的运行</td>
</tr>
<tr>
<td>err</td>
<td>错误信息，一般达到err等级的信息以及可以影响到服务或系统的运行了。</td>
</tr>
<tr>
<td>crit</td>
<td>临界状况信息，比err等级还要严重</td>
</tr>
<tr>
<td>alert</td>
<td>警告状态信息，比crit还要严重。必须立即采取行动</td>
</tr>
<tr>
<td>emerg</td>
<td>疼痛等级信息，系统已经无法使用了</td>
</tr>
</tbody></table>
</li>
<li><p>日志记录位置</p>
<ul>
<li>日志文件的绝对路径，如“/var/log/secure”</li>
<li>系统设备文件，如“/dev/lp0”</li>
<li>转发给远程主机，如“@192.168.0.210:514”<br>用户名，如“root”</li>
<li>忽略或丢弃日志，如“~”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="14-3-日志轮替"><a href="#14-3-日志轮替" class="headerlink" title="14.3 日志轮替"></a>14.3 日志轮替</h3><h4 id="14-3-1-日志文件的命名规则"><a href="#14-3-1-日志文件的命名规则" class="headerlink" title="14.3.1 日志文件的命名规则"></a>14.3.1 日志文件的命名规则</h4><ul>
<li><p>如果配置文件中拥有“dateext”参数，那么日志会用日期来作为日志文件的后缀， 例如“secure-20130605”。这样的话日志文件名不会重叠，所以也就不需要日志文 件的改名，只需要保存指定的日志个数， 删除多余的日志文件即可。</p>
</li>
<li><p>如果配置文件中没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日志 轮替时，当前的“secure”日志会自动改名为 “secure.1”，然后新建“secure”日志，用来 保存新的日志。当第二次进行日志轮替时， “secure.1”会自动改名为“secure.2”，当前的 “secure”日志会自动改名为“secure.1”，然 后也会新建“secure”日志，用来保存新的日志 ，以此类推。</p>
</li>
</ul>
<h4 id="14-3-2-logrotate配置文件"><a href="#14-3-2-logrotate配置文件" class="headerlink" title="14.3.2  logrotate配置文件"></a>14.3.2  logrotate配置文件</h4><table>
<thead>
<tr>
<th>参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>daily</td>
<td>日志的轮替周期是每天</td>
</tr>
<tr>
<td>weekly</td>
<td>日志的轮替周期是每周</td>
</tr>
<tr>
<td>monthly</td>
<td>日志的轮替周期是每月</td>
</tr>
<tr>
<td>rotate 数字</td>
<td>保留的日志文件的个数。0指没有备份</td>
</tr>
<tr>
<td>compress</td>
<td>日志轮替时，旧的日志进行压缩</td>
</tr>
<tr>
<td>create mode owner group</td>
<td>建立新日志，同时指定新日志的权限与所有者和 所属组。如create 0600 root utmp</td>
</tr>
<tr>
<td>mail address</td>
<td>当日志轮替时，输出内容通过邮件发送到指定的 邮件地址。如mail <a href="mailto:&#49;&#x37;&#55;&#49;&#53;&#54;&#54;&#54;&#55;&#57;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#109;">&#49;&#x37;&#55;&#49;&#53;&#54;&#54;&#54;&#55;&#57;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>missingok</td>
<td>如果日志不存在，则忽略该日志的警告信息</td>
</tr>
<tr>
<td>notifempty</td>
<td>如果日志为空文件，则不进行日志轮替</td>
</tr>
<tr>
<td>minsize 大小</td>
<td>日志轮替的最小值。也就是日志一定要达到这个 最小值才会轮替，否则就算时间达到也不轮替size 大小 日志只有大于指定大小才进行日志轮替，而不是 按照时间轮替。如size 100k</td>
</tr>
<tr>
<td>dateext</td>
<td>使用日期作为日志轮替文件的后缀。如secure- 20130605</td>
</tr>
</tbody></table>
<p> 在/etc/logrotate.conf 配置文件里修改轮替规则，下面大括号外面的变量相当于局部变量，而大括号里面的相当于全局变量，只有大括号里面没有声明，外面的才生效，一旦大括号声明了，大括号里面的优先级高于外面，优先生效 </p>
<h4 id="14-3-3-把apache日志加入轮替"><a href="#14-3-3-把apache日志加入轮替" class="headerlink" title="14.3.3  把apache日志加入轮替"></a>14.3.3  把apache日志加入轮替</h4><p>vi /etc/logrotate.conf /usr/local/apache2/logs/access_log<br>{<br>daily<br>create<br>rotate 30<br>}<br>一般只有源码包安装才需要这样加入，RPM包在安装时候会自动做日志</p>
<p>logrotate命令<br>logrotate [选项] 配置文件名<br>如果此命令没有选项，则会按照配置文件中的条件进行</p>
<h4 id="14-3-4-logrotate-命令"><a href="#14-3-4-logrotate-命令" class="headerlink" title="14.3.4  logrotate 命令"></a>14.3.4  logrotate 命令</h4><ul>
<li>logrotate [选项] 配置文件名<ul>
<li>-v:显示日志轮替过程。加了-v选项，会显示日志的轮 替的过程</li>
<li>-f: 强制进行日志轮替。不管日志轮替的条件是否已经 符合，强制配置文件中所有的日志进行轮替</li>
</ul>
</li>
</ul>
<h2 id="第十五章-启动管理"><a href="#第十五章-启动管理" class="headerlink" title="第十五章 启动管理"></a>第十五章 启动管理</h2><h3 id="15-1-CentOS-6-x启动管理"><a href="#15-1-CentOS-6-x启动管理" class="headerlink" title="15.1 CentOS 6.x启动管理"></a>15.1 CentOS 6.x启动管理</h3><h4 id="15-1-1-系统运行级别"><a href="#15-1-1-系统运行级别" class="headerlink" title="15.1.1 系统运行级别"></a>15.1.1 系统运行级别</h4><ul>
<li><p>运行级别</p>
<table>
<thead>
<tr>
<th>运行级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>单用户模式，可以想象为windows的安全模式，主要用 于系统修复</td>
</tr>
<tr>
<td>2</td>
<td>不完全的命令行模式，不含NFS服务</td>
</tr>
<tr>
<td>3</td>
<td>完全的命令行模式，就是标准字符界面</td>
</tr>
<tr>
<td>4</td>
<td>系统保留</td>
</tr>
<tr>
<td>5</td>
<td>图形模式</td>
</tr>
<tr>
<td>6</td>
<td>重启动</td>
</tr>
</tbody></table>
</li>
<li><p>运行级别命令</p>
<ul>
<li>runlevel<br>查看运行级别命令</li>
<li>init 运行级别<br>改变运行级别命令</li>
</ul>
</li>
<li><p>修改系统默认运行级别<br>vim /etc/inittab<br>id:3:initdefault:<br>系统开机后直接进入哪个运行级别，就把数字改为对应的数字 </p>
</li>
</ul>
<h4 id="15-1-2-系统启动过程"><a href="#15-1-2-系统启动过程" class="headerlink" title="15.1.2  系统启动过程"></a>15.1.2  系统启动过程</h4><p> <img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020053015380272.png" alt="系统启动流程"> </p>
<ul>
<li><p>initramfs内存文件系统<br>CentOS 6.x中使用initramfs内存文件系统 取代了CentOS 5.x中的initrd RAM Disk。 他们的作用类似，可以通过启动引导程序加载到内存中，然后加载启动过程中所需要的内核模块，比如USB、SATA、SCSI 硬盘的驱动和LVM、RAID文件系统的驱动</p>
</li>
<li><p>一个实验看initramfs文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  mkdir /tmp/initramfs</span><br><span class="line">  # 建立测试目录</span><br><span class="line">  cp /boot/initramfs-2.6.32-279.el6.i686.img /tmp/initramfs/ </span><br><span class="line">  # 复制initramfs文件</span><br><span class="line">  cd /tmp/initramfs/</span><br><span class="line">  file initramfs-2.6.32-279.el6.i686.img</span><br><span class="line">  mv initramfs-2.6.32-279.el6.i686.img initramfs-2.6.32-279.el6.i686.img.gz</span><br><span class="line">  # 修改文件的后缀名为.gz</span><br><span class="line">  gunzip initramfs-2.6.32-279.el6.i686.img.gz</span><br><span class="line">  # 解压缩</span><br><span class="line">file initramfs-2.6.32-279.el6.i686.img</span><br><span class="line">  cpio -ivcdu &lt; initramfs-2.6.32-279.el6.i686.img</span><br><span class="line">  # 解读cpio文件</span><br></pre></td></tr></table></figure></li>
<li><p>调用/etc/init/rcS.conf配置文件<br>主要功能是两个:</p>
<ul>
<li>先调用/etc/rc.d/rc.sysinit，然后由 /etc/rc.d/rc.sysinit配置文件进行Linux系统初始化。</li>
<li>然后再调用/etc/inittab，然后由/etc/inittab配 置文件确定系统的默认运行级别。</li>
</ul>
</li>
<li><p>由/etc/rc.d/rc.sysinit初始化</p>
<p>1、获得网络环境<br>2、挂载设备<br>3、开机启动画面Plymouth(取替了过往的 RHGB)<br>4、判断是否启用SELinux<br>5、显示于开机过程中的欢迎画面<br>6、初始化硬件<br>7、用户自定义模块的加载<br>8、配置内核的参数<br>9、设置主机名<br>10、同步存储器<br>11、设备映射器及相关的初始化<br>12、初始化软件磁盘阵列(RAID)<br>13、初始化 LVM 的文件系统功能<br>14、检验磁盘文件系统(fsck)<br>15、设置磁盘配额(quota)<br>16、重新以可读写模式挂载系统磁盘<br>17、更新quota(非必要)<br>18、启动系统虚拟随机数生成器<br>19、配置机器(非必要)<br>20、清除开机过程当中的临时文件<br>21、创建ICE目录<br>22、启动交换分区(swap)<br>23、将开机信息写入/var/log/dmesg文件中</p>
</li>
<li><p>调用/etc/rc.d/rc文件<br>运行级别参数传入/etc/rc.d/rc这个脚本之 后，由这个脚本文件按照不同的运行级别启动/etc/rc[0-6].d/目录中的相应的程序</p>
<ul>
<li>/etc/rc3.d/K??开头的文件(??是数字)，会按照数字顺序依次关闭</li>
<li>/etc/rc3.d/S??开头的文件(??是数字)，会 按照数字顺序依次启动</li>
</ul>
</li>
</ul>
<h3 id="15-2-启动引导程序grub"><a href="#15-2-启动引导程序grub" class="headerlink" title="15.2 启动引导程序grub"></a>15.2 启动引导程序grub</h3><h4 id="15-2-1-Grub配置文件"><a href="#15-2-1-Grub配置文件" class="headerlink" title="15.2.1 Grub配置文件"></a>15.2.1 Grub配置文件</h4><ul>
<li> <strong>grub中分区表示</strong> </li>
</ul>
<table>
<thead>
<tr>
<th>硬盘</th>
<th>分区</th>
<th>Linux中设备文件 名</th>
<th>Grub中设备文件名</th>
</tr>
</thead>
<tbody><tr>
<td>第一块SCSI硬盘</td>
<td>第一个主分区</td>
<td>/dev/sda1</td>
<td>hd(0,0)</td>
</tr>
<tr>
<td>第一块SCSI硬盘</td>
<td>第二个主分区</td>
<td>/dev/sda2</td>
<td>hd(0,1)</td>
</tr>
<tr>
<td>第一块SCSI硬盘</td>
<td>扩展分区</td>
<td>/dev/sda3</td>
<td>hd(0,2)</td>
</tr>
<tr>
<td>第一块SCSI硬盘</td>
<td>第一个逻辑分区</td>
<td>/dev/sda5</td>
<td>hd(0,4)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>第一个主分区</td>
<td>/dev/sdb1</td>
<td>hd(1,0)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>第二个主分区</td>
<td>/dev/sdb2</td>
<td>hd(1,1)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>扩展分区</td>
<td>/dev/sdb3</td>
<td>hd(1,2)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>第一个逻辑</td>
<td>/dev/sdb5</td>
<td>hd(1,4)</td>
</tr>
</tbody></table>
<ul>
<li>grub配置文件 vi /boot/grub/grub.conf<ul>
<li>default=0 默认启动第一个系统</li>
<li>timeout=5 等待时间，默认是5秒</li>
<li>splashimage=(hd0,0)/grub/splash.xpm.gz<br>这里是指定grub启动时的背景图像文件的保存位置的</li>
<li>hiddenmenu 隐藏菜单</li>
<li>在CentOS7中为vim /etc/default/grub</li>
<li>title CentOS (2.6.32-279.el6.i686) t itle就是标题的意思</li>
<li>root (hd0,0) 是指启动程序的保存分区</li>
<li>kernel /vmlinuz-2.6.32-279.el6.i686 ro root=UUID=b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet<br>定义内核加载时的选项</li>
<li>initrd /initramfs-2.6.32-279.el6.i686.img 指定了initramfs内存文件系统镜像文件的所在位置</li>
</ul>
</li>
</ul>
<h4 id="15-2-2-Grub加密与字符界面分辨率调整"><a href="#15-2-2-Grub加密与字符界面分辨率调整" class="headerlink" title="15.2.2 Grub加密与字符界面分辨率调整"></a>15.2.2 Grub加密与字符界面分辨率调整</h4><ul>
<li><p>在开机选择内核界面可以按e进入里面破解root密码，这个时候为了安全，便需要给grub加密才能进入按e界面</p>
</li>
<li><p>grub加密<br>命令：<br>grub-md5-crypt<br>生成加密密码串<br>vi /boot/grub/grub.conf<br>在splashimage=（hd0，0）这一行前面写入<br>password –md5 刚刚生产的密码串<br>Password选项放在整体设置处<br>重启就可以了<br>CentOS 7.2以后使用 grub2-setpassword 直接设置密码</p>
</li>
<li><p>纯字符界面的分辨率调整<br>查询内核是否支持分辨率调整<br>grep “CONFIG_FRAMEBUFFER_CONSOLE” /boot/config-3.10.0-1127.el7.x86_64<br>显示 CONFIG_FRAMEBUFFER_CONSOLE=y<br>就为可以调整</p>
</li>
<li><p>再输入命令：<br>vim /boot/grub/grub.conf<br>内核的选项文件中<br>Kernel /vmlinuz- ******<em>这句话后面加入 vga=791，便是调整1024</em>768 16位的分辨率，具体数字对应分辨率见下表：</p>
<table>
<thead>
<tr>
<th>色深</th>
<th>640*480</th>
<th>800*600</th>
<th>1024*768</th>
<th>1280*1024</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>769</td>
<td>771</td>
<td>773</td>
<td>775</td>
</tr>
<tr>
<td>15位</td>
<td>784</td>
<td>787</td>
<td>790</td>
<td>793</td>
</tr>
<tr>
<td>16位</td>
<td>785</td>
<td>788</td>
<td>791</td>
<td>794</td>
</tr>
<tr>
<td>32位</td>
<td>786</td>
<td>789</td>
<td>792</td>
<td>795</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="15-3-系统修复模式"><a href="#15-3-系统修复模式" class="headerlink" title="15.3 系统修复模式"></a>15.3 系统修复模式</h3><ul>
<li><p>单用户模式<br>在登陆选择内核界面，按e键进入内核选项</p>
</li>
<li><p>单用户模式常见的错误修复</p>
<ul>
<li>遗忘root密码</li>
<li>修改系统默认运行级别</li>
</ul>
</li>
<li><p>修改密码：<br>CentOS7<br>找到linux16 这一行 在CN.UTF-8 后面加入<br>rd.break console=tty0<br>然后按ctrl+x<br>然后依次输入：<br>mount -o remount,rw /sysroot<br>chroot /sysroot/<br>passwd root 或者 echo 密码 | passwd –stdin root<br>在这之后会出现很多小方块 这行小方块是中文编码问题，不用管它。输一次密码回车，再输一次确认密码，回车。<br>接着输入：<br>touch /.autorelabel<br>sync<br>exit<br>exit<br>重启就OK了，使用新密码登陆</p>
</li>
<li><p>光盘修复模式<br>在忘记了grub密码的时候可以使用这个模式<br>在虚拟机中放入光盘iso文件，在虚拟机VMware界面读条的时候，快速按F2键，苹果系统可按fn+F2，进入刚开始学习安装的界面之后，选择上面第四栏BOOT，调到光盘启动CR-Drive为首选(按+号调节)，F10保存。在安装节目选第三项Troublesooting 回车，选择第二项Rescue a CentOS system 回车，选择2 Shell模式 回车 回车 ，此时根目录已经被挂载到光盘下 /mnt/sysimage目录下<br>chroot /mnt/sysimage #改变主目录<br>grub2-setpassword<br>输入新密码即可</p>
</li>
<li><p>重要系统文件丢失，导致系统无法启动<br>假设丢了etc/inittab 文件，你可以在其他同版本的Linux查询到这个文件所在的包<br>chroot /mnt/sysimage #改变主目录<br>cd /root<br>rpm -qf /etc/inittab #查询下/etc/inittab文件属于哪个包。<br>mkdir /mnt/cdrom #建立挂载点<br>mount /dev/sr0 /mnt/cdrom #挂载光盘<br>rpm2cpio /mnt/cdrom/Packages/initscripts-8.45.3-1.i386.rpm | cpio -idv ./etc/inittab<br>#提取inittab文件到当前目录<br>cp etc/inittab /etc/inittab #复制inittab文件到指定位置</p>
<p>在光盘修复模式下可以修改大部分问题。</p>
</li>
<li><p>Linux的安全性</p>
<p> <img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20200530155429286.png" alt="Linux的安全性"> ￼<br>所以安全性是相对的，这是给我们留的退路</p>
</li>
</ul>
<h2 id="第十六章-备份与恢复"><a href="#第十六章-备份与恢复" class="headerlink" title="第十六章 备份与恢复"></a>第十六章 备份与恢复</h2><h3 id="16-1-备份概述"><a href="#16-1-备份概述" class="headerlink" title="16.1 备份概述"></a>16.1 备份概述</h3><ul>
<li><p>Linux系统需要备份的数据</p>
<ul>
<li>/root/目录:</li>
<li>/home/目录:</li>
<li>/var/spool/mail/目录:</li>
<li>/etc/目录:</li>
<li>其他目录:</li>
</ul>
</li>
<li><p>安装服务的数据</p>
<ul>
<li><p>apache需要备份的数据</p>
<ul>
<li><p>配置文件</p>
</li>
<li><p>网页主目录</p>
</li>
<li><p>日志文件</p>
</li>
<li><p>mysql需要备份的数据</p>
</li>
<li><p>源码包安装的mysql:/usr/local/mysql/data/</p>
</li>
<li><p>RPM包安装的mysql:/var/lib/mysql/</p>
</li>
<li><p>】备份策略</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>备份策略</p>
<ul>
<li><p>完全备份:完全备份就是指把所有需要备 份的数据全部备份，当然完全备份可以备份整块硬盘，整个分区或某个具体的目录</p>
<p> <img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20200530160146194.png" alt="差异备份"> </p>
</li>
<li><p>增量备份</p>
</li>
<li><p>差异备份<br>￼</p>
</li>
</ul>
</li>
</ul>
<h3 id="16-2-dump和restore命令"><a href="#16-2-dump和restore命令" class="headerlink" title="16.2 dump和restore命令"></a>16.2 dump和restore命令</h3><h4 id="16-2-1-dump命令"><a href="#16-2-1-dump命令" class="headerlink" title="16.2.1 dump命令"></a>16.2.1 dump命令</h4><ul>
<li><p>dump [选项] 备份之后的文件名 原文件或目录</p>
<ul>
<li>-level:就是我们说的0-9十个备份级别</li>
<li>-f 文件名: 指定备份之后的文件名</li>
<li>-u: 备份成功之后，把备份时间记录在/etc/dumpdates文件</li>
<li>-v:显示备份过程中更多的输出信息</li>
<li>-j: 调用bzlib库压缩备份文件，其实就是把备份文件压缩 为.bz2格式，默认压缩等级是2</li>
<li>-W: 显示允许被dump的分区的备份等级及备份时间</li>
<li>CentOS 7以前版本需要安装dump yum -y install dump下载</li>
</ul>
</li>
<li><p>CentOS 7 以后版本使用xfsdump备份xfs文件系统</p>
<ul>
<li>XFS提供了 xfsdump 和 xfsrestore 工具协助备份XFS文件系统中的数据。xfsdump 按inode顺序备份一个XFS文件系统。</li>
<li>centos7选择xfs格式作为默认文件系统，而且不再使用以前的ext，仍然支持ext4，xfs专为大数据产生，每个单个文件系统最大可以支持8eb，单个文件可以支持16tb，不仅数据量大，而且扩展性高。还可以通过xfsdump，xfsrestore来备份和恢复。</li>
<li>与传统的UNIX文件系统不同，XFS不需要在备份前被卸载；对使用中的XFS文件系统做备份就可以保证镜像的一致性。XFS的备份和恢复的过程是可以被中断然后继续的，无须冻结文件系统。xfsdump 甚至提供了高性能的多线程备份操作——它把一次dump拆分成多个数据流，每个数据流可以被发往不同的目的地。</li>
<li>使用yum -y install xfsdump下载</li>
</ul>
</li>
<li><p>只有在备份文件系统才能执行增量备份，执行1-9级别，文件和目录只能执行0级别</p>
</li>
<li><p>备份分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dump -0uj -f /root/boot.bak.bz2 /boot/</span><br><span class="line"># 备份命令。先执行一次完全备份，并压缩和更新备份时间 </span><br><span class="line">cat /etc/dumpdates</span><br><span class="line"># 查看备份时间文件</span><br><span class="line">cp install.log /boot/</span><br><span class="line"># 复制日志文件到/boot分区</span><br><span class="line">dump -1uj -f /root/boot.bak1.bz2 /boot/</span><br><span class="line"># 增量备份/boot分区，并压缩</span><br><span class="line">dump –W</span><br><span class="line"># 查询分区的备份时间及备份级别的</span><br></pre></td></tr></table></figure></li>
<li><p>备份文件或目录<br>dump -0j -f /root/etc.dump.bz2 /etc/<br>完全备份/etc/目录，只能使用0级别进行完全备份 ，而不再支持增量备份</p>
</li>
</ul>
<h4 id="16-2-1-restore命令"><a href="#16-2-1-restore命令" class="headerlink" title="16.2.1 restore命令"></a>16.2.1 restore命令</h4><ul>
<li>estore [模式选项] [选项]<ul>
<li>模式选项:restore命令常用的模式有以下四种，这四个模式不能混用。<ul>
<li>-C:比较备份数据和实际数据的变化。</li>
<li>-i: 进入交互模式，手工选择需要恢复的文件。</li>
<li>-t: 查看模式，用于查看备份文件中拥有哪些数据。</li>
<li>-r: 还原模式，用于数据还原。</li>
</ul>
</li>
<li>选项:<br>-f: 指定备份文件的文件名<br>比较备份数据和实际数据的变化<br>mv /boot/vmlinuz-2.6.32-279.el6.i686 /boot/vmlinuz-2.6.32- 279.el6.i686.bak<br>#把/boot目录中内核镜像文件改个名字 restore -C -f /root/boot.bak.bz2 #restore发现内核镜像文件丢失</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>《Linux》</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习笔记</title>
    <url>/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="Go语言概述"><a href="#Go语言概述" class="headerlink" title="Go语言概述"></a>Go语言概述</h3><h4 id="1-Go语言简介"><a href="#1-Go语言简介" class="headerlink" title="1.Go语言简介"></a>1.Go语言简介</h4><ul>
<li><p>Go 是一个开源的编程语言，它能让<font color="cornflowerblue">构造简单、可靠且高效的软件</font>变得容易。</p>
</li>
<li><p>Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。</p>
</li>
</ul>
<h4 id="2-Go语言特色"><a href="#2-Go语言特色" class="headerlink" title="2.Go语言特色"></a>2.Go语言特色</h4><ul>
<li>简洁、快速、安全</li>
<li>并行、有趣、开源</li>
<li>内存管理、v数组安全、编译迅速</li>
</ul>
<h4 id="3-Go-语言用途"><a href="#3-Go-语言用途" class="headerlink" title="3.Go 语言用途"></a>3.Go 语言用途</h4><ul>
<li><p>Go 语言被设计成一门应用于搭载 <font color="cornflowerblue">Web 服务器</font>，<font color="cornflowerblue">存储集群</font>或类似用途的<font color="cornflowerblue">巨型中央服务器</font>的系统编程语言。</p>
</li>
<li><p>对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了<font color="cornflowerblue">海量并行的支持</font>，这对于游戏服务端的开发而言是再好不过了。</p>
</li>
</ul>
<h3 id="Go语言结构"><a href="#Go语言结构" class="headerlink" title="Go语言结构"></a>Go语言结构</h3><h4 id="1-Hello-World-实例"><a href="#1-Hello-World-实例" class="headerlink" title="1.Hello World 实例"></a>1.Hello World 实例</h4><p>（1）Go 语言的基础组成有以下几个部分：</p>
<ul>
<li>包声明</li>
<li>引入包</li>
<li>函数</li>
<li>变量</li>
<li>语句 &amp; 表达式</li>
<li>注释</li>
</ul>
<p>（2）接下来让我们来看下简单的代码，该代码输出了”Hello World!”:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 这是我的第一个简单的程序 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）让我们来看下以上程序的各个部分：</p>
<ol>
<li><em>package main</em> 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</li>
<li><em>import “fmt”</em> 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），<font color="red">fmt 包实现了格式化 IO（输入/输出）的函数</font>。</li>
<li>下一行 <em>func main()</em> 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</li>
<li>/<em>…</em>/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li>
<li><em>fmt.Println(…)</em> 可以将字符串输出到控制台，并在最后自动增加换行字符 \n。<br>使用 fmt.Print(“hello, world\n”) 可以得到相同的结果。<br>Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</li>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个<font color="red">大写字母开头</font>，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 <font color="red">public</font>）；标识符如果<font color="red">以小写字母开头</font>，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 <font color="red">private</font> ）。</li>
</ol>
<h4 id="2-执行-Go-程序"><a href="#2-执行-Go-程序" class="headerlink" title="2.执行 Go 程序"></a>2.执行 Go 程序</h4><p>（1）让我们来看下如何编写 Go 代码并执行它。步骤如下：</p>
<ul>
<li>打开编辑器如Sublime2，将以上代码添加到编辑器中。</li>
<li>将以上代码保存为 <em>hello.go</em></li>
<li>打开命令行，并进入程序文件保存的目录中。</li>
<li>输入命令 <em>go run hello.go</em> 并按回车执行代码。</li>
</ul>
<p>（2）如果操作正确你将在屏幕上看到 <em>“Hello World!”</em> 字样的输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run hello.<span class="keyword">go</span></span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>



<h3 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h3><h4 id="1-行分隔符"><a href="#1-行分隔符" class="headerlink" title="1.行分隔符"></a>1.行分隔符</h4><ul>
<li><p>在 Go 程序中，<font color="red">一行代表一个语句结束</font>。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。</p>
</li>
<li><p>如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。</p>
</li>
</ul>
<h4 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h4><ul>
<li><p>注释不会被编译，每一个包应该有相关注释。</p>
</li>
<li><p>单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。如：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Author by w3cschoolW3Cschool教程</span></span><br><span class="line"><span class="comment"> 我是多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h4 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3.关键字"></a>3.关键字</h4><p>（1）下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p>
<table>
<thead>
<tr>
<th>break</th>
<th>default</th>
<th>func</th>
<th>interface</th>
<th>select</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td>defer</td>
<td>go</td>
<td>map</td>
<td>struct</td>
</tr>
<tr>
<td>chan</td>
<td>else</td>
<td>goto</td>
<td>package</td>
<td>switch</td>
</tr>
<tr>
<td>const</td>
<td>fallthrough</td>
<td>if</td>
<td>range</td>
<td>type</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>import</td>
<td>return</td>
<td>var</td>
</tr>
</tbody></table>
<p>（2）除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：</p>
<table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody><tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody></table>
<h3 id="Go语言数据类型"><a href="#Go语言数据类型" class="headerlink" title="Go语言数据类型"></a>Go语言数据类型</h3><h4 id="1-Go-语言数据类型"><a href="#1-Go-语言数据类型" class="headerlink" title="1.Go 语言数据类型"></a>1.Go 语言数据类型</h4><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>数字类型</strong> 整型 int 和浮点型 float，Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) 联合体类型 (union)(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型(i) Channel 类型</td>
</tr>
</tbody></table>
<h4 id="2-数字类型"><a href="#2-数字类型" class="headerlink" title="2.数字类型"></a>2.数字类型</h4><ul>
<li>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<ul>
<li>浮点型：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>float32</strong> IEEE-754 32位浮点型数</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>float64</strong> IEEE-754 64位浮点型数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>complex64</strong> 32 位实数和虚数</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>complex128</strong> 64 位实数和虚数</td>
</tr>
</tbody></table>
<h4 id="3-其他数字类型"><a href="#3-其他数字类型" class="headerlink" title="3.其他数字类型"></a>3.其他数字类型</h4><p>以下列出了其他更多的数字类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>byte</strong> 类似 uint8</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>rune</strong> 类似 int32</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>uint</strong> 32 或 64 位</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>int</strong> 与 uint 一样大小</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>uintptr</strong> 无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<h3 id="Go语言变量"><a href="#Go语言变量" class="headerlink" title="Go语言变量"></a>Go语言变量</h3><h4 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1.变量声明"></a>1.变量声明</h4><p>（1）第一种，指定变量类型，先声明后赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var v_name v_type</span></span><br><span class="line"><span class="comment">//v_name = value</span></span><br></pre></td></tr></table></figure>

<p>（2）第二种，根据值自行判定变量类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var v_name = value</span></span><br></pre></td></tr></table></figure>

<p>（3）第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v_name := value</span></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">c : = <span class="number">10</span></span><br></pre></td></tr></table></figure>



<h4 id="2-多变量声明"><a href="#2-多变量声明" class="headerlink" title="2.多变量声明"></a>2.多变量声明</h4><p>（1）类型相同多个变量, 非全局变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">//和python很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">//出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）类型不同的多个变量，全局变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>（3）实例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">b = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">c := <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d, e, f <span class="keyword">int</span></span><br><span class="line">d, e, f = <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span></span><br><span class="line"></span><br><span class="line">g, h, i := <span class="number">18</span>, <span class="number">19</span>, “work”</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    j <span class="keyword">int</span></span><br><span class="line">    k <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">j = <span class="number">21</span></span><br><span class="line">k = <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="3-值类型和引用类型"><a href="#3-值类型和引用类型" class="headerlink" title="3.值类型和引用类型"></a>3.值类型和引用类型</h4><p>（1）所有像 int、float、bool 和 string 这些基本类型都属于<font color="red">值类型</font>，使用这些类型的变量直接指向存在内存中的值：</p>
<p><img src="/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/201611202341534498.png" alt="img"></p>
<p>当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，如：<code>j = i</code>，实际上是在内存中将 i 的值进行了拷贝：</p>
<p><img src="/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/201611202342229643.png" alt="img"></p>
<p>你可以通过 &amp;i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。</p>
<p>内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。</p>
<p>（2）更复杂的数据通常会需要使用多个字，这些数据一般使用<font color="red">引用类型</font>保存。</p>
<p>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</p>
<p><img src="/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/201611202342474583.png" alt="img"></p>
<p>这个内存地址为称之为指针，这个指针实际上也被存在另外的某一个字中。</p>
<p>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。</p>
<p>当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。</p>
<p>如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</p>
<h3 id="Go语言常量"><a href="#Go语言常量" class="headerlink" title="Go语言常量"></a>Go语言常量</h3><h4 id="1-常量的定义格式"><a href="#1-常量的定义格式" class="headerlink" title="1.常量的定义格式"></a>1.常量的定义格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const identifier [type] = value</span><br></pre></td></tr></table></figure>

<p>（1）你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p>
<ul>
<li>显式类型定义： <code>const b string = &quot;abc&quot;</code></li>
<li>隐式类型定义： <code>const b = &quot;abc&quot;</code></li>
</ul>
<p>（2）多个相同类型的声明可以简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const c_name1, c_name2 = value1, value2</span><br></pre></td></tr></table></figure>



<h4 id="2-iota"><a href="#2-iota" class="headerlink" title="2.iota"></a>2.iota</h4><p>（1）iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p>
<p>（2）在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。</p>
<p>（4）iota 可以被用作枚举值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>（5）iota 用法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> ha ha <span class="number">100</span> <span class="number">100</span> <span class="number">7</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言运算符"><a href="#Go语言运算符" class="headerlink" title="Go语言运算符"></a>Go语言运算符</h3><p>略</p>
<h3 id="Go语言条件语句"><a href="#Go语言条件语句" class="headerlink" title="Go语言条件语句"></a>Go语言条件语句</h3><p>Go 语言提供了以下几种条件判断语句：</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-if-statement.html">if 语句</a></td>
<td align="left"><strong>if 语句</strong> 由一个布尔表达式后紧跟一个或多个语句组成。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-if-else-statement.html">if…else 语句</a></td>
<td align="left"><strong>if 语句</strong> 后可以使用可选的 <strong>else 语句</strong>, else 语句中的表达式在布尔表达式为 false 时执行。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-nested-if-statements.html">if 嵌套语句</a></td>
<td align="left">你可以在 <strong>if</strong> 或 <strong>else if</strong> 语句中嵌入一个或多个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-switch-statement.html">switch 语句</a></td>
<td align="left"><strong>switch</strong> 语句用于基于不同条件执行不同动作。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-select-statement.html">select 语句</a></td>
<td align="left"><strong>select</strong> 语句类似于 <strong>switch</strong> 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</td>
</tr>
</tbody></table>
<h4 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;   </span><br><span class="line">    <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-if…else语句"><a href="#2-if…else语句" class="headerlink" title="2.if…else语句"></a>2.if…else语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;   </span><br><span class="line">    <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-if嵌套语句"><a href="#3-if嵌套语句" class="headerlink" title="3.if嵌套语句"></a>3.if嵌套语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 <span class="number">1</span> &#123;   </span><br><span class="line">    <span class="comment">/* 在布尔表达式 1 为 true 时执行 */</span>   </span><br><span class="line">    <span class="keyword">if</span> 布尔表达式 <span class="number">2</span> &#123;      </span><br><span class="line">        <span class="comment">/* 在布尔表达式 2 为 true 时执行 */</span>   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4.switch语句"></a>4.switch语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;    </span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-select语句"><a href="#5-select语句" class="headerlink" title="5.select语句"></a>5.select语句</h4><p><a href="https://blog.csdn.net/zhonglinzhang/article/details/45913443">参考：select用法</a></p>
<p>（1）select是Go中的一个控制结构，类似于用于通信的switch语句。<font color="red">每个case必须是一个通信操作</font>，要么是发送要么是接收。</p>
<p><strong>select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。</strong></p>
<p>（2）语法</p>
<p>Go 编程语言中 select 语句的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;    </span><br><span class="line">	<span class="keyword">case</span> communication clause  :</span><br><span class="line">    	statement(s);          </span><br><span class="line">    <span class="keyword">case</span> communication clause  :       </span><br><span class="line">    	statement(s);     </span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span>    </span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span>       </span><br><span class="line">    	statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下描述了 select 语句的语法：</p>
<ul>
<li><p>每个case都必须是一个通信</p>
</li>
<li><p>所有channel表达式都会被求值</p>
</li>
<li><p>所有被发送的表达式都会被求值</p>
</li>
<li><p>如果任意某个通信可以进行，它就执行；其他被忽略。</p>
</li>
<li><p>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。</p>
<p>否则：</p>
<ol>
<li>如果有default子句，则执行该语句。</li>
<li>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</li>
</ol>
</li>
</ul>
<p>（3）实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3\n&quot;</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;c3 is closed\n&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;no communication\n&quot;</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no communication</span><br></pre></td></tr></table></figure>



<h3 id="GO语言循环语句"><a href="#GO语言循环语句" class="headerlink" title="GO语言循环语句"></a>GO语言循环语句</h3><h4 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1.for循环"></a>1.for循环</h4><p>（1）和 C 语言的 for 一样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>（2）和 C 的 while 一样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>（3）和 C 的 for(;;) 一样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>init： 一般为赋值表达式，给控制变量赋初值；</li>
<li>condition： 关系表达式或逻辑表达式，循环控制条件；</li>
<li>post： 一般为赋值表达式，给控制变量增量或减量。</li>
</ul>
<p>（3）for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;    </span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">15</span>   </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span>   </span><br><span class="line">    numbers := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;    </span><br><span class="line">    <span class="comment">/* for 循环 */</span>   </span><br><span class="line">    <span class="keyword">for</span> a := <span class="number">0</span>; a &lt; <span class="number">10</span>; a++ &#123;      </span><br><span class="line">        fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> a &lt; b &#123;      </span><br><span class="line">        a++      </span><br><span class="line">        fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)      </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> i,x:= <span class="keyword">range</span> numbers &#123;      </span><br><span class="line">        fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i,x)   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-循环嵌套"><a href="#2-循环嵌套" class="headerlink" title="2.循环嵌套"></a>2.循环嵌套</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">   &#123;</span><br><span class="line">      statement(s);</span><br><span class="line">   &#125;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例:</p>
<p>以下实例使用循环嵌套来输出 2 到 100 间的素数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> i, j <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i=<span class="number">2</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j=<span class="number">2</span>; j &lt;= (i/j); j++ &#123;</span><br><span class="line">         <span class="keyword">if</span>(i%j==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果发现因子，则不是素数</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j &gt; (i/j)) &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;%d  是素数\n&quot;</span>, i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-循环控制语句"><a href="#3-循环控制语句" class="headerlink" title="3.循环控制语句"></a>3.循环控制语句</h4><p>GO 语言支持以下几种循环控制语句：</p>
<table>
<thead>
<tr>
<th align="left">控制语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-break-statement.html">break 语句</a></td>
<td align="left">经常用于中断当前 for 循环或跳出 switch 语句</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-continue-statement.html">continue 语句</a></td>
<td align="left">跳过当前循环的剩余语句，然后继续进行下一轮循环。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-goto-statement.html">goto 语句</a></td>
<td align="left">将控制转移到被标记的语句。</td>
</tr>
</tbody></table>
<h4 id="Go语言函数"><a href="#Go语言函数" class="headerlink" title="Go语言函数"></a>Go语言函数</h4><h4 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1.函数定义"></a>1.函数定义</h4><p>（1）Go 语言函数定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func function_name( [parameter list] ) [return_types]&#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）函数定义解析：</p>
<ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parameter list]：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<p>（3）实例</p>
<p>以下实例为 max() 函数的代码，该函数传入两个整型参数 num1 和 num2，并返回这两个参数的最大值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2.函数调用"></a>2.函数调用</h4><p>当创建函数时，你定义了函数需要做什么，通过调用改函数来执行指定任务。</p>
<p>调用函数，向函数传递参数，并返回值，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line">   <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用函数并返回最大值 */</span></span><br><span class="line">   ret = max(a, b)</span><br><span class="line"></span><br><span class="line">   fmt.Printf( <span class="string">&quot;最大值是 : %d\n&quot;</span>, ret )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例在 main() 函数中调用 max（）函数，执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最大值是 : 200</span><br></pre></td></tr></table></figure>



<h4 id="3-函数返回多个值"><a href="#3-函数返回多个值" class="headerlink" title="3.函数返回多个值"></a>3.函数返回多个值</h4><p>Go 函数可以返回多个值，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Mahesh&quot;</span>, <span class="string">&quot;Kumar&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kumar Mahesh</span><br></pre></td></tr></table></figure>



<h4 id="4-函数参数"><a href="#4-函数参数" class="headerlink" title="4.函数参数"></a>4.函数参数</h4><p>函数如果使用参数，该变量可称为函数的形参。</p>
<p>形参就像定义在函数体内的局部变量。</p>
<p>调用函数，可以通过两种方式来传递参数：</p>
<table>
<thead>
<tr>
<th align="left">传递类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-call-by-value.html">值传递</a></td>
<td align="left">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-call-by-reference.html">引用传递</a></td>
<td align="left">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td>
</tr>
</tbody></table>
<p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p>
<h4 id="5-函数用法"><a href="#5-函数用法" class="headerlink" title="5.函数用法"></a>5.函数用法</h4><table>
<thead>
<tr>
<th align="left">函数用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-as-values.html">函数作为值</a></td>
<td align="left">函数定义后可作为值来使用</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-closures.html">闭包</a></td>
<td align="left">闭包是匿名函数，可在动态编程中使用</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-method.html">方法</a></td>
<td align="left">方法就是一个包含了接受者的函数</td>
</tr>
</tbody></table>
<p>（1）函数作为值</p>
<p>Go 语言可以很灵活的创建函数，并作为值使用。以下实例中我们在定义的函数中初始化一个变量，该函数仅仅是为了使用内置函数 math.sqrt() ，实例为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明函数变量 */</span></span><br><span class="line">   getSquareRoot := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用函数 */</span></span><br><span class="line">   fmt.Println(getSquareRoot(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>（2）闭包</p>
<p>Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<p>以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>（3）方法</p>
<h3 id="Go语言变量作用域"><a href="#Go语言变量作用域" class="headerlink" title="Go语言变量作用域"></a>Go语言变量作用域</h3><p>略</p>
<h3 id="Go语言数组"><a href="#Go语言数组" class="headerlink" title="Go语言数组"></a>Go语言数组</h3><h4 id="1-声明数组"><a href="#1-声明数组" class="headerlink" title="1.声明数组"></a>1.声明数组</h4><p>Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure>

<p>以上为一维数组的定义方式。数组长度必须是整数且大于 0。例如以下定义了数组 balance 长度为 10 类型为 float32：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var balance [10] float32</span><br></pre></td></tr></table></figure>



<h4 id="2-初始化数组"><a href="#2-初始化数组" class="headerlink" title="2.初始化数组"></a>2.初始化数组</h4><ul>
<li><p>方式一</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   <span class="comment">//不允许写成 var arr [3]int = &#123;1,2,3&#125;</span></span><br><span class="line">   fmt.Println(arr) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">   arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">   arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">   arr[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">   fmt.Println(arr) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式三<br>这是方式一的一种简化形式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(arr) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>方式四<br>方式一的简化形式，也是用得最多的一种方式。</p>
<p>注意：:=符号只允许在函数中使用，即只能在声明局部变量的时候使用，而var没有这个限制。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;	arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;	fmt.Println(arr) <span class="comment">//[1 2 3]&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>方式五<br>让编译器根据初始值的个数自行推断数组的长度。以…来代替[]中的数字，注意若[]中为空则表示为切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(arr) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式六<br>利用指定索引值的方式来初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">4</span>:<span class="number">3</span>&#125; <span class="comment">//例如 0:1 表示数组下标0对应的值为1</span></span><br><span class="line">	fmt.Println(arr) <span class="comment">// [1 0 0 0 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr[<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1[<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr1[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">arr3 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr4 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">arr5 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Go语言指针"><a href="#Go语言指针" class="headerlink" title="Go语言指针"></a>Go语言指针</h3><h4 id="1-什么是指针"><a href="#1-什么是指针" class="headerlink" title="1.什么是指针"></a>1.什么是指针</h4><p>（1）一个指针变量可以指向任何一个值的内存地址。</p>
<p>（2）类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。（3）以下是有效的指针声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 指向整型*/</span><span class="keyword">var</span> fp *<span class="keyword">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure>

<p>本例中这是一个指向 int 和 float32 的指针。</p>
<h4 id="2-如何使用指针"><a href="#2-如何使用指针" class="headerlink" title="2.如何使用指针"></a>2.如何使用指针</h4><p>（1）指针使用流程：</p>
<ul>
<li>定义指针变量。</li>
<li>为指针变量赋值。</li>
<li>访问指针变量中指向地址的值。</li>
</ul>
<p>（2）在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;a 变量的地址是: %x\n&quot;</span>, &amp;a  )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;ip 变量的存储地址: %x\n&quot;</span>, ip )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a 变量的地址是: <span class="number">20818</span>a220ip 变量的存储地址: <span class="number">20818</span>a220*ip 变量的值: <span class="number">20</span></span><br></pre></td></tr></table></figure>



<h4 id="3-Go-空指针"><a href="#3-Go-空指针" class="headerlink" title="3.Go 空指针"></a>3.Go 空指针</h4><p>（1）当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p>
<p>​        nil 指针也称为空指针。</p>
<p>​        nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p>
<p>（2）一个指针变量通常缩写为 ptr。</p>
<p>​    查看以下实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span>  ptr *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;ptr 的值为 : %x\n&quot;</span>, ptr  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ptr 的值为 : 0</span><br></pre></td></tr></table></figure>

<p>（3）空指针判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(ptr != nil)     /* ptr 不是空指针 */</span><br><span class="line">if(ptr == nil)    /* ptr 是空指针 */</span><br></pre></td></tr></table></figure>



<h4 id="4-Go指针更多内容"><a href="#4-Go指针更多内容" class="headerlink" title="4.Go指针更多内容"></a>4.Go指针更多内容</h4><p>接下来我们将为大家介绍Go语言中更多的指针应用：</p>
<table>
<thead>
<tr>
<th align="left">内容</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-array-of-pointers.html">Go 指针数组</a></td>
<td align="left">你可以定义一个指针数组来存储地址</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-pointer-to-pointer.html">Go 指向指针的指针</a></td>
<td align="left">Go 支持指向指针的指针</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-passing-pointers-to-functions.html">Go 像函数传递指针参数</a></td>
<td align="left">通过引用或地址传参，在函数调用时可以改变其值</td>
</tr>
</tbody></table>
<h3 id="Go语言结构体"><a href="#Go语言结构体" class="headerlink" title="Go语言结构体"></a>Go语言结构体</h3><h4 id="1-定义结构体"><a href="#1-定义结构体" class="headerlink" title="1.定义结构体"></a>1.定义结构体</h4><p>（1）结构体定义需要使用<font color="red"> type</font> 和 <font color="red">struct </font>语句。struct 语句定义一个新的数据类型，结构体有中一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-访问结构体成员"><a href="#2-访问结构体成员" class="headerlink" title="2.访问结构体成员"></a>2.访问结构体成员</h4><p>（1）如果要访问结构体成员，需要使用点号 (.) 操作符，格式为：<font color="red">“结构体.成员名”</font>。</p>
<p>结构体类型变量使用struct关键字定义，实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* 声明 Book2 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 title : %s\n&quot;</span>, Book1.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 author : %s\n&quot;</span>, Book1.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 subject : %s\n&quot;</span>, Book1.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 book_id : %d\n&quot;</span>, Book1.book_id)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 title : %s\n&quot;</span>, Book2.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 author : %s\n&quot;</span>, Book2.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 subject : %s\n&quot;</span>, Book2.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 book_id : %d\n&quot;</span>, Book2.book_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Book <span class="number">1</span> title : Go 语言</span><br><span class="line">Book <span class="number">1</span> author : www.w3cschool.cn</span><br><span class="line">Book <span class="number">1</span> subject : Go 语言教程</span><br><span class="line">Book <span class="number">1</span> book_id : <span class="number">6495407</span></span><br><span class="line">Book <span class="number">2</span> title : Python 教程</span><br><span class="line">Book <span class="number">2</span> author : www.w3cschool.cn</span><br><span class="line">Book <span class="number">2</span> subject : Python 语言教程</span><br><span class="line">Book <span class="number">2</span> book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>



<h4 id="3-结构体作为函数参数"><a href="#3-结构体作为函数参数" class="headerlink" title="3.结构体作为函数参数"></a>3.结构体作为函数参数</h4><p>（1）你可以向其他数据类型一样将结构体类型作为参数传递给函数。并以以上实例的方式访问结构体变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* 声明 Book2 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   printBook(Book1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   printBook(Book2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Book title : Go 语言</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Go 语言教程</span><br><span class="line">Book book_id : <span class="number">6495407</span></span><br><span class="line">Book title : Python 教程</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Python 语言教程</span><br><span class="line">Book book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>



<h4 id="4-结构体指针"><a href="#4-结构体指针" class="headerlink" title="4.结构体指针"></a>4.结构体指针</h4><p>（1）你可以定义指向结构体的指针类似于其他指针变量，格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br></pre></td></tr></table></figure>

<p>（2）以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>

<p>（3）使用结构体指针访问结构体成员，使用 “.” 操作符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer.title;</span><br></pre></td></tr></table></figure>

<p>（4）接下来让我们使用结构体指针重写以上实例，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* Declare Book1 of type Book */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* Declare Book2 of type Book */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   printBook(&amp;Book1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   printBook(&amp;Book2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book *Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Book title : Go 语言</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Go 语言教程</span><br><span class="line">Book book_id : <span class="number">6495407</span></span><br><span class="line">Book title : Python 教程</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Python 语言教程</span><br><span class="line">Book book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言切片（Slice）"><a href="#Go语言切片（Slice）" class="headerlink" title="Go语言切片（Slice）"></a>Go语言切片（Slice）</h3><h4 id="1-定义切片"><a href="#1-定义切片" class="headerlink" title="1.定义切片"></a>1.定义切片</h4><p>（1）你可以声明一个未指定大小的数组来定义切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>（2）或使用<font color="red">make()函数</font>来创建切片:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">也可以简写为</span><br><span class="line"></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>

<p>（3）也可以指定容量，其中capacity为可选参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">type</span>, length, capacity)</span><br></pre></td></tr></table></figure>

<p>这里 len 是数组的长度并且也是切片的初始长度。</p>
<h4 id="2-切片初始化"><a href="#2-切片初始化" class="headerlink" title="2.切片初始化"></a>2.切片初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s :=[] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125; </span><br></pre></td></tr></table></figure>

<p>（1）直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[:] </span><br></pre></td></tr></table></figure>

<p>（2）初始化切片s,是数组arr的引用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:endIndex] </span><br></pre></td></tr></table></figure>

<p>（3）将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:] </span><br></pre></td></tr></table></figure>

<p>（4）缺省endIndex时将表示一直到arr的最后一个元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[:endIndex] </span><br></pre></td></tr></table></figure>

<p>（5）缺省startIndex时将表示从arr的第一个元素开始</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := s[startIndex:endIndex] </span><br></pre></td></tr></table></figure>

<p>（6）通过切片s初始化切片s1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>) </span><br></pre></td></tr></table></figure>

<p>（7）通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</p>
<h4 id="3-len-和-cap-函数"><a href="#3-len-和-cap-函数" class="headerlink" title="3.len() 和 cap() 函数"></a>3.len() 和 cap() 函数</h4><p>（1）切片是可索引的，并且可以由 len() 方法获取长度。</p>
<p>（2）切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>
<p>（3）以下为具体实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">3</span> <span class="built_in">cap</span>=<span class="number">5</span> slice=[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<h4 id="4-空-nil-切片"><a href="#4-空-nil-切片" class="headerlink" title="4.空(nil)切片"></a>4.空(nil)切片</h4><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> slice=[]</span><br><span class="line">切片是空的</span><br></pre></td></tr></table></figure>



<h4 id="5-切片截取"><a href="#5-切片截取" class="headerlink" title="5.切片截取"></a>5.切片截取</h4><p>可以通过设置下限及上限来设置截取切片 **[lower-bound:upper-bound]**，实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;   </span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers ==&quot;</span>, numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[1:4] ==&quot;</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[:3] ==&quot;</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[4:] ==&quot;</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]</span><br><span class="line">numbers == [0 1 2 3 4 5 6 7 8]</span><br><span class="line">numbers[1:4] == [1 2 3]</span><br><span class="line">numbers[:3] == [0 1 2]</span><br><span class="line">numbers[4:] == [4 5 6 7 8]</span><br><span class="line">len=0 cap=5 slice=[]</span><br><span class="line">len=2 cap=9 slice=[0 1]</span><br><span class="line">len=3 cap=7 slice=[2 3 4]</span><br></pre></td></tr></table></figure>



<h4 id="6-append-和-copy-函数"><a href="#6-append-和-copy-函数" class="headerlink" title="6.append() 和 copy() 函数"></a>6.append() 和 copy() 函数</h4><p>（1）如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p>
<p>（2）下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> slice=[]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">1</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">8</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">16</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<h3 id="Go语言范围（Range"><a href="#Go语言范围（Range" class="headerlink" title="Go语言范围（Range)"></a>Go语言范围（Range)</h3><h4 id="1-Go-语言范围"><a href="#1-Go-语言范围" class="headerlink" title="1.Go 语言范围"></a>1.Go 语言范围</h4><p>（1）Go 语言中 range 关键字用于for循环中迭代数组(array)、切片(slice)、链表(channel)或集合(map)的元素。</p>
<p>（2）在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值，对于映射，它返回下一个键值对的键。</p>
<p>（2）Range返回一个值或两个值。如果在Range表达式的左侧只使用了一个值，则该值是下表中的第一个值。</p>
<table>
<thead>
<tr>
<th>Range表达式</th>
<th>第一个值</th>
<th>第二个值[可选的]</th>
</tr>
</thead>
<tbody><tr>
<td>Array 或者 slice a [n]E</td>
<td>索引 i int</td>
<td>a[i] E</td>
</tr>
<tr>
<td>String s string type</td>
<td>索引 i int</td>
<td>rune int</td>
</tr>
<tr>
<td>map m map[K]V</td>
<td>键 k K</td>
<td>值 m[k] V</td>
</tr>
<tr>
<td>channel c chan E</td>
<td>元素 e E</td>
<td>none</td>
</tr>
</tbody></table>
<p>（4）实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//(1)这是我们使用range去求一个slice的和。使用数组跟这个很类似</span></span><br><span class="line">    nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum:&quot;</span>, sum)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(2)在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;index:&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(3)range也可以用在map的键值对上。</span></span><br><span class="line">    kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(4)range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;go&quot;</span> &#123;</span><br><span class="line">        fmt.Println(i, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum: <span class="number">9</span></span><br><span class="line">index: <span class="number">1</span></span><br><span class="line">a -&gt; apple</span><br><span class="line">b -&gt; banana</span><br><span class="line"><span class="number">0</span> <span class="number">103</span></span><br><span class="line"><span class="number">1</span> <span class="number">111</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言Map（集合）"><a href="#Go语言Map（集合）" class="headerlink" title="Go语言Map（集合）"></a>Go语言Map（集合）</h3><h4 id="1-定义-Map"><a href="#1-定义-Map" class="headerlink" title="1.定义 Map"></a>1.定义 Map</h4><p>（1）可以使用<font color="red">内建函数 make </font>也可以使用 <font color="red">map 关键字</font>来定义 Map:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable = <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure>

<p>（2）如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p>
<p>（3）实例</p>
<p>下面实例演示了创建和使用map:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">   <span class="comment">/* 创建集合 */</span></span><br><span class="line">   countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* map 插入 key-value 对，各个国家对应的首都 */</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;France&quot;</span>] = <span class="string">&quot;Paris&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Italy&quot;</span>] = <span class="string">&quot;Rome&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Japan&quot;</span>] = <span class="string">&quot;Tokyo&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;India&quot;</span>] = <span class="string">&quot;New Delhi&quot;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 使用 key 输出 map 值 */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 查看元素在集合中是否存在 */</span></span><br><span class="line">   captial, ok := countryCapitalMap[<span class="string">&quot;United States&quot;</span>]</span><br><span class="line">   <span class="comment">/* 如果 ok 是 true, 则存在，否则不存在 */</span></span><br><span class="line">   <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is&quot;</span>, captial)  </span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is not present&quot;</span>) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Capital of France is Paris</span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br><span class="line">Capital of United States is not present</span><br></pre></td></tr></table></figure>



<h4 id="2-delete-函数"><a href="#2-delete-函数" class="headerlink" title="2.delete() 函数"></a>2.delete() 函数</h4><p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key。实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">   <span class="comment">/* 创建 map */</span></span><br><span class="line">   countryCapitalMap := <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">string</span> &#123;<span class="string">&quot;France&quot;</span>:<span class="string">&quot;Paris&quot;</span>,<span class="string">&quot;Italy&quot;</span>:<span class="string">&quot;Rome&quot;</span>,<span class="string">&quot;Japan&quot;</span>:<span class="string">&quot;Tokyo&quot;</span>,<span class="string">&quot;India&quot;</span>:<span class="string">&quot;New Delhi&quot;</span>&#125;</span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">&quot;原始 map&quot;</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 删除元素 */</span></span><br><span class="line">   <span class="built_in">delete</span>(countryCapitalMap,<span class="string">&quot;France&quot;</span>);</span><br><span class="line">   fmt.Println(<span class="string">&quot;Entry for France is deleted&quot;</span>)  </span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">&quot;删除元素后 map&quot;</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">原始 mapCapital of France is ParisCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New DelhiEntry <span class="keyword">for</span> France is deleted删除元素后 mapCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New Delhi</span><br></pre></td></tr></table></figure>



<h3 id="Go语言递归函数"><a href="#Go语言递归函数" class="headerlink" title="Go语言递归函数"></a>Go语言递归函数</h3><h4 id="1-Go-语言递归函数"><a href="#1-Go-语言递归函数" class="headerlink" title="1.Go 语言递归函数"></a>1.Go 语言递归函数</h4><p>递归，就是在运行的过程中调用自己。</p>
<p>语法格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> &#123;   recursion() <span class="comment">/* 函数调用自身 */</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   recursion()&#125;</span><br></pre></td></tr></table></figure>

<p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。</p>
<p>递归函数对于解决数学上的问题是非常有用的，就像计算阶乘，生成斐波那契数列等。</p>
<h4 id="2-阶乘"><a href="#2-阶乘" class="headerlink" title="2.阶乘"></a>2.阶乘</h4><p>以下实例通过 Go 语言的递归函数实例阶乘：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">    result = <span class="number">1</span>;   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = x * Factorial(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">15</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d 的阶乘是 %d\n&quot;</span>, i, Factorial(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span> 的阶乘是 <span class="number">1307674368000</span></span><br></pre></td></tr></table></figure>



<h4 id="3-斐波那契数列"><a href="#3-斐波那契数列" class="headerlink" title="3.斐波那契数列"></a>3.斐波那契数列</h4><p>以下实例通过 Go 语言的递归函数实现斐波那契数列：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n<span class="number">-2</span>) + fibonacci(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">       fmt.Printf(<span class="string">&quot;%d\t&quot;</span>, fibonacci(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">5</span>   <span class="number">8</span>   <span class="number">13</span>  <span class="number">21</span>  <span class="number">34</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言类型转换"><a href="#Go语言类型转换" class="headerlink" title="Go语言类型转换"></a>Go语言类型转换</h3><h4 id="1-Go-语言类型转换"><a href="#1-Go-语言类型转换" class="headerlink" title="1.Go 语言类型转换"></a>1.Go 语言类型转换</h4><p>（1）类型转换用于将一种数据类型的变量转换为另外一种类型的变量。Go 语言类型转换基本格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure>

<p>type_name 为类型，expression 为表达式。</p>
<p>（2）实例</p>
<p>以下实例中将整型转化为浮点型，并计算结果，将结果赋值给浮点型变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">17</span></span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">   <span class="keyword">var</span> mean <span class="keyword">float32</span></span><br><span class="line">   </span><br><span class="line">   mean = <span class="keyword">float32</span>(sum)/<span class="keyword">float32</span>(count)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;mean 的值为: %f\n&quot;</span>,mean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mean 的值为: <span class="number">3.400000</span></span><br></pre></td></tr></table></figure>



<h4 id="2-go-不支持隐式转换类型"><a href="#2-go-不支持隐式转换类型" class="headerlink" title="2.go 不支持隐式转换类型"></a>2.go 不支持隐式转换类型</h4><p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int32</span></span><br><span class="line">    b = a</span><br><span class="line">    fmt.Printf(<span class="string">&quot;b 为 : %d&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cannot use a (<span class="keyword">type</span> <span class="keyword">int64</span>) as <span class="keyword">type</span> <span class="keyword">int32</span> in assignment</span><br><span class="line">cannot use b (<span class="keyword">type</span> <span class="keyword">int32</span>) as <span class="keyword">type</span> <span class="keyword">string</span> in argument to fmt.Printf</span><br></pre></td></tr></table></figure>

<p>但是如果改成 <code>b = int32(a) </code>就不会报错了:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int32</span></span><br><span class="line">    b = <span class="keyword">int32</span>(a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;b 为 : %d&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="GO语言接口"><a href="#GO语言接口" class="headerlink" title="GO语言接口"></a>GO语言接口</h3><h4 id="1-Go-语言接口"><a href="#1-Go-语言接口" class="headerlink" title="1.Go 语言接口"></a>1.Go 语言接口</h4><p>（1）Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p>
<p>实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_name1</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_namen</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个接口Phone，接口里面有一个方法call()。然后我们在main函数里面定义了一个Phone类型变量，并分别为之赋值为NokiaPhone和IPhone。然后调用call()方法，输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">I am Nokia, I can call you!</span><br><span class="line">I am iPhone, I can call you!</span><br></pre></td></tr></table></figure>

<p>（2）</p>
<ul>
<li><a href="https://www.cnblogs.com/itogo/p/8645486.html">参考1</a></li>
<li><a href="https://blog.csdn.net/lipenghandsome/article/details/105916687">参考2</a></li>
</ul>
<h3 id="GO语言错误处理"><a href="#GO语言错误处理" class="headerlink" title="GO语言错误处理"></a>GO语言错误处理</h3><h4 id="1-Go-错误处理"><a href="#1-Go-错误处理" class="headerlink" title="1.Go 错误处理"></a>1.Go 错误处理</h4><p>（1）Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p>
<p>error类型是一个接口类型，这是它的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）我们可以在编码中通过实现 error 接口类型来生成错误信息。</p>
<p>函数通常在最后的返回值中返回错误信息。使用<font color="red">errors.New </font>可返回一个错误信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）在下面的例子中，我们在调用Sqrt的时候传递的一个负数，然后就得到了non-nil的error对象，将此对象与nil比较，结果为true，所以fmt.Println(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err:= Sqrt(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 DivideError 结构</span></span><br><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">    dividee <span class="keyword">int</span></span><br><span class="line">    divider <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `error` 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(de *DivideError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    strFormat := <span class="string">`</span></span><br><span class="line"><span class="string">    Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="string">    dividee: %d</span></span><br><span class="line"><span class="string">    divider: 0</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(strFormat, de.dividee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 `int` 类型除法运算的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(varDividee <span class="keyword">int</span>, varDivider <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>, errorMsg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> varDivider == <span class="number">0</span> &#123;</span><br><span class="line">            dData := DivideError&#123;</span><br><span class="line">                    dividee: varDividee,</span><br><span class="line">                    divider: varDivider,</span><br><span class="line">            &#125;</span><br><span class="line">            errorMsg = dData.Error()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> varDividee / varDivider, <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况</span></span><br><span class="line">    <span class="keyword">if</span> result, errorMsg := Divide(<span class="number">100</span>, <span class="number">10</span>); errorMsg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;100/10 = &quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当被除数为零的时候会返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span> _, errorMsg := Divide(<span class="number">100</span>, <span class="number">0</span>); errorMsg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;errorMsg is: &quot;</span>, errorMsg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>/<span class="number">10</span> =  <span class="number">10</span></span><br><span class="line">errorMsg is:  </span><br><span class="line">   Cannot proceed, the divider is zero.</span><br><span class="line">  dividee: <span class="number">100</span></span><br><span class="line">  divider: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>（4）</p>
<ul>
<li><a href="https://blog.csdn.net/m0_38004619/article/details/98968097">Go语言中的异常处理</a></li>
<li><a href="https://www.jianshu.com/p/f30da01eea97">Golang错误和异常处理的正确姿势</a></li>
</ul>
]]></content>
      <categories>
        <category>《Golang》</category>
      </categories>
      <tags>
        <tag>Go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>三层交换机配置VLAN</title>
    <url>/2021/07/31/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AEVLAN/</url>
    <content><![CDATA[<h4 id="1-二层转发与三层转发原理"><a href="#1-二层转发与三层转发原理" class="headerlink" title="1.二层转发与三层转发原理"></a>1.二层转发与三层转发原理</h4><h5 id="（1）二层转发（交换机转发）"><a href="#（1）二层转发（交换机转发）" class="headerlink" title="（1）二层转发（交换机转发）"></a>（1）二层转发（交换机转发）</h5><ul>
<li><p>首先需要明确，交换机连接的线路（主机）属于同一局域网（同一网段：具有相同的网络号，ip&amp;&amp;netmask），同一网段内的主机可以直接通信而不需要进行路由器转发。</p>
</li>
<li><p>当主机1需要发送数据给主机2时，先看主机2的IP是否和自己属于同一网段；如果是，则先根据主机2的IP地址查找自己的ARP表，如果没找到对应的主机2的MAC地址（物理地址），则向整个局域网广播发送一个ARP请求（含主机2 IP），局域网内其他主机收到这个ARP请求时，对比发现这个IP和自己不一致，所以不予理会，当主机2收到这个ARP请求时，对比发现这个IP正是自己，所以给主机1回送一个ARP响应（含主机2 MAC），这样主机1就获取到了主机2的MAC地址了，并在ARP表中增加一项（主机2 - IP - MAC）。最后主机1就可以根据这个主机2的MAC地址发送数据了。</p>
</li>
<li><p>有了主机2的MAC地址，具体怎么发送呢？主机1先将数据（含主机2 MAC地址）发送给与自己直接相连的交换机，交换机知道本局域网内的所有主机在自己的哪个接口方向，why? 交换机里面有张MAC交互表（MAC - 接口X），每一项是主机MAC和对应接口号，这张MAC交换表是通过交换机的<a href="https://blog.csdn.net/m0_37768843/article/details/89423196">自学习功能</a>[构建起来的。然后交换机根据这个MAC地址就知道要把数据从哪个接口发送出去，下一个收到的交换机也是这样操作，直到数据到达主机2。</p>
</li>
</ul>
<h5 id="（2）三层转发（路由器转发）"><a href="#（2）三层转发（路由器转发）" class="headerlink" title="（2）三层转发（路由器转发）"></a>（2）三层转发（路由器转发）</h5><ul>
<li>路由器连接的线路属于不同的局域网（网段），不同局域网直接发送数据需要进行路由转发。</li>
<li>当主机1需要发送数据给主机2时，先看主机2的IP是否和自己属于同一网段；如果不是，则主机1直接将数据二层转发给默认网关（主机1的ARP表中有默认路由器的IP和MAC，故可以将数据通过交换机发送给默认路由器），而不会构造ARP请求在本局域网内广播寻找主机2。</li>
<li>默认路由器接收到数据后，根据目的IP地址的网络号查看（通过多种路由协议构建起来的）路由表，如果没找到对应的项，则丢弃数据；如果找到对应的项，则获得路由表中的下一跳路由器IP地址，拿着这个下一跳IP地址查看ARP表，找到下一跳的MAC地址，通过MAC地址将数据发送给下一跳路由器。下一跳路由器也是如此转发，直到转发到主机2所在网段，并发送给主机2。</li>
<li>所有在三层转发过程中，数据中信息字段的目的IP地址是一直没有改变的（一直是主机2），但是MAC地址是动态改变的，是下一跳路由器或主机的MAC地址。三层转发建立在二层转发基础之上。</li>
</ul>
<h5 id="（3）能否通过交互机实现三层转发"><a href="#（3）能否通过交互机实现三层转发" class="headerlink" title="（3）能否通过交互机实现三层转发"></a>（3）能否通过交互机实现三层转发</h5><ul>
<li>问题：能够通过交换机实现三层转发，即实现不同网段之间的连接。</li>
<li>理论上来说，对应传统的二层交换机是无法做到这一点的。因为当主机1首先查看到目的主机2的IP地址与自己属于不同的网段，会将数据直接发送给默认网关，而不会通过交换机发送到主机2。网上有一种说法，说将主机1的默认网关设置为自己的IP就能实现交换机三层转发，这中做法还有待验证。</li>
<li>但是随着设备的发展，现在已经出现了三层交换机，不仅具有二层的MAC转发功能，同时具备三层的路由功能，因此能实现三层转发。具体做法是在交换机上构造不同的虚拟局域网<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/419962?fromtitle=VLAN&fromid=320429&fr=aladdin">VLAN</a>，VLAN本质就是指一个<a href="https://baike.baidu.com/item/%E7%BD%91%E6%AE%B5">网段</a>，之所以叫做虚拟的局域网，是因为它是在<font color="cornflowerblue">虚拟的路由器的接口</font>下创建的网段。不同网段的VLAN可以通过交换机实现三层互通。</li>
</ul>
<h4 id="2-cisco模拟器上实现交换机二层、三层通"><a href="#2-cisco模拟器上实现交换机二层、三层通" class="headerlink" title="2.cisco模拟器上实现交换机二层、三层通"></a>2.cisco模拟器上实现交换机二层、三层通</h4><h5 id="（1）网络拓扑图"><a href="#（1）网络拓扑图" class="headerlink" title="（1）网络拓扑图"></a>（1）网络拓扑图</h5><p><img src="/2021/07/31/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AEVLAN/image-20210730144404698.png" alt="image-20210730144404698"></p>
<h5 id="（2）交换机配置"><a href="#（2）交换机配置" class="headerlink" title="（2）交换机配置"></a>（2）交换机配置</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Switch&gt;</span><span class="bash"><span class="built_in">enable</span></span></span><br><span class="line"><span class="meta">Switch#</span><span class="bash">conf t</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line"><span class="meta">#</span><span class="bash">创建vlan</span></span><br><span class="line"><span class="meta">Switch(config)#</span><span class="bash">vlan 2</span></span><br><span class="line"><span class="meta">Switch(config-vlan)#</span><span class="bash"><span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">Switch(config)#</span><span class="bash">vlan 3</span></span><br><span class="line"><span class="meta">Switch(config-vlan)#</span><span class="bash"><span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">进入接口配置模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置接口为接入模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将接口接入到对应的vlan</span></span><br><span class="line"><span class="meta">Switch(config)#</span><span class="bash">int f0/1</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">switchport mode access</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">switchport access vlan 2</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">int f0/2</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">switchport mode access</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">switchport access vlan 2</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">int f0/3</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">switchport mode access</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">switchport access vlan 3</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">int f0/4</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">switchport mode access</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">switchport access vlan 3</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash"><span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">进入vlan配置模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动该vlan</span></span><br><span class="line"><span class="meta">#</span><span class="bash">配置vlan的接口ip（虚拟的路由器接口，多个接口同一ip）</span></span><br><span class="line"><span class="meta">Switch(config)#</span><span class="bash">int vlan 2</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash"></span></span><br><span class="line"><span class="bash">%LINK-5-CHANGED: Interface Vlan2, changed state to up</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan2, changed state to up</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">no shutdown</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">ip address 192.168.1.1 255.255.255.0</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash"><span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">Switch(config)#</span><span class="bash">int vlan 3</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash"></span></span><br><span class="line"><span class="bash">%LINK-5-CHANGED: Interface Vlan3, changed state to up</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan3, changed state to up</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">no shutdown</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash">ip address 192.168.2.1 255.255.255.0</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash"><span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动交换机路由功能</span></span><br><span class="line"><span class="meta">Switch(config)#</span><span class="bash">ip routing</span></span><br></pre></td></tr></table></figure>

<h5 id="3-主机配置"><a href="#3-主机配置" class="headerlink" title="(3)主机配置"></a>(3)主机配置</h5><img src="/2021/07/31/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AEVLAN/image-20210730145243574.png" alt="image-20210730145243574" style="zoom:50%;">

<img src="/2021/07/31/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AEVLAN/image-20210730145302547.png" alt="image-20210730145302547" style="zoom:50%;">

<img src="/2021/07/31/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AEVLAN/image-20210730145317227.png" alt="image-20210730145317227" style="zoom:50%;">

<img src="/2021/07/31/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AEVLAN/image-20210730145330498.png" alt="image-20210730145330498" style="zoom:50%;">



<h5 id="（5）连通性测试"><a href="#（5）连通性测试" class="headerlink" title="（5）连通性测试"></a>（5）连通性测试</h5><ul>
<li>二层互通</li>
</ul>
<p><img src="/2021/07/31/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AEVLAN/image-20210730145524388.png" alt="image-20210730145524388"></p>
<ul>
<li>三层互通</li>
</ul>
<p><img src="/2021/07/31/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AEVLAN/image-20210730145549933.png" alt="image-20210730145549933"></p>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-collections模块</title>
    <url>/2022/01/07/Python-collections%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<ul>
<li><p>collections模块实现一些特定的数据类型，可以替代Python中常用的内置数据类型如dict, list, set,tuple，简单说就是对基本数据类型做了更上一层的处理。</p>
</li>
<li><p>collections是日常工作中的重点、高频模块，常用类型有：</p>
<ul>
<li><p>计数器（Counter）</p>
</li>
<li><p>双向队列（deque）</p>
</li>
<li><p>默认字典（defaultdict）</p>
</li>
<li><p>有序字典（OrderedDict）</p>
</li>
<li><p>具名元组（namedtuple）　</p>
</li>
</ul>
</li>
</ul>
<h1 id="1-计数器Counter"><a href="#1-计数器Counter" class="headerlink" title="1. 计数器Counter"></a>1. 计数器Counter</h1><ul>
<li>Counter作为字典dict的一个子类， 可以支持方便、快速的计数 ，将元素进行数量统计，计数后返回一个字典，键值为元素，值为元素个数</li>
</ul>
<ul>
<li><p>常用方法</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">most_common(int)</td>
<td align="center">按照元素出现的次数进行从高到低的排序，返回前int个元素的字典</td>
</tr>
<tr>
<td align="center">elements</td>
<td align="center">返回经过计算器Counter后的元素，返回的是一个迭代器</td>
</tr>
<tr>
<td align="center">update</td>
<td align="center">和set集合的update一样，对集合进行并集更新</td>
</tr>
<tr>
<td align="center">subtract</td>
<td align="center">和update类似，只是update是做加法，subtract做减法,从另一个集合中减去本集合的元素</td>
</tr>
<tr>
<td align="center">items</td>
<td align="center">返回由Counter生成的字典的所有item</td>
</tr>
<tr>
<td align="center">keys</td>
<td align="center">返回由Counter生成的字典的所有key</td>
</tr>
<tr>
<td align="center">values</td>
<td align="center">返回由Counter生成的字典的所有value</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;abcabccabde&quot;</span></span><br><span class="line">li = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">dic = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span> : <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span> : <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Counter对象获取各个元素的个数，返回字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Counter(str):&quot;</span>, Counter(<span class="built_in">str</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Counter(li):&quot;</span>, Counter(li))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Counter(dic):&quot;</span>, Counter(dic))</span><br><span class="line"></span><br><span class="line"><span class="comment"># most_common(int)按照元素出现的次数进行从高到低的排序，返回前int个元素的元组（键，值）</span></span><br><span class="line">d1 = Counter(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.most_common(2):&quot;</span>,d1.most_common(<span class="number">2</span>))</span><br><span class="line">d1 = Counter(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.most_common():&quot;</span>,d1.most_common())    <span class="comment"># 不加参数返回所有</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># elements返回经过计算器Counter后的元素，返回的是一个迭代器</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;sorted(d1.elements()):&quot;</span>, <span class="built_in">sorted</span>(d1.elements()))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;list(d1.elements()):&quot;</span>, <span class="built_in">list</span>(d1.elements()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># update和set集合的update一样，对集合进行并集更新</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.update(&#x27;aaa&#x27;):&quot;</span>, d1.update(<span class="string">&quot;aaa&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(d1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># subtract 和update类似，只是update是做加法，subtract做减法,从另一个集合中减去本集合的元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.substract(&#x27;aab&#x27;):&quot;</span>, d1.subtract(<span class="string">&quot;aab&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(d1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># items 返回由Counter生成的字典的所有item</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.items():&quot;</span>, d1.items())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回由Counter生成的字典的所有key</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.keys():&quot;</span>, d1.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回由Counter生成的字典的所有value</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;d1.values():&quot;</span>, d1.values())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-&gt;Counter(<span class="built_in">str</span>): Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">-&gt;Counter(li): Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">-&gt;Counter(dic): Counter(&#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line">    </span><br><span class="line">-&gt;d1.most_common(<span class="number">2</span>): [(<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line">-&gt;d1.most_common(): [(<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">-&gt;<span class="built_in">sorted</span>(d1.elements()): [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">-&gt;<span class="built_in">list</span>(d1.elements()): [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">-&gt;d1.update(<span class="string">&#x27;aaa&#x27;</span>): <span class="literal">None</span></span><br><span class="line">-&gt;Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">-&gt;d1.substract(<span class="string">&#x27;aab&#x27;</span>): <span class="literal">None</span></span><br><span class="line">-&gt;Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">-&gt;d1.items(): dict_items([(<span class="string">&#x27;a&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">1</span>)])</span><br><span class="line">    </span><br><span class="line">-&gt;d1.keys(): dict_keys([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">-&gt;d1.values(): dict_values([<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2-双向队列deque"><a href="#2-双向队列deque" class="headerlink" title="2.双向队列deque"></a>2.双向队列deque</h1><ul>
<li>deque是栈和队列的一种广义实现，deque是”double-end queue”的简称；deque支持线程安全、有效内存地以近似O(1)的性能在deque的两端插入和删除元素，尽管list也支持相似的操作，但是它主要在固定长度操作上的优化，从而在pop(0)和insert(0,v)（会改变数据的位置和大小）上有O(n)的时间复杂度。</li>
</ul>
<ul>
<li><p>常用方法</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">append</td>
<td align="center">队列右边添加元素</td>
</tr>
<tr>
<td align="center">appendleft</td>
<td align="center">队列左边添加元素</td>
</tr>
<tr>
<td align="center">clear</td>
<td align="center">清空队列中的所有元素</td>
</tr>
<tr>
<td align="center">count(value)</td>
<td align="center">返回队列中包含value的个数</td>
</tr>
<tr>
<td align="center">extend</td>
<td align="center">队列右边扩展，可以是列表、元组或字典，如果是字典则将字典的key加入到deque</td>
</tr>
<tr>
<td align="center">extendleft</td>
<td align="center">同extend，在左边扩展</td>
</tr>
<tr>
<td align="center">pop</td>
<td align="center">移除并返回队列右边的元素</td>
</tr>
<tr>
<td align="center">popleft</td>
<td align="center">移除并返回队列左边的元素</td>
</tr>
<tr>
<td align="center">remove（value）</td>
<td align="center">移除队列第一个出现的元素</td>
</tr>
<tr>
<td align="center">reverse</td>
<td align="center">队列的所有元素进行反转</td>
</tr>
<tr>
<td align="center">rotate（n）</td>
<td align="center">对队列数进行移动</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">dst = deque(list1)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt; deque([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># append appendleft</span></span><br><span class="line">dst.append(<span class="number">4</span>)</span><br><span class="line">dst.appendleft(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># extend extendleft</span></span><br><span class="line">ex = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">st = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">dst.extend(ex)</span><br><span class="line">dst.extendleft(st)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop popleft</span></span><br><span class="line">dst.pop()</span><br><span class="line">dst.popleft()</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># count</span></span><br><span class="line"><span class="built_in">print</span>(dst.count(<span class="number">2</span>))</span><br><span class="line">-&gt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># insert</span></span><br><span class="line">dst.insert(<span class="number">0</span>, <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># rotate</span></span><br><span class="line">dst = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], maxlen = <span class="number">9</span>)</span><br><span class="line">dst.rotate(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], maxlen=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove</span></span><br><span class="line">dst.remove(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(dst)</span><br><span class="line">-&gt;deque([<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>], maxlen=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># maxlen</span></span><br><span class="line"><span class="built_in">print</span>(dst.maxlen)</span><br><span class="line">-&gt;<span class="number">9</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-默认字典defaultdict"><a href="#3-默认字典defaultdict" class="headerlink" title="3. 默认字典defaultdict"></a>3. 默认字典defaultdict</h1><ul>
<li> Python中通过Key访问字典，当Key不存在时，会引发<code>‘KeyError’</code>异常。为了避免这种情况的发生，可以使用collections类中的defaultdict()方法来为字典提供默认值 </li>
</ul>
<ul>
<li><p> defaultdict是内置数据类型dict的一个子类，基本功能与dict一样，只是重写了一个<code>missing(key)</code>和增加了一个可写的对象变量<font color="cornflowerblue"> default_factory </font> </p>
</li>
<li><p>如果default_factory属性为None，就报出以key作为遍历的KeyError异常；</p>
</li>
<li><p>如果default_factory不为None，就会向给定的key提供一个默认值，这个值插入到词典中，并返回； 如 d = defaultdict(list) ，默认值是一个空的列表</p>
</li>
<li><p>举例</p>
<ul>
<li><p>default_factory属性为None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># default_factory属性为None</span></span><br><span class="line">d = defaultdict()</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="comment"># 报错:KeyError: &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>default_factory属性为list（列表字典）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># default_factory属性为list</span></span><br><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;a&#x27;</span>])	<span class="comment"># 不存在键&#x27;a&#x27;时，返回默认值一个空的列表</span></span><br><span class="line"><span class="built_in">print</span>(d)		<span class="comment"># 此时d中增加了一个有默认值的键了</span></span><br><span class="line"><span class="comment"># -&gt;[]</span></span><br><span class="line"><span class="comment"># -&gt;defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;a&#x27;: []&#125;)</span></span><br><span class="line"></span><br><span class="line">s = [(<span class="string">&#x27;y&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;y&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;r&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">    d[k].append(v)	<span class="comment"># 如果不存在键K,则返回一个默认值[]给d[k]</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># -&gt;defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;y&#x27;: [1, 3], &#x27;b&#x27;: [2, 4], &#x27;r&#x27;: [1]&#125;)	</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dict.setdefault()也可以实现相同的功能</span></span><br><span class="line">e = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">    e.setdefault(k, []).append(v)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment"># -&gt;&#123;&#x27;y&#x27;: [1, 3], &#x27;b&#x27;: [2, 4], &#x27;r&#x27;: [1]&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>default_factory属性为set（集合字典）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将default_factory设置为set，使得defaultdict可以建立一个集合字典</span></span><br><span class="line">s = [(<span class="string">&#x27;r&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;r&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;r&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line">d = defaultdict(<span class="built_in">set</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">    d[k].add(v)     <span class="comment"># 键k不存在则返回一个默认的空set，set类似list,但set中元素不能重复</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># -&gt;defaultdict(&lt;class &#x27;set&#x27;&gt;, &#123;&#x27;r&#x27;: &#123;1, 3&#125;, &#x27;b&#x27;: &#123;2, 4&#125;&#125;)</span></span><br></pre></td></tr></table></figure></li>
<li><p>default_factory属性为int（计数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置default_factory为int，使得defaultdict可以用于计数</span></span><br><span class="line"><span class="comment"># 字符串中的字母第一次出现时，字典中没有该字母，default_factory函数调用int()为其提供一个默认值0,加法操作将计算出每个字母出现的次数。</span></span><br><span class="line">s = <span class="string">&#x27;abidajiadgaji&#x27;</span></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> s:</span><br><span class="line">    d[k] += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># -&gt;defaultdict(&lt;class &#x27;int&#x27;&gt;, &#123;&#x27;a&#x27;: 4, &#x27;b&#x27;: 1, &#x27;i&#x27;: 3, &#x27;d&#x27;: 2, &#x27;j&#x27;: 2, &#x27;g&#x27;: 1&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="4-具名元组namedtuple"><a href="#4-具名元组namedtuple" class="headerlink" title="4. 具名元组namedtuple"></a>4. 具名元组namedtuple</h1><ul>
<li><p>普通元组的局限性： 不能为元组内部的数据进行命名，所以往往我们并不知道一个元组所要表达的意义 </p>
</li>
<li><p> <strong>namedtuple</strong>： 引入了 <strong>collections.namedtuple</strong> 这个工厂函数，来构造一个带字段名的元组。具名元组的实例和普通元组消耗的内存一样多，因为字段名都被存在对应的类里面。这个类跟普通的对象实例比起来也要小一些，因为 Python 不会用 <strong>dict</strong> 来存放这些实例的属性。</p>
</li>
<li><p>定义格式：<font color="cornflowerblue">collections.namedtuple(typename, field_names, verbose=False, rename=False) </font></p>
<ul>
<li> <strong>typename</strong>：元组名称</li>
<li> <strong>field_names</strong>: 元组中元素的名称</li>
<li> <strong>rename</strong>: 如果元素名称中含有 python 的关键字，则必须设置为 rename=True</li>
<li> <strong>verbose</strong>: 默认就好</li>
</ul>
</li>
<li><p>创建命名元组并实例化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个具名元组，需要两个参数，一个是元组名，另一个是元组的各个字段名。</span></span><br><span class="line"><span class="comment"># 后者可以是有多个字符串组成的可迭代对象，或者是有空格分隔开的字段名组成的字符串</span></span><br><span class="line">User = namedtuple(<span class="string">&#x27;User&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">User = namedtuple(<span class="string">&#x27;User&#x27;</span>, <span class="string">&#x27;name age id&#x27;</span>)</span><br><span class="line"><span class="comment"># User是具名元组的变量名，&#x27;User&#x27;是具名元组的名称,一般相同</span></span><br><span class="line"></span><br><span class="line">zlx = User(<span class="string">&#x27;zlx&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(zlx)</span><br></pre></td></tr></table></figure></li>
<li><p>具名元组的特有属性</p>
<ul>
<li>类属性**_fields**： 包含这个类所有字段名的元组 </li>
<li>类方法 **_make(iterable)**：接受一个可迭代对象来生产这个类的实例 </li>
<li>实例方法 **_asdict()**：把具名元组以 collections.OrderedDict 的形式返回，可以利用它来把元组里的信息友好的展示出来 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取所有字段名</span></span><br><span class="line"><span class="built_in">print</span>(zlx._fields)</span><br><span class="line"><span class="comment"># -&gt; (&#x27;name&#x27;, &#x27;age&#x27;, &#x27;id&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取各个字段的值</span></span><br><span class="line"><span class="built_in">print</span>(zlx.name)</span><br><span class="line"><span class="built_in">print</span>(zlx.age)</span><br><span class="line"><span class="built_in">print</span>(zlx.<span class="built_in">id</span>)</span><br><span class="line"><span class="comment"># -&gt; zlx</span></span><br><span class="line"><span class="comment"># -&gt; 22</span></span><br><span class="line"><span class="comment"># -&gt; 123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改对象属性，注意要使用&quot;_replace&quot;方法</span></span><br><span class="line">zlx = zlx._replace(age=<span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(zlx)</span><br><span class="line"><span class="comment"># -&gt; User(name=&#x27;zlx&#x27;, age=18, id=&#x27;123456&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将User对象转换成字典，注意要使用&quot;_asdict&quot;</span></span><br><span class="line"><span class="built_in">print</span>(zlx._asdict())</span><br><span class="line"><span class="comment"># -&gt; &#123;&#x27;name&#x27;: &#x27;zlx&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: &#x27;123456&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-有序字典-OrderedDict"><a href="#5-有序字典-OrderedDict" class="headerlink" title="5. 有序字典 OrderedDict"></a>5. 有序字典 OrderedDict</h1><ul>
<li><p>python中的字典dict是无序的，即迭代遍历（键，值）的顺序可能和插入的顺序不一致，因为它是按照hash来存储的。 常规dict并不跟踪插入顺序，迭代处理会根据键在散列表中存储的顺序来生成值。在OrderDict中则相反，它会记住元素插入的顺序，并在创建迭代器时使用这个顺序。 </p>
</li>
<li><p>OrderedDict提供了一个有序的字典结构，内部维护这一个根据键插入顺序排序的双向链表，在迭代操作的时候保持了元素插入时的顺序。需要注意的是，一个OrderedDic的大小是一个普通字典的两倍，因为内部维护了另外一个链表，所有在数据量大的时候，如果不要求保持插入顺序，最好用普通字典。</p>
</li>
<li><p>有序字典和普通字典的相等测试：有序字典是对顺序敏感的，即元素插入顺序不同，两个有序字典就不同；普通字典对顺序是不敏感的，即元素插入顺序不同，两个普通字典仍相同。</p>
</li>
<li><p>有序字典除具有普通字典的原始方法外，还提供了和顺序相关的操作，popitem(last=True)以LIFO方式弹出元素（last=False则以FIFO方式）；reversed(dict)返回一个逆序的orderedDict对象</p>
</li>
<li><pre><code class="python">from collections import OrderedDict
d = &#123;&#125;
d[&#39;a&#39;] = &#39;A&#39;
d[&#39;b&#39;] = &#39;B&#39;
d[&#39;c&#39;] = &#39;C&#39;
for k, v in d.items():
    print(k, v)
b = &#123;&#125;
b[&#39;a&#39;] = &#39;A&#39;
b[&#39;c&#39;] = &#39;C&#39;
b[&#39;b&#39;] = &#39;B&#39;
for k, v in d.items():
    print(k, v)
print(d == b)   # True

d = OrderedDict()
d[&#39;a&#39;] = &#39;A&#39;
d[&#39;b&#39;] = &#39;B&#39;
d[&#39;c&#39;] = &#39;C&#39;
for k, v in d.items():
    print(k, v)
b = OrderedDict()
b[&#39;a&#39;] = &#39;A&#39;
b[&#39;c&#39;] = &#39;C&#39;
b[&#39;b&#39;] = &#39;B&#39;
for k, v in d.items():
    print(k, v)
print(d == b)   # False

print(d.popitem(last=True))
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-lambda表达式</title>
    <url>/2022/02/19/Python-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Python-lambda表达式"><a href="#Python-lambda表达式" class="headerlink" title="Python lambda表达式"></a>Python lambda表达式</h2><h3 id="一、语法和介绍"><a href="#一、语法和介绍" class="headerlink" title="一、语法和介绍"></a>一、语法和介绍</h3><ul>
<li>语法：<font color="red">lambda argument_list: expression</font><ul>
<li>lambda函数：又称“匿名函数”</li>
<li>argument_list：参数列表，作为函数的输入</li>
<li>expression：表达式，只能用到参数列表中出现的参数，根据表达式计算得到的值作为函数的输出</li>
</ul>
</li>
<li>介绍：<ul>
<li>lambda的函数体只有一个表达式，而非代码块，代码简洁</li>
<li>lambda函数无需命名即可快速调用</li>
<li>简单单行函数或一次性函数可以用lambda表达式来书写</li>
</ul>
</li>
</ul>
<h3 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h3><ol>
<li><p>匿名调用和命名调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># def函数写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># lambada表达式既可以匿名直接调用，也可以赋值给某个变量再调用</span></span><br><span class="line"><span class="comment"># 匿名调用</span></span><br><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> x, y: x + y)(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名调用</span></span><br><span class="line">a = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"><span class="built_in">print</span>(a(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>作为函数法返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x, y: x + y</span><br></pre></td></tr></table></figure></li>
<li><p>与其他函数配合使用</p>
<ul>
<li><p>filter(function, iterable)函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 过滤掉某些不符合条件的元素</span></span><br><span class="line"><span class="comment"># 其中iterable可以为列表、字符串或元组，逐一对元素通过function的条件进行筛选，然后保留下满足条件的数据。python3返回的是一个迭代器，可以用list进行转换得到输出结果</span></span><br><span class="line"><span class="comment"># 此时lambda函数用于指定过滤列表元素的条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留奇数</span></span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span>, nums))</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure></li>
<li><p>map(function, iterable)函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 会根据提供的function函数对指定序列做映射</span></span><br><span class="line"><span class="comment"># 逐一对元素通过function操作,返回的是一个迭代器，可以用list进行转换</span></span><br><span class="line"><span class="comment"># 此时lambda函数用于指定映射规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出平方</span></span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, nums))</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure></li>
<li><p>reduce(function, iterable)函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对参数序列中的元素进行累计</span></span><br><span class="line"><span class="comment"># 函数先将iterable中的第1和第2个元素进行function操作，将得到的结果与第3个数进行function操作，如此累积</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求和</span></span><br><span class="line">nums = reduce(<span class="keyword">lambda</span> x, y: x + y, nums)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure></li>
<li><p>sorted(iterable, key = function) 和 iterable.sort(key = function)函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时lambda函数用于指定对列表中所有元素进行排序的准则</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字符串长度排序</span></span><br><span class="line">s = [<span class="string">&quot;abdc&quot;</span>, <span class="string">&quot;djind&quot;</span>, <span class="string">&quot;in&quot;</span>, <span class="string">&quot;a&quot;</span>]</span><br><span class="line">s.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x))</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字典的键排序</span></span><br><span class="line">d = &#123;<span class="number">4</span>: <span class="string">&quot;hhh&quot;</span>, <span class="number">3</span>: <span class="string">&quot;jidn&quot;</span>, <span class="number">5</span>: <span class="string">&quot;djien&quot;</span>&#125;</span><br><span class="line">d = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按元组的某一位排序</span></span><br><span class="line">d = [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">0</span>)]</span><br><span class="line">d = <span class="built_in">list</span>(<span class="built_in">sorted</span>(d, key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="三、举例"><a href="#三、举例" class="headerlink" title="三、举例"></a>三、举例</h3><p>​    将字符串按照字母顺序排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python中的字符串类型是不允许直接修改元素的。必须先把要排序的字符串放在容器里，如list。然后在通过sort函数排序，最后还原成字符串</span></span><br><span class="line">s=<span class="string">&quot;string&quot;</span></span><br><span class="line">l=<span class="built_in">list</span>(s)</span><br><span class="line">l.sort()</span><br><span class="line">s=<span class="string">&quot;&quot;</span>.join(l)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="comment"># 通过lambda表达式一行搞定</span></span><br><span class="line"><span class="comment"># 表达式为 （x.sort(), x）[1] 去元组中的第二个数,即已经排好序的参数x,而传入的参数是list(s)</span></span><br><span class="line">s=<span class="string">&quot;&quot;</span>.join((<span class="keyword">lambda</span> x:(x.sort(),x)[<span class="number">1</span>])(<span class="built_in">list</span>(s)))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>匿名函数</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>获取前k大的索引</title>
    <url>/2022/03/11/%E8%8E%B7%E5%8F%96%E5%89%8Dk%E5%A4%A7%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<ul>
<li>获取前n大的元素索引</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMaxNumIndex</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    max_num_index = <span class="built_in">list</span>(<span class="built_in">map</span>(nums.index, heapq.nlargest(k, nums)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;max_num_index:&#x27;</span>, max_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMaxNumIndex2</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    copy_nums = copy.deepcopy(nums)</span><br><span class="line">    copy_nums.sort()</span><br><span class="line">    max_num_index = [nums.index(one) <span class="keyword">for</span> one <span class="keyword">in</span> copy_nums[-k:]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;max_num_index:&#x27;</span>, max_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMaxNumIndex3</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    num_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        num_dict[i] = nums[i]</span><br><span class="line">    <span class="comment"># 先按x[1]值大小排序，值相同的按x[0]索引排序</span></span><br><span class="line">    sort_list = <span class="built_in">sorted</span>(num_dict.items(), key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], -x[<span class="number">0</span>]))</span><br><span class="line">    max_num_index = [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> sort_list[-k:]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;max_num_index:&#x27;</span>, max_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMaxNumIndex4</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    copy_list = copy.deepcopy(nums)</span><br><span class="line">    min_num = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    max_num_index = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        one_max_index = copy_list.index(<span class="built_in">max</span>(copy_list))</span><br><span class="line">        max_num_index.append(one_max_index)</span><br><span class="line">        copy_list[one_max_index] = min_num</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;max_num_index:&#x27;</span>, max_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMaxNumIndex5</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    nums = np.array(nums)</span><br><span class="line">    <span class="built_in">print</span>(nums.argsort())</span><br><span class="line">    <span class="comment"># argsort将nums从小到达排序，并提取在原数组中的索引</span></span><br><span class="line">    <span class="comment"># 排序前   [12, 3, 4, 18, 20, 1, 34, 2, 0]</span></span><br><span class="line">    <span class="comment"># 排序后   [0, 1, 2, 3, 4, 12, 18, 20, 34]</span></span><br><span class="line">    <span class="comment"># 提取索引后[8, 5, 7, 1, 2, 0, 3, 4, 6]</span></span><br><span class="line">    max_num_index = nums.argsort()[-k:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;max_num_index:&#x27;</span>, max_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">    k = <span class="number">3</span></span><br><span class="line">    getListMaxNumIndex(nums, k)</span><br><span class="line">    getListMaxNumIndex2(nums, k)</span><br><span class="line">    getListMaxNumIndex3(nums, k)</span><br><span class="line">    getListMaxNumIndex4(nums, k)</span><br><span class="line">    getListMaxNumIndex5(nums, k)</span><br></pre></td></tr></table></figure>



<ul>
<li>获取前n小的元素索引</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMinNumIndex</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    min_num_index = <span class="built_in">list</span>(<span class="built_in">map</span>(nums.index, heapq.nsmallest(k, nums)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;min_num_index:&#x27;</span>, min_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMinNumIndex2</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    copy_nums = copy.deepcopy(nums)</span><br><span class="line">    copy_nums.sort()</span><br><span class="line">    min_num_index = [nums.index(one) <span class="keyword">for</span> one <span class="keyword">in</span> copy_nums[:k]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;min_num_index:&#x27;</span>, min_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMinNumIndex3</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    num_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        num_dict[i] = nums[i]</span><br><span class="line">    <span class="comment"># 先按x[1]值大小排序，值相同的按x[0]索引排序</span></span><br><span class="line">    sort_list = <span class="built_in">sorted</span>(num_dict.items(), key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], -x[<span class="number">0</span>]))</span><br><span class="line">    min_num_index = [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> sort_list[:k]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;min_num_index:&#x27;</span>, min_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMinNumIndex4</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    copy_list = copy.deepcopy(nums)</span><br><span class="line">    max_num = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    min_num_index = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        one_min_index = copy_list.index(<span class="built_in">min</span>(copy_list))</span><br><span class="line">        min_num_index.append(one_min_index)</span><br><span class="line">        copy_list[one_min_index] = max_num</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;min_num_index:&#x27;</span>, min_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListMinNumIndex5</span>(<span class="params">nums: <span class="built_in">list</span>, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">    nums = np.array(nums)</span><br><span class="line">    <span class="built_in">print</span>(nums.argsort())</span><br><span class="line">    <span class="comment"># argsort将nums从小到达排序，并提取在原数组中的索引</span></span><br><span class="line">    <span class="comment"># 排序前   [12, 3, 4, 18, 20, 1, 34, 2, 0]</span></span><br><span class="line">    <span class="comment"># 排序后   [0, 1, 2, 3, 4, 12, 18, 20, 34]</span></span><br><span class="line">    <span class="comment"># 提取索引后[8, 5, 7, 1, 2, 0, 3, 4, 6]</span></span><br><span class="line">    min_num_index = nums.argsort()[:k]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;min_num_index:&#x27;</span>, min_num_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">    k = <span class="number">3</span></span><br><span class="line">    getListMinNumIndex(nums, k)</span><br><span class="line">    getListMinNumIndex2(nums, k)</span><br><span class="line">    getListMinNumIndex3(nums, k)</span><br><span class="line">    getListMinNumIndex4(nums, k)</span><br><span class="line">    getListMinNumIndex5(nums, k)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础容器</title>
    <url>/2021/12/24/Python%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一、列表"><a href="#一、列表" class="headerlink" title="一、列表"></a>一、列表</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li><p>L.<strong>index</strong>(v)</p>
</li>
<li><p>L.index(v  , begin) </p>
</li>
<li><p>L.index(v  , begin, end) </p>
<p>返回对应元素的索引下标, begin为开始索引，end为结束索引,当 value 不存在时触发ValueError错误 </p>
</li>
</ul>
<ul>
<li><p>L.<strong>count</strong>(x)</p>
<p>用于统计某个元素在列表中出现的次数 </p>
</li>
</ul>
<ul>
<li><p>L.<strong>pop</strong>([index])</p>
<p>删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系</p>
</li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li><p>L.<strong>insert</strong>(index,  obj)</p>
<p>将某个元素插放到列表中指定的位置 </p>
</li>
<li><p>L.<strong>extend</strong>(lst)</p>
<p>向列表追加另一个列表</p>
</li>
<li><p>L.<strong>remove</strong>(x)</p>
<p> 从列表中删除第一次出现在列表中的值 x</p>
</li>
<li><p>L.<strong>clear</strong>()</p>
<p>清空列表,等同于 L[:] = [] </p>
</li>
<li><p>L.<strong>sort</strong>(reverse=False)</p>
<p>将列表中的元素进行排序，默认顺序按值的小到大的顺序排列 </p>
</li>
<li><p>L.<strong>reverse</strong>() </p>
</li>
<li><p>列表的反转，用来改变原列表的先后顺序 </p>
</li>
</ul>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><ul>
<li><p>L.<strong>copy</strong>()</p>
<p>复制此列表（只复制一层，不会复制深层对象) </p>
</li>
</ul>
<h2 id="获取前k大的索引"><a href="#获取前k大的索引" class="headerlink" title="获取前k大的索引"></a>获取前k大的索引</h2><ul>
<li><a href="/2022/03/11/%E8%8E%B7%E5%8F%96%E5%89%8Dk%E5%A4%A7%E7%9A%84%E7%B4%A2%E5%BC%95/" title="获取前k大的索引">获取前k大的索引</a></li>
</ul>
<h1 id="二、字典"><a href="#二、字典" class="headerlink" title="二、字典"></a>二、字典</h1><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><ul>
<li><strong>get</strong>(key,  default=None)<br>返回指定键的值，如果值不在字典中返回default值</li>
</ul>
<ul>
<li><strong>setdefault</strong>(key,  default=None)<br>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</li>
</ul>
<ul>
<li><strong>popitem</strong>()<br>随机返回并删除字典中的一对键和值(一般删除末尾对)。</li>
</ul>
<ul>
<li><strong>items</strong>()<br>以列表返回可遍历的(键, 值)  元组数组</li>
</ul>
<ul>
<li><strong>keys</strong>()<br>返回一个迭代器，可以使用 list() 来转换为列表</li>
</ul>
<ul>
<li><strong>values</strong>()<br>返回一个迭代器，可以使用 list() 来转换为列表</li>
</ul>
<h2 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h2><ul>
<li><strong>update</strong>(dict2)<br>字典记录累加，把字典参数 dict2 的 key/value(键/值) 对更新到字典 dict 里。</li>
</ul>
<ul>
<li><p><strong>clear</strong>()</p>
<p>删除字典内所有元素</p>
</li>
</ul>
<ul>
<li><p><strong>del</strong> dic[key]</p>
<p>删除字典内单个元素</p>
</li>
</ul>
<h2 id="获取最大值的索引"><a href="#获取最大值的索引" class="headerlink" title="获取最大值的索引"></a>获取最大值的索引</h2><ul>
<li><p>获取最大值/最小值的键</p>
<ul>
<li>max_key = max(my_dic, key=my_dic.get)</li>
<li>min_key = min(my_dic, key=my_dic.get)</li>
</ul>
</li>
<li><p>获取最大值/最小值及其键</p>
<ul>
<li>max_item = max(zip(my_dic.values(), my_dic,keys()))</li>
<li>min_item = min(zip(my_dic.values(), my_dic.keys()))</li>
<li>zip():将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。</li>
</ul>
</li>
</ul>
<h1 id="三、集合"><a href="#三、集合" class="headerlink" title="三、集合"></a>三、集合</h1><ul>
<li><p><strong>update</strong>() </p>
<p>给集合添加元素</p>
</li>
<li><p><strong>clear</strong>() </p>
<p>移除集合中的所有元素</p>
</li>
<li><p><strong>copy</strong>() </p>
<p>拷贝一个集合</p>
</li>
<li><p><strong>pop</strong>() </p>
<p>随机移除元素</p>
</li>
</ul>
<h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ul>
<li><p><strong>isspace</strong>()</p>
<p>如果字符串中只包含空白，则返回 True，否则返回  False.</p>
</li>
</ul>
<ul>
<li><p><strong>startswith</strong>(substr,  beg=0, end=len(string))</p>
<p>检查字符串是否是以指定子字符串  substr 开头，是则返回 True，否则返回 False。如果beg 和 end  指定值，则在指定范围内检查。</p>
</li>
</ul>
<ul>
<li><p><strong>endswith</strong>(suffix,  beg=0, end=len(string))</p>
<p>检查字符串是否以 obj 结束，如果beg 或者 end  指定则检查指定的范围内是否以 obj 结束，如果是，返回  True,否则返回 False.</p>
</li>
</ul>
<h2 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h2><ul>
<li><p><strong>find</strong>(str,  beg=0 end=len(string))</p>
<p>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</p>
</li>
<li><p><strong>rfind</strong>(str,  beg=0,end=len(string))</p>
<p>类似于 find()函数，不过是从右边开始查找.</p>
</li>
</ul>
<ul>
<li><p><strong>count</strong>(str,  beg= 0,end=len(string))</p>
<p>里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</p>
</li>
</ul>
<h2 id="修改-2"><a href="#修改-2" class="headerlink" title="修改"></a>修改</h2><ul>
<li><p><strong>replace</strong>(old,  new [, max])</p>
<p>把  将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。</p>
</li>
<li><p><strong>lstrip</strong>()</p>
<p>截掉字符串左边的空格或指定字符。</p>
</li>
</ul>
<ul>
<li><p><strong>rstrip</strong>()</p>
<p>删除字符串字符串末尾的空格.</p>
</li>
<li><p><strong>strip</strong>([chars])</p>
<p>在字符串上执行 lstrip()和  rstrip()</p>
</li>
</ul>
<ul>
<li><p><strong>lower</strong>()</p>
<p>转换字符串中所有大写字符为小写.</p>
</li>
</ul>
<ul>
<li><p><strong>upper</strong>()</p>
<p>转换字符串中的小写字母为大写</p>
</li>
</ul>
<ul>
<li><p><strong>swapcase</strong>()</p>
<p>将字符串中大写转换为小写，小写转换为大写</p>
</li>
</ul>
<h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><ul>
<li><p><strong>center</strong>(width,  fillchar)</p>
<p>返回一个指定的宽度 width 居中的字符串，fillchar  为填充的字符，默认为空格。</p>
</li>
</ul>
<ul>
<li><p><strong>zfill</strong> (width)</p>
<p>返回长度为 width 的字符串，原字符串右对齐，前面填充0</p>
</li>
<li><p><strong>ljust</strong>(width[,  fillchar])</p>
<p>返回一个原字符串左对齐,并使用 fillchar 填充至长度  width 的新字符串，fillchar 默认为空格。</p>
</li>
</ul>
<h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><ul>
<li><p>str.<strong>split</strong>(‘分割符’)</p>
<p>将str按指定的一个分隔符进行分割</p>
</li>
<li><p><strong>re.split</strong>(‘分割符1|分割符2|…’, str)    或    <strong>re.split</strong>(r’[分割符1, 分割符2, …]’, str) </p>
<p>​    将str按指定的一些分隔符进行分割，不保留分隔符</p>
</li>
<li><p><strong>re.split</strong>(‘(分割符1|分割符2|…)’, str)    或    <strong>re.split</strong>(r’([分割符1, 分割符2, …])’, str) </p>
<p>​    将str按指定的一些分隔符进行分割，保留分隔符</p>
</li>
</ul>
]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab学习笔记</title>
    <url>/2022/04/15/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一、命名规则"><a href="#一、命名规则" class="headerlink" title="一、命名规则"></a>一、命名规则</h2><ul>
<li>变量名区分大小写</li>
<li>变量名长度不超过63位 (MATLAB R2012a 32bit和64bit计算机上测试结果)</li>
<li>变量名以字母开头，可以由字母、数字和下划线组成,但不能使用标点</li>
<li>变量名应简洁明了，通过变量名可以直观看出变量所表示的物理意义</li>
</ul>
<ul>
<li>clear all：除Workspace中所有的变量</li>
<li>clc ：清除Command Window中的所有命令</li>
<li>注释：%%或%</li>
</ul>
<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><h3 id="1-数字"><a href="#1-数字" class="headerlink" title="1. 数字"></a>1. 数字</h3><ul>
<li>rand：生成均匀分布的伪随机数，分布在（0~1）之间<ul>
<li>rand(m, n)：生成m行n列的均匀分布的伪随机数</li>
<li>rand(m, n, ‘double’)：生成指定精度的均匀分布的伪随机数，参数还可以是’single’</li>
<li>rand(RandStream, m, n)利用指定的RandStream（随机种子）生成为随机数</li>
</ul>
</li>
<li>randn：生成标准正态分布的伪随机数（均值为0，方差为1，语法同上）</li>
<li>randi：生成均匀分布的伪随机数<ul>
<li>randi(iMax)：在开区间(0，iMax)生成均匀分布的为随机整数</li>
<li>randi(iMax)：在开区间(0, iMax)生成m*n型随机矩阵</li>
<li>randi([iMin, iMax], m, n)：在开区间(iMin, iMax)生成m*n型随机矩阵</li>
</ul>
</li>
</ul>
<h3 id="2-字符与字符串"><a href="#2-字符与字符串" class="headerlink" title="2. 字符与字符串"></a>2. 字符与字符串</h3><h3 id="3-矩阵"><a href="#3-矩阵" class="headerlink" title="3. 矩阵"></a>3. 矩阵</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]	<span class="comment">% 定义矩阵</span></span><br><span class="line">B = A&#x27;		<span class="comment">% 求矩阵的转置</span></span><br><span class="line">C = A(:)	<span class="comment">% 矩阵向量化（竖直方向）</span></span><br><span class="line">D = inv(A)	<span class="comment">% 求矩阵的逆矩阵</span></span><br><span class="line"></span><br><span class="line">E = <span class="built_in">zeros</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">3</span>)	<span class="comment">% 创建10行5列全是0的3维矩阵</span></span><br><span class="line">E(:, :, <span class="number">1</span>) = <span class="built_in">rand</span>(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">E(:, :, <span class="number">2</span>) = randi([<span class="number">3</span>, <span class="number">8</span>], <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">E(:, :, <span class="number">3</span>) = <span class="built_in">randn</span>(<span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<h3 id="4-元胞数组ceil"><a href="#4-元胞数组ceil" class="headerlink" title="4. 元胞数组ceil"></a>4. 元胞数组ceil</h3><ul>
<li>元胞数组是MATLAB中特有的一种数据类型，是数组的一种，其内部元素可以是属于不同的数据类型，概念理解上，可以认为它和c语言里面的结构体、C++里面的对象很类似。元胞数组是matlab中的特色数据类型，它不同于其它数据类型(如字符型，字符数组或者叫字符串，以及一般的算术数据和数组)。它特有的存取数据方法决定了它的特点，它有给人一种查询信息的感觉，可以逐渐追踪一直到所有的变量全部翻译成基本的数据信息。它的class函数输出就是cell(细胞之意)。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">ceil</span>(<span class="number">1</span>, <span class="number">6</span>)	<span class="comment">% 生成一个1行5列的元胞数组</span></span><br><span class="line">A[<span class="number">2</span>] = <span class="built_in">eye</span>(<span class="number">3</span>)	<span class="comment">% 将一个3*3的单位矩阵赋值给元胞数组第2个盒子（注意：索引从1开始）</span></span><br><span class="line">A[<span class="number">5</span>] = <span class="built_in">magic</span>(<span class="number">5</span>)	<span class="comment">% 将一个5*5幻方矩阵赋值给元胞数组第5个盒子</span></span><br><span class="line">B = A[<span class="number">2</span>]		<span class="comment">% 将元胞数组第5个盒子取出</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="5-结构体struct"><a href="#5-结构体struct" class="headerlink" title="5. 结构体struct"></a>5. 结构体struct</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">books = struct(<span class="string">&#x27;name&#x27;</span>, &#123;&#123;<span class="string">&#x27;Math&#x27;</span>, <span class="string">&#x27;English&#x27;</span>&#125;&#125;, <span class="string">&#x27;price&#x27;</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line">books.name	<span class="comment">% 属性</span></span><br><span class="line">books.name(<span class="number">1</span>)	<span class="comment">% 取出的是ceil</span></span><br><span class="line">books.name&#123;<span class="number">1</span>&#125;	<span class="comment">% 取出的是字符串</span></span><br></pre></td></tr></table></figure>



<h2 id="三、矩阵操作"><a href="#三、矩阵操作" class="headerlink" title="三、矩阵操作"></a>三、矩阵操作</h2><h3 id="1-矩阵定义与构造"><a href="#1-矩阵定义与构造" class="headerlink" title="1. 矩阵定义与构造"></a>1. 矩阵定义与构造</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">B = <span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>			<span class="comment">% 生成从1到9步长为2的一行多列矩阵</span></span><br><span class="line">C = <span class="built_in">repmat</span>(B, <span class="number">3</span>, <span class="number">2</span>)	<span class="comment">% 将矩阵B按照3行2列复制生成矩阵</span></span><br><span class="line">D = <span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">4</span>)		<span class="comment">% 创建2行4列全是1的矩阵</span></span><br><span class="line">E = <span class="built_in">zeros</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">3</span>)	<span class="comment">% 创建10行5列全是0的3维矩阵</span></span><br></pre></td></tr></table></figure>



<h3 id="2-矩阵的四则运算"><a href="#2-矩阵的四则运算" class="headerlink" title="2. 矩阵的四则运算"></a>2. 矩阵的四则运算</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">C = A + B</span><br><span class="line">D = A - B</span><br><span class="line">E = A * B</span><br><span class="line">F = A .* B	<span class="comment">% 对应项相乘</span></span><br><span class="line">G = A / B	<span class="comment">% 等价于A*inv(B)</span></span><br><span class="line">H = A ./ B	<span class="comment">% 对应项相除</span></span><br></pre></td></tr></table></figure>



<h3 id="3-矩阵下标"><a href="#3-矩阵下标" class="headerlink" title="3. 矩阵下标"></a>3. 矩阵下标</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">B = A(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">C = A(<span class="number">2</span>, :)</span><br><span class="line">D = A(:, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">[m, n] = <span class="built_in">find</span>(A &gt; <span class="number">20</span>)	<span class="comment">% 找到A中值大于20的索引值，m表示行索引，n表示列索引</span></span><br></pre></td></tr></table></figure>



<h2 id="四、程序结构"><a href="#四、程序结构" class="headerlink" title="四、程序结构"></a>四、程序结构</h2><h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1. for循环"></a>1. for循环</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量 = 初值:步长:中值			<span class="comment">% 步长默认值为1</span></span><br><span class="line">	执行语句<span class="number">1</span></span><br><span class="line">	、、、</span><br><span class="line">	执行语句n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2. while循环"></a>2. while循环</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式</span><br><span class="line">	执行语句<span class="number">1</span></span><br><span class="line">	、、、</span><br><span class="line">	执行语句<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="3-if分支结构"><a href="#3-if分支结构" class="headerlink" title="3. if分支结构"></a>3. if分支结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 条件表达式</span><br><span class="line">	语句体</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if 条件表达式</span><br><span class="line">	语句体1</span><br><span class="line">else</span><br><span class="line">	语句体2</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="五、基本绘图操作"><a href="#五、基本绘图操作" class="headerlink" title="五、基本绘图操作"></a>五、基本绘图操作</h2><h3 id="1-二维平面绘图"><a href="#1-二维平面绘图" class="headerlink" title="1. 二维平面绘图"></a>1. 二维平面绘图</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">figure</span>  <span class="comment">% 建立一个幕布</span></span><br><span class="line"><span class="built_in">plot</span>(x,y)   <span class="comment">% 绘图</span></span><br><span class="line">title(<span class="string">&#x27;y=sin(x)&#x27;</span>)   <span class="comment">% 标题</span></span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>) <span class="comment">% x轴标签</span></span><br><span class="line">ylabel(<span class="string">&#x27;sin(x)&#x27;</span>)    <span class="comment">% y轴标签</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">2</span>*<span class="built_in">pi</span>])  <span class="comment">% x轴取值范围</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1650249994373.png" alt="1650249994373"></p>
<h3 id="2-绘制双Y曲线"><a href="#2-绘制双Y曲线" class="headerlink" title="2. 绘制双Y曲线"></a>2. 绘制双Y曲线</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 绘制双y曲线</span></span><br><span class="line">x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span>;</span><br><span class="line">y1 = <span class="number">200</span>*<span class="built_in">exp</span>(<span class="number">-0.05</span>*x).*<span class="built_in">sin</span>(x);   <span class="comment">% *是矩阵相乘，.*是矩阵对应项相乘</span></span><br><span class="line">y2 = <span class="number">0.8</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">10</span>*x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">title(<span class="string">&#x27;Mutiple Decay Rates&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time (\musec)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">yyaxis left</span><br><span class="line"><span class="built_in">plot</span>(x,y1)</span><br><span class="line">ylabel(<span class="string">&#x27;Slow Decay&#x27;</span>)</span><br><span class="line"></span><br><span class="line">yyaxis right</span><br><span class="line"><span class="built_in">plot</span>(x,y2)</span><br><span class="line">ylabel(<span class="string">&#x27;Fast Decay&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1650250039875.png" alt="1650250039875"></p>
<h3 id="3-三维绘图"><a href="#3-三维绘图" class="headerlink" title="3. 三维绘图"></a>3. 三维绘图</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">10</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="built_in">plot3</span>(<span class="built_in">sin</span>(t),<span class="built_in">cos</span>(t),t)</span><br><span class="line">xlabel(<span class="string">&#x27;sin(t)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;cos(t)&#x27;</span>)</span><br><span class="line">zlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">grid on     <span class="comment">% 打开网格</span></span><br><span class="line">axis square</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1650250188559.png" alt="1650250188559"></p>
<h3 id="4-双峰函数"><a href="#4-双峰函数" class="headerlink" title="4. 双峰函数"></a>4. 双峰函数</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[x,y,z] = peaks(<span class="number">30</span>);</span><br><span class="line">mesh(x,y,z)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1650250259611.png" alt="1650250259611"></p>
]]></content>
      <categories>
        <category>《Matlab》</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记</title>
    <url>/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-Python简介"><a href="#1-Python简介" class="headerlink" title="1. Python简介"></a>1. Python简介</h2><h3 id="1-1-Python-定义"><a href="#1-1-Python-定义" class="headerlink" title="1.1 Python 定义"></a>1.1 Python 定义</h3><p>是一个免费、开源、跨平台、动态、面向对象的编程语言。</p>
<h3 id="1-2-Python程序的执行方式"><a href="#1-2-Python程序的执行方式" class="headerlink" title="1.2 Python程序的执行方式"></a>1.2 Python程序的执行方式</h3><h4 id="（1）交互式"><a href="#（1）交互式" class="headerlink" title="（1）交互式"></a>（1）交互式</h4><p>在命令行输入指令，回车即可得到结果。</p>
<p>(1) 打开终端</p>
<p>(2) 进入交互式：python3</p>
<p>(3) 编写代码：print(“hello world”) </p>
<p>(4) 离开交互式：exit()</p>
<h4 id="（2）文件式"><a href="#（2）文件式" class="headerlink" title="（2）文件式"></a>（2）文件式</h4><p>将指令编写到.py文件，可以重复运行程序。</p>
<p>(1)  编写文件</p>
<p>(2)  打开终端</p>
<p>(3)   进入程序所在目录：cd 目录</p>
<p>(4)  执行程序： python3 文件名</p>
<h3 id="1-3-执行过程"><a href="#1-3-执行过程" class="headerlink" title="1.3 执行过程"></a>1.3 执行过程</h3><p>计算机只能识别机器码(1010)，不能识别源代码(python)。由源代码转变成机器码的过程分成两类：编译和解释。</p>
<h4 id="（1）编译"><a href="#（1）编译" class="headerlink" title="（1）编译"></a>（1）编译</h4><p>在程序运行之前，通过编译器将源代码变成机器码，例如：C语言。</p>
<ul>
<li>优点：运行速度快</li>
</ul>
<ul>
<li>缺点：开发效率低，不能跨平台。</li>
</ul>
<h4 id="（2）解释"><a href="#（2）解释" class="headerlink" title="（2）解释"></a>（2）解释</h4><p>在程序运行之时，通过解释器对程序逐行翻译，然后执行，例如Javascript。</p>
<ul>
<li>优点：开发效率高，可以跨平台；</li>
</ul>
<ul>
<li>缺点：运行速度慢。</li>
</ul>
<h4 id="（3）Python是解释型语言"><a href="#（3）Python是解释型语言" class="headerlink" title="（3）Python是解释型语言"></a>（3）Python是解释型语言</h4><p>Python是解释型语言，但为了提高运行速度，使用了一种编译的方法。编译之后得到pyc文件，存储了字节码（特定于Python的表现形式，不是机器码）。</p>
<p>源代码 – 编译 –&gt; 字节码 – 解释 –&gt; 机器码</p>
<h3 id="1-4-解释器类型"><a href="#1-4-解释器类型" class="headerlink" title="1.4 解释器类型"></a>1.4 解释器类型</h3><p>(1) CPython（C语言开发)</p>
<p>(2)  Jython (java开发)</p>
<p>(3) IronPython (.net开发)</p>
<h2 id="2-数据基本运算"><a href="#2-数据基本运算" class="headerlink" title="2. 数据基本运算"></a>2. 数据基本运算</h2><h3 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h3><h4 id="（1）-pycharm常用快捷键"><a href="#（1）-pycharm常用快捷键" class="headerlink" title="（1） pycharm常用快捷键"></a>（1） pycharm常用快捷键</h4><ul>
<li><p>移动到本行开头：home键</p>
</li>
<li><p>移动到本行末尾：end键盘</p>
</li>
<li><p> 注释代码：ctrl + /</p>
</li>
</ul>
<ul>
<li> 复制行：<font color="red">ctrl +d</font></li>
</ul>
<ul>
<li>删除行：<font color="red">shift + delete</font></li>
</ul>
<ul>
<li> 选择列：shift + alt +鼠标左键</li>
</ul>
<ul>
<li>移动行：ctrl  + shift + 上下箭头</li>
</ul>
<ul>
<li>代码格式化：<font color="red"> ctrl+alt+l </font></li>
<li>查看函数参数：<font color="red">ctrl+P</font></li>
<li>重构成员：shift+F6</li>
</ul>
<h4 id="（2）注释"><a href="#（2）注释" class="headerlink" title="（2）注释"></a>（2）注释</h4><p>​    给人看的，通常是对代码的描述信息。</p>
<ul>
<li>单行注释：以#号开头。</li>
</ul>
<ul>
<li>多行注释：三引号开头，三引号结尾。</li>
</ul>
<h3 id="2-2-数据"><a href="#2-2-数据" class="headerlink" title="2.2 数据"></a>2.2 数据</h3><ul>
<li><p>整形int</p>
</li>
<li><p>浮点型float </p>
</li>
<li><p>字符串str</p>
</li>
<li><p>布尔bool</p>
</li>
</ul>
<h3 id="2-3-运算"><a href="#2-3-运算" class="headerlink" title="2.3 运算"></a>2.3 运算</h3><h4 id="（1）-类型转换"><a href="#（1）-类型转换" class="headerlink" title="（1） 类型转换"></a>（1） 类型转换</h4><ul>
<li>转换为整形: int(数据)</li>
</ul>
<ul>
<li>转换为浮点型:float(数据)</li>
</ul>
<ul>
<li>转换为字符串:str(数据)</li>
</ul>
<ul>
<li>转换为布尔:bool(数据)</li>
</ul>
<h4 id="（2）运算符"><a href="#（2）运算符" class="headerlink" title="（2）运算符"></a>（2）运算符</h4><h5 id="（1）算术运算符"><a href="#（1）算术运算符" class="headerlink" title="（1）算术运算符"></a>（1）算术运算符</h5><ul>
<li>+   加法</li>
</ul>
<ul>
<li>-   减法</li>
</ul>
<ul>
<li>*   乘法</li>
</ul>
<ul>
<li>/   除法：结果为浮点数</li>
</ul>
<ul>
<li>//  整除：除的结果去掉小数部分</li>
</ul>
<ul>
<li>%  求余</li>
</ul>
<ul>
<li>**  幂运算</li>
</ul>
<h5 id="（2）-增强运算符"><a href="#（2）-增强运算符" class="headerlink" title="（2） 增强运算符"></a>（2） 增强运算符</h5><ul>
<li>y += x     相当于 y = y + x</li>
</ul>
<ul>
<li>y -= x      相当于 y = y - x</li>
</ul>
<ul>
<li>y *= x      相当于 y = y * x</li>
</ul>
<ul>
<li>y /= x      相当于 y = y / x</li>
</ul>
<ul>
<li>y //= x     相当于 y = y // x</li>
</ul>
<ul>
<li>y %= x     相当于 y = y % x</li>
</ul>
<ul>
<li>y **= x     相当于 y = y ** x</li>
</ul>
<h5 id="（3）-比较运算符"><a href="#（3）-比较运算符" class="headerlink" title="（3） 比较运算符"></a>（3） 比较运算符</h5><ul>
<li> &lt;     小于</li>
</ul>
<ul>
<li> &lt;=    小于等于</li>
</ul>
<ul>
<li><p>&gt;     大于</p>
</li>
<li><p> &gt;=    大于等于</p>
</li>
</ul>
<ul>
<li> ==    等于</li>
</ul>
<ul>
<li> !=     不等于</li>
</ul>
<h5 id="（4）-逻辑运算符"><a href="#（4）-逻辑运算符" class="headerlink" title="（4） 逻辑运算符"></a>（4） 逻辑运算符</h5><ul>
<li>与and     </li>
</ul>
<ul>
<li>或or</li>
</ul>
<ul>
<li>非 not </li>
</ul>
<h5 id="（5）身份运算符"><a href="#（5）身份运算符" class="headerlink" title="（5）身份运算符"></a>（5）身份运算符</h5><ul>
<li><p>语法:</p>
<p>x is y</p>
<p>x is not y</p>
</li>
<li><p>作用：</p>
<p>is 用于判断两个对象是否是同一个对象,是时返回True,否则返回False。</p>
</li>
</ul>
<h5 id="（6）优先级"><a href="#（6）优先级" class="headerlink" title="（6）优先级"></a>（6）优先级</h5><p>​    高到低：</p>
<p>​        算数运算符</p>
<p>​        比较运算符</p>
<p>​        增强运算符</p>
<p>​        身份运算符</p>
<p>​        逻辑运算符</p>
<h2 id="3-语句"><a href="#3-语句" class="headerlink" title="3. 语句"></a>3. 语句</h2><h3 id="3-1-条件语句"><a href="#3-1-条件语句" class="headerlink" title="3.1 条件语句"></a>3.1 条件语句</h3><h4 id="（1）if-elif-语句"><a href="#（1）if-elif-语句" class="headerlink" title="（1）if elif 语句"></a>（1）if elif 语句</h4><ul>
<li> 作用:</li>
</ul>
<p>  让程序根据条件选择性的执行语句。</p>
<ul>
<li>语法:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">   语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">   语句块<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   语句块<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）真值表达式"><a href="#（2）真值表达式" class="headerlink" title="（2）真值表达式"></a>（2）真值表达式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">100</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;真值&quot;</span>)</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">bool</span>(<span class="number">100</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;真值&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="（3）条件表达式"><a href="#（3）条件表达式" class="headerlink" title="（3）条件表达式"></a>（3）条件表达式</h4><ul>
<li>  语法：变量 = 结果1 if 条件 else 结果2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">input</span>(<span class="string">&quot;请输入性别:&quot;</span>) == <span class="string">&quot;男&quot;</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li> 作用：根据条件(True/False) 来决定返回结果1还是结果2。</li>
</ul>
<h3 id="3-2-循环语句"><a href="#3-2-循环语句" class="headerlink" title="3.2 循环语句"></a>3.2 循环语句</h3><h4 id="（1）while语句"><a href="#（1）while语句" class="headerlink" title="（1）while语句"></a>（1）while语句</h4><h4 id="（2）for-语句"><a href="#（2）for-语句" class="headerlink" title="（2）for 语句"></a>（2）for 语句</h4><ul>
<li>作用:用来遍历可迭代对象的数据元素。可迭代对象是指能依次获取数据元素的对象，例如：容器类型。</li>
</ul>
<ul>
<li> 语法:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量列表 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">    <span class="comment"># 语句块</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）range-函数"><a href="#（3）range-函数" class="headerlink" title="（3）range 函数"></a>（3）range 函数</h4><ul>
<li>作用:</li>
</ul>
<p>​      用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器)。</p>
<ul>
<li>语法:</li>
</ul>
<p>​       <font color="red">range(开始点，结束点，间隔)</font></p>
<ul>
<li><p>说明:</p>
<p>函数返回的可迭代对象可以用for取出其中的元素</p>
<p>返回的数字不包含结束点</p>
<p>开始点默认为0</p>
<p>间隔默认值为1 </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写法1:range(开始,结束,间隔)</span></span><br><span class="line"><span class="comment"># 注意:不包含结束值</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法2:range(开始,结束)</span></span><br><span class="line"><span class="comment"># 注意:间隔默认为1</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):	</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法3:range(结束)</span></span><br><span class="line"><span class="comment"># 注意:开始默认为0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>



<h3 id="3-3-跳转语句"><a href="#3-3-跳转语句" class="headerlink" title="3.3 跳转语句"></a>3.3 跳转语句</h3><h4 id="（1）break-语句"><a href="#（1）break-语句" class="headerlink" title="（1）break 语句"></a>（1）break 语句</h4><p>​    跳出循环体，后面的代码不再执行。</p>
<h4 id="（2）continue-语句"><a href="#（2）continue-语句" class="headerlink" title="（2）continue 语句"></a>（2）continue 语句</h4><p>​    跳过本次，继续下次循环。</p>
<h2 id="4-Python基础容器"><a href="#4-Python基础容器" class="headerlink" title="4. Python基础容器"></a>4. Python基础容器</h2><a href="/2021/12/24/Python%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8/" title="Python基础容器">Python基础容器</a>



<h2 id="5-函数-function"><a href="#5-函数-function" class="headerlink" title="5. 函数 function"></a>5. 函数 function</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><ul>
<li>用于封装一个特定的功能，表示一个功能或者行为。</li>
<li> 函数是可以重复执行的语句块, 可以重复调用。</li>
<li>提高代码的可重用性和可维护性（代码层次结构更清晰）。</li>
</ul>
<h3 id="5-2-基础语法"><a href="#5-2-基础语法" class="headerlink" title="5.2 基础语法"></a>5.2 基础语法</h3><h4 id="（1）定义函数"><a href="#（1）定义函数" class="headerlink" title="（1）定义函数"></a>（1）定义函数</h4><ul>
<li><p>语法：</p>
<p>def 函数名(形式参数):</p>
<pre><code>   函数体
</code></pre>
</li>
<li><p> 说明：</p>
</li>
</ul>
<p>  def 关键字：全称是define，意为”定义”。</p>
<p>  函数名：对函数体中语句的描述，规则与变量名相同。</p>
<p>  形式参数：函数定义者要求调用者提供的信息。</p>
<p>  函数体：完成该功能的语句。</p>
<ul>
<li>函数的第一行语句建议使用文档字符串描述函数的功能与参数。</li>
</ul>
<h4 id="（2）调用函数"><a href="#（2）调用函数" class="headerlink" title="（2）调用函数"></a>（2）调用函数</h4><ul>
<li>语法：函数名(实际参数) </li>
</ul>
<ul>
<li>说明：根据形参传递内容。</li>
</ul>
<h4 id="（3）返回值"><a href="#（3）返回值" class="headerlink" title="（3）返回值"></a>（3）返回值</h4><ul>
<li><p>定义：</p>
<p>函数定义者告诉调用者的结果。</p>
</li>
<li><p>语法：</p>
<p>return 数据 </p>
</li>
<li><p>说明：</p>
<p>return后没有语句，相当于返回 None。</p>
<p>函数体没有return，相当于返回None。</p>
</li>
</ul>
<h3 id="5-3-可变／不可变类型"><a href="#5-3-可变／不可变类型" class="headerlink" title="5.3 可变／不可变类型"></a>5.3 可变／不可变类型</h3><h4 id="1-不可变类型参数"><a href="#1-不可变类型参数" class="headerlink" title="(1) 不可变类型参数:"></a>(1) 不可变类型参数:</h4><ul>
<li>数值型(整数，浮点数)</li>
</ul>
<ul>
<li>布尔值bool</li>
</ul>
<ul>
<li>None 空值</li>
</ul>
<ul>
<li>字符串str</li>
</ul>
<ul>
<li>元组tuple</li>
</ul>
<h4 id="2-可变类型参数"><a href="#2-可变类型参数" class="headerlink" title="(2) 可变类型参数:"></a>(2) 可变类型参数:</h4><ul>
<li>列表 list</li>
</ul>
<ul>
<li>字典 dict</li>
</ul>
<ul>
<li>集合 set</li>
</ul>
<h4 id="3-传参说明："><a href="#3-传参说明：" class="headerlink" title="(3) 传参说明："></a>(3) 传参说明：</h4><ul>
<li>不可变类型的数据传参时，函数内部不会改变原数据的值。</li>
</ul>
<ul>
<li>可变类型的数据传参时，函数内部可以改变原数据。 </li>
</ul>
<h3 id="5-4-函数参数"><a href="#5-4-函数参数" class="headerlink" title="5.4 函数参数"></a>5.4 函数参数</h3><h4 id="（1）实参传递方式"><a href="#（1）实参传递方式" class="headerlink" title="（1）实参传递方式"></a>（1）实参传递方式</h4><h5 id="①位置传参"><a href="#①位置传参" class="headerlink" title="①位置传参"></a>①<strong>位置传参</strong></h5><p>​    定义：实参与形参的位置依次对应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun01</span>(<span class="params">p1, p2, p3</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1)</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br><span class="line">    <span class="built_in">print</span>(p3)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 位置实参:根据顺序与形参进行对应</span></span><br><span class="line">fun01(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h5 id="②序列传参"><a href="#②序列传参" class="headerlink" title="②序列传参"></a>②<font color="red"><strong>序列传参</strong></font></h5><p>​    定义：<font color="red">实参用*将序列拆解后与形参的位置依次对应。</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">p1, p2, p3</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1, p2, p3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列实参:拆,按照顺序与形参对应</span></span><br><span class="line">list01 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">name = <span class="string">&quot;孙悟空&quot;</span></span><br><span class="line">tuple01 = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># func01(list01)</span></span><br><span class="line">func01(*list01)  <span class="comment"># 拆  1, 2, 3</span></span><br><span class="line">func01(*name)  <span class="comment"># 拆  孙 悟 空</span></span><br><span class="line">func01(*tuple01)  <span class="comment"># 拆  4, 5, 6</span></span><br></pre></td></tr></table></figure>

<h5 id="③关键字传参"><a href="#③关键字传参" class="headerlink" title="③关键字传参"></a>③<font color="red"><strong>关键字传参</strong></font></h5><p>​    定义：实参根据形参的名字进行对应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun01</span>(<span class="params">p1, p2, p3</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1)</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br><span class="line">    <span class="built_in">print</span>(p3)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 关键字实参:根据名字与形参进行对应</span></span><br><span class="line">fun01(p1=<span class="number">1</span>, p2=<span class="number">2</span>, p3=<span class="number">3</span>)</span><br><span class="line">fun01(p2=<span class="number">2</span>, p1=<span class="number">1</span>, p3=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h5 id="④字典关键字传参"><a href="#④字典关键字传参" class="headerlink" title="④字典关键字传参"></a>④<font color="red"><strong>字典关键字传参</strong></font></h5><p>​    定义：实参用**将字典拆解后与形参的名字进行对应。</p>
<p>​    作用：配合形参的缺省参数，可以使调用者随意传参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">p1, p2, p3</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1, p2, p3)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 字典实参:拆,按照名称与形参对应</span></span><br><span class="line">dict01 = &#123;<span class="string">&quot;p2&quot;</span>:<span class="string">&quot;B&quot;</span>,<span class="string">&quot;p1&quot;</span>:<span class="string">&quot;A&quot;</span>,<span class="string">&quot;p3&quot;</span>:<span class="string">&quot;C&quot;</span>&#125;</span><br><span class="line">func01(**dict01)</span><br></pre></td></tr></table></figure>



<h4 id="（2）形参定义方式"><a href="#（2）形参定义方式" class="headerlink" title="（2）形参定义方式"></a>（2）形参定义方式</h4><h5 id="①缺省形参"><a href="#①缺省形参" class="headerlink" title="①缺省形参"></a>①<strong>缺省形参</strong></h5><ul>
<li><p>语法：</p>
<p>def 函数名(形参名1=默认实参1, 形参名2=默认实参2, …):</p>
<p>​       函数体</p>
</li>
<li><p>说明：</p>
<p>缺省参数必须<font color="red">自右至左依次存在</font>，如果一个参数有缺省参数，则其右侧的所有参数都必须有缺省参数。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">p1=<span class="number">0</span>, p2=<span class="string">&quot;&quot;</span>, p3=<span class="number">100</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1)</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br><span class="line">    <span class="built_in">print</span>(p3) </span><br><span class="line">    </span><br><span class="line">func01(p2=<span class="number">2</span>)</span><br><span class="line">func01(p2=<span class="number">2</span>,p3=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 支持同时使用位置实参与关键字实参</span></span><br><span class="line">func01(<span class="number">1</span>,p3=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 注意1:先位置实参,后关键字实参</span></span><br><span class="line"><span class="comment"># func01(p1=1,2,3) # 错误</span></span><br></pre></td></tr></table></figure>

<h5 id="②位置形参"><a href="#②位置形参" class="headerlink" title="②位置形参"></a>②<strong>位置形参</strong></h5><ul>
<li><p>语法：</p>
<p>​    def 函数名(形参名1, 形参名2, …):</p>
<p>​           函数体</p>
</li>
</ul>
<h5 id="③命名关键字形参"><a href="#③命名关键字形参" class="headerlink" title="③命名关键字形参"></a>③<font color="red"><strong>命名关键字形参</strong></font></h5><ul>
<li><p>语法：</p>
<p>def 函数名(*args, 命名关键字形参1, 命名关键字形参2, …):</p>
<pre><code>   函数体
</code></pre>
<p>def 函数名(*, 命名关键字形参1, 命名关键字形参2, …):</p>
<p>​      函数体</p>
</li>
<li><p>作用：</p>
<p><font color="orange">强制实参使用关键字传参</font> </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命名关键字形参:</span></span><br><span class="line"><span class="comment"># 星号元组形参后面的位置形参</span></span><br><span class="line"><span class="comment"># 限制实参必须是关键字实参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">*args, p1, p2</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(p1)</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func01(p1=<span class="number">1</span>, p2=<span class="number">2</span>)</span><br><span class="line">func01(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, p1=<span class="number">1</span>, p2=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func02</span>(<span class="params">p1, *, p2=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(p1)</span><br><span class="line">    <span class="built_in">print</span>(p2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通常星号后面的命名关键字形参属于辅助参数,可选.</span></span><br><span class="line">func02(<span class="number">1</span>)</span><br><span class="line">func02(<span class="number">1</span>, p2=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h5 id="④星号元组形参"><a href="#④星号元组形参" class="headerlink" title="④星号元组形参"></a>④<font color="red">星号元组形参</font></h5><ul>
<li><p>语法：</p>
<p>def 函数名(*元组形参名):</p>
<p>​     函数体</p>
</li>
<li><p>作用：</p>
<p><font color="orange">可以将多个位置实参合并为一个元组</font></p>
</li>
<li><p>说明：</p>
<p>一般命名为’<font color="orange">args</font>，形参列表中最多只能有一个</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 位置实参数量可以无限</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">func01()  <span class="comment"># 空元组</span></span><br><span class="line">func01(<span class="number">1</span>, <span class="number">2</span>, <span class="number">34</span>)  <span class="comment"># (1, 2, 34)</span></span><br><span class="line"><span class="comment"># 不支持关键字实参</span></span><br><span class="line"><span class="comment"># func01(args=1,a=1)</span></span><br></pre></td></tr></table></figure>

<h5 id="⑤双星号字典形参"><a href="#⑤双星号字典形参" class="headerlink" title="⑤双星号字典形参"></a>⑤<font color="red"><strong>双星号字典形参</strong></font></h5><ul>
<li><p>语法：</p>
<p>def 函数名(**字典形参名):</p>
<p>​       函数体</p>
</li>
<li><p>作用：</p>
<p><font color="orange">可以将多个关键字实参合并为一个字典</font></p>
</li>
<li><p>说明:</p>
<p>一般命名为<font color="orange">‘kwargs</font></p>
<p>形参列表中最多只能有一个</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关键字实参数量无限</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(kwargs) <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line">func01(a=<span class="number">1</span>,b=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># func01(1,2,3) # 报错</span></span><br></pre></td></tr></table></figure>

<h5 id="⑥参数自左至右的顺序"><a href="#⑥参数自左至右的顺序" class="headerlink" title="⑥参数自左至右的顺序"></a>⑥参数自左至右的顺序</h5><p>位置形参 –&gt; 星号元组形参 –&gt; 命名关键字形参 –&gt; 双星号字典形参</p>
<p>练习：说出程序执行结果.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">list_target</span>):</span></span><br><span class="line">  <span class="built_in">print</span>(list_target)<span class="comment"># ?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func02</span>(<span class="params">*args</span>):</span></span><br><span class="line">  <span class="built_in">print</span>(args)<span class="comment"># ?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func03</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">  <span class="built_in">print</span>(args)<span class="comment"># ?</span></span><br><span class="line">  <span class="built_in">print</span>(kwargs)<span class="comment"># ?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func04</span>(<span class="params">p1,p2,*,p4,**kwargs</span>):</span></span><br><span class="line">  <span class="built_in">print</span>(p1)<span class="comment"># ?</span></span><br><span class="line">  <span class="built_in">print</span>(p2)<span class="comment"># ?</span></span><br><span class="line">  <span class="built_in">print</span>(p4)<span class="comment"># ?</span></span><br><span class="line">  <span class="built_in">print</span>(kwargs)<span class="comment"># ?</span></span><br><span class="line"></span><br><span class="line">func01([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">func02(*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">func03(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,a=<span class="number">4</span>,b=<span class="number">5</span>,c=<span class="number">6</span>) </span><br><span class="line">func04(<span class="number">10</span>,<span class="number">20</span>,p4=<span class="number">30</span>,p5=<span class="number">40</span>)</span><br></pre></td></tr></table></figure>



<h2 id="6-作用域"><a href="#6-作用域" class="headerlink" title="6. 作用域"></a>6. 作用域</h2><h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><p>变量起作用的范围。</p>
<h3 id="6-2-分类"><a href="#6-2-分类" class="headerlink" title="6.2 分类"></a>6.2 分类</h3><p>(1)  Local 局部作用域：函数内部。</p>
<p>(2)  Enclosing  外部嵌套作用域 ：函数嵌套。</p>
<p>(3)  Global 全局作用域：模块(.py文件)内部。 </p>
<p>(4)  Builtin 内置模块作用域：builtins.py文件。</p>
<h3 id="6-3-变量名的查找规则"><a href="#6-3-变量名的查找规则" class="headerlink" title="6.3 变量名的查找规则"></a>6.3 变量名的查找规则</h3><p>(1) 由内到外：L -&gt; E -&gt; G -&gt; B</p>
<p>(2) 在访问变量时，先查找本地变量，然后是包裹此函数外部的函数内部的变量，之后是全局变量，最后是内置变量。</p>
<h3 id="6-4-局部变量"><a href="#6-4-局部变量" class="headerlink" title="6.4 局部变量"></a>6.4 局部变量</h3><p>(1) 定义在函数内部的变量(形参也是局部变量)</p>
<p>(2) 只能在函数内部使用</p>
<p>(3) 调用函数时才被创建，函数结束后自动销毁</p>
<h3 id="6-5-全局变量"><a href="#6-5-全局变量" class="headerlink" title="6.5 全局变量"></a>6.5 全局变量</h3><p>(1) 定义在函数外部,模块内部的变量。</p>
<p>(2) 在整个模块(py文件)范围内访问（但函数内不能将其直接赋值）。</p>
<h3 id="6-6-global-语句"><a href="#6-6-global-语句" class="headerlink" title="6.6 global 语句"></a>6.6 global 语句</h3><p>(1) 作用：</p>
<p>​    在函数内部修改或定义全局变量(全局声明)。</p>
<p>(2) 语法：</p>
<p>​    global 变量1, 变量2, …</p>
<p>(3) 说明</p>
<p>​    在函数内直接为全局变量赋值，视为创建新的局部变量。</p>
<p>​    不能先声明局部的变量，再用global声明为全局变量。</p>
<h3 id="6-7-nonlocal-语句"><a href="#6-7-nonlocal-语句" class="headerlink" title="6.7 nonlocal 语句"></a>6.7 nonlocal 语句</h3><p>(1) 作用：</p>
<p>​    在内层函数修改外层嵌套函数内的变量</p>
<p>(2) 语法</p>
<p>​    nonlocal 变量名1,变量名2, …</p>
<p>(3) 说明</p>
<p>​    在被嵌套的内函数中进行使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 全局作用域:文件内部</span></span><br><span class="line"><span class="comment">#   全局变量:在全部作用域内创建的变量</span></span><br><span class="line"><span class="comment">#   适用范围:整个文件</span></span><br><span class="line">data02 = <span class="number">20</span></span><br><span class="line">data03 = [<span class="number">30</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>():</span></span><br><span class="line">    <span class="comment"># 1. 局部作用域:函数内部</span></span><br><span class="line">    <span class="comment"># 局部变量:在局部作用域内创建的变量</span></span><br><span class="line">    <span class="comment"># 适用范围:一个函数</span></span><br><span class="line">    data01 = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(data01)</span><br><span class="line">    <span class="built_in">print</span>(data02)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func02</span>():</span></span><br><span class="line">    <span class="comment"># print(data01) # 不能访问其他函数局部变量</span></span><br><span class="line">    <span class="built_in">print</span>(data02) <span class="comment"># 读取全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func03</span>():</span></span><br><span class="line">    <span class="comment"># 在局部作用域中不能修改全局变量</span></span><br><span class="line">    <span class="comment"># data02 = 200</span></span><br><span class="line">    <span class="comment"># 必须通过global语句声明</span></span><br><span class="line">    <span class="keyword">global</span> data02</span><br><span class="line">    data02 = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func04</span>():</span></span><br><span class="line">    <span class="comment"># 没有修改全局变量</span></span><br><span class="line">    <span class="comment"># 在修改全局变量指向的列表</span></span><br><span class="line">    <span class="comment"># 所以不需要通过global语句声明</span></span><br><span class="line">    data03[<span class="number">0</span>] = <span class="number">300</span></span><br><span class="line"></span><br><span class="line">func01()</span><br><span class="line">func02()</span><br><span class="line">func03()</span><br><span class="line">func04()</span><br><span class="line"><span class="built_in">print</span>(data02) <span class="comment"># 200</span></span><br><span class="line"><span class="built_in">print</span>(data03) <span class="comment"># [300]</span></span><br></pre></td></tr></table></figure>

<p>练习：画出下列代码内存图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data01 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">global</span> data01</span><br><span class="line">    data01 += <span class="number">1</span></span><br><span class="line">    p += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">data02 = <span class="number">10</span></span><br><span class="line">func01(data02)</span><br><span class="line">func01(data02)</span><br><span class="line"><span class="built_in">print</span>(data01)  <span class="comment"># ?</span></span><br><span class="line"><span class="built_in">print</span>(data02)  <span class="comment"># ?</span></span><br></pre></td></tr></table></figure>



<h2 id="7-面向对象简介"><a href="#7-面向对象简介" class="headerlink" title="7. 面向对象简介"></a>7. 面向对象简介</h2><h3 id="7-1-面向过程"><a href="#7-1-面向过程" class="headerlink" title="7.1 面向过程"></a>7.1 面向过程</h3><p>(1) <strong>定义</strong>：分析出解决问题的步骤，然后逐步实现。</p>
<p>​    例如：婚礼筹办</p>
<p>​    – 请柬（选照片、措词、制作）</p>
<p>​    – 宴席（场地、找厨师、准备桌椅餐具、计划菜品、购买食材）</p>
<p>​    – 仪式（定婚礼仪式流程、请主持人）</p>
<p>(2) <strong>公式</strong>：<font color="red">程序 = 算法 + 数据结构</font></p>
<p>(3) <strong>优点</strong>：所有环节、细节自己掌控。</p>
<p>(4) <strong>缺点</strong>：考虑所有细节，工作量大。 </p>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210311120846382.png" alt="image-20210311120846382"></p>
<h3 id="7-2-面向对象"><a href="#7-2-面向对象" class="headerlink" title="7.2 面向对象"></a>7.2 面向对象</h3><p>(1) <strong>定义</strong>：找出解决问题的人，然后分配职责。</p>
<p>​    例如：婚礼筹办</p>
<p>​    – 发请柬：找摄影公司（拍照片、制作请柬）</p>
<p>​    – 宴席：找酒店（告诉对方标准、数量、挑选菜品） </p>
<p>​    – 婚礼仪式：找婚庆公司（对方提供司仪、制定流程、提供设备、帮助执行）</p>
<p>(2) <strong>公式</strong>：<font color="red">程序 = 对象 + 交互</font></p>
<p>(3) <strong>优点</strong></p>
<p>​    a. 思想层面：</p>
<p>​        – 可模拟现实情景，更接近于人类思维。</p>
<p>​        – 有利于梳理归纳、分析解决问题。</p>
<p>​    b. 技术层面：</p>
<p>​        – <font color="orange">高复用</font>：对重复的代码进行封装，提高开发效率。</p>
<p>​        – <font color="orange">高扩展</font>：增加新的功能，不修改以前的代码。</p>
<p>​        – <font color="orange">高维护</font>：代码可读性好，逻辑清晰，结构规整。</p>
<p>(4) <strong>缺点</strong>：学习曲线陡峭。</p>
<h2 id="8-类和对象"><a href="#8-类和对象" class="headerlink" title="8. 类和对象"></a>8. 类和对象</h2><h3 id="8-1-语法"><a href="#8-1-语法" class="headerlink" title="8.1 语法"></a>8.1 语法</h3><h4 id="（1）定义类"><a href="#（1）定义类" class="headerlink" title="（1）定义类"></a>（1）定义类</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">		文档说明</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,参数</span>):</span></span><br><span class="line">		self.实例变量 = 参数</span><br><span class="line"></span><br><span class="line">	 方法成员</span><br></pre></td></tr></table></figure>

<ul>
<li>说明<ul>
<li> 类名所有单词首字母大写.</li>
<li>init 也叫构造函数，创建对象时被调用，也可以省略。</li>
<li>self 变量 绑定的是被创建的对象，名称可以随意。</li>
</ul>
</li>
</ul>
<h4 id="（2）实例化对象"><a href="#（2）实例化对象" class="headerlink" title="（2）实例化对象"></a>（2）实例化对象</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量 = 类名(参数)</span><br></pre></td></tr></table></figure>

<ul>
<li> 说明</li>
<li>变量存储的是实例化后的对象地址</li>
<li>类名后面的参数按照构造函数的形参传递</li>
</ul>
<h3 id="2-2-实例成员"><a href="#2-2-实例成员" class="headerlink" title="2.2 实例成员"></a>2.2 实例成员</h3><h4 id="（1）-实例变量"><a href="#（1）-实例变量" class="headerlink" title="（1） 实例变量"></a>（1） 实例变量</h4><ul>
<li><p>定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象.变量名</span><br></pre></td></tr></table></figure></li>
<li><p>调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象.变量名 </span><br></pre></td></tr></table></figure></li>
<li><p> 说明</p>
</li>
<li><p>首次通过对象赋值为创建，再次赋值为修改.</p>
</li>
<li><p>通常在构造函数(__init_)中创建</p>
</li>
<li><p>每个对象存储一份，通过对象地址访问</p>
</li>
</ul>
<ul>
<li>作用：描述某个对象的数据。</li>
</ul>
<ul>
<li><font color="red">_<em>dict</em>_</font>：对象的属性，用于存储自身实例变量的字典。</li>
</ul>
<h4 id="（2）实例方法"><a href="#（2）实例方法" class="headerlink" title="（2）实例方法"></a>（2）实例方法</h4><ul>
<li>定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 方法名称(<span class="params">self, 参数</span>):</span></span><br><span class="line">        方法体</span><br></pre></td></tr></table></figure>

<ul>
<li>调用： </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象.方法名称(参数)</span><br><span class="line">   <span class="comment"># 不建议通过类名访问实例方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>说明</p>
<ul>
<li>至少有一个形参，第一个参数绑定调用这个方法的对象,一般命名为self。</li>
<li>无论创建多少对象，方法只有一份，并且被所有对象共享。</li>
</ul>
</li>
<li><p>作用：表示对象行为。</p>
</li>
</ul>
<h3 id="2-3-类成员"><a href="#2-3-类成员" class="headerlink" title="2.3 类成员"></a>2.3 类成员</h3><h4 id="（1）类变量"><a href="#（1）类变量" class="headerlink" title="（1）类变量"></a>（1）类变量</h4><ul>
<li> 定义：在类中，方法外。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">     变量名 = 数据</span><br></pre></td></tr></table></figure>

<ul>
<li>调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">类名.变量名</span><br><span class="line"><span class="comment"># 不建议通过对象访问类变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>特点：</p>
<ul>
<li><p>随类的加载而加载</p>
</li>
<li><p>存在优先于对象</p>
</li>
<li><p>只有一份，被所有对象共享。</p>
</li>
</ul>
</li>
<li><p>作用：描述所有对象的共有数据。</p>
</li>
</ul>
<h4 id="（2）-类方法"><a href="#（2）-类方法" class="headerlink" title="（2） 类方法"></a>（2） <font color="red">类方法</font></h4><ul>
<li>定义：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 方法名称(<span class="params">cls,参数</span>):</span></span><br><span class="line">    方法体</span><br></pre></td></tr></table></figure>

<ul>
<li>调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">类名.方法名(参数) </span><br><span class="line"><span class="comment"># 不建议通过对象访问类方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>说明</p>
<ul>
<li>至少有一个形参，第一个形参用于绑定类，一般命名为’cls’</li>
<li>使用@classmethod修饰的目的是调用类方法时可以隐式传递类。</li>
</ul>
</li>
<li><p>类方法中不能访问实例成员，实例方法中可以访问类成员。</p>
</li>
</ul>
<ul>
<li>作用：操作类变量。</li>
</ul>
<h3 id="2-4-静态方法"><a href="#2-4-静态方法" class="headerlink" title="2.4 静态方法"></a>2.4 静态方法</h3><ul>
<li>定义：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 方法名称(<span class="params">参数</span>):</span></span><br><span class="line">    方法体</span><br></pre></td></tr></table></figure>

<ul>
<li>调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">类名.方法名称(参数) </span><br><span class="line"><span class="comment"># 不建议通过对象访问静态方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>说明<ul>
<li>使用@ staticmethod修饰的目的是该方法不需要隐式传参数。</li>
<li>静态方法不能访问实例成员和类成员</li>
</ul>
</li>
<li>作用：定义常用的工具函数。</li>
</ul>
<h2 id="9-面向对象三大特征"><a href="#9-面向对象三大特征" class="headerlink" title="9. 面向对象三大特征"></a>9. 面向对象三大特征</h2><h3 id="9-1-封装"><a href="#9-1-封装" class="headerlink" title="9.1 封装"></a>9.1 封装</h3><h4 id="（1）数据角度"><a href="#（1）数据角度" class="headerlink" title="（1）数据角度"></a>（1）数据角度</h4><ul>
<li> 定义：将一些基本数据类型复合成一个自定义类型。</li>
</ul>
<ul>
<li><p>优势：</p>
<ul>
<li><p>将数据（变量）与对数据的操作（方法）相关联。</p>
</li>
<li><p>代码可读性更高（类是对象的模板）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="（2）行为角度"><a href="#（2）行为角度" class="headerlink" title="（2）行为角度"></a>（2）行为角度</h4><ul>
<li><p>定义：</p>
<p>向类外提供必要的功能，隐藏实现的细节。</p>
</li>
<li><p>优势：</p>
<p>简化编程，使用者不必了解具体的实现细节，只需要调用对外提供的功能。</p>
</li>
</ul>
<h4 id="（3）设计角度"><a href="#（3）设计角度" class="headerlink" title="（3）设计角度"></a>（3）<font color="red">设计角度</font></h4><ul>
<li>分而治之<ul>
<li>将一个大的需求分解为许多类，每个类处理一个独立的功能</li>
<li>拆分好处：便于分工，便于复用，可扩展性强</li>
</ul>
</li>
<li>变则疏之<ul>
<li>变化的地方独立封装，避免影响其他类</li>
</ul>
</li>
<li>高内聚<ul>
<li>类中各个方法都在完成一项任务（单一职责的类）</li>
</ul>
</li>
<li>低耦合<ul>
<li>类与类的关联性与依赖度较低（每个类独立），让一个类改变尽量不影响其他类。</li>
</ul>
</li>
</ul>
<h4 id="（4）私有成员："><a href="#（4）私有成员：" class="headerlink" title="（4）私有成员："></a>（4）<font color="red">私有成员</font>：</h4><ul>
<li>作用：无需向类外提供的成员，可以通过私有化进行屏蔽。</li>
</ul>
<ul>
<li>做法：命名使用<font color="orange">双下划线开头</font>。</li>
</ul>
<ul>
<li>本质：障眼法，实际也可以访问。</li>
</ul>
<p>​              私有成员的名称被修改为：<strong>_类名__成员名</strong>，可以通过___dict__属性查看。</p>
<p>– 演示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.__data = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func01</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func01执行了&quot;</span>)</span><br><span class="line"></span><br><span class="line">m01 = MyClass(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># print(m01.__data) # 无法访问</span></span><br><span class="line"><span class="built_in">print</span>(m01._MyClass__data)</span><br><span class="line"><span class="built_in">print</span>(m01.__dict__)  <span class="comment"># &#123;&#x27;_MyClass__data&#x27;: 10&#125;</span></span><br><span class="line"><span class="comment"># m01.__func01() # 无法访问</span></span><br><span class="line">m01._MyClass__func01()</span><br></pre></td></tr></table></figure>

<h4 id="（5）属性-property"><a href="#（5）属性-property" class="headerlink" title="（5）属性@property"></a>（5）<font color="red">属性@property</font></h4><ul>
<li>作用：保护实例变量（读取、只读、只写）</li>
</ul>
<ul>
<li>定义：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 属性名(<span class="params">self</span>):</span></span><br><span class="line">  <span class="keyword">return</span> self.__属性名</span><br><span class="line"></span><br><span class="line"><span class="meta">@属性名.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 属性名(<span class="params">self, value</span>):</span></span><br><span class="line">  self.__属性名= value</span><br></pre></td></tr></table></figure>

<ul>
<li>调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象.属性名 = 数据</span><br><span class="line">变量 = 对象.属性名</span><br></pre></td></tr></table></figure>

<ul>
<li>三种形式：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 读写属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__data</span><br><span class="line"></span><br><span class="line"><span class="meta">    @data.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__data = value</span><br><span class="line"></span><br><span class="line">m01 = MyClass(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(m01.data)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 只读属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__data = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m01 = MyClass()</span><br><span class="line"><span class="comment"># m01.data = 20# AttributeError: can&#x27;t set attribute</span></span><br><span class="line"><span class="built_in">print</span>(m01.data)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3. 只写属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data = property()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># @data.setter</span></span><br><span class="line">    <span class="comment"># def data(self, value):</span></span><br><span class="line">    <span class="comment">#     self.__data = value</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__data = value</span><br><span class="line"></span><br><span class="line">    data = <span class="built_in">property</span>(fset=data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m01 = MyClass(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(m01.data)  <span class="comment"># AttributeError: unreadable attribute</span></span><br><span class="line">m01.data = <span class="number">20</span></span><br></pre></td></tr></table></figure>



<h3 id="9-2-继承"><a href="#9-2-继承" class="headerlink" title="9.2 继承"></a>9.2 继承</h3><h4 id="（1）继承方法"><a href="#（1）继承方法" class="headerlink" title="（1）继承方法"></a>（1）继承方法</h4><ul>
<li>语法:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> 父类方法(<span class="params">self</span>):</span></span><br><span class="line">     方法体</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类(<span class="params">父类</span>)：</span></span><br><span class="line"><span class="class">   <span class="title">def</span> 子类方法(<span class="params">self</span>):</span></span><br><span class="line">     方法体</span><br><span class="line"></span><br><span class="line">儿子 = 子类()</span><br><span class="line">儿子.子类方法()</span><br><span class="line">儿子.父类方法()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>说明：</p>
<p>子类直接拥有父类的方法.</p>
</li>
<li><p>演示：</p>
</li>
</ul>
<h4 id="（2）内置函数"><a href="#（2）内置函数" class="headerlink" title="（2）内置函数"></a>（2）内置函数</h4><ul>
<li><p><font color="orange">isinstance(对象, 类型) </font></p>
<p>​    返回指定对象是否是某个类的对象。</p>
</li>
<li><p><font color="orange">issubclass(类型，类型)</font></p>
<p>​    返回指定类型是否属于某个类型。</p>
</li>
</ul>
<h4 id="（3）继承数据"><a href="#（3）继承数据" class="headerlink" title="（3）继承数据"></a>（3）继承数据</h4><ul>
<li>语法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类(<span class="params">父类</span>):</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,父类参数,子类参数</span>):</span></span><br><span class="line">   <span class="built_in">super</span>().__init__(参数) <span class="comment"># 调用父类构造函数</span></span><br><span class="line">   self.实例变量 = 参数</span><br></pre></td></tr></table></figure>

<ul>
<li> 说明</li>
</ul>
<p>  子类如果没有构造函数，将自动执行父类的，但如果有构造函数将覆盖父类的。此时必须通过super()函数调用父类的构造函数，以确保父类实例变量被正常创建。</p>
<ul>
<li>演示</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="string">&quot;&quot;</span>, age=<span class="number">0</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 子类有构造函数,不会使用继承而来的父类构造函数[子覆盖了父方法,好像它不存在]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="comment"># 子类构造函数：父类构造函数参数,子类构造函数参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, score</span>):</span></span><br><span class="line">        <span class="comment"># 调用父类构造函数</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line"></span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">ts = Person(<span class="string">&quot;唐僧&quot;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="built_in">print</span>(ts.name)</span><br><span class="line">kw = Student(<span class="string">&quot;悟空&quot;</span>, <span class="number">23</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(wk.name)</span><br><span class="line"><span class="built_in">print</span>(wk.score)</span><br></pre></td></tr></table></figure>

<p>(4) 练习：</p>
<p>创建父类：车(品牌，速度)</p>
<p>创建子类：电动车(电池容量,充电功率)</p>
<p>创建子类对象并画出内存图。</p>
<h4 id="（4）-定义"><a href="#（4）-定义" class="headerlink" title="（4） 定义"></a>（4） 定义</h4><ul>
<li> 概念： 重用现有类的功能，并在此基础上进行扩展。</li>
</ul>
<ul>
<li> 说明：子类直接具有父类的成员（共性），还可以扩展新功能。</li>
</ul>
<ul>
<li><p>相关知识</p>
<ul>
<li><p>父类（基类、超类）、子类（派生类）。</p>
</li>
<li><p>父类相对于子类更抽象，范围更宽泛；子类相对于父类更具体，范围更狭小。</p>
</li>
<li><p>单继承：父类只有一个（例如 Java，C#）。</p>
</li>
<li><p> 多继承：父类有多个（例如C++，Python）。</p>
</li>
<li><p>Object类：任何类都直接或间接继承自 Object 类。</p>
</li>
</ul>
</li>
</ul>
<h4 id="（5）多继承"><a href="#（5）多继承" class="headerlink" title="（5）多继承"></a>（5）多继承</h4><ul>
<li>定义：一个子类继承两个或两个以上的基类，父类中的属性和方法同时被子类继承下来。</li>
</ul>
<ul>
<li><p>同名方法解析顺序（MRO， Method Resolution Order）:</p>
<p>类自身 –&gt; 父类继承列表（由左至右）–&gt; 再上层父类</p>
</li>
</ul>
<p>​          A</p>
<p>​       /       \</p>
<p>   /               \</p>
<p>  B                C</p>
<p>   \                 /</p>
<p>​       \          /</p>
<p>​           D </p>
<p>(3) 练习：写出下列代码在终端中执行效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">	    <span class="built_in">super</span>().func01()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A,B</span>):</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">self</span>):</span></span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">	    <span class="built_in">super</span>().func01()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">    	<span class="built_in">super</span>().func01()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>(<span class="params">C,D</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func01</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">	    <span class="built_in">super</span>().func01()</span><br><span class="line"></span><br><span class="line">e = E()</span><br><span class="line">e.func01()</span><br></pre></td></tr></table></figure>



<h3 id="9-3-多态"><a href="#9-3-多态" class="headerlink" title="9.3 多态"></a>9.3 多态</h3><h4 id="（1）重写内置函数"><a href="#（1）重写内置函数" class="headerlink" title="（1）重写内置函数"></a>（1）重写内置函数</h4><ul>
<li>定义：Python中，以双下划线开头、双下划线结尾的是系统定义的成员。我们可以在自定义类中进行重写，从而改变其行为。</li>
</ul>
<ul>
<li> __str__ 函数：将对象转换为字符串(对人友好的)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="string">&quot;&quot;</span>, age=<span class="number">0</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>的年龄是<span class="subst">&#123;self.age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">wk = Person(<span class="string">&quot;悟空&quot;</span>, <span class="number">26</span>)</span><br><span class="line"><span class="comment"># &lt;__main__.Person object at 0x7fbabfbc3e48&gt;</span></span><br><span class="line"><span class="comment"># 悟空的年龄是26</span></span><br><span class="line"><span class="built_in">print</span>(wk) </span><br><span class="line"><span class="comment"># message = wk.__str__()</span></span><br><span class="line"><span class="comment"># print(message)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>算数运算符重载</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210305133828932.png" alt="image-20210305133828932"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        二维向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x是:%d,y是:%d&quot;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector2(self.x + other.x, self.y + other.y)</span><br><span class="line"></span><br><span class="line">v01 = Vector2(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">v02 = Vector2(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(v01 + v02)  <span class="comment"># v01.__add__(v02)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>复合运算符重载</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210305133752412.png" alt="image-20210305133752412"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        二维向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x是:%d,y是:%d&quot;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># + 创建新</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector2(self.x + other.x, self.y + other.y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># += 在原有基础上修改(自定义类属于可变对象)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iadd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        self.x += other.x</span><br><span class="line">        self.y += other.y</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">v01 = Vector2(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">v02 = Vector2(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(v01))</span><br><span class="line">v01 += v02</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(v01))</span><br><span class="line"><span class="built_in">print</span>(v01)</span><br></pre></td></tr></table></figure>

<ul>
<li>比较运算重载</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210305133720536.png" alt="image-20210305133720536"></p>
<p>– 演示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        二维向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 决定相同的依据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x == other.x <span class="keyword">and</span> self.y == other.y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 决定大小的依据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x &lt; other.x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v01 = Vector2(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">v02 = Vector2(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(v01 == v02)  <span class="comment"># True 比较两个对象内容(__eq__决定)</span></span><br><span class="line"><span class="built_in">print</span>(v01 <span class="keyword">is</span> v02)  <span class="comment"># False 比较两个对象地址</span></span><br><span class="line"></span><br><span class="line">list01 = [</span><br><span class="line">    Vector2(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">    Vector2(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">    Vector2(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    Vector2(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    Vector2(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    Vector2(<span class="number">4</span>, <span class="number">4</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须重写 eq</span></span><br><span class="line"><span class="built_in">print</span>(Vector2(<span class="number">5</span>, <span class="number">5</span>) <span class="keyword">in</span> list01)</span><br><span class="line"><span class="built_in">print</span>(list01.count(Vector2(<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须重写 lt</span></span><br><span class="line">list01.sort()</span><br><span class="line"><span class="built_in">print</span>(list01)</span><br></pre></td></tr></table></figure>

<h4 id="（2）重写自定义函数"><a href="#（2）重写自定义函数" class="headerlink" title="（2）重写自定义函数"></a>（2）重写自定义函数</h4><ul>
<li>子类实现了父类中相同的方法（方法名、参数），在调用该方法时，实际执行的是子类的方法。</li>
</ul>
<ul>
<li> 快捷键：ctrl + O</li>
</ul>
<ul>
<li> 作用</li>
<li>在继承的基础上，体现类型的个性（一个行为有不同的实现）。</li>
<li>增强程序灵活性。</li>
</ul>
<h2 id="10-程序结构"><a href="#10-程序结构" class="headerlink" title="10. 程序结构"></a>10. 程序结构</h2><h3 id="10-1-模块-Module"><a href="#10-1-模块-Module" class="headerlink" title="10.1 模块 Module"></a>10.1 模块 Module</h3><h4 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​    包含一系列<strong>数据、函数、类</strong>的文件，通常以**.py**结尾。</p>
<h4 id="（2）作用"><a href="#（2）作用" class="headerlink" title="（2）作用"></a>（2）作用</h4><p>​    让一些相关的数据，函数，类有逻辑的组织在一起，使逻辑结构更加清晰。有利于多人合作开发。</p>
<h4 id="（3）导入"><a href="#（3）导入" class="headerlink" title="（3）导入"></a>（3）导入</h4><ul>
<li><p>import </p>
<ul>
<li><p>语法：</p>
<p>import 模块名</p>
<p>import 模块名 as 别名</p>
</li>
<li><p>作用：将模块整体导入到当前模块中</p>
</li>
<li><p>使用：</p>
<p>模块名.成员</p>
<p>别名.成员</p>
</li>
</ul>
</li>
<li><p>from import </p>
<ul>
<li><p>语法：</p>
<p>from 模块名 import 成员名</p>
<p>from 模块名 import 成员名  as 别名</p>
<p>from 模块名 import *</p>
</li>
<li><p>作用：将模块内的成员导入到当前模块作用域中</p>
</li>
<li><p>使用：直接使用成员名</p>
</li>
</ul>
</li>
</ul>
<h4 id="（4）模块变量"><a href="#（4）模块变量" class="headerlink" title="（4）模块变量"></a>（4）模块变量</h4><ul>
<li>__doc__变量：文档字符串。</li>
</ul>
<ul>
<li><p>__name__变量：模块自身名字，可以判断是否为主模块。</p>
<p>当此模块作为主模块(第一个运行的模块)运行时，__name__绑定’__main__‘，不是主模块，而是被其它模块导入时,存储模块名。</p>
</li>
</ul>
<h4 id="（5）-加载过程"><a href="#（5）-加载过程" class="headerlink" title="（5） 加载过程"></a>（5） 加载过程</h4><ul>
<li>在模块导入时，模块的所有语句会执行。</li>
</ul>
<ul>
<li>如果一个模块已经导入，则再次导入时不会重新执行模块内的语句。</li>
</ul>
<h4 id="（6）分类"><a href="#（6）分类" class="headerlink" title="（6）分类"></a>（6）分类</h4><ul>
<li>内置模块(builtins)，在解析器的内部可以直接使用。</li>
</ul>
<ul>
<li>标准库模块，安装Python时已安装且可直接使用。</li>
</ul>
<ul>
<li> 第三方模块（通常为开源），需要自己安装。</li>
</ul>
<ul>
<li> 用户自己编写的模块（可以作为其他人的第三方模块）</li>
</ul>
<h3 id="10-2-包package"><a href="#10-2-包package" class="headerlink" title="10.2 包package"></a>10.2 <font color="red">包package</font></h3><h4 id="（1）定义-1"><a href="#（1）定义-1" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​    将模块以<strong>文件夹的形式</strong>进行分组管理。让一些相关的模块组织在一起，使逻辑结构更加清晰。</p>
<h4 id="（2）-init-py的作用"><a href="#（2）-init-py的作用" class="headerlink" title="（2）__init.py的作用"></a>（2）__init.py的作用</h4><ul>
<li><p> _<em>init</em>_.py 在包被导入时会被执行</p>
</li>
<li><p>表示（标识）一个Python Package</p>
</li>
<li><p>对于自己写的模块，想要一键导入，单单这样写：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> package <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>​    是不够的，要在_<em>init</em>_.py中加入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [‘module1’,‘module2’,.]</span><br></pre></td></tr></table></figure>

<h4 id="（3）导入-1"><a href="#（3）导入-1" class="headerlink" title="（3）导入"></a>（3）导入</h4><ul>
<li><p>import </p>
<ul>
<li><p>语法：</p>
<p>import 包</p>
<p>import 包 as 别名</p>
</li>
<li><p>作用：将包中<strong>__init__模块内整体</strong>导入到当前模块中</p>
</li>
<li><p>使用：<strong>包.成员</strong></p>
</li>
</ul>
</li>
<li><p>from import </p>
<ul>
<li><p>语法：</p>
<p>from 包 import 成员</p>
<p>from 包  import 成员 as 别名</p>
</li>
<li><p>作用：将包中<strong>__init__模块内的成员</strong>导入到当前模块作用域中</p>
</li>
<li><p>使用：<strong>直接使用成员名</strong></p>
</li>
</ul>
</li>
<li><p>演示：</p>
<p>目录结构：</p>
<p>​        main.py</p>
<p>​        package01/</p>
<p>​            __init__.py</p>
<p>​            module01.py</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	package01/</span></span><br><span class="line"><span class="string">	    module01.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func01执行了&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func02</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func02执行了&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    main.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 方式1:import 包 as 别名</span></span><br><span class="line"><span class="keyword">import</span> package01 <span class="keyword">as</span> p</span><br><span class="line"></span><br><span class="line">p.module01.func01()</span><br><span class="line">p.func02()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2:from 包 import 成员</span></span><br><span class="line"><span class="keyword">from</span> package01 <span class="keyword">import</span> module01,func02</span><br><span class="line"></span><br><span class="line">module01.func01()</span><br><span class="line">func02()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	package01/</span></span><br><span class="line"><span class="string">	    __init__.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> package01.module01</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> package01.module01 <span class="keyword">import</span> func02</span><br></pre></td></tr></table></figure>



<h2 id="11-异常处理"><a href="#11-异常处理" class="headerlink" title="11. 异常处理"></a>11. 异常处理</h2><h3 id="11-1-异常"><a href="#11-1-异常" class="headerlink" title="11.1 异常"></a>11.1 异常</h3><h4 id="（1）定义-2"><a href="#（1）定义-2" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​        运行时检测到的错误。</p>
<h4 id="（2）现象"><a href="#（2）现象" class="headerlink" title="（2）现象"></a>（2）现象</h4><p>​        当异常发生时，程序不会再向下执行，而转到函数的调用语句。</p>
<h4 id="（3）常见异常类型"><a href="#（3）常见异常类型" class="headerlink" title="（3）常见异常类型"></a>（3）常见异常类型</h4><ul>
<li>名称异常(<font color="orange">NameError</font>)：变量未定义。</li>
</ul>
<ul>
<li><p>类型异常(<font color="orange">TypeError)</font>：不同类型数据进行运算。</p>
</li>
<li><p>索引异常(<font color="orange">IndexError</font>)：超出索引范围。</p>
</li>
<li><p>属性异常(<font color="orange">AttributeError</font>)：对象没有对应名称的属性。</p>
</li>
<li><p>键异常(<font color="orange">KeyError</font>)：没有对应名称的键。</p>
</li>
<li><p>异常基类<font color="orange">Exception</font>。</p>
</li>
<li></li>
</ul>
<h3 id="11-2-处理"><a href="#11-2-处理" class="headerlink" title="11.2 处理"></a>11.2 <font color="red">处理</font></h3><h4 id="（1）语法："><a href="#（1）语法：" class="headerlink" title="（1）语法："></a>（1）语法：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	可能触发异常的语句</span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span> [<span class="keyword">as</span> 变量<span class="number">1</span>]：</span><br><span class="line">	处理语句<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">2</span> [<span class="keyword">as</span> 变量<span class="number">2</span>]：</span><br><span class="line">	处理语句<span class="number">2</span></span><br><span class="line"><span class="keyword">except</span> Exception [<span class="keyword">as</span> 变量<span class="number">3</span>]：</span><br><span class="line">	不是以上错误类型的处理语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	未发生异常的语句</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	无论是否发生异常的语句</span><br></pre></td></tr></table></figure>

<h4 id="（2）作用-1"><a href="#（2）作用-1" class="headerlink" title="（2）作用"></a>（2）作用</h4><p>​    将程序由异常状态转为正常流程。</p>
<h4 id="（3）说明"><a href="#（3）说明" class="headerlink" title="（3）说明"></a>（3）说明</h4><ul>
<li>as 子句是用于绑定错误对象的变量，可以省略</li>
</ul>
<ul>
<li>except子句可以有一个或多个，用来捕获某种类型的错误。</li>
</ul>
<ul>
<li>else子句最多只能有一个。</li>
</ul>
<ul>
<li>finally子句最多只能有一个，如果没有except子句，必须存在。</li>
</ul>
<ul>
<li>如果异常没有被捕获到，会向上层(调用处)继续传递，直到程序终止运行。</li>
</ul>
<h3 id="11-3-raise-语句"><a href="#11-3-raise-语句" class="headerlink" title="11.3 raise 语句"></a>11.3 raise 语句</h3><h4 id="（1）-作用"><a href="#（1）-作用" class="headerlink" title="（1） 作用"></a>（1） 作用</h4><p>​    抛出一个错误，让程序进入异常状态。</p>
<h4 id="（2）目的"><a href="#（2）目的" class="headerlink" title="（2）目的"></a>（2）目的</h4><p>​    在程序调用层数较深时，向主调函数传递错误信息要层层return比较麻烦，所以人为抛出异常，可以直接传递错误信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wife</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">20</span> &lt;= value &lt;= <span class="number">60</span>:</span><br><span class="line">            self.__age = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 创建异常  -- 抛出 错误信息</span></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;我不要&quot;</span>,<span class="string">&quot;if 20 &lt;= value &lt;= 60&quot;</span>,<span class="number">1001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- 接收 错误信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你老婆年龄：&quot;</span>))</span><br><span class="line">        w01 = Wife(age)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e.args) <span class="comment"># (&#x27;我不要&#x27;, &#x27;if 30 &lt;= value &lt;= 60&#x27;, 1001)</span></span><br></pre></td></tr></table></figure>



<h2 id="12-迭代器iterator"><a href="#12-迭代器iterator" class="headerlink" title="12. 迭代器iterator"></a>12. 迭代器iterator</h2><p>​    每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。例如：循环获取容器中的元素。</p>
<h3 id="12-1-可迭代对象iterabale"><a href="#12-1-可迭代对象iterabale" class="headerlink" title="12.1 可迭代对象iterabale"></a>12.1 可迭代对象iterabale</h3><h4 id="（1）定义-3"><a href="#（1）定义-3" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​        可迭代对象：具有<font color="orange">__iter__</font>函数的对象，可以返回迭代器对象。如字符串，列表等。</p>
<h4 id="（2）语法"><a href="#（2）语法" class="headerlink" title="（2）语法"></a>（2）语法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 可迭代对象名称:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">   		<span class="keyword">return</span> 迭代器</span><br><span class="line"><span class="comment"># 使用：</span></span><br><span class="line">	<span class="keyword">for</span> 变量名 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">		语句</span><br></pre></td></tr></table></figure>

<h4 id="（3）原理"><a href="#（3）原理" class="headerlink" title="（3）原理"></a>（3）原理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">迭代器 = 可迭代对象.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        <span class="built_in">print</span>(迭代器.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h4 id="（4）演示"><a href="#（4）演示" class="headerlink" title="（4）演示"></a>（4）演示</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">&quot;我是花果山水帘洞孙悟空&quot;</span></span><br><span class="line"><span class="comment"># for item in message:</span></span><br><span class="line"><span class="comment">#     print(item)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 获取迭代器对象</span></span><br><span class="line">iterator = message.__iter__()</span><br><span class="line"><span class="comment"># 2. 获取下一个元素</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        item = iterator.__next__()</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">        <span class="comment"># 3. 如果停止迭代则跳出循环</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<h3 id="12-2-迭代器对象iterator"><a href="#12-2-迭代器对象iterator" class="headerlink" title="12.2 迭代器对象iterator"></a>12.2 迭代器对象iterator</h3><h4 id="（1）定义-4"><a href="#（1）定义-4" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​        可以被next()函数调用并返回下一个值的对象。</p>
<h4 id="（2）语法-1"><a href="#（2）语法-1" class="headerlink" title="（2）语法"></a>（2）语法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 迭代器类名:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, 聚合对象</span>):</span></span><br><span class="line">        self.聚合对象= 聚合对象 </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="keyword">if</span> 没有元素:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">            <span class="keyword">return</span> 聚合对象元素</span><br></pre></td></tr></table></figure>

<h4 id="（3）说明-1"><a href="#（3）说明-1" class="headerlink" title="（3）说明"></a>（3）说明</h4><p>​    聚合对象通常是容器对象。</p>
<h4 id="（4）作用"><a href="#（4）作用" class="headerlink" title="（4）作用"></a>（4）作用</h4><p>​    使用者只需通过一种方式，便可简洁明了的获取聚合对象中各个元素，而又无需了解其内部结构。</p>
<h4 id="（5）演示："><a href="#（5）演示：" class="headerlink" title="（5）演示："></a>（5）演示：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentIterator</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.__data = data</span><br><span class="line">        self.__index = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__index == <span class="built_in">len</span>(self.__data) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.__index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.__data[self.__index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentController</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__students = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_student</span>(<span class="params">self, stu</span>):</span></span><br><span class="line">        self.__students.append(stu)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> StudentIterator(self.__students)</span><br><span class="line"> </span><br><span class="line">controller = StudentController()</span><br><span class="line">controller.add_student(<span class="string">&quot;悟空&quot;</span>)</span><br><span class="line">controller.add_student(<span class="string">&quot;八戒&quot;</span>)</span><br><span class="line">controller.add_student(<span class="string">&quot;唐僧&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for item in controller:</span></span><br><span class="line"><span class="comment">#     print(item) #</span></span><br><span class="line">iterator = controller.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        item = iterator.__next__()</span><br><span class="line">        <span class="built_in">print</span>(item)  <span class="comment">#</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<h2 id="13-生成器generator"><a href="#13-生成器generator" class="headerlink" title="13. 生成器generator"></a>13. 生成器generator</h2><ul>
<li>定义：能够动态(循环一次计算一次返回一次)提供数据的可迭代对象。</li>
</ul>
<ul>
<li>作用：在循环过程中，按照某种算法推算数据，不必创建容器存储完整的结果，从而节省内存空间。数据量越大，优势越明显。以上作用也称之为<strong>延迟操作或惰性操作</strong>，通俗的讲就是在需要的时候才计算结果，而不是一次构建出所有结果。</li>
</ul>
<h3 id="13-1-生成器函数"><a href="#13-1-生成器函数" class="headerlink" title="13.1 生成器函数"></a>13.1 生成器函数</h3><h4 id="（1）定义-5"><a href="#（1）定义-5" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>​    含有<font color="orange">yield</font>语句的函数，返回值为生成器对象。</p>
<h4 id="（2）语法-2"><a href="#（2）语法-2" class="headerlink" title="（2）语法"></a>（2）语法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 函数名():</span></span><br><span class="line">	…</span><br><span class="line">	<span class="keyword">yield</span> 数据</span><br><span class="line">	…</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用：</span></span><br><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 函数名():</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>

<h4 id="（3）说明-2"><a href="#（3）说明-2" class="headerlink" title="（3）说明"></a>（3）说明</h4><ul>
<li>调用生成器函数将返回一个生成器对象，不执行函数体。</li>
</ul>
<ul>
<li>yield翻译为”产生”或”生成”</li>
</ul>
<h4 id="（4）执行过程："><a href="#（4）执行过程：" class="headerlink" title="（4）执行过程："></a>（4）执行过程：</h4><p>​        a. 调用生成器函数会<strong>自动创建迭代器对象</strong>。</p>
<p>​        b. 调用迭代器对象的__next__()方法时才执行生成器函数。</p>
<p>​        c. 每次执行到yield语句时返回数据，暂时离开。</p>
<p>​        d. 待下次调用__next__()方法时继续从离开处继续执行。</p>
<h4 id="（5）原理"><a href="#（5）原理" class="headerlink" title="（5）原理"></a>（5）原理</h4><p>​        生成迭代器对象的大致规则如下</p>
<p>​            a. 将yield关键字以前的代码放在next方法中。</p>
<p>​            b. 将yield关键字后面的数据作为next方法的返回值。</p>
<p>(6) 演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_range</span>(<span class="params">stop</span>):</span></span><br><span class="line">    number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> number &lt; stop:</span><br><span class="line">        <span class="keyword">yield</span> number</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> my_range(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(number)  <span class="comment"># 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>



<h3 id="13-2-内置生成器"><a href="#13-2-内置生成器" class="headerlink" title="13.2 内置生成器"></a>13.2 <font color="red">内置生成器</font></h3><h4 id="（1）枚举函数enumerate"><a href="#（1）枚举函数enumerate" class="headerlink" title="（1）枚举函数enumerate"></a>（1）枚举函数enumerate</h4><ul>
<li>语法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> <span class="built_in">enumerate</span>(可迭代对象):</span><br><span class="line">    语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 索引, 元素<span class="keyword">in</span> <span class="built_in">enumerate</span>(可迭代对象):</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>

<ul>
<li> 作用：遍历可迭代对象时，可以<strong>将索引与元素组合为一个元组</strong>。</li>
</ul>
<ul>
<li>演示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list01 = [<span class="number">43</span>, <span class="number">43</span>, <span class="number">54</span>, <span class="number">56</span>, <span class="number">76</span>]</span><br><span class="line"><span class="comment"># 从头到尾读          -- 读取数据</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list01:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非从头到尾读        -- 修改数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list01)):</span><br><span class="line">    <span class="keyword">if</span> list01[i] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        list01[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(list01):  <span class="comment"># -- 读写数据</span></span><br><span class="line">    <span class="keyword">if</span> item % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        list01[i] += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）zip"><a href="#（2）zip" class="headerlink" title="（2）zip"></a>（2）zip</h4><ul>
<li>语法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(可迭代对象<span class="number">1</span>, 可迭代对象<span class="number">2</span>):</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：将<strong>多个可迭代对象中对应的元素组合成一个个元组</strong>，生成的元组个数由最小的可迭代对象决定。</li>
</ul>
<ul>
<li>演示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_name = [<span class="string">&quot;悟空&quot;</span>, <span class="string">&quot;八戒&quot;</span>, <span class="string">&quot;沙僧&quot;</span>]</span><br><span class="line">list_age = [<span class="number">22</span>, <span class="number">26</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># for 变量 in zip(可迭代对象1,可迭代对象2)</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(list_name, list_age):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># (&#x27;悟空&#x27;, 22)</span></span><br><span class="line"><span class="comment"># (&#x27;八戒&#x27;, 26)</span></span><br><span class="line"><span class="comment"># (&#x27;沙僧&#x27;, 25)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用:矩阵转置</span></span><br><span class="line"><span class="built_in">map</span> = [</span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment"># new_map = []</span></span><br><span class="line"><span class="comment"># for item in zip(map[0],map[1],map[2],map[3]):</span></span><br><span class="line"><span class="comment">#     new_map.append(list(item))</span></span><br><span class="line"><span class="comment"># print(new_map)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># new_map = []</span></span><br><span class="line"><span class="comment"># for item in zip(*map):</span></span><br><span class="line"><span class="comment">#     new_map.append(list(item))</span></span><br><span class="line"></span><br><span class="line">new_map = [<span class="built_in">list</span>(item) <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(*<span class="built_in">map</span>)]</span><br><span class="line"><span class="built_in">print</span>(new_map)</span><br><span class="line"><span class="comment"># [[2, 4, 2, 0], [0, 2, 4, 4], [0, 0, 2, 0], [2, 2, 4, 4]]</span></span><br></pre></td></tr></table></figure>



<h3 id="13-3-生成器表达式"><a href="#13-3-生成器表达式" class="headerlink" title="13.3 生成器表达式"></a>13.3 生成器表达式</h3><ul>
<li>定义：用推导式形式创建生成器对象。</li>
</ul>
<ul>
<li>语法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量 = (表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 可迭代对象 <span class="keyword">if</span> 条件)</span><br></pre></td></tr></table></figure>



<h2 id="14-函数式编程"><a href="#14-函数式编程" class="headerlink" title="14. 函数式编程"></a>14. 函数式编程</h2><ul>
<li><p>定义：用一系列函数解决问题。</p>
<ul>
<li>函数可以<strong>赋值给变量</strong>，赋值后变量绑定函数。</li>
<li>允许将函数<strong>作为参数</strong>传入另一个函数。</li>
<li>允许函数<strong>返回一个函数</strong>。</li>
</ul>
</li>
<li><p>高阶函数：将函数作为参数或返回值的函数。</p>
</li>
</ul>
<h3 id="14-1-函数作为参数"><a href="#14-1-函数作为参数" class="headerlink" title="14.1 函数作为参数"></a>14.1 函数作为参数</h3><p>​    将核心逻辑传入方法体，使该方法的适用性更广，体现了面向对象的开闭原则。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list01 = [<span class="number">342</span>, <span class="number">4</span>, <span class="number">54</span>, <span class="number">56</span>, <span class="number">6776</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数,在列表中查找所有大于100的数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number_gt_100</span>():</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="keyword">if</span> number &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">yield</span> number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数,在列表中查找所有偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number_by_even</span>():</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> number</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：得到的是列表中的元素</span></span><br><span class="line"><span class="comment"># 返回值：对列表元素判断后的结果(True False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition01</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">return</span> number &gt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition02</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">return</span> number % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition03</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通用函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_all</span>(<span class="params">condition</span>):</span> <span class="comment"># 抽象</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="comment"># if number &gt; 100:</span></span><br><span class="line">        <span class="comment"># if condition01(item):</span></span><br><span class="line">        <span class="comment"># if condition02(item):</span></span><br><span class="line">        <span class="keyword">if</span> condition(item):<span class="comment"># 统一</span></span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> find_all(condition03):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>



<h4 id="（1）lambda-表达式"><a href="#（1）lambda-表达式" class="headerlink" title="（1）lambda 表达式"></a>（1）lambda 表达式</h4><p>​    <a href="/2022/02/19/Python-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="Python-lambda表达式">Python-lambda表达式</a></p>
<ul>
<li>定义：是一种匿名方法</li>
</ul>
<ul>
<li><p>作用：</p>
<ul>
<li>作为参数传递时语法简洁，优雅，代码可读性强。</li>
<li>随时创建和销毁，减少程序耦合度。</li>
</ul>
</li>
<li><p>语法</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义：</span></span><br><span class="line">变量 = <span class="keyword">lambda</span> 形参: 方法体</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用：</span></span><br><span class="line">变量(实参)</span><br></pre></td></tr></table></figure>

<ul>
<li>说明：<ul>
<li>形参没有可以不填</li>
<li>方法体只能有一条语句，且不支持赋值语句。</li>
</ul>
</li>
</ul>
<p>(5) 演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> common.iterable_tools <span class="keyword">import</span> IterableHelper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数,在列表中查找所有大于100的数</span></span><br><span class="line"><span class="comment"># def condition01(number):</span></span><br><span class="line"><span class="comment">#     return number &gt; 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数,在列表中查找所有偶数</span></span><br><span class="line"><span class="comment"># def condition02(number):</span></span><br><span class="line"><span class="comment">#     return number % 2 == 0</span></span><br><span class="line"></span><br><span class="line">list01 = [<span class="number">342</span>, <span class="number">4</span>, <span class="number">54</span>, <span class="number">56</span>, <span class="number">6776</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> IterableHelper.find_all(list01,<span class="keyword">lambda</span> number: number &gt; <span class="number">100</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> IterableHelper.find_all(list01,<span class="keyword">lambda</span> number: number % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>



<h4 id="（2）内置高阶函数"><a href="#（2）内置高阶函数" class="headerlink" title="（2）内置高阶函数"></a>（2）内置高阶函数</h4><ul>
<li>map（函数，可迭代对象）：使用可迭代对象中的每个元素调用函数，将返回值作为新可迭代对象元素；返回值为新可迭代对象。</li>
</ul>
<ul>
<li>filter(函数，可迭代对象)：根据条件筛选可迭代对象中的元素，返回值为新可迭代对象。</li>
</ul>
<ul>
<li>sorted(可迭代对象，key = 函数, reverse = bool值)：排序，返回值为排序结果。</li>
</ul>
<ul>
<li>max(可迭代对象，key = 函数)：根据函数获取可迭代对象的最大值。</li>
</ul>
<ul>
<li>min(可迭代对象，key = 函数)：根据函数获取可迭代对象的最小值。</li>
</ul>
<ul>
<li>演示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, eid, did, name, money</span>):</span></span><br><span class="line">        self.eid = eid  <span class="comment"># 员工编号</span></span><br><span class="line">        self.did = did  <span class="comment"># 部门编号</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.money = money</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 员工列表</span></span><br><span class="line">list_employees = [</span><br><span class="line">    Employee(<span class="number">1001</span>, <span class="number">9002</span>, <span class="string">&quot;师父&quot;</span>, <span class="number">60000</span>),</span><br><span class="line">    Employee(<span class="number">1002</span>, <span class="number">9001</span>, <span class="string">&quot;孙悟空&quot;</span>, <span class="number">50000</span>),</span><br><span class="line">    Employee(<span class="number">1003</span>, <span class="number">9002</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="number">20000</span>),</span><br><span class="line">    Employee(<span class="number">1004</span>, <span class="number">9001</span>, <span class="string">&quot;沙僧&quot;</span>, <span class="number">30000</span>),</span><br><span class="line">    Employee(<span class="number">1005</span>, <span class="number">9001</span>, <span class="string">&quot;小白龙&quot;</span>, <span class="number">15000</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. map 映射</span></span><br><span class="line"><span class="comment"># 需求:获取所有员工姓名</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> item: item.name, list_employees):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. filter 过滤器</span></span><br><span class="line"><span class="comment"># 需求：查找所有部门是9002的员工</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="keyword">lambda</span> item: item.did == <span class="number">9002</span>, list_employees):</span><br><span class="line">    <span class="built_in">print</span>(item.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. max min 最值</span></span><br><span class="line">emp = <span class="built_in">max</span>(list_employees, key=<span class="keyword">lambda</span> emp: emp.money)</span><br><span class="line"><span class="built_in">print</span>(emp.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. sorted</span></span><br><span class="line"><span class="comment"># 升序排列</span></span><br><span class="line">new_list = <span class="built_in">sorted</span>(list_employees, key=<span class="keyword">lambda</span> emp: emp.money)</span><br><span class="line"><span class="built_in">print</span>(new_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 降序排列</span></span><br><span class="line">new_list = <span class="built_in">sorted</span>(list_employees, key=<span class="keyword">lambda</span> emp: emp.money, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(new_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="14-2-函数作为返回值"><a href="#14-2-函数作为返回值" class="headerlink" title="14.2 函数作为返回值"></a>14.2 函数作为返回值</h3><p>逻辑连续，当内部函数被调用时，不脱离当前的逻辑。</p>
<h4 id="（1）闭包"><a href="#（1）闭包" class="headerlink" title="（1）闭包"></a>（1）<font color="red">闭包</font></h4><ul>
<li><p>三要素：</p>
<ul>
<li>必须有一个内嵌函数。</li>
<li>内嵌函数必须引用外部函数中变量。</li>
<li>外部函数返回值必须是内嵌函数。</li>
</ul>
</li>
<li><p>语法</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 外部函数名(<span class="params">参数</span>):</span></span><br><span class="line">    外部变量</span><br><span class="line">    <span class="function"><span class="keyword">def</span> 内部函数名(<span class="params">参数</span>):</span></span><br><span class="line">        使用外部变量</span><br><span class="line">    <span class="keyword">return</span> 内部函数名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用：</span></span><br><span class="line">变量 = 外部函数名(参数)</span><br><span class="line">变量(参数)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义：是由函数及其相关的引用环境组合而成的实体。 </p>
</li>
<li><p>优点：内部函数可以使用外部变量。</p>
</li>
</ul>
<ul>
<li>缺点：外部变量一直存在于内存中，不会在调用结束后释放，占用内存。</li>
</ul>
<ul>
<li><p>作用：实现python装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="comment"># 定义：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 函数装饰器名称(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> 内部函数名(<span class="params">*args, **kwarg</span>):</span></span><br><span class="line">        需要添加的新功能</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> 内部函数名</span><br><span class="line"></span><br><span class="line"><span class="meta">@ 函数装饰器名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 被装饰函数名():</span></span><br><span class="line">	原来的功能</span><br></pre></td></tr></table></figure></li>
</ul>
<p>(7) 演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">give_gife_money</span>(<span class="params">money</span>):</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;获得&quot;</span>, money, <span class="string">&quot;元压岁钱&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">child_buy</span>(<span class="params">commodity, price</span>):</span> </span><br><span class="line">        <span class="keyword">nonlocal</span> money		<span class="comment"># 在内层函数修改外层嵌套函数内的变量</span></span><br><span class="line">        money -= price</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;购买了&quot;</span>, commodity, <span class="string">&quot;花了&quot;</span>, price, <span class="string">&quot;元,还剩下&quot;</span>, money)</span><br><span class="line">    <span class="keyword">return</span> child_buy</span><br><span class="line"></span><br><span class="line">action = give_gife_money(<span class="number">500</span>)	<span class="comment"># 返回值是一个函数child_buy</span></span><br><span class="line">action(<span class="string">&quot;变形金刚&quot;</span>, <span class="number">200</span>)</span><br><span class="line">action(<span class="string">&quot;芭比娃娃&quot;</span>, <span class="number">300</span>)</span><br></pre></td></tr></table></figure>



<h4 id="（2）函数装饰器decorator"><a href="#（2）函数装饰器decorator" class="headerlink" title="（2）函数装饰器decorator"></a>（2）<font color="red">函数装饰器decorator</font></h4><ul>
<li> 定义：在不改变原函数的调用以及内部代码情况下，为其添加新功能的函数。</li>
</ul>
<ul>
<li>语法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数装饰器名称(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span>	<span class="comment">#星号元组形参，双星号字典形参</span></span><br><span class="line">        需要添加的新功能</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@ 函数装饰器名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 原函数名称(<span class="params">参数</span>):</span></span><br><span class="line">    函数体</span><br><span class="line"></span><br><span class="line">原函数(参数)</span><br></pre></td></tr></table></figure>

<ul>
<li>本质：使用“<font color="orange">@函数装饰器名称</font>”修饰原函数，<font color="orange">等同于创建与原函数名称相同的变量，关联内嵌函数</font>；故调用原函数时执行内嵌函数。</li>
</ul>
<p>​        <font color="red">原函数名称 = 函数装饰器名称（原函数名称）</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func01</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;旧功能&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_func</span>(<span class="params">func</span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;新功能&quot;</span>)</span><br><span class="line">        func() <span class="comment"># 执行旧功能</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新功能覆盖了旧功能（没有将func01作为参数传入new_func）</span></span><br><span class="line"><span class="comment"># func01 = new_func</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用一次外部函数(装饰器本质)</span></span><br><span class="line">func01 = new_func(func01)</span><br><span class="line"><span class="comment"># 调用多次内部函数</span></span><br><span class="line">func01()</span><br><span class="line">func01()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>装饰器链：</p>
<p>一个函数可以被多个装饰器修饰，执行顺序为从近到远。</p>
</li>
</ul>
<h2 id="15-文件操作"><a href="#15-文件操作" class="headerlink" title="15. 文件操作"></a>15. 文件操作</h2><h3 id="15-1-文件与字节串"><a href="#15-1-文件与字节串" class="headerlink" title="15.1 文件与字节串"></a>15.1 文件与字节串</h3><h4 id="（1）文件"><a href="#（1）文件" class="headerlink" title="（1）文件"></a>（1）文件</h4><p>​    文件是保存在持久化存储设备(硬盘、U盘、光盘..)上的一段数据。从格式编码角度分为文本文件（打开后会自动解码为字符）、二进制文件(视频、音频等)。在Python里把文件视作一种类型的对象，类似之前学习过的其它类型。</p>
<h4 id="（2）字节串（bytes）"><a href="#（2）字节串（bytes）" class="headerlink" title="（2）字节串（bytes）"></a>（2）字节串（bytes）</h4><p>​    在python3中引入了字节串的概念，与str不同，字节串以字节序列值表达数据，更方便用来处理二进程数据。因此在python3中字节串是常见的二进制数据展现方式。</p>
<ul>
<li>普通的ascii编码字符串可以在前面加b转换为字节串，例如：b’hello’</li>
<li>字符串转换为字节串方法 ：str.encode()</li>
<li>字节串转换为字符串方法 : bytes.decode() </li>
</ul>
<h3 id="15-2-文件读写"><a href="#15-2-文件读写" class="headerlink" title="15.2 文件读写"></a>15.2 文件读写</h3><h4 id="（1）打开文件"><a href="#（1）打开文件" class="headerlink" title="（1）打开文件"></a>（1）打开文件</h4><ul>
<li><p><font color="red">file_object = open(file_name, access_mode=’r’, buffering=-1)</font></p>
</li>
<li><p>功能：打开一个文件，返回一个文件对象。</p>
</li>
<li><p>参数：</p>
<ul>
<li><p>file_name  文件名；</p>
</li>
<li><p>access_mode  打开文件的方式,如果不写默认为‘r’ </p>
<table>
<thead>
<tr>
<th align="center">文件模式</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">以读方式打开，文件必须存在</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">以写方式打开，文件不存在则会创建，存在则清空原有内容</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">以追加模式打开</td>
</tr>
<tr>
<td align="center">r+</td>
<td align="center">以读写模式打开，文件必须存在</td>
</tr>
<tr>
<td align="center">w+</td>
<td align="center">以读写模式打开，不存在则会创建，存在则清空原有内容</td>
</tr>
<tr>
<td align="center">a+</td>
<td align="center">以读写模式打开，追加模式</td>
</tr>
<tr>
<td align="center">rb</td>
<td align="center">以二进制读模式打开，同r</td>
</tr>
<tr>
<td align="center">wb</td>
<td align="center">以二进制写模式打开，同w</td>
</tr>
<tr>
<td align="center">ab</td>
<td align="center">以二进制追加模式打开，同a</td>
</tr>
<tr>
<td align="center">rb+</td>
<td align="center">以二进制读写模式打开，同r+</td>
</tr>
<tr>
<td align="center">wb+</td>
<td align="center">以二进制读写模式打开，同w+</td>
</tr>
<tr>
<td align="center">ab+</td>
<td align="center">以二进制读写模式打开，同a+</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li>buffering  1表示有行缓冲，默认则表示使用系统默认提供的缓冲机制。</li>
<li>返回值：成功返回文件操作对象。</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>加b的打开方式读写要求必须都是字节串</li>
<li>无论什么文件都可以使用二进制方式打开，但是二进制文件使用文本方式打开读写会出错</li>
</ul>
</li>
</ul>
<h4 id="（2）读取文件"><a href="#（2）读取文件" class="headerlink" title="（2）读取文件"></a>（2）读取文件</h4><ul>
<li><p>read([size])</p>
<ul>
<li>功能： 来直接读取文件中字符。</li>
<li>参数： 如果没有给定size参数（默认值为-1）或者size值为负，文件将被读取直至末尾，给定size最多读取给定数目个字符（字节）。</li>
<li>返回值： 返回读取到的内容</li>
<li>注意：文件过大时候不建议直接读取到文件结尾，读到文件结尾会返回空字符串。</li>
</ul>
</li>
<li><p>readline([size])</p>
<ul>
<li>功能： 指定的用来读取文件中一行</li>
<li>参数： 如果没有给定size参数（默认值为-1）或者size值为负，表示读取一行，给定size表示最多读取指定的字符（字节）。</li>
<li>返回值： 返回读取到的内容</li>
</ul>
</li>
<li><p>readlines([sizeint])</p>
<ul>
<li><p>功能： 读取文件中的每一行作为列表中的一项</p>
</li>
<li><p>参数： 如果没有给定size参数（默认值为-1）或者size值为负，文件将被读取直至末尾，给定size表示读取到size字符所在行为止。</p>
</li>
<li><p>返回值： 返回读取到的内容列表</p>
</li>
<li><p>文件对象本身也是一个可迭代对象，在for循环中可以迭代文件的每一行。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">     <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>

<h4 id="（3）写入文件"><a href="#（3）写入文件" class="headerlink" title="（3）写入文件"></a>（3）写入文件</h4><ul>
<li>write(string)<ul>
<li>功能: 把文本数据或二进制数据块的字符串写入到文件中去</li>
<li>参数：要写入的内容</li>
<li>如果需要换行要自己在写入内容中添加\n</li>
</ul>
</li>
<li>writelines(str_list)<ul>
<li>功能：接受一个字符串列表作为参数，将它们写入文件。</li>
<li>参数: 要写入的内容列表</li>
</ul>
</li>
</ul>
<h4 id="（4）关闭文件"><a href="#（4）关闭文件" class="headerlink" title="（4）关闭文件"></a>（4）关闭文件</h4><p>​    打开一个文件后我们就可以通过文件对象对文件进行操作了，当操作结束后使用close（）关闭这个对象可以防止一些误操作，也可以节省资源。</p>
<p>​    file_object.close()</p>
<h4 id="（5）with操作"><a href="#（5）with操作" class="headerlink" title="（5）with操作"></a>（5）with操作</h4><ul>
<li><p>Python中with语句使用于<font color="orange">对资源进行访问</font>的场合，保证不管处理过程中是否发生错误或者异常都会</p>
<p>执行规定的”清理“操作，释放被访问的资源，比如有文件读写后自动关闭、线程中锁自动获取和释放。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]:</span><br><span class="line">	<span class="keyword">with</span>-body</span><br></pre></td></tr></table></figure>
<ul>
<li>通过with方法可以不用close(),因为with生成的对象在语句块结束后会自动处理，所以也就不需要close了，但是这个文件对象只能在with语句块内使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file&#x27;</span>,<span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read()</span><br></pre></td></tr></table></figure>



<h3 id="15-2-其他操作"><a href="#15-2-其他操作" class="headerlink" title="15.2 其他操作"></a>15.2 其他操作</h3><h4 id="（1）刷新缓冲区"><a href="#（1）刷新缓冲区" class="headerlink" title="（1）刷新缓冲区"></a>（1）刷新缓冲区</h4><ul>
<li>缓冲:系统自动的在内存中为每一个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，再由缓冲区送到磁盘中去。从磁盘中读数据，则一次从磁盘文件将一批数据读入到内存缓冲区中，然后再从缓冲区将数据送到程序的数据区。</li>
</ul>
<ul>
<li><p>刷新缓冲区条件：</p>
<ul>
<li><p>缓冲区被写满</p>
</li>
<li><p>程序执行结束或者文件对象被关闭</p>
</li>
<li><p>行缓冲遇到换行</p>
</li>
<li><p>程序中调用flush()函数</p>
<ul>
<li>flush()<br>该函数调用后会进行一次磁盘交互，将缓冲区中的内容写入到磁盘。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（2）文件偏移量"><a href="#（2）文件偏移量" class="headerlink" title="（2）文件偏移量"></a>（2）文件偏移量</h4><ul>
<li><p>定义：打开一个文件进行操作时系统会自动生成一个记录，记录中描述了我们对文件的一系列操作。其中包括每次操作到的文件位置。文件的读写操作都是从这个位置开始进行的。</p>
</li>
<li><p>基本操作</p>
</li>
<li><p>tell()</p>
<ul>
<li>功能：获取文件偏移量大小</li>
</ul>
</li>
<li><p>seek(offset[,whence])</p>
<ul>
<li>功能:移动文件偏移量位置</li>
<li>参数：<ul>
<li>offset 代表相对于某个位置移动的字节数。负数表示向前移动，正数表示向后移动。</li>
<li>whence是基准位置的默认值为 0，代表从文件开头算起，1代表从当前位置算起，2 代表从文件末尾算起。</li>
<li>必须以二进制方式打开文件时基准位置才能是1或者2</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（3）文件描述符"><a href="#（3）文件描述符" class="headerlink" title="（3）文件描述符"></a>（3）文件描述符</h4><ul>
<li><p>定义：系统中每一个IO操作都会分配一个整数作为编号，该整数即这个IO操作的文件描述符。</p>
</li>
<li><p>获取文件描述符</p>
<ul>
<li>fileno()<br>通过IO对象获取对应的文件描述符</li>
</ul>
</li>
</ul>
<h3 id="15-3-文件管理函数"><a href="#15-3-文件管理函数" class="headerlink" title="15.3 文件管理函数"></a>15.3 文件管理函数</h3><ul>
<li><p>获取文件大小  </p>
<p>os.path.getsize(file)</p>
</li>
<li><p>查看文件列表  </p>
<p>os.listdir(dir)</p>
</li>
<li><p>查看文件是否存在</p>
<p>os.path.exists(file)</p>
</li>
<li><p>判断文件类型</p>
<p>os.path.isfile(file)</p>
</li>
<li><p>删除文件</p>
<p>os.remove(file)</p>
</li>
</ul>
<h2 id="16-网络编程"><a href="#16-网络编程" class="headerlink" title="16. 网络编程"></a>16. 网络编程</h2><p>计算机网络功能主要包括实现资源共享，实现数据信息的快速传递。</p>
<h3 id="16-1-网络编程基础"><a href="#16-1-网络编程基础" class="headerlink" title="16.1 网络编程基础"></a>16.1 网络编程基础</h3><h4 id="（1）OSI七层模型"><a href="#（1）OSI七层模型" class="headerlink" title="（1）OSI七层模型"></a>（1）OSI七层模型</h4><blockquote>
<p>制定组织： ISO（国际标准化组织）</p>
</blockquote>
<blockquote>
<p>作用：使网络通信工作流程标准化</p>
</blockquote>
<blockquote>
<p>应用层 ： 提供用户服务，具体功能由应用程序实现<br>表示层 ： 数据的压缩优化加密<br>会话层 ： 建立用户级的连接，选择适当的传输服务<br>传输层 ： 提供传输服务<br>网络层 ： 路由选择，网络互联<br>链路层 ： 进行数据交换，控制具体数据的发送<br>物理层 ： 提供数据传输的硬件保证，网卡接口，传输介质</p>
</blockquote>
<blockquote>
<p>优点 </p>
<ol>
<li>建立了统一的工作流程</li>
<li>分部清晰，各司其职，每个步骤分工明确</li>
<li>降低了各个模块之间的耦合度，便于开发</li>
</ol>
</blockquote>
<h4 id="（2）四层模型（TCP-IP模型）"><a href="#（2）四层模型（TCP-IP模型）" class="headerlink" title="（2）四层模型（TCP/IP模型）"></a>（2）四层模型（TCP/IP模型）</h4><p>背景 ： 实际工作中工程师无法完全按照七层模型要求操作，逐渐演化为更符合实际情况的四层</p>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_tcpip%E6%A8%A1%E5%9E%8B.png" alt="TCP/IP模型"></p>
<h5 id="1-gt-数据传输过程"><a href="#1-gt-数据传输过程" class="headerlink" title="1&gt; 数据传输过程"></a>1&gt; 数据传输过程</h5><ol>
<li>发送端由应用程序发送消息，逐层添加首部信息，最终在物理层发送消息包。</li>
<li>发送的消息经过多个节点（交换机，路由器）传输，最终到达目标主机。</li>
<li>目标主机由物理层逐层解析首部消息包，最终到应用程序呈现消息。</li>
</ol>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_TCP.png" alt="TCP/IP模型"></p>
<h5 id="2-gt-网络协议"><a href="#2-gt-网络协议" class="headerlink" title="2&gt; 网络协议"></a>2&gt; 网络协议</h5><blockquote>
<p>在网络数据传输中，都遵循的规定，包括建立什么样的数据结构，什么样的特殊标志等。</p>
</blockquote>
<h5 id="3-gt-网络基础概念"><a href="#3-gt-网络基础概念" class="headerlink" title="3&gt; 网络基础概念"></a>3&gt; 网络基础概念</h5><ul>
<li>IP地址</li>
</ul>
<blockquote>
<p>功能：确定一台主机的网络路由位置</p>
</blockquote>
<blockquote>
<p>查看本机网络地址命令： ifconfig</p>
</blockquote>
<blockquote>
<p>结构</p>
<blockquote>
<p>IPv4  点分十进制表示 172.40.91.185 每部分取值范围0–255<br>IPv6  128位 扩大了地址范围</p>
</blockquote>
</blockquote>
<ul>
<li>域名</li>
</ul>
<blockquote>
<p>定义： 给网络服务器地址起的名字</p>
</blockquote>
<blockquote>
<p>作用： 方便记忆，表达一定的含义</p>
</blockquote>
<blockquote>
<p>ping [ip] : 测试和某个主机是否联通</p>
</blockquote>
<ul>
<li>端口号（port）</li>
</ul>
<blockquote>
<p>作用：端口是网络地址的一部分，用于区分主机上不同的网络应用程序。</p>
</blockquote>
<blockquote>
<p>特点：一个系统中的应用监听端口不能重复</p>
</blockquote>
<blockquote>
<p>取值范围： 1 – 65535</p>
<blockquote>
<p>1–1023  系统应用或者大众程序监听端口<br>1024–65535 自用端口</p>
</blockquote>
</blockquote>
<h4 id="（3）传输层服务"><a href="#（3）传输层服务" class="headerlink" title="（3）传输层服务"></a>（3）传输层服务</h4><h5 id="1-gt-基于TCP协议的数据传输"><a href="#1-gt-基于TCP协议的数据传输" class="headerlink" title="1&gt;  基于TCP协议的数据传输"></a>1&gt;  基于TCP协议的数据传输</h5><ol>
<li>传输特征 ： 提供了可靠的数据传输，可靠性指数据传输过程中无丢失，无失序，无差错，无重复。</li>
<li>实现手段 ： 在通信前需要建立数据连接，通信结束要正常断开连接。</li>
<li>适用情况 ： 对数据传输准确性有明确要求，传数文件较大，需要确保可靠性的情况。比如：网页获取，文件下载，邮件收发。</li>
</ol>
<blockquote>
<p>三次握手（建立连接）</p>
<blockquote>
<p>客户端向服务器发送消息报文请求连接<br>服务器收到请求后，回复报文确定可以连接<br>客户端收到回复，发送最终报文连接建立</p>
</blockquote>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p>
<blockquote>
<p>四次挥手（断开连接）</p>
<blockquote>
<p>主动方发送报文请求断开连接<br>被动方收到请求后，立即回复，表示准备断开<br>被动方准备就绪，再次发送报文表示可以断开<br>主动方收到确定，发送最终报文完成断开</p>
</blockquote>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p>
<h5 id="2-gt-基于UDP协议的数据传输"><a href="#2-gt-基于UDP协议的数据传输" class="headerlink" title="2 &gt; 基于UDP协议的数据传输"></a>2 &gt; 基于UDP协议的数据传输</h5><ol>
<li>传输特点 ： 不保证传输的可靠性，传输过程没有连接和断开，数据收发自由随意。</li>
<li>适用情况 ： 网络较差，对传输可靠性要求不高。比如：网络视频，群聊，广播</li>
</ol>
<h3 id="16-2-socket套接字编程"><a href="#16-2-socket套接字编程" class="headerlink" title="16.2 socket套接字编程"></a>16.2 socket套接字编程</h3><h4 id="（1）套接字介绍"><a href="#（1）套接字介绍" class="headerlink" title="（1）套接字介绍"></a>（1）套接字介绍</h4><ol>
<li><p>套接字 ： 实现网络编程进行数据传输的一种技术手段</p>
</li>
<li><p>Python实现套接字编程：import  socket</p>
</li>
<li><p>套接字分类</p>
</li>
</ol>
<ul>
<li>流式套接字(<font color="red">SOCK_STREAM</font>): 以<strong>字节流</strong>方式传输数据，实现<strong>TCP</strong>网络传输方案。(面向连接–tcp协议–可靠的–流式套接字)</li>
</ul>
<ul>
<li>数据报套接字(<font color="red">SOCK_DGRAM</font>): 以<strong>数据报</strong>形式传输数据，实现<strong>UDP</strong>网络传输方案。(无连接–udp协议–不可靠–数据报套接字)</li>
</ul>
<h4 id="（2）tcp套接字编程"><a href="#（2）tcp套接字编程" class="headerlink" title="（2）tcp套接字编程"></a>（2）tcp套接字编程</h4><h5 id="1-gt-服务端流程"><a href="#1-gt-服务端流程" class="headerlink" title="1&gt; 服务端流程"></a>1&gt; 服务端流程</h5><p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_TCP_Server.png"></p>
<ol>
<li><strong>创建套接字</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd=socket.socket(socket_family=AF_INET,socket_type=SOCK_STREAM,proto=<span class="number">0</span>)</span><br><span class="line">功能：创建套接字</span><br><span class="line">参数：  </span><br><span class="line">	socket_family  网络地址类型 AF_INET表示ipv4</span><br><span class="line">	socket_type  套接字类型 SOCK_STREAM(流式)  SOCK_DGRAM(数据报式)</span><br><span class="line">	proto  通常为<span class="number">0</span>  选择子协议</span><br><span class="line">返回值： 套接字对象</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>绑定地址</strong></li>
</ol>
<blockquote>
<p>本地地址 ： ‘localhost’ , ‘127.0.0.1’<br>网络地址 ： ‘172.40.91.185’<br>自动获取地址： ‘0.0.0.0’</p>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/address.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.bind(addr)</span><br><span class="line">功能： 绑定本机网络地址</span><br><span class="line">参数： 二元元组 (ip,port)  (<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">8888</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>设置监听</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.listen(n)</span><br><span class="line">功能 ： 将套接字设置为监听套接字，确定监听队列大小</span><br><span class="line">参数 ： 监听队列大小</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>等待处理客户端连接请求</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">connfd,addr = sockfd.accept()</span><br><span class="line">功能： 阻塞等待处理客户端请求</span><br><span class="line">返回值： connfd  客户端连接套接字</span><br><span class="line">         addr  连接的客户端地址</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>消息收发</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = connfd.recv(buffersize)</span><br><span class="line">功能 : 接受客户端消息</span><br><span class="line">参数 ：每次最多接收消息的大小</span><br><span class="line">返回值： 接收到的内容</span><br><span class="line"></span><br><span class="line">n = connfd.send(data)</span><br><span class="line">功能 : 发送消息</span><br><span class="line">参数 ：要发送的内容  <span class="built_in">bytes</span>格式</span><br><span class="line">返回值： 发送的字节数</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>关闭套接字</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.close()</span><br><span class="line">功能：关闭套接字</span><br></pre></td></tr></table></figure>



<h5 id="2-gt-客户端流程"><a href="#2-gt-客户端流程" class="headerlink" title="2&gt; 客户端流程"></a>2&gt; 客户端流程</h5><p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_TCP_Client.png"></p>
<ol>
<li><strong>创建套接字</strong></li>
</ol>
<blockquote>
<p>注意:只有相同类型的套接字才能进行通信</p>
</blockquote>
<ol start="2">
<li><strong>请求连接</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.connect(server_addr)</span><br><span class="line">功能：连接服务器</span><br><span class="line">参数：元组  服务器地址</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>收发消息</strong></li>
</ol>
<blockquote>
<p>注意： 防止两端都阻塞，recv send要配合</p>
</blockquote>
<ol start="4">
<li><strong>关闭套接字</strong></li>
</ol>
<h5 id="3-gt-tcp-套接字数据传输特点"><a href="#3-gt-tcp-套接字数据传输特点" class="headerlink" title="3&gt; tcp 套接字数据传输特点"></a>3&gt; tcp 套接字数据传输特点</h5><ul>
<li><p>tcp连接中当一端退出，另一端如果阻塞在recv，此时recv会立即返回一个空字串。</p>
</li>
<li><p>tcp连接中如果一端已经不存在，仍然试图通过send发送则会产生BrokenPipeError</p>
</li>
<li><p>一个监听套接字可以同时连接多个客户端，也能够重复被连接</p>
</li>
</ul>
<h5 id="4-gt-网络收发缓冲区"><a href="#4-gt-网络收发缓冲区" class="headerlink" title="4&gt; 网络收发缓冲区"></a>4&gt; 网络收发缓冲区</h5><ol>
<li>网络缓冲区有效的协调了消息的收发速度</li>
<li>send和recv实际是向缓冲区发送接收消息，当缓冲区不为空recv就不会阻塞。</li>
</ol>
<h5 id="5-gt-tcp粘包"><a href="#5-gt-tcp粘包" class="headerlink" title="5&gt; tcp粘包"></a>5&gt; tcp粘包</h5><blockquote>
<p>原因：tcp以字节流方式传输，没有消息边界。多次发送的消息被一次接收，此时就会形成粘包。</p>
</blockquote>
<blockquote>
<p>影响：如果每次发送内容是一个独立的含义，需要接收端独立解析此时粘包会有影响。</p>
</blockquote>
<blockquote>
<p>处理方法</p>
<blockquote>
<ol>
<li>人为的添加消息边界</li>
<li>控制发送速度</li>
</ol>
</blockquote>
</blockquote>
<h4 id="（3）UDP套接字编程"><a href="#（3）UDP套接字编程" class="headerlink" title="（3）UDP套接字编程"></a>（3）UDP套接字编程</h4><h5 id="1-gt-服务端流程-1"><a href="#1-gt-服务端流程-1" class="headerlink" title="1&gt; 服务端流程"></a>1&gt; 服务端流程</h5><p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_UDP_Server.png"></p>
<ol>
<li>创建数据报套接字</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd = socket(AF_INET,SOCK_DGRAM)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>绑定地址</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.bind(addr)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>消息收发</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data,addr = sockfd.recvfrom(buffersize)</span><br><span class="line">功能： 接收UDP消息</span><br><span class="line">参数： 每次最多接收多少字节</span><br><span class="line">返回值： data  接收到的内容</span><br><span class="line">	addr  消息发送方地址</span><br><span class="line"></span><br><span class="line">n = sockfd.sendto(data,addr)</span><br><span class="line">功能： 发送UDP消息</span><br><span class="line">参数： data  发送的内容 <span class="built_in">bytes</span>格式</span><br><span class="line">	addr  目标地址</span><br><span class="line">返回值：发送的字节数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>关闭套接字</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure>



<h5 id="2-gt-客户端流程-1"><a href="#2-gt-客户端流程-1" class="headerlink" title="2&gt; 客户端流程"></a>2&gt; 客户端流程</h5><p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_UDP_Client.png"></p>
<ol>
<li>创建套接字</li>
<li>收发消息</li>
<li>关闭套接字</li>
</ol>
<hr>
<blockquote>
<p>总结 ：tcp套接字和udp套接字编程区别</p>
<blockquote>
<ol>
<li>流式套接字是以字节流方式传输数据，数据报套接字以数据报形式传输</li>
<li>tcp套接字会有粘包，udp套接字有消息边界不会粘包</li>
<li>tcp套接字保证消息的完整性，udp套接字则不能</li>
<li>tcp套接字依赖listen accept建立连接才能收发消息，udp套接字则不需要</li>
<li>tcp套接字使用send，recv收发消息，udp套接字使用sendto，recvfrom</li>
</ol>
</blockquote>
</blockquote>
<hr>
<h4 id="（4）socket套接字属性"><a href="#（4）socket套接字属性" class="headerlink" title="（4）socket套接字属性"></a>（4）socket套接字属性</h4><ul>
<li><p>sockfd.type  套接字类型</p>
</li>
<li><p> sockfd.family 套接字地址类型</p>
</li>
<li><p> sockfd.getsockname() 获取套接字绑定地址</p>
</li>
</ul>
<ul>
<li>sockfd.fileno() 获取套接字的文件描述符</li>
</ul>
<ul>
<li>sockfd.getpeername() 获取连接套接字客户端地址</li>
</ul>
<ul>
<li> sockfd.setsockopt(level,option,value)</li>
<li>功能：设置套接字选项</li>
<li>参数： level  选项类别   SOL_SOCKET<pre><code>        option 具体选项内容
              value  选项值
</code></pre>
</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_setsockopt.png"></p>
<h3 id="16-3-struct模块进行数据打包"><a href="#16-3-struct模块进行数据打包" class="headerlink" title="16.3 struct模块进行数据打包"></a>16.3 struct模块进行数据打包</h3><ol>
<li>原理： 将一组简单数据进行打包，转换为bytes格式发送。或者将一组bytes格式数据，进行解析。</li>
<li>接口使用</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Struct(fmt)</span><br><span class="line">功能: 生成结构化对象</span><br><span class="line">参数：fmt  定制的数据结构</span><br><span class="line"></span><br><span class="line">st.pack(v1,v2,v3....)</span><br><span class="line">功能: 将一组数据按照指定格式打包转换为<span class="built_in">bytes</span></span><br><span class="line">参数：要打包的数据</span><br><span class="line">返回值： <span class="built_in">bytes</span>字节串</span><br><span class="line"></span><br><span class="line">st.unpack(bytes_data)</span><br><span class="line">功能： 将<span class="built_in">bytes</span>字节串按照指定的格式解析</span><br><span class="line">参数： 要解析的 <span class="built_in">bytes</span>字节串</span><br><span class="line">返回值： 解析后的内容</span><br><span class="line"></span><br><span class="line">struct.pack(fmt,v1,v2,v3...)</span><br><span class="line">struct.unpack(fmt,bytes_data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明： 可以使用struct模块直接调用pack unpack。此时这两函数第一个参数传入fmt。其他用法功能相同</p>
</blockquote>
<h3 id="16-4-HTTP传输"><a href="#16-4-HTTP传输" class="headerlink" title="16.4 HTTP传输"></a>16.4 HTTP传输</h3><h4 id="（1）HTTP协议-（超文本传输协议）"><a href="#（1）HTTP协议-（超文本传输协议）" class="headerlink" title="（1）HTTP协议 （超文本传输协议）"></a>（1）HTTP协议 （超文本传输协议）</h4><ol>
<li><p>用途 ： 网页获取，数据的传输</p>
</li>
<li><p>特点</p>
</li>
</ol>
<blockquote>
<ul>
<li>应用层协议，传输层使用<strong>tcp</strong>传输</li>
<li>简单，灵活，很多语言都有HTTP专门接口</li>
<li>无状态，协议不记录传输内容</li>
<li>http1.1 支持持久连接，丰富了请求类型</li>
</ul>
</blockquote>
<ol start="3">
<li>网页请求过程</li>
</ol>
<blockquote>
<p>1.客户端（浏览器）通过tcp传输，发送http请求给服务端<br>2.服务端接收到http请求后进行解析<br>3.服务端处理请求内容，组织响应内容<br>4.服务端将响应内容以http响应格式发送给浏览器<br>5.浏览器接收到响应内容，解析展示</p>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE.png"></p>
<h4 id="（2）HTTP请求（request）"><a href="#（2）HTTP请求（request）" class="headerlink" title="（2）HTTP请求（request）"></a>（2）HTTP请求（request）</h4><ul>
<li>请求行 ： 具体的请求类别和请求内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET         /        HTTP/1.1</span><br><span class="line">请求类别   请求内容     协议版本</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求类别：每个请求类别表示要做不同的事情 </span><br><span class="line">		GET : 获取网络资源</span><br><span class="line">		POST ：提交一定的信息，得到反馈</span><br><span class="line">		HEAD ： 只获取网络资源的响应头</span><br><span class="line">		PUT ： 更新服务器资源</span><br><span class="line">		DELETE ： 删除服务器资源</span><br><span class="line">		CONNECT</span><br><span class="line">		TRACE ： 测试</span><br><span class="line">		OPTIONS ： 获取服务器性能信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>请求头：对请求的进一步解释和描述</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip</span><br></pre></td></tr></table></figure>

<ul>
<li>空行</li>
<li>请求体: 请求参数或者提交内容</li>
</ul>
<h4 id="（3）http响应（response）"><a href="#（3）http响应（response）" class="headerlink" title="（3）http响应（response）"></a>（3）http响应（response）</h4><ol>
<li>响应格式：响应行，响应头，空行，响应体</li>
</ol>
<ul>
<li>响应行 ： 反馈基本的响应情况</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1     200       OK</span><br><span class="line">版本信息    响应码   附加信息</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">响应码 ： </span><br><span class="line">	1xx  提示信息，表示请求被接收</span><br><span class="line">	2xx  响应成功</span><br><span class="line">	3xx  响应需要进一步操作，重定向</span><br><span class="line">	4xx  客户端错误</span><br><span class="line">	5xx  服务器错误</span><br></pre></td></tr></table></figure>

<ul>
<li>响应头：对响应内容的描述</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>

<ul>
<li>响应体：响应的主体内容信息</li>
</ul>
<h2 id="17-并发编程"><a href="#17-并发编程" class="headerlink" title="17. 并发编程"></a>17. 并发编程</h2><h3 id="17-1-多任务编程"><a href="#17-1-多任务编程" class="headerlink" title="17.1 多任务编程"></a>17.1 多任务编程</h3><ol>
<li>意义： 充分利用计算机CPU的多核资源，同时处理多个应用程序任务，以此提高程序的运行效率。</li>
<li>实现方案 ：多进程 ， 多线程</li>
</ol>
<h3 id="17-2-进程（process）"><a href="#17-2-进程（process）" class="headerlink" title="17.2 进程（process）"></a>17.2 进程（process）</h3><h4 id="（1）进程理论基础"><a href="#（1）进程理论基础" class="headerlink" title="（1）进程理论基础"></a>（1）进程理论基础</h4><ol>
<li><h5 id="定义-：-程序在计算机中的一次运行。"><a href="#定义-：-程序在计算机中的一次运行。" class="headerlink" title="定义 ： 程序在计算机中的一次运行。"></a>定义 ： 程序在计算机中的一次运行。</h5><ul>
<li>程序是一个可执行的文件，是静态的占有磁盘。</li>
<li>进程是一个动态的过程描述，占有计算机运行资源，有一定的生命周期。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><h5 id="系统中如何产生一个进程"><a href="#系统中如何产生一个进程" class="headerlink" title="系统中如何产生一个进程"></a>系统中如何产生一个进程</h5><p>【1】 用户空间通过调用程序接口或者命令发起请求<br>【2】 操作系统接收用户请求，开始创建进程<br>【3】 操作系统调配计算机资源，确定进程状态等<br>【4】 操作系统将创建的进程提供给用户使用</p>
</li>
</ol>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux.png"></p>
<ol start="3">
<li><h5 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h5></li>
</ol>
<ul>
<li><p>cpu时间片：如果一个进程占有<strong>cpu内核</strong>则称这个进程在cpu时间片上。</p>
</li>
<li><p>PCB(进程控制块)：在内存中开辟的一块空间，用于存放<strong>进程的基本信息</strong>，也用于系统查找识别进程。</p>
</li>
<li><p>进程ID（PID）： 系统为每个进程分配的一个大于0的整数，作为进程ID。每个进程ID不重复。</p>
<blockquote>
<p>Linux查看进程ID ： ps -aux</p>
</blockquote>
</li>
<li><p>父子进程 ： 系统中每一个进程(除了系统初始化进程)都有唯一的父进程，可以有0个或多个子进程。父子进程关系便于进程管理。</p>
<blockquote>
<p>查看进程树： pstree</p>
</blockquote>
</li>
<li><p>进程状态</p>
<ul>
<li>三态<br>就绪态 ： 进程具备执行条件，等待分配cpu资源<br>运行态 ： 进程占有cpu时间片正在运行<br>等待态 ： 进程暂时停止运行，让出cpu</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4_3%E6%80%81.png"></p>
<ul>
<li>五态 (在三态基础上增加新建和终止)<br>新建 ： 创建一个进程，获取资源的过程<br>终止 ： 进程结束，释放资源的过程</li>
</ul>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4_5%E6%80%81.png"></p>
<ul>
<li>状态查看命令 ： ps -aux  –&gt; STAT列</li>
</ul>
<blockquote>
<pre><code>           S 等待态
           R 执行态
           Z 僵尸

           \+ 前台进程
           l   有多线程的
</code></pre>
</blockquote>
<ul>
<li>进程的运行特征<br>【1】 多进程可以更充分使用计算机多核资源<br>【2】 进程之间的运行互不影响，各自独立<br>【3】 每个进程拥有独立的空间，各自使用自己空间资源</li>
</ul>
<h3 id="17-3-基于fork的多进程编程"><a href="#17-3-基于fork的多进程编程" class="headerlink" title="17.3 基于fork的多进程编程"></a>17.3 基于fork的多进程编程</h3><h4 id="（1）fork使用"><a href="#（1）fork使用" class="headerlink" title="（1）fork使用"></a>（1）fork使用</h4><blockquote>
<p>pid = os.fork()<br>    功能： 创建新的进程<br>    返回值：整数，如果创建进程失败返回一个负数，如果成功则在原有进程中返回新进程的PID，在新进程中返回0</p>
</blockquote>
<blockquote>
<p>注意</p>
<blockquote>
<ul>
<li>子进程会复制父进程全部内存空间，从fork下一句开始执行。</li>
<li>父子进程各自独立运行，运行顺序不一定。</li>
<li>利用父子进程fork返回值的区别，配合if结构让父子进程执行不同的内容几乎是固定搭配。</li>
<li>父子进程有各自特有特征比如PID PCB 命令集等。</li>
<li>父进程fork之前开辟的空间子进程同样拥有，父子进程对各自空间的操作不会相互影响。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="（2）进程相关函数"><a href="#（2）进程相关函数" class="headerlink" title="（2）进程相关函数"></a>（2）进程相关函数</h4><blockquote>
<p>os.getpid()<br>       功能： 获取一个进程的PID值<br>       返回值： 返回当前进程的PID </p>
</blockquote>
<blockquote>
<p>os.getppid()<br>       功能： 获取父进程的PID号<br>       返回值： 返回父进程PID</p>
</blockquote>
<blockquote>
<p>os._exit(status)<br>       功能: 结束一个进程<br>       参数：进程的终止状态</p>
</blockquote>
<blockquote>
<p>sys.exit([status])<br>       功能：退出进程<br>       参数：整数 表示退出状态<br>                   字符串 表示退出时打印内容</p>
</blockquote>
<h4 id="（3）孤儿和僵尸"><a href="#（3）孤儿和僵尸" class="headerlink" title="（3）孤儿和僵尸"></a>（3）孤儿和僵尸</h4><ol>
<li>孤儿进程 ： 父进程先于子进程退出，此时子进程成为孤儿进程。</li>
</ol>
<blockquote>
<p>特点： 孤儿进程会被系统进程收养，此时系统进程就会成为孤儿进程新的父进程，孤儿进程退出该进程会自动处理。</p>
</blockquote>
<ol start="2">
<li>僵尸进程 ： 子进程先于父进程退出，父进程又没有处理子进程的退出状态，此时子进程就会称为僵尸进程。</li>
</ol>
<blockquote>
<p>特点： 僵尸进程虽然结束，但是会存留部分PCB在内存中，大量的僵尸进程会浪费系统的内存资源。</p>
</blockquote>
<ol start="3">
<li>如何避免僵尸进程产生</li>
</ol>
<ul>
<li>使用wait函数处理子进程退出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pid,status = os.wait()</span><br><span class="line">功能：在父进程中阻塞等待处理子进程退出</span><br><span class="line">返回值： pid  退出的子进程的PID</span><br><span class="line">		status  子进程退出状态</span><br></pre></td></tr></table></figure>


<ul>
<li><p>创建二级子进程处理僵尸</p>
<p>【1】 父进程创建子进程，等待回收子进程<br>【2】 子进程创建二级子进程然后退出<br>【3】 二级子进程称为孤儿，和原来父进程一同执行事件</p>
</li>
</ul>
<ul>
<li><p>通过信号处理子进程退出</p>
<blockquote>
<p>原理： 子进程退出时会发送信号给父进程，如果父进程忽略子进程信号，则系统就会自动处理子进程退出。</p>
</blockquote>
<blockquote>
<p>方法： 使用signal模块在父进程创建子进程前写如下语句 ：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> signal</span><br><span class="line">signal.signal(signal.SIGCHLD,signal.SIG_IGN)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点 ： 非阻塞，不会影响父进程运行。可以处理所有子进程退出</p>
</blockquote>
</li>
</ul>
<h4 id="（4）群聊聊天室"><a href="#（4）群聊聊天室" class="headerlink" title="（4）群聊聊天室"></a>（4）群聊聊天室</h4><blockquote>
<p>功能 ： 类似qq群功能<br>【1】 有人进入聊天室需要输入姓名，姓名不能重复<br>【2】 有人进入聊天室时，其他人会收到通知：xxx 进入了聊天室<br>【3】 一个人发消息，其他人会收到：xxx ： xxxxxxxxxxx<br>【4】 有人退出聊天室，则其他人也会收到通知:xxx退出了聊天室<br>【5】 扩展功能：服务器可以向所有用户发送公告:管理员消息： xxxxxxxxx</p>
</blockquote>
<h3 id="17-4-multiprocessing-模块创建进程"><a href="#17-4-multiprocessing-模块创建进程" class="headerlink" title="17.4 multiprocessing 模块创建进程"></a>17.4 multiprocessing 模块创建进程</h3><h4 id="（1）进程创建方法"><a href="#（1）进程创建方法" class="headerlink" title="（1）进程创建方法"></a>（1）进程创建方法</h4><ol>
<li><h5 id="流程特点"><a href="#流程特点" class="headerlink" title="流程特点"></a>流程特点</h5><p> 【1】 将需要子进程执行的事件封装为函数<br> 【2】 通过模块的Process类创建进程对象，关联函数<br> 【3】 可以通过进程对象设置进程信息及属性<br> 【4】 通过进程对象调用start启动进程<br> 【5】 通过进程对象调用join回收进程</p>
</li>
<li><h5 id="基本接口使用"><a href="#基本接口使用" class="headerlink" title="基本接口使用"></a>基本接口使用</h5></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Process()</span><br><span class="line">功能 ： 创建进程对象</span><br><span class="line">参数 ： target 绑定要执行的目标函数 </span><br><span class="line">	args 元组，用于给target函数位置传参</span><br><span class="line">	kwargs 字典，给target函数键值传参</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.start()</span><br><span class="line">功能 ： 启动进程</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:启动进程此时target绑定函数开始执行，该函数作为子进程执行内容，此时进程真正被创建</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.join([timeout])</span><br><span class="line">功能：阻塞等待回收进程</span><br><span class="line">参数：超时时间</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<blockquote>
<ul>
<li>使用multiprocessing创建进程同样是子进程复制父进程空间代码段，父子进程运行互不影响。</li>
<li>子进程只运行target绑定的函数部分，其余内容均是父进程执行内容。</li>
<li>multiprocessing中父进程往往只用来创建子进程、回收子进程，具体事件由子进程完成。</li>
<li>multiprocessing创建的子进程中无法使用标准输入</li>
</ul>
</blockquote>
</blockquote>
<ol start="3">
<li><h5 id="进程对象属性"><a href="#进程对象属性" class="headerlink" title="进程对象属性"></a>进程对象属性</h5></li>
</ol>
<blockquote>
<p>p.name  进程名称</p>
</blockquote>
<blockquote>
<p>p.pid   对应子进程的PID号</p>
</blockquote>
<blockquote>
<p>p.is_alive() 查看子进程是否在生命周期</p>
</blockquote>
<blockquote>
<p>p.daemon  设置父子进程的退出关系  </p>
<blockquote>
<ul>
<li>如果设置为True则子进程会随父进程的退出而结束</li>
<li>要求必须在start()前设置</li>
<li>如果daemon设置成True 通常就不会使用 join()</li>
</ul>
</blockquote>
</blockquote>
<h4 id="（2）自定义进程类"><a href="#（2）自定义进程类" class="headerlink" title="（2）自定义进程类"></a>（2）自定义进程类</h4><ol>
<li><h5 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h5><p>【1】 继承Process类<br>【2】 重写<code>__init__</code>方法添加自己的属性，使用super()加载父类属性<br>【3】 重写run()方法</p>
</li>
<li><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>【1】 实例化对象<br>【2】 调用start自动执行run方法<br>【3】 调用join回收进程</p>
</li>
</ol>
<h4 id="（3）进程池实现"><a href="#（3）进程池实现" class="headerlink" title="（3）进程池实现"></a>（3）进程池实现</h4><ol>
<li><h5 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h5><p>   【1】 进程的创建和销毁过程消耗的资源较多<br>   【2】 当任务量众多，每个任务在很短时间内完成时，需要频繁的创建和销毁进程。此时对计算机压力较大<br>   【3】 进程池技术很好的解决了以上问题。</p>
</li>
<li><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5></li>
</ol>
<blockquote>
<p>创建一定数量的进程来处理事件，事件处理完进程不退出而是继续处理其他事件，直到所有事件全都处理完毕统一销毁。增加进程的重复利用，降低资源消耗。</p>
</blockquote>
<ol start="3">
<li><h5 id="进程池实现过程"><a href="#进程池实现过程" class="headerlink" title="进程池实现过程"></a>进程池实现过程</h5></li>
</ol>
<p>【1】 创建进程池对象，放入适当的进程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line">Pool(processes)</span><br><span class="line">功能： 创建进程池对象</span><br><span class="line">参数： 指定进程数量，默认根据系统自动判定</span><br></pre></td></tr></table></figure>

<p>【2】 将事件加入进程池队列执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool.apply_async(func,args,kwds)</span><br><span class="line">功能: 使用进程池执行func事件</span><br><span class="line">参数： func 事件函数</span><br><span class="line">      args 元组  给func按位置传参</span><br><span class="line">      kwds 字典  给func按照键值传参</span><br><span class="line">返回值： 返回函数事件对象</span><br></pre></td></tr></table></figure>

<p>【3】 关闭进程池</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool.close()</span><br><span class="line">功能： 关闭进程池</span><br></pre></td></tr></table></figure>

<p>【4】 回收进程池中进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pool.join()</span><br><span class="line">功能： 回收进程池中进程</span><br></pre></td></tr></table></figure>



<h3 id="17-5-进程间通信（IPC）"><a href="#17-5-进程间通信（IPC）" class="headerlink" title="17.5 进程间通信（IPC）"></a>17.5 进程间通信（IPC）</h3><ol>
<li>必要性： 进程间<strong>空间独立，资源不共享</strong>，此时在需要进程间数据传输时就需要特定的手段进行数据通信。</li>
</ol>
<ol start="2">
<li>常用进程间通信方法</li>
</ol>
<blockquote>
<p>管道  消息队列  共享内存  信号  信号量  套接字 </p>
</blockquote>
<h4 id="（1）管道通信-Pipe"><a href="#（1）管道通信-Pipe" class="headerlink" title="（1）管道通信(Pipe)"></a>（1）管道通信(Pipe)</h4><ol>
<li><h5 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h5></li>
</ol>
<blockquote>
<p>在内存中开辟管道空间，生成管道操作对象，多个进程使用同一个管道对象进行读写即可实现通信</p>
</blockquote>
<ol start="2">
<li><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  multiprocessing <span class="keyword">import</span> Pipe</span><br><span class="line"></span><br><span class="line">fd1,fd2 = Pipe(duplex = <span class="literal">True</span>)</span><br><span class="line">功能: 创建管道</span><br><span class="line">参数：默认表示双向管道</span><br><span class="line">如果为<span class="literal">False</span> 表示单向管道</span><br><span class="line">返回值：表示管道两端的读写对象</span><br><span class="line">	  如果是双向管道均可读写</span><br><span class="line">	  如果是单向管道fd1只读  fd2只写</span><br><span class="line"></span><br><span class="line">fd.recv()</span><br><span class="line">功能 ： 从管道获取内容</span><br><span class="line">返回值：获取到的数据</span><br><span class="line"></span><br><span class="line">fd.send(data)</span><br><span class="line">功能： 向管道写入内容</span><br><span class="line">参数： 要写入的数据</span><br></pre></td></tr></table></figure>



<h4 id="（2）消息队列"><a href="#（2）消息队列" class="headerlink" title="（2）消息队列"></a>（2）消息队列</h4><ol>
<li>通信原理</li>
</ol>
<blockquote>
<p>在内存中建立队列模型，进程通过队列将消息存入，或者从队列取出完成进程间通信。</p>
</blockquote>
<ol start="2">
<li>实现方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = Queue(maxsize=<span class="number">0</span>)</span><br><span class="line">功能: 创建队列对象</span><br><span class="line">参数：最多存放消息个数</span><br><span class="line">返回值：队列对象</span><br><span class="line"></span><br><span class="line">q.put(data,[block,timeout])</span><br><span class="line">功能：向队列存入消息</span><br><span class="line">参数：data  要存入的内容</span><br><span class="line">block  设置是否阻塞 <span class="literal">False</span>为非阻塞</span><br><span class="line">timeout  超时检测</span><br><span class="line"></span><br><span class="line">q.get([block,timeout])</span><br><span class="line">功能：从队列取出消息</span><br><span class="line">参数：block  设置是否阻塞 <span class="literal">False</span>为非阻塞</span><br><span class="line">timeout  超时检测</span><br><span class="line">返回值： 返回获取到的内容</span><br><span class="line"></span><br><span class="line">q.full()   判断队列是否为满</span><br><span class="line">q.empty()  判断队列是否为空</span><br><span class="line">q.qsize()  获取队列中消息个数</span><br><span class="line">q.close()  关闭队列</span><br></pre></td></tr></table></figure>



<h4 id="（3）共享内存"><a href="#（3）共享内存" class="headerlink" title="（3）共享内存"></a>（3）共享内存</h4><ol>
<li><h5 id="通信原理："><a href="#通信原理：" class="headerlink" title="通信原理："></a>通信原理：</h5><p>在内中开辟一块空间，进程可以写入内容和读取内容完成通信，但是每次写入内容会覆盖之前内容。</p>
</li>
<li><h5 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h5></li>
</ol>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6_ctype.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Value,Array</span><br><span class="line"></span><br><span class="line">obj = Value(ctype,data)</span><br><span class="line">功能 ： 开辟共享内存</span><br><span class="line">参数 ： ctype  表示共享内存空间类型 <span class="string">&#x27;i&#x27;</span>  <span class="string">&#x27;f&#x27;</span>  <span class="string">&#x27;c&#x27;</span></span><br><span class="line">       data   共享内存空间初始数据</span><br><span class="line">返回值：共享内存对象</span><br><span class="line"></span><br><span class="line">obj.value  对该属性的修改查看即对共享内存读写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Array(ctype,data)</span><br><span class="line">功能： 开辟共享内存空间</span><br><span class="line">参数： ctype  表示共享内存数据类型</span><br><span class="line">      data   整数则表示开辟空间的大小，其他数据类型表示开辟空间存放的初始化数据</span><br><span class="line">返回值：共享内存对象</span><br><span class="line"></span><br><span class="line">Array共享内存读写： 通过遍历obj可以得到每个值，直接可以通过索引序号修改任意值。</span><br><span class="line"></span><br><span class="line">* 可以使用obj.value直接打印共享内存中的字节串</span><br></pre></td></tr></table></figure>



<h4 id="（4）信号量（信号灯集）"><a href="#（4）信号量（信号灯集）" class="headerlink" title="（4）信号量（信号灯集）"></a>（4）信号量（信号灯集）</h4><ol>
<li>通信原理</li>
</ol>
<blockquote>
<p>给定一个数量对多个进程可见。多个进程都可以操作该数量增减，并根据数量值决定自己的行为。</p>
</blockquote>
<ol start="2">
<li>实现方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Semaphore</span><br><span class="line"></span><br><span class="line">sem = Semaphore(num)</span><br><span class="line">功能 ： 创建信号量对象</span><br><span class="line">参数 ： 信号量的初始值</span><br><span class="line">返回值 ： 信号量对象</span><br><span class="line"></span><br><span class="line">sem.acquire()  将信号量减<span class="number">1</span> 当信号量为<span class="number">0</span>时阻塞</span><br><span class="line">sem.release()  将信号量加<span class="number">1</span></span><br><span class="line">sem.get_value() 获取信号量数量</span><br></pre></td></tr></table></figure>



<h3 id="17-6-线程编程（Thread）"><a href="#17-6-线程编程（Thread）" class="headerlink" title="17.6 线程编程（Thread）"></a>17.6 线程编程（Thread）</h3><h4 id="（1）线程基本概念"><a href="#（1）线程基本概念" class="headerlink" title="（1）线程基本概念"></a>（1）线程基本概念</h4><ol>
<li><p>什么是线程<br>【1】 线程被称为轻量级的进程<br>【2】 线程也可以使用计算机多核资源，是多任务编程方式<br>【3】 线程是系统分配内核的最小单元<br>【4】 线程可以理解为<strong>进程的分支任务</strong></p>
</li>
<li><p>线程特征<br>【1】 一个进程中可以包含多个线程<br>【2】 线程也是一个运行行为，消耗计算机资源<br>【3】 一个进程中的所有线程<strong>共享这个进程的资源</strong><br>【4】 多个线程之间的运行互不影响各自运行<br>【5】 线程的创建和销毁消耗资源远小于进程<br>【6】 各个线程也有自己的ID等特征</p>
</li>
</ol>
<h4 id="（2）threading模块创建线程"><a href="#（2）threading模块创建线程" class="headerlink" title="（2）threading模块创建线程"></a>（2）threading模块创建线程</h4><p>【1】 创建线程对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Thread </span><br><span class="line"></span><br><span class="line">t = Thread()</span><br><span class="line">功能：创建线程对象</span><br><span class="line">参数：target 绑定线程函数</span><br><span class="line">     args   元组 给线程函数位置传参</span><br><span class="line">     kwargs 字典 给线程函数键值传参</span><br></pre></td></tr></table></figure>

<p>【2】 启动线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<p>【3】 回收线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.join([timeout])</span><br></pre></td></tr></table></figure>



<h4 id="（3）线程对象属性"><a href="#（3）线程对象属性" class="headerlink" title="（3）线程对象属性"></a>（3）线程对象属性</h4><blockquote>
<p>t.name 线程名称<br>t.setName()  设置线程名称<br>t.getName()  获取线程名称</p>
</blockquote>
<blockquote>
<p>t.is_alive()  查看线程是否在生命周期</p>
</blockquote>
<blockquote>
<p>t.daemon  设置主线程和分支线程的退出关系<br>t.setDaemon()  设置daemon属性值<br>t.isDaemon()  查看daemon属性值</p>
<blockquote>
<p>daemon为True时主线程退出分支线程也退出。要在start前设置，通常不和join一起使用。</p>
</blockquote>
</blockquote>
<h4 id="（4）自定义线程类"><a href="#（4）自定义线程类" class="headerlink" title="（4）自定义线程类"></a>（4）自定义线程类</h4><ol>
<li><p>创建步骤<br>【1】 继承Thread类<br>【2】 重写<code>__init__</code>方法添加自己的属性，使用super()加载父类属性<br>【3】 重写run()方法</p>
</li>
<li><p>使用方法<br>【1】 实例化对象<br>【2】 调用start自动执行run方法<br>【3】 调用join回收线程</p>
</li>
</ol>
<h3 id="17-7-同步互斥"><a href="#17-7-同步互斥" class="headerlink" title="17.7 同步互斥"></a>17.7 同步互斥</h3><h4 id="（1）线程间通信方法"><a href="#（1）线程间通信方法" class="headerlink" title="（1）线程间通信方法"></a>（1）线程间通信方法</h4><ol>
<li>通信方法</li>
</ol>
<blockquote>
<p>线程间使用全局变量进行通信</p>
</blockquote>
<ol start="2">
<li>共享资源争夺</li>
</ol>
<ul>
<li><p>共享资源：多个进程或者线程都可以操作的资源称为共享资源。对共享资源的操作代码段称为<strong>临界区</strong>。</p>
</li>
<li><p>影响 ： 对共享资源的无序操作可能会带来数据的混乱，或者操作错误。此时往往<strong>需要同步互斥机制协调操作顺序</strong>。</p>
</li>
</ul>
<ol start="3">
<li>同步互斥机制</li>
</ol>
<blockquote>
<p>同步 ： 同步是一种协作关系，为完成操作，多进程或者线程间形成一种协调，<strong>按照必要的步骤有序执行操作</strong>。</p>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7_%E5%90%8C%E6%AD%A5.png"></p>
<blockquote>
<p>互斥 ： 互斥是一种制约关系，当一个进程或者线程<strong>占有资源时会进行加锁处理</strong>，此时其他进程线程就无法操作该资源，直到解锁后才能操作。</p>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7_%E4%BA%92%E6%96%A5.png"></p>
<h4 id="（2）线程同步互斥方法"><a href="#（2）线程同步互斥方法" class="headerlink" title="（2）线程同步互斥方法"></a>（2）线程同步互斥方法</h4><h5 id="1-gt-线程Event"><a href="#1-gt-线程Event" class="headerlink" title="1&gt; 线程Event"></a>1&gt; 线程Event</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event</span><br><span class="line"></span><br><span class="line">e = Event()  创建线程event对象</span><br><span class="line"></span><br><span class="line">e.wait([timeout])  阻塞等待e被<span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">e.<span class="built_in">set</span>()  设置e，使wait结束阻塞</span><br><span class="line"></span><br><span class="line">e.clear() 使e回到未被设置状态</span><br><span class="line"></span><br><span class="line">e.is_set()  查看当前e是否被设置</span><br></pre></td></tr></table></figure>

<h5 id="2-gt-线程锁-Lock"><a href="#2-gt-线程锁-Lock" class="headerlink" title="2&gt; 线程锁 Lock"></a>2&gt; 线程锁 Lock</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line">lock = Lock()  创建锁对象</span><br><span class="line">lock.acquire() 上锁  如果lock已经上锁再调用会阻塞</span><br><span class="line">lock.release() 解锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>  lock:  上锁</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">	 <span class="keyword">with</span>代码块结束自动解锁</span><br></pre></td></tr></table></figure>



<h4 id="（3）死锁及其处理"><a href="#（3）死锁及其处理" class="headerlink" title="（3）死锁及其处理"></a>（3）死锁及其处理</h4><ol>
<li><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5></li>
</ol>
<blockquote>
<p>死锁是指两个或两个以上的线程在执行过程中，由于<strong>竞争资源或者由于彼此通信</strong>而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p>
</blockquote>
<p><img src="/2022/06/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%AD%BB%E9%94%81.jpg"></p>
<ol start="2">
<li><h5 id="死锁产生条件"><a href="#死锁产生条件" class="headerlink" title="死锁产生条件"></a>死锁产生条件</h5></li>
</ol>
<blockquote>
<p>死锁发生的必要条件</p>
<blockquote>
<ul>
<li><font color="red">互斥条件</font>：指线程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li><font color="red">请求和保持条件</font>：指线程已经保持至少一个资源，但又提出了新的资源<strong>请求</strong>，而该资源已被其它进程占有，此时请求线程阻塞，但又对自己已获得的其它资源<strong>保持不放</strong>。</li>
<li><font color="red">不剥夺条件</font>：指线程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放,通常CPU内存资源是可以被系统强行调配剥夺的。</li>
<li><font color="red">环路等待条件</font>：指在发生死锁时，必然存在一个线程——资源的环形链，即进程集合{T0，T1，T2，···，Tn}中的T0正在等待一个T1占用的资源；T1正在等待T2占用的资源，……，Tn正在等待已被T0占用的资源。</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p>死锁的产生原因</p>
<blockquote>
<p>简单来说造成死锁的原因可以概括成三句话：</p>
<ul>
<li>当前线程拥有其他线程需要的资源</li>
<li>当前线程等待其他线程已拥有的资源</li>
<li>都不放弃自己拥有的资源</li>
</ul>
</blockquote>
</blockquote>
<ol start="3">
<li><p>如何避免死锁</p>
<p>死锁是我们非常不愿意看到的一种现象，我们要尽可能<strong>避免死锁</strong>的情况发生。通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率。</p>
</li>
</ol>
<h3 id="17-8-python线程GIL"><a href="#17-8-python线程GIL" class="headerlink" title="17.8 python线程GIL"></a>17.8 python线程GIL</h3><ol>
<li>python线程的GIL问题 （全局解释器锁）</li>
</ol>
<blockquote>
<p>什么是GIL ：由于python解释器设计中加入了解释器锁，导致python解释器同一时刻只能解释执行一个线程，大大降低了线程的执行效率。</p>
</blockquote>
<blockquote>
<p>导致后果： 因为遇到阻塞时线程会主动让出解释器，去解释其他线程。所以python多线程在执行<strong>多阻塞高延迟IO</strong>时可以提升程序效率，其他情况并不能对效率有所提升。</p>
</blockquote>
<blockquote>
<p>GIL问题建议</p>
<ul>
<li>尽量使用进程完成无阻塞的并发行为</li>
<li>不使用c作为解释器 （Java  C#）</li>
</ul>
</blockquote>
<ol start="2">
<li>结论 ： 在无阻塞状态下，多线程程序和单线程程序执行效率几乎差不多，甚至还不如单线程效率。但是多进程运行相同内容却可以有明显的效率提升。</li>
</ol>
<h3 id="17-9-进程线程的区别联系"><a href="#17-9-进程线程的区别联系" class="headerlink" title="17.9 进程线程的区别联系"></a>17.9 进程线程的区别联系</h3><h4 id="（1）区别联系"><a href="#（1）区别联系" class="headerlink" title="（1）区别联系"></a>（1）区别联系</h4><ol>
<li>两者都是多任务编程方式，都能使用计算机多核资源</li>
<li>进程的创建删除消耗的计算机资源比线程多</li>
<li>进程空间独立，数据互不干扰，有专门通信方法；线程使用全局变量通信</li>
<li>一个进程可以有多个分支线程，两者有包含关系</li>
<li>多个线程共享进程资源，在共享资源操作时往往需要同步互斥处理</li>
<li>进程线程在系统中都有自己的特有属性标志，如ID,代码段，命令集等。</li>
</ol>
<h4 id="（2）使用场景"><a href="#（2）使用场景" class="headerlink" title="（2）使用场景"></a>（2）使用场景</h4><ol>
<li><p>任务场景：如果是相对独立的任务模块，可能使用多进程，如果是多个分支共同形成一个整体任务可能用多线程</p>
</li>
<li><p>项目结构：多种编程语言实现不同任务模块，可能是多进程，或者前后端分离应该各自为一个进程。</p>
</li>
<li><p>难易程度：通信难度，数据处理的复杂度来判断用进程间通信还是同步互斥方法。</p>
</li>
</ol>
<h4 id="（3）要求"><a href="#（3）要求" class="headerlink" title="（3）要求"></a>（3）要求</h4><ol>
<li>对进程线程怎么理解/说说进程线程的差异</li>
<li>进程间通信知道哪些，有什么特点</li>
<li>什么是同步互斥，你什么情况下使用，怎么用</li>
<li>给一个情形，说说用进程还是线程，为什么</li>
<li>问一些概念，僵尸进程的处理，GIL问题，进程状态</li>
</ol>
<h3 id="17-10-并发网络通信模型"><a href="#17-10-并发网络通信模型" class="headerlink" title="17.10 并发网络通信模型"></a>17.10 并发网络通信模型</h3><h4 id="（1）常见网络模型"><a href="#（1）常见网络模型" class="headerlink" title="（1）常见网络模型"></a>（1）常见网络模型</h4><ol>
<li>循环服务器模型 ：循环接收客户端请求，处理请求。同一时刻只能处理一个请求，处理完毕后再处理下一个。</li>
</ol>
<blockquote>
<p>优点：实现简单，占用资源少<br>缺点：无法同时处理多个客户端请求</p>
</blockquote>
<blockquote>
<p>适用情况：处理的任务可以很快完成，客户端无需长期占用服务端程序。udp比tcp更适合循环。</p>
</blockquote>
<ol start="2">
<li>多进程/线程网络并发模型：每当一个客户端连接服务器，就创建一个新的进程/线程为该客户端服务，客户端退出时再销毁该进程/线程。</li>
</ol>
<blockquote>
<p>优点：能同时满足多个客户端长期占有服务端需求，可以处理各种请求。<br>缺点： 资源消耗较大</p>
</blockquote>
<blockquote>
<p>适用情况：客户端同时连接量较少，需要处理行为较复杂情况。</p>
</blockquote>
<ol start="3">
<li><p>IO并发模型：利用IO多路复用,异步IO等技术，同时处理多个客户端IO请求。</p>
<blockquote>
<p>优点 ： 资源消耗少，能同时高效处理多个IO行为<br>缺点 ： 只能处理并发产生的IO事件，无法处理cpu计算</p>
</blockquote>
<blockquote>
<p>适用情况：HTTP请求，网络传输等都是IO行为。</p>
</blockquote>
</li>
</ol>
<h4 id="（2）基于fork的多进程网络并发模型"><a href="#（2）基于fork的多进程网络并发模型" class="headerlink" title="（2）基于fork的多进程网络并发模型"></a>（2）基于fork的多进程网络并发模型</h4><p>​    <strong>实现步骤</strong></p>
<ol>
<li>创建监听套接字</li>
<li>等待接收客户端请求</li>
<li>客户端连接创建新的进程处理客户端请求</li>
<li>原进程继续等待其他客户端连接</li>
<li>如果客户端退出，则销毁对应的进程</li>
</ol>
<h4 id="（3）基于threading的多线程网络并发"><a href="#（3）基于threading的多线程网络并发" class="headerlink" title="（3）基于threading的多线程网络并发"></a>（3）基于threading的多线程网络并发</h4><p>​    <strong>实现步骤</strong></p>
<ol>
<li>创建监听套接字</li>
<li>循环接收客户端连接请求</li>
<li>当有新的客户端连接创建线程处理客户端请求</li>
<li>主线程继续等待其他客户端连接</li>
<li>当客户端退出，则对应分支线程退出</li>
</ol>
<h4 id="（4）ftp-文件服务器"><a href="#（4）ftp-文件服务器" class="headerlink" title="（4）ftp 文件服务器"></a>（4）ftp 文件服务器</h4><ol>
<li>功能<br>【1】 分为服务端和客户端，要求可以有多个客户端同时操作。<br>【2】 客户端可以查看服务器文件库中有什么文件。<br>【3】 客户端可以从文件库中下载文件到本地。<br>【4】 客户端可以上传一个本地文件到文件库。<br>【5】 使用print在客户端打印命令输入提示，引导操作</li>
</ol>
<h3 id="17-11-IO并发"><a href="#17-11-IO并发" class="headerlink" title="17.11 IO并发"></a>17.11 IO并发</h3><h4 id="（1）IO-分类"><a href="#（1）IO-分类" class="headerlink" title="（1）IO 分类"></a>（1）IO 分类</h4><blockquote>
<p>IO分类：阻塞IO ，非阻塞IO，IO多路复用，异步IO等</p>
</blockquote>
<h5 id="1-gt-阻塞IO"><a href="#1-gt-阻塞IO" class="headerlink" title="1&gt; 阻塞IO"></a>1&gt; 阻塞IO</h5><ol>
<li><p>定义：在执行IO操作时如果执行条件不满足则阻塞。阻塞IO是IO的默认形态。</p>
</li>
<li><p>效率：阻塞IO是效率很低的一种IO。但是由于逻辑简单所以是默认IO行为。</p>
</li>
<li><p>阻塞情况：</p>
</li>
</ol>
<ul>
<li><p>因为某种执行条件没有满足造成的函数阻塞<br>e.g.  accept   input   recv</p>
</li>
<li><p>处理IO的时间较长产生的阻塞状态<br>e.g. 网络传输，大文件读写</p>
</li>
</ul>
<h5 id="2-gt-非阻塞IO"><a href="#2-gt-非阻塞IO" class="headerlink" title="2&gt; 非阻塞IO"></a>2&gt; 非阻塞IO</h5><ol>
<li>定义 ：通过修改IO属性行为，使原本阻塞的IO变为非阻塞的状态。</li>
</ol>
<ul>
<li><p>设置套接字为非阻塞IO</p>
<blockquote>
<p>sockfd.setblocking(bool)<br> 功能：设置套接字为非阻塞IO<br> 参数：默认为True，表示套接字IO阻塞；设置为False则套接字IO变为非阻塞</p>
</blockquote>
</li>
<li><p>超时检测 ：设置一个最长阻塞时间，超过该时间后则不再阻塞等待。</p>
<blockquote>
<p>sockfd.settimeout(sec)<br>功能：设置套接字的超时时间<br>参数：设置的时间</p>
</blockquote>
</li>
</ul>
<h4 id="（2）IO多路复用"><a href="#（2）IO多路复用" class="headerlink" title="（2）IO多路复用"></a>（2）IO多路复用</h4><ol>
<li><p>定义</p>
<blockquote>
<p>同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件。以此形成可以同时处理多个IO的行为，避免一个IO阻塞造成其他IO均无法执行，提高了IO执行效率。</p>
</blockquote>
</li>
<li><p>具体方案</p>
<blockquote>
<p>select方法 ： windows  linux  unix<br>poll方法： linux  unix<br>epoll方法： linux</p>
</blockquote>
</li>
</ol>
<h5 id="1-gt-select-方法"><a href="#1-gt-select-方法" class="headerlink" title="1&gt; select 方法"></a>1&gt; select 方法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rs, ws, xs=select(rlist, wlist, xlist[, timeout])</span><br><span class="line">功能: 监控IO事件，阻塞等待IO发生</span><br><span class="line">参数：rlist  列表  存放关注的等待发生的IO事件</span><br><span class="line">      wlist  列表  存放关注的要主动处理的IO事件</span><br><span class="line">      xlist  列表  存放关注的出现异常要处理的IO</span><br><span class="line">      timeout  超时时间</span><br><span class="line"></span><br><span class="line">返回值： rs 列表  rlist中准备就绪的IO</span><br><span class="line">        ws 列表  wlist中准备就绪的IO</span><br><span class="line">	xs 列表  xlist中准备就绪的IO</span><br></pre></td></tr></table></figure>

<p>select 实现tcp服务</p>
<pre><code>【1】 将关注的IO放入对应的监控类别列表
【2】通过select函数进行监控
【3】遍历select返回值列表，确定就绪IO事件
【4】处理发生的IO事件
</code></pre>
<blockquote>
<p>注意</p>
<blockquote>
<p>wlist中如果存在IO事件，则select立即返回给ws<br>处理IO过程中不要出现死循环占有服务端的情况<br>IO多路复用消耗资源较少，效率较高</p>
</blockquote>
</blockquote>
<h5 id="2-gt-poll方法"><a href="#2-gt-poll方法" class="headerlink" title="2&gt; poll方法"></a>2&gt; poll方法</h5><p><em><strong>代码实现: day12/poll_server.py</strong></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = select.poll()</span><br><span class="line">功能 ： 创建poll对象</span><br><span class="line">返回值： poll对象</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.register(fd,event)   </span><br><span class="line">功能: 注册关注的IO事件</span><br><span class="line">参数：fd  要关注的IO</span><br><span class="line">      event  要关注的IO事件类型</span><br><span class="line">  	     常用类型：POLLIN  读IO事件（rlist）</span><br><span class="line">		      POLLOUT 写IO事件 (wlist)</span><br><span class="line">		      POLLERR 异常IO  （xlist）</span><br><span class="line">		      POLLHUP 断开连接 </span><br><span class="line">		  e.g. p.register(sockfd,POLLIN|POLLERR)</span><br><span class="line"></span><br><span class="line">p.unregister(fd)</span><br><span class="line">功能：取消对IO的关注</span><br><span class="line">参数：IO对象或者IO对象的fileno</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">events = p.poll()</span><br><span class="line">功能： 阻塞等待监控的IO事件发生</span><br><span class="line">返回值： 返回发生的IO</span><br><span class="line">        events格式  [(fileno,event),()....]</span><br><span class="line">        每个元组为一个就绪IO，元组第一项是该IO的fileno，第二项为该IO就绪的事件类型</span><br></pre></td></tr></table></figure>

<p>poll_server 步骤</p>
<pre><code>【1】 创建套接字
【2】 将套接字register
【3】 创建查找字典，并维护
【4】 循环监控IO发生
【5】 处理发生的IO
</code></pre>
<h5 id="3-gt-epoll方法"><a href="#3-gt-epoll方法" class="headerlink" title="3&gt; epoll方法"></a>3&gt; epoll方法</h5><ol>
<li><p>使用方法 ： 基本与poll相同</p>
<ul>
<li>生成对象改为 epoll()</li>
<li>将所有事件类型改为EPOLL类型</li>
</ul>
</li>
<li><p>epoll特点</p>
<ul>
<li>epoll 效率比select poll要高</li>
<li>epoll 监控IO数量比select要多</li>
<li>epoll 的触发方式比poll要多 （EPOLLET边缘触发）</li>
</ul>
</li>
</ol>
<h4 id="（3）协程技术"><a href="#（3）协程技术" class="headerlink" title="（3）协程技术"></a>（3）协程技术</h4><h5 id="1-gt-基础概念"><a href="#1-gt-基础概念" class="headerlink" title="1&gt; 基础概念"></a>1&gt; 基础概念</h5><ol>
<li><p>定义：纤程，微线程。是允许在不同入口点不同位置暂停或开始的计算机程序，简单来说，<strong>协程就是可以暂停执行的函数</strong>。</p>
</li>
<li><p>协程原理 ： 记录一个函数的上下文，协程调度切换时会将记录的上下文保存，在切换回来时进行调取，恢复原有的执行内容，以便从上一次执行位置继续执行。</p>
</li>
<li><p>协程优缺点</p>
</li>
</ol>
<blockquote>
<p>优点</p>
<blockquote>
<ol>
<li>协程完成多任务占用计算资源很少</li>
<li>由于协程的多任务切换在应用层完成，因此切换开销少</li>
<li>协程为单线程程序，无需进行共享资源同步互斥处理</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>缺点</p>
<blockquote>
<p>协程的本质是一个单线程，无法利用计算机多核资源</p>
</blockquote>
</blockquote>
<p>python3.5以后，使用标准库asyncio和async/await 语法来编写并发代码。asyncio库通过对异步IO行为的支持完成python的协程。虽然官方说asyncio是未来的开发方向，但是由于其生态不够丰富，大量的客户端不支持awaitable需要自己去封装，所以在使用上存在缺陷。更多时候只能使用已有的异步库（asyncio等），功能有限</p>
<hr>
<h5 id="2-gt-第三方协程模块"><a href="#2-gt-第三方协程模块" class="headerlink" title="2&gt; 第三方协程模块"></a>2&gt; 第三方协程模块</h5><ol>
<li> greenlet模块</li>
</ol>
<ul>
<li><p>安装 ： sudo  pip3 install greenlet</p>
</li>
<li><p>函数 </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">greenlet.greenlet(func)</span><br><span class="line">功能：创建协程对象</span><br><span class="line">参数：协程函数</span><br><span class="line"></span><br><span class="line">g.switch()</span><br><span class="line">功能：选择要执行的协程函数</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>gevent模块                </li>
</ol>
<ul>
<li><p>安装：sudo pip3 install gevent</p>
</li>
<li><p>函数</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gevent.spawn(func,argv)</span><br><span class="line">功能: 生成协程对象</span><br><span class="line">参数：func  协程函数</span><br><span class="line">     argv  给协程函数传参（不定参）</span><br><span class="line">返回值： 协程对象</span><br><span class="line"></span><br><span class="line">gevent.joinall(<span class="built_in">list</span>,[timeout])</span><br><span class="line">功能: 阻塞等待协程执行完毕</span><br><span class="line">参数：<span class="built_in">list</span>  协程对象列表</span><br><span class="line">     timeout 超时时间</span><br><span class="line"></span><br><span class="line">gevent.sleep(sec)</span><br><span class="line">功能: gevent睡眠阻塞</span><br><span class="line">参数：睡眠时间</span><br><span class="line"></span><br><span class="line">* gevent协程只有在遇到gevent指定的阻塞行为时才会自动在协程之间进行跳转</span><br><span class="line">如gevent.joinall(),gevent.sleep()带来的阻塞</span><br></pre></td></tr></table></figure>

<ul>
<li>monkey脚本</li>
</ul>
<blockquote>
<p>作用：在gevent协程中，协程只有遇到gevent指定类型的阻塞才能跳转到其他协程，因此，我们希望将普通的IO阻塞行为转换为可以触发gevent协程跳转的阻塞，以提高执行效率。</p>
</blockquote>
<blockquote>
<p>转换方法：gevent 提供了一个脚本程序monkey,可以修改底层解释IO阻塞的行为，将很多普通阻塞转换为gevent阻塞。</p>
</blockquote>
<blockquote>
<p>使用方法</p>
</blockquote>
<blockquote>
<blockquote>
<p>【1】 导入monkey</p>
</blockquote>
</blockquote>
<pre><code>    from gevent  import monkey
</code></pre>
<blockquote>
<blockquote>
<p>【2】 运行相应的脚本，例如转换socket中所有阻塞</p>
</blockquote>
</blockquote>
<pre><code>    monkey.patch_socket()
</code></pre>
<blockquote>
<blockquote>
<p>【3】 如果将所有可转换的IO阻塞全部转换则运行all</p>
</blockquote>
</blockquote>
<pre><code>    monkey.patch_all()
</code></pre>
<blockquote>
<blockquote>
<p>【4】 注意：脚本运行函数需要在对应模块导入前执行</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面向对象</tag>
        <tag>迭代器</tag>
        <tag>生成器</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy教程</title>
    <url>/2022/08/06/Numpy%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="NumPy-教程"><a href="#NumPy-教程" class="headerlink" title="NumPy 教程"></a>NumPy 教程</h2><ul>
<li>NumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</li>
</ul>
<ul>
<li>NumPy 的前身 Numeric 最早是由 Jim Hugunin 与其它协作者共同开发，2005 年，Travis Oliphant 在 Numeric 中结合了另一个同性质的程序库 Numarray 的特色，并加入了其它扩展而开发了 NumPy。NumPy 为开放源代码并且由许多协作者共同维护开发。</li>
<li>NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含：<ul>
<li>一个强大的N维数组对象 ndarray</li>
<li>广播功能函数</li>
<li>整合 C/C++/Fortran 代码的工具</li>
<li>线性代数、傅里叶变换、随机数生成等功能</li>
</ul>
</li>
</ul>
<h2 id="NumPy-Ndarray-对象"><a href="#NumPy-Ndarray-对象" class="headerlink" title="NumPy Ndarray 对象"></a>NumPy Ndarray 对象</h2><ul>
<li>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。</li>
</ul>
<ul>
<li>ndarray 对象是用于存放同类型元素的多维数组。</li>
</ul>
<ul>
<li>ndarray 中的每个元素在内存中都有相同存储大小的区域。</li>
</ul>
<ul>
<li><p>ndarray 内部由以下内容组成：</p>
<ul>
<li>一个指向数据（内存或内存映射文件中的一块数据）的指针。</li>
<li>数据类型或 dtype，描述在数组中的固定大小值的格子。</li>
<li>一个表示数组形状（shape）的元组，表示各维度大小的元组。</li>
<li>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。</li>
</ul>
</li>
<li><p>ndarray 的内部结构:</p>
<p> <img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/20200327233644385.png" alt="ndarray"> </p>
<p>跨度可以是负数，这样会使数组在内存中后向移动，切片中 obj[::-1] 或 obj[:,::-1] 就是如此。</p>
</li>
<li><p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>| 名称   | 描述                                                      |<br>| —— | ——————————————————— |<br>| object | 数组或嵌套的数列                                          |<br>| dtype  | 数组元素的数据类型，可选                                  |<br>| copy   | 对象是否需要复制，可选                                    |<br>| order  | 创建数组的样式，C为行方向，F为列方向，A为任意方向（默认） |<br>| subok  | 默认返回一个与基类类型一致的数组                          |<br>| ndmin  | 指定生成数组的最小维度                                    |</p>
<ul>
<li>ndarray 对象由计算机内存的连续一维部分组成，并结合索引模式，将每个元素映射到内存块中的一个位置。内存块以行顺序(C样式)或列顺序(FORTRAN或MatLab风格，即前述的F样式)来保存元素 </li>
</ul>
<h2 id="NumPy-数据类型"><a href="#NumPy-数据类型" class="headerlink" title="NumPy 数据类型"></a>NumPy 数据类型</h2><ul>
<li><p>numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。下表列举了常用 NumPy 基本类型。</p>
<p><img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/1659759941145.png" alt="1659759941145"></p>
</li>
<li><p>numpy 的数值类型实际上是 dtype 对象的实例，并对应唯一的字符，包括 np.bool_，np.int32，np.float32，等等。 </p>
</li>
</ul>
<h3 id="数据类型对象-dtype"><a href="#数据类型对象-dtype" class="headerlink" title="数据类型对象 (dtype)"></a>数据类型对象 (dtype)</h3><ul>
<li><p>数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：</p>
<ul>
<li>数据的类型（整数，浮点数或者 Python 对象）</li>
<li>数据的大小（例如， 整数使用多少个字节存储）</li>
<li>数据的字节顺序（小端法或大端法）</li>
<li>在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li>
<li>如果数据类型是子数组，它的形状和数据类型</li>
</ul>
</li>
<li><p>字节顺序是通过对数据类型预先设定”&lt;“或”&gt;“来决定的。”&lt;“意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。”&gt;”意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。</p>
</li>
</ul>
<ul>
<li>dtype 对象是使用以下语法构造的：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.dtype(<span class="built_in">object</span>, align, copy)</span><br><span class="line"><span class="comment"># object - 要转换为的数据类型对象</span></span><br><span class="line"><span class="comment"># align - 如果为 true，填充字段使其类似 C 的结构体。</span></span><br><span class="line"><span class="comment"># copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>每个内建类型都有一个唯一定义它的字符代码，如下：</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">对应类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">b</td>
<td align="center">布尔型</td>
</tr>
<tr>
<td align="center">i</td>
<td align="center">(有符号) 整型</td>
</tr>
<tr>
<td align="center">u</td>
<td align="center">无符号整型 integer</td>
</tr>
<tr>
<td align="center">f</td>
<td align="center">浮点型</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">复数浮点型</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">timedelta（时间间隔）</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">datetime（日期时间）</td>
</tr>
<tr>
<td align="center">O</td>
<td align="center">(Python) 对象</td>
</tr>
<tr>
<td align="center">S, a</td>
<td align="center">(byte-)字符串</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">Unicode</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">原始数据 (void)</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="NumPy-读取数据"><a href="#NumPy-读取数据" class="headerlink" title="NumPy 读取数据"></a>NumPy 读取数据</h2><ul>
<li><p>CSV:Comma-Separated Value,逗号分隔值文件</p>
</li>
<li><p>显示：表格状态</p>
</li>
</ul>
<ul>
<li>源文件：换行和逗号分隔行列的格式化文本,每一行的数据表示一条记录</li>
</ul>
<ul>
<li>由于csv便于展示,读取和写入,所以很多地方也是用csv的格式存储和传输中小型的数据,为了方便教学,我们会经常操作csv格式的文件,但是操作数据库中的数据也是很容易的实现的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.loadtxt(fname,dtype=np.<span class="built_in">float</span>,delimiter=<span class="literal">None</span>,skiprows=<span class="number">0</span>,usecols=<span class="literal">None</span>,unpack=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/1659760531602.png" alt="1659760531602"></p>
<h2 id="NumPy-数组属性"><a href="#NumPy-数组属性" class="headerlink" title="NumPy 数组属性"></a>NumPy 数组属性</h2><ul>
<li><p>NumPy 数组的维数称为秩（rank），秩就是轴的数量，即数组的维度，一维数组的秩为 1，二维数组的秩为 2，以此类推。</p>
</li>
<li><p>在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</p>
</li>
</ul>
<ul>
<li>很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。</li>
</ul>
<ul>
<li><p>NumPy 的数组中比较重要 ndarray 对象属性有：</p>
<p><img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/1659761591454.png" alt="1659761591454"></p>
<ul>
<li><p>ndarray.ndim<br>ndarray.ndim 用于返回数组的维数，等于秩。</p>
</li>
<li><p>ndarray.shape<br>ndarray.shape 表示数组的维度，返回一个元组，这个元组的长度就是维度的数目，即 ndim 属性(秩)。比如，一个二维数组，其维度表示”行数”和”列数”。</p>
</li>
<li><p>ndarray.shape 也可以用于调整数组大小。</p>
<p>NumPy 也提供了 reshape 函数来调整数组大小。</p>
</li>
<li><p>ndarray.itemsize<br>ndarray.itemsize 以字节的形式返回数组中每一个元素的大小。</p>
<p>例如，一个元素类型为 float64 的数组 itemsiz 属性值为 8(float64 占用 64 个 bits，每个字节长度为 8，所以 64/8，占用 8 个字节），又如，一个元素类型为 complex32 的数组 item 属性为 4（32/8）。</p>
</li>
<li><p>ndarray.flags<br>ndarray.flags 返回 ndarray 对象的内存信息，包含以下属性：</p>
<p><img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/1659761773766.png" alt="1659761773766"></p>
</li>
</ul>
</li>
</ul>
<h2 id="NumPy-创建数组"><a href="#NumPy-创建数组" class="headerlink" title="NumPy 创建数组"></a>NumPy 创建数组</h2><p>ndarray 数组除了可以使用底层 ndarray 构造器来创建外，也可以通过以下几种方式来创建。</p>
<h3 id="numpy-empty"><a href="#numpy-empty" class="headerlink" title="numpy.empty"></a>numpy.empty</h3><ul>
<li>numpy.empty 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.empty(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># shape	数组形状</span></span><br><span class="line"><span class="comment"># dtype	数据类型，可选</span></span><br><span class="line"><span class="comment"># order	有&quot;C&quot;和&quot;F&quot;两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</span></span><br></pre></td></tr></table></figure>



<h3 id="numpy-zeros"><a href="#numpy-zeros" class="headerlink" title="numpy.zeros"></a>numpy.zeros</h3><ul>
<li>创建指定大小的数组，数组元素以 0 来填充：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = float, order = &#x27;C&#x27;)</span><br><span class="line"># shape	数组形状</span><br><span class="line"># dtype	数据类型，可选</span><br><span class="line"># order	‘C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组</span><br></pre></td></tr></table></figure>



<h3 id="numpy-ones"><a href="#numpy-ones" class="headerlink" title="numpy.ones"></a>numpy.ones</h3><ul>
<li>创建指定形状的数组，数组元素以 1 来填充：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ones(shape, dtype = <span class="literal">None</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># shape	数组形状</span></span><br><span class="line"><span class="comment"># dtype	数据类型，可选</span></span><br><span class="line"><span class="comment"># order	‘C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组</span></span><br></pre></td></tr></table></figure>



<h2 id="NumPy-从已有的数组创建数组"><a href="#NumPy-从已有的数组创建数组" class="headerlink" title="NumPy 从已有的数组创建数组"></a>NumPy 从已有的数组创建数组</h2><h3 id="numpy-asarray"><a href="#numpy-asarray" class="headerlink" title="numpy.asarray"></a>numpy.asarray</h3><ul>
<li>numpy.asarray 类似 numpy.array，但 numpy.asarray 参数只有三个，比 numpy.array 少两个。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.asarray(a, dtype = <span class="literal">None</span>, order = <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># a	任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组</span></span><br><span class="line"><span class="comment"># dtype	数据类型，可选</span></span><br><span class="line"><span class="comment"># order	可选，有&quot;C&quot;和&quot;F&quot;两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</span></span><br></pre></td></tr></table></figure>



<h3 id="numpy-frombuffer"><a href="#numpy-frombuffer" class="headerlink" title="numpy.frombuffer"></a>numpy.frombuffer</h3><ul>
<li><p>numpy.frombuffer 用于实现动态数组。</p>
</li>
<li><p>numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.frombuffer(buffer, dtype = <span class="built_in">float</span>, count = -<span class="number">1</span>, offset = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># buffer	可以是任意对象，会以流的形式读入。</span></span><br><span class="line"><span class="comment"># dtype	返回数组的数据类型，可选</span></span><br><span class="line"><span class="comment"># count	读取的数据数量，默认为-1，读取所有数据。</span></span><br><span class="line"><span class="comment"># offset	读取的起始位置，默认为0。</span></span><br></pre></td></tr></table></figure>



<h3 id="numpy-fromiter"><a href="#numpy-fromiter" class="headerlink" title="numpy.fromiter"></a>numpy.fromiter</h3><ul>
<li>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.fromiter(iterable, dtype, count=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># iterable	可迭代对象</span></span><br><span class="line"><span class="comment"># dtype	返回数组的数据类型</span></span><br><span class="line"><span class="comment"># count	读取的数据数量，默认为-1，读取所有数据</span></span><br></pre></td></tr></table></figure>



<h2 id="NumPy-从数值范围创建数组"><a href="#NumPy-从数值范围创建数组" class="headerlink" title="NumPy 从数值范围创建数组"></a>NumPy 从数值范围创建数组</h2><h2 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange"></a>numpy.arange</h2><ul>
<li>numpy 包中的使用 arange 函数创建数值范围并返回 ndarray 对象，函数格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype)</span><br><span class="line"><span class="comment">#  start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。</span></span><br><span class="line"><span class="comment">#  start	起始值，默认为0</span></span><br><span class="line"><span class="comment">#  stop	终止值（不包含）</span></span><br><span class="line"><span class="comment">#  step	步长，默认为1</span></span><br><span class="line"><span class="comment">#  dtype	返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。</span></span><br></pre></td></tr></table></figure>



<h2 id="numpy-linspace"><a href="#numpy-linspace" class="headerlink" title="numpy.linspace"></a>numpy.linspace</h2><ul>
<li>numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># start	序列的起始值</span></span><br><span class="line"><span class="comment"># stop	序列的终止值，如果endpoint为true，该值包含于数列中</span></span><br><span class="line"><span class="comment"># num	要生成的等步长的样本数量，默认为50</span></span><br><span class="line"><span class="comment"># endpoint	该值为 true 时，数列中中包含stop值，反之不包含，默认是True。</span></span><br><span class="line"><span class="comment"># retstep	如果为 True 时，生成的数组中会显示间距，反之不显示。</span></span><br><span class="line"><span class="comment"># dtype	ndarray 的数据类型</span></span><br></pre></td></tr></table></figure>



<h2 id="numpy-logspace"><a href="#numpy-logspace" class="headerlink" title="numpy.logspace"></a>numpy.logspace</h2><ul>
<li>numpy.logspace 函数用于创建一个于等比数列。格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># start	序列的起始值为：base ** start</span></span><br><span class="line"><span class="comment"># stop	序列的终止值为：base ** stop。如果endpoint为true，该值包含于数列中</span></span><br><span class="line"><span class="comment"># num	要生成的等步长的样本数量，默认为50</span></span><br><span class="line"><span class="comment"># endpoint	该值为 true 时，数列中中包含stop值，反之不包含，默认是True。</span></span><br><span class="line"><span class="comment"># base	对数 log 的底数。</span></span><br><span class="line"><span class="comment"># dtype	ndarray 的数据类型</span></span><br></pre></td></tr></table></figure>



<h2 id="NumPy-切片和索引"><a href="#NumPy-切片和索引" class="headerlink" title="NumPy 切片和索引"></a>NumPy 切片和索引</h2><ul>
<li><p>ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。</p>
</li>
<li><p>ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。通过冒号分隔切片参数 start:stop:step 来进行切片操作。</p>
</li>
</ul>
<ul>
<li>冒号 : 的解释：如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引(不包括停止索引)之间的项。</li>
</ul>
<ul>
<li>切片还可以包括省略号 …，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</li>
</ul>
<h2 id="NumPy-高级索引"><a href="#NumPy-高级索引" class="headerlink" title="NumPy 高级索引"></a>NumPy 高级索引</h2><ul>
<li>NumPy 比一般的 Python 序列提供更多的索引方式。除了之前看到的用整数和切片的索引外，数组可以由整数数组索引、布尔索引及花式索引。</li>
</ul>
<h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><ul>
<li><p>我们可以通过一个布尔数组来索引目标数组。</p>
</li>
<li><p>布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p>
</li>
</ul>
<ul>
<li>~（取补运算符）来过滤 NaN</li>
</ul>
<h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><ul>
<li><p>花式索引指的是利用整数数组进行索引。</p>
</li>
<li><p>花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。</p>
</li>
</ul>
<ul>
<li><p>花式索引跟切片不一样，它总是将数据复制到新数组中。</p>
<ul>
<li><p>（1）传入顺序索引数组</p>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x=np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> (x[[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>]])</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]]</span><br></pre></td></tr></table></figure></li>
<li><p>（2）传入倒序索引数组</p>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x=np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> (x[[-<span class="number">4</span>,-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">7</span>]])</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [<span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]]</span><br></pre></td></tr></table></figure></li>
<li><p>（3）传入多个索引数组（要使用np.ix_）</p>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x=np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> (x[np.ix_([<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<pre><code>输出结果为：

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[ <span class="number">4</span>  <span class="number">7</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">23</span> <span class="number">21</span> <span class="number">22</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">31</span> <span class="number">29</span> <span class="number">30</span>]</span><br><span class="line"> [ <span class="number">8</span> <span class="number">11</span>  <span class="number">9</span> <span class="number">10</span>]]</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="NumPy-广播-Broadcast"><a href="#NumPy-广播-Broadcast" class="headerlink" title="NumPy 广播(Broadcast)"></a>NumPy 广播(Broadcast)</h2><ul>
<li><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p>
</li>
<li><p>如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p>
</li>
</ul>
<ul>
<li><p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">			[<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">			[<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">			[<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line"> [<span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]]</span><br></pre></td></tr></table></figure></li>
<li><p>下面的图片展示了数组 b 如何通过广播来与数组 a 兼容。</p>
<p> <img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/20200327233751196.gif" alt="在这里插入图片描述"> </p>
</li>
</ul>
<p>​    4x3 的二维数组与长为 3 的一维数组相加，等效于把数组 b 在二维上重复 4 次再运算</p>
<ul>
<li><p>广播的规则:</p>
<ul>
<li><p>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。<br>输出数组的形状是输入数组形状的各个维度上的最大值。</p>
</li>
<li><p>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</p>
</li>
<li><p>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。</p>
</li>
<li><p><strong>简单理解：</strong>对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p>
<ul>
<li><p>数组拥有相同形状。</p>
</li>
<li><p>当前维度的值相等。</p>
</li>
<li><p>当前维度的值有一个是 1。</p>
<p>若条件不满足，抛出 “ValueError: frames are not aligned” 异常。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="NumPy-迭代数组"><a href="#NumPy-迭代数组" class="headerlink" title="NumPy 迭代数组"></a>NumPy 迭代数组</h2><ul>
<li><p>NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式。</p>
</li>
<li><p>迭代器最基本的任务的可以完成对数组元素的访问。</p>
</li>
</ul>
<h3 id="控制遍历顺序"><a href="#控制遍历顺序" class="headerlink" title="控制遍历顺序"></a>控制遍历顺序</h3><ul>
<li>for x in np.nditer(a, order=’F’):Fortran order，即是列序优先；</li>
<li>for x in np.nditer(a.T, order=’C’):C order，即是行序优先；</li>
<li>可以通过显式设置，来强制 nditer 对象使用某种顺序。</li>
</ul>
<h3 id="修改数组中元素的值"><a href="#修改数组中元素的值" class="headerlink" title="修改数组中元素的值"></a>修改数组中元素的值</h3><ul>
<li>nditer 对象有另一个可选参数 op_flags。 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。</li>
</ul>
<h3 id="使用外部循环"><a href="#使用外部循环" class="headerlink" title="使用外部循环"></a>使用外部循环</h3><p>nditer类的构造器拥有flags参数，它可以接受下列值：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>c_index</code></td>
<td>可以跟踪 C 顺序的索引</td>
</tr>
<tr>
<td><code>f_index</code></td>
<td>可以跟踪 Fortran 顺序的索引</td>
</tr>
<tr>
<td><code>multi-index</code></td>
<td>每次迭代可以跟踪一种索引类型</td>
</tr>
<tr>
<td><code>external_loop</code></td>
<td>给出的值是具有多个值的一维数组，而不是零维数组</td>
</tr>
</tbody></table>
<h3 id="广播迭代"><a href="#广播迭代" class="headerlink" title="广播迭代"></a>广播迭代</h3><ul>
<li>如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。</li>
</ul>
<h2 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h2><h3 id="修改数组形状"><a href="#修改数组形状" class="headerlink" title="修改数组形状"></a>修改数组形状</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>reshape</code></td>
<td>不改变数据的条件下修改形状</td>
</tr>
<tr>
<td><code>flat</code></td>
<td>数组元素迭代器</td>
</tr>
<tr>
<td><code>flatten</code></td>
<td>返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td>
</tr>
<tr>
<td><code>ravel</code></td>
<td>返回展开数组</td>
</tr>
</tbody></table>
<h4 id="numpy-reshape"><a href="#numpy-reshape" class="headerlink" title="numpy.reshape"></a>numpy.reshape</h4><ul>
<li>numpy.reshape 函数可以在不改变数据的条件下修改形状，格式如下： numpy.reshape(arr, newshape, order=‘C’)<ul>
<li>arr：要修改形状的数组</li>
<li>newshape：整数或者整数数组，新的形状应当兼容原有形状</li>
<li>order：‘C’ – 按行，‘F’ – 按列，‘A’ – 原顺序，‘k’ – 元素在内存中的出现顺序。</li>
</ul>
</li>
</ul>
<h4 id="numpy-ndarray-flat"><a href="#numpy-ndarray-flat" class="headerlink" title="numpy.ndarray.flat"></a>numpy.ndarray.flat</h4><ul>
<li>numpy.ndarray.flat 是一个数组元素迭代器。</li>
</ul>
<h4 id="numpy-ndarray-flatten"><a href="#numpy-ndarray-flatten" class="headerlink" title="numpy.ndarray.flatten"></a>numpy.ndarray.flatten</h4><ul>
<li><p>numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ndarray.flatten(order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># order：‘C’ – 按行，‘F’ – 按列，‘A’ – 原顺序，‘K’ – 元素在内存中的出现顺序。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>numpy.ravel</p>
<h4 id="numpy-ravel"><a href="#numpy-ravel" class="headerlink" title="numpy.ravel()"></a>numpy.ravel()</h4><ul>
<li><p>展平的数组元素，顺序通常是”C风格”，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ravel(a, order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># order：‘C’ – 按行，‘F’ – 按列，‘A’ – 原顺序，‘K’ – 元素在内存中的出现顺序。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>transpose</code></td>
<td>对换数组的维度</td>
</tr>
<tr>
<td><code>ndarray.T</code></td>
<td>和 <code>self.transpose()</code> 相同</td>
</tr>
<tr>
<td><code>rollaxis</code></td>
<td>向后滚动指定的轴</td>
</tr>
<tr>
<td><code>swapaxes</code></td>
<td>对换数组的两个轴</td>
</tr>
</tbody></table>
<h4 id="numpy-transpose"><a href="#numpy-transpose" class="headerlink" title="numpy.transpose"></a>numpy.transpose</h4><ul>
<li>numpy.transpose 函数用于对换数组的维度，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.transpose(arr, axes)</span><br><span class="line"><span class="comment"># 参数说明:</span></span><br><span class="line"><span class="comment"># arr：要操作的数组</span></span><br><span class="line"><span class="comment"># axes：整数列表，对应维度，通常所有维度都会对换。</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-rollaxis"><a href="#numpy-rollaxis" class="headerlink" title="numpy.rollaxis"></a>numpy.rollaxis</h4><ul>
<li>numpy.rollaxis 函数向后滚动特定的轴到一个特定位置，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.rollaxis(arr, axis, start)</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># arr：数组</span></span><br><span class="line"><span class="comment"># axis：要向后滚动的轴，其它轴的相对位置不会改变</span></span><br><span class="line"><span class="comment"># start：默认为零，表示完整的滚动。会滚动到特定位置。</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-swapaxes"><a href="#numpy-swapaxes" class="headerlink" title="numpy.swapaxes"></a>numpy.swapaxes</h4><ul>
<li>numpy.swapaxes 函数用于交换数组的两个轴，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.swapaxes(arr, axis1, axis2)</span><br><span class="line"><span class="comment"># arr：输入的数组</span></span><br><span class="line"><span class="comment"># axis1：对应第一个轴的整数</span></span><br><span class="line"><span class="comment"># axis2：对应第二个轴的整数</span></span><br></pre></td></tr></table></figure>



<h3 id="修改数组维度"><a href="#修改数组维度" class="headerlink" title="修改数组维度"></a>修改数组维度</h3><table>
<thead>
<tr>
<th>维度</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>broadcast</code></td>
<td>产生模仿广播的对象</td>
</tr>
<tr>
<td><code>broadcast_to</code></td>
<td>将数组广播到新形状</td>
</tr>
<tr>
<td><code>expand_dims</code></td>
<td>扩展数组的形状</td>
</tr>
<tr>
<td><code>squeeze</code></td>
<td>从数组的形状中删除一维条目</td>
</tr>
</tbody></table>
<h4 id="numpy-broadcast"><a href="#numpy-broadcast" class="headerlink" title="numpy.broadcast"></a>numpy.broadcast</h4><ul>
<li>numpy.broadcast 用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。</li>
</ul>
<h4 id="numpy-broadcast-to"><a href="#numpy-broadcast-to" class="headerlink" title="numpy.broadcast_to"></a>numpy.broadcast_to</h4><ul>
<li>numpy.broadcast_to 函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.broadcast_to(array, shape, subok)</span><br></pre></td></tr></table></figure>

<h4 id="numpy-expand-dims"><a href="#numpy-expand-dims" class="headerlink" title="numpy.expand_dims"></a>numpy.expand_dims</h4><ul>
<li>numpy.expand_dims 函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> numpy.expand_dims(arr, axis)</span><br><span class="line"><span class="comment"># arr：输入数组</span></span><br><span class="line"><span class="comment"># axis：新轴插入的位置</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-squeeze"><a href="#numpy-squeeze" class="headerlink" title="numpy.squeeze"></a>numpy.squeeze</h4><ul>
<li>numpy.squeeze 函数从给定数组的形状中删除一维的条目，函数格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># arr：输入数组</span></span><br><span class="line"><span class="comment"># axis：整数或整数元组，用于选择形状中一维条目的子集</span></span><br></pre></td></tr></table></figure>



<h3 id="连接数组"><a href="#连接数组" class="headerlink" title="连接数组"></a>连接数组</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>concatenate</code></td>
<td>连接沿现有轴的数组序列</td>
</tr>
<tr>
<td><code>stack</code></td>
<td>沿着新的轴加入一系列数组。</td>
</tr>
<tr>
<td><code>hstack</code></td>
<td>水平堆叠序列中的数组（列方向）</td>
</tr>
<tr>
<td><code>vstack</code></td>
<td>竖直堆叠序列中的数组（行方向）</td>
</tr>
</tbody></table>
<h4 id="numpy-concatenate"><a href="#numpy-concatenate" class="headerlink" title="numpy.concatenate"></a>numpy.concatenate</h4><ul>
<li>numpy.concatenate 函数用于沿指定轴连接相同形状的两个或多个数组，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.concatenate((a1, a2, ...), axis)</span><br><span class="line"><span class="comment"># a1, a2, ...：相同类型的数组</span></span><br><span class="line"><span class="comment"># axis：沿着它连接数组的轴，默认为 0</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-stack"><a href="#numpy-stack" class="headerlink" title="numpy.stack"></a>numpy.stack</h4><ul>
<li>numpy.stack 函数用于沿新轴连接数组序列，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.stack(arrays, axis)</span><br><span class="line"><span class="comment"># arrays相同形状的数组序列</span></span><br><span class="line"><span class="comment"># axis：返回数组中的轴，输入数组沿着它来堆叠</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-hstack"><a href="#numpy-hstack" class="headerlink" title="numpy.hstack"></a>numpy.hstack</h4><ul>
<li>numpy.hstack 是 numpy.stack 函数的变体，它通过水平堆叠来生成数组。</li>
</ul>
<h4 id="numpy-vstack"><a href="#numpy-vstack" class="headerlink" title="numpy.vstack"></a>numpy.vstack</h4><ul>
<li>numpy.vstack 是 numpy.stack 函数的变体，它通过垂直堆叠来生成数组。</li>
</ul>
<h3 id="分割数组"><a href="#分割数组" class="headerlink" title="分割数组"></a>分割数组</h3><table>
<thead>
<tr>
<th>函数</th>
<th>数组及操作</th>
</tr>
</thead>
<tbody><tr>
<td><code>split</code></td>
<td>将一个数组分割为多个子数组</td>
</tr>
<tr>
<td><code>hsplit</code></td>
<td>将一个数组水平分割为多个子数组（按列）</td>
</tr>
<tr>
<td><code>vsplit</code></td>
<td>将一个数组垂直分割为多个子数组（按行）</td>
</tr>
</tbody></table>
<h4 id="numpy-split"><a href="#numpy-split" class="headerlink" title="numpy.split"></a>numpy.split</h4><ul>
<li>函数沿特定的轴将数组分割为子数组，格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.split(ary, indices_or_sections, axis)</span><br><span class="line"><span class="comment"># ary：被分割的数组</span></span><br><span class="line"><span class="comment"># indices_or_sections：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）</span></span><br><span class="line"><span class="comment"># axis：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-hsplit"><a href="#numpy-hsplit" class="headerlink" title="numpy.hsplit"></a>numpy.hsplit</h4><ul>
<li>numpy.hsplit 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。</li>
</ul>
<h4 id="numpy-vsplit"><a href="#numpy-vsplit" class="headerlink" title="numpy.vsplit"></a>numpy.vsplit</h4><ul>
<li>numpy.vsplit 沿着垂直轴分割，其分割方式与hsplit用法相同。</li>
</ul>
<h3 id="数组元素的添加与删除"><a href="#数组元素的添加与删除" class="headerlink" title="数组元素的添加与删除"></a>数组元素的添加与删除</h3><table>
<thead>
<tr>
<th>函数</th>
<th>元素及描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>resize</code></td>
<td>返回指定形状的新数组</td>
</tr>
<tr>
<td><code>append</code></td>
<td>将值添加到数组末尾</td>
</tr>
<tr>
<td><code>insert</code></td>
<td>沿指定轴将值插入到指定下标之前</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>删掉某个轴的子数组，并返回删除后的新数组</td>
</tr>
<tr>
<td><code>unique</code></td>
<td>查找数组内的唯一元素</td>
</tr>
</tbody></table>
<h4 id="numpy-resize"><a href="#numpy-resize" class="headerlink" title="numpy.resize"></a>numpy.resize</h4><ul>
<li><p>numpy.resize 函数返回指定大小的新数组。</p>
</li>
<li><p>如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.resize(arr, shape)</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># arr：要修改大小的数组</span></span><br><span class="line"><span class="comment"># shape：返回数组的新形状</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-append"><a href="#numpy-append" class="headerlink" title="numpy.append"></a>numpy.append</h4><ul>
<li><p>numpy.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。</p>
</li>
<li><p>append 函数返回的始终是一个一维数组。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.append(arr, values, axis=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># arr：输入数组</span></span><br><span class="line"><span class="comment"># values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</span></span><br><span class="line"><span class="comment"># axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-insert"><a href="#numpy-insert" class="headerlink" title="numpy.insert"></a>numpy.insert</h4><ul>
<li><p>numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。</p>
</li>
<li><p>如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.insert(arr, obj, values, axis)</span><br><span class="line"><span class="comment"># arr：输入数组</span></span><br><span class="line"><span class="comment"># obj：在其之前插入值的索引</span></span><br><span class="line"><span class="comment"># values：要插入的值</span></span><br><span class="line"><span class="comment"># axis：沿着它插入的轴，如果未提供，则输入数组会被展开</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-delete"><a href="#numpy-delete" class="headerlink" title="numpy.delete"></a>numpy.delete</h4><ul>
<li>numpy.delete 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Numpy.delete(arr, obj, axis)</span><br><span class="line">arr：输入数组</span><br><span class="line">obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</span><br><span class="line">axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<h4 id="numpy-unique"><a href="#numpy-unique" class="headerlink" title="numpy.unique"></a>numpy.unique</h4><ul>
<li>numpy.unique 函数用于去除数组中的重复元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.unique(arr, return_index, return_inverse, return_counts)</span><br><span class="line"><span class="comment"># arr：输入数组，如果不是一维数组则会展开</span></span><br><span class="line"><span class="comment"># return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</span></span><br><span class="line"><span class="comment"># return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</span></span><br><span class="line"><span class="comment"># return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数</span></span><br></pre></td></tr></table></figure>



<h2 id="NumPy-位运算"><a href="#NumPy-位运算" class="headerlink" title="NumPy 位运算"></a>NumPy 位运算</h2><ul>
<li><p>NumPy <strong>“bitwise_”</strong> 开头的函数是位运算函数。</p>
</li>
<li><p>NumPy 位运算包括以下几个函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>bitwise_and</code></td>
<td>对数组元素执行位与操作</td>
</tr>
<tr>
<td><code>bitwise_or</code></td>
<td>对数组元素执行位或操作</td>
</tr>
<tr>
<td><code>invert</code></td>
<td>按位取反</td>
</tr>
<tr>
<td><code>left_shift</code></td>
<td>向左移动二进制表示的位</td>
</tr>
<tr>
<td><code>right_shift</code></td>
<td>向右移动二进制表示的位</td>
</tr>
</tbody></table>
<p> <strong>注：</strong>也可以使用 “&amp;”、 “~”、 “|” 和 “^” 等操作符进行计算。 </p>
</li>
</ul>
<h3 id="bitwise-and"><a href="#bitwise-and" class="headerlink" title="bitwise_and"></a>bitwise_and</h3><ul>
<li><p>bitwise_and() 函数对数组中整数的二进制形式执行位与运算。</p>
</li>
<li><p>位与操作运算规律如下：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>AND</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="bitwise-or"><a href="#bitwise-or" class="headerlink" title="bitwise_or"></a>bitwise_or</h3><ul>
<li><p>bitwise_or()函数对数组中整数的二进制形式执行位或运算。</p>
</li>
<li><p>位或操作运算规律如下：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>OR</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="invert"><a href="#invert" class="headerlink" title="invert"></a>invert</h3><ul>
<li><p>invert() 函数对数组中整数进行位取反运算，即 0 变成 1，1 变成 0。</p>
</li>
<li><p>对于有符号整数，取该二进制数的补码，然后 +1。二进制数，最高位为0表示正数，最高位为 1 表示负数。</p>
</li>
</ul>
<h3 id="left-shift"><a href="#left-shift" class="headerlink" title="left_shift"></a>left_shift</h3><ul>
<li>left_shift() 函数将数组元素的二进制形式向左移动到指定位置，右侧附加相等数量的 0。</li>
</ul>
<h3 id="right-shift"><a href="#right-shift" class="headerlink" title="right_shift"></a>right_shift</h3><ul>
<li>right_shift() 函数将数组元素的二进制形式向右移动到指定位置，左侧附加相等数量的 0。</li>
</ul>
<h2 id="NumPy-字符串函数"><a href="#NumPy-字符串函数" class="headerlink" title="NumPy 字符串函数"></a>NumPy 字符串函数</h2><ul>
<li><p>以下函数用于对 dtype 为 numpy.string_ 或 numpy.unicode_ 的数组执行向量化字符串操作。 它们基于 Python 内置库中的标准字符串函数。</p>
</li>
<li><p>这些函数在字符数组类（numpy.char）中定义。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>add()</code></td>
<td>对两个数组的逐个字符串元素进行连接</td>
</tr>
<tr>
<td>multiply()</td>
<td>返回按元素多重连接后的字符串</td>
</tr>
<tr>
<td><code>center()</code></td>
<td>居中字符串</td>
</tr>
<tr>
<td><code>capitalize()</code></td>
<td>将字符串第一个字母转换为大写</td>
</tr>
<tr>
<td><code>title()</code></td>
<td>将字符串的每个单词的第一个字母转换为大写</td>
</tr>
<tr>
<td><code>lower()</code></td>
<td>数组元素转换为小写</td>
</tr>
<tr>
<td><code>upper()</code></td>
<td>数组元素转换为大写</td>
</tr>
<tr>
<td><code>split()</code></td>
<td>指定分隔符对字符串进行分割，并返回数组列表</td>
</tr>
<tr>
<td><code>splitlines()</code></td>
<td>返回元素中的行列表，以换行符分割</td>
</tr>
<tr>
<td><code>strip()</code></td>
<td>移除元素开头或者结尾处的特定字符</td>
</tr>
<tr>
<td><code>join()</code></td>
<td>通过指定分隔符来连接数组中的元素</td>
</tr>
<tr>
<td><code>replace()</code></td>
<td>使用新字符串替换字符串中的所有子字符串</td>
</tr>
<tr>
<td><code>decode()</code></td>
<td>数组元素依次调用<code>str.decode</code></td>
</tr>
<tr>
<td><code>encode()</code></td>
<td>数组元素依次调用<code>str.encode</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="numpy-char-add"><a href="#numpy-char-add" class="headerlink" title="numpy.char.add()"></a>numpy.char.add()</h3><ul>
<li>numpy.char.add() 函数依次对两个数组的元素进行字符串连接。</li>
</ul>
<h3 id="numpy-char-multiply"><a href="#numpy-char-multiply" class="headerlink" title="numpy.char.multiply()"></a>numpy.char.multiply()</h3><ul>
<li>numpy.char.multiply() 函数执行多重连接。</li>
</ul>
<h3 id="numpy-char-center"><a href="#numpy-char-center" class="headerlink" title="numpy.char.center()"></a>numpy.char.center()</h3><ul>
<li>numpy.char.center() 函数用于将字符串居中，并使用指定字符在左侧和右侧进行填充。</li>
</ul>
<h3 id="numpy-char-capitalize"><a href="#numpy-char-capitalize" class="headerlink" title="numpy.char.capitalize()"></a>numpy.char.capitalize()</h3><ul>
<li>numpy.char.capitalize() 函数将字符串的第一个字母转换为大写。</li>
</ul>
<h3 id="numpy-char-title"><a href="#numpy-char-title" class="headerlink" title="numpy.char.title()"></a>numpy.char.title()</h3><ul>
<li>numpy.char.title() 函数将字符串的每个单词的第一个字母转换为大写。</li>
</ul>
<h3 id="numpy-char-lower"><a href="#numpy-char-lower" class="headerlink" title="numpy.char.lower()"></a>numpy.char.lower()</h3><ul>
<li>numpy.char.lower() 函数对数组的每个元素转换为小写。它对每个元素调用 str.lower。</li>
</ul>
<h3 id="numpy-char-upper"><a href="#numpy-char-upper" class="headerlink" title="numpy.char.upper()"></a>numpy.char.upper()</h3><ul>
<li>numpy.char.upper() 函数对数组的每个元素转换为大写。它对每个元素调用 str.upper。</li>
</ul>
<h3 id="numpy-char-split"><a href="#numpy-char-split" class="headerlink" title="numpy.char.split()"></a>numpy.char.split()</h3><ul>
<li>numpy.char.split() 通过指定分隔符对字符串进行分割，并返回数组。默认情况下，分隔符为空格。</li>
</ul>
<h3 id="numpy-char-splitlines"><a href="#numpy-char-splitlines" class="headerlink" title="numpy.char.splitlines()"></a>numpy.char.splitlines()</h3><ul>
<li><p>numpy.char.splitlines() 函数以换行符作为分隔符来分割字符串，并返回数组。</p>
</li>
<li><p>\n，\r，\r\n 都可用作换行符。</p>
</li>
</ul>
<h3 id="numpy-char-strip"><a href="#numpy-char-strip" class="headerlink" title="numpy.char.strip()"></a>numpy.char.strip()</h3><ul>
<li>numpy.char.strip() 函数用于移除开头或结尾处的特定字符。</li>
</ul>
<h3 id="numpy-char-join"><a href="#numpy-char-join" class="headerlink" title="numpy.char.join()"></a>numpy.char.join()</h3><ul>
<li>numpy.char.join() 函数通过指定分隔符来连接数组中的元素或字符串。</li>
</ul>
<h3 id="numpy-char-replace"><a href="#numpy-char-replace" class="headerlink" title="numpy.char.replace()"></a>numpy.char.replace()</h3><ul>
<li>numpy.char.replace() 函数使用新字符串替换字符串中的所有子字符串。</li>
</ul>
<h3 id="numpy-char-encode"><a href="#numpy-char-encode" class="headerlink" title="numpy.char.encode()"></a>numpy.char.encode()</h3><ul>
<li>numpy.char.encode() 函数对数组中的每个元素调用 str.encode 函数。 默认编码是 utf-8，可以使用标准 Python 库中的编解码器。</li>
</ul>
<h3 id="numpy-char-decode"><a href="#numpy-char-decode" class="headerlink" title="numpy.char.decode()"></a>numpy.char.decode()</h3><ul>
<li>numpy.char.decode() 函数对编码的元素进行 str.decode() 解码。</li>
</ul>
<h2 id="NumPy-数学函数"><a href="#NumPy-数学函数" class="headerlink" title="NumPy 数学函数"></a>NumPy 数学函数</h2><p>NumPy 包含大量的各种数学运算的函数，包括三角函数，算术运算的函数，复数处理函数等</p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><ul>
<li><p>NumPy 提供了标准的三角函数：sin()、cos()、tan()。</p>
</li>
<li><p>arcsin，arccos，和 arctan 函数返回给定角度的 sin，cos 和 tan 的反三角函数。</p>
</li>
<li><p>这些函数的结果可以通过 numpy.degrees() 函数将弧度转换为角度。</p>
</li>
</ul>
<h3 id="舍入函数"><a href="#舍入函数" class="headerlink" title="舍入函数"></a>舍入函数</h3><h4 id="numpy-around"><a href="#numpy-around" class="headerlink" title="numpy.around()"></a>numpy.around()</h4><p>函数返回指定数字的四舍五入值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.around(a,decimals)</span><br><span class="line"><span class="comment">#  a: 数组</span></span><br><span class="line"><span class="comment"># decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-floor"><a href="#numpy-floor" class="headerlink" title="numpy.floor()"></a>numpy.floor()</h4><p>numpy.floor() 返回小于或者等于指定表达式的最大整数，即向下取整。</p>
<h4 id="numpy-ceil"><a href="#numpy-ceil" class="headerlink" title="numpy.ceil()"></a>numpy.ceil()</h4><p>numpy.ceil() 返回大于或者等于指定表达式的最小整数，即向上取整。</p>
<h2 id="NumPy-算术函数"><a href="#NumPy-算术函数" class="headerlink" title="NumPy 算术函数"></a>NumPy 算术函数</h2><ul>
<li><p>NumPy 算术函数包含简单的加减乘除: add()，subtract()，multiply() 和 divide()。</p>
</li>
<li><p>需要注意的是数组必须具有相同的形状或符合数组广播规则。</p>
</li>
</ul>
<ul>
<li>此外 Numpy 也包含了其他重要的算术函数。</li>
</ul>
<h3 id="numpy-reciprocal"><a href="#numpy-reciprocal" class="headerlink" title="numpy.reciprocal()"></a>numpy.reciprocal()</h3><p>numpy.reciprocal() 函数返回参数逐元素的倒数。如 1/4 倒数为 4/1。</p>
<h4 id="numpy-power"><a href="#numpy-power" class="headerlink" title="numpy.power()"></a>numpy.power()</h4><p>numpy.power() 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p>
<h4 id="numpy-mod"><a href="#numpy-mod" class="headerlink" title="numpy.mod()"></a>numpy.mod()</h4><p>numpy.mod() 计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder() 也产生相同的结果。</p>
<h2 id="NumPy-统计函数"><a href="#NumPy-统计函数" class="headerlink" title="NumPy 统计函数"></a>NumPy 统计函数</h2><p>NumPy 提供了很多统计函数，用于从数组中查找最小元素，最大元素，百分位标准差和方差等。 函数说明如下：</p>
<h3 id="numpy-amin-和-numpy-amax"><a href="#numpy-amin-和-numpy-amax" class="headerlink" title="numpy.amin() 和 numpy.amax()"></a>numpy.amin() 和 numpy.amax()</h3><ul>
<li><p>numpy.amin() 用于计算数组中的元素沿指定轴的最小值。</p>
</li>
<li><p>numpy.amax() 用于计算数组中的元素沿指定轴的最大值。</p>
</li>
</ul>
<h3 id="numpy-ptp"><a href="#numpy-ptp" class="headerlink" title="numpy.ptp()"></a>numpy.ptp()</h3><ul>
<li>numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</li>
</ul>
<h3 id="numpy-percentile"><a href="#numpy-percentile" class="headerlink" title="numpy.percentile()"></a>numpy.percentile()</h3><ul>
<li>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数numpy.percentile()接受以下参数。</li>
</ul>
<h3 id="numpy-percentile-a-q-axis"><a href="#numpy-percentile-a-q-axis" class="headerlink" title="numpy.percentile(a, q, axis)"></a>numpy.percentile(a, q, axis)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> numpy.percentile(a, q, axis) </span><br><span class="line"><span class="comment"># a: 输入数组</span></span><br><span class="line"><span class="comment"># q: 要计算的百分位数，在 0 ~ 100 之间</span></span><br><span class="line"><span class="comment"># axis: 沿着它计算百分位数的轴</span></span><br></pre></td></tr></table></figure>


<p>首先明确百分位数：</p>
<p>​    第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。</p>
<p>​    举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。这里的 p = 70。</p>
<h3 id="numpy-median"><a href="#numpy-median" class="headerlink" title="numpy.median()"></a>numpy.median()</h3><p>numpy.median() 函数用于计算数组 a 中元素的中位数（中值）</p>
<h4 id="numpy-mean"><a href="#numpy-mean" class="headerlink" title="numpy.mean()"></a>numpy.mean()</h4><p>numpy.mean() 函数返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。</p>
<p>算术平均值是沿轴的元素的总和除以元素的数量。</p>
<h4 id="numpy-average"><a href="#numpy-average" class="headerlink" title="numpy.average()"></a>numpy.average()</h4><p>numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。</p>
<h3 id="numpy-std"><a href="#numpy-std" class="headerlink" title="numpy.std()"></a>numpy.std()</h3><p>求标准差</p>
<h3 id="numpy-var"><a href="#numpy-var" class="headerlink" title="numpy.var()"></a>numpy.var()</h3><p>统计中的方差</p>
<h2 id="NumPy-排序、条件刷选函数"><a href="#NumPy-排序、条件刷选函数" class="headerlink" title="NumPy 排序、条件刷选函数"></a>NumPy 排序、条件刷选函数</h2><p>NumPy 提供了多种排序的方法。 这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>速度</th>
<th>最坏情况</th>
<th>工作空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;quicksort&#39;</code>（快速排序）</td>
<td>1</td>
<td><code>O(n^2)</code></td>
<td>0</td>
<td>否</td>
</tr>
<tr>
<td><code>&#39;mergesort&#39;</code>（归并排序）</td>
<td>2</td>
<td><code>O(n*log(n))</code></td>
<td>~n/2</td>
<td>是</td>
</tr>
<tr>
<td><code>&#39;heapsort&#39;</code>（堆排序）</td>
<td>3</td>
<td><code>O(n*log(n))</code></td>
<td>0</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="numpy-sort"><a href="#numpy-sort" class="headerlink" title="numpy.sort()"></a>numpy.sort()</h3><p>numpy.sort() 函数返回输入数组的排序副本。函数格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.sort(a, axis, kind, order)</span><br><span class="line"><span class="comment">#a: 要排序的数组</span></span><br><span class="line"><span class="comment"># axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序</span></span><br><span class="line"><span class="comment"># kind: 默认为’quicksort’（快速排序）</span></span><br><span class="line"><span class="comment"># order: 如果数组包含字段，则是要排序的字段</span></span><br></pre></td></tr></table></figure>

<h3 id="numpy-argsort"><a href="#numpy-argsort" class="headerlink" title="numpy.argsort()"></a>numpy.argsort()</h3><p>numpy.argsort() 函数返回的是数组值从小到大的索引值。</p>
<h3 id="numpy-lexsort"><a href="#numpy-lexsort" class="headerlink" title="numpy.lexsort()"></a>numpy.lexsort()</h3><p>numpy.lexsort() 用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p>
<p>这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p>
<h3 id="msort、sort-complex、partition、argpartition"><a href="#msort、sort-complex、partition、argpartition" class="headerlink" title="msort、sort_complex、partition、argpartition"></a>msort、sort_complex、partition、argpartition</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>msort(a)</td>
<td>数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis=0)。</td>
</tr>
<tr>
<td>sort_complex(a)</td>
<td>对复数按照先实部后虚部的顺序进行排序。</td>
</tr>
<tr>
<td>partition(a, kth[, axis, kind, order])</td>
<td>指定一个数，对数组进行分区</td>
</tr>
<tr>
<td>argpartition(a, kth[, axis, kind, order])</td>
<td>可以通过关键字 kind 指定算法沿着指定轴对数组进行分区</td>
</tr>
</tbody></table>
<h3 id="numpy-argmax-和-numpy-argmin"><a href="#numpy-argmax-和-numpy-argmin" class="headerlink" title="numpy.argmax() 和 numpy.argmin()"></a>numpy.argmax() 和 numpy.argmin()</h3><p>​    numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引。</p>
<h3 id="numpy-nonzero"><a href="#numpy-nonzero" class="headerlink" title="numpy.nonzero()"></a>numpy.nonzero()</h3><p>​    numpy.nonzero() 函数返回输入数组中非零元素的索引。</p>
<h3 id="numpy-where"><a href="#numpy-where" class="headerlink" title="numpy.where()"></a>numpy.where()</h3><p>​    numpy.where() 函数返回输入数组中满足给定条件的元素的索引。</p>
<h3 id="numpy-extract"><a href="#numpy-extract" class="headerlink" title="numpy.extract()"></a>numpy.extract()</h3><p>​    numpy.extract() 函数根据某个条件从数组中抽取元素，返回满条件的元素。</p>
<h2 id="NumPy-字节交换"><a href="#NumPy-字节交换" class="headerlink" title="NumPy 字节交换"></a>NumPy 字节交换</h2><p>​    在几乎所有的机器上，多字节对象都被存储为连续的字节序列。字节顺序，是跨越多字节的程序对象的存储规则。</p>
<p>​    <strong>大端模式：</strong>指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。<br>​    <strong>小端模式：</strong>指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。<br>例如在 C 语言中，一个类型为 int 的变量 x 地址为 0x100，那么其对应地址表达式&amp;x的值为 0x100。且x的四个字节将被存储在存储器的 0x100, 0x101, 0x102, 0x103位置。</p>
<p><strong>numpy.ndarray.byteswap()</strong></p>
<p>​    numpy.ndarray.byteswap() 函数将 ndarray 中每个元素中的字节进行大小端转换。</p>
<h2 id="NumPy-副本和视图"><a href="#NumPy-副本和视图" class="headerlink" title="NumPy 副本和视图"></a>NumPy 副本和视图</h2><ul>
<li><p>副本是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。</p>
</li>
<li><p>视图是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。</p>
</li>
</ul>
<ul>
<li><p>视图一般发生在：</p>
<ul>
<li>numpy 的切片操作返回原数据的视图。</li>
<li>调用 ndarray 的 view() 函数产生一个视图。</li>
</ul>
</li>
<li><p>副本一般发生在：</p>
<ul>
<li><p>Python 序列的切片操作，调用deepCopy()函数。</p>
</li>
<li><p>调用 ndarray 的 copy() 函数产生一个副本。</p>
</li>
</ul>
</li>
</ul>
<h3 id="无复制"><a href="#无复制" class="headerlink" title="无复制"></a>无复制</h3><p>​    简单的赋值不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 id()返回 Python 对象的通用标识符，类似于 C 中的指针。</p>
<p>此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p>
<h4 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h4><p>ndarray.view() 方会创建一个新的数组对象，该方法创建的新数组的维数更改不会更改原始数据的维数。使用切片创建视图修改数据会影响到原始数组。</p>
<h4 id="副本或深拷贝"><a href="#副本或深拷贝" class="headerlink" title="副本或深拷贝"></a>副本或深拷贝</h4><p>ndarray.copy() 函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。</p>
<h3 id="Python-append-与深拷贝、浅拷贝"><a href="#Python-append-与深拷贝、浅拷贝" class="headerlink" title="Python append() 与深拷贝、浅拷贝"></a>Python append() 与深拷贝、浅拷贝</h3><h4 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h4><p>在 Python 中，对象赋值实际上是对象的引用。当创建一个对象，然后把它赋给另一个变量的时候，Python 并没有拷贝这个对象，而只是拷贝了这个对象的引用，我们称之为浅拷贝。</p>
<p>在 Python 中，为了使当进行赋值操作时，两个变量互补影响，可以使用 copy 模块中的 deepcopy 方法，称之为深拷贝。</p>
<h4 id="append-函数"><a href="#append-函数" class="headerlink" title="append() 函数"></a>append() 函数</h4><p>当 list 类型的对象进行 append 操作时，实际上追加的是该对象的引用。</p>
<p>id() 函数：返回对象的唯一标识，可以类比成该对象在内存中的地址。</p>
<h2 id="NumPy-矩阵库-Matrix"><a href="#NumPy-矩阵库-Matrix" class="headerlink" title="NumPy 矩阵库(Matrix)"></a>NumPy 矩阵库(Matrix)</h2><p>NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。</p>
<p>一个m × n  的矩阵是一个由 $ m $ 行（row）列 $ n $（column）元素排列成的矩形阵列。</p>
<p>矩阵里的元素可以是数字、符号或数学式。</p>
<h3 id="matlib-empty"><a href="#matlib-empty" class="headerlink" title="matlib.empty()"></a>matlib.empty()</h3><p>​    matlib.empty() 函数返回一个新的矩阵，语法格式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.matlib.empty(shape, dtype, order)</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># shape: 定义新矩阵形状的整数或整数元组</span></span><br><span class="line"><span class="comment"># Dtype: 可选，数据类型</span></span><br><span class="line"><span class="comment"># order: C（行序优先） 或者 F（列序优先）numpy.matlib.zeros()</span></span><br><span class="line">numpy.matlib.zeros() 函数创建一个以 <span class="number">0</span> 填充的矩阵。</span><br></pre></td></tr></table></figure>

<h3 id="numpy-matlib-ones"><a href="#numpy-matlib-ones" class="headerlink" title="numpy.matlib.ones()"></a>numpy.matlib.ones()</h3><p>​    numpy.matlib.ones()函数创建一个以 1 填充的矩阵。</p>
<h3 id="numpy-matlib-eye"><a href="#numpy-matlib-eye" class="headerlink" title="numpy.matlib.eye()"></a>numpy.matlib.eye()</h3><p>​    numpy.matlib.eye() 函数返回一个矩阵，对角线元素为 1，其他位置为零。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.matlib.eye(n, M,k, dtype)</span><br><span class="line"><span class="comment"># n: 返回矩阵的行数</span></span><br><span class="line"><span class="comment"># M: 返回矩阵的列数，默认为 n</span></span><br><span class="line"><span class="comment"># k: 对角线的索引</span></span><br><span class="line"><span class="comment"># dtype: 数据类型</span></span><br></pre></td></tr></table></figure>

<h3 id="numpy-matlib-identity"><a href="#numpy-matlib-identity" class="headerlink" title="numpy.matlib.identity()"></a>numpy.matlib.identity()</h3><p>​    numpy.matlib.identity() 函数返回给定大小的单位矩阵。</p>
<p>​    单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。</p>
<p>​     <img src="/2022/08/06/Numpy%E6%95%99%E7%A8%8B/20200327233848845.png" alt="在这里插入图片描述"> </p>
<h3 id="numpy-matlib-rand"><a href="#numpy-matlib-rand" class="headerlink" title="numpy.matlib.rand()"></a>numpy.matlib.rand()</h3><p>​    numpy.matlib.rand() 函数创建一个给定大小的矩阵，数据是随机填充的。</p>
<h2 id="NumPy-线性代数"><a href="#NumPy-线性代数" class="headerlink" title="NumPy 线性代数"></a>NumPy 线性代数</h2><p>NumPy 提供了线性代数函数库 <strong>linalg</strong>，该库包含了线性代数所需的所有功能，可以看看下面的说明：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>dot</code></td>
<td>两个数组的点积，即元素对应相乘。</td>
</tr>
<tr>
<td><code>vdot</code></td>
<td>两个向量的点积</td>
</tr>
<tr>
<td><code>inner</code></td>
<td>两个数组的内积</td>
</tr>
<tr>
<td><code>matmul</code></td>
<td>两个数组的矩阵积</td>
</tr>
<tr>
<td><code>determinant</code></td>
<td>数组的行列式</td>
</tr>
<tr>
<td><code>solve</code></td>
<td>求解线性矩阵方程</td>
</tr>
<tr>
<td><code>inv</code></td>
<td>计算矩阵的乘法逆矩阵</td>
</tr>
</tbody></table>
<h3 id="numpy-dot"><a href="#numpy-dot" class="headerlink" title="numpy.dot()"></a>numpy.dot()</h3><p>​    numpy.dot() 对于两个一维的数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为内积)；对于二维数组，计算的是两个数组的矩阵乘积；对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和： dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.dot(a, b, out=<span class="literal">None</span>) </span><br><span class="line"><span class="comment"># a : ndarray 数组</span></span><br><span class="line"><span class="comment"># b : ndarray 数组</span></span><br><span class="line"><span class="comment"># out : ndarray, 可选，用来保存dot()的计算结果</span></span><br></pre></td></tr></table></figure>

<h3 id="numpy-vdot"><a href="#numpy-vdot" class="headerlink" title="numpy.vdot()"></a>numpy.vdot()</h3><p>​    numpy.vdot() 函数是两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开。</p>
<h3 id="numpy-inner"><a href="#numpy-inner" class="headerlink" title="numpy.inner()"></a>numpy.inner()</h3><p>​    numpy.inner() 函数返回一维数组的向量内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p>
<h3 id="numpy-matmul"><a href="#numpy-matmul" class="headerlink" title="numpy.matmul"></a>numpy.matmul</h3><p>​    numpy.matmul 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。</p>
<p>​    另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。</p>
<h3 id="numpy-linalg-det"><a href="#numpy-linalg-det" class="headerlink" title="numpy.linalg.det()"></a>numpy.linalg.det()</h3><p>​    numpy.linalg.det() 函数计算输入矩阵的行列式。</p>
<p>​    行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。</p>
<p>​    换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为 ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。</p>
<h3 id="numpy-linalg-solve"><a href="#numpy-linalg-solve" class="headerlink" title="numpy.linalg.solve()"></a>numpy.linalg.solve()</h3><p>​    numpy.linalg.solve() 函数给出了矩阵形式的线性方程的解。</p>
<h3 id="numpy-linalg-inv"><a href="#numpy-linalg-inv" class="headerlink" title="numpy.linalg.inv()"></a>numpy.linalg.inv()</h3><p>​    numpy.linalg.inv() 函数计算矩阵的乘法逆矩阵。</p>
<p>​    <strong>逆矩阵（inverse matrix）</strong>：设A是数域上的一个n阶矩阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=E ，则我们称B是A的逆矩阵，而A则被称为可逆矩阵。注：E为单位矩阵。</p>
<h2 id="NumPy-IO"><a href="#NumPy-IO" class="headerlink" title="NumPy IO"></a>NumPy IO</h2><p>Numpy 可以读写磁盘上的文本数据或二进制数据。</p>
<p>NumPy 为 ndarray 对象引入了一个简单的文件格式：npy。</p>
<p>npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。</p>
<p>常用的 IO 函数有：</p>
<ul>
<li>load() 和 save() 函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。</li>
</ul>
<ul>
<li>savze() 函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。</li>
</ul>
<ul>
<li>loadtxt() 和 savetxt() 函数处理正常的文本文件(.txt 等)</li>
</ul>
<h3 id="numpy-save"><a href="#numpy-save" class="headerlink" title="numpy.save()"></a>numpy.save()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.save() 函数将数组保存到以 .npy 为扩展名的文件中。</span><br><span class="line"><span class="comment"># arr: 要保存的数组</span></span><br><span class="line"><span class="comment"># allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。</span></span><br><span class="line"><span class="comment"># fix_imports: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据。</span></span><br><span class="line"><span class="comment"># .npy是 Numpy 专用的二进制格式后的数据，可以使用 load() 函数来读取数据就可以正常显示。</span></span><br></pre></td></tr></table></figure>

<h3 id="numpy-savez"><a href="#numpy-savez" class="headerlink" title="numpy.savez"></a>numpy.savez</h3><p>​    numpy.savez() 函数将多个数组保存到以 npz 为扩展名的文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.savez(file, *args, **kwds)</span><br><span class="line"><span class="comment"># file：要保存的文件，扩展名为 .npz，如果文件路径末尾没有扩展名 .npz，该扩展名会被自动加上。</span></span><br><span class="line"><span class="comment"># args: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为 arr_0, arr_1, …　。</span></span><br><span class="line"><span class="comment"># kwds: 要保存的数组使用关键字名称。</span></span><br></pre></td></tr></table></figure>

<h3 id="numpy-savetxt"><a href="#numpy-savetxt" class="headerlink" title="numpy.savetxt()"></a>numpy.savetxt()</h3><p>​    savetxt() 函数是以简单的文本文件格式存储数据，对应的使用 loadtxt() 函数来获取数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.loadtxt(FILENAME, dtype=<span class="built_in">int</span>, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">np.savetxt(FILENAME, a, fmt=<span class="string">&quot;%d&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="comment"># 参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib笔记</title>
    <url>/2022/08/08/Matplotlib%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="matplotlib函数功能速查"><a href="#matplotlib函数功能速查" class="headerlink" title="matplotlib函数功能速查"></a>matplotlib函数功能速查</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>plt.plot(x,y,fmt,…)</td>
<td>绘制一个坐标图</td>
</tr>
<tr>
<td>plt.boxplot(data,notch,position)</td>
<td>绘制一个箱型图</td>
</tr>
<tr>
<td>plt.bar(left,height,width,bottom)</td>
<td>绘制一个条形图</td>
</tr>
<tr>
<td>plt.barh(width,bottom,left,height)</td>
<td>绘制一个横向条形图</td>
</tr>
<tr>
<td>plt.polar(theta,r)</td>
<td>绘制极坐标图</td>
</tr>
<tr>
<td>plt.pie(data,explode)</td>
<td>绘制饼图(explode接收一个列表,根据列表对应数据突出各部分内容)</td>
</tr>
<tr>
<td>plt.psd(x,NFFT=256,pad_to,Fs)</td>
<td>绘制功率谱密度图</td>
</tr>
<tr>
<td>plt.specgram(x,NFFT=256,pad,F)</td>
<td>绘制谱图</td>
</tr>
<tr>
<td>plt.cohere(x,y,NFFT=256,Fs)</td>
<td>绘制X-Y的相关性函数</td>
</tr>
<tr>
<td>plt.scatter(x,y)</td>
<td>绘制散点图,其中,x和y长度相同</td>
</tr>
<tr>
<td>plt.step(x,y,where)</td>
<td>绘制步阶图</td>
</tr>
<tr>
<td>plt.hist(x,bins,normed)</td>
<td>绘制直方图(bins表示直方图个数,当normed=1时,将数据出现次数转换成频率)</td>
</tr>
<tr>
<td>plt.contour(X,Y,Z,N)</td>
<td>绘制等值图</td>
</tr>
<tr>
<td>plt.vlines</td>
<td>绘制垂直图</td>
</tr>
<tr>
<td>plt.stem(x,y,linefmt,markerfmt)</td>
<td>绘制柴火图</td>
</tr>
<tr>
<td>plt.plot_date</td>
<td>绘制数据日期</td>
</tr>
</tbody></table>
<h3 id="matplotlib基本功能"><a href="#matplotlib基本功能" class="headerlink" title="matplotlib基本功能"></a>matplotlib基本功能</h3><ol>
<li>基本绘图 （在二维平面坐标系中绘制连续的线）<ol>
<li>设置线型、线宽和颜色  </li>
<li>设置坐标轴范围</li>
<li>设置坐标刻度</li>
<li>设置坐标轴</li>
<li>图例</li>
<li>特殊点</li>
<li>备注</li>
</ol>
</li>
<li>图形对象(图形窗口)<ol>
<li>子图</li>
<li>刻度定位器</li>
<li>刻度网格线</li>
<li>半对数坐标</li>
<li>散点图</li>
<li>填充</li>
<li>条形图</li>
<li>饼图</li>
<li>等高线图</li>
<li>热成像图</li>
<li>三维曲面</li>
<li>简单动画</li>
</ol>
</li>
</ol>
<h3 id="基本绘图"><a href="#基本绘图" class="headerlink" title="基本绘图"></a>基本绘图</h3><h4 id="绘图核心API"><a href="#绘图核心API" class="headerlink" title="绘图核心API"></a>绘图核心API</h4><p>案例：绘制一条余弦曲线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="comment"># xarray: &lt;序列&gt; 水平坐标序列</span></span><br><span class="line"><span class="comment"># yarray: &lt;序列&gt; 垂直坐标序列</span></span><br><span class="line">mp.plot(xarray, yarray)</span><br><span class="line"><span class="comment">#显示图表</span></span><br><span class="line">mp.show()</span><br></pre></td></tr></table></figure>

<p>绘制水平线与垂直线：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="comment"># vertical 绘制垂直线</span></span><br><span class="line">mp.vlines(vval, ymin, ymax, ...)</span><br><span class="line"><span class="comment"># horizotal 绘制水平线</span></span><br><span class="line">mp.hlines(xval, xmin, xmax, ...)</span><br><span class="line"><span class="comment">#显示图表</span></span><br><span class="line">mp.show()</span><br></pre></td></tr></table></figure>

<h4 id="线型、线宽和颜色"><a href="#线型、线宽和颜色" class="headerlink" title="线型、线宽和颜色"></a>线型、线宽和颜色</h4><p>案例：绘制一条正弦曲线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">	<span class="comment">#	数字</span></span><br><span class="line"><span class="comment">#color: &lt;关键字参数&gt; 颜色</span></span><br><span class="line">	<span class="comment">#	英文颜色单词 或 常见颜色英文单词首字母 或 #495434 或 (1,1,1) 或 (1,1,1,1)</span></span><br><span class="line"><span class="comment">#alpha: &lt;关键字参数&gt; 透明度</span></span><br><span class="line">	<span class="comment">#	浮点数值</span></span><br><span class="line">mp.plot(xarray, yarray, linestyle=<span class="string">&#x27;&#x27;</span>, linewidth=<span class="number">1</span>, color=<span class="string">&#x27;&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<h4 id="设置坐标轴范围"><a href="#设置坐标轴范围" class="headerlink" title="设置坐标轴范围"></a>设置坐标轴范围</h4><p>案例：把坐标轴范围设置为 -π ~ π</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#x_limt_min:	&lt;float&gt; x轴范围最小值</span></span><br><span class="line"><span class="comment">#x_limit_max:	&lt;float&gt; x轴范围最大值</span></span><br><span class="line">mp.xlim(x_limt_min, x_limit_max)</span><br><span class="line"><span class="comment">#y_limt_min:	&lt;float&gt; y轴范围最小值</span></span><br><span class="line"><span class="comment">#y_limit_max:	&lt;float&gt; y轴范围最大值</span></span><br><span class="line">mp.ylim(y_limt_min, y_limit_max)</span><br></pre></td></tr></table></figure>

<h4 id="设置坐标刻度"><a href="#设置坐标刻度" class="headerlink" title="设置坐标刻度"></a>设置坐标刻度</h4><p>案例：把横坐标的刻度显示为：0, π/2, π, 3π/2, 2π</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#x_val_list: 	x轴刻度值序列</span></span><br><span class="line"><span class="comment">#x_text_list:	x轴刻度标签文本序列 [可选]</span></span><br><span class="line">mp.xticks(x_val_list , x_text_list )</span><br><span class="line"><span class="comment">#y_val_list: 	y轴刻度值序列</span></span><br><span class="line"><span class="comment">#y_text_list:	y轴刻度标签文本序列 [可选]</span></span><br><span class="line">mp.yticks(y_val_list , y_text_list )</span><br></pre></td></tr></table></figure>

<p><em><strong>刻度文本的特殊语法</strong></em> – <em>LaTex排版语法字符串</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">r&#x27;$x^n+y^n=z^n$&#x27;</span>,   <span class="string">r&#x27;$\int\frac&#123;1&#125;&#123;x&#125; dx = \ln |x| + C$&#x27;</span>,     <span class="string">r&#x27;$-\frac&#123;\pi&#125;&#123;2&#125;$&#x27;</span></span><br></pre></td></tr></table></figure>

<p>$$<br>x^n+y^n=z^n,  \int\frac{1}{x} dx = \ln |x| + C,     -\frac{\pi}{2}<br>$$</p>
<h4 id="设置坐标轴"><a href="#设置坐标轴" class="headerlink" title="设置坐标轴"></a>设置坐标轴</h4><p>坐标轴名：left / right / bottom / top</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取当前坐标轴字典，&#123;&#x27;left&#x27;:左轴,&#x27;right&#x27;:右轴,&#x27;bottom&#x27;:下轴,&#x27;top&#x27;:上轴 &#125;</span></span><br><span class="line">ax = mp.gca()</span><br><span class="line"><span class="comment"># 获取其中某个坐标轴</span></span><br><span class="line">axis = ax.spines[<span class="string">&#x27;坐标轴名&#x27;</span>]</span><br><span class="line"><span class="comment"># 设置坐标轴的位置。 该方法需要传入2个元素的元组作为参数</span></span><br><span class="line"><span class="comment"># type: &lt;<span class="built_in">str</span>&gt; 移动坐标轴的参照类型  一般为&#x27;data&#x27; (以数据的值作为移动参照值)</span></span><br><span class="line"><span class="comment"># val:  参照值</span></span><br><span class="line">axis.set_position((<span class="built_in">type</span>, val))</span><br><span class="line"><span class="comment"># 设置坐标轴的颜色</span></span><br><span class="line"><span class="comment"># color: &lt;str&gt; 颜色值字符串</span></span><br><span class="line">axis.set_color(color)</span><br></pre></td></tr></table></figure>

<p>案例：设置坐标轴至中心。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置坐标轴</span></span><br><span class="line">ax = mp.gca()</span><br><span class="line">axis_b = ax.spines[<span class="string">&#x27;bottom&#x27;</span>]</span><br><span class="line">axis_b.set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">axis_l = ax.spines[<span class="string">&#x27;left&#x27;</span>]</span><br><span class="line">axis_l.set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p>显示两条曲线的图例，并测试loc属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 再绘制曲线时定义曲线的label</span></span><br><span class="line"><span class="comment"># label: &lt;关键字参数 str&gt; 支持LaTex排版语法字符串</span></span><br><span class="line">mp.plot(xarray, yarray ... label=<span class="string">&#x27;&#x27;</span>, ...)</span><br><span class="line"><span class="comment"># 设置图例的位置</span></span><br><span class="line"><span class="comment"># loc: &lt;关键字参数&gt; 制定图例的显示位置 (若不设置loc，则显示默认位置)</span></span><br><span class="line"><span class="comment">#	 ===============   =============</span></span><br><span class="line"><span class="comment">#    Location String   Location Code</span></span><br><span class="line"><span class="comment">#    ===============   =============</span></span><br><span class="line"><span class="comment">#    &#x27;best&#x27;            0</span></span><br><span class="line"><span class="comment">#    &#x27;upper right&#x27;     1</span></span><br><span class="line"><span class="comment">#    &#x27;upper left&#x27;      2</span></span><br><span class="line"><span class="comment">#    &#x27;lower left&#x27;      3</span></span><br><span class="line"><span class="comment">#    &#x27;lower right&#x27;     4</span></span><br><span class="line"><span class="comment">#    &#x27;right&#x27;           5</span></span><br><span class="line"><span class="comment">#    &#x27;center left&#x27;     6</span></span><br><span class="line"><span class="comment">#    &#x27;center right&#x27;    7</span></span><br><span class="line"><span class="comment">#    &#x27;lower center&#x27;    8</span></span><br><span class="line"><span class="comment">#    &#x27;upper center&#x27;    9</span></span><br><span class="line"><span class="comment">#    &#x27;center&#x27;          10</span></span><br><span class="line"><span class="comment">#    ===============   =============</span></span><br><span class="line">mp.legend(loc=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="特殊点"><a href="#特殊点" class="headerlink" title="特殊点"></a>特殊点</h4><p>案例：绘制当x=3π/4时两条曲线上的特殊点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xarray: &lt;序列&gt; 所有需要标注点的水平坐标组成的序列</span></span><br><span class="line"><span class="comment"># yarray: &lt;序列&gt; 所有需要标注点的垂直坐标组成的序列</span></span><br><span class="line">mp.scatter(xarray, yarray, </span><br><span class="line">           marker=<span class="string">&#x27;&#x27;</span>, 		<span class="comment">#点型 ~ matplotlib.markers</span></span><br><span class="line">           s=<span class="string">&#x27;&#x27;</span>, 			<span class="comment">#大小</span></span><br><span class="line">           edgecolor=<span class="string">&#x27;&#x27;</span>, 	<span class="comment">#边缘色</span></span><br><span class="line">           facecolor=<span class="string">&#x27;&#x27;</span>,	<span class="comment">#填充色</span></span><br><span class="line">           zorder=<span class="number">3</span>			<span class="comment">#绘制图层编号 （编号越大，图层越靠上）</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>marker点型可参照：help(matplotlib.markers)</em></p>
<p><em>也可参照附录： matplotlib point样式</em></p>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>案例：为在某条曲线上的点添加备注，指明函数方程与值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在图表中为某个点添加备注。包含备注文本，备注箭头等图像的设置。</span></span><br><span class="line">mp.annotate(</span><br><span class="line">    <span class="string">r&#x27;$\frac&#123;\pi&#125;&#123;2&#125;$&#x27;</span>,			<span class="comment">#备注中显示的文本内容</span></span><br><span class="line">    xycoords=<span class="string">&#x27;data&#x27;</span>,			<span class="comment">#备注目标点所使用的坐标系（data表示数据坐标系）</span></span><br><span class="line">    xy=(x, y),	 				<span class="comment">#备注目标点的坐标</span></span><br><span class="line">    textcoords=<span class="string">&#x27;offset points&#x27;</span>,	<span class="comment">#备注文本所使用的坐标系（offset points表示参照点的偏移坐标系）</span></span><br><span class="line">    xytext=(x, y),				<span class="comment">#备注文本的坐标</span></span><br><span class="line">    fontsize=<span class="number">14</span>,				<span class="comment">#备注文本的字体大小</span></span><br><span class="line">    arrowprops=<span class="built_in">dict</span>()			<span class="comment">#使用字典定义文本指向目标点的箭头样式</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>arrowprops参数使用字典定义指向目标点的箭头样式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#arrowprops字典参数的常用key</span></span><br><span class="line">arrowprops=<span class="built_in">dict</span>(</span><br><span class="line">	arrowstyle=<span class="string">&#x27;&#x27;</span>,		<span class="comment">#定义箭头样式</span></span><br><span class="line">    connectionstyle=<span class="string">&#x27;&#x27;</span>	<span class="comment">#定义连接线的样式</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>箭头样式（arrowstyle）字符串如下</p>
<pre><code>============   =============================================
Name           Attrs
============   =============================================
  &#39;-&#39;          None
  &#39;-&gt;&#39;         head_length=0.4,head_width=0.2
  &#39;-[&#39;         widthB=1.0,lengthB=0.2,angleB=None
  &#39;|-|&#39;        widthA=1.0,widthB=1.0
  &#39;-|&gt;&#39;        head_length=0.4,head_width=0.2
  &#39;&lt;-&#39;         head_length=0.4,head_width=0.2
  &#39;&lt;-&gt;&#39;        head_length=0.4,head_width=0.2
  &#39;&lt;|-&#39;        head_length=0.4,head_width=0.2
  &#39;&lt;|-|&gt;&#39;      head_length=0.4,head_width=0.2
  &#39;fancy&#39;      head_length=0.4,head_width=0.4,tail_width=0.4
  &#39;simple&#39;     head_length=0.5,head_width=0.5,tail_width=0.2
  &#39;wedge&#39;      tail_width=0.3,shrink_factor=0.5
============   =============================================
</code></pre>
<p>连接线样式（connectionstyle）字符串如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">============   =============================================</span><br><span class="line">Name           Attrs</span><br><span class="line">============   =============================================</span><br><span class="line">  &#x27;angle&#x27; 		angleA=90,angleB=0,rad=0.0</span><br><span class="line">  &#x27;angle3&#x27; 		angleA=90,angleB=0`   </span><br><span class="line">  &#x27;arc&#x27;			angleA=0,angleB=0,armA=None,armB=None,rad=0.0</span><br><span class="line">  &#x27;arc3&#x27; 		rad=0.0</span><br><span class="line">  &#x27;bar&#x27; 		armA=0.0,armB=0.0,fraction=0.3,angle=None</span><br><span class="line">============   =============================================</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="图形对象（图形窗口）"><a href="#图形对象（图形窗口）" class="headerlink" title="图形对象（图形窗口）"></a>图形对象（图形窗口）</h3><p>案例：绘制两个窗口，一起显示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动构建 matplotlib 窗口</span></span><br><span class="line">mp.figure(</span><br><span class="line">    <span class="string">&#x27;&#x27;</span>,					<span class="comment">#窗口标题栏文本 </span></span><br><span class="line">    figsize=(<span class="number">4</span>, <span class="number">3</span>),		<span class="comment">#窗口大小 &lt;元组&gt;</span></span><br><span class="line">    dpi=<span class="number">120</span>,			<span class="comment">#像素密度</span></span><br><span class="line">	facecolor=<span class="string">&#x27;&#x27;</span>		<span class="comment">#图表背景色</span></span><br><span class="line">)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mp.figure方法不仅可以构建一个新窗口，如果已经构建过title=’xxx’的窗口，又使用figure方法构建了title=’xxx’ 的窗口的话，mp将不会创建新的窗口，而是把title=’xxx’的窗口置为当前操作窗口。</p>
<p><strong>设置当前窗口的参数</strong></p>
<p>案例：测试窗口相关参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置图表标题 显示在图表上方</span></span><br><span class="line">mp.title(title, fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 设置水平轴的文本</span></span><br><span class="line">mp.xlabel(x_label_str, fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 设置垂直轴的文本</span></span><br><span class="line">mp.ylabel(y_label_str, fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 设置刻度参数   labelsize设置刻度字体大小</span></span><br><span class="line">mp.tick_params(..., labelsize=<span class="number">8</span>, ...)</span><br><span class="line"><span class="comment"># 设置图表网格线  linestyle设置网格线的样式</span></span><br><span class="line">	<span class="comment">#	-  or solid 粗线</span></span><br><span class="line">	<span class="comment">#   -- or dashed 虚线</span></span><br><span class="line">	<span class="comment">#   -. or dashdot 点虚线</span></span><br><span class="line">	<span class="comment">#   :  or dotted 点线</span></span><br><span class="line">mp.grid(linestyle=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置紧凑布局，把图表相关参数都显示在窗口中</span></span><br><span class="line">mp.tight_layout() </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h4><p><strong>矩阵式布局</strong></p>
<p>绘制矩阵式子图布局相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Subplot Layout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"><span class="comment"># 拆分矩阵</span></span><br><span class="line">	<span class="comment"># rows:	行数</span></span><br><span class="line">    <span class="comment"># cols:	列数</span></span><br><span class="line">    <span class="comment"># num:	编号</span></span><br><span class="line">mp.subplot(rows, cols, num)</span><br><span class="line">	<span class="comment">#	1 2 3</span></span><br><span class="line">	<span class="comment">#	4 5 6</span></span><br><span class="line">	<span class="comment">#	7 8 9 </span></span><br><span class="line">mp.subplot(<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>)		<span class="comment">#操作3*3的矩阵中编号为5的子图</span></span><br><span class="line">mp.subplot(<span class="number">335</span>)			<span class="comment">#简写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制9宫格矩阵式子图，每个子图中写一个数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Subplot Layout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">	mp.subplot(<span class="number">3</span>, <span class="number">3</span>, i+<span class="number">1</span>)</span><br><span class="line">	mp.text(</span><br><span class="line">		<span class="number">0.5</span>, <span class="number">0.5</span>, i+<span class="number">1</span>, </span><br><span class="line">		ha=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">		va=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">		size=<span class="number">36</span>,</span><br><span class="line">		alpha=<span class="number">0.5</span>,</span><br><span class="line">		withdash=<span class="literal">False</span></span><br><span class="line">	)</span><br><span class="line">	mp.xticks([])</span><br><span class="line">	mp.yticks([])</span><br><span class="line"></span><br><span class="line">mp.tight_layout()</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>网格式布局</strong></p>
<p>网格式布局支持单元格的合并。</p>
<p>绘制网格式子图布局相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> mg</span><br><span class="line">mp.figure(<span class="string">&#x27;Grid Layout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"><span class="comment"># 调用GridSpec方法拆分网格式布局</span></span><br><span class="line"><span class="comment"># rows:	行数</span></span><br><span class="line"><span class="comment"># cols:	列数</span></span><br><span class="line"><span class="comment"># gs = mg.GridSpec(rows, cols)	拆分成3行3列</span></span><br><span class="line">gs = mg.GridSpec(<span class="number">3</span>, <span class="number">3</span>)	</span><br><span class="line"><span class="comment"># 合并0行与0、1列为一个子图表</span></span><br><span class="line">mp.subplot(gs[<span class="number">0</span>, :<span class="number">2</span>])</span><br><span class="line">mp.text(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">&#x27;1&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">36</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制一个自定义网格布局。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> mg</span><br><span class="line">mp.figure(<span class="string">&#x27;GridLayout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">gridsubs = mp.GridSpec(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 合并0行、0/1列为一个子图</span></span><br><span class="line">mp.subplot(gridsubs[<span class="number">0</span>, :<span class="number">2</span>])</span><br><span class="line">mp.text(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">36</span>)</span><br><span class="line">mp.tight_layout()</span><br><span class="line">mp.xticks([])</span><br><span class="line">mp.yticks([])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>自由式布局</strong></p>
<p>自由式布局相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Flow Layout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置图标的位置，给出左下角点坐标与宽高即可</span></span><br><span class="line"><span class="comment"># left_bottom_x: 坐下角点x坐标</span></span><br><span class="line"><span class="comment"># left_bottom_x: 坐下角点y坐标</span></span><br><span class="line"><span class="comment"># width:		 宽度</span></span><br><span class="line"><span class="comment"># height:		 高度</span></span><br><span class="line"><span class="comment"># mp.axes([left_bottom_x, left_bottom_y, width, height])</span></span><br><span class="line">mp.axes([<span class="number">0.03</span>, <span class="number">0.03</span>, <span class="number">0.94</span>, <span class="number">0.94</span>])</span><br><span class="line">mp.text(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="string">&#x27;1&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">36</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：测试自由式布局，定位子图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;FlowLayout&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mp.axes([<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">0.3</span>])</span><br><span class="line">mp.text(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">36</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="刻度定位器"><a href="#刻度定位器" class="headerlink" title="刻度定位器"></a>刻度定位器</h4><p>刻度定位器相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取当前坐标轴</span></span><br><span class="line">ax = mp.gca()</span><br><span class="line"><span class="comment"># 设置水平坐标轴的主刻度定位器</span></span><br><span class="line">ax.xaxis.set_major_locator(mp.NullLocator())</span><br><span class="line"><span class="comment"># 设置水平坐标轴的次刻度定位器为多点定位器，间隔0.1</span></span><br><span class="line">ax.xaxis.set_minor_locator(mp.MultipleLocator(<span class="number">0.1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制一个数轴。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Locators&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取当前坐标轴</span></span><br><span class="line">ax = mp.gca()</span><br><span class="line"><span class="comment"># 隐藏除底轴以外的所有坐标轴</span></span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="comment"># 将底坐标轴调整到子图中心位置</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 设置水平坐标轴的主刻度定位器</span></span><br><span class="line">ax.xaxis.set_major_locator(mp.NullLocator())</span><br><span class="line"><span class="comment"># 设置水平坐标轴的次刻度定位器为多点定位器，间隔0.1</span></span><br><span class="line">ax.xaxis.set_minor_locator(mp.MultipleLocator(<span class="number">0.1</span>))</span><br><span class="line"><span class="comment"># 标记所用刻度定位器类名 </span></span><br><span class="line">mp.text(<span class="number">5</span>, <span class="number">0.3</span>, <span class="string">&#x27;NullLocator()&#x27;</span>, ha=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">12</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：使用for循环测试刻度器样式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">locators = [<span class="string">&#x27;mp.NullLocator()&#x27;</span>, <span class="string">&#x27;mp.MaxNLocator(nbins=4)&#x27;</span>]</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> i, locator <span class="keyword">in</span> <span class="built_in">enumerate</span>(locators):</span><br><span class="line">    mp.subplot(<span class="built_in">len</span>(locators), <span class="number">1</span>, i+<span class="number">1</span>)</span><br><span class="line">	mp.xlim(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">	mp.ylim(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">	mp.yticks([])</span><br><span class="line">	<span class="comment"># 获取当前坐标轴</span></span><br><span class="line">	ax = mp.gca()</span><br><span class="line">	<span class="comment"># 隐藏除底轴以外的所有坐标轴</span></span><br><span class="line">	ax.spines[<span class="string">&#x27;left&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">	ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">	ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">	<span class="comment"># 将底坐标轴调整到子图中心位置</span></span><br><span class="line">	ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">	<span class="comment"># 设置水平坐标轴的主刻度定位器</span></span><br><span class="line">	ax.xaxis.set_major_locator(<span class="built_in">eval</span>( ))</span><br><span class="line">	<span class="comment"># 设置水平坐标轴的次刻度定位器为多点定位器，间隔0.1</span></span><br><span class="line">	ax.xaxis.set_minor_locator(mp.MultipleLocator(<span class="number">0.1</span>))</span><br><span class="line">	mp.plot(np.arange(<span class="number">11</span>), np.zeros(<span class="number">11</span>), c=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">	<span class="comment"># 标记所用刻度定位器类名</span></span><br><span class="line">	mp.text(<span class="number">5</span>, <span class="number">0.3</span>, locator, ha=<span class="string">&#x27;center&#x27;</span>, size=<span class="number">12</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>常用刻度器如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 空定位器：不绘制刻度</span></span><br><span class="line">mp.NullLocator()</span><br><span class="line"><span class="comment"># 最大值定位器：</span></span><br><span class="line"><span class="comment"># 最多绘制nbins+1个刻度</span></span><br><span class="line">mp.MaxNLocator(nbins=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 定点定位器：根据locs参数中的位置绘制刻度</span></span><br><span class="line">mp.FixedLocator(locs=[<span class="number">0</span>, <span class="number">2.5</span>, <span class="number">5</span>, <span class="number">7.5</span>, <span class="number">10</span>])</span><br><span class="line"><span class="comment"># 自动定位器：由系统自动选择刻度的绘制位置</span></span><br><span class="line">mp.AutoLocator()</span><br><span class="line"><span class="comment"># 索引定位器：由offset确定起始刻度，由base确定相邻刻度的间隔</span></span><br><span class="line">mp.IndexLocator(offset=<span class="number">0.5</span>, base=<span class="number">1.5</span>)</span><br><span class="line"><span class="comment"># 多点定位器：从0开始，按照参数指定的间隔(缺省1)绘制刻度</span></span><br><span class="line">mp.MultipleLocator()</span><br><span class="line"><span class="comment"># 线性定位器：等分numticks-1份，绘制numticks个刻度</span></span><br><span class="line">mp.LinearLocator(numticks=<span class="number">21</span>)</span><br><span class="line"><span class="comment"># 对数定位器：以base为底，绘制刻度</span></span><br><span class="line">mp.LogLocator(base=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="刻度网格线"><a href="#刻度网格线" class="headerlink" title="刻度网格线"></a>刻度网格线</h4><p>绘制刻度网格线的相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax = mp.gca()</span><br><span class="line"><span class="comment">#绘制刻度网格线</span></span><br><span class="line">ax.grid(</span><br><span class="line">    which=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># &#x27;major&#x27;/&#x27;minor&#x27; &lt;-&gt; &#x27;主刻度&#x27;/&#x27;次刻度&#x27; </span></span><br><span class="line">    axis=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># &#x27;x&#x27;/&#x27;y&#x27;/&#x27;both&#x27; &lt;-&gt; 绘制x或y轴</span></span><br><span class="line">    linewidth=<span class="number">1</span>, 	<span class="comment"># 线宽</span></span><br><span class="line">    linestyle=<span class="string">&#x27;&#x27;</span>, 	<span class="comment"># 线型</span></span><br><span class="line">    color=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># 颜色</span></span><br><span class="line">	alpha=<span class="number">0.5</span>		<span class="comment"># 透明度</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制曲线 [1, 10, 100, 1000, 100, 10, 1]，然后设置刻度网格线，测试刻度网格线的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = np.array([<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">1</span>])</span><br><span class="line">mp.figure(<span class="string">&#x27;Normal &amp; Log&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.subplot(<span class="number">211</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;Normal&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">mp.ylabel(<span class="string">&#x27;y&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax = mp.gca()</span><br><span class="line">ax.xaxis.set_major_locator(mp.MultipleLocator(<span class="number">1.0</span>))</span><br><span class="line">ax.xaxis.set_minor_locator(mp.MultipleLocator(<span class="number">0.1</span>))</span><br><span class="line">ax.yaxis.set_major_locator(mp.MultipleLocator(<span class="number">250</span>))</span><br><span class="line">ax.yaxis.set_minor_locator(mp.MultipleLocator(<span class="number">50</span>))</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">ax.grid(which=<span class="string">&#x27;major&#x27;</span>, axis=<span class="string">&#x27;both&#x27;</span>, linewidth=<span class="number">0.75</span>,</span><br><span class="line">        linestyle=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">ax.grid(which=<span class="string">&#x27;minor&#x27;</span>, axis=<span class="string">&#x27;both&#x27;</span>, linewidth=<span class="number">0.25</span>,</span><br><span class="line">        linestyle=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">mp.plot(y, <span class="string">&#x27;o-&#x27;</span>, c=<span class="string">&#x27;dodgerblue&#x27;</span>, label=<span class="string">&#x27;plot&#x27;</span>)</span><br><span class="line">mp.legend()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="半对数坐标"><a href="#半对数坐标" class="headerlink" title="半对数坐标"></a>半对数坐标</h4><p>y轴将以指数方式递增。 基于半对数坐标绘制第二个子图，表示曲线：[1, 10, 100, 1000, 100, 10, 1]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Grid&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">1</span>]</span><br><span class="line">mp.semilogy(y)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h4><p>可以通过每个点的坐标、颜色、大小和形状表示不同的特征值。</p>
<table>
<thead>
<tr>
<th>身高</th>
<th>体重</th>
<th>性别</th>
<th>年龄段</th>
<th>种族</th>
</tr>
</thead>
<tbody><tr>
<td>180</td>
<td>80</td>
<td>男</td>
<td>中年</td>
<td>亚洲</td>
</tr>
<tr>
<td>160</td>
<td>50</td>
<td>女</td>
<td>青少</td>
<td>美洲</td>
</tr>
</tbody></table>
<p>绘制散点图的相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.scatter(</span><br><span class="line">    x, 					<span class="comment"># x轴坐标数组</span></span><br><span class="line">    y,					<span class="comment"># y轴坐标数组</span></span><br><span class="line">    marker=<span class="string">&#x27;&#x27;</span>, 			<span class="comment"># 点型</span></span><br><span class="line">    s=<span class="number">10</span>,				<span class="comment"># 大小</span></span><br><span class="line">    color=<span class="string">&#x27;&#x27;</span>,			<span class="comment"># 颜色</span></span><br><span class="line">    edgecolor=<span class="string">&#x27;&#x27;</span>, 		<span class="comment"># 边缘颜色</span></span><br><span class="line">    facecolor=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># 填充色</span></span><br><span class="line">    zorder=<span class="string">&#x27;&#x27;</span>			<span class="comment"># 图层序号</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>numpy.random提供了normal函数用于产生符合 正态分布 的随机数 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line"><span class="comment"># 172:	期望值</span></span><br><span class="line"><span class="comment"># 10:	标准差</span></span><br><span class="line"><span class="comment"># n:	数字生成数量</span></span><br><span class="line">x = np.random.normal(<span class="number">172</span>, <span class="number">20</span>, n)</span><br><span class="line">y = np.random.normal(<span class="number">60</span>, <span class="number">10</span>, n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制平面散点图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;scatter&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;scatter&#x27;</span>)</span><br><span class="line">mp.scatter(x, y)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置点的颜色</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.scatter(x, y, c=<span class="string">&#x27;red&#x27;</span>)			<span class="comment">#直接设置颜色</span></span><br><span class="line">d = (x-<span class="number">172</span>)**<span class="number">2</span> + (y-<span class="number">60</span>)**<span class="number">2</span></span><br><span class="line">mp.scatter(x, y, c=d, cmap=<span class="string">&#x27;jet&#x27;</span>)	<span class="comment">#以c作为参数，取cmap颜色映射表中的颜色值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>cmap颜色映射表参照附件：cmap颜色映射表</em></p>
<h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>以某种颜色自动填充两条曲线的闭合区域。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.fill_between(</span><br><span class="line">	x,				<span class="comment"># x轴的水平坐标</span></span><br><span class="line">    sin_x,			<span class="comment"># 下边界曲线上点的垂直坐标</span></span><br><span class="line">    cos_x,			<span class="comment"># 上边界曲线上点的垂直坐标</span></span><br><span class="line">    sin_x&lt;cos_x, 	<span class="comment"># 填充条件，为True时填充</span></span><br><span class="line">    color=<span class="string">&#x27;&#x27;</span>, 		<span class="comment"># 填充颜色</span></span><br><span class="line">    alpha=<span class="number">0.2</span>		<span class="comment"># 透明度</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制两条曲线： sin_x = sin(x)    cos_x = cos(x / 2) / 2    [0-8π]  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">1000</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">8</span> * np.pi, n)</span><br><span class="line">sin_y = np.sin(x)</span><br><span class="line">cos_y = np.cos(x / <span class="number">2</span>) / <span class="number">2</span></span><br><span class="line">mp.figure(<span class="string">&#x27;Fill&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;Fill&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">mp.xlabel(<span class="string">&#x27;x&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.ylabel(<span class="string">&#x27;y&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">mp.grid(linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">mp.plot(x, sin_y, c=<span class="string">&#x27;dodgerblue&#x27;</span>,</span><br><span class="line">        label=<span class="string">r&#x27;$y=sin(x)$&#x27;</span>)</span><br><span class="line">mp.plot(x, cos_y, c=<span class="string">&#x27;orangered&#x27;</span>,</span><br><span class="line">        label=<span class="string">r&#x27;$y=\frac&#123;1&#125;&#123;2&#125;cos(\frac&#123;x&#125;&#123;2&#125;)$&#x27;</span>)</span><br><span class="line">mp.fill_between(x, cos_y, sin_y, cos_y &lt; sin_y,</span><br><span class="line">                color=<span class="string">&#x27;dodgerblue&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">mp.fill_between(x, cos_y, sin_y, cos_y &gt; sin_y,</span><br><span class="line">                color=<span class="string">&#x27;orangered&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">mp.legend()</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="条形图（柱状图）"><a href="#条形图（柱状图）" class="headerlink" title="条形图（柱状图）"></a>条形图（柱状图）</h4><p>绘制柱状图的相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;Bar&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.bar(</span><br><span class="line">	x,				<span class="comment"># 水平坐标数组</span></span><br><span class="line">    y,				<span class="comment"># 柱状图高度数组</span></span><br><span class="line">    width,			<span class="comment"># 柱子的宽度</span></span><br><span class="line">    color=<span class="string">&#x27;&#x27;</span>, 		<span class="comment"># 填充颜色</span></span><br><span class="line">    label=<span class="string">&#x27;&#x27;</span>,		<span class="comment">#</span></span><br><span class="line">    alpha=<span class="number">0.2</span>		<span class="comment">#</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：先以柱状图绘制苹果12个月的销量，然后再绘制橘子的销量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">apples = np.array([<span class="number">30</span>, <span class="number">25</span>, <span class="number">22</span>, <span class="number">36</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">33</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">15</span>])</span><br><span class="line">oranges = np.array([<span class="number">24</span>, <span class="number">33</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">35</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">32</span>, <span class="number">20</span>, <span class="number">22</span>])</span><br><span class="line">mp.figure(<span class="string">&#x27;Bar&#x27;</span>  , facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;Bar&#x27;</span>, font size=<span class="number">20</span>)</span><br><span class="line">mp.xlabel(<span class="string">&#x27;Month&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.ylabel(<span class="string">&#x27;Price&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">mp.grid(axis=<span class="string">&#x27;y&#x27;</span>, linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">mp.ylim((<span class="number">0</span>, <span class="number">40</span>))</span><br><span class="line">x = np.arange(<span class="built_in">len</span>(apples))</span><br><span class="line">mp.bar(x-<span class="number">0.2</span>, apples, <span class="number">0.4</span>, color=<span class="string">&#x27;dodgerblue&#x27;</span>,label=<span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">mp.bar(x + <span class="number">0.2</span>, oranges, <span class="number">0.4</span>, color=<span class="string">&#x27;orangered&#x27;</span>,label=<span class="string">&#x27;Orange&#x27;</span>, alpha=<span class="number">0.75</span>)</span><br><span class="line">mp.xticks(x, [</span><br><span class="line">    <span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>])</span><br><span class="line">mp.legend()</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p>绘制饼状图的基本API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.pie(</span><br><span class="line">    values, 		<span class="comment"># 值列表		</span></span><br><span class="line">    spaces, 		<span class="comment"># 扇形之间的间距列表</span></span><br><span class="line">    labels, 		<span class="comment"># 标签列表</span></span><br><span class="line">    colors, 		<span class="comment"># 颜色列表</span></span><br><span class="line">    <span class="string">&#x27;%d%%&#x27;</span>,			<span class="comment"># 标签所占比例格式</span></span><br><span class="line">	shadow=<span class="literal">True</span>, 	<span class="comment"># 是否显示阴影</span></span><br><span class="line">    startangle=<span class="number">90</span>	<span class="comment"># 逆时针绘制饼状图时的起始角度</span></span><br><span class="line">    radius=<span class="number">1</span>		<span class="comment"># 半径</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制饼状图显示5门语言的流行程度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&#x27;pie&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"><span class="comment">#整理数据</span></span><br><span class="line">values = [<span class="number">26</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">11</span>]</span><br><span class="line">spaces = [<span class="number">0.05</span>, <span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>]</span><br><span class="line">labels = [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>]</span><br><span class="line">colors = [<span class="string">&#x27;dodgerblue&#x27;</span>, <span class="string">&#x27;orangered&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;limegreen&#x27;</span>, <span class="string">&#x27;violet&#x27;</span>, <span class="string">&#x27;gold&#x27;</span>]</span><br><span class="line">mp.figure(<span class="string">&#x27;Pie&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;Pie&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 等轴比例</span></span><br><span class="line">mp.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">mp.pie(</span><br><span class="line">    values, 		<span class="comment"># 值列表		</span></span><br><span class="line">    spaces, 		<span class="comment"># 扇形之间的间距列表</span></span><br><span class="line">    labels, 		<span class="comment"># 标签列表</span></span><br><span class="line">    colors, 		<span class="comment"># 颜色列表</span></span><br><span class="line">    <span class="string">&#x27;%d%%&#x27;</span>,			<span class="comment"># 标签所占比例格式</span></span><br><span class="line">	shadow=<span class="literal">True</span>, 	<span class="comment"># 是否显示阴影</span></span><br><span class="line">    startanle=<span class="number">90</span>	<span class="comment"># 逆时针绘制饼状图时的起始角度</span></span><br><span class="line">    radius=<span class="number">1</span>		<span class="comment"># 半径</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="等高线图"><a href="#等高线图" class="headerlink" title="等高线图"></a>等高线图</h4><p>组成等高线需要网格点坐标矩阵，也需要每个点的高度。所以等高线属于3D数学模型范畴。</p>
<p>绘制等高线的相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.contourf(x, y, z, <span class="number">8</span>, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">cntr = mp.contour(</span><br><span class="line">    x, 					<span class="comment"># 网格坐标矩阵的x坐标 （2维数组）</span></span><br><span class="line">    y, 					<span class="comment"># 网格坐标矩阵的y坐标 （2维数组）</span></span><br><span class="line">    z, 					<span class="comment"># 网格坐标矩阵的z坐标 （2维数组）</span></span><br><span class="line">    <span class="number">8</span>, 					<span class="comment"># 把等高线绘制成8部分</span></span><br><span class="line">    colors=<span class="string">&#x27;black&#x27;</span>,		<span class="comment"># 等高线的颜色</span></span><br><span class="line">	linewidths=<span class="number">0.5</span>		<span class="comment"># 线宽</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>案例：生成网格坐标矩阵，并且绘制等高线：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 生成网格化坐标矩阵</span></span><br><span class="line">x, y = np.meshgrid(np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n),</span><br><span class="line">                   np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n))</span><br><span class="line"><span class="comment"># 根据每个网格点坐标，通过某个公式计算z高度坐标</span></span><br><span class="line">z = (<span class="number">1</span> - x/<span class="number">2</span> + x**<span class="number">5</span> + y**<span class="number">3</span>) * np.exp(-x**<span class="number">2</span> - y**<span class="number">2</span>)</span><br><span class="line">mp.figure(<span class="string">&#x27;Contour&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;Contour&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">mp.xlabel(<span class="string">&#x27;x&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.ylabel(<span class="string">&#x27;y&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">mp.grid(linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制等高线图</span></span><br><span class="line">mp.contourf(x, y, z, <span class="number">8</span>, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">cntr = mp.contour(x, y, z, <span class="number">8</span>, colors=<span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">                  linewidths=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 为等高线图添加高度标签</span></span><br><span class="line">mp.clabel(cntr, inline_spacing=<span class="number">1</span>, fmt=<span class="string">&#x27;%.1f&#x27;</span>,</span><br><span class="line">          fontsize=<span class="number">10</span>)</span><br><span class="line">mp.show()</span><br></pre></td></tr></table></figure>

<h4 id="热成像图"><a href="#热成像图" class="headerlink" title="热成像图"></a>热成像图</h4><p>用图形的方式显示矩阵及矩阵中值的大小<br>1 2 3<br>4 5 6<br>7 8 9</p>
<p>绘制热成像图的相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把矩阵z图形化，使用cmap表示矩阵中每个元素值的大小</span></span><br><span class="line"><span class="comment"># origin: 坐标轴方向</span></span><br><span class="line"><span class="comment">#    upper: 缺省值，原点在左上角</span></span><br><span class="line"><span class="comment">#    lower: 原点在左下角</span></span><br><span class="line">mp.imshow(z, cmap=<span class="string">&#x27;jet&#x27;</span>, origin=<span class="string">&#x27;low&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用颜色条显示热度值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.colorbar()</span><br></pre></td></tr></table></figure>

<h4 id="3D图像绘制"><a href="#3D图像绘制" class="headerlink" title="3D图像绘制"></a>3D图像绘制</h4><p> matplotlib支持绘制三维曲面。若希望绘制三维曲面，需要使用axes3d提供的3d坐标系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> axes3d</span><br><span class="line">ax3d = mp.gca(projection=<span class="string">&#x27;3d&#x27;</span>)   <span class="comment"># class axes3d</span></span><br></pre></td></tr></table></figure>

<p>matplotlib支持绘制三维点阵、三维曲面、三维线框图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax3d.scatter(..)		<span class="comment"># 绘制三维点阵</span></span><br><span class="line">ax3d.plot_surface(..)	<span class="comment"># 绘制三维曲面</span></span><br><span class="line">ax3d.plot_wireframe(..)	<span class="comment"># 绘制三维线框图</span></span><br></pre></td></tr></table></figure>

<p>3d散点图的绘制相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax3d.scatter(</span><br><span class="line">    x, 				<span class="comment"># x轴坐标数组</span></span><br><span class="line">    y,				<span class="comment"># y轴坐标数组</span></span><br><span class="line">    marker=<span class="string">&#x27;&#x27;</span>, 		<span class="comment"># 点型</span></span><br><span class="line">    s=<span class="number">10</span>,			<span class="comment"># 大小</span></span><br><span class="line">    zorder=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># 图层序号</span></span><br><span class="line">    color=<span class="string">&#x27;&#x27;</span>,		<span class="comment"># 颜色</span></span><br><span class="line">    edgecolor=<span class="string">&#x27;&#x27;</span>, 	<span class="comment"># 边缘颜色</span></span><br><span class="line">    facecolor=<span class="string">&#x27;&#x27;</span>,	<span class="comment"># 填充色</span></span><br><span class="line">    c=v,			<span class="comment"># 颜色值 根据cmap映射应用相应颜色</span></span><br><span class="line">    cmap=<span class="string">&#x27;&#x27;</span>			<span class="comment"># </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>案例：随机生成3组坐标，程标准正态分布规则，并且绘制它们。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">1000</span></span><br><span class="line">x = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">z = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">d = np.sqrt(x ** <span class="number">2</span> + y ** <span class="number">2</span> + z ** <span class="number">2</span>)</span><br><span class="line">mp.figure(<span class="string">&#x27;3D Scatter&#x27;</span>)</span><br><span class="line">ax = mp.gca(projection=<span class="string">&#x27;3d&#x27;</span>)  <span class="comment"># 创建三维坐标系</span></span><br><span class="line">mp.title(<span class="string">&#x27;3D Scatter&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;z&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">ax.scatter(x, y, z, s=<span class="number">60</span>, c=d, cmap=<span class="string">&#x27;jet_r&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">mp.show()</span><br></pre></td></tr></table></figure>

<p>3d平面图的绘制相关API：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax3d.plot_surface(</span><br><span class="line">    x, 					<span class="comment"># 网格坐标矩阵的x坐标 （2维数组）</span></span><br><span class="line">    y, 					<span class="comment"># 网格坐标矩阵的y坐标 （2维数组）</span></span><br><span class="line">    z, 					<span class="comment"># 网格坐标矩阵的z坐标 （2维数组）</span></span><br><span class="line">    rstride=<span class="number">30</span>,			<span class="comment"># 行跨距</span></span><br><span class="line">    cstride=<span class="number">30</span>, 		<span class="comment"># 列跨距</span></span><br><span class="line">    cmap=<span class="string">&#x27;jet&#x27;</span>			<span class="comment"># 颜色映射</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制3d平面图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 生成网格化坐标矩阵</span></span><br><span class="line">x, y = np.meshgrid(np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n),</span><br><span class="line">                   np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n))</span><br><span class="line"><span class="comment"># 根据每个网格点坐标，通过某个公式计算z高度坐标</span></span><br><span class="line">z = (<span class="number">1</span> - x/<span class="number">2</span> + x**<span class="number">5</span> + y**<span class="number">3</span>) * np.exp(-x**<span class="number">2</span> - y**<span class="number">2</span>)</span><br><span class="line">mp.figure(<span class="string">&#x27;3D&#x27;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax3d = mp.gca(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&#x27;3D&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">ax3d.set_xlabel(<span class="string">&#x27;x&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax3d.set_ylabel(<span class="string">&#x27;y&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax3d.set_zlabel(<span class="string">&#x27;z&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 绘制3D平面图</span></span><br><span class="line"><span class="comment"># rstride: 行跨距</span></span><br><span class="line"><span class="comment"># cstride: 列跨距 </span></span><br><span class="line">ax3d.plot_surface(x,y,z,rstride=<span class="number">30</span>,cstride=<span class="number">30</span>, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：3d线框图的绘制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制3D平面图 </span></span><br><span class="line"><span class="comment"># rstride: 行跨距</span></span><br><span class="line"><span class="comment"># cstride: 列跨距 </span></span><br><span class="line">ax3d.plot_wireframe(x,y,z,rstride=<span class="number">30</span>,cstride=<span class="number">30</span>, </span><br><span class="line">	linewidth=<span class="number">1</span>, color=<span class="string">&#x27;dodgerblue&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="简单动画"><a href="#简单动画" class="headerlink" title="简单动画"></a>简单动画</h4><p>动画即是在一段时间内快速连续的重新绘制图像的过程。</p>
<p>matplotlib提供了方法用于处理简单动画的绘制。定义update函数用于即时更新图像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.animation <span class="keyword">as</span> ma</span><br><span class="line"><span class="comment">#定义更新函数行为</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 每隔10毫秒执行一次update更新函数，作用于mp.gcf()当前窗口对象</span></span><br><span class="line"><span class="comment"># mp.gcf()：	获取当前窗口</span></span><br><span class="line"><span class="comment"># update：	更新函数</span></span><br><span class="line"><span class="comment"># interval：	间隔时间（单位：毫秒）</span></span><br><span class="line">anim = ma.FuncAnimation(mp.gcf(), update, interval=<span class="number">10</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：随机生成各种颜色的100个气泡。让他们不断的增大。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义一种可以存放在ndarray里的类型，用于保存一个球</span></span><br><span class="line">ball_type = np.dtype([</span><br><span class="line">	(<span class="string">&#x27;position&#x27;</span>, <span class="built_in">float</span>, <span class="number">2</span>),  <span class="comment"># 位置(水平和垂直坐标)</span></span><br><span class="line">    (<span class="string">&#x27;size&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>),      <span class="comment"># 大小</span></span><br><span class="line">    (<span class="string">&#x27;growth&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>),    <span class="comment"># 生长速度</span></span><br><span class="line">    (<span class="string">&#x27;color&#x27;</span>, <span class="built_in">float</span>, <span class="number">4</span>)])    <span class="comment"># 颜色(红、绿、蓝和透明度)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#随机生成100个点对象</span></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line">balls = np.zeros(<span class="number">100</span>, dtype=ball_type)</span><br><span class="line">balls[<span class="string">&#x27;position&#x27;</span>]=np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (n, <span class="number">2</span>))</span><br><span class="line">balls[<span class="string">&#x27;size&#x27;</span>]=np.random.uniform(<span class="number">40</span>, <span class="number">70</span>, n)</span><br><span class="line">balls[<span class="string">&#x27;growth&#x27;</span>]=np.random.uniform(<span class="number">10</span>, <span class="number">20</span>, n)</span><br><span class="line">balls[<span class="string">&#x27;color&#x27;</span>]=np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (n, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">mp.figure(<span class="string">&quot;Animation&quot;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&quot;Animation&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.xticks </span><br><span class="line">mp.yticks(())</span><br><span class="line"></span><br><span class="line">sc = mp.scatter(</span><br><span class="line">	balls[<span class="string">&#x27;position&#x27;</span>][:, <span class="number">0</span>], </span><br><span class="line">	balls[<span class="string">&#x27;position&#x27;</span>][:, <span class="number">1</span>], </span><br><span class="line">	balls[<span class="string">&#x27;size&#x27;</span>], </span><br><span class="line">	color=balls[<span class="string">&#x27;color&#x27;</span>], alpha=<span class="number">0.5</span>)</span><br><span class="line">	</span><br><span class="line"><span class="comment">#定义更新函数行为</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">number</span>):</span></span><br><span class="line">	balls[<span class="string">&#x27;size&#x27;</span>] += balls[<span class="string">&#x27;growth&#x27;</span>]</span><br><span class="line">	<span class="comment">#每次让一个气泡破裂，随机生成一个新的</span></span><br><span class="line">	boom_ind = number % n</span><br><span class="line">	balls[boom_ind][<span class="string">&#x27;size&#x27;</span>]=np.random.uniform(<span class="number">40</span>, <span class="number">70</span>, <span class="number">1</span>)</span><br><span class="line">	balls[boom_ind][<span class="string">&#x27;position&#x27;</span>]=np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">	<span class="comment"># 重新设置属性</span></span><br><span class="line">	sc.set_sizes(balls[<span class="string">&#x27;size&#x27;</span>])</span><br><span class="line">	sc.set_offsets(balls[<span class="string">&#x27;position&#x27;</span>])</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 每隔30毫秒执行一次update更新函数，作用于mp.gcf()当前窗口对象</span></span><br><span class="line"><span class="comment"># mp.gcf()：	获取当前窗口</span></span><br><span class="line"><span class="comment"># update：		更新函数</span></span><br><span class="line"><span class="comment"># interval：	间隔时间（单位：毫秒）</span></span><br><span class="line">anim = ma.FuncAnimation(mp.gcf(), update, interval=<span class="number">30</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用生成器函数提供数据，实现动画绘制</p>
<p>在很多情况下，绘制动画的参数是动态获取的，matplotlib支持定义generator生成器函数，用于生成数据，把生成的数据交给update函数更新图像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.animation <span class="keyword">as</span> ma</span><br><span class="line"><span class="comment">#定义更新函数行为</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">data</span>):</span></span><br><span class="line">    t, v = data</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span>():</span></span><br><span class="line">	<span class="keyword">yield</span> t, v</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 每隔10毫秒将会先调用生成器，获取生成器返回的数据，</span></span><br><span class="line"><span class="comment"># 把生成器返回的数据交给并且调用update函数，执行更新图像函数</span></span><br><span class="line">anim = ma.FuncAnimation(mp.gcf(), update, generator,interval=<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：绘制信号曲线：y=sin(2 * π * t) * exp(sin(0.2 * π * t))，数据通过生成器函数生成，在update函数中绘制曲线。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mp.figure(<span class="string">&quot;Signal&quot;</span>, facecolor=<span class="string">&#x27;lightgray&#x27;</span>)</span><br><span class="line">mp.title(<span class="string">&quot;Signal&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">mp.xlim(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">mp.ylim(-<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">mp.grid(linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;lightgray&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">pl = mp.plot([], [], color=<span class="string">&#x27;dodgerblue&#x27;</span>, label=<span class="string">&#x27;Signal&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">pl.set_data([],[])</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">data</span>):</span></span><br><span class="line">	t, v = data</span><br><span class="line">	x, y = pl.get_data()</span><br><span class="line">	x.append(t)</span><br><span class="line">	y.append(v)</span><br><span class="line">	<span class="comment">#重新设置数据源</span></span><br><span class="line">	pl.set_data(x, y)</span><br><span class="line">	<span class="comment">#移动坐标轴</span></span><br><span class="line">	<span class="keyword">if</span>(x[-<span class="number">1</span>]&gt;<span class="number">10</span>):</span><br><span class="line">		mp.xlim(x[-<span class="number">1</span>]-<span class="number">10</span>, x[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y_generator</span>():</span></span><br><span class="line">	<span class="keyword">global</span> x</span><br><span class="line">	y = np.sin(<span class="number">2</span> * np.pi * x) * np.exp(np.sin(<span class="number">0.2</span> * np.pi * x))</span><br><span class="line">	<span class="keyword">yield</span> (x, y)</span><br><span class="line">	x += <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">anim = ma.FuncAnimation(mp.gcf(), update, y_generator, interval=<span class="number">20</span>)</span><br><span class="line">mp.tight_layout()</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas教程</title>
    <url>/2022/08/08/Pandas%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="pandas基础"><a href="#pandas基础" class="headerlink" title="pandas基础"></a>pandas基础</h2><h3 id="pandas介绍"><a href="#pandas介绍" class="headerlink" title="pandas介绍"></a>pandas介绍</h3><p>Python Data Analysis Library</p>
<p>pandas是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入 了大量库和一些标准的数据模型，提供了高效地操作大型结构化数据集所需的工具。</p>
<h3 id="pandas核心数据结构"><a href="#pandas核心数据结构" class="headerlink" title="pandas核心数据结构"></a>pandas核心数据结构</h3><p>数据结构是计算机存储、组织数据的方式。 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p>
<h4 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h4><p>Series可以理解为一个一维的数组，只是index名称可以自己改动。类似于定长的有序字典，有Index和 value。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空的系列</span></span><br><span class="line">s = pd.Series()</span><br><span class="line"><span class="comment"># 从ndarray创建一个系列</span></span><br><span class="line">data = np.array([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">s = pd.Series(data)</span><br><span class="line">s = pd.Series(data,index=[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>])</span><br><span class="line"><span class="comment"># 从字典创建一个系列	</span></span><br><span class="line">data = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">0.</span>, <span class="string">&#x27;b&#x27;</span> : <span class="number">1.</span>, <span class="string">&#x27;c&#x27;</span> : <span class="number">2.</span>&#125;</span><br><span class="line">s = pd.Series(data)</span><br><span class="line"><span class="comment"># 从标量创建一个系列</span></span><br><span class="line">s = pd.Series(<span class="number">5</span>, index=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h5 id="访问Series中的数据"><a href="#访问Series中的数据" class="headerlink" title="访问Series中的数据"></a>访问Series中的数据</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用索引检索元素</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>], s[:<span class="number">3</span>], s[-<span class="number">3</span>:])</span><br><span class="line"><span class="comment"># 使用标签检索数据</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;a&#x27;</span>], s[[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]])</span><br></pre></td></tr></table></figure>

<h5 id="pandas日期处理"><a href="#pandas日期处理" class="headerlink" title="pandas日期处理"></a>pandas日期处理</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pandas识别的日期字符串格式</span></span><br><span class="line">dates = pd.Series([<span class="string">&#x27;2011&#x27;</span>, <span class="string">&#x27;2011-02&#x27;</span>, <span class="string">&#x27;2011-03-01&#x27;</span>, <span class="string">&#x27;2011/04/01&#x27;</span>, </span><br><span class="line">                   <span class="string">&#x27;2011/05/01 01:01:01&#x27;</span>, <span class="string">&#x27;01 Jun 2011&#x27;</span>])</span><br><span class="line"><span class="comment"># to_datetime() 转换日期数据类型</span></span><br><span class="line">dates = pd.to_datetime(dates)</span><br><span class="line"><span class="built_in">print</span>(dates, dates.dtype, <span class="built_in">type</span>(dates))</span><br><span class="line"><span class="comment"># datetime类型数据支持日期运算</span></span><br><span class="line">delta = dates - pd.to_datetime(<span class="string">&#x27;1970-01-01&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取天数数值</span></span><br><span class="line"><span class="built_in">print</span>(delta.dt.days)</span><br></pre></td></tr></table></figure>

<p>Series.dt提供了很多日期相关操作，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Series.dt.year	The year of the datetime.</span><br><span class="line">Series.dt.month	The month <span class="keyword">as</span> January=<span class="number">1</span>, December=<span class="number">12.</span></span><br><span class="line">Series.dt.day	The days of the datetime.</span><br><span class="line">Series.dt.hour	The hours of the datetime.</span><br><span class="line">Series.dt.minute	The minutes of the datetime.</span><br><span class="line">Series.dt.second	The seconds of the datetime.</span><br><span class="line">Series.dt.microsecond	The microseconds of the datetime.</span><br><span class="line">Series.dt.week	The week ordinal of the year.</span><br><span class="line">Series.dt.weekofyear	The week ordinal of the year.</span><br><span class="line">Series.dt.dayofweek	The day of the week <span class="keyword">with</span> Monday=<span class="number">0</span>, Sunday=<span class="number">6.</span></span><br><span class="line">Series.dt.weekday	The day of the week <span class="keyword">with</span> Monday=<span class="number">0</span>, Sunday=<span class="number">6.</span></span><br><span class="line">Series.dt.dayofyear	The ordinal day of the year.</span><br><span class="line">Series.dt.quarter	The quarter of the date.</span><br><span class="line">Series.dt.is_month_start	Indicates whether the date <span class="keyword">is</span> the first day of the month.</span><br><span class="line">Series.dt.is_month_end	Indicates whether the date <span class="keyword">is</span> the last day of the month.</span><br><span class="line">Series.dt.is_quarter_start	Indicator <span class="keyword">for</span> whether the date <span class="keyword">is</span> the first day of a quarter.</span><br><span class="line">Series.dt.is_quarter_end	Indicator <span class="keyword">for</span> whether the date <span class="keyword">is</span> the last day of a quarter.</span><br><span class="line">Series.dt.is_year_start	Indicate whether the date <span class="keyword">is</span> the first day of a year.</span><br><span class="line">Series.dt.is_year_end	Indicate whether the date <span class="keyword">is</span> the last day of the year.</span><br><span class="line">Series.dt.is_leap_year	Boolean indicator <span class="keyword">if</span> the date belongs to a leap year.</span><br><span class="line">Series.dt.days_in_month	The number of days <span class="keyword">in</span> the month.</span><br></pre></td></tr></table></figure>



<h4 id="DateTimeIndex"><a href="#DateTimeIndex" class="headerlink" title="DateTimeIndex"></a>DateTimeIndex</h4><p>通过指定周期和频率，使用<code>date_range()</code>函数就可以创建日期序列。 默认情况下，范围的频率是天。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 以日为频率</span></span><br><span class="line">datelist = pd.date_range(<span class="string">&#x27;2019/08/21&#x27;</span>, periods=<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(datelist)</span><br><span class="line"><span class="comment"># 以月为频率</span></span><br><span class="line">datelist = pd.date_range(<span class="string">&#x27;2019/08/21&#x27;</span>, periods=<span class="number">5</span>,freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(datelist)</span><br><span class="line"><span class="comment"># 构建某个区间的时间序列</span></span><br><span class="line">start = pd.datetime(<span class="number">2017</span>, <span class="number">11</span>, <span class="number">1</span>)</span><br><span class="line">end = pd.datetime(<span class="number">2017</span>, <span class="number">11</span>, <span class="number">5</span>)</span><br><span class="line">dates = pd.date_range(start, end)</span><br><span class="line"><span class="built_in">print</span>(dates)</span><br></pre></td></tr></table></figure>

<p><code>bdate_range()</code>用来表示商业日期范围，不同于<code>date_range()</code>，它不包括星期六和星期天。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">datelist = pd.bdate_range(<span class="string">&#x27;2011/11/03&#x27;</span>, periods=<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(datelist)</span><br></pre></td></tr></table></figure>



<h4 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h4><p>DataFrame是一个类似于表格的数据类型，可以理解为一个二维数组，索引有两个维度，可更改。DataFrame具有以下特点：</p>
<ul>
<li>潜在的列是不同的类型</li>
<li>大小可变</li>
<li>标记轴(行和列)</li>
<li>可以对行和列执行算术运算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空的DataFrame</span></span><br><span class="line">df = pd.DataFrame()</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从列表创建DataFrame</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line">data = [[<span class="string">&#x27;Alex&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;Bob&#x27;</span>,<span class="number">12</span>],[<span class="string">&#x27;Clarke&#x27;</span>,<span class="number">13</span>]]</span><br><span class="line">df = pd.DataFrame(data,columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line">data = [[<span class="string">&#x27;Alex&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;Bob&#x27;</span>,<span class="number">12</span>],[<span class="string">&#x27;Clarke&#x27;</span>,<span class="number">13</span>]]</span><br><span class="line">df = pd.DataFrame(data,columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>],dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line">data = [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;,&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从字典来创建DataFrame</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>],<span class="string">&#x27;Age&#x27;</span>:[<span class="number">28</span>,<span class="number">34</span>,<span class="number">29</span>,<span class="number">42</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;s1&#x27;</span>,<span class="string">&#x27;s2&#x27;</span>,<span class="string">&#x27;s3&#x27;</span>,<span class="string">&#x27;s4&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">        <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>



<h3 id="核心数据结构操作"><a href="#核心数据结构操作" class="headerlink" title="核心数据结构操作"></a>核心数据结构操作</h3><h4 id="列访问"><a href="#列访问" class="headerlink" title="列访问"></a><strong>列访问</strong></h4><p>​    DataFrame的单列数据为一个Series。根据DataFrame的定义可以 知晓DataFrame是一个带有标签的二维数组，每个标签相当每一列的列名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;one&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df[[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]])	<span class="comment"># 花式索引</span></span><br></pre></td></tr></table></figure>

<h4 id="列添加"><a href="#列添加" class="headerlink" title="列添加"></a><strong>列添加</strong></h4><p>​    DataFrame添加一列的方法非常简单，只需要新建一个列索引。并对该索引下的数据进行赋值操作即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>],<span class="string">&#x27;Age&#x27;</span>:[<span class="number">28</span>,<span class="number">34</span>,<span class="number">29</span>,<span class="number">42</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;s1&#x27;</span>,<span class="string">&#x27;s2&#x27;</span>,<span class="string">&#x27;s3&#x27;</span>,<span class="string">&#x27;s4&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;score&#x27;</span>]=pd.Series([<span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>], index=[<span class="string">&#x27;s1&#x27;</span>,<span class="string">&#x27;s2&#x27;</span>,<span class="string">&#x27;s3&#x27;</span>,<span class="string">&#x27;s4&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="列删除"><a href="#列删除" class="headerlink" title="列删除"></a><strong>列删除</strong></h4><p>​    删除某列数据需要用到pandas提供的方法pop，pop方法的用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;three&#x27;</span> : pd.Series([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])&#125;</span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dataframe is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一列： one</span></span><br><span class="line"><span class="keyword">del</span>(df[<span class="string">&#x27;one&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用pop方法删除一列</span></span><br><span class="line">df.pop(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="行访问"><a href="#行访问" class="headerlink" title="行访问"></a><strong>行访问</strong></h4><ul>
<li>如果只是需要访问DataFrame某几行数据的实现方式则采用数组的选取方式，使用 “:” 即可：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]), </span><br><span class="line">    <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="number">2</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>loc</strong>方法是针对DataFrame<strong>索引名称</strong>的切片方法。loc方法使用方法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]])</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>iloc</strong>和loc区别是iloc接收的必须是<strong>行索引和列索引的位置</strong>。iloc方法的使用方法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(df.iloc[[<span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>

<h4 id="行添加"><a href="#行添加" class="headerlink" title="行添加"></a><strong>行添加</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="string">&#x27;zs&#x27;</span>, <span class="number">12</span>], [<span class="string">&#x27;ls&#x27;</span>, <span class="number">4</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="string">&#x27;ww&#x27;</span>, <span class="number">16</span>], [<span class="string">&#x27;zl&#x27;</span>, <span class="number">8</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line">df = df.append(df2)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="行删除"><a href="#行删除" class="headerlink" title="行删除"></a><strong>行删除</strong></h4><p>使用索引标签从DataFrame中删除或删除行。 如果标签重复，则会删除多行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="string">&#x27;zs&#x27;</span>, <span class="number">12</span>], [<span class="string">&#x27;ls&#x27;</span>, <span class="number">4</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="string">&#x27;ww&#x27;</span>, <span class="number">16</span>], [<span class="string">&#x27;zl&#x27;</span>, <span class="number">8</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">df = df.append(df2)</span><br><span class="line"><span class="comment"># 删除index为0的行</span></span><br><span class="line">df = df.drop(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="修改DataFrame中的数据"><a href="#修改DataFrame中的数据" class="headerlink" title="修改DataFrame中的数据"></a><strong>修改DataFrame中的数据</strong></h4><p>更改DataFrame中的数据，原理是将这部分数据提取出来，重新赋值为新的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="string">&#x27;zs&#x27;</span>, <span class="number">12</span>], [<span class="string">&#x27;ls&#x27;</span>, <span class="number">4</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="string">&#x27;ww&#x27;</span>, <span class="number">16</span>], [<span class="string">&#x27;zl&#x27;</span>, <span class="number">8</span>]], columns = [<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">df = df.append(df2)</span><br><span class="line">df[<span class="string">&#x27;Name&#x27;</span>][<span class="number">0</span>] = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="DataFrame常用属性"><a href="#DataFrame常用属性" class="headerlink" title="DataFrame常用属性"></a><strong>DataFrame常用属性</strong></h4><table>
<thead>
<tr>
<th>编号</th>
<th>属性或方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>axes</code></td>
<td>返回 行/列 标签（index）列表。</td>
</tr>
<tr>
<td>2</td>
<td><code>dtype</code></td>
<td>返回对象的数据类型(<code>dtype</code>)。</td>
</tr>
<tr>
<td>3</td>
<td><code>empty</code></td>
<td>如果系列为空，则返回<code>True</code>。</td>
</tr>
<tr>
<td>4</td>
<td><code>ndim</code></td>
<td>返回底层数据的维数，默认定义：<code>1</code>。</td>
</tr>
<tr>
<td>5</td>
<td><code>size</code></td>
<td>返回基础数据中的元素数。</td>
</tr>
<tr>
<td>6</td>
<td><code>values</code></td>
<td>将系列作为<code>ndarray</code>返回。</td>
</tr>
<tr>
<td>7</td>
<td><code>head()</code></td>
<td>返回前<code>n</code>行。</td>
</tr>
<tr>
<td>8</td>
<td><code>tail()</code></td>
<td>返回最后<code>n</code>行。</td>
</tr>
</tbody></table>
<p>实例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>],<span class="string">&#x27;Age&#x27;</span>:[<span class="number">28</span>,<span class="number">34</span>,<span class="number">29</span>,<span class="number">42</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;s1&#x27;</span>,<span class="string">&#x27;s2&#x27;</span>,<span class="string">&#x27;s3&#x27;</span>,<span class="string">&#x27;s4&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;score&#x27;</span>]=pd.Series([<span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>], index=[<span class="string">&#x27;s1&#x27;</span>,<span class="string">&#x27;s2&#x27;</span>,<span class="string">&#x27;s3&#x27;</span>,<span class="string">&#x27;s4&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(df.axes)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;Age&#x27;</span>].dtype)</span><br><span class="line"><span class="built_in">print</span>(df.empty)</span><br><span class="line"><span class="built_in">print</span>(df.ndim)</span><br><span class="line"><span class="built_in">print</span>(df.size)</span><br><span class="line"><span class="built_in">print</span>(df.values)</span><br><span class="line"><span class="built_in">print</span>(df.head(<span class="number">3</span>)) <span class="comment"># df的前三行</span></span><br><span class="line"><span class="built_in">print</span>(df.tail(<span class="number">3</span>)) <span class="comment"># df的后三行</span></span><br></pre></td></tr></table></figure>



<h2 id="Jupyter-notebook"><a href="#Jupyter-notebook" class="headerlink" title="Jupyter notebook"></a>Jupyter notebook</h2><ul>
<li>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。使用浏览器作为界面，向后台的IPython服务器发送请求，并显示结果。 Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 </li>
</ul>
<ul>
<li>IPython 是一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。</li>
</ul>
<p><strong>安装ipython</strong></p>
<p><strong>windows：</strong>     前提是有numpy，matplotlib  pandas </p>
<p>​            采用pip安装  <code>pip install ipython</code></p>
<p><strong>OS X：</strong>        AppStore下载安装苹果开发工具Xcode。</p>
<p>​            使用easy_install或pip安装IPython，或者从源文件安装。</p>
<p><strong>安装Jupyter notebook</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install jupyter</span><br></pre></td></tr></table></figure>



<h2 id="pandas核心"><a href="#pandas核心" class="headerlink" title="pandas核心"></a>pandas核心</h2><h3 id="pandas描述性统计"><a href="#pandas描述性统计" class="headerlink" title="pandas描述性统计"></a>pandas描述性统计</h3><p>数值型数据的描述性统计主要包括了计算数值型数据的完整情况、最小值、均值、中位 数、最大值、四分位数、极差、标准差、方差、协方差等。在NumPy库中一些常用的统计学函数也可用于对数据框进行描述性统计。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.<span class="built_in">min</span>	最小值 </span><br><span class="line">np.<span class="built_in">max</span>	最大值 </span><br><span class="line">np.mean	均值 </span><br><span class="line">np.ptp	极差 </span><br><span class="line">np.median	中位数 </span><br><span class="line">np.std	标准差 </span><br><span class="line">np.var	方差 </span><br><span class="line">np.cov	协方差</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DF</span></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 测试描述性统计函数</span></span><br><span class="line"><span class="built_in">print</span>(df.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(df.<span class="built_in">sum</span>(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(df.mean())</span><br><span class="line"><span class="built_in">print</span>(df.mean(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>pandas提供了统计相关函数：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>count()</code></th>
<th>非空观测数量</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>sum()</code></td>
<td>所有值之和</td>
</tr>
<tr>
<td>3</td>
<td><code>mean()</code></td>
<td>所有值的平均值</td>
</tr>
<tr>
<td>4</td>
<td><code>median()</code></td>
<td>所有值的中位数</td>
</tr>
<tr>
<td>5</td>
<td><code>std()</code></td>
<td>值的标准偏差</td>
</tr>
<tr>
<td>6</td>
<td><code>min()</code></td>
<td>所有值中的最小值</td>
</tr>
<tr>
<td>7</td>
<td><code>max()</code></td>
<td>所有值中的最大值</td>
</tr>
<tr>
<td>8</td>
<td><code>abs()</code></td>
<td>绝对值</td>
</tr>
<tr>
<td>9</td>
<td><code>prod()</code></td>
<td>数组元素的乘积</td>
</tr>
<tr>
<td>10</td>
<td><code>cumsum()</code></td>
<td>累计总和</td>
</tr>
<tr>
<td>11</td>
<td><code>cumprod()</code></td>
<td>累计乘积</td>
</tr>
</tbody></table>
<p>pandas还提供了一个方法叫作describe，能够一次性得出数据框所有数值型特征的非空值数目、均值、标准差等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create a Dictionary of series</span></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create a DataFrame</span></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df.describe())</span><br><span class="line"><span class="built_in">print</span>(df.describe(include=[<span class="string">&#x27;object&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(df.describe(include=[<span class="string">&#x27;number&#x27;</span>]))</span><br></pre></td></tr></table></figure>



<h3 id="pandas排序"><a href="#pandas排序" class="headerlink" title="pandas排序"></a>pandas排序</h3><p>​    <em>Pandas</em>有两种排序方式，它们分别是按标签与按实际值排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">unsorted_df=pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">                         index=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>],columns=[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(unsorted_df)</span><br></pre></td></tr></table></figure>

<h4 id="按行标签排序"><a href="#按行标签排序" class="headerlink" title="按行标签排序"></a><strong>按行标签排序</strong></h4><p>​    使<font color="red">sort_index()</font>方法，通过传递<code>axis</code>参数和排序顺序，可以对<code>DataFrame</code>进行排序。 默认情况下，按照升序对行标签进行排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line">unsorted_df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 按照行标进行排序</span></span><br><span class="line">sorted_df=unsorted_df.sort_index()</span><br><span class="line"><span class="built_in">print</span> (sorted_df)</span><br><span class="line"><span class="comment"># 控制排序顺序</span></span><br><span class="line">sorted_df = unsorted_df.sort_index(ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span> (sorted_df)</span><br></pre></td></tr></table></figure>

<h4 id="按列标签排序"><a href="#按列标签排序" class="headerlink" title="按列标签排序"></a><strong>按列标签排序</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line">unsorted_df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 按照列标签进行排序</span></span><br><span class="line">sorted_df=unsorted_df.sort_index(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> (sorted_df)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="按某列值排序"><a href="#按某列值排序" class="headerlink" title="按某列值排序"></a><strong>按某列值排序</strong></h4><p>​    像索引排序一样，<font color="red">sort_values()</font>是按值排序的方法。它接受一个<code>by</code>参数，它将使用要与其排序值的<code>DataFrame</code>的列名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line">unsorted_df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 按照年龄进行排序</span></span><br><span class="line">sorted_df = unsorted_df.sort_values(by=<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (sorted_df)</span><br><span class="line"><span class="comment"># 先按Age进行升序排序，然后按Rating降序排序</span></span><br><span class="line">sorted_df = unsorted_df.sort_values(by=[<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Rating&#x27;</span>], ascending=[<span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"><span class="built_in">print</span> (sorted_df)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="pandas分组"><a href="#pandas分组" class="headerlink" title="pandas分组"></a>pandas分组</h3><p>在许多情况下，我们将数据分成多个集合，并在每个子集上应用一些函数。在应用函数中，可以执行以下操作 :</p>
<ul>
<li><em>聚合</em> - 计算汇总统计</li>
<li><em>转换</em> - 执行一些特定于组的操作</li>
<li><em>过滤</em> - 在某些情况下丢弃数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">ipl_data = &#123;<span class="string">&#x27;Team&#x27;</span>: [<span class="string">&#x27;Riders&#x27;</span>, <span class="string">&#x27;Riders&#x27;</span>, <span class="string">&#x27;Devils&#x27;</span>, <span class="string">&#x27;Devils&#x27;</span>, <span class="string">&#x27;Kings&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;kings&#x27;</span>, <span class="string">&#x27;Kings&#x27;</span>, <span class="string">&#x27;Kings&#x27;</span>, <span class="string">&#x27;Riders&#x27;</span>, <span class="string">&#x27;Royals&#x27;</span>, <span class="string">&#x27;Royals&#x27;</span>, <span class="string">&#x27;Riders&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;Rank&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>,<span class="number">4</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">2</span> , <span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">         <span class="string">&#x27;Year&#x27;</span>: [<span class="number">2014</span>,<span class="number">2015</span>,<span class="number">2014</span>,<span class="number">2015</span>,<span class="number">2014</span>,<span class="number">2015</span>,<span class="number">2016</span>,<span class="number">2017</span>,<span class="number">2016</span>,<span class="number">2014</span>,<span class="number">2015</span>,<span class="number">2017</span>],</span><br><span class="line">         <span class="string">&#x27;Points&#x27;</span>:[<span class="number">876</span>,<span class="number">789</span>,<span class="number">863</span>,<span class="number">673</span>,<span class="number">741</span>,<span class="number">812</span>,<span class="number">756</span>,<span class="number">788</span>,<span class="number">694</span>,<span class="number">701</span>,<span class="number">804</span>,<span class="number">690</span>]&#125;</span><br><span class="line">df = pd.DataFrame(ipl_data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="将数据拆分成组"><a href="#将数据拆分成组" class="headerlink" title="将数据拆分成组"></a>将数据拆分成组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照年份Year字段分组</span></span><br><span class="line"><span class="built_in">print</span> (df.groupby(<span class="string">&#x27;Year&#x27;</span>))</span><br><span class="line"><span class="comment"># 查看分组结果</span></span><br><span class="line"><span class="built_in">print</span> (df.groupby(<span class="string">&#x27;Year&#x27;</span>).groups)</span><br></pre></td></tr></table></figure>

<h4 id="迭代遍历分组"><a href="#迭代遍历分组" class="headerlink" title="迭代遍历分组"></a>迭代遍历分组</h4><p>groupby返回可迭代对象，可以使用for循环遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grouped = df.groupby(<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line"><span class="comment"># 遍历每个分组</span></span><br><span class="line"><span class="keyword">for</span> year,group <span class="keyword">in</span> grouped:</span><br><span class="line">    <span class="built_in">print</span> (year)</span><br><span class="line">    <span class="built_in">print</span> (group)</span><br></pre></td></tr></table></figure>

<h4 id="获得一个分组细节"><a href="#获得一个分组细节" class="headerlink" title="获得一个分组细节"></a>获得一个分组细节</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grouped = df.groupby(<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (grouped.get_group(<span class="number">2014</span>))</span><br></pre></td></tr></table></figure>

<h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><p>​    聚合函数为每个组返回聚合值。当创建了分组(<em>group by</em>)对象，就可以对每个分组数据执行求和、求标准差等操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 聚合每一年的平均的分</span></span><br><span class="line">grouped = df.groupby(<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (grouped[<span class="string">&#x27;Points&#x27;</span>].agg(np.mean))</span><br><span class="line"><span class="comment"># 聚合每一年的分数之和、平均分、标准差</span></span><br><span class="line">grouped = df.groupby(<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line">agg = grouped[<span class="string">&#x27;Points&#x27;</span>].agg([np.<span class="built_in">sum</span>, np.mean, np.std])</span><br><span class="line"><span class="built_in">print</span> (agg)</span><br></pre></td></tr></table></figure>



<h3 id="pandas数据表关联操作"><a href="#pandas数据表关联操作" class="headerlink" title="pandas数据表关联操作"></a>pandas数据表关联操作</h3><p>​    Pandas具有功能全面的高性能内存中连接操作，与SQL等关系数据库非常相似。<br>​    Pandas提供了一个单独的<code>merge()</code>函数，作为DataFrame对象之间所有标准数据库连接操作的入口。</p>
<p><strong>合并两个DataFrame：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">left = pd.DataFrame(&#123;</span><br><span class="line">         <span class="string">&#x27;student_id&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">         <span class="string">&#x27;student_name&#x27;</span>: [<span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;Amy&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Ayoung&#x27;</span>, <span class="string">&#x27;Billy&#x27;</span>, <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;Bran&#x27;</span>, <span class="string">&#x27;Bryce&#x27;</span>, <span class="string">&#x27;Betty&#x27;</span>, <span class="string">&#x27;Emma&#x27;</span>, <span class="string">&#x27;Marry&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>, <span class="string">&#x27;Jean&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Daniel&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;class_id&#x27;</span>:[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>], </span><br><span class="line">         <span class="string">&#x27;gender&#x27;</span>:[<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>], </span><br><span class="line">         <span class="string">&#x27;age&#x27;</span>:[<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>], </span><br><span class="line">         <span class="string">&#x27;score&#x27;</span>:[<span class="number">98</span>,<span class="number">74</span>,<span class="number">67</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">29</span>,<span class="number">32</span>,<span class="number">34</span>,<span class="number">85</span>,<span class="number">64</span>,<span class="number">52</span>,<span class="number">38</span>,<span class="number">26</span>,<span class="number">89</span>,<span class="number">68</span>,<span class="number">46</span>,<span class="number">32</span>,<span class="number">78</span>,<span class="number">79</span>,<span class="number">87</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(</span><br><span class="line">         &#123;<span class="string">&#x27;class_id&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">         <span class="string">&#x27;class_name&#x27;</span>: [<span class="string">&#x27;ClassA&#x27;</span>, <span class="string">&#x27;ClassB&#x27;</span>, <span class="string">&#x27;ClassC&#x27;</span>, <span class="string">&#x27;ClassE&#x27;</span>]&#125;)</span><br><span class="line"><span class="comment"># 合并两个DataFrame</span></span><br><span class="line">data = pd.merge(left,right)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<p><strong>使用“how”参数合并DataFrame：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并两个DataFrame (左连接)</span></span><br><span class="line">rs = pd.merge(left, right, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br></pre></td></tr></table></figure>

<p>其他合并方法同数据库相同：<a href="https://www.durango.cn/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/">请参考MySQL连接操作</a></p>
<table>
<thead>
<tr>
<th>合并方法</th>
<th>SQL等效</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>left</code></td>
<td><code>LEFT OUTER JOIN</code></td>
<td>使用左侧对象的键</td>
</tr>
<tr>
<td><code>right</code></td>
<td><code>RIGHT OUTER JOIN</code></td>
<td>使用右侧对象的键</td>
</tr>
<tr>
<td><code>outer</code></td>
<td><code>FULL OUTER JOIN</code></td>
<td>使用键的联合</td>
</tr>
<tr>
<td><code>inner</code></td>
<td><code>INNER JOIN</code></td>
<td>使用键的交集</td>
</tr>
</tbody></table>
<p>试验：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并两个DataFrame (左连接)</span></span><br><span class="line">rs = pd.merge(left,right,on=<span class="string">&#x27;subject_id&#x27;</span>, how=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br><span class="line"><span class="comment"># 合并两个DataFrame (左连接)</span></span><br><span class="line">rs = pd.merge(left,right,on=<span class="string">&#x27;subject_id&#x27;</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br><span class="line"><span class="comment"># 合并两个DataFrame (左连接)</span></span><br><span class="line">rs = pd.merge(left,right,on=<span class="string">&#x27;subject_id&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rs)</span><br></pre></td></tr></table></figure>



<h3 id="pandas透视表与交叉表"><a href="#pandas透视表与交叉表" class="headerlink" title="pandas透视表与交叉表"></a>pandas透视表与交叉表</h3><p>有如下数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">left = pd.DataFrame(&#123;</span><br><span class="line">         <span class="string">&#x27;student_id&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">         <span class="string">&#x27;student_name&#x27;</span>: [<span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;Amy&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Ayoung&#x27;</span>, <span class="string">&#x27;Billy&#x27;</span>, <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;Bran&#x27;</span>, <span class="string">&#x27;Bryce&#x27;</span>, <span class="string">&#x27;Betty&#x27;</span>, <span class="string">&#x27;Emma&#x27;</span>, <span class="string">&#x27;Marry&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>, <span class="string">&#x27;Jean&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Daniel&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;class_id&#x27;</span>:[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>], </span><br><span class="line">         <span class="string">&#x27;gender&#x27;</span>:[<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;F&#x27;</span>], </span><br><span class="line">         <span class="string">&#x27;age&#x27;</span>:[<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>], </span><br><span class="line">         <span class="string">&#x27;score&#x27;</span>:[<span class="number">98</span>,<span class="number">74</span>,<span class="number">67</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">29</span>,<span class="number">32</span>,<span class="number">34</span>,<span class="number">85</span>,<span class="number">64</span>,<span class="number">52</span>,<span class="number">38</span>,<span class="number">26</span>,<span class="number">89</span>,<span class="number">68</span>,<span class="number">46</span>,<span class="number">32</span>,<span class="number">78</span>,<span class="number">79</span>,<span class="number">87</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(</span><br><span class="line">         &#123;<span class="string">&#x27;class_id&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">         <span class="string">&#x27;class_name&#x27;</span>: [<span class="string">&#x27;ClassA&#x27;</span>, <span class="string">&#x27;ClassB&#x27;</span>, <span class="string">&#x27;ClassC&#x27;</span>, <span class="string">&#x27;ClassE&#x27;</span>]&#125;)</span><br><span class="line"><span class="comment"># 合并两个DataFrame</span></span><br><span class="line">data = pd.merge(left,right)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<h4 id="透视表"><a href="#透视表" class="headerlink" title="透视表"></a><strong>透视表</strong></h4><p>​    透视表(pivot table)是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。<strong>它根据一个或多个键对数据进行分组聚合，并根据每个分组进行数据汇总</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以class_id与gender做分组汇总数据，默认聚合统计所有列</span></span><br><span class="line"><span class="built_in">print</span>(data.pivot_table(index=[<span class="string">&#x27;class_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以class_id与gender做分组汇总数据，聚合统计score列</span></span><br><span class="line"><span class="built_in">print</span>(data.pivot_table(index=[<span class="string">&#x27;class_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>], values=[<span class="string">&#x27;score&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以class_id与gender做分组汇总数据，聚合统计score列，针对age的每个值列级分组统计</span></span><br><span class="line"><span class="built_in">print</span>(data.pivot_table(index=[<span class="string">&#x27;class_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>], values=[<span class="string">&#x27;score&#x27;</span>], </span><br><span class="line">                       columns=[<span class="string">&#x27;age&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以class_id与gender做分组汇总数据，聚合统计score列，针对age的每个值列级分组统计，添加行、列小计</span></span><br><span class="line"><span class="built_in">print</span>(data.pivot_table(index=[<span class="string">&#x27;class_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>], values=[<span class="string">&#x27;score&#x27;</span>], </span><br><span class="line">                       columns=[<span class="string">&#x27;age&#x27;</span>], margins=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以class_id与gender做分组汇总数据，聚合统计score列，针对age的每个值列级分组统计，添加行、列小计</span></span><br><span class="line"><span class="built_in">print</span>(data.pivot_table(index=[<span class="string">&#x27;class_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>], values=[<span class="string">&#x27;score&#x27;</span>], </span><br><span class="line">                       columns=[<span class="string">&#x27;age&#x27;</span>], margins=<span class="literal">True</span>, aggfunc=<span class="string">&#x27;max&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="交叉表"><a href="#交叉表" class="headerlink" title="交叉表"></a><strong>交叉表</strong></h4><p>交叉表(cross-tabulation, 简称crosstab)是一种用于<strong>计算分组频率的特殊透视表</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照class_id分组，针对不同的gender，统计数量</span></span><br><span class="line"><span class="built_in">print</span>(pd.crosstab(data.class_id, data.gender, margins=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>



<h3 id="pandas可视化"><a href="#pandas可视化" class="headerlink" title="pandas可视化"></a>pandas可视化</h3><h4 id="基本绘图"><a href="#基本绘图" class="headerlink" title="基本绘图"></a><strong>基本绘图</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> mp </span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">4</span>),index=pd.date_range(<span class="string">&#x27;2018/12/18&#x27;</span>,</span><br><span class="line">   periods=<span class="number">10</span>), columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line">df.plot()</span><br><span class="line">mp.show()</span><br></pre></td></tr></table></figure>

<p>plot方法允许除默认线图之外的少数绘图样式。 这些方法可以作为<code>plot()</code>的<code>kind</code>关键字参数。这些包括 ：</p>
<ul>
<li><code>bar</code>或<code>barh</code>为条形</li>
<li><code>hist</code>为直方图</li>
<li><code>scatter</code>为散点图</li>
</ul>
<h4 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a><strong>条形图</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">4</span>),columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df.plot.bar()</span><br><span class="line"><span class="comment"># df.plot.bar(stacked=True)</span></span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a><strong>直方图</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame()</span><br><span class="line">df[<span class="string">&#x27;a&#x27;</span>] = pd.Series(np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)-<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&#x27;b&#x27;</span>] = pd.Series(np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>))</span><br><span class="line">df[<span class="string">&#x27;c&#x27;</span>] = pd.Series(np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line">df.plot.hist(bins=<span class="number">20</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a><strong>散点图</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">50</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df.plot.scatter(x=<span class="string">&#x27;a&#x27;</span>, y=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a><strong>饼状图</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(<span class="number">3</span> * np.random.rand(<span class="number">4</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], columns=[<span class="string">&#x27;x&#x27;</span>])</span><br><span class="line">df.plot.pie(subplots=<span class="literal">True</span>)</span><br><span class="line">mp.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="数据读取与存储"><a href="#数据读取与存储" class="headerlink" title="数据读取与存储"></a>数据读取与存储</h3><h4 id="读取与存储csv："><a href="#读取与存储csv：" class="headerlink" title="读取与存储csv："></a><strong>读取与存储csv：</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filepath 文件路径。该字符串可以是一个URL。有效的URL方案包括http，ftp和file </span></span><br><span class="line"><span class="comment"># sep 分隔符。read_csv默认为“,”，read_table默认为制表符“[Tab]”。</span></span><br><span class="line"><span class="comment"># header 接收int或sequence。表示将某行数据作为列名。默认为infer，表示自动识别。</span></span><br><span class="line"><span class="comment"># names 接收array。表示列名。</span></span><br><span class="line"><span class="comment"># index_col 表示索引列的位置，取值为sequence则代表多重索引。 </span></span><br><span class="line"><span class="comment"># dtype 代表写入的数据类型（列名为key，数据格式为values）。</span></span><br><span class="line"><span class="comment"># engine 接收c或者python。代表数据解析引擎。默认为c。</span></span><br><span class="line"><span class="comment"># nrows 接收int。表示读取前n行。</span></span><br><span class="line"></span><br><span class="line">pd.read_table(</span><br><span class="line">    filepath_or_buffer, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="string">&#x27;infer&#x27;</span>, names=<span class="literal">None</span>, </span><br><span class="line">    index_col=<span class="literal">None</span>, dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, nrows=<span class="literal">None</span>) </span><br><span class="line">pd.read_csv(</span><br><span class="line">    filepath_or_buffer, sep=<span class="string">&#x27;,&#x27;</span>, header=<span class="string">&#x27;infer&#x27;</span>, names=<span class="literal">None</span>, </span><br><span class="line">    index_col=<span class="literal">None</span>, dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, nrows=<span class="literal">None</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_csv(excel_writer=<span class="literal">None</span>, sheetname=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, mode=’w’, encoding=<span class="literal">None</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="读取与存储excel："><a href="#读取与存储excel：" class="headerlink" title="读取与存储excel："></a><strong>读取与存储excel：</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># io 表示文件路径。</span></span><br><span class="line"><span class="comment"># sheetname 代表excel表内数据的分表位置。默认为0。 </span></span><br><span class="line"><span class="comment"># header 接收int或sequence。表示将某行数据作为列名。默认为infer，表示自动识别。</span></span><br><span class="line"><span class="comment"># names 表示索引列的位置，取值为sequence则代表多重索引。</span></span><br><span class="line"><span class="comment"># index_col 表示索引列的位置，取值为sequence则代表多重索引。</span></span><br><span class="line"><span class="comment"># dtype 接收dict。数据类型。</span></span><br><span class="line">pandas.read_excel(io, sheetname=<span class="number">0</span>, header=<span class="number">0</span>, index_col=<span class="literal">None</span>, names=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_excel(excel_writer=<span class="literal">None</span>, sheetname=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, mode=’w’, encoding=<span class="literal">None</span>) </span><br></pre></td></tr></table></figure>

<h4 id="读取与存储JSON："><a href="#读取与存储JSON：" class="headerlink" title="读取与存储JSON："></a><strong>读取与存储JSON：</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过json模块转换为字典，再转换为DataFrame</span></span><br><span class="line">pd.read_json(<span class="string">&#x27;../ratings.json&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="案例：movielens电影评分数据分析"><a href="#案例：movielens电影评分数据分析" class="headerlink" title="案例：movielens电影评分数据分析"></a>案例：movielens电影评分数据分析</h2><p>需求如下：</p>
<ol>
<li><p>读取数据，从用户表读取用户信息、同样方法，导入电影评分表、电影数据表。</p>
</li>
<li><p>合并数据表</p>
</li>
<li><p>对数据初步描述分析</p>
</li>
<li><p>查看每一部电影不同性别的平均评分并计算分歧差值，之后排序</p>
</li>
<li><p>算出每部电影平均得分并对其进行排序</p>
</li>
<li><p>查看评分次数多的电影并进行排序 </p>
</li>
<li><p>过滤掉评分条目数不足250条的电影</p>
</li>
<li><p>评分最高的十部电影</p>
</li>
<li><p>查看不同年龄的分布情况并且采用直方图进行可视化</p>
</li>
<li><p>在原数据中标记出用户位于的年龄分组</p>
</li>
<li><p>可视化显示movies_ratings中不同类型电影的频数</p>
</li>
</ol>
]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>生物信息学笔记</title>
    <url>/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="认识序列"><a href="#认识序列" class="headerlink" title="认识序列"></a>认识序列</h2><h3 id="序列分类"><a href="#序列分类" class="headerlink" title="序列分类"></a>序列分类</h3><p>​    蛋白质序列和核酸序列。蛋白质序列是由 20 个不同的字母，也就是 20 种不同的氨基酸排列组合而成。核酸序列是由 4 种不同的字母，也就是 4 种 不同的碱基排列组合而成。核酸序列又分为 DNA 序列和 RNA 序列。 </p>
<h3 id="序列格式"><a href="#序列格式" class="headerlink" title="序列格式"></a>序列格式</h3><p>​    生物序列有自己的书写格式，而且格式很多。不同的处理软件会用到不同的格式，但是最常用的，大多数软件都识别的格式是 <strong>FASTA 格式</strong>。</p>
<p>​    FASTA 格式，第一行是一个大于号“&gt;”开头，后面紧接注释信息，比如序 列的名字，编号等。因为前面有大于号，序列分析软件会自动识别这是一条序列的开始，且 这一行是注释而不是序列。从第二行开始就是纯序列部分。</p>
<h2 id="序列相似性"><a href="#序列相似性" class="headerlink" title="序列相似性"></a>序列相似性</h2><h3 id="序列相似性的意义"><a href="#序列相似性的意义" class="headerlink" title="序列相似性的意义"></a>序列相似性的意义</h3><p>​    意义在于，相似的序列往往起源于一个共同的祖先。它们很可能有相似的 空间结构和生物学功能。因此，对于一个已知序列但未知结构和功能的蛋白质，如果与它序 列相似的某些蛋白质的结构和功能已知，那么就可以推测出这个未知结构和功能的蛋白质的结构和功能。简言之，相似的序列意味着相似的结构，相似的结构意味着相似的功能</p>
<h3 id="一致度和相似度"><a href="#一致度和相似度" class="headerlink" title="一致度和相似度"></a>一致度和相似度</h3><p>​    一致度可以定义为它们对应位置上相同的残基数目占总长度的百分比。一个残基就是指一个字母（氨基酸或碱基）</p>
<p>​    相似度可以暂时定义为他们对应位置上相似的残基 与相同的残基的数目和占总长度的百分比</p>
<h2 id="替换计分矩阵"><a href="#替换计分矩阵" class="headerlink" title="替换计分矩阵"></a>替换计分矩阵</h2><h3 id="核酸序列的替换记分矩阵"><a href="#核酸序列的替换记分矩阵" class="headerlink" title="核酸序列的替换记分矩阵"></a><strong>核酸序列的替换记分矩阵</strong></h3><h4 id="等价矩阵"><a href="#等价矩阵" class="headerlink" title="等价矩阵"></a>等价矩阵</h4><p>​    这个矩阵最简单. 其中，相同核苷酸之间的匹配得分为 1，不同核苷酸间的替换得分为 0。由于不含有碱基的 理化信息和不区别对待不同的替换，在实际的序列比较中很少使用，一般只用于理论计算。</p>
<h4 id="转换-颠换矩阵"><a href="#转换-颠换矩阵" class="headerlink" title="转换-颠换矩阵"></a>转换-颠换矩阵</h4><p>​    我们说 核酸的碱基按照环结构特征被划分为两类，一类是嘌呤，包括腺嘌呤 A 和鸟嘌呤 G，它们都有两个环；另一类是嘧啶，包括胞嘧啶 C 和胸腺嘧啶 T，它们只有一个环。</p>
<p>​    如果 DNA 碱基的替换保持环数不变，则称为<strong>转换</strong>，比如腺嘌呤 A 替换为 鸟嘌呤 G、或者胞嘧啶 C 替换 为胸腺嘧啶 T，也就是嘌呤变嘌呤，嘧啶变嘧啶；如果环数发生变化，则称为<strong>颠换</strong>，比如腺 嘌呤 A 替换为胞嘧啶 C、或者胸腺嘧啶 T 替换为鸟嘌呤 G，也就是嘌呤变嘧啶，或者嘧啶 变嘌呤。</p>
<p>​    在进化过程中，转换发生的频率远比颠换高。也就是说，大自然更倾向于接受嘌呤 和嘌呤之间的替换，以及嘧啶和嘧啶之间的替换，而嘌呤和嘧啶之间的替换会导致不好的事 情发生，这种替换大多在进化过程中已经被淘汰了。为了反映这一情况，转换-颠换矩阵中， 转换的得分比颠换要高为-1 分，而颠换的得分为-5 分。 </p>
<h4 id="BLAST矩阵"><a href="#BLAST矩阵" class="headerlink" title="BLAST矩阵"></a>BLAST矩阵</h4><p>​    经过大量实际比对发现，如果令被比对的两个核苷酸相同时 得分为+5 分，不相同为-4 分，这时比对效果最好。这个矩阵广泛地被 DNA 序列比较所采 用。没有为什么，就是好，实践经验所得。因为这个矩阵最早应用于 BLAST 工具，因此得名 BLAST 矩阵</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984260134.png" alt="1667984260134"></p>
<h3 id="蛋白质序列的替换记分矩阵"><a href="#蛋白质序列的替换记分矩阵" class="headerlink" title="蛋白质序列的替换记分矩阵"></a>蛋白质序列的替换记分矩阵</h3><h4 id="等价矩阵-1"><a href="#等价矩阵-1" class="headerlink" title="等价矩阵"></a>等价矩阵</h4><h4 id="PAM-矩阵"><a href="#PAM-矩阵" class="headerlink" title="PAM 矩阵"></a>PAM 矩阵</h4><p>​    PAM 矩阵基于进化原 理。如果两种氨基酸替换频繁，说明自然界容易接受这种替换，那么这一对氨基酸替换的得 分就应该高。</p>
<p>​    PAM 矩阵是目前蛋白质序列比较中最广泛使用的记分方法之一。基础的 PAM-1 矩阵反应的是进化产生的每一百个氨基酸平均发生一个突变的量值，由统计方法得到。 PAM-1 自乘 n 次，可以得到 PAM-n ，表示发生了更多次突变。</p>
<p>​    我们需要根据要比较的序列之间的亲缘关系远近，来选择适合的 PAM 矩阵。如果序列亲缘关系远，也就是说序列间会 有很多突变，那就选 PAM 后面跟一个大数字的矩阵。如果亲缘关系近，也就是突变比较少， 序列间大多数地方都是一样的，那就选 PAM 后面跟一个小数字的矩阵。</p>
<p>​    如PAM250矩阵。对角线上的数值为匹配氨基酸的得分。其他位置上≥0 的得分代 表对应的一对氨基酸为相似氨基酸，&lt;0 的是不相似的氨基酸。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984465411.png" alt="1667984465411"></p>
<h4 id="BLOSUM-矩阵"><a href="#BLOSUM-矩阵" class="headerlink" title="BLOSUM 矩阵"></a>BLOSUM 矩阵</h4><p>​    BLOSUM 矩阵有和 PAM 矩阵相同的地方，也有不同的地方。相同的是，BLOSUM 矩阵 后面也带有一个编号，有很多种 BLOSUM 矩阵。不同的是，BLOSUM 矩阵都是通过对大量 符合特定要求的序列计算而来的。这点和 PAM 矩阵不同的。</p>
<p>​    PAM-1 矩阵是基于相似度大于85%的序列计算产生的，也就是通过关系较近的序列计算出来的。那些进化距离较远的矩阵， 如 PAM-250，是通过 PAM-1 自乘得到的。也就是说，BLOSUM 矩阵的相似性是根据<strong>真实数</strong> <strong>据</strong>产生的，而 PAM 矩阵是通过矩阵自乘外推而来的。和 PAM 矩阵的另一个不同之处是 BLOSUM 矩阵的编号。这些编号，比如 BLOSUM80 中的 80，代表这个矩阵是由一致度≥80% 的序列计算而来的。同理，BLOSUM62 是指这个矩阵是由一致度≥62%的序列计算而来的。 因此，BLOSUM 后面跟一个小数字的矩阵适合用于比较相似度低的序列，也就是亲缘关系 远的序列；而 BLOSUM 后面跟一个大数字的矩阵适合比较相似度高的序列，也就是亲缘关 系近的序列。  </p>
<p>​    BLOSUM 62 矩阵.样子和 PAM 矩阵差不多，但是里面的数值是不一样的。同样， ≥0 的得分代表对应的一对氨基酸为相似氨基酸，&lt;0 的是不相似的氨基酸。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984606849.png" alt="1667984606849"></p>
<p>​    亲缘关系较近的序列之间的比较，用 PAM 数小的矩阵或 BLOSUM 数大的矩阵；而亲缘关系较远的序列之间的比较，用 PAM 数大的矩阵或 BLOSUM数小的矩阵。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984664136.png" alt="1667984664136"></p>
<h4 id="遗传密码矩阵"><a href="#遗传密码矩阵" class="headerlink" title="遗传密码矩阵"></a>遗传密码矩阵</h4><p>​    它是通过计算一个氨基酸转换成另一个氨基酸所需的密码子变化的数目而得到的。 矩阵的值对应为据此付出的代价。如果变化一个碱基就可以使一个氨基酸的密码子转换为另 一个氨基酸的密码子，则这两个氨基酸的替换代价为 1；如果需要 2 个碱基的改变，则替换 代价为 2；再比如从蛋氨酸（Met）到酪氨酸（Tyr）三个密码子都要变，则代价为 3。</p>
<p>​    遗传密码矩阵常用于进化距离的计算，它的优点是计算结果可以直接用于绘制进化树，但是它在 蛋白质序列比对，尤其是相似程度很低的蛋白质序列比对中，很少被使用。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984738576.png" alt="1667984738576"></p>
<h4 id="疏水矩阵"><a href="#疏水矩阵" class="headerlink" title="疏水矩阵"></a>疏水矩阵</h4><p>​    它是根据氨基酸残基替换前后疏水性的变化而得到的矩阵。 若一次氨基酸替换导致疏水特性不发生太大的变化，则这种替换得分高，否则替换得分低。 疏水矩阵物理意义明确，有一定的<strong>理化性质</strong>依据，适用于偏重蛋白质功能方面的序列比对。 在这个矩阵里，氨基酸按照亲疏水性排列。前边是亲水的，后面是疏水的。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1667984790580.png" alt="1667984790580"></p>
<h2 id="序列比对-Dotplot打点法"><a href="#序列比对-Dotplot打点法" class="headerlink" title="序列比对-Dotplot打点法"></a>序列比对-Dotplot打点法</h2><h3 id="序列比对概念"><a href="#序列比对概念" class="headerlink" title="序列比对概念"></a>序列比对概念</h3><p>​    <strong>Sequence aligmen</strong>t:运用特定的算法找出两个或者多个序列之间产生最大相似度得分的空格插入和序列排列方案。</p>
<p>比如：</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668043108983.png" alt="1668043108983"></p>
<p>​    这两条序列的比对就是把 s 和 t 这两个字符串上下排列起来，在某些位置插入空格，这些空格叫空位（gap）。然后依次比较它们在每一个位置上字符的匹配情况，匹配的好，这个位置 就会得高分，匹配的不好，看看能不能左右错一错，或填上个空位，让附近的位置更好的匹 配在一起，从而使所有位置的得分之和尽可能的高。说白了，就是通过插入空位，让上下两行中尽可能多的一致的和相似的字符对在一起。这不是随便摆摆看看就能完成的，需要使用专门的序列比对算法。 </p>
<p>​    根据比对序列的个数可以把序列比对分为<strong>双序列比对和多序列比对</strong>。顾名思义，双序列 比对就是比 2 条，而多序列比对是比 2 条以上。此外根据序列比对的算法不同，</p>
<p>​    双序列比对 又分为<strong>全局比对和局部比对</strong>。全局比对就是全长比较，一个字符都不能落下。而局部比对是 比较对得最好的局部，对得不好的部分会被忽略不计。我们将从双序列比对的全局比对入手，看看序列比对的算法是如何插入空位，并使得插入后两条序列的得分最高的。</p>
<h3 id="打点法概念"><a href="#打点法概念" class="headerlink" title="打点法概念"></a>打点法概念</h3><p>​    打点法是最简单的比较两个序列的方法，理论上可以用纸和笔来完成。如果要比较下面这两条序列： </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668043715094.png" alt="1668043715094"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668043742557.png" alt="1668043742557"></p>
<p>​    在打点矩阵中，<strong>连续的对角线及对角线的平行线代表两条序列中相同的区域</strong>。</p>
<p>​    这个矩阵 中在主对角线位置上连续的红色的对角线说明这个位置对应的序列 1 的部分和序列 2 的部分是完全相同的，都是 THEFA。此外，跟红对角线平行的蓝色平行线和绿色平行线，同样指出了序列 1 和序列 2 中两条相同的序列。也就是序列 1 和序列 2 中对应位置的 TCAT，以及序列 1 和序列 2 中对应位置的 AT。由这三条线，我们找到了序列 1 和序列 2 中三条相同的 子序列。最后，我们放眼全局，红色的线和蓝色的线加起来基本上构成了一条主对角线。由 此我们可以得出结论：序列 1 和序列 2 是比较相似的两条序列</p>
<p>​    </p>
<p>​    除了可以用打点法给两条不同的序列打点，还可以用一条序列自己跟自己打点。这样可 以发现序列中重复的片段。比如我们让下面这条序列自己和自己打点：</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668044008636.png" alt="1668044008636"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668044040422.png" alt="1668044040422"></p>
<p>​    这样的打点矩阵必然是对称的，并且一定有一条主对角线（图 3）。此外，在横向或纵向上， 与主对角线平行的短平行线所对应的序列片段就是重复的部分。其中，红色短平行线对应的 ‘THE’在序列中重复出现了 3 次。包括主对角线在内，平行线出现的次数就是重复的次数。 </p>
<p>​    用这种方法我们还可以快捷的发现序列中的<strong>串联重复序列以及重复的次数</strong>。我们只要数数在半个矩阵中包括主对角线在内的所有等距的平行线的个数，就可以知道重复的次数，而且最短的平行线对应的序列就是重复单元。</p>
<p>​    短的串联重复序列具有高度多态性，也就 是说不同的个体间重复次数存在差异，而且这种差异在基因遗传过程中一般遵循孟德尔共显性遗传规律，所以快速查找某些特定的短的串联复序列的重复次数可以用于法医学的<u>个体识别或亲子鉴定</u>等领域。 </p>
<h3 id="Dotlet-界面介绍"><a href="#Dotlet-界面介绍" class="headerlink" title="Dotlet 界面介绍"></a><strong>Dotlet 界面介绍</strong></h3><p>​    可以自动打点的软件有很多（表 1）。我们挑其中最常用的 Dotlet 软件做为演示（<strong><a href="http://myhits.isb-sib.ch/cgi-bin/dotlet">http://myhits.isb-sib.ch/cgi-bin/dotlet</a></strong>。Dotlet 基于 Java 开发，所以页面打开后会蹦出 JAVA 对话框。像对待 Jsmol 一样，接受 JAVA，信任 JAVA，运行 JAVA。当然前提是你的电脑已 经安装了 JAVA。如果还没有安装，可以到课程附件或者 JAVA 官网下载安装。别忘了安装后，重启浏览器，JAVA 才能生效。同样的，IE 如果不好使，可以尝试其他浏览器。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668044569496.png" alt="1668044569496"></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">网址链接</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Dotlet</td>
<td align="center"><a href="http://myhits.isb-sib.ch/cgi-bin/dotlet">http://myhits.isb-sib.ch/cgi-bin/dotlet</a></td>
</tr>
<tr>
<td align="center">Dnadot</td>
<td align="center"><a href="http://arbl.cvmbs.colostate.edu/molkit/dnadot">http://arbl.cvmbs.colostate.edu/molkit/dnadot</a></td>
</tr>
<tr>
<td align="center">Dotter</td>
<td align="center"><a href="http://sonnhammer.sbc.su.se/Dotter.html">http://sonnhammer.sbc.su.se/Dotter.html</a></td>
</tr>
<tr>
<td align="center">Dottup</td>
<td align="center"><a href="http://emboss.sourceforge.net/">http://emboss.sourceforge.net</a></td>
</tr>
</tbody></table>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668044813102.png" alt="1668044813102"></p>
<h3 id="Dotlet-应用实例"><a href="#Dotlet-应用实例" class="headerlink" title="Dotlet 应用实例"></a>Dotlet 应用实例</h3><p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668044956053.png" alt="1668044956053"></p>
<p>​    图 1 是上一节中 seq1 自己和自己打点计算出的打点图。注意默认的颜色方案是在越相 似的地方打的点的颜色越浅，越不相似的地方颜色越深。所以整体感觉像是在一张黑纸上打 白点。因为是 seq1 自己和自己打点，所以应该有一条明显的主对角线，这是所有自己和自 己打点的序列都会出现的情况。除此之外，还有一条与主对角线平行的次对角线，涉及 seq1 大约 1/2 的长度。这说明 seq1 的前半部分和后半部分非常的相似！</p>
<p>​    我们把鼠标点在这条次对角线上的任意位置，之后就可以从下面的序列显示区域看到，这一点，对应横着这条 seq1 的位置 153 开始的这一段，同时对应竖着这条 seq1 的位置 11 开 始的这一段。为什么这一点对应的是一段呢？因为我们这里选的单元长度是 15，也就是一 次比较 15 个字母。从这里也可以看出，如果把 seq1 的前半段和后半段重合起来的话，它们是完全一样的序列。  </p>
<p>​    图 1 右边给出了打点所用的参数设置。按照选定的替换计分矩阵和单元长度计算，比较 所能打出的最高分是 165 分，最低分是-60 分。默认的颜色方案是灰度从 0%到 100%。也就 是最高分 165 分的点具有 100%的灰度，即纯白色；最低分-60 分具有 0%的灰度，即纯黑色。参数下面的图给出了各个分值的点的个数。横坐标是分值，从-60 到 165，纵坐标是得某一分值的点的个数。我们可以看到绝大多数点的分值都是较低的，也就是绝大多数位置的比较 结果都是不相似的。只有少数对角线上的比较才是高分值的点，因为这些位置对应的是相似 的区域。这个情况反映在打点图上就是，绝大多数点都是深色的，只有少数点是浅色的，这 些浅色的点位于主对角线和两条对称的次对角线上。</p>
<p>​    这里我们可以通过调整灰度条，来屏蔽大多数低分值的点，让他们统统变成黑色背景， 并且强化高分值的点，让他们以纯白色突出显示出来（图 2）。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668045793136.png" alt="1668045793136"></p>
<h2 id="序列比对-动态规划法"><a href="#序列比对-动态规划法" class="headerlink" title="序列比对-动态规划法"></a>序列比对-动态规划法</h2><h3 id="双序列全局比对"><a href="#双序列全局比对" class="headerlink" title="双序列全局比对"></a>双序列全局比对</h3><p>​    经典的全局比对算法是 <strong>Needleman-Wunsch 算法</strong>。1970 年，Needleman 和 Wunsch 首先将<strong>动态规划</strong>法应用于两条序列的全局比对，后来这个算法就称为 Needleman-Wunsch 算法。今天，所有比对软件使用的算法都是从这个经典算法衍生出来的。  </p>
<p>​    我们用 Needleman-Wunsch 算法为序列 p 和序列 q 创建全局比对。输入值除了两条序列 之外，还要有<strong>替换计分矩阵</strong>以确定不同字母间的相似度得分，以及空位罚分（图 1）。空位 罚分就是当字母对空位的时候应该得几分。我们还是希望一致或相似的字母尽可能的对在一 起，字母对空位的情况和不相似的字母对在一起的情况一样，都不是我们希望的，还是少出 现为好，所以通常字母对空位会得到一个负分，这个负分就叫做<strong>空位罚分</strong>。这里我们让空位罚分，也就是 gap 分值为-5 分。在比对中没有空位对空位的情况。输入值就是这些。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046097925.png" alt="1668046097925"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046123952.png" alt="1668046123952"></p>
<p>​    接下来我们要创建一个得分矩阵（图 2-1），并根据公式（图 2-2）把得分矩阵填满。填 满后全局比对就会跃然于纸上。得分矩阵的第一行是序列 p，第一列是序列 q，这一步和打点法很像。不过要注意，p 和 q 的前面各留一个空列和一个空行，也就是第 0 列和第 0 行。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046208548.png" alt="1668046208548"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046444856.png" alt="1668046444856"></p>
<p>​    按照上面的公式，将整个得分矩阵填满。这时，我们再回过头来看一下第一行和第一列 （图 6）。其实，第一行的每一个值都是从左边的格加 gap 来的。所以我们给它们补上向左 的箭头。第一列的每一个值都是从上边的格加 gap 来的。所以我们给它们补上向上的箭头。 至此，所有的箭头和数值就都填好了。填满之后，<strong>右下角的分数就是整个全局比对最终的得 分</strong>。然后从这个位置开始<strong>追溯箭头一直到左上角的零</strong>，并且把这些箭头标记出来。</p>
<p>​    图 6 中标出的红色箭头是写出全局比对的唯一依据。追溯箭头是从右下角到左上角，但是写全局比对是从左上角开始，如果是<strong>斜箭头则是字符对字符，如果是水平箭头或垂直箭头 则是字符对空位，箭头指着的序列为空位</strong>。我们看第一个是斜箭头，字母对字母，就是 A 对 A，第二个是水平箭头，字母对空位，箭头指着的序列是空位，也就是 C 对空位。然后 斜箭头 G 对 A，斜箭头 T 对 T，斜箭头 C 对 C，一直写到右下角，全局比对就出现了（图 7）。 唯一的一个空位插在序列 q 的 A 与 A 之间，这样最终的比对得分最高。不信的话可以试试， 其他任何一种插入空位的比对结果，得分都不会超过 21 分。因为我们在得分矩阵的创建过 程中，每一步都是在上一步最优的情况下得出的当前最优结果。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046572690.png" alt="1668046572690"></p>
<h3 id="双序列局部对比"><a href="#双序列局部对比" class="headerlink" title="双序列局部对比"></a>双序列局部对比</h3><p>​    在看局部比对的算法之前，先看看序列 a 和序列 b 这两条序列，谁和序列 c 更相似一些 （图 1）。AC 做全局比对的得分是-46 分。BC 做全局比对的得分是 8 分。单从分数上看，b 跟 c 更相似，因为得分高。但是如果只看红框里这部分，a 和 c 显然比 b 和 c 对得要好。如 果只比较红框里这部分的话，a 和 c 的得分是 24 分，比 b 和 c 的得分要高。这个例子告诉我 们，对于像这样一长一短的两条序列，比较局部比比较全长更有意义。这就是为什么除了全局比对，还有局部比对。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046680161.png" alt="1668046680161"></p>
<p>​    局部比对的算法和全局比对很相似，只是在选最大值时通过增加了第四个元素“0”，来 达到比对局部的效果。序列 p 和序列 q，一长一短，其他输入值跟全局比对的一样（图 2）。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046702735.png" alt="1668046702735"></p>
<p>​    局部比对的计算公式在全局比对的基础上增加了第四个元素“0”。得分矩阵初始值仍是 0，但第一行和第一列与全局比对不同，全是 0（图 3）。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046728157.png" alt="1668046728157"></p>
<p>​    从 s(1,1)开始要选择四个值中的最大值。除了上面格 s(0,1)+gap=0+-5=-5，左边 格 s(1,0)+gap=0+-5=-5，斜上格 s(0,0)+w(1,1)=0+-3=-3，还有一个 0。max(-5,  -5,-3,0)=0。并且这个 0 既不是从上面格，也不是从左边格，以及斜上格三个方向来的， 而是来自于公式里增加的“0”，所以不用画箭头（图 4）。</p>
<p>​    s(1,4)的计算：上面格 s(0,4)+gap=0+-5=-5，左边格 s(1,3)+gap=4+-5=-1， 斜上格 s(0,3)+w(1,4)=0+0=0，还有一个 0。max(-5,-1,0,0)=0。这个 0 和 s(1,1) 的 0 是不一样的。这个 0 应该画上斜上的箭头（图 5），因为它可以来自公式中的 0，也可 以来自斜上格。而 s(1,1)的 0 没有箭头因为它只来自公式中的 0。两种情况虽然都是 0， 但来源不同，一定要通过箭头标识清楚。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046866779.png" alt="1668046866779"></p>
<p>​    按照公式，填充满整个得分矩阵（图 6）。与全局比对不同，<strong>局部比对的得分不是在右下角，而是在整个矩阵中找最大值</strong>。这个最大值才是局部比对的最终得分，他可能出现在任何一个位置。这次箭头追溯也不是从右下角到左上角，而是从<strong>刚刚找到的最大值开始追溯到没有箭头为止</strong>。追溯箭头终止的位置也可以是得分矩阵中的任何一个位置。 </p>
<p>​    最后根据标记好的箭头写出比对结果（图 7）。从左上到右下标记的红色箭头依次是： 斜箭头字母对字母，C 对 C；斜箭头字母对字母，G 对 G。相比这两条序列的全局比对结果， 两端的空位在局部比对中就全部被忽略掉了。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668046946332.png" alt="1668046946332"></p>
<h2 id="一致度和相似度-1"><a href="#一致度和相似度-1" class="headerlink" title="一致度和相似度"></a>一致度和相似度</h2><p>​    我们回过头来，再看看一致度和相似度的计算。之前我们卡在长度不一样的两个序列如 何计算一致度和相似度这个问题上。现在学会了序列比对，我们就可以先给这两条长度不同 的序列做全局比对，然后计算全局比对中一致字符的个数和相似字符的个数，再除以全局比对的长度，就可以得到它们的一致度和相似度了。比如下面这两条序列：  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668059549705.png" alt="1668059549705"></p>
<p>首先做出它们的全局比对，比对中一致字符的个数是 4 个，全局比对长度 6，一致度=67%。 相似字符个数 1，相似度就是(4+1)/6=83%。 </p>
<p>​    由此，我们必须回过头来，把长度相同的两个序列计算一致度和相似度的方法重新规范 一下。尽管长度相同，但是做出的<strong>全局比对的长度并不一定等于序列的长度</strong>，比如下面这两条序列：  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668059716946.png" alt="1668059716946"></p>
<p>上下各加入一个空位，全局比对的长度就不等于序列的长度了。所以不管两条序列长度是否相同，都要先对它们做全局比对。让两条序列先以最优的方式比对起来，再从全局比对中数 出一致字符和相似字符的个数，除以全局比对的长度，来得到它们的一致度和相似度。 </p>
<h2 id="在线双序列比对工具"><a href="#在线双序列比对工具" class="headerlink" title="在线双序列比对工具"></a>在线双序列比对工具</h2><h3 id="EMBL全局双序列比对工具"><a href="#EMBL全局双序列比对工具" class="headerlink" title="EMBL全局双序列比对工具"></a>EMBL全局双序列比对工具</h3><p>​    目前，使用率最高的是 EMBL 网 站的双序列比对工具（<a href="http://www.ebi.ac.uk/Tools/psa%EF%BC%89%E3%80%82%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%B8%8A%E9%9D%A2%E6%9C%89%E5%85%A8%E5%B1%80%E6%AF%94%E5%AF%B9%E5%B7%A5%E5%85%B7%E3%80%81">http://www.ebi.ac.uk/Tools/psa）。打开页面，上面有全局比对工具、</a> 局部比对工具、还有基因组比对工具。</p>
<p>​    首先看全局比对中的蛋白质序列比对工具（图 1）。输入值非常简单，把要比较的两条 蛋白质序列贴在输入框里或者上传。可以使用示例文件 global.fasta 里面的两条序列。如果想 要进一步设置比对的参数，可以点 More options。从这里可以选择使用哪种替换记分矩阵。 按照之前讲过的原则，选择 PAM 矩阵或 BLOSUM 矩阵。如果实在不知道选哪个矩阵，就 闭着眼睛选 BLOSUME62 吧！下拉菜单里默认选的就是BLOSUM62。除了选择替换记分矩 阵，这里还可以设置空位罚分，也就是 gap 的分值。这里实际上是让你选空位对字母的情况罚几分，所以显示的是正数，但在计算的过程中还是按照负数处理。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668059927886.png" alt="1668059927886"></p>
<p>​    计算机只需要用几秒钟的时间，就可以计算出结果（图 2）。在结果页面里，上部是比对使用的参数，以及得出的<strong>序列比对的长度、一致度、相似度、空位比例和比对得分</strong>。下部就是序列比对。在序列比对里，左边是两条序列的名字，因为输入的是 FASTA 格式的序列， 所以程序自动识别出了序列的名字。右边的序列比对分 3 行。上下两行是序列，里面插入了 许多的空位。中间这行标记出了哪些位置上下两个字母是完全相同的，用<strong>竖线</strong>表示。<strong>上下两个字母相似，用双点表示。上下不相似，用单点表示</strong>。字母对空位的情况，用空格表示。</p>
<p>​    这样，我们只要数数比对结果里竖线的个数（40 个），再除以比对的长度（196 个），就可计算 出一致度。再用竖线的个数加上双点的个数（40+29=69 个），除以比对长度（196 个），就是相似度。整个比对里一共插入了 65 个空位，占整个比对长度的 33%。序列两边的数是这一行中的字母在序列中的位置数，而不是这一行的长度。比如第二行是 seq1 的第 49 个字母 到第 97 个字母，是 seq2 的第 27 个字母到第 75 个字母。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668060665974.png" alt="1668060665974"></p>
<h3 id="EMBL-局部双序列比对工具"><a href="#EMBL-局部双序列比对工具" class="headerlink" title="EMBL 局部双序列比对工具"></a><strong>EMBL 局部双序列比对工具</strong></h3><p>​    EMBL 的局部双序列比对工具可以选择经典的 Smith-Waterman 算法。仍然比对蛋白质序 列。输入的序列在示例文件 local.fasta 里面。More options 里面的参数设置和全局比对是一样 的。在这个例子里，我们保持所有参数都为默认值，点提交。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668060778365.png" alt="1668060778365"></p>
<p>​    从比对结果可以看出（图 2），只有中间黑色的相似的部分出现在比对结果中了，两头 红色的不相似的部分被忽略掉了。也就是只返回了局部最相似，得分最高的片段的比对结果。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061385996.png" alt="1668061385996"></p>
<p>​    用这两条序列再做一次全局比对（图 3）。从两次的比对结果可以更清楚的看出，全局比对里前面和后面对得不好的部分在局部比对里就都被忽略了</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061413235.png" alt="1668061413235"></p>
<p>​    除了一长一短两条序列适合做局部比对，有的时候两条差不多长的序列也可以做局部比对，<strong>以找出它们最相似的局部片段</strong>。比如示例文件 local2.fasta 里面的两条序列长度差不多。我们做局部比对看看结果如（图 4）。为了让相似的部分突出出来，我们把 gap 都调大，gap开头调到 10，gap 延长调到 5，提交。  </p>
<p>​    比对结果中，只有黑色的相似的部分出现在最终的比对结果中了，两头红色的不相似的 、部分全部被忽略了（图 5）。 </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061515140.png" alt="1668061515140"></p>
<p>​    如果给这两条序列做全局比对的话，会发现，绝大部分位置对得都很差，只有中间这一 段对的还不错（图 6）。所以，有时候两条序列并不同源，它们只是有一个功能相似的区域，这时用局部比对我们就能很快找到这一区域在两条序列中的位置。但是如果做全局比对的话，结果就不如局部比对明显了。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061599727.png" alt="1668061599727"></p>
<h3 id="Gap-的类型及分值设置"><a href="#Gap-的类型及分值设置" class="headerlink" title="Gap 的类型及分值设置"></a>Gap 的类型及分值设置</h3><p>​    EMBL 比对工具将 gap 分为两种，一种叫“gap 开头（GAP OPEN）”，另一种叫“gap 延长（GAP EXTEND）”（图 1）。gap 开头就是连续的一串 gap 里面打头的那一个，可以当 它是队长。gap 延长就是剩下的那些 gap，也就是队长后面跟着的小兵。这一串里，第一个 gap 是 gap 开头，后面的都是 gap 延长。单独的一个 gap 按 gap 开头算。</p>
<p>​    gap 开头和 gap 延长 可以分别定义不同的罚分。<strong>默认情况下，gap 开头罚分多，gap 延长罚分少</strong>。全局比对的例子里我们就是用这种搭配组合方案做出的比对。这次我们反过来试试，<strong>让 gap 开头罚分少， 让 gap 延长罚分多</strong>。比如 gap 开头选罚 1 分，gap 延长选罚 5 分，其他参数不变，再作一次看看结果发生了什么变化。 </p>
<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061742608.png" alt="1668061742608">

<p>​    <strong>当 gap 开头小，gap 延长大的时候，做出来的比对里面，gap 很分散</strong>，极少有连续长串 的 gap 出现（图 2-A）。开头的一串 gap 是个例外，因为 seq2 太短， seq1 的这一段只能跟 gap 相对。其他部分的 gap 都是分散出现的。这和我们第一次做出来的比对结果是截然不同的（图 2-B）。在第一次做的结果里，也就是 <strong>gap 开头大，gap 延长小的时候，gap 很集中</strong>，有很多成 长串出现的 gap。</p>
<p>​    大家可以想想其中的奥妙。当 gap 开头大，gap 延长小的时候，说明在连续的字母里插入一个 gap 打开一个缺口要付出很大的代价，因为 gap 开头罚分大。但是这个 缺口一旦打开了，也就是一旦有了第一个 gap，后面再接更多的 gap 就容易了，因为 gap 延 长罚分小。所以这种情况下，gap 都集中连成长串出现。</p>
<p>​    而反过来，当 gap 开头小，gap 延长大的时候，说明在连续的字母里插入一个 gap 打开一个缺口很容易，并不需要付出太大代价，因为 gap 开头罚分小。但是想在第一个 gap 后面再接一个 gap 就难了，因为 gap 延长罚分大。所以这种情况下很难有长串的 gap 出现，gap每延长一个都要付出巨大代价。因此在第二次我们做的结果里（图 2-A）都是分散的 gap。除了开头一段因两条序列长短不同而不得已出现的长串 gap 外，没有其他的长串 gap 了。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668061932050.png" alt="1668061932050"></p>
<p>​    这就是说，通过调整 gap 开头和 gap 延长，我们可以把序列比对做成我们期待的样子。举两个例子，看看应该怎样调整 gap 最合理。第一个例子，你知道要比对的两条序列很相似，是同源序列，所以它们的结构和功能也应该都差不多。其中一条序列的结构已知，另一条未知。你想把它们很好的比对在一起，用其中已知结构的序列做模板，来预测另一个序列的结构。这时候我们期待得到的是 gap 分散的比对结果还是 gap 集中的呢？另一例子，你知道要比对的两条序列绝大部分区域都很相似，但是其中一条序列的一个功能区在另一条序列中是缺失的。你想要通过序列比对把这个功能区找出来。这时候我们要怎么设置 gap 开头和 gap延长呢？这两个例子告诉我们，在实际应用中，需要根据不同的情况选取不同的 gap 罚分，以满足不同的生物学意义。如果你对结果没有什么预期，那就请保持默认的参数。</p>
<h3 id="其他在线双序列比对工具"><a href="#其他在线双序列比对工具" class="headerlink" title="其他在线双序列比对工具"></a>其他在线双序列比对工具</h3><p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668236467003.png" alt="1668236467003"></p>
<table>
<thead>
<tr>
<th align="center">软件名</th>
<th align="center">比对类型</th>
<th align="center">网址链接</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EMBL</td>
<td align="center">Global/Local</td>
<td align="center">http:/ / www. ebi.ac.uk/Tools/psa</td>
</tr>
<tr>
<td align="center">PIR</td>
<td align="center">Global</td>
<td align="center"><a href="http://pir.georgetown.edu/pirwww/search/pairwise.shtml">http://pir.georgetown.edu/pirwww/search/pairwise.shtml</a></td>
</tr>
<tr>
<td align="center">Lalign</td>
<td align="center">Global/Local</td>
<td align="center"><a href="http://www.ch.embnet.org/software/LALIGNform.html">http://www.ch.embnet.org/software/LALIGNform.html</a></td>
</tr>
<tr>
<td align="center">LAGAN</td>
<td align="center">Global</td>
<td align="center"><a href="http://agan.stanford.edu/laganweb/index.shtml">http://agan.stanford.edu/laganweb/index.shtml</a></td>
</tr>
<tr>
<td align="center">AligmMe</td>
<td align="center">Alignment of Membrane Proteins</td>
<td align="center"><a href="http://bioinfo.mpg.de/AlignMe/AlignMe.html">http://bioinfo.mpg.de/AlignMe/AlignMe.html</a></td>
</tr>
<tr>
<td align="center">MCALIGN</td>
<td align="center">Alignment fo non-coding DNA sequences</td>
<td align="center"><a href="http://homepages.ed.ac.uk/eang33/mcalign/mcinstructions.html">http://homepages.ed.ac.uk/eang33/mcalign/mcinstructions.html</a></td>
</tr>
<tr>
<td align="center">Biotools</td>
<td align="center">Global/Local</td>
<td align="center"><a href="http://1.51.215.28/~gongj/biotools">http://1.51.215.28/~gongj/biotools</a></td>
</tr>
</tbody></table>
<h2 id="BLAST搜索"><a href="#BLAST搜索" class="headerlink" title="BLAST搜索"></a>BLAST搜索</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    我们已经学会如何做双序列比对，那可不可以拿一条序列和数据库中的每条序列逐一进行双序列比对，通过这种方法来找相似呢？这确实是一个办法。这样我们只要根据比对后得出的相似度排序，就可以找到最相似的那条序列了。但是，这种方法因计算耗时过长，只是理论上可行而已。之前我们用 EMBL 的双序列比对工具做全局比对，虽然很快就出结果了， 但至少也要经历一两秒钟的时间。而数据库中有几百万条序列，全部比对一遍，耗时太长。因此，我们需要<strong>快速的数据库相似性搜索工具</strong>。目前世界上广泛使用的就BLAST。它可以在尽可能准确的前提下，快速的从数据库中找到跟某一条序列相似的序列。 </p>
<p>​    BLAST 是 Basic Local Alignment Search Tool 的首字母缩写，直译过来就是<strong>基本局部比对搜索工具</strong>。    </p>
<p>​    BLAST 的<strong>基本原理</strong>很简单，要点是<strong>片段对</strong>的概念。所谓片段对是指两个给定序列中的一对子序列，它们的长度相等，且可以形成无空位的完全匹配。(图 1-A )中方框里的就是两个片段对。BLAST 从头至尾将两条序列扫描一遍并找出所有片段对，并在允许的阈值范围内对片段对进行延伸，最终找出高分值片段对（high-scoring pairs, HSPs）（图 1-B）。这样的<strong>计算复杂度是 n 的一次方</strong>（n 是序列的长度）。如果做双序列比对话需要构建一个 n 乘以 n 的表格，计算复杂度是 n 的二次方。所以找高分值片段对比做双序列比对节省了大量的时间，当然，前提是牺牲了一定的准确度。  </p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668240861872.png" alt="1668240861872"></p>
<h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>（按搜索内容分类）</p>
<p>​    BLAST 实际上是综合在一起的一组工具的统称，它不仅可用于直接对蛋白质序列数据库和核酸序列数据库进行搜索，而且可以将待搜索的核酸序列翻译成蛋白质序列后再进行搜 索，或者反之，以提高搜索效率。因此 BLAST 可以分为 <strong>BLASTp，BLASTn，BLASTx，tBLASTn 和 tBLASTx</strong>。  </p>
<ul>
<li>BLASTp 也就是用蛋白质序列搜索蛋白质序列数据库</li>
<li>BLASTn 是用核酸序列搜索核酸序列数据库</li>
<li>BLASTx 是将核酸序列<strong>按 6 条链</strong>翻译成蛋白质序列后搜索蛋白质序列数据库。<ul>
<li><strong>为什么是按 6 条链翻译？</strong>在无法得知翻译起始位点在情况下，翻译可能是从第1个碱基开始，三个三个的往后翻译，也可能是从第 2 个碱基开始，也可能从第 3 个碱基开始。另外还有可能是从 这条链的互补链上开始，这样又有3个可能的开始位置，加起来一共会产生 6 条可能被翻译出来的蛋白质序列。这 6 条中有些是真实存在的，有些是不存在，但是谁真谁假我们无从知晓，所以 6 条序列都要到数据库中去搜索一下试试。</li>
<li>既然是核酸序列，<strong>为什么不做 BLASTn 直接到核酸数据库里去搜索</strong>，而是要到蛋白质数据库里搜索呢？我们说这样做是有意义的，比如，从核酸序列数据库里找不到跟你手里这条核酸序列相似的序列，或 找到了相似的序列但这些找到的序列无法提供有意义的注释信息。这时，就可以去蛋白质数 据库试试，看看这条核酸序列的翻译产物能不能从蛋白质数据库里找到相似的序列以及有意 义的注释信息。或者说，你不是想找跟你这条核酸序列相似的核酸序列，而是想找跟你这条 核酸序列编码蛋白质相似的蛋白质序列，这时就要做 BLASTx。 </li>
</ul>
</li>
<li>tBLASTn 是用蛋白质序列 搜核酸序列数据库，核酸数据库中的核酸序列要按 6 条链翻译成蛋白质序列后再被搜索<ul>
<li>核酸数据库里不是已经注释了某条核酸序列能够翻译成什么蛋白质序列吗？为 什么还要把这些序列可能翻译出来的 6 条蛋白质序列都翻译出来搜索呢？我们说，你看到的 是已经注释的，还有没注释的呢！就算是已经注释的，你看到的也只是已经研究出来的成果， 还有没研究出来的呢！别忘了，基因可以重叠，注释上说某段 DNA 序列可以编码某个蛋白，但是可能某个未被发现的基因也用到了这段 DNA 序列。而你要搜索的这个蛋白质序列可能 刚好就是这个未被发现的基因的翻译产物。这样就必须把核酸序列所有可能的翻译产物都翻译出来，才能搜索得到。  </li>
</ul>
</li>
<li> tBLASTx 是将核酸序列按 6 条链翻译成蛋白质序列后 搜索核酸序列数据库，核酸数据库中的所有核酸序列也要按 6 条链翻译成的蛋白质序列后再 被搜索。这样用 BLASTn 搜不着的，用 tBLASTx 就能搜着了。  </li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668241911377.png" alt="1668241911377"></p>
<h3 id="BLASTp"><a href="#BLASTp" class="headerlink" title="BLASTp"></a>BLASTp</h3><p><strong><a href="http://www.ncbi.nlm.nih.gov/">http://www.ncbi.nlm.nih.gov/</a></strong></p>
<p>1&gt; 在 BLASTp 输入界面里（图 1）：</p>
<ul>
<li>1）输入待搜索的蛋白质序列，这条序列可以在示例文件 blast.fasta 里面找到</li>
<li>2）指定搜索跟输入序列哪部分相似的序列，如果空着就是全长搜索</li>
<li>3）给搜索任务起一个名字，如果输入的是 FASTA 格式的序列，那么在输入框里面点一下，序列的名字就会被自动识别出来。</li>
<li>4）如果在 Align two or more sequences 前面打勾的话，可以同时提交多个 BLAST 任务。 </li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668242455679.png" alt="1668242455679"></p>
<p>2&gt; 在输入界面的下部（图 2）</p>
<ul>
<li>1）选择被搜索的数据库</li>
<li>2）Organism 可以把搜索范围限定在某一特定物种内， 或者排除某一物种</li>
<li>3）在算法选择这一栏里，有之前提到的三种不同的 BLAST 算法，标准BLAST，PSI-BLAST 和 PHI-BLAST</li>
</ul>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668242652994.png" alt="1668242652994"></p>
<p>3&gt; 图形化搜索结果部分</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668242912374.png" alt="1668242912374"></p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668242929689.png" alt="1668242929689"></p>
<h3 id="PSI-BLAST"><a href="#PSI-BLAST" class="headerlink" title="PSI-BLAST"></a>PSI-BLAST</h3><p>​    为了提高速度，标准 BLAST 牺牲了一定的准确度，牺牲掉的准确度对高度相似的序列， 也就是亲缘关系近的序列构成不了威胁，不会把它们落掉，但是对于那些只有一点点相似， 也就是远源的序列，就有点麻烦了。它们很可能被落掉而没有被 BLAST 发现。 </p>
<pre><code> 要解决这个问题，可以用 **PSI-BLAST**。PSI-BLAST 可以搜罗出一个庞大的蛋白质家族， 当然也包括标准 BLAST 不小心漏掉的那些远房亲戚。换言之，标准 BLAST 找到了直接认识的朋友，但朋友的朋友都丢掉了。PSI 是 **Position-Specific Iterated** 首字母缩写，中文是**位点特异性迭代**。
</code></pre>
<p>​    PSI-BLAST 的特色是搜完一遍再搜一遍，且从第二次搜索开始，每次搜索前都利用上一次搜索到的结果创建一个位置特异权重矩阵以扩大本次搜索的范围。如此反复直至没有新的结果产生为止。<strong>位置特异权重矩</strong>阵（Position-Specific Scoring Matrix，简称 PSSM）是 以矩阵的形式，统计一个多序列比对中，每个位置上不同残基出现的百分比。假设 A 的朋 友只有 B，B 朋友除 A 外还有 C。如果输入序列的第一个位置是 A，那么在第一轮没有 PSSM 辅助的情况下，只有第一个位置是 A 或 B 的序列被找到了。它们是图 1-A 中所示的四条序列。根据这四条序列创建的 PSSM（图 1-B）得知，第一个位置可以是 A，也可以是 B，那么在第二轮搜索中，除了 A 的朋友 B 之外，B 的朋友 C 也可以出现在第一个位置了。这样如此反复，我们就可以找到朋友的朋友了。</p>
<p><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243096395.png" alt="1668243096395"></p>
<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243216063.png" alt="1668243216063" style="zoom: 67%;">

<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243227679.png" alt="1668243227679" style="zoom: 67%;">

<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243240064.png" alt="1668243240064" style="zoom:67%;">



<h3 id="PHI-BLAST"><a href="#PHI-BLAST" class="headerlink" title="PHI-BLAST"></a>PHI-BLAST</h3><p>​    PHI-BLAST 和 PSI-BLAST 不同，PSI-BLAST 是撒大网搜索，而 PHI-BLAST 则是<strong>精准搜索</strong>。PHI 是 Pattern-Hit Initiated 首字母缩写，中文是<strong>模式识别</strong>。PHI-BLAST 能找到与输入序列相似的并符合某种特征模式的蛋白质序列。模式 Pattern 是对特征的描述。</p>
<p>​    特定模式可通过正则表达式来表述。所谓正则表达式就是这句话的一个简约的规范性字 符书写法。发生 N 糖基化位点的序列符合的特定模式翻译成正则表达式为 N{P}[ST]{P}。 其中，N 是天冬酰胺，P 是脯氨酸，S 是丝氨酸，T 是苏氨酸。{}代表除大括号里的氨基酸 以外的任意氨基酸，[]代表中括号中的任意一个氨基酸。得知这些符号的含义之后，这个 正则表达式就很容易读懂了。PHI-BLAST 可以根据给入的正则表达式对搜索到的相似序列进行模式匹配，符合正则表达式的才会被作为结果输出。 </p>
<p>​    熟悉一下正则表达式，{}代表除什么以外，[]代表其中之一，x 代表任意字 母，(3,7)代表 3 到 7 个某字符。那么正则表达式{L}GEx[GAS][LIVM]x(3,7)的意思是， 除 L 以外的任意一个字母，紧接 G，再紧接 E，再接一个任意字符，之后是 GAS 中的任意 一个，再接 LIVM 中的任意一个，最后再接 3 到 7 个任意字符。</p>
<p>​    在 NCBI BLAST 工具的输入页面，当算法选择了 PHI-BLAST 之后，会自动出现模式输 入框（图 1）。输入正则表达式 S[IVFL]TPS(2)（含义为：一个 S 后面紧接 IVFL 中的任意 一个字母，再接 T，再接 P，再接两个 S）。这次搜索找到的相似序列中，只有符合该模式的才会被作为结果返回。 </p>
<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243596930.png" alt="1668243596930" style="zoom:67%;">

<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243608075.png" alt="1668243608075" style="zoom:67%;">



<h3 id="SMART-BLAST"><a href="#SMART-BLAST" class="headerlink" title="SMART-BLAST"></a>SMART-BLAST</h3><img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243698142.png" alt="1668243698142" style="zoom:67%;">

<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243709460.png" alt="1668243709460" style="zoom:67%;">

<img src="/2022/11/10/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0/1668243748950.png" alt="1668243748950" style="zoom:67%;">

<table>
<thead>
<tr>
<th>位置</th>
<th>服务器</th>
<th>网址谅解</th>
</tr>
</thead>
<tbody><tr>
<td>USA</td>
<td>NCBI</td>
<td><a href="http://www.ncbi.nlm.nih.gov/BLAST">http://www.ncbi.nlm.nih.gov/BLAST</a></td>
</tr>
<tr>
<td>Europe</td>
<td>ExPASys</td>
<td><a href="http://web.expasy.org/blast">http://web.expasy.org/blast</a></td>
</tr>
<tr>
<td>Europe</td>
<td>Uniprot</td>
<td><a href="http://www.uniprot.org/blast/">http://www.uniprot.org/blast/</a></td>
</tr>
<tr>
<td>Japan</td>
<td>DDBJ</td>
<td><a href="http://blast.ddbj.nig.ac.jp/">http://blast.ddbj.nig.ac.jp</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>《生物信息学》</category>
      </categories>
      <tags>
        <tag>生物信息学</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记</title>
    <url>/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668234025873.png" alt="1668234025873"></p>
<h3 id="类型检验"><a href="#类型检验" class="headerlink" title="类型检验"></a>类型检验</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = torch.randn(<span class="number">2</span>, <span class="number">3</span>)   <span class="comment"># 正态分布随机初始化2*3矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.<span class="built_in">type</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))  <span class="comment"># python自带type()函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合法化检验</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(data, torch.FloatTensor))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(data, torch.cuda.FloatTensor))</span><br><span class="line">data = data.cuda()  <span class="comment"># 将数据搬运到GPU上面</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(data, torch.cuda.FloatTensor))</span><br></pre></td></tr></table></figure>



<h3 id="张量和维度"><a href="#张量和维度" class="headerlink" title="张量和维度"></a>张量和维度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标量 Dimension 0 (0阶张量); 如Loss</span></span><br><span class="line">data = torch.tensor(<span class="number">1.</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape:&quot;</span>, data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size():&quot;</span>, data.size())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.ndimension():&quot;</span>, data.ndimension())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量 Dimension 1 (1阶张量); 如Bias，Linear Input</span></span><br><span class="line">data = torch.tensor([<span class="number">1.1</span>])</span><br><span class="line">data = torch.tensor([<span class="number">1.1</span>, <span class="number">2.2</span>])</span><br><span class="line"><span class="comment"># 随机初始化生成一维的长度为1、2的向量</span></span><br><span class="line">data = torch.FloatTensor(<span class="number">1</span>)</span><br><span class="line">data = torch.FloatTensor(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 用numpy初始化</span></span><br><span class="line">data = torch.from_numpy(np.ones(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape:&quot;</span>, data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size():&quot;</span>, data.size())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.ndimension():&quot;</span>, data.ndimension())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵 Dimension 2 (2阶张量); 如 Linear Input Batch，第一维度表示每个batch的样本数</span></span><br><span class="line">data = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape:&quot;</span>, data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape[0]:&quot;</span>, data.shape[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 取shape的第0个元素，即张量第一维的元素个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size(0):&quot;</span>, data.size(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size(1):&quot;</span>, data.size(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.ndimension():&quot;</span>, data.ndimension())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dimension 3 （3阶张量）; 如RNN Input Batch</span></span><br><span class="line">data = torch.randn(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape:&quot;</span>, data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size():&quot;</span>, data.size())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.ndimension():&quot;</span>, data.ndimension())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dimension 4 （4阶张量）; 如CNN</span></span><br><span class="line">data = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">28</span>)    <span class="comment"># 2张照片，3个通道，28 * 28个像素</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.shape:&quot;</span>, data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.size():&quot;</span>, data.size())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data.ndimension():&quot;</span>, data.ndimension())</span><br><span class="line"></span><br><span class="line"><span class="comment"># number of element</span></span><br><span class="line"><span class="built_in">print</span>(data.numel()) <span class="comment"># 2*3*28*28 元素个数</span></span><br><span class="line"><span class="built_in">print</span>(data.dim())	<span class="comment"># 张量维度</span></span><br></pre></td></tr></table></figure>



<h2 id="创建Tensor"><a href="#创建Tensor" class="headerlink" title="创建Tensor"></a>创建Tensor</h2><h3 id="通过list创建"><a href="#通过list创建" class="headerlink" title="通过list创建"></a>通过list创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过list创建tensor</span></span><br><span class="line">data = torch.tensor([<span class="number">2.</span>, <span class="number">3.2</span>])</span><br><span class="line">data = torch.FloatTensor([<span class="number">2.</span>, <span class="number">3.2</span>]) <span class="comment"># 尽量少用，容易混淆</span></span><br><span class="line">data = torch.tensor([[<span class="number">2.</span>, <span class="number">3.2</span>], [<span class="number">1.</span>, <span class="number">0.5</span>]])</span><br></pre></td></tr></table></figure>



<h3 id="通过numpy创建"><a href="#通过numpy创建" class="headerlink" title="通过numpy创建"></a>通过numpy创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过numpy创建tensor</span></span><br><span class="line">a = np.array([<span class="number">2</span>, <span class="number">3.3</span>])</span><br><span class="line">data = torch.from_numpy(a)</span><br><span class="line">a = np.ones([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">data = torch.from_numpy(a)</span><br></pre></td></tr></table></figure>



<h3 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建未初始化的tensor</span></span><br><span class="line">data = torch.empty(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">data = torch.FloatTensor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">data = torch.IntTensor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>



<h3 id="set-default-tensor-type"><a href="#set-default-tensor-type" class="headerlink" title="set_default_tensor_type()"></a>set_default_tensor_type()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置默认tensor类型</span></span><br><span class="line"><span class="built_in">print</span>(torch.tensor([<span class="number">1.2</span>, <span class="number">3</span>]).<span class="built_in">type</span>())    <span class="comment"># 默认是FloatTensor</span></span><br><span class="line">torch.set_default_tensor_type( torch.DoubleTensor)</span><br><span class="line"><span class="built_in">print</span>(torch.tensor([<span class="number">1.2</span>, <span class="number">3</span>]).<span class="built_in">type</span>())</span><br></pre></td></tr></table></figure>



<h3 id="rand-randn"><a href="#rand-randn" class="headerlink" title="rand/randn()"></a>rand/randn()</h3><ul>
<li><p>rand/rand_like; randint/randint_like</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rand/rand_like; randint/randint_like</span></span><br><span class="line">a = torch.rand(<span class="number">3</span>, <span class="number">3</span>)     <span class="comment"># 在[0,1]之间均匀采样</span></span><br><span class="line">data = torch.rand_like(a)   <span class="comment"># 接受参数不在是shape而是一个tensor</span></span><br><span class="line">a = torch.randint(<span class="number">1</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">3</span>])    <span class="comment"># 在[1,10)之间均匀采样</span></span><br><span class="line">data = torch.randint_like(a, <span class="number">1</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>randn</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># randn</span></span><br><span class="line">data = torch.randn(<span class="number">3</span>, <span class="number">3</span>)    <span class="comment"># N(0,1)标准正态分布取样</span></span><br><span class="line">data = torch.normal(mean=<span class="number">3</span>, std=<span class="number">1</span>, size=(<span class="number">3</span>, <span class="number">3</span>))     <span class="comment"># N(3,1)正态分布取样</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 让每一个值服从不同的正态分布</span></span><br><span class="line">torch.normal(mean=torch.arange(<span class="number">4.</span>), std=torch.arange(<span class="number">1.</span>, <span class="number">0.6</span>, -<span class="number">0.1</span>)).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="full"><a href="#full" class="headerlink" title="full()"></a>full()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建初始化为同一个值的tensor</span></span><br><span class="line">data = torch.full([<span class="number">2</span>, <span class="number">3</span>], <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>



<h3 id="arange"><a href="#arange" class="headerlink" title="arange()"></a>arange()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建等差数列的tensor</span></span><br><span class="line">data = torch.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)   <span class="comment"># [0, 10)步幅为2</span></span><br><span class="line">data = torch.linspace(<span class="number">0</span>, <span class="number">10</span>, steps=<span class="number">11</span>) <span class="comment"># [0, 10]等分为11份</span></span><br><span class="line">data = torch.logspace(<span class="number">0</span>, -<span class="number">1</span>, steps=<span class="number">11</span>) <span class="comment"># 将[0,-1]11等分的值作为10的指数返回</span></span><br></pre></td></tr></table></figure>



<h3 id="zeros-ones-eye"><a href="#zeros-ones-eye" class="headerlink" title="zeros/ones/eye()"></a>zeros/ones/eye()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成全0/1，对角的tensor</span></span><br><span class="line">data = torch.zeros(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">data = torch.ones(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">data = torch.eye(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>



<h3 id="randperm"><a href="#randperm" class="headerlink" title="randperm()"></a>randperm()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机打算取值创建1维tensor</span></span><br><span class="line">data = torch.randperm(<span class="number">10</span>)   <span class="comment"># 不包含10</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 协同shuffle洗牌</span></span><br><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">b = torch.rand(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a, <span class="string">&#x27;\n&#x27;</span>, b)</span><br><span class="line">idx = torch.randperm(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(idx)</span><br><span class="line"><span class="built_in">print</span>(a[idx], <span class="string">&#x27;\n&#x27;</span>, b[idx])</span><br></pre></td></tr></table></figure>



<h2 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h2><h3 id="四个维度"><a href="#四个维度" class="headerlink" title="四个维度"></a>四个维度</h3><p>batch，channel，height，width</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>



<h4 id="基本切片"><a href="#基本切片" class="headerlink" title="基本切片"></a>基本切片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切片 select fisrt/last N</span></span><br><span class="line"><span class="built_in">print</span>(a[:<span class="number">2</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(a[:<span class="number">2</span>, :<span class="number">1</span>, :, :].shape)</span><br><span class="line"><span class="built_in">print</span>(a[:<span class="number">2</span>, -<span class="number">3</span>:, :, :].shape)</span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>], -<span class="number">3</span>:, :, :].shape)</span><br></pre></td></tr></table></figure>



<h3 id="隔点采样"><a href="#隔点采样" class="headerlink" title="隔点采样"></a>隔点采样</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 隔点采样 select by steps</span></span><br><span class="line"><span class="built_in">print</span>(a[:, :, <span class="number">0</span>:<span class="number">28</span>:<span class="number">2</span>, <span class="number">0</span>:<span class="number">28</span>:<span class="number">2</span>].shape)  <span class="comment"># 步长为2采样</span></span><br><span class="line"><span class="built_in">print</span>(a[:, :, ::<span class="number">2</span>, ::<span class="number">2</span>].shape)</span><br></pre></td></tr></table></figure>



<h3 id="a-index-select"><a href="#a-index-select" class="headerlink" title="a.index_select()"></a>a.index_select()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在某一维度上根据具体索引采样 index_select</span></span><br><span class="line"><span class="built_in">print</span>(a.index_select(<span class="number">0</span>, torch.tensor([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])).shape)  <span class="comment"># 在第0维度（batch）上采样[0,1,2]</span></span><br><span class="line"><span class="built_in">print</span>(a.index_select(<span class="number">1</span>, torch.tensor([<span class="number">0</span>, <span class="number">1</span>])).shape)  <span class="comment"># 在第1维度（channel）上采样[0,1]</span></span><br><span class="line"><span class="built_in">print</span>(a.index_select(<span class="number">2</span>, torch.arange(<span class="number">0</span>, <span class="number">28</span>, <span class="number">2</span>)).shape)</span><br></pre></td></tr></table></figure>



<h3 id="…"><a href="#…" class="headerlink" title="…"></a>…</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...表示任意多维度</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, ...])  <span class="comment"># 等价于a[0, :, :, :]和a[0]</span></span><br><span class="line"><span class="built_in">print</span>(a[..., :<span class="number">2</span>])  <span class="comment"># 等价于a[:, :, :, :2]</span></span><br></pre></td></tr></table></figure>



<h3 id="masked-select"><a href="#masked-select" class="headerlink" title="masked_select()"></a>masked_select()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据掩码取满足条件的值（会改变shape ）masked_select</span></span><br><span class="line">x = torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">mask = x.ge(<span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.masked_select(x, mask))</span><br></pre></td></tr></table></figure>



<h3 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打平后根据索引采样  take</span></span><br><span class="line">x = torch.tensor([[<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="built_in">print</span>(torch.take(x, torch.tensor([<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>])))</span><br></pre></td></tr></table></figure>



<h2 id="维度变换"><a href="#维度变换" class="headerlink" title="维度变换"></a>维度变换</h2><h3 id="view-reshape"><a href="#view-reshape" class="headerlink" title="view/reshape"></a>view/reshape</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"></span><br><span class="line">a = a.view(<span class="number">4</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"></span><br><span class="line">a = a.reshape(<span class="number">4</span> * <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br></pre></td></tr></table></figure>



<h3 id="unsqueeze-squeeze-拉伸-挤压"><a href="#unsqueeze-squeeze-拉伸-挤压" class="headerlink" title="unsqueeze/squeeze 拉伸/挤压"></a>unsqueeze/squeeze 拉伸/挤压</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># unsqueeze</span></span><br><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(a.unsqueeze(<span class="number">0</span>).shape)  <span class="comment"># 在第0维度前插入维度；索引范围[-5, 4]</span></span><br><span class="line"><span class="built_in">print</span>(a.unsqueeze(-<span class="number">1</span>).shape)  <span class="comment"># 在最后一个维度后插入维度</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># squeeze</span></span><br><span class="line">b = torch.rand(<span class="number">32</span>)</span><br><span class="line">b = b.unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">2</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line"><span class="built_in">print</span>(b.squeeze().shape)  <span class="comment"># 挤压所有size为1的维度</span></span><br><span class="line"><span class="built_in">print</span>(b.squeeze(<span class="number">0</span>).shape)</span><br><span class="line"><span class="built_in">print</span>(b.squeeze(<span class="number">1</span>).shape)  <span class="comment"># size不为1的维度不能被挤压</span></span><br></pre></td></tr></table></figure>



<h3 id="expand-repeat-扩张-重复"><a href="#expand-repeat-扩张-重复" class="headerlink" title="expand/repeat  扩张/重复"></a>expand/repeat  扩张/重复</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># expand(推荐使用)</span></span><br><span class="line">f = torch.rand(<span class="number">4</span>, <span class="number">32</span>, <span class="number">14</span>, <span class="number">14</span>)  <span class="comment"># [4, 32, 14, 14]</span></span><br><span class="line">b = torch.rand(<span class="number">32</span>)</span><br><span class="line">b = b.unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">2</span>).unsqueeze(<span class="number">0</span>)  <span class="comment"># [1, 32, 1, 1]</span></span><br><span class="line"><span class="comment"># 每个channel所有像素增加一个bias</span></span><br><span class="line">b = b.expand(<span class="number">4</span>, <span class="number">32</span>, <span class="number">14</span>, <span class="number">14</span>)  <span class="comment"># 维度一致；只有size为1的维度才能扩张成N</span></span><br><span class="line">b = b.expand(-<span class="number">1</span>, <span class="number">32</span>, -<span class="number">1</span>, -<span class="number">1</span>)  <span class="comment"># -1表示维度size不变</span></span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># repeat</span></span><br><span class="line">b = torch.rand(<span class="number">32</span>)</span><br><span class="line">b = b.unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">2</span>).unsqueeze(<span class="number">0</span>)  <span class="comment"># [1, 32, 1, 1]</span></span><br><span class="line">b = b.repeat(<span class="number">4</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">14</span>)  <span class="comment"># 参数指重复次数</span></span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br></pre></td></tr></table></figure>



<h3 id="转置-t"><a href="#转置-t" class="headerlink" title="转置 t"></a>转置 t</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4.转置 t</span></span><br><span class="line"><span class="comment"># 只适用于矩阵，dimension为2</span></span><br><span class="line">a = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(a.t())</span><br></pre></td></tr></table></figure>



<h3 id="transpose-维度交换"><a href="#transpose-维度交换" class="headerlink" title="transpose 维度交换"></a>transpose 维度交换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># transpose 维度交换</span></span><br><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">14</span>)</span><br><span class="line"><span class="comment"># [b,c,h,w] =&gt; [b,w,h,c] =&gt; [b, whc] =&gt; [b,c,w,h]  导致数据污染</span></span><br><span class="line">a1 = a.transpose(<span class="number">1</span>, <span class="number">3</span>).contiguous().view(<span class="number">4</span>, <span class="number">3</span> * <span class="number">14</span> * <span class="number">14</span>).view(<span class="number">4</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">14</span>)</span><br><span class="line"><span class="comment"># [b,c,h,w] =&gt; [b,w,h,c] =&gt; [b, whc] =&gt; [b,w,h,c]  =&gt; [b,c,w,h]</span></span><br><span class="line">a2 = a.transpose(<span class="number">1</span>, <span class="number">3</span>).contiguous().view(<span class="number">4</span>, <span class="number">3</span> * <span class="number">14</span> * <span class="number">14</span>).view(<span class="number">4</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">3</span>).transpose(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(a, a1)))</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(a, a2)))</span><br></pre></td></tr></table></figure>



<h3 id="permute-维度排列"><a href="#permute-维度排列" class="headerlink" title="permute 维度排列"></a>permute 维度排列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># permute 维度排列</span></span><br><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">7</span>)</span><br><span class="line">a1 = a.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a1.shape)</span><br></pre></td></tr></table></figure>



<h2 id="Broadcast机制"><a href="#Broadcast机制" class="headerlink" title="Broadcast机制"></a>Broadcast机制</h2><ul>
<li>broadcast广播/自动扩张机制<ul>
<li>expand</li>
<li>不需要复制数据</li>
</ul>
</li>
<li>主要思想<ul>
<li>在前面插入维度，使维度一致</li>
<li>扩张size为1的维度使得size一致</li>
</ul>
</li>
<li>为什么需要broadcast<ul>
<li>需求场景</li>
<li>减少内存消耗</li>
</ul>
</li>
<li>可以broadcast的情况<ul>
<li>从最后一维往前开始匹配</li>
<li>如果当前维度为1，扩展size到一致</li>
<li>如果往前没有维度，则插入一个维度，并扩展size到一致</li>
<li>其他情况都是不能broadcast的</li>
</ul>
</li>
</ul>
<p><img src="/2022/11/12/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1668428901290.png" alt="1668428901290"></p>
<h2 id="拼接与拆分"><a href="#拼接与拆分" class="headerlink" title="拼接与拆分"></a>拼接与拆分</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>要求除dim=d外，其他维度size一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a1 = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">a2 = torch.rand(<span class="number">5</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">b = torch.cat([a1, a2], dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(b.size())</span><br><span class="line"></span><br><span class="line">a1 = torch.rand(<span class="number">4</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">a2 = torch.rand(<span class="number">4</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">b = torch.cat([a1, a2], dim=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(b.size())</span><br><span class="line"></span><br><span class="line">a1 = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">a2 = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">b = torch.cat([a1, a2], dim=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(b.size())</span><br></pre></td></tr></table></figure>



<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>要求所有维度一致，会在dim=d维度前新增一个维度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a1 = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">a2 = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">b = torch.stack([a1, a2], dim=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(b.size())</span><br></pre></td></tr></table></figure>



<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>按照长度拆分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">3</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">aa, bb = a.split([<span class="number">2</span>, <span class="number">1</span>], dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(aa.size(), bb.size())</span><br><span class="line"></span><br><span class="line">aa, bb, cc = a.split(<span class="number">1</span>, dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(aa.size(), bb.size(), cc.size())</span><br></pre></td></tr></table></figure>



<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>按照数量拆分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">3</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">aa, bb = a.chunk(<span class="number">2</span>, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">aa, bb, cc = a.chunk(<span class="number">3</span>, dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(aa.size(), bb.size(), cc.size())</span><br></pre></td></tr></table></figure>



<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h3><p> +=*/ 或者add，sub，mul，div</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">b = torch.rand(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据broadcast机制，b会自动扩展成[3, 4]再参与运算</span></span><br><span class="line">c1 = a + b</span><br><span class="line">c2 = a.add(b)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(c1, c2)))</span><br><span class="line"></span><br><span class="line">c1 = a - b</span><br><span class="line">c2 = a.sub(b)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(c1, c2)))</span><br><span class="line"></span><br><span class="line">c1 = a * b</span><br><span class="line">c2 = a.mul(b)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(c1, c2)))</span><br><span class="line"></span><br><span class="line">c1 = a / b</span><br><span class="line">c2 = a.div(b)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.eq(c1, c2)))</span><br></pre></td></tr></table></figure>



<h3 id="matmul矩阵相乘"><a href="#matmul矩阵相乘" class="headerlink" title="matmul矩阵相乘"></a>matmul矩阵相乘</h3><ul>
<li><p>mm 只支持二维</p>
</li>
<li><p>matmul</p>
</li>
<li><p>@</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mm 只支持二维</span></span><br><span class="line">a = torch.tensor([[<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">3.</span>, <span class="number">4.</span>]])</span><br><span class="line">b = torch.ones(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">c = torch.mm(a, b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># matmul</span></span><br><span class="line">c = torch.matmul(a, b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># @</span></span><br><span class="line">c = a @ b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个例子</span></span><br><span class="line">x = torch.rand(<span class="number">4</span>, <span class="number">784</span>)</span><br><span class="line">w = torch.rand(<span class="number">512</span>, <span class="number">784</span>)</span><br><span class="line"><span class="built_in">print</span>((x @ w.t()).shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于2维张量相乘</span></span><br><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">64</span>)</span><br><span class="line">b = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">32</span>)</span><br><span class="line">c = torch.rand(<span class="number">4</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.matmul(a, b).size())</span><br><span class="line"><span class="built_in">print</span>(torch.matmul(a, c).size())</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      <categories>
        <category>《Python》</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
</search>
