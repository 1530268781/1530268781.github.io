<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>网络实验四-DHCP动态分配IP</title>
    <url>/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/</url>
    <content><![CDATA[<h1 id="实验四-DHCP动态分配IP"><a href="#实验四-DHCP动态分配IP" class="headerlink" title="实验四 DHCP动态分配IP"></a>实验四 DHCP动态分配IP</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>掌握DHCP（动态主机配置协议）工作原理<br>启动路由器的DHCP服务为局域网中的机器分配IP地址<br>启动服务器的DHCP服务为局域网中的机器分配IP地址</p>
<h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p>Cisco Packet Tracer</p>
<h2 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h2><p>（1）新建Packet Tracer拓扑图（如图）；<br>（2）静态配置路由器的IP地址；<br>（3）左侧网络通过路由器DHCP动态分配各主机包括服务器的IP地址；<br>（4）右侧网络通过服务器DHCP动态分配各主机的IP地址。</p>
<h2 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h2><h3 id="1-新建packet-tracer网络拓扑图"><a href="#1-新建packet-tracer网络拓扑图" class="headerlink" title="1.新建packet tracer网络拓扑图"></a>1.新建packet tracer网络拓扑图</h3><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps7.jpg" alt="img" style="zoom: 80%;">



<h3 id="2-启动路由器DHCP服务"><a href="#2-启动路由器DHCP服务" class="headerlink" title="2.启动路由器DHCP服务"></a>2.启动路由器DHCP服务</h3><p>(config)#ip dhcp pool test1<br>(dhcp-config)#network 192.168.1.0 255.255.255.0<br>(dhcp-config)#dns-server 192.168.1.1    //设置默认DNS服务器<br>(dhcp-config)#exit</p>
<p>(config)#in f0/0<br>(config)#ip address 192.168.1.254 255.255.255.0<br>(config)#no shut</p>
<h3 id="3-启动服务器DHCP服务"><a href="#3-启动服务器DHCP服务" class="headerlink" title="3.启动服务器DHCP服务"></a>3.启动服务器DHCP服务</h3><ul>
<li>（1）先静态配置服务器的IP地址、子网掩码、默认网关和默认DNS服务器</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps8.jpg" alt="img"></p>
<ul>
<li>（2）再开启服务器DHCP服务</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps9.jpg" alt="img"></p>
<h2 id="五、运行结果"><a href="#五、运行结果" class="headerlink" title="五、运行结果"></a>五、运行结果</h2><p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps10.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps11.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-DHCP%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DIP/wps59-1621920521237.jpg" alt="img"></p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>DHCP是动态主机分配协议，是一个局域网的网络协议，使用UDP协议工作。</p>
<div class="note success modern"><p>主要有两个用途：<br>（1）用于内部网或网络服务供应商ISP自动分配IP地址；<br>（2）给用户用于内部网管理员作为对所有计算机作中央管理的手段。</p>
</div>

<div class="note success modern"><p>DHCP具有以下功能：<br>1、保证任何IP地址在同一时刻只能由一台DHCP客户机所使用。<br>2、DHCP应当可以给用户分配永久固定的IP地址。<br>3、DHCP应当可以同用其他方法获得IP地址的主机共存（如手工配置IP地址的主机）。<br>4、DHCP服务器应当向现有的BOOTP客户端提供服务。</p>
</div>]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>pictures</title>
    <url>/2021/05/22/pictures/</url>
    <content><![CDATA[<p><img src="/2021/05/22/pictures/2.png" alt="2"></p>
<p><img src="/2021/05/22/pictures/1.jpg" alt="3"></p>
<p><img src="/2021/05/22/pictures/3.png"></p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验六-FTP与Email服务</title>
    <url>/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>了解FTP（简单传送协议）的作用及基本原理<br>掌握服务器端FTP的配置<br>掌握服务器与客户端之间文件共享<br>掌握邮件服务器的配合，发送与接收邮件<br>了解TFTP文件共享基本原理</p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Cisco Packet Tracer    tftp32.exe</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>（1）新建Packet Tracer拓扑图（如图，以实验五为基础）；<br>（2）新增服务器Server1，作为Laptop1的DNS域名服务器；<br>（3）启动Server0和Server1的DNS服务，并配置DNS映射表；<br>（4）启动Server0的FTP服务，在Laptop1上访问并共享Server0上的文件；<br>（5）在PC0和Laptop1上配置邮件，包括姓名、邮件地址，邮件服务器等；<br>（6）启用服务器的EMail服务，并设置用户。<br>（7）测试在两台主机之间发送邮件    。  </p>
<h1 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h1><p>1.新建packet tracer网络拓扑图</p>
<p><img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185013306.png" alt="image-20210528185013306"></p>
<p>2.配置新增的服务器，并修改Laptop1的默认DNS为Server0的IP地址</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185024685.png" alt="image-20210528185024685" style="zoom: 67%;">



<p>3.启动两个服务器的DNS服务，并新增四条地址转换信息，如图</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185034976.png" alt="image-20210528185034976" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185054327.png" alt="image-20210528185054327" style="zoom:67%;">



<p>4.启动Server0的FTP服务，新增一个用户信息，包括用户名、密码以及权限</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185106041.png" alt="image-20210528185106041" style="zoom:67%;">



<p>5.在Laptop1上访问Server0上的FTP1，实现下载和上传文件</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185117275.png" alt="image-20210528185117275" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185125957.png" alt="image-20210528185125957" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185136089.png" alt="image-20210528185136089" style="zoom:50%;">



<p>6.在PC0和Laptop1上配置两个Email用户，如图</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185141602.png" alt="image-20210528185141602" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185146855.png" alt="image-20210528185146855" style="zoom:67%;">



<p>7.在对应邮件服务器上注册</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185156699.png" alt="image-20210528185156699" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185206053.png" alt="image-20210528185206053" style="zoom:67%;">

<p>8.收发邮件<br>–发送端</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185213776.png" alt="image-20210528185213776" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185219900.png" alt="image-20210528185219900" style="zoom:67%;">

<p>–接受端</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185224344.png" alt="image-20210528185224344" style="zoom:67%;">

<p>–回信</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185230738.png" alt="image-20210528185230738" style="zoom:67%;">

<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185239349.png" alt="image-20210528185239349" style="zoom:67%;">



<p>9.了解TFTP文件的收发</p>
<img src="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/image-20210528185244592.png" alt="image-20210528185244592" style="zoom:67%;">



<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p> FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。<br>默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。</p>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验五-NAT地址转换</title>
    <url>/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="实验五-NAT地址转换"><a href="#实验五-NAT地址转换" class="headerlink" title="实验五 NAT地址转换"></a>实验五 NAT地址转换</h1><p>​                                             </p>
<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>了解NAT的作用及基本原理</p>
<p>掌握NAT常见应用场景及配置</p>
<p>掌握静态NAT的配置，实现局域网访问互联网</p>
<h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p>· Cisco Packet Tracer</p>
<h2 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h2><p>（1）新建Packet Tracer拓扑图（如图）；</p>
<p>（2）静态配置服务器的IP地址，子网掩码和默认网关（见实验四）；</p>
<p>（3）通过服务器DHCP动态分配各主机的IP地址；</p>
<p>（4）在Router0上配置动态NAT地址转换，建立（PC0，Laptop0本地和全局的）地址之间的临时映射关系（过一段时间没有数据就会删除映射关系）；</p>
<p>（5）在Router0上配置静态NAT地址转换，建立（服务器本地和全局的）地址之间的永久映射关系，对外提供服务。</p>
<p>（6）启用服务器的DNS服务，给服务器的内部全局地址分配一个域名，并测试能否访问成功。  </p>
<h2 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h2><h3 id="1-packet-tracer网络拓扑图"><a href="#1-packet-tracer网络拓扑图" class="headerlink" title="1. packet tracer网络拓扑图"></a><strong>1.</strong> packet tracer网络拓扑图</h3><p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps1.jpg" alt="img"> </p>
<h3 id="2-完成网络的基本配置"><a href="#2-完成网络的基本配置" class="headerlink" title="2. 完成网络的基本配置"></a><strong>2.</strong> 完成网络的基本配置</h3><p>包括各主句的IP地址、子网掩码、网关、默认DNS服务器等，以及路由表的配置，实现网络之间的连通。（略，见实验1-4）</p>
<h3 id="3-配置动态NAT"><a href="#3-配置动态NAT" class="headerlink" title="3. 配置动态NAT"></a><strong>3.</strong> 配置动态NAT</h3><ul>
<li><p>（1）定义NAT设备（路由器）的内外接口</p>
<p>—R0上</p>
<p>（config）int f0/0</p>
<p>（config-if）<font color="cornflowerblue">ip nat inside</font></p>
<p>（config）int f0/1</p>
<p>（config-if）<font color="cornflowerblue">ip nat outside</font></p>
</li>
<li><p>（2）定义NAT地址池</p>
<p>— ip nat pool pool-name start-ip  end-ip netmask 子网掩码</p>
<p>（config）<font color="cornflowerblue">ip nat pool</font> <font color="red">out</font> 202.106.0.4  202.106.0.24  <font color="cornflowerblue">netmask</font> 255.255.255.0</p>
</li>
<li><p>（3）利用ACL(地址控制列表Address Control List)定义允许转换的本地地址列表</p>
<p>—access-list ACL号 permit  &lt;网段&gt;  &lt;子网掩码反码&gt;</p>
<p>（config）<font color="cornflowerblue">access-list </font><font color="red">10</font> <font color="cornflowerblue">permit </font>192.168.0.0 0.0.0.255</p>
</li>
<li><p>（4）定义内部本地地址与内部全局地址的转换关系</p>
<p>（config<font color="cornflowerblue">）ip nat inside source list</font> <font color="red">10</font> <font color="cornflowerblue">pool </font><font color="red">out</font></p>
</li>
</ul>
<h3 id="4-配置静态NAT"><a href="#4-配置静态NAT" class="headerlink" title="4. 配置静态NAT"></a><strong>4.</strong> 配置静态NAT</h3><p>（config）<font color="cornflowerblue">ip nat inside source static</font> 192.168.0.1  202.106.0.3</p>
<p>（config）<font color="cornflowerblue">ip nat outside source static</font> 202.106.0.3 192.168.0.1</p>
<h3 id="5-启动DNS服务"><a href="#5-启动DNS服务" class="headerlink" title="5.启动DNS服务"></a>5.启动DNS服务</h3><p>给服务器的内部全局地址分配一个域名</p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps2.jpg" alt="img"> </p>
<h3 id="6-测试连通性"><a href="#6-测试连通性" class="headerlink" title="6. 测试连通性"></a><strong>6.</strong> 测试连通性</h3><p>测试Server0与Laptop1的连通性，并在Laptop1上访问第 5步的域名</p>
<h2 id="五、运行结果"><a href="#五、运行结果" class="headerlink" title="五、运行结果"></a>五、运行结果</h2><p>（1）NAT表</p>
<img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps3.jpg" alt="img" style="zoom:80%;"> 

 

<p>（2）连通性</p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps4.jpg" alt="img" style="zoom: 80%;"><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps5.jpg" alt="img" style="zoom:80%;"><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps6.jpg" alt="img" style="zoom:80%;"> </p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p> 1.NAT将网络划分为内部网络和外部网络两部分，局域网主机利用NAT访问网络时，是将局域网内部的本地地址转换为全局地址（互联网合法的IP地址）后转发数据包；</p>
<p> 2.NAT分为两种类型：NAT（网络地址转换）和NAPT（网络端口地址转换IP地址对应一个全局地址）。</p>
<p>（1）静态NAT：实现内部地址与外部地址一对一的映射。现实中，一般都用于服务器；</p>
<p>（2）动态NAT：定义一个地址池，自动映射，也是一对一的。现实中，用得比较少；</p>
<p>（3）NAPT：使用不同的端口来映射多个内网IP地址到一个指定的外网IP地址，多对一。</p>
<p>3.NAPT采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自Internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</p>
<p>4.<font color="red">区分 内部/外部 局部/全局：</font></p>
<p>—内部本地（局部）地址：转换前的主机（私有）地址。</p>
<p>—内部全局地址：内部主机与外部主机通信地址，通常为公有地址。</p>
<p>—外部本地（局部）地址：能够被内部主机识别的外部主机的地址，对内部主机可见的地址。</p>
<p>—外部全局地址：外部主机的真实地址，对内部主机是不可见的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inside localne内部本地  内部转换前地址</span><br><span class="line">inside global内部全局 本地转换后地址</span><br><span class="line">ip nat inside xx 内部本地 内部全局</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">outside global外部全局 外部转换前地址</span><br><span class="line">outside local外部本地  外部转换后地址</span><br><span class="line">ip nat outside xx 外部全局  外部本地</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/wps7.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验三-OSPF+RIP路由配置</title>
    <url>/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF-RIP%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>  掌握综合路由器的配置方法；<br>  掌握查看通过路由重分布学习产生的路由；<br>  熟悉广域网线缆的链接方式；</p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Cisco Packet Tracer</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>新建Packet Tracer拓扑图<br>（1）在实验二基础上新增一个路由器R5连接到R4，配置R4各个接口的IP地址即子网掩码；<br>（2）新增一个网段192.168.7.0，重新配置PC1的ip地址与默认网关；<br>（3）在路由器R4上左侧配置RIP V2路由协议；右侧配置OSPF协议。<br>（4）在R4路由进程中引入外部路由，进行路由重分布。<br>（5）在路由器R5上配置RIP路由协议；<br>（6）验证PC1、PC0主机之间可以互相通信；</p>
<h1 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h1><h2 id="1-新建packet-tracer网络拓扑图"><a href="#1-新建packet-tracer网络拓扑图" class="headerlink" title="1.新建packet tracer网络拓扑图"></a>1.新建packet tracer网络拓扑图</h2><p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF-RIP%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/wps5.jpg" alt="img"></p>
<h2 id="2-在路由器R4上左侧配置RIP-V2路由协议；右侧配置OSPF协议"><a href="#2-在路由器R4上左侧配置RIP-V2路由协议；右侧配置OSPF协议" class="headerlink" title="2.在路由器R4上左侧配置RIP V2路由协议；右侧配置OSPF协议"></a>2.在路由器R4上左侧配置RIP V2路由协议；右侧配置OSPF协议</h2><p>—-R4<br>(config) #router ospf 100<br>(config-router) #network 192.168.3.0 0.0.0.255 area 2<br>(config-router) #network 192.168.7.0 0.0.0.255 area 2<br>(config-router) #<font color="red">redistribute rip metric 10 subnets</font>  //将RIP路由重分布给OSPF路由协议<br>(config-router)#exit</p>
<p>(config) #router rip<br>(config-router) #network 192.168.7.0<br>(config-router) #ver 2<br>(config-router) #no auto-s<br>(config-router) #<font color="red">redistribute ospf 100 matric 10</font>    //将OSPF路由重分布给RIP路由协议</p>
<h2 id="3-在路由器R5上配置RIP路由协议"><a href="#3-在路由器R5上配置RIP路由协议" class="headerlink" title="3.在路由器R5上配置RIP路由协议"></a>3.在路由器R5上配置RIP路由协议</h2><p>router (config) #hostname R5<br>—-R5<br>(config)#router rip<br>(config-rout er)#network 192.168.7.0<br>(config-rout er)#network 192.168.2.0<br>(config-rout er)#ver 2<br>(config-rout er)#no auto-summary</p>
<h1 id="五、运行结果"><a href="#五、运行结果" class="headerlink" title="五、运行结果"></a>五、运行结果</h1><ul>
<li>（1）路由表</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF-RIP%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/wps6.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF-RIP%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/wps7.jpg" alt="img"></p>
<ul>
<li>（2）测试网络连通性，在PC1上ping PC0</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF-RIP%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/wps8.jpg" alt="img"></p>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>1.路由重分布：为了在同一个网络中有效地支持多种路由协议，必须在不同的路由协议之间共享路由信息。在不同的路由协议之间交换路由信息的过程称为路由重分布，它将一种路由选择协议获悉的路由信息告知给另一种路由选择协议。</p>
<p>2.为了支持本设备能够运行多个路由协议进程，系统软件提供了路由信息从一个路由进程重分布到另一个路由进程的功能。比如你可以将OSPF路由域的路由重新分布后通告RIP路由域中，也可以将RIP路由域的路由重新分布后通告到OSPF路由域中。路由的相互重分布可以在所有的IP路由协议之间进行。</p>
<p>3.命令格式：router(router-config)#redistribute  protocol [protocol-id]  {level-1 | level-2|level-1-2}<br>[metric metric-value]  [metric-type  type-value]<br>[match (internal | external 1 |external 2)]<br>[tag tag-value] [route-map map-tag] [weightweight] [subnets]</p>
<p>（1）protocol变量表示源路由协议。源路由指该路由协议的路由是那些将被翻译成另一种协议的路由，protocol变量的可用值有：BGP、EIGRP、IGRP、OSPF、STATIC[IP]、CONNECTED、RIP。其中STATIC[IP]用于重分布IP静态路由给ISIS，CONNECTED表示OSPF和IS-IS重分布这些路由作为到达AS的外部路由。</p>
<p>（2）protocol-id是AS的号码，level-1、level-2、level-1-2仅用于IS-IS。</p>
<p>（3）可选项metric后面跟着metric-value，以指定度量值，redistribute命令使用的metric  metric-value变量值优先于default-metric后面的缺省度量值。</p>
<p>（4）可选项metric-type type-value，当该关键字用于OSPF时，其变量缺省为一个type 2外部路由，并作为公布到OSPF AS中的默认路由。使用数值1表名缺省路由是一个type 1外部路由。</p>
<p>（5）可选关键字match和其参数internal、external 1、external 2专用于重分布到其他路由协议的OSPF路由。internal表示路由是AS的内部路由。external 1表示路由是type 1外部路由，external 2表示路由是type 2外部路由。</p>
<p>（6）可选项tag tag-value将一个32位的小数值赋给外部路由。tag-value不能用于OSPF路由协议但是可以供ASBR使用。如果tag标记没有定义，当重分布BGP路由时，所使用的缺省标记是来自BGP路由的远程AS号码。其他路由协议的缺省标记为0。</p>
<p>（7）router-map map-tag 将过滤器用于源路由协议导入的路由。不指定router-map，则允许所有的路由被重分布。</p>
<p>（8）weight weight给重分布到BGP中的路由指定一个0-65535的整数。BGP使用weight值确定多条路径中的最佳路径。</p>
<p>（9）subnets用于重分布路由到OSPF，启用粒度重分布或者汇总重分布。</p>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验二-OSPF动态配合路由</title>
    <url>/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>熟掌握OSPF协议的配置方法：<br>掌握查看通过动态路由协议OSPF学习产生的路由；<br>熟悉广域网线缆的链接方式。</p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Cisco Packet Tracer</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>（1）新建Packet Tracer拓扑图（如图）<br>（2）设置主机的IP地址及子网掩码；（同实验一）<br>（3）用命令行方式配置各个路由器各接口的IP地址及子网掩码；（同实验一）<br>（4）OSPF方式动态配置路由，实现两个网络连通并检验连通性。</p>
<h1 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h1><ul>
<li>1.新建packet tracer网络拓扑图</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202133291.png" alt="image-20210528202133291"></p>
<ul>
<li>2.设置各主机IP地址与子网掩码，分别为：</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202142464.png" alt="image-20210528202142464" style="zoom:67%;"><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202145959.png" alt="image-20210528202145959" style="zoom:67%;"></p>
<ul>
<li>3.选择命令行选项卡进入设备配置命令行界面（ＣＬＩ），用命令行方式配置路由器各个接口IP地址。（同实验一）<ul>
<li>(1)回车：进入非特权模式 &gt;</li>
<li>(2)&gt;enable:进入特权模式 Router#</li>
<li>(3)#configure terminal:进入配置状态模式 Router(config)#</li>
<li>(4)(config)#interface fastEthernet 0/1：进入接口配置状态Router(config-if)#</li>
<li>(5)配置接口IP地址<br>(config-if)#ip address  202.168.1.254  255.255.255.0</li>
</ul>
</li>
</ul>
<ul>
<li>4.OSPF动态配置路由<ul>
<li>(1)先进入配置状态模式(config)#    (同3)</li>
<li>(2)OSPF动态配置路由表<br>–R3<br>(config)#router OSPF 100        //100是进程ID<br>(config-router)#network  192.168.1.0  0.0.0.255  area  1<br>(config-router)#network  192.168.4.0  0.0.0.255  area  1<br>–R1<br>(config)#router OSPF 100<br>(config-router)#network  192.168.4.0  0.0.0.255  area  1<br>(config-router)#network  192.168.5.0  0.0.0.255  area  0<br>–R0<br>(config)#router OSPF 100<br>(config-router)#network  192.168.5.0  0.0.0.255  area 0<br>(config-router)#network  192.168.6.0  0.0.0.255  area 0<br>–R2<br>(config)#router OSPF 100<br>(config-router)#network  192.168.6.0  0.0.0.255  area 0<br>(config-router)#network  192.168.3.0  0.0.0.255  area 2<br>–R4<br>(config)#router OSPF 100<br>(config-router)#network 192.168.3.0  0.0.0.255  area 2<br>(config-router)#network 192.168.7.0  0.0.0.255  area 2</li>
<li>(3)测试主机与默认网关之间、两个局域网之间的连通性<br>ping IP地址</li>
</ul>
</li>
</ul>
<h1 id="五、运行结果"><a href="#五、运行结果" class="headerlink" title="五、运行结果"></a>五、运行结果</h1><ul>
<li>（1）OSPF动态路由配置（以router3为例）</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202233400.png" alt="image-20210528202233400"></p>
<p>路由表</p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202238003.png" alt="image-20210528202238003"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202247398.png"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202303263.png" alt="image-20210528202303263"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202316860.png" alt="image-20210528202316860"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202320527.png" alt="image-20210528202320527"></p>
<ul>
<li>（2）测试网络连通性，在PC0上ping PC1</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-OSPF%E5%8A%A8%E6%80%81%E9%85%8D%E5%90%88%E8%B7%AF%E7%94%B1/image-20210528202325845.png" alt="image-20210528202325845"></p>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>OSPF开放式最短路径优先协议，是目前网路中应用最广泛的路由协议之一。<br>属于内部网管路由协议，能够适应各种规模的网络环境，是典型的链路状态协议。<br>OSPF路由协议通过向全网扩散（洪泛法）本设备的链路状态信息，使网络中每台设备最终同步一个具有全网链路状态的数据库，然后路由器采用SPF算法，以自己为根，计算到达其他网络的最短路径，最终形成全网路由信息。</p>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验一-静态配置路由+RIP动态配置路由</title>
    <url>/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>熟悉广域网线缆的链接方式；<br>掌握路由器和主机各接口IP地址的配置；<br>掌握静态路由的配置方法和技巧，实现网络的连通性；<br>掌握RIP动态路由的配置方法和技巧，实现网络的连通性。</p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Cisco Packet Tracer</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>（1）新建Packet Tracer拓扑图，三个局域网段通过两台路由器连接，两个网段分别有两台主机通过交换机与路由器相连；<br>（2）设置四台主机的IP地址及子网掩码；<br>（3）通过配置线连接主机与路由器，用命令行方式配置两台路由器各接口的IP地址及子网掩码；<br>（4）静态方式配置路由，实现两个网络连通并检验连通性；<br>（5）RIP方式动态配置路由，实现两个网络连通并检验连通性。</p>
<h1 id="四、方案设计"><a href="#四、方案设计" class="headerlink" title="四、方案设计"></a>四、方案设计</h1><ul>
<li>1.新建packet tracer网络拓扑图</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps1.jpg" alt="img"></p>
<ul>
<li>2.设置各主机IP地址与子网掩码，分别为：</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps2.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps3-1622204035658.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps4.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps5.jpg" alt="img"></p>
<ul>
<li><p>3.选择命令行选项卡进入设备配置命令行界面（ＣＬＩ），用命令行方式配置路由器各个接口IP地址。</p>
<ul>
<li><p>(1)回车：进入非特权模式 &gt;</p>
</li>
<li><p>(2)&gt;enable:进入特权模式 Router#</p>
</li>
<li><p>(3)#configure terminal:进入配置状态模式 Router(config)#</p>
<p>​    也可以输入conf t    (技巧：输入命令关键词可以只输入前面几个字母(只要这几个字母能跟别的命令区别开即可,即最小匹配)，不用输全。也可输入命令的一部分，再按Tab键，系统会自动补全命令单词。)</p>
</li>
<li><p>(4)(config)#interface fastEthernet 0/1：进入接口配置状态Router(config-if)#<br>也可以输入in f 0/1；Inter fast 0/1；Interface faste 0/1</p>
</li>
<li><p>(5)配置接口IP地址<br>(config-if)#ip address  202.168.1.254  255.255.255.0</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>4.静态方式配置路由</p>
<ul>
<li>(1)先进入配置状态模式(config)#    (同3)</li>
<li>(2)静态配置路由表<br>(config)#ip route &lt;网络号&gt; &lt;掩码&gt; &lt;下一跳&gt;<br>如ip route 202.168.2.0 255.255.255.0 202.168.3.1</li>
<li>（3）.测试主机与默认网关之间、两个局域网之间的连通性<br>ping IP地址<br>如在PC0的命令提示符界面输入 &gt;ping 202.168.2.1</li>
</ul>
</li>
<li><p>5.RIP动态配置路由</p>
<ul>
<li>(1)先进入配置状态模式(config)#    (同3)</li>
<li>(2)RIP动态配置路由表<br>(config)#router RIP<br>(config-router)#network 192.168.1.0<br>(config-router)#network 192.168.3.0<br>(config-router)#ver 2<br>(config-router)#no auto-summary</li>
<li>（3）.测试主机与默认网关之间、两个局域网之间的连通性<br>ping IP地址</li>
</ul>
</li>
</ul>
<h1 id="五、运行结果"><a href="#五、运行结果" class="headerlink" title="五、运行结果"></a>五、运行结果</h1><ul>
<li>（1）配置IP地址（以router0为例）</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps6.jpg" alt="img"></p>
<ul>
<li>（2）静态路由配置（以router0为例）</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps7.jpg" alt="img"></p>
<p>路由表</p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps8.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps9.jpg" alt="img"></p>
<ul>
<li>（3）测试两个局域网主机间的连通性</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps10.jpg" alt="img" style="zoom: 67%;"><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps11.jpg" alt="img" style="zoom: 67%;"></p>
<ul>
<li>（4）RIP动态路由配置（以router0为例）</li>
</ul>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps12.jpg" alt="img"></p>
<p>路由表</p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps13.jpg" alt="img"></p>
<p><img src="/2021/05/23/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-RIP%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/wps14.jpg" alt="img"></p>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><ul>
<li>（1）有些命令只能在特定模式下使用，注意命令提示符的变化；只有当路由器的路由表信息完成配置后，局域网之间才算真正的连通。</li>
<li>（2）路由器属于网络层设备，能够根据IP包头的信息，选择一条最佳路径，将数据包转发出去。实现不同网段的主机之间的互相访问。路由器是根据路由表进行选路和转发的。而路由表里就是由一条条路由信息组成。</li>
<li>（3）生成路由表主要有两种方法：手工配置和动态配置，即静态路由协议配置和动态路由协议配置。</li>
<li>（4）静态路由是指由网络管理员手工配置的路由信息。静态路由除了具有简单、高效、可靠的优点外，它的另一个好处是网络安全保密性高。缺省路由可以看做是静态路由的一种特殊情况。当数据在查找路由表时，没有找到和目标相匹配的路由表项时，为数据指定默认路由。</li>
<li>（5）RIP(Routing Information Protocols,路由信息协议)是应用较早、使用较普遍的IGP内部网管协议，适用于小型同类网络，是距离矢量协议；</li>
<li>（6）RIP协议通过跳数作为衡量路径开销的，RIP协议里规定最大跳数为15（超过为不可达），其优点是实现简单，开销较小，缺点是网络规模较小，“坏消息传的慢”；</li>
<li>（7）RIP协议有两个版本：RIPv1和RIPv2，RIPv1属于有类路由协议，不支持VLSM，以广播形式进行路由信息的更新，更新周期为30秒；RIPv2属于无类路由协议，支持VLSM，以组播形式进行路由更细。</li>
</ul>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>《第一行代码-笔记》</title>
    <url>/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
    <content><![CDATA[<div class="note warning modern"><p><strong>前言：</strong>目录结构还有待优化，可直接ctrl+F搜索有无需要了解的内容<br>本笔记属于个人初学android过程时总结，如有错误或者图片缺失，还请留言指正，十分感谢！<br>仅供学习参考，如需转载请注明来自[Durango]: <a href="http://www.durango.cn/">www.durango.cn</a></p>
</div>




<h1 id="第一章-第一行代码"><a href="#第一章-第一行代码" class="headerlink" title="第一章     第一行代码"></a>第一章     <strong>第一行代码</strong></h1><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><h3 id="Linux内核层、系统运行库、应用架构层、应用层"><a href="#Linux内核层、系统运行库、应用架构层、应用层" class="headerlink" title="Linux内核层、系统运行库、应用架构层、应用层"></a>Linux内核层、系统运行库、应用架构层、应用层</h3><h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><h3 id="活动（Activity）、服务（Service）、广播接收器（Broadcast-Receiver）、-内容提供者（Content-Provider"><a href="#活动（Activity）、服务（Service）、广播接收器（Broadcast-Receiver）、-内容提供者（Content-Provider" class="headerlink" title="活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、        内容提供者（Content Provider)"></a>活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、        内容提供者（Content Provider)</h3><h2 id="APP目录"><a href="#APP目录" class="headerlink" title="APP目录"></a>APP目录</h2><ul>
<li>1.build: 一些编译时自动生成的文件</li>
</ul>
<h4 id="2-libs-第三方jar包"><a href="#2-libs-第三方jar包" class="headerlink" title="2.libs: 第三方jar包"></a>2.libs: 第三方jar包</h4><h4 id="3-androidTest-测试用例，自动化监测"><a href="#3-androidTest-测试用例，自动化监测" class="headerlink" title="3.androidTest: 测试用例，自动化监测"></a>3.androidTest: 测试用例，自动化监测</h4><h4 id="4-java-放置Java代码"><a href="#4-java-放置Java代码" class="headerlink" title="4.java: 放置Java代码"></a>4.<font color="red">java</font>: 放置Java代码</h4><h4 id="5-res-资源文件"><a href="#5-res-资源文件" class="headerlink" title="5.res: 资源文件"></a>5<font color="red">.res</font>: 资源文件</h4><p>​                drawable: 图片</p>
<p>​                layout: 布局文件</p>
<p>​                values: 字符串</p>
<h4 id="6-AndroidMainfest-xml-项目配置文件，四大活动必须在此注册！"><a href="#6-AndroidMainfest-xml-项目配置文件，四大活动必须在此注册！" class="headerlink" title="6.AndroidMainfest.xml: 项目配置文件，四大活动必须在此注册！"></a>6.AndroidMainfest.xml: 项目配置文件，四大活动必须在此注册！</h4><p>​    ……</p>
<h2 id="主活动"><a href="#主活动" class="headerlink" title="主活动"></a>主活动</h2><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200912223928217.png" alt="image-20200912223928217"></p>
<h2 id="引入布局"><a href="#引入布局" class="headerlink" title="引入布局"></a><font color="red">引入布局</font></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setContentView( R.layout.hello_world_layout)</span><br></pre></td></tr></table></figure>



<h2 id="资源的引用"><a href="#资源的引用" class="headerlink" title="资源的引用"></a><font color="red">资源的引用</font></h2><h4 id="1-代码中"><a href="#1-代码中" class="headerlink" title="1.代码中"></a>1.代码中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R.string.hello_world</span><br></pre></td></tr></table></figure>

<p>​        R .类型 .名称</p>
<h4 id="2-XML中"><a href="#2-XML中" class="headerlink" title="2.XML中"></a>2.XML中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@.string.hello_world</span><br></pre></td></tr></table></figure>

<p>​    @ .类型 .名称</p>
<h3 id="定义id-id-名称"><a href="#定义id-id-名称" class="headerlink" title="定义id: @+id/名称"></a>定义id: @+id/名称</h3><h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><h4 id="（p26）"><a href="#（p26）" class="headerlink" title="（p26）"></a>（p26）</h4><h1 id="第二章-探究活动"><a href="#第二章-探究活动" class="headerlink" title="第二章 探究活动"></a>第二章 探究活动</h1><h2 id="活动是什么"><a href="#活动是什么" class="headerlink" title="活动是什么"></a>活动是什么</h2><h2 id="活动的基本用法"><a href="#活动的基本用法" class="headerlink" title="活动的基本用法"></a>活动的基本用法</h2><h3 id="一、手动创建活动"><a href="#一、手动创建活动" class="headerlink" title="一、手动创建活动"></a>一、手动创建活动</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172254284.png" alt="image-20200913172254284"></p>
<h3 id="二、创建和加载布局"><a href="#二、创建和加载布局" class="headerlink" title="二、创建和加载布局"></a>二、创建和加载布局</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172406723.png" alt="image-20200913172406723"></p>
<p>​                                                                                    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172431922.png" alt="image-20200913172431922"></p>
<h4 id="添加按钮："><a href="#添加按钮：" class="headerlink" title="添加按钮："></a><font color="orange">添加按钮：</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">	android:id=&quot;@+id/button_1&quot;</span><br><span class="line">	android:layout_width=&quot;match_parent&quot;</span><br><span class="line">	android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">	android:text=&quot;Button 1&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="加载布局："><a href="#加载布局：" class="headerlink" title="加载布局："></a><font color="orange">加载布局：</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setContentView(R.layout.布局文件名)</span><br></pre></td></tr></table></figure>

<h3 id="三、在AndroidManifest文件中注册"><a href="#三、在AndroidManifest文件中注册" class="headerlink" title="三、在AndroidManifest文件中注册"></a>三、在AndroidManifest文件中注册</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174606232.png" alt="image-20200913174606232"></p>
<h3 id="四、在活动中使用Toast提醒"><a href="#四、在活动中使用Toast提醒" class="headerlink" title="四、在活动中使用Toast提醒"></a>四、在活动中使用Toast提醒</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174713039.png" alt="image-20200913174713039"></p>
<h3 id="五、在活动中使用Menu"><a href="#五、在活动中使用Menu" class="headerlink" title="五、在活动中使用Menu"></a>五、在活动中使用Menu</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174848093.png" alt="image-20200913174848093"></h4><p>2.然后在main.xml文件中添加(创建两个菜单项)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;item</span><br><span class="line">	android:id=&quot;@+id/add_itme&quot;</span><br><span class="line">	android:title=&quot;Add&quot;/&gt;</span><br><span class="line">&lt;item</span><br><span class="line">	android:id=&quot;@+id/remove_itme&quot;</span><br><span class="line">	android:title=&quot;Remove&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-重写onCreateOptionMenu（）方法"><a href="#3-重写onCreateOptionMenu（）方法" class="headerlink" title="3.重写onCreateOptionMenu（）方法"></a>3.重写<font color="orange">onCreateOptionMenu（）</font>方法</h4><h4 id="在Java代码中使用快捷键-”Ctrl-O“"><a href="#在Java代码中使用快捷键-”Ctrl-O“" class="headerlink" title="在Java代码中使用快捷键 ”Ctrl+O“"></a>在Java代码中使用快捷键 ”Ctrl+O“</h4><p>​                                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913175533827.png" alt="image-20200913175533827"></p>
<h4 id="4-重写onOptionsItemSelected"><a href="#4-重写onOptionsItemSelected" class="headerlink" title="4.重写onOptionsItemSelected"></a>4.重写<font color="orange">onOptionsItemSelected</font></h4><p>​                                    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913180038921.png" alt="image-20200913180038921"></p>
<h3 id="六、摧毁一个活动"><a href="#六、摧毁一个活动" class="headerlink" title="六、摧毁一个活动"></a>六、摧毁一个活动</h3><h4 id="stop"><a href="#stop" class="headerlink" title="stop();"></a><font color="orange">stop();</font></h4><h2 id="使用Intent（意图）在活动之间穿梭"><a href="#使用Intent（意图）在活动之间穿梭" class="headerlink" title="使用Intent（意图）在活动之间穿梭"></a>使用Intent（意图）在活动之间穿梭</h2><h3 id="一、使用显式的Intent"><a href="#一、使用显式的Intent" class="headerlink" title="一、使用显式的Intent"></a>一、使用显式的Intent</h3><h4 id><a href="#" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913212452461.png" alt="image-20200913212452461"></h4><h4 id="首先构建一个Intent，传入FirstActivity-this作为上下文，传入SecondActicity-class作为目标活动，然后通过startActivity（）方法来执行这个Intent。"><a href="#首先构建一个Intent，传入FirstActivity-this作为上下文，传入SecondActicity-class作为目标活动，然后通过startActivity（）方法来执行这个Intent。" class="headerlink" title="首先构建一个Intent，传入FirstActivity.this作为上下文，传入SecondActicity.class作为目标活动，然后通过startActivity（）方法来执行这个Intent。"></a>首先构建一个Intent，传入FirstActivity.this作为<font color="orange">上下文</font>，传入SecondActicity.class作为<font color="orange">目标活动</font>，然后通过startActivity（）方法来执行这个Intent。</h4><h3 id="二、使用隐式的Intent（意图过滤器intent-filter"><a href="#二、使用隐式的Intent（意图过滤器intent-filter" class="headerlink" title="二、使用隐式的Intent（意图过滤器intent-filter)"></a>二、使用隐式的Intent（意图过滤器<font color="red">intent-filter</font>)</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913213406302.png" alt="image-20200913213406302"></h4><h4 id="-1"><a href="#-1" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913213734619.png" alt="image-20200913213734619"></h4><h4 id="2-DEFAULT是一种默认的category，在调用startActicity-方法时会自动将这个category添加到Intent中。"><a href="#2-DEFAULT是一种默认的category，在调用startActicity-方法时会自动将这个category添加到Intent中。" class="headerlink" title="2.DEFAULT是一种默认的category，在调用startActicity()方法时会自动将这个category添加到Intent中。"></a>2.DEFAULT是一种默认的category，在调用startActicity()方法时会自动将这个category添加到Intent中。</h4><h4 id="3-每个Intent只能指定一个action，却能指定多个category，这样增加："><a href="#3-每个Intent只能指定一个action，却能指定多个category，这样增加：" class="headerlink" title="3.每个Intent只能指定一个action，却能指定多个category，这样增加："></a>3.每个Intent只能指定一个action，却能指定多个category，这样增加：</h4><h4 id="intent-addCategory-“com-example-activity-MY-CATEGORY”-；"><a href="#intent-addCategory-“com-example-activity-MY-CATEGORY”-；" class="headerlink" title="intent.addCategory(“com.example.activity.MY_CATEGORY”)；"></a>intent.<font color="red">addCategory(“com.example.activity.MY_CATEGORY”)</font>；</h4><h4 id="4-然后在活动二的intent-filter中添加声明："><a href="#4-然后在活动二的intent-filter中添加声明：" class="headerlink" title="4.然后在活动二的intent-filter中添加声明："></a>4.然后在活动二的intent-filter中添加声明：</h4><h4 id="lt-category-android-name-”com-example-activity-MY-CATEGORY”"><a href="#lt-category-android-name-”com-example-activity-MY-CATEGORY”" class="headerlink" title="&lt;category android:name=”com.example.activity.MY_CATEGORY”"></a><font color="red">&lt;category android:name=”com.example.activity.MY_CATEGORY”</font></h4><h4 id="5-只有-lt-action-gt-和-lt-category-gt-同时匹配上-Intent中指定的-action-和-category-时，这个活动才能响应该Intent"><a href="#5-只有-lt-action-gt-和-lt-category-gt-同时匹配上-Intent中指定的-action-和-category-时，这个活动才能响应该Intent" class="headerlink" title="5.只有&lt;action&gt;和&lt;category&gt;同时匹配上 Intent中指定的 action 和 category 时，这个活动才能响应该Intent"></a>5.<font color="orange">只有&lt;action&gt;和&lt;category&gt;同时匹配上 Intent中指定的 action 和 category 时，这个活动才能响应该Intent</font></h4><h3 id="三、更多隐式的Intent"><a href="#三、更多隐式的Intent" class="headerlink" title="三、更多隐式的Intent"></a>三、更多隐式的Intent</h3><h4 id="1-使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动"><a href="#1-使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动" class="headerlink" title="1.使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动"></a>1.使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动</h4><p>​            <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913220158511.png" alt="image-20200913220158511"></p>
<h5 id="（1）这里我们首先指定了Intent的action是Intent-ACTION-VIEW，这是一个Android系统内置的动作，其常量值为-android-intent-action-VIEW。"><a href="#（1）这里我们首先指定了Intent的action是Intent-ACTION-VIEW，这是一个Android系统内置的动作，其常量值为-android-intent-action-VIEW。" class="headerlink" title="（1）这里我们首先指定了Intent的action是Intent.ACTION_VIEW，这是一个Android系统内置的动作，其常量值为                android.intent.action.VIEW。"></a>（1）这里我们首先指定了Intent的action是<font color="red">Intent.ACTION_VIEW</font>，这是一个Android系统内置的动作，其常量值为                android.intent.action.VIEW。</h5><h5 id="（2）然后通过Uri-parse-方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData-方法将这个uri对象-传递进去。"><a href="#（2）然后通过Uri-parse-方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData-方法将这个uri对象-传递进去。" class="headerlink" title="（2）然后通过Uri.parse()方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData()方法将这个uri对象                传递进去。"></a>（2）然后通过<font color="red">Uri.parse()</font>方法，将一个网址字符串解析成一个Uri对象，再调用Intent的<font color="red">setData()</font>方法将这个uri对象                传递进去。</h5><h5 id="（3）可能你会对setData-部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，-主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri-parse-方法中解析产生的。"><a href="#（3）可能你会对setData-部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，-主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri-parse-方法中解析产生的。" class="headerlink" title="（3）可能你会对setData()部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，                主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri.parse()方法中解析产生的。"></a>（3）可能你会对<font color="red">setData()</font>部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，                主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri.parse()方法中解析产生的。</h5><h4 id="2-与此对应，我们还可以在-lt-intent-filter-gt-标签中再配置一个-lt-data-gt-标签，用于更精确地"><a href="#2-与此对应，我们还可以在-lt-intent-filter-gt-标签中再配置一个-lt-data-gt-标签，用于更精确地" class="headerlink" title="2.与此对应，我们还可以在&lt;intent-filter&gt;标签中再配置一个&lt;data&gt;标签，用于更精确地"></a>2.与此对应，我们还可以在&lt;intent-filter&gt;标签中再配置一个&lt;<font color="red">data</font>&gt;标签，用于更精确地</h4><pre><code>            指定当前活动能够响应什么类型的数据。\&lt;data&gt;标签中主要可以配置以下内容。
            android:scheme。用于指定数据的协议部分，如上例中的http部分。
            android:host。用于指定数据的主机名部分，如上例中的www.baidu.com部分。
            android:port。用于指定数据的端口部分，一般紧随在主机名之后。
            android:path。用于指定主机名和端口之后的部分,如一段网址中跟在域名之后的内容。
            android:mimeType。用于指定可以处理的数据类型,允许使用通配符的方式进行指定。
</code></pre>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><h5 id="这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了"><a href="#这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了" class="headerlink" title="这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了"></a>这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了</h5><h3 id="四、向下一个活动传递数据"><a href="#四、向下一个活动传递数据" class="headerlink" title="四、向下一个活动传递数据"></a>四、<font color="red">向下一个活动传递数据</font></h3><h4 id="1-通过Intent的putExtra-方法携带数据"><a href="#1-通过Intent的putExtra-方法携带数据" class="headerlink" title="1.通过Intent的putExtra()方法携带数据"></a>1.通过Intent的<font color="orange">putExtra()</font>方法携带数据</h4><h4 id="-2"><a href="#-2" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915194843260.png" alt="image-20200915194843260"></h4><h6 id="putExtra-“extra-data”-data-第一个参数是“键”，第二个参数是“数据”"><a href="#putExtra-“extra-data”-data-第一个参数是“键”，第二个参数是“数据”" class="headerlink" title="*putExtra(“extra_data”, data)*第一个参数是“键”，第二个参数是“数据”"></a>*<font color="orange">putExtra(“extra_data”, data)</font>*第一个参数是<strong>“键”</strong>，第二个参数是“数据”</h6><h4 id="2-通过Intent的getStringExtra-键-获取数据"><a href="#2-通过Intent的getStringExtra-键-获取数据" class="headerlink" title="2.通过Intent的getStringExtra(键)获取数据"></a>2.通过Intent的<font color="orange">getStringExtra(键)</font>获取数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915200007173.png" alt="image-20200915200007173"></p>
<h5 id="getStringExtra-getIntExtra-getBooleanExtra"><a href="#getStringExtra-getIntExtra-getBooleanExtra" class="headerlink" title="getStringExtra() / getIntExtra() / getBooleanExtra()"></a><font color="orange">getStringExtra() / getIntExtra() / getBooleanExtra()</font></h5><h3 id="五、返回数据给上一个活动"><a href="#五、返回数据给上一个活动" class="headerlink" title="五、返回数据给上一个活动"></a>五、<font color="red">返回数据给上一个活动</font></h3><h4 id="1-通过startActivityForResult（）来启动SecondActivity"><a href="#1-通过startActivityForResult（）来启动SecondActivity" class="headerlink" title="1.通过startActivityForResult（）来启动SecondActivity"></a>1.通过<font color="orange">startActivityForResult（）</font>来启动SecondActivity</h4><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915213454637.png" alt="image-20200915213454637"></p>
<h4 id="2-使用setResult（）返回数据"><a href="#2-使用setResult（）返回数据" class="headerlink" title="2.使用setResult（）返回数据"></a>2.使用<font color="orange">setResult（）</font>返回数据</h4><p>​                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915213859847.png" alt="image-20200915213859847"></p>
<h4 id="3-在FirstActivity中重写-onActivityResult（）"><a href="#3-在FirstActivity中重写-onActivityResult（）" class="headerlink" title="3.在FirstActivity中重写 onActivityResult（）"></a>3.在FirstActivity中重写<font color="orange"> onActivityResult（）</font></h4><p>​                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915214529345.png" alt="image-20200915214529345"></p>
<ol>
<li>首先通过检查requCode来判断数据来源，（FirstActivity可能调用startActivityForResult()去启动很多不同的活动，每个活动都会回调到活动的onActivityResult()中）。</li>
<li>然后通过resultCode来判断处理结果是否成功（RESULT_OK|RESULT_CANCELED）</li>
<li>最后通过 getStringExtra(键)来获取data携带的数据。</li>
</ol>
<h3 id="六、Bundle与Intent结合传递大量数据"><a href="#六、Bundle与Intent结合传递大量数据" class="headerlink" title="六、Bundle与Intent结合传递大量数据"></a>六、<font color="cornflowerblue">Bundle与Intent结合传递大量数据</font></h3><h4 id="1-传数据"><a href="#1-传数据" class="headerlink" title="1,传数据"></a>1,传数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">bundle.putString(&quot;date_string&quot;,&quot;some thing you just typed&quot;);</span><br><span class="line">bundle.putInt(&quot;data_Int&quot;,256);</span><br><span class="line">Intent intent = new Intent(...);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h4 id="2-取数据"><a href="#2-取数据" class="headerlink" title="2.取数据"></a>2.取数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intent  intent = getIntent();</span><br><span class="line">Bundle bundle = indent.getExtres();</span><br><span class="line">String str = bundle.getString(&quot;data_string&quot;);</span><br><span class="line">int in = bundle.getInt(&quot;data_Int&quot;);</span><br></pre></td></tr></table></figure>



<h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><h3 id="一、返回栈"><a href="#一、返回栈" class="headerlink" title="一、返回栈"></a>一、返回栈</h3><p>其实Android是使用任务(Task）来管理活动的，一个任务就是一组存放在栈里的活动的集其实Android是使用任务(Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈(Back Stack )。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中人栈，并处于栈顶的位置。而每当我们按下Back键或调用finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个人栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。</p>
<h3 id="二、活动状态"><a href="#二、活动状态" class="headerlink" title="二、活动状态"></a>二、活动状态</h3><h4 id="1-运行状态"><a href="#1-运行状态" class="headerlink" title="1.运行状态"></a>1.<font color="cornflowerblue">运行状态</font></h4><h5 id="当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。"><a href="#当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。" class="headerlink" title="当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。"></a>当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。</h5><h4 id="2-暂停状态"><a href="#2-暂停状态" class="headerlink" title="2.暂停状态"></a>2.<font color="cornflowerblue">暂停状态</font></h4><h5 id="当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。"><a href="#当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。" class="headerlink" title="当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。"></a>当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。</h5><h4 id="3-停止状态"><a href="#3-停止状态" class="headerlink" title="3.停止状态"></a>3.<font color="cornflowerblue">停止状态</font></h4><h5 id="当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保-存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可-能会被系统回收。"><a href="#当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保-存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可-能会被系统回收。" class="headerlink" title="当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保    存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可    能会被系统回收。"></a>当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保    存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可    能会被系统回收。</h5><h4 id="4-摧毁状态"><a href="#4-摧毁状态" class="headerlink" title="4.摧毁状态"></a>4.<font color="cornflowerblue">摧毁状态</font></h4><h5 id="当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证-手机的内存充足。"><a href="#当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证-手机的内存充足。" class="headerlink" title="当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证    手机的内存充足。"></a>当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证    手机的内存充足。</h5><h3 id="三、活动的生存期"><a href="#三、活动的生存期" class="headerlink" title="三、活动的生存期"></a>三、活动的生存期</h3><h4 id="1-oncCreat-活动第一次被创建时调用"><a href="#1-oncCreat-活动第一次被创建时调用" class="headerlink" title="1.oncCreat(): 活动第一次被创建时调用"></a>1.oncCreat(): 活动第一次被创建时调用</h4><h4 id="2-onStart-在活动由不可见变为可见时调用"><a href="#2-onStart-在活动由不可见变为可见时调用" class="headerlink" title="2.onStart(): 在活动由不可见变为可见时调用"></a>2.onStart(): 在活动由不可见变为可见时调用</h4><h4 id="3-onResume-在活动准备好和用户进行交互时调用"><a href="#3-onResume-在活动准备好和用户进行交互时调用" class="headerlink" title="3.onResume(): 在活动准备好和用户进行交互时调用"></a>3.onResume(): 在活动准备好和用户进行交互时调用</h4><h4 id="4-onPause-在系统准备启动或者恢复另一个活动时调用"><a href="#4-onPause-在系统准备启动或者恢复另一个活动时调用" class="headerlink" title="4.onPause(): 在系统准备启动或者恢复另一个活动时调用"></a>4.onPause(): 在系统准备启动或者恢复另一个活动时调用</h4><h4 id="5-onStop-在活动完全不可见时调用"><a href="#5-onStop-在活动完全不可见时调用" class="headerlink" title="5.onStop(): 在活动完全不可见时调用"></a>5.onStop(): 在活动完全不可见时调用</h4><h4 id="6-onDestory-在活动被销毁时调用"><a href="#6-onDestory-在活动被销毁时调用" class="headerlink" title="6.onDestory(): 在活动被销毁时调用"></a>6.onDestory(): 在活动被销毁时调用</h4><h4 id="7-onRestart-在活动由停止状态变为运行状态时调用"><a href="#7-onRestart-在活动由停止状态变为运行状态时调用" class="headerlink" title="7.onRestart(): 在活动由停止状态变为运行状态时调用"></a>7.onRestart(): 在活动由停止状态变为运行状态时调用</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200919221411685.png" alt="image-20200919221411685" style="zoom: 67%;">

<p>​    完整生存期：onCreate() → onDestory()</p>
<p>​    可见生存期：onStart() → onStop()</p>
<p>​    前台生存期：onResume() → onPause()</p>
<h3 id="四、体验活动的生命周期"><a href="#四、体验活动的生命周期" class="headerlink" title="四、体验活动的生命周期"></a>四、体验活动的生命周期</h3><h4 id="1-新建两个活动分别为-NormalActicity-和-DialogActivity"><a href="#1-新建两个活动分别为-NormalActicity-和-DialogActivity" class="headerlink" title="1.新建两个活动分别为 NormalActicity 和 DialogActivity"></a>1.新建两个活动分别为 NormalActicity 和 DialogActivity</h4><h4 id="2-修改对话框活动的主题："><a href="#2-修改对话框活动的主题：" class="headerlink" title="2.修改对话框活动的主题："></a>2.修改对话框活动的主题：</h4><ol>
<li><h5 id="AppCompatActivity-android-theme-”-style-Theme-AppCompat-Dialog”"><a href="#AppCompatActivity-android-theme-”-style-Theme-AppCompat-Dialog”" class="headerlink" title="AppCompatActivity: android:theme=”@style/Theme.AppCompat.Dialog”"></a><font color="red">AppCompatActivity</font>: <strong>android:theme=”@style/Theme.AppCompat.Dialog”</strong></h5></li>
<li><h5 id="Activity-android-theme-”-android-style-Theme-Dialog”"><a href="#Activity-android-theme-”-android-style-Theme-Dialog”" class="headerlink" title="Activity:android:theme=”@android:style/Theme.Dialog”"></a><font color="red">Activity:android</font>:<strong>theme=”@android:style/Theme.Dialog”</strong></h5></li>
</ol>
<h4 id="3-在主活动中打印日志（充分利用日志过滤器）"><a href="#3-在主活动中打印日志（充分利用日志过滤器）" class="headerlink" title="3.在主活动中打印日志（充分利用日志过滤器）"></a>3.在主活动中打印日志（充分利用日志过滤器）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200919222550069.png" alt="image-20200919222550069"></p>
<h5 id="（1）可以看到，MainActivity-第一次被创建时会依次执行-onCreate-、onStart-和-onResume-方法；"><a href="#（1）可以看到，MainActivity-第一次被创建时会依次执行-onCreate-、onStart-和-onResume-方法；" class="headerlink" title="（1）可以看到，MainActivity 第一次被创建时会依次执行 onCreate()、onStart() 和 onResume()方法；"></a>（1）可以看到，MainActivity 第一次被创建时会依次执行 onCreate()、onStart() 和 onResume()方法；</h5><h5 id="（2）启动NormalActivity-会执行-onPause-和-onStop-因为NormalActivity已经完全遮住MainActivity了；"><a href="#（2）启动NormalActivity-会执行-onPause-和-onStop-因为NormalActivity已经完全遮住MainActivity了；" class="headerlink" title="（2）启动NormalActivity,会执行 onPause() 和 onStop(),因为NormalActivity已经完全遮住MainActivity了；"></a>（2）启动NormalActivity,会执行 onPause() 和 onStop(),因为NormalActivity已经完全遮住MainActivity了；</h5><h5 id="（3）返回MainActivity，会执行-onRestart-、onStart-和onResume"><a href="#（3）返回MainActivity，会执行-onRestart-、onStart-和onResume" class="headerlink" title="（3）返回MainActivity，会执行 onRestart()、onStart()和onResume();"></a>（3）返回MainActivity，会执行 onRestart()、onStart()和onResume();</h5><h5 id="（4）启动DialogActivity-只会执行onPause-方法，因为此时MainActivity没有完全遮住；"><a href="#（4）启动DialogActivity-只会执行onPause-方法，因为此时MainActivity没有完全遮住；" class="headerlink" title="（4）启动DialogActivity,只会执行onPause()方法，因为此时MainActivity没有完全遮住；"></a>（4）启动DialogActivity,只会执行onPause()方法，因为此时MainActivity没有完全遮住；</h5><h5 id="（5）返回MainActivity-只会执行onResume。"><a href="#（5）返回MainActivity-只会执行onResume。" class="headerlink" title="（5）返回MainActivity,只会执行onResume。"></a>（5）返回MainActivity,只会执行onResume。</h5><h3 id="五、活动被回收了怎么办"><a href="#五、活动被回收了怎么办" class="headerlink" title="五、活动被回收了怎么办"></a>五、活动被回收了怎么办</h3><h4 id="1-问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate-创建一个新的实例，造成数据的丢失。"><a href="#1-问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate-创建一个新的实例，造成数据的丢失。" class="headerlink" title="1.问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate()创建一个新的实例，造成数据的丢失。"></a>1.问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate()创建一个新的实例，造成数据的丢失。</h4><h4 id="2-通过onSaveInstanceState-回调方法保存数据"><a href="#2-通过onSaveInstanceState-回调方法保存数据" class="headerlink" title="2.通过onSaveInstanceState()回调方法保存数据"></a>2.通过<font color="red">onSaveInstanceState()</font>回调方法保存数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@0verride</span><br><span class="line">protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">	super.onSaveInstancestate(outState);</span><br><span class="line">	string tempData - &quot;Something you just typed&quot;;</span><br><span class="line">	outState.putString( &quot;data_key&quot; , tempData) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="-3"><a href="#-3" class="headerlink" title></a></h4><h4 id="3-在onCreate-中取值"><a href="#3-在onCreate-中取值" class="headerlink" title="3.在onCreate()中取值"></a>3.在onCreate()中取值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (savedInstancestate != null)&#123;</span><br><span class="line">	String tempData = savedInstanceState.getString(&quot;data_key&quot;);</span><br><span class="line">	Log.d(TAG,tempData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="活动的启动模式-（launchMode"><a href="#活动的启动模式-（launchMode" class="headerlink" title="活动的启动模式 （launchMode)"></a>活动的启动模式 （launchMode)</h2><h3 id="一、standard"><a href="#一、standard" class="headerlink" title="一、standard"></a>一、standard</h3><h4 id="1-standard是活动默认的启动模式"><a href="#1-standard是活动默认的启动模式" class="headerlink" title="1.standard是活动默认的启动模式"></a>1.standard是活动默认的启动模式</h4><p>​        每当启动一个新的活动，它就会在返回栈中人栈，并处于栈顶的位置。对于使用standard模式的活动，</p>
<p>​        系统不会在乎这个活动是否已经在返回栈中存在<font color="red">，每次启动都会创建该活动的一个新的实例</font>。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131226413.png" alt="image-20200922131226413" style="zoom: 67%;"></h4><h3 id="二、singleTop"><a href="#二、singleTop" class="headerlink" title="二、singleTop"></a>二、singleTop</h3><h4 id="1-当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。"><a href="#1-当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。" class="headerlink" title="1.当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。"></a>1.当活动的启动模式指定为singleTop，在启动活动时如果发现<font color="red">返回栈的栈顶已经是该活动</font>，则认为可以<font color="red">直接使用</font>它，不会再创建新的活动实例。</h4><h4 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131614840.png" alt="image-20200922131614840" style="zoom: 67%;"></h4><h3 id="三、singleTask"><a href="#三、singleTask" class="headerlink" title="三、singleTask"></a>三、singleTask</h3><h4 id="1-当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。"><a href="#1-当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。" class="headerlink" title="1.当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。"></a>1.当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则<font color="red">直接使用该实例，并把在这个活动之上的所有活动统统出栈</font>，如果没有发现就会创建一个新的活动实例。</h4><h4 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131805919.png" alt="image-20200922131805919" style="zoom: 67%;"></h4><h3 id="四、singleInstance"><a href="#四、singleInstance" class="headerlink" title="四、singleInstance"></a>四、singleInstance</h3><h4 id="1-指定为singleInstance的活动会启动一个新的返回栈，"><a href="#1-指定为singleInstance的活动会启动一个新的返回栈，" class="headerlink" title="1.指定为singleInstance的活动会启动一个新的返回栈，"></a>1.指定为singleInstance的活动会启动一个新的返回栈，</h4><p>在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了<font color="red">共享活动实例</font>的问题。</p>
<h4 id="2-3"><a href="#2-3" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922132137611.png" alt="image-20200922132137611" style="zoom:67%;"></h4><h2 id="活动的最佳实践"><a href="#活动的最佳实践" class="headerlink" title="活动的最佳实践"></a>活动的最佳实践</h2><h1 id="第三章-UI开发的点点滴滴"><a href="#第三章-UI开发的点点滴滴" class="headerlink" title="第三章 UI开发的点点滴滴"></a>第三章 UI开发的点点滴滴</h1><h2 id="如何编写程序界面"><a href="#如何编写程序界面" class="headerlink" title="如何编写程序界面"></a>如何编写程序界面</h2><h2 id="常用控件的使用方法"><a href="#常用控件的使用方法" class="headerlink" title="常用控件的使用方法"></a>常用控件的使用方法</h2><h3 id="一、TextView"><a href="#一、TextView" class="headerlink" title="一、TextView"></a>一、<font color="cornflowerblue">TextView</font></h3><h4 id="1-文本对齐方式-gravity"><a href="#1-文本对齐方式-gravity" class="headerlink" title="1.文本对齐方式(gravity)"></a>1.文本对齐方式(<font color="red">gravity</font>)</h4><h5 id="android-gravity-”center-top-bottom-left-right”"><a href="#android-gravity-”center-top-bottom-left-right”" class="headerlink" title="android: gravity=”center|top|bottom|left|right”"></a>android: gravity=”center|top|bottom|left|right”</h5><h4 id="2-文本颜色，大小（textColor、textSize）"><a href="#2-文本颜色，大小（textColor、textSize）" class="headerlink" title="2.文本颜色，大小（textColor、textSize）"></a>2.文本颜色，大小（<font color="red">textColor、textSize</font>）</h4><h5 id="字体以“sp”为单位"><a href="#字体以“sp”为单位" class="headerlink" title="字体以“sp”为单位"></a>字体以“sp”为单位</h5><h4 id="3-文本标签TextView其它的XML文件元素"><a href="#3-文本标签TextView其它的XML文件元素" class="headerlink" title="3.文本标签TextView其它的XML文件元素"></a>3.文本标签TextView其它的XML文件元素</h4><table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:autoLink</td>
<td>设置是否当文本为URL链接/email/电话号码/map时，文本显示为可单击的链接。可选值(none/web/email/phone/map/all)</td>
</tr>
<tr>
<td>android:autoText</td>
<td>如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。</td>
</tr>
<tr>
<td>android:linksClickable</td>
<td>设置链接是否单击连接，即使设置了autoLink。</td>
</tr>
<tr>
<td>android:maxLength</td>
<td>限制显示的文本长度，超出部分不显示。</td>
</tr>
<tr>
<td>android:lines</td>
<td>设置文本的行数，设置两行就显示两行，即使第二行没有数据。</td>
</tr>
<tr>
<td>android:maxLines</td>
<td>设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。</td>
</tr>
<tr>
<td>android:minLines</td>
<td>设置文本的最小行数，与lines类似。</td>
</tr>
<tr>
<td>android:lineSpacingExtra</td>
<td>设置行间距。</td>
</tr>
<tr>
<td>android:lineSpacingMultiplier</td>
<td>设置行间距的倍数。如”1.2”</td>
</tr>
<tr>
<td>android:textColor</td>
<td>设置文本颜色</td>
</tr>
<tr>
<td>android:textColorLink</td>
<td>文字链接的颜色.</td>
</tr>
<tr>
<td>android:textStyle</td>
<td>设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开</td>
</tr>
<tr>
<td>android:maxHeight</td>
<td>设置文本区域的最大高度</td>
</tr>
<tr>
<td>android:minHeight</td>
<td>设置文本区域的最小高度</td>
</tr>
<tr>
<td>android:minWidth</td>
<td>设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。</td>
</tr>
<tr>
<td>android:maxWidth</td>
<td>设置文本区域的最大宽度</td>
</tr>
</tbody></table>
<h3 id="二、Button"><a href="#二、Button" class="headerlink" title="二、Button"></a>二、<font color="cornflowerblue">Button</font></h3><h4 id="1-自动进行大小写转换（textAllCaps"><a href="#1-自动进行大小写转换（textAllCaps" class="headerlink" title="1.自动进行大小写转换（textAllCaps)"></a>1.自动进行大小写转换（<font color="red">textAllCaps</font>)</h4><h5 id="android-textALlCaps-”false-true”"><a href="#android-textALlCaps-”false-true”" class="headerlink" title="android: textALlCaps:”false|true”"></a>android: textALlCaps:”false|true”</h5><h4 id="2-4种事件监听器的注册方式"><a href="#2-4种事件监听器的注册方式" class="headerlink" title="2. 4种事件监听器的注册方式"></a>2. 4种事件监听器的注册方式</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141303023.png" alt="image-20200923141303023" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141336930.png" alt="image-20200923141336930" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141506965.png" alt="image-20200923141506965" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141521823.png" alt="image-20200923141521823" style="zoom:67%;">



<h3 id="三、EditText"><a href="#三、EditText" class="headerlink" title="三、EditText"></a>三、<font color="cornflowerblue">EditText</font></h3><h4 id="1-提示性文字（hint"><a href="#1-提示性文字（hint" class="headerlink" title="1.提示性文字（hint)"></a>1.提示性文字（<font color="red">hint</font>)</h4><h4 id="2-最大行数（maxLines）"><a href="#2-最大行数（maxLines）" class="headerlink" title="2.最大行数（maxLines）"></a>2.最大行数（<font color="red">maxLines</font>）</h4><h4 id="3-密码框（android-inputType-”TextPassword”）"><a href="#3-密码框（android-inputType-”TextPassword”）" class="headerlink" title="3.密码框（android: inputType=”TextPassword”）"></a>3.密码框（<font color="red">android: inputType=”TextPassword”</font>）</h4><h4 id="4-获取文本内容（-getText-toString-）"><a href="#4-获取文本内容（-getText-toString-）" class="headerlink" title="4.获取文本内容（,,, .getText().toString( )  ）"></a>4.获取文本内容（<font color="red">,,, .getText().toString( )</font>  ）</h4><h4 id="5-输入框EditText-其它的XML文件元素"><a href="#5-输入框EditText-其它的XML文件元素" class="headerlink" title="5.输入框EditText 其它的XML文件元素"></a>5.输入框EditText 其它的XML文件元素</h4><table>
<thead>
<tr>
<th><strong>属性名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>android:<strong>imeOptions</strong></td>
<td><strong>设置软键盘的<strong><strong>Enter</strong></strong>键</strong>。有如下值可设置：normal，actionUnspecified，actionNone，actionGo，actionSearch，actionSend，actionNext，actionDone，flagNoExtractUi，flagNoAccessoryAction，flagNoEnterAction。可用’|’设置多个。这里仅设置显示图标之用。</td>
</tr>
<tr>
<td>android:imeActionId</td>
<td>设置IME动作ID，在onEditorAction中捕获判断进行逻辑操作。</td>
</tr>
<tr>
<td>android:imeActionLabel</td>
<td>设置IME动作标签。但是不能保证一定会使用，猜想在输入法扩展的时候应该有用。</td>
</tr>
<tr>
<td>android:<strong>singleLine</strong></td>
<td>设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=”test_ singleLine “ android:singleLine=”true” android:layout_width=”20dp” 将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行</td>
</tr>
<tr>
<td>android:<strong>maxlines</strong></td>
<td>指定 EditText 的最大行数，当输入的内容超过指定最大行数时，文本就会向上滚动，而不继续拉伸EditText</td>
</tr>
</tbody></table>
<h3 id="四、ImageView"><a href="#四、ImageView" class="headerlink" title="四、ImageView"></a>四、<font color="cornflowerblue">ImageView</font></h3><h4 id="1-android-src"><a href="#1-android-src" class="headerlink" title="1.android:src"></a>1.android:src</h4><h4 id="2-android-background"><a href="#2-android-background" class="headerlink" title="2. android:background"></a>2. android:background</h4><h4 id="3-setImageResource-方法"><a href="#3-setImageResource-方法" class="headerlink" title="3.setImageResource()方法"></a>3.setImageResource()方法</h4><h3 id="五、ProgressBar-进度条"><a href="#五、ProgressBar-进度条" class="headerlink" title="五、ProgressBar (进度条)"></a>五、<font color="cornflowerblue">ProgressBar </font>(进度条)</h3><h4 id="1-（控件通用属性）visibility-”visiblle-invisible-gone”"><a href="#1-（控件通用属性）visibility-”visiblle-invisible-gone”" class="headerlink" title="1.（控件通用属性）visibility=”visiblle|invisible|gone”"></a>1.（控件通用属性）<font color="red">visibility</font>=”visiblle|invisible|gone”</h4><h4 id="2-代码中获取-控制控件可见性"><a href="#2-代码中获取-控制控件可见性" class="headerlink" title="2.代码中获取/控制控件可见性"></a>2.代码中获取/控制控件可见性</h4><p>​            获取：getVisibility()</p>
<p>​            设置：setVisibility(<font color="red">View.VISIBLE|View.INVISIBLE|View.GONE</font>)</p>
<h4 id="3-水平进度条"><a href="#3-水平进度条" class="headerlink" title="3.水平进度条"></a>3.水平进度条</h4><h5 id="（1）style-”-android-attr-progressBarStyleHorizontal”-类别"><a href="#（1）style-”-android-attr-progressBarStyleHorizontal”-类别" class="headerlink" title="（1）style=”?android:attr/progressBarStyleHorizontal”    //类别"></a>（1）style=”?android:attr/progressBarStyleHorizontal”    //类别</h5><h5 id="android-max-”100”-进度条最大值"><a href="#android-max-”100”-进度条最大值" class="headerlink" title="android:max=”100”    //进度条最大值"></a>android:max=”100”    //进度条最大值</h5><h5 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922172028074.png" alt="image-20200922172028074" style="zoom:50%;"></h5><h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><h4 id="-4"><a href="#-4" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141825784.png" alt="image-20200923141825784" style="zoom:50%;"></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141850913.png" alt="image-20200923141850913" style="zoom:50%;">

<h3 id="六、AlterDialog（对话框）"><a href="#六、AlterDialog（对话框）" class="headerlink" title="六、AlterDialog（对话框）"></a>六、<font color="cornflowerblue">AlterDialog</font>（对话框）</h3><h4 id="1-AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog-一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示"><a href="#1-AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog-一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示" class="headerlink" title="1.AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示:"></a>1.AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示:</h4><h4 id="2-4"><a href="#2-4" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922172454707.png" alt="image-20200922172454707" style="zoom:67%;"></h4><p>​            首先通过<font color="red">AlertDialog.Builder</font>创建一个AlertDialog 的实例,然后可以为这个对话框设置标题、<br>​    内容、可否取消等属性，接下来调用<font color="red">setPositiveButton()</font>方法为对话框设置确定按钮的点击<br>​    事件，调用<font color="red">setNegativeButton()</font>方法设置取消按钮的点击事件，最后调用<font color="red">show()</font>方法将对话<br>​    框显示出来。</p>
<h3 id="七、ProgressDialog-带进度条的提示框"><a href="#七、ProgressDialog-带进度条的提示框" class="headerlink" title="七、ProgressDialog(带进度条的提示框)"></a>七、<font color="cornflowerblue">ProgressDialog</font>(带进度条的提示框)</h3><h4 id="1-ProgressDialog-和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog-会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog-也比较相似"><a href="#1-ProgressDialog-和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog-会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog-也比较相似" class="headerlink" title="1.ProgressDialog 和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog 也比较相似"></a>1.ProgressDialog 和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog 也比较相似</h4><h4 id="2-5"><a href="#2-5" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922173459763.png" alt="image-20200922173459763" style="zoom:67%;"></h4><p>注意，如果在<font color="red">setCancelable()中传人了false</font>，表示ProgressDialog是不能通过Back键<br>取消掉的，这时你就一定要在代码中做好控制，当数据加载完成后必须要调用ProgressDialog 的<br>dismiss()方法来关闭对话框，否则ProgressDialog将会一直存在。</p>
<h3 id="八、RadioButton-单选按钮-和-Checkbox-复选框"><a href="#八、RadioButton-单选按钮-和-Checkbox-复选框" class="headerlink" title="八、RadioButton(单选按钮) 和 Checkbox(复选框)"></a>八、<font color="cornflowerblue">RadioButton(单选按钮) 和 Checkbox(复选框)</font></h3><h3 id="九、Spinner-下拉框"><a href="#九、Spinner-下拉框" class="headerlink" title="九、Spinner (下拉框)"></a>九、<font color="cornflowerblue">Spinner (下拉框)</font></h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142240994.png" alt="image-20200923142240994" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142315034.png" alt="image-20200923142315034" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142334764.png" alt="image-20200923142334764" style="zoom:67%;">



<h2 id="详解4种基本布局"><a href="#详解4种基本布局" class="headerlink" title="详解4种基本布局"></a>详解4种基本布局</h2><h3 id="一、线性布局（LinearLayout）"><a href="#一、线性布局（LinearLayout）" class="headerlink" title="一、线性布局（LinearLayout）"></a>一、线性布局（<font color="cornflowerblue">LinearLayout</font>）</h3><h4 id="1-排列方向orientation"><a href="#1-排列方向orientation" class="headerlink" title="1.排列方向orientation"></a>1.排列方向<font color="red">orientation</font></h4><h5 id="1-horizontal-2-vertical"><a href="#1-horizontal-2-vertical" class="headerlink" title="(1)horizontal        (2)vertical"></a>(1)horizontal        (2)vertical</h5><p>​    </p>
<h4 id="2-对齐方式"><a href="#2-对齐方式" class="headerlink" title="2.对齐方式"></a>2.对齐方式</h4><h5 id="（1）gravity-文字在控件中的对齐方式"><a href="#（1）gravity-文字在控件中的对齐方式" class="headerlink" title="（1）gravity: 文字在控件中的对齐方式"></a>（1）gravity: <font color="orange">文字在控件中</font>的对齐方式</h5><h5 id="（2）layout-gravity-控件在布局中的对齐方式"><a href="#（2）layout-gravity-控件在布局中的对齐方式" class="headerlink" title="（2）layout_gravity: 控件在布局中的对齐方式"></a>（2）<font color="red">layout_gravity</font>: <font color="orange">控件在布局中</font>的对齐方式</h5><p>​                top、bottom、left、right、center_vertical、center_horizontal</p>
<p>​        <strong>！注意</strong>：LinearLayout的排列方向是horizontal时，只有垂直方向上的对齐方式才会生效，因为此时    水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式。同样的道理，当LinearLayout的排列方向是vertical时，只有水平方向上的对齐方式才会生效。</p>
<h4 id="3-重要属性-layout-weight"><a href="#3-重要属性-layout-weight" class="headerlink" title="3.重要属性 layout_weight"></a>3.重要属性 <font color="red">layout_weight</font></h4><h5 id="1-允许我们使用比例的方式来指定控件的大小-它在手机屏幕的适配性方面可以起到非常重要"><a href="#1-允许我们使用比例的方式来指定控件的大小-它在手机屏幕的适配性方面可以起到非常重要" class="headerlink" title="(1)允许我们使用比例的方式来指定控件的大小,它在手机屏幕的适配性方面可以起到非常重要"></a>(1)允许我们使用<font color="red">比例的方式</font>来指定控件的大小,它在手机屏幕的适配性方面可以起到非常重要</h5><h5 id="2-定义水平-垂直方向的比例时，需要指定layout-width-”0dp”-layout-height-”0dp”"><a href="#2-定义水平-垂直方向的比例时，需要指定layout-width-”0dp”-layout-height-”0dp”" class="headerlink" title="(2)定义水平/垂直方向的比例时，需要指定layout_width=”0dp”/layout_height=”0dp”"></a>(2)定义水平/垂直方向的比例时，需要指定<font color="red">layout_width=”0dp”/layout_height=”0dp”</font></h5><h5 id="-5"><a href="#-5" class="headerlink" title></a></h5><h3 id="二、相对布局"><a href="#二、相对布局" class="headerlink" title="二、相对布局"></a>二、相对布局</h3><h4 id="1-相对于父布局进行定位"><a href="#1-相对于父布局进行定位" class="headerlink" title="1.相对于父布局进行定位"></a>1.相对于<font color="red">父布局</font>进行定位</h4><table>
<thead>
<tr>
<th align="left"><strong>属性声明</strong></th>
<th align="center"><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>android:layout_alignParentLeft</strong></td>
<td align="center">是否跟父布局左对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentRight</strong></td>
<td align="center">是否跟父布局右对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentTop</strong></td>
<td align="center">是否跟父布局顶部对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentBottom</strong></td>
<td align="center">是否跟父布局底部对齐</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerHorizontal</strong></td>
<td align="center">在父布局中水平居中</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerVertical</strong></td>
<td align="center">在父布局中垂直居中</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerInParent</strong></td>
<td align="center">在父布局的中间位置</td>
</tr>
</tbody></table>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922224343384.png" alt="image-20200922224343384" style="zoom: 33%;">



<h4 id="2-相对于兄弟组件定位"><a href="#2-相对于兄弟组件定位" class="headerlink" title="2.相对于兄弟组件定位"></a>2.相对于<font color="red">兄弟组件</font>定位</h4><p>​        </p>
<table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>android:layout_toRightOf</strong>=“控件id”</td>
<td>在指定控件右边</td>
</tr>
<tr>
<td><strong>android:layout_toLeftOf</strong>=“控件id”</td>
<td>在指定控件左边</td>
</tr>
<tr>
<td><strong>android:layout_above</strong>=“控件id”</td>
<td>在指定控件上边</td>
</tr>
<tr>
<td><strong>android:layout_below=“控件id”</strong></td>
<td>在指定控件下边</td>
</tr>
<tr>
<td><strong>android:layout_alignBaseline</strong>=“控件id”</td>
<td>与指定控件水平对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignLeft</strong>=“控件id”</td>
<td>与指定控件左对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignRight</strong>=“控件id”</td>
<td>与指定控件右对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignTop</strong>=“控件id”</td>
<td>与指定控件顶部对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignBottom</strong>=“控件id”</td>
<td>与指定控件底部对齐</td>
</tr>
</tbody></table>
<h4 id="3-margin-偏移-：设置组件与相对于的边距"><a href="#3-margin-偏移-：设置组件与相对于的边距" class="headerlink" title="3. margin(偏移)：设置组件与相对于的边距"></a>3.<font color="red"> margin(偏移)</font>：设置组件与相对于的边距</h4><table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>layout_margin</strong></td>
<td>设置组件上下左右的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginLeft</strong></td>
<td>设置组件离左边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginRight</strong></td>
<td>设置组件离右边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginTop</strong></td>
<td>设置组件离上边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginBottom</strong></td>
<td>设置组件离下边的偏移量</td>
</tr>
</tbody></table>
<h4 id="4-padding-填充-：设置组件内部元素间的边距"><a href="#4-padding-填充-：设置组件内部元素间的边距" class="headerlink" title="4.padding(填充)：设置组件内部元素间的边距"></a>4.<font color="red">padding(填充)</font>：设置组件内部元素间的边距</h4><table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>padding</strong></td>
<td>设置组件上下左右的偏移量</td>
</tr>
<tr>
<td><strong>paddingLeft</strong></td>
<td>设置组件离左边的偏移量</td>
</tr>
<tr>
<td><strong>paddingRight</strong></td>
<td>设置组件离右边的偏移量</td>
</tr>
<tr>
<td><strong>paddingTop</strong></td>
<td>设置组件离上边的偏移量</td>
</tr>
<tr>
<td><strong>paddingBottom</strong></td>
<td>设置组件离下边的偏移量</td>
</tr>
</tbody></table>
<h5 id="！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。"><a href="#！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。" class="headerlink" title="！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。"></a>！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。</h5><h3 id="三、帧布局"><a href="#三、帧布局" class="headerlink" title="三、帧布局"></a>三、帧布局</h3><h3 id="四、百分百布局"><a href="#四、百分百布局" class="headerlink" title="四、百分百布局"></a>四、百分百布局</h3><h4 id="1-percentFrameLayout-继承了FrameLayout的全部特性"><a href="#1-percentFrameLayout-继承了FrameLayout的全部特性" class="headerlink" title="1.percentFrameLayout: 继承了FrameLayout的全部特性"></a>1.<font color="red">percentFrameLayout</font>: 继承了FrameLayout的全部特性</h4><h4 id="percentRelativeLayout-继承了RelativeLayout的全部特性"><a href="#percentRelativeLayout-继承了RelativeLayout的全部特性" class="headerlink" title="percentRelativeLayout: 继承了RelativeLayout的全部特性"></a><font color="red">percentRelativeLayout</font>: 继承了RelativeLayout的全部特性</h4><h4 id="2-设置组件的宽高"><a href="#2-设置组件的宽高" class="headerlink" title="2.设置组件的宽高"></a>2.设置组件的宽高</h4><h5 id="app-layout-widthPercent-”-”"><a href="#app-layout-widthPercent-”-”" class="headerlink" title="app: layout_widthPercent=”..%”"></a>app: <font color="red">layout_widthPercent</font>=”..%”</h5><h5 id="app-layout-heightPercent-“-”"><a href="#app-layout-heightPercent-“-”" class="headerlink" title="app: layout_heightPercent=“..%”"></a>app: layout_heightPercent=“..%”</h5><h4 id="3-在项目的build-gradle中添加百分比布局库的依赖-保证百分比布局在Android所有系统版本上的兼容性"><a href="#3-在项目的build-gradle中添加百分比布局库的依赖-保证百分比布局在Android所有系统版本上的兼容性" class="headerlink" title="3.在项目的build.gradle中添加百分比布局库的依赖,保证百分比布局在Android所有系统版本上的兼容性"></a>3.在项目的build.gradle中添加百分比布局库的依赖,保证百分比布局在Android所有系统版本上的兼容性</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922230757044.png" alt="image-20200922230757044"></p>
<h4 id="4-使用百分比布局"><a href="#4-使用百分比布局" class="headerlink" title="4.使用百分比布局"></a>4.使用百分比布局</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922230933563.png" alt="image-20200922230933563"></p>
<h2 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h2><h3 id="1-引入布局"><a href="#1-引入布局" class="headerlink" title="1.引入布局"></a>1.引入布局</h3><h4 id="（1）创建一个标题栏布局title-xml文件"><a href="#（1）创建一个标题栏布局title-xml文件" class="headerlink" title="（1）创建一个标题栏布局title.xml文件"></a>（1）创建一个标题栏布局title.xml文件</h4><h4 id="（2）在活动中引用-lt-include-layout-“-layout-title”-gt"><a href="#（2）在活动中引用-lt-include-layout-“-layout-title”-gt" class="headerlink" title="（2）在活动中引用  &lt;include layout = “@layout/title”/ &gt;"></a>（2）在活动中引用  <font color="red">&lt;include layout = “@layout/title”/ &gt;</font></h4><h4 id="3-隐藏系统自带的标题栏"><a href="#3-隐藏系统自带的标题栏" class="headerlink" title="(3) 隐藏系统自带的标题栏"></a>(3) 隐藏系统自带的标题栏</h4><h4 id="ActionBar-actionbar-getSupportActionBar"><a href="#ActionBar-actionbar-getSupportActionBar" class="headerlink" title="ActionBar actionbar = getSupportActionBar("></a><font color="red">ActionBar actionbar = getSupportActionBar(</font></h4><pre><code>    &lt;font color=&#39;red&#39;&gt;if (actionbar !=null) &#123;&lt;/font&gt;
        &lt;font color=&#39;red&#39;&gt;actionbar.hide( );&lt;/font&gt;
    &lt;font color=&#39;red&#39;&gt;&#125;&lt;/font&gt;
</code></pre>
<h3 id="2-创建自定义控件（布局）"><a href="#2-创建自定义控件（布局）" class="headerlink" title="2.创建自定义控件（布局）"></a>2.创建自定义控件（布局）</h3><h4 id="（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题-但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。"><a href="#（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题-但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。" class="headerlink" title="（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题,但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。"></a>（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题,但是如果布局中有一些控件<font color="red">要求能够响应事件</font>，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用<font color="red">自定义控件</font>的方式来解决。</h4><h4 id="（2）创建一个自定义布局类-TitleLayout-包含组件的响应事件"><a href="#（2）创建一个自定义布局类-TitleLayout-包含组件的响应事件" class="headerlink" title="（2）创建一个自定义布局类 TitleLayout(包含组件的响应事件)"></a>（2）创建一个自定义布局类 TitleLayout(包含组件的响应事件)</h4><p>public class TitleLayout extends LinearLayout {</p>
<p>​    public TitleLayout(Context context，AttributeSet attrs) {<br>​            super(context,attrs);<br>​            <font color="red">LayoutInflater.from(context).inflate(R.layout.title, this);</font>    //动态加载布局文件</p>
<p>​                                                                        //布局id， 父布局</p>
<p>​            Button titleBack = (Button) findViewById(R.id.title_back);<br>​            Button titleEdit = (Button) findViewById(R.id.title_edit);<br>​            titleBack.setOnclickListener(new onclickListener(){<br>​                @override<br>​                public void onclick(View v) {<br>​                        <font color="red">( (Activity) getContext()).finish();</font>    //结束此次活动<br>​                }<br>​            });<br>​            titleEdit.setonclickListener(new OnclickListener() {<br>​                @override<br>​                public void onclick(View v){<br>​                Toast.makeText(getContext()，”You clicked Edit button”,<br>​                Toast.LENGTH_SHORT).show();<br>​                });</p>
<p>​        }</p>
<p>}</p>
<h4 id="3-在布局文件中添加这个自定义控件"><a href="#3-在布局文件中添加这个自定义控件" class="headerlink" title="3.在布局文件中添加这个自定义控件"></a>3.在布局文件中添加这个自定义控件</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200930140657613.png" alt="image-20200930140657613"></p>
<h5 id="添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我"><a href="#添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我" class="headerlink" title="添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我"></a>添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我</h5><pre><code>们需要指明&lt;font color=&#39;red&#39;&gt;控件的完整类名&lt;/font&gt;，&lt;font color=&#39;red&#39;&gt;包名在这里是不可以省略的&lt;/font&gt;。
</code></pre>
<h2 id="最常用和最难用的控件——ListView"><a href="#最常用和最难用的控件——ListView" class="headerlink" title="最常用和最难用的控件——ListView"></a>最常用和最难用的控件——ListView</h2><h3 id="一、ListView的简单用法"><a href="#一、ListView的简单用法" class="headerlink" title="一、ListView的简单用法"></a>一、ListView的简单用法</h3><h4 id="1-在布局中加入ListView控件"><a href="#1-在布局中加入ListView控件" class="headerlink" title="1.在布局中加入ListView控件"></a>1.在布局中加入ListView控件</h4><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193319537.png" alt="image-20201001193319537" style="zoom:67%;"></p>
<h4 id="2-准备数据（M）"><a href="#2-准备数据（M）" class="headerlink" title="2.准备数据（M）"></a>2.准备数据（M）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193518241.png" alt="image-20201001193518241"></p>
<h4 id="3-准备视图（V）"><a href="#3-准备视图（V）" class="headerlink" title="3.准备视图（V）"></a>3.准备视图（V）</h4><h5 id="ListView-listView-ListView-findViewById-R-id-list-view"><a href="#ListView-listView-ListView-findViewById-R-id-list-view" class="headerlink" title="ListView listView = (ListView) findViewById(R.id.list_view);"></a>ListView listView = (ListView) findViewById(R.id.list_view);</h5><h4 id="4-准备适配器-C"><a href="#4-准备适配器-C" class="headerlink" title="4.准备适配器(C)"></a>4.准备适配器(C)</h4><h5 id="ArrayAdapter-lt-String-gt-adapter-new-ArrayAdapter-lt-String-gt-MainActivity-this，-android-R-layout-simple-list-item-1-data"><a href="#ArrayAdapter-lt-String-gt-adapter-new-ArrayAdapter-lt-String-gt-MainActivity-this，-android-R-layout-simple-list-item-1-data" class="headerlink" title="ArrayAdapter&lt; String &gt;  adapter = new ArrayAdapter&lt; String&gt;(MainActivity.this，            android.R.layout.simple_list_item_1, data);"></a>ArrayAdapter&lt; String &gt;  adapter = new ArrayAdapter&lt; String&gt;(MainActivity.this，            android.R.layout.simple_list_item_1, data);</h5><ul>
<li>​    <font color="red">参数一：当前活动上下文</font></li>
<li>​    <font color="red">参数二：子项布局ID</font></li>
<li>​    <font color="red">参数三：数据数组</font></li>
</ul>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193946230.png" alt="image-20201001193946230" style="zoom:67%;">



<h3 id="二、定制ListView的界面"><a href="#二、定制ListView的界面" class="headerlink" title="二、定制ListView的界面"></a>二、定制ListView的界面</h3><h4 id="1-新建一个Fruit类，作为适配器的适配类型"><a href="#1-新建一个Fruit类，作为适配器的适配类型" class="headerlink" title="1.新建一个Fruit类，作为适配器的适配类型"></a>1.新建一个Fruit类，作为适配器的<font color="cornflowerblue">适配类型</font></h4><p>​    public class Fruit {<br>​            private String name;<br>​            private int imageId;</p>
<p>​            public Fruit(String name，int imageId) {<br>​                    this.name = name;<br>​                    this.imageId = imageId;<br>​            }<br>​            public String getName( ) {<br>​                    return name;</p>
<p>​            }</p>
<p>​            public int getImageId( ) {<br>​                    return imageId;</p>
<p>​            }</p>
<p>​    }</p>
<h4 id="2-自定义子项布局fruit-item-xml"><a href="#2-自定义子项布局fruit-item-xml" class="headerlink" title="2.自定义子项布局fruit_item.xml"></a>2.<font color="cornflowerblue">自定义子项布局</font>fruit_item.xml</h4><h5 id="-6"><a href="#-6" class="headerlink" title></a></h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201001194813625.png" alt="image-20201001194813625" style="zoom:67%;">



<h4 id="3-自定义适配器MyAdapter"><a href="#3-自定义适配器MyAdapter" class="headerlink" title="3.自定义适配器MyAdapter"></a>3.<font color="cornflowerblue">自定义适配器</font>MyAdapter</h4><p>​    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001195642103.png" alt="image-20201001195642103"></p>
<p>​    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001195931382.png" alt="image-20201001195931382"></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200025598.png" alt="image-20201001200025598" style="zoom:67%;">

<h4 id="-7"><a href="#-7" class="headerlink" title></a></h4><h4 id="4-初始化数据，创建数据列表"><a href="#4-初始化数据，创建数据列表" class="headerlink" title="4.初始化数据，创建数据列表"></a>4.初始化数据，创建数据列表</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200303132.png" alt="image-20201001200303132" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200312627.png" alt="image-20201001200312627" style="zoom: 80%;">



<h3 id="四、提升ListView的运行效率"><a href="#四、提升ListView的运行效率" class="headerlink" title="四、提升ListView的运行效率"></a>四、提升ListView的运行效率</h3><h4 id="1-重用convertView"><a href="#1-重用convertView" class="headerlink" title="1.重用convertView"></a>1.重用<font color="red">convertView</font></h4><h3 id="-8"><a href="#-8" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201004105237701.png" alt="image-20201004105237701" style="zoom: 80%;"></h3><h4 id="2-内部类ViewHolder对控件实例进行缓存"><a href="#2-内部类ViewHolder对控件实例进行缓存" class="headerlink" title="2.内部类ViewHolder对控件实例进行缓存"></a>2.内部类ViewHolder对控件实例进行缓存</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004105406460.png" alt="image-20201004105406460" style="zoom:80%;">

<h2 id="更强大的滚轮控件——RecyclerView"><a href="#更强大的滚轮控件——RecyclerView" class="headerlink" title="更强大的滚轮控件——RecyclerView"></a>更强大的滚轮控件——RecyclerView</h2><h3 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h3><h4 id="1-首先需要在项目的build-gradle中添加相应的依赖库"><a href="#1-首先需要在项目的build-gradle中添加相应的依赖库" class="headerlink" title="1.首先需要在项目的build.gradle中添加相应的依赖库"></a>1.首先需要在项目的build.gradle中添加相应的<font color="red">依赖库</font></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004130717161.png" alt="image-20201004130717161" style="zoom:80%;">

<h4 id="2-在布局中引用"><a href="#2-在布局中引用" class="headerlink" title="2.在布局中引用"></a>2.在布局中引用</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004130855069.png" alt="image-20201004130855069" style="zoom:80%;">



<h4 id="3-准备Fruit类、fruit-item-xml、"><a href="#3-准备Fruit类、fruit-item-xml、" class="headerlink" title="3.准备Fruit类、fruit_item.xml、"></a>3.准备Fruit类、fruit_item.xml、</h4><h4 id="4-为RecycleView准备一个适配器FruitAdapter-继承自RecyclerView-Adapter-并将泛型指定为FruitAdapter-ViewHolder"><a href="#4-为RecycleView准备一个适配器FruitAdapter-继承自RecyclerView-Adapter-并将泛型指定为FruitAdapter-ViewHolder" class="headerlink" title="4.为RecycleView准备一个适配器FruitAdapter,继承自RecyclerView.Adapter,并将泛型指定为FruitAdapter.ViewHolder"></a>4.为RecycleView准备一个适配器<font color="red">FruitAdapter</font>,继承自<font color="cornflowerblue">RecyclerView.Adapter,</font>并将泛型指定为<font color="cornflowerblue">FruitAdapter.ViewHolder</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004132129131.png" alt="image-20201004132129131"></p>
<h4 id="5-在活动中使用RecyclerView"><a href="#5-在活动中使用RecyclerView" class="headerlink" title="5.在活动中使用RecyclerView"></a>5.在活动中使用RecyclerView</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004160217803.png" alt="image-20201004160217803" style="zoom:80%;">

<h3 id="二、实现横向滚动和瀑布流布局"><a href="#二、实现横向滚动和瀑布流布局" class="headerlink" title="二、实现横向滚动和瀑布流布局"></a>二、实现横向滚动和瀑布流布局</h3><h4 id="1-横向滚动"><a href="#1-横向滚动" class="headerlink" title="1.横向滚动"></a>1.横向滚动</h4><h5 id="layoutManager-setOrientation-LineatLayoutManager-HORIZONTAL"><a href="#layoutManager-setOrientation-LineatLayoutManager-HORIZONTAL" class="headerlink" title="layoutManager.setOrientation(LineatLayoutManager.HORIZONTAL);"></a>layoutManager.<font color="red">setOrientation(LineatLayoutManager.HORIZONTAL);</font></h5><h4 id="2-瀑布流布局-StaggeredGridLayoutManager"><a href="#2-瀑布流布局-StaggeredGridLayoutManager" class="headerlink" title="2.瀑布流布局 StaggeredGridLayoutManager"></a>2.瀑布流布局 <font color="cornflowerblue">StaggeredGridLayoutManager</font></h4><h5 id="StaggeredGridLayoutManager-layoutManager-new-StaggeredGridLayoutManager-3-StaggeredGridLayoutManager-VERTICAL"><a href="#StaggeredGridLayoutManager-layoutManager-new-StaggeredGridLayoutManager-3-StaggeredGridLayoutManager-VERTICAL" class="headerlink" title="StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager (3, StaggeredGridLayoutManager.VERTICAL);"></a>StaggeredGridLayoutManager layoutManager = new <font color="red">StaggeredGridLayoutManager (3, StaggeredGridLayoutManager.VERTICAL)</font>;</h5><h5 id="recycleView-setLayoutManager-layoutManager"><a href="#recycleView-setLayoutManager-layoutManager" class="headerlink" title="recycleView.setLayoutManager(layoutManager);"></a>recycleView.setLayoutManager(layoutManager);</h5><p>​        </p>
<p>​    小技巧：设置不同长度文本</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004161014946.png" alt="image-20201004161014946" style="zoom:80%;">



<h3 id="三、RecyclerView的点击事件"><a href="#三、RecyclerView的点击事件" class="headerlink" title="三、RecyclerView的点击事件"></a>三、RecyclerView的点击事件</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004161141203.png" alt="image-20201004161141203"></p>
<h1 id="第四章-探究碎片"><a href="#第四章-探究碎片" class="headerlink" title="第四章 探究碎片"></a>第四章 探究碎片</h1><h2 id="碎片是什么"><a href="#碎片是什么" class="headerlink" title="碎片是什么"></a>碎片是什么</h2><h2 id="碎片的使用方式"><a href="#碎片的使用方式" class="headerlink" title="碎片的使用方式"></a>碎片的使用方式</h2><h3 id="一、静态使用Fragment"><a href="#一、静态使用Fragment" class="headerlink" title="一、静态使用Fragment"></a>一、<font color="cornflowerblue">静态使用</font>Fragment</h3><h4 id="1-这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。"><a href="#1-这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。" class="headerlink" title="1. 这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。"></a>1. 这是使用Fragment最简单的一种方式，把Fragment当成<font color="red">普通的控件</font>，直接写在Activity的布局文件中。</h4><h4 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h4><h5 id="（1）创建碎片布局文件-fragment-master-xml"><a href="#（1）创建碎片布局文件-fragment-master-xml" class="headerlink" title="（1）创建碎片布局文件 fragment_master.xml"></a>（1）创建碎片布局文件 <font color="orange">fragment_master.xml</font></h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153418988.png" alt="image-20201013153418988" style="zoom:80%;">

<h5 id="（2）创建碎片类MasterFragment-Java"><a href="#（2）创建碎片类MasterFragment-Java" class="headerlink" title="（2）创建碎片类MasterFragment.Java"></a>（2）创建碎片类<font color="orange">MasterFragment.Java</font></h5><p>​        使用inflater.inflate适配布局。实际应用中，也可以添加动态获取信息，绑定到布局控件中。</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153554997.png" alt="image-20201013153554997" style="zoom:80%;">

<p>​        ！补充：（1）（2）也可以通过<font color="red">向导新建</font>来实现</p>
<h5 id="（3）在布局文件中直接用创建好的Fragment控件"><a href="#（3）在布局文件中直接用创建好的Fragment控件" class="headerlink" title="（3）在布局文件中直接用创建好的Fragment控件"></a>（3）在布局文件中直接用创建好的Fragment控件</h5><p>​        要通过android:name 属性来显示的<font color="red">指明要添加的碎片类名</font></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153856622.png" alt="image-20201013153856622" style="zoom:80%;">



<h3 id="二、动态添加Fragment"><a href="#二、动态添加Fragment" class="headerlink" title="二、动态添加Fragment"></a>二、<font color="cornflowerblue">动态添加</font>Fragment</h3><h4 id="1-程序运行时根据具体情况，动态地添加Fragment到Activity活动中。"><a href="#1-程序运行时根据具体情况，动态地添加Fragment到Activity活动中。" class="headerlink" title="1.程序运行时根据具体情况，动态地添加Fragment到Activity活动中。"></a>1.程序运行时根据具体情况，<font color="red">动态地添加</font>Fragment到Activity活动中。</h4><h4 id="2-Fragment事务："><a href="#2-Fragment事务：" class="headerlink" title="2.Fragment事务："></a>2.<font color="orange">Fragment事务</font>：</h4><h5 id="（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。"><a href="#（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。" class="headerlink" title="（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。"></a>（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。</h5><pre><code>    （2）Android提供了&lt;font color=&#39;pink&#39;&gt;FragmentManager类&lt;/font&gt;管理Fragment：
    在Activity运行过程中，通过FragmentManager开启事务，通过调用&lt;font color=&#39;red&#39;&gt;add()，remove(), replace()&lt;/font&gt;实        现动态添加、删除、替换Fragement。
    FragmentManager使用&lt;font color=&#39;pink&#39;&gt;FragmentTransaction类&lt;/font&gt;来管理事务
</code></pre>
<h4 id="3-实现步骤"><a href="#3-实现步骤" class="headerlink" title="3.实现步骤"></a>3.实现步骤</h4><h5 id="（1）在上例基础上，新建一个碎片布局-fragment-another-xml及其类AnotherFragment-java"><a href="#（1）在上例基础上，新建一个碎片布局-fragment-another-xml及其类AnotherFragment-java" class="headerlink" title="（1）在上例基础上，新建一个碎片布局 fragment_another.xml及其类AnotherFragment.java"></a>（1）在上例基础上，新建一个碎片布局 fragment_another.xml及其类AnotherFragment.java</h5><h5 id="（2）修改MainActivity的布局文件acitivty-main-xml"><a href="#（2）修改MainActivity的布局文件acitivty-main-xml" class="headerlink" title="（2）修改MainActivity的布局文件acitivty_main.xml:"></a>（2）修改MainActivity的布局文件acitivty_main.xml:</h5><p>​            将右侧碎片替换成一个<font color="red">FrameLayout</font>布局。<br>​            <font color="orange">动态加载碎片时需要指定容器，一般使用FrameLayout。</font><br>​            随后可在代码中向FrameLayout中动态地添加碎片，在第一次运行时加载DetailFragement，单击按            钮后加载AnotherFragment</p>
<p>​        </p>
<h5 id="（3）在代码证动态加载碎片控件"><a href="#（3）在代码证动态加载碎片控件" class="headerlink" title="（3）在代码证动态加载碎片控件"></a>（3）在代码证动态加载碎片控件</h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155307418.png" alt="image-20201013155307418" style="zoom: 67%;">



<p>​        或者</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155506638.png" alt="image-20201013155506638" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155515431.png" alt="image-20201013155515431" style="zoom:80%;">

<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013160047336.png" alt="image-20201013160047336"></p>
<h4 id="4-在碎片中模拟返回栈"><a href="#4-在碎片中模拟返回栈" class="headerlink" title="4.在碎片中模拟返回栈"></a>4.在碎片中模拟返回栈</h4><h5 id="addToBackStack-用于将一个事务添加到返回栈"><a href="#addToBackStack-用于将一个事务添加到返回栈" class="headerlink" title="addToBackStack()用于将一个事务添加到返回栈"></a><font color="red">addToBackStack()</font>用于将一个事务添加到返回栈</h5><h4 id="5-碎片和活动之间进行通信"><a href="#5-碎片和活动之间进行通信" class="headerlink" title="5.碎片和活动之间进行通信"></a>5.碎片和活动之间进行通信</h4><h5 id="（1）在活动中获取碎片实例："><a href="#（1）在活动中获取碎片实例：" class="headerlink" title="（1）在活动中获取碎片实例："></a>（1）<font color="cornflowerblue">在活动中获取碎片实例：</font></h5><p>FramengtManager fm = getSupportFramengtManager();<br>DetailFragment frag = (DetailFragment)fm.<font color="red">findFragmentById</font>(R.id.fragment_detail);</p>
<h5 id="（2）在碎片中访问活动中的方法："><a href="#（2）在碎片中访问活动中的方法：" class="headerlink" title="（2）在碎片中访问活动中的方法："></a>（2）<font color="cornflowerblue">在碎片中访问活动中的方法：</font></h5><p>在碎片中直接通过调用getActivity()方法获得和当前碎片相关联的活动实例，例如：<br>MainActivity activity = (MainActivity)<font color="red">getActivity()</font>;</p>
<h2 id="碎片的生命周期"><a href="#碎片的生命周期" class="headerlink" title="碎片的生命周期"></a>碎片的生命周期</h2><h3 id="一、碎片的状态"><a href="#一、碎片的状态" class="headerlink" title="一、碎片的状态"></a>一、碎片的状态</h3><h4 id="1-运行状态："><a href="#1-运行状态：" class="headerlink" title="1.运行状态："></a>1.运行状态：</h4><p>当嵌入该Fragment的Activity是处于运行状态的，并且该Fragment是可见的，那么该Fragment是处于运行状态的。</p>
<h4 id="2-暂停状态："><a href="#2-暂停状态：" class="headerlink" title="2.暂停状态："></a>2.暂停状态：</h4><p>当嵌入该Fragment的Activity是处于暂停状态时，那么该Fragment也是处于暂停状态的。</p>
<h4 id="3-停止状态："><a href="#3-停止状态：" class="headerlink" title="3.停止状态："></a>3.停止状态：</h4><p>当嵌入该Fragment的Activity是处于停止状态时，那么该Fragment也会进入停止状态。<br>或者通过调用FragmentTransation的remove()、replace()方法将Fragment从Activity中移除，但如果在事务提交前调用addToBackStack()方法添加到返回栈，这时的碎片进入到停止状态。进入停止状态的碎片有可能被系统回收。但在回收前如果又被置于前台(从返回栈中返回)，将不需要被创建。</p>
<h4 id="4-销毁状态："><a href="#4-销毁状态：" class="headerlink" title="4.销毁状态："></a>4.销毁状态：</h4><p>当嵌入该Fragment的Activity是被销毁时，该Fragment进入到销毁状态。<br>或者通过调用FragmentTransation的remove()、replace()方法将Fragment从Activity中移除，但在事务提交前没有调用addToBackStack()方法添加到返回栈，这时的碎片进行到销毁状态。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194148649.png" alt="image-20201014194148649" style="zoom: 50%;"><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194253899.png" alt="image-20201014194253899" style="zoom: 67%;"></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194329244.png" alt="image-20201014194329244" style="zoom:67%;">



<h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><h3 id="layout-large-文件夹"><a href="#layout-large-文件夹" class="headerlink" title="layout - large 文件夹"></a>layout <font color="red">- large</font> 文件夹</h3><h3 id="layout-sw600dp文件夹"><a href="#layout-sw600dp文件夹" class="headerlink" title="layout - sw600dp文件夹"></a>layout<font color="red"> - sw600dp</font>文件夹</h3><h2 id="简易版的新闻应用"><a href="#简易版的新闻应用" class="headerlink" title="简易版的新闻应用"></a>简易版的新闻应用</h2><h3 id="一、准备一个新闻实体类-News-java"><a href="#一、准备一个新闻实体类-News-java" class="headerlink" title="一、准备一个新闻实体类 News.java"></a>一、准备一个新闻实体类 <font color="cornflowerblue">News.java</font></h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201014194855870.png" alt="image-20201014194855870" style="zoom:67%;">

<h3 id="二、接着新建布局文件news-content-frag-xml，用于作为内容碎片类的布局"><a href="#二、接着新建布局文件news-content-frag-xml，用于作为内容碎片类的布局" class="headerlink" title="二、接着新建布局文件news_content_frag.xml，用于作为内容碎片类的布局"></a>二、接着新建布局文件<font color="cornflowerblue">news_content_frag.xml</font>，用于作为<font color="cornflowerblue">内容碎片类</font>的布局</h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195315804.png" alt="image-20201014195315804" style="zoom:67%;">



<h3 id="三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment"><a href="#三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment" class="headerlink" title="三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment"></a>三、然后再新建一个<font color="cornflowerblue">内容碎片类NewsContentFragment</font>，继承自Fragment</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195546698.png" alt="image-20201014195546698"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195955104.png" alt="image-20201014195955104"></p>
<h3 id="四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击-com-example-fragmentbestpractice"><a href="#四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击-com-example-fragmentbestpractice" class="headerlink" title="四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击 com.example.fragmentbestpractice"></a>四、这样我们就把<font color="cornflowerblue">新闻内容的碎片和布局都创建好了</font>，但是它们都是在双页模式中使用的，如果<font color="red">想在单页模式中使用</font>的话，我们还需要再创建一个活动。右击 com.example.fragmentbestpractice</h3><p>包→New→Activity-→Empty Activity，新建一个NewsContentActivity，并将布局名指定成<br>news_content，然后修改news_content.xml中的代码，如下所示:</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014200437146.png" alt="image-20201014200437146"></p>
<h3 id="五、然后修改NewsContentActivity中的代码，如下所示"><a href="#五、然后修改NewsContentActivity中的代码，如下所示" class="headerlink" title="五、然后修改NewsContentActivity中的代码，如下所示:"></a>五、然后修改<font color="cornflowerblue">NewsContentActivity</font>中的代码，如下所示:</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014201305152.png" alt="image-20201014201305152"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014201739780.png" alt="image-20201014201739780"></p>
<h3 id="六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news-title-frag-xml"><a href="#六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news-title-frag-xml" class="headerlink" title="六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news title frag.xml"></a>六、接下来还需要再创建一个用于显示<font color="cornflowerblue">新闻列表碎片类的布局</font>，新建<font color="cornflowerblue">news title frag.xml</font></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202002701.png" alt="image-20201014202002701"></p>
<h3 id="七、新建news-item-xml作为RecyclerView子项的布局"><a href="#七、新建news-item-xml作为RecyclerView子项的布局" class="headerlink" title="七、新建news_item.xml作为RecyclerView子项的布局"></a>七、新建<font color="cornflowerblue">news_item.xml</font>作为RecyclerView子项的布局</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202257283.png" alt="image-20201014202257283"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202303375.png" alt="image-20201014202303375"></p>
<h3 id="八、既然新闻列表和子项的布局都已经创建好了-那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示"><a href="#八、既然新闻列表和子项的布局都已经创建好了-那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示" class="headerlink" title="八、既然新闻列表和子项的布局都已经创建好了,那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示:"></a>八、既然新闻列表和子项的布局都已经创建好了,那么接下来我们就需要一个用于展示新闻列表的地方。这里新建<font color="cornflowerblue">NewsTitleFragment</font>作为<font color="cornflowerblue">新闻列表的碎片类</font>，代码如下所示:</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014203519438.png" alt="image-20201014203519438"></p>
<h3 id="九、创建两个模式的主活动布局"><a href="#九、创建两个模式的主活动布局" class="headerlink" title="九、创建两个模式的主活动布局"></a>九、创建两个模式的<font color="cornflowerblue">主活动布局</font></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014203644781.png" alt="image-20201014203644781"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014204051184.png" alt="image-20201014204051184"></p>
<h3 id="十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示"><a href="#十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示" class="headerlink" title="十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示:"></a>十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中<font color="cornflowerblue">新建一个内部类NewsAdapter</font>来作为RecyclerView的<font color="cornflowerblue">适配器</font>，如下所示:</h3><h4 id="（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）"><a href="#（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）" class="headerlink" title="（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）"></a><font color="red">（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）</font></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014205746854.png" alt="image-20201014205746854" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210158025.png" alt="image-20201014210158025" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210210198.png" alt="image-20201014210210198" style="zoom:67%;">



<h3 id="十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示"><a href="#十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示" class="headerlink" title="十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示:"></a>十一、现在还剩最后一步收尾工作，就是向RecyclerView中<font color="cornflowerblue">填充数据</font>了。修改NewsTitle-Fragment中的代码，如下所示:</h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210535588.png" alt="image-20201014210535588" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210606503.png" alt="image-20201014210606503" style="zoom:67%;">







<h1 id="第五章-全局大喇叭——详解广播机制"><a href="#第五章-全局大喇叭——详解广播机制" class="headerlink" title="第五章 全局大喇叭——详解广播机制"></a>第五章 全局大喇叭——详解广播机制</h1><h2 id="广播机制简介"><a href="#广播机制简介" class="headerlink" title="广播机制简介"></a>广播机制简介</h2><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117133937067.png" alt="image-20201117133937067"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117134653797.png" alt="image-20201117134653797"></p>
<h3 id="一、一种传输信息的机制"><a href="#一、一种传输信息的机制" class="headerlink" title="一、一种传输信息的机制"></a>一、一种传输信息的机制</h3><h4 id="广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。"><a href="#广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。" class="headerlink" title="广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。"></a>广播消息可以是<font color="red">应用程序的数据信息</font>，也可以是<font color="red">Android的系统消息</font>，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。</h4><h4 id="Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。"><a href="#Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。" class="headerlink" title="Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。"></a>Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。</h4><h4 id="接收广播需要专门的广播接收器（Broadcast-Reciever）。"><a href="#接收广播需要专门的广播接收器（Broadcast-Reciever）。" class="headerlink" title="接收广播需要专门的广播接收器（Broadcast Reciever）。"></a>接收广播需要专门的广播接收器（Broadcast Reciever）。</h4><h4 id="广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。"><a href="#广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。" class="headerlink" title="广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。"></a>广播接收器通过<font color="red">设置好的过滤器</font>监听特定的广播消息然后进行响应。</h4><h3 id="二、广播的类型"><a href="#二、广播的类型" class="headerlink" title="二、广播的类型"></a>二、广播的类型</h3><h4 id="1-标准广播"><a href="#1-标准广播" class="headerlink" title="1.标准广播"></a>1.<font color="cornflowerblue">标准广播</font></h4><p>​        异步执行。在广播发出之后，所有的广播接收器都会在同一时刻接收到这条广播消息。</p>
<h4 id="2-有序广播"><a href="#2-有序广播" class="headerlink" title="2.有序广播"></a>2.有序广播</h4><h5 id="同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。"><a href="#同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。" class="headerlink" title="同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。"></a>同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。</h5><h5 id="广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。"><a href="#广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。" class="headerlink" title="广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。"></a>广播接收器是有先后顺序，<font color="red">优先级</font>高的广播接收器就可以先收到广播消息。</h5><h5 id="优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。"><a href="#优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。" class="headerlink" title="优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。"></a>优先级高的广播接收器可以<font color="red">截断</font>正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。</h5><h2 id="BroadcastReceiver介绍"><a href="#BroadcastReceiver介绍" class="headerlink" title="BroadcastReceiver介绍"></a>BroadcastReceiver介绍</h2><h3 id="一、BroadcastReceiver"><a href="#一、BroadcastReceiver" class="headerlink" title="一、BroadcastReceiver"></a>一、BroadcastReceiver</h3><h4 id="1-本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。"><a href="#1-本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。" class="headerlink" title="1.本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。"></a>1.本质上是一种<font color="red">全局监听器</font>，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。</h4><h4 id="2-BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如："><a href="#2-BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如：" class="headerlink" title="2. BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如："></a>2. BroadcastReceiver用于<font color="red">接收指定的广播</font>，通过<font color="red">设置过滤器</font>监听感兴趣的广播消息后进行响应，例如：</h4><p>启动Activity作为响应，或者通过NotificationManager提醒用户，或者启动Service等等。<br>自身并不实现图形用户界面。</p>
<h3 id="二、Broadcast开发过程"><a href="#二、Broadcast开发过程" class="headerlink" title="二、Broadcast开发过程"></a>二、Broadcast开发过程</h3><h4 id="1-定义广播接收器"><a href="#1-定义广播接收器" class="headerlink" title="1.定义广播接收器"></a>1.<font color="cornflowerblue">定义广播接收器</font></h4><h5 id="继承BroadcastReceiver基类，实现onReceiver方法："><a href="#继承BroadcastReceiver基类，实现onReceiver方法：" class="headerlink" title="继承BroadcastReceiver基类，实现onReceiver方法："></a>继承BroadcastReceiver基类，实现onReceiver方法：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135128320.png" alt="image-20201117135128320"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135631266.png" alt="image-20201117135631266"></p>
<h4 id="2-注册广播接收器"><a href="#2-注册广播接收器" class="headerlink" title="2.注册广播接收器"></a>2.<font color="cornflowerblue">注册广播接收器</font></h4><h5 id="（1）静态注册："><a href="#（1）静态注册：" class="headerlink" title="（1）静态注册："></a>（1）<font color="red">静态注册</font>：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135302391.png" alt="image-20201117135302391"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140345059.png" alt="image-20201117140345059"></p>
<h5 id="（2）动态注册：（可定义为内部类）"><a href="#（2）动态注册：（可定义为内部类）" class="headerlink" title="（2）动态注册：（可定义为内部类）"></a>（2）<font color="red">动态注册</font>：（可定义为内部类）</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135729313.png" alt="image-20201117135729313"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140330496.png" alt="image-20201117140330496"></p>
<h4 id="3-BroadcastReceiver响应"><a href="#3-BroadcastReceiver响应" class="headerlink" title="3.BroadcastReceiver响应"></a>3.BroadcastReceiver响应</h4><h5 id="（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive-方法，onReceive-方法执行完后，BroadcastReceiver的实例就会被销毁。"><a href="#（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive-方法，onReceive-方法执行完后，BroadcastReceiver的实例就会被销毁。" class="headerlink" title="（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive()方法，onReceive()方法执行完后，BroadcastReceiver的实例就会被销毁。"></a>（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并<font color="orange">自动触发它的onReceive()方法</font>，onReceive()方法执行完后，BroadcastReceiver的实例就会<font color="orange">被销毁</font>。</h5><h5 id="（2）-如果BroadcastReceiver的onReceive-方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive-方法里执行一些耗时的操作，否则会弹出ANR（Application-No-Response）对话框。"><a href="#（2）-如果BroadcastReceiver的onReceive-方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive-方法里执行一些耗时的操作，否则会弹出ANR（Application-No-Response）对话框。" class="headerlink" title="（2） 如果BroadcastReceiver的onReceive()方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive()方法里执行一些耗时的操作，否则会弹出ANR（Application No Response）对话框。"></a>（2） 如果BroadcastReceiver的onReceive()方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive()方法里执行一些耗时的操作，否则会弹出ANR（Application No Response）对话框。</h5><h2 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h2><h3 id="一、标准广播："><a href="#一、标准广播：" class="headerlink" title="一、标准广播："></a>一、标准广播：</h3><h4 id="1-是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast-Intent的传播。"><a href="#1-是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast-Intent的传播。" class="headerlink" title="1.是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播。"></a>1.是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播。</h4><h4 id="2-Intent-intent-new-Intent-“com-example-broadcasttest-MY-BROADCAST”"><a href="#2-Intent-intent-new-Intent-“com-example-broadcasttest-MY-BROADCAST”" class="headerlink" title="2. Intent intent = new Intent(“com.example.broadcasttest.MY_BROADCAST”);"></a>2. Intent intent = new Intent(“com.example.broadcasttest.MY_BROADCAST”);</h4><h4 id="sendBroadcast-intent"><a href="#sendBroadcast-intent" class="headerlink" title="sendBroadcast(intent);"></a><font color="red">sendBroadcast(intent);</font></h4><p>​            </p>
<h3 id="二、有序广播："><a href="#二、有序广播：" class="headerlink" title="二、有序广播："></a>二、有序广播：</h3><h4 id="1-该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast-方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras-Bundle-bundle-方法）。"><a href="#1-该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast-方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras-Bundle-bundle-方法）。" class="headerlink" title="1.该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast()方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras(Bundle bundle)方法）。"></a>1.该广播的接收者将<font color="red">按预先声明的优先级</font>依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast()方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras(Bundle bundle)方法）。</h4><h4 id="2-Intent-intent-new-Intent-“iet-jxufe-cn-android-OrderedBroadcastTest”"><a href="#2-Intent-intent-new-Intent-“iet-jxufe-cn-android-OrderedBroadcastTest”" class="headerlink" title="2. Intent intent=new Intent(“iet.jxufe.cn.android.OrderedBroadcastTest”);"></a>2. Intent intent=new Intent(“iet.jxufe.cn.android.OrderedBroadcastTest”);</h4><pre><code>        &lt;font color=&#39;red&#39;&gt;endOrderedBroadcast(intent,null);&lt;/font&gt;
    3.优先级设置
</code></pre>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140951277.png" alt="image-20201117140951277"></p>
<h2 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h2><h3 id="一、Android本地广播机制："><a href="#一、Android本地广播机制：" class="headerlink" title="一、Android本地广播机制："></a>一、Android本地广播机制：</h3><h4 id="广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播"><a href="#广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播" class="headerlink" title="广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播"></a>广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播</h4><h4 id="方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。"><a href="#方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。" class="headerlink" title="方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。"></a>方法：使用<font color="cornflowerblue">LocalBroadcastManager</font>对广播进行管理，对发送广播和注册广播接收器进行管理。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117141401456.png" alt="image-20201117141401456"></p>
<h1 id="第六章-数据存储全方案–持久化技术"><a href="#第六章-数据存储全方案–持久化技术" class="headerlink" title="第六章 数据存储全方案–持久化技术"></a>第六章 数据存储全方案–持久化技术</h1><h2 id="持久化技术简介"><a href="#持久化技术简介" class="headerlink" title="持久化技术简介"></a>持久化技术简介</h2><h3 id="1-数据存储方式"><a href="#1-数据存储方式" class="headerlink" title="1.数据存储方式"></a>1.数据存储方式</h3><ul>
<li><font color="red">文件存储</font></li>
<li><font color="red">SharedPreferences</font></li>
<li><font color="red">SQLite数据库</font></li>
</ul>
<h3 id="2-Android内部存储和外部存储"><a href="#2-Android内部存储和外部存储" class="headerlink" title="2.Android内部存储和外部存储"></a>2.Android内部存储和外部存储</h3><h4 id="（1）内存（Memory）："><a href="#（1）内存（Memory）：" class="headerlink" title="（1）内存（Memory）："></a>（1）内存（Memory）：</h4><p>​            RAM，类似于PC的内存条</p>
<h4 id="（2）内部存储（Internal-Storage）："><a href="#（2）内部存储（Internal-Storage）：" class="headerlink" title="（2）内部存储（Internal Storage）："></a>（2）内部存储（Internal Storage）：</h4><p>​            机身固有存储，类似于PC的硬盘 </p>
<h4 id="（3）外部存储（External-Storage）："><a href="#（3）外部存储（External-Storage）：" class="headerlink" title="（3）外部存储（External Storage）："></a>（3）外部存储（External Storage）：</h4><p>​                早期的Android设备(4.4之前) 指SDCard(扩展卡)，类似于PC上的U盘。</p>
<p>​        之后随着技术的进步，机身存储得到了快速增大(8G以上)，此时的外部存储是<font color="orange">概念级别的“外部存储”</font>，机        身<font color="red">固有的存储</font>有一部分被划分为“内部存储”，另一部分被划分为“外部存储”，但其实都是机身固有存储。        后期的外部存储也包括了SDCard。<br>​        所以不管Android手机是否有可移动的SDCard，他们总是有外部存储和内部存储。</p>
<h3 id="3-几个重要文件夹"><a href="#3-几个重要文件夹" class="headerlink" title="3.几个重要文件夹"></a>3.几个重要文件夹</h3><h4 id="打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹"><a href="#打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹" class="headerlink" title="打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：data文件夹、mnt文件夹、sdcard 文件夹、storage文件夹"></a>打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：<font color="red">data</font>文件夹、<font color="red">mnt</font>文件夹、<font color="red">sdcard</font> 文件夹、<font color="red">storage</font>文件夹</h4><h3 id="4-内部存储data"><a href="#4-内部存储data" class="headerlink" title="4.内部存储data"></a>4.<font color="cornflowerblue">内部存储data</font></h3><h4 id="1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："><a href="#1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：" class="headerlink" title="(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："></a>(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：</h4><ul>
<li><h5 id="文件夹app：存放着我们所有安装的app的apk文件"><a href="#文件夹app：存放着我们所有安装的app的apk文件" class="headerlink" title="文件夹app：存放着我们所有安装的app的apk文件"></a>文件夹<font color="red">app</font>：存放着我们所有安装的app的apk文件</h5></li>
<li><h5 id="文件夹data：一些包名，展开后，"><a href="#文件夹data：一些包名，展开后，" class="headerlink" title="文件夹data：一些包名，展开后，"></a>文件夹<font color="red">data</font>：一些包名，展开后，</h5><p>data/data/包名/<font color="orange">shared_prefs</font>(SharedPreference存储方式)</p>
<pre><code>data/data/包名/&lt;font color=&#39;orange&#39;&gt;databases&lt;/font&gt;（数据库存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;files&lt;/font&gt;（文件存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;cache&lt;/font&gt;
</code></pre>
</li>
</ul>
<h4 id="（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data"><a href="#（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data" class="headerlink" title="（2）路径的访问：Environment.getDataDirectory()获取内部存储根路径。/data"></a>（2）路径的访问：<font color="red">Environment.getDataDirectory()</font>获取内部存储根路径。/data</h4><h4 id="3-几点："><a href="#3-几点：" class="headerlink" title="(3)几点："></a>(3)几点：</h4><ol>
<li><h4 id="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"><a href="#系统默认只在内部存储中创建cache目录，并且此时cache目录是空的" class="headerlink" title="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"></a>系统默认<font color="orange">只在内部存储中创建cache目录</font>，并且此时cache目录是空的</h4></li>
<li><h4 id="此外，还可以根据需要自动创建：shared-prefs，databases，files目录"><a href="#此外，还可以根据需要自动创建：shared-prefs，databases，files目录" class="headerlink" title="此外，还可以根据需要自动创建：shared_prefs，databases，files目录"></a>此外，还可以根据需要<font color="orange">自动创建</font>：shared_prefs，databases，files目录</h4><p>但files可以<font color="orange">手动创建</font>，而shared_prefs，databases不能</p>
</li>
<li><h4 id="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"><a href="#别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。" class="headerlink" title="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"></a>别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。</h4></li>
</ol>
<h4 id="（4）内部存储的API"><a href="#（4）内部存储的API" class="headerlink" title="（4）内部存储的API"></a>（4）内部存储的API</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028153632199.png" alt="image-20201028153632199" style="zoom:80%;">





<h3 id="5-外部存储storage"><a href="#5-外部存储storage" class="headerlink" title="5.外部存储storage"></a>5.<font color="cornflowerblue">外部存储storage</font></h3><h4 id="1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"><a href="#1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。" class="headerlink" title="(1)一般是/storage/emulated/0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"></a>(1)一般是<font color="red">/storage/emulated/0</font>也有可能是其它文件夹，不同厂家不同版本有可能不一样。</h4><h4 id="storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy"><a href="#storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy" class="headerlink" title="/storage/sdcard0，/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy"></a><font color="red">/storage/sdcard0，</font>/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy</h4><ul>
<li><h5 id="公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等"><a href="#公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等" class="headerlink" title="公有目录：10大类，比如DCIM,Download等这些系统创建的文件夹。storage/emulated/0/Download等"></a><font color="red">公有目录</font>：10大类，比如DCIM,Download等这些系统创建的文件夹。<font color="orange">storage/emulated/0/Download</font>等</h5></li>
<li><h5 id="私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。"><a href="#私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。" class="headerlink" title="私有目录：Android文件夹，打开后有data文件夹。storage/emulated/0/Android/data/包名 文件夹：里面包含了许多包名组成的文件夹。"></a><font color="red">私有目录</font>：Android文件夹，打开后有<font color="red">data</font>文件夹。<font color="orange">storage/emulated/0/Android/data/包名 文件夹</font>：里面包含了许多包名组成的文件夹。</h5><h4 id="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"><a href="#（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。" class="headerlink" title="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"></a>（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的<font color="green">数据会一并删除</font>。</h4><p>如果直接在<font color="red">根目录</font>（<font color="orange">/storage/emulated/0</font>）下创建一个应用的文件夹，这样当该应用被卸载后，这些数据还保留在外部存储中，<font color="green">留下垃圾数据</font>。</p>
</li>
</ul>
<h4 id="（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。"><a href="#（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。" class="headerlink" title="（3）路径的访问：Environment.getExternalStorageDirectory()：获取机身存储的外部存储根路径。"></a>（3）路径的访问：<font color="red">Environment.getExternalStorageDirectory()</font>：获取机身存储的外部存储根路径。</h4><h4 id="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"><a href="#（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录" class="headerlink" title="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"></a>（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要<font color="red">手动创建私有目录</font></h4><h5 id="context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件"><a href="#context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件" class="headerlink" title="context.getExternalFilesDir(…)：在storage/emulated/0/Android/data/包名/files 中创建文件"></a>context.<font color="orange">getExternalFilesDir(…)</font>：在storage/emulated/0/Android/data/包名/files 中创建文件</h5><p>​    context.<font color="orange">getExternalCacheDir() </font>：在storage/emulated/0/Android/data/包名/cache 中创建文件</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028154738508.png" alt="image-20201028154738508" style="zoom:80%;">

<h3 id="6-内部存储与外部存储比较"><a href="#6-内部存储与外部存储比较" class="headerlink" title="6.内部存储与外部存储比较"></a>6.内部存储与外部存储比较</h3><p>​        外部存储目录空间较大，而内部存储空间有限<br>​        部分目录不会被自动创建，需要手动创建<br>​        两者<font color="red">都不需要权限</font><br>​        两者<font color="red">都会随着App的卸载而会自动被删除</font><br>​        对于内部存储，<font color="orange">只有</font>本App才可以访问<br>​        对于外部私有目录，本App可以直接访问，而其它App在自 Android 7.0 开始，系统对应用私有目录的访问权限进一步限制。其他 App 无法通过 file:// 这种形式的 Uri 直接读写该目录下的文件内容，而是通过 FileProvider 访问。<br>​        需要注意的是：由于用户可以直接查看并操作外部私有存储目录，那么也就意味着我们在操作这个目录下的文件的时候一定要做好异常和判空处理。</p>
<h3 id="7-数据存储与清除"><a href="#7-数据存储与清除" class="headerlink" title="7.数据存储与清除"></a>7.数据存储与清除</h3><h4 id="（1）数据存储："><a href="#（1）数据存储：" class="headerlink" title="（1）数据存储："></a>（1）数据存储：</h4><ul>
<li><p>默认情况下，存储在<font color="red">内部存储</font>：<br><font color="orange">data/app</font>：用户APP安装目录，存放apk；</p>
<p><font color="orange">data/data/包名/</font>：存放应用程序的数据</p>
</li>
<li><p>数据可以存放到指定的<font color="red">外部存储</font>：</p>
<p><font color="orange">/storage/sdcard</font>（共有目录）</p>
<p><font color="orange">/storage/sdcard0/Android/data/包名/</font>（私有目录）</p>
<h4 id="（2）清除数据："><a href="#（2）清除数据：" class="headerlink" title="（2）清除数据："></a>（2）清除数据：</h4></li>
</ul>
<h5 id="删除对应包中的cache，files，lib，shared-prefs，datbBases等等"><a href="#删除对应包中的cache，files，lib，shared-prefs，datbBases等等" class="headerlink" title="删除对应包中的cache，files，lib，shared_prefs，datbBases等等"></a>删除<font color="red">对应包中的</font><font color="cornflowerblue">cache</font>，files，lib，shared_prefs，datbBases等等</h5><p>​        （清除<font color="red">data/data/packagename中的</font>cache，files，lib， databases，shared_prefs等等）</p>
<p>​        （清除<font color="red">storage/emulated/0/Android/data/packagenam中的</font>文件）</p>
<h4 id="3-清除缓存："><a href="#3-清除缓存：" class="headerlink" title="(3) 清除缓存："></a>(3) 清除缓存：</h4><h5 id="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"><a href="#删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。" class="headerlink" title="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"></a>删除的是App运行过程中所产生的<font color="red">临时数据</font>，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在<font color="red">内存</font>中。</h5><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1.内部存储"></a>1.内部存储</h3><h4 id="（1）存："><a href="#（1）存：" class="headerlink" title="（1）存："></a>（1）存：</h4><p>方法1：使用 context.getFilesDir() 获取内部存储data/data/包名/files目录，然后创建文件，最后利用文件(全路径)新建FileOutputStream对象进行文件写入。<br>FileOutputStream fileOutputStream = new FileOutputStream(filePathName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160019136.png" alt="image-20201028160019136" style="zoom:80%;">

<p>方法2：直接使用Context.openFileOutput()方法(只需要文件名)获取FileOutputStream对象，进行文件写入。</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201028160258040.png" alt="image-20201028160258040" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160348975.png" alt="image-20201028160348975" style="zoom:80%;">

<h4 id="（2）取："><a href="#（2）取：" class="headerlink" title="（2）取："></a>（2）取：</h4><p>方法1：使用context.getFilesDir() 获取内部存储data/data/包名/files目录，然后利用文件(全路径)创建FileInputStream对象，进行内容读取。<br>FileInputStream fileInputStream = new FileInputStream(filePathName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/myBlog\source\_posts\安卓数据存储之文件存储\3.png" alt="image-20201028160834999" style="zoom:80%;">

<p>方法2：直接使用Context. openFileInput()方法(只需要文件名)获取FileInputStream对象，进行文件内容读取。<br>FileInputStream fileInputStream = openFileInput(fileName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160853113.png" alt="image-20201028160853113" style="zoom:80%;">

<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20210531224957336.png" alt="image-20210531224957336"></p>
<h3 id="2-外部存储"><a href="#2-外部存储" class="headerlink" title="2.外部存储"></a>2.外部存储</h3><h4 id="（1）外部根目录："><a href="#（1）外部根目录：" class="headerlink" title="（1）外部根目录："></a>（1）外部根目录：</h4><p>使用 <font color="red">Environment.getExternalStorageDirectory()</font> 获取</p>
<p>一般是/storage/emulated/0</p>
<h4 id="（2）外部公有目录："><a href="#（2）外部公有目录：" class="headerlink" title="（2）外部公有目录："></a>（2）外部公有目录：</h4><p>使用<font color="red">Environment.getExternalStoragePublicDirectory</font>获取</p>
<p>/storage/emulated/0/Music</p>
<p>针对外部<font color="red">共有目录、根目录</font>等位置的存取需要<font color="orange">添加权限</font>，Android 6.0 之后还需要做运行时权限申请。针对外部<font color="red">私有目录</font>的存取则<font color="orange">不需要添加权限</font>。<br>默认情况下，Android系统<font color="red">不会</font>为我们的App在外部存储中创建私有路径，需要<font color="red">手动创建</font>。<br>外部私有目录在App卸载时同步删除。</p>
<p>​    </p>
<h4 id="（3）获取外部私有目录"><a href="#（3）获取外部私有目录" class="headerlink" title="（3）获取外部私有目录"></a>（3）获取外部私有目录</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162002693.png" alt="image-20201028162002693" style="zoom:80%;">





<h4 id="（4）存："><a href="#（4）存：" class="headerlink" title="（4）存："></a>（4）存：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162420940.png" alt="image-20201028162420940"></p>
<h4 id="（5）取："><a href="#（5）取：" class="headerlink" title="（5）取："></a>（5）取：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162532386.png" alt="image-20201028162532386"></p>
<h2 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h2><h3 id="1-获取SharedPreferences对象"><a href="#1-获取SharedPreferences对象" class="headerlink" title="1.获取SharedPreferences对象"></a>1.获取<font color="cornflowerblue">SharedPreferences对象</font></h3><h4 id="1-Context-getSharedPreferences-方法"><a href="#1-Context-getSharedPreferences-方法" class="headerlink" title="(1) Context . getSharedPreferences()方法 "></a>(1) <font color="red">Context . getSharedPreferences()方法 </font></h4><p>​        此方法接受两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个。SharedPreferences 文件都是存放在 /data/data/&lt;包名&gt;/shared_prefs/ 目录下的。<br>​        第二个参数用于<font color="orange">指定操作模式</font>，主要为 MODE_PRIVATE（默认操作模式） 和 MODE_MULTI_PROCESS（多进程读写） 。</p>
<h4 id="2-Activity-类中的-getPreferences-方法"><a href="#2-Activity-类中的-getPreferences-方法" class="headerlink" title="(2)Activity 类中的 getPreferences() 方法"></a>(2)<font color="red">Activity 类中的 getPreferences() 方法</font></h4><p>这个方法和 Context 中的 getSharedPreferences() 方法类似，不过它只接收一个操作模式参数，使用这个方法时<font color="orange">会自动将当前活动的类名作为 SharedPreferences 的文件名</font>。</p>
<h4 id="3-PreferenceManager-类中的-getDefaultSharedPreferences-方法"><a href="#3-PreferenceManager-类中的-getDefaultSharedPreferences-方法" class="headerlink" title="(3) PreferenceManager 类中的 getDefaultSharedPreferences() 方法"></a>(3)<font color="red"> PreferenceManager 类中的 getDefaultSharedPreferences() 方法</font></h4><p>这是一个<font color="orange">静态方法</font>，它接收一个 Context 参数，并自动<font color="orange">使用当前应用程序的包名作为前缀</font>来命名 SharedPreferences 文件。</p>
<h3 id="2-通过SharedPreferences对象获取到Editor对象存数据"><a href="#2-通过SharedPreferences对象获取到Editor对象存数据" class="headerlink" title="2.通过SharedPreferences对象获取到Editor对象存数据"></a>2.通过SharedPreferences对象获取到<font color="cornflowerblue">Editor对象</font>存数据</h3><h4 id="（1）SharePreferences-Editor-editor-shared-edit"><a href="#（1）SharePreferences-Editor-editor-shared-edit" class="headerlink" title="（1）SharePreferences.Editor  editor = shared.edit();"></a>（1）SharePreferences.Editor  editor = shared.<font color="red">edit();</font></h4><p>调用 SharedPreferences 对象的 edit() 方法来获取一个 SharePreferences.Editor 对象。</p>
<h4 id="（2）editor-putString"><a href="#（2）editor-putString" class="headerlink" title="（2）editor.putString( )"></a>（2）editor<font color="red">.putString( )</font></h4><p>向 SharedPreferences.Editor 对象中添加数据，如果添加一个字符串则使用 editor.putString() 方法，以此类推。</p>
<h4 id="（3）editor-commit-editor-apply"><a href="#（3）editor-commit-editor-apply" class="headerlink" title="（3）editor.commit()  editor.apply()"></a>（3）<font color="red">editor.commit()  editor.apply()</font></h4><p>调用 editor.commit() 方法或者editor.apply()方法将添加的数据提交，从而完成数据存储操作。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164007127.png" alt="image-20201028164007127"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164138241.png" alt="image-20201028164138241"></p>
<h3 id="3-SharePreferences读取与删除数据"><a href="#3-SharePreferences读取与删除数据" class="headerlink" title="3.SharePreferences读取与删除数据"></a>3.SharePreferences<font color="cornflowerblue">读取与删除</font>数据</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164251857.png" alt="image-20201028164251857"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164334426.png" alt="image-20201028164334426"></p>
<h2 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h2><h3 id="一、创建数据库"><a href="#一、创建数据库" class="headerlink" title="一、创建数据库"></a>一、创建数据库</h3><h4 id="1-SQLiteOpenHelper-帮助类"><a href="#1-SQLiteOpenHelper-帮助类" class="headerlink" title="1.  SQLiteOpenHelper 帮助类"></a>1. <font color="cornflowerblue"> SQLiteOpenHelper</font> 帮助类</h4><ul>
<li><p>重写onCreate() 和 onUpgrade() 方法，分别在这两个方法实现创建、更新数据库的逻辑；</p>
</li>
<li><p>两个重要的实例方法：getReadableDatabase() 和 getWritableDatabese() ,这两个方法都可以创建或打开一个现有数据库（不存在则创建），并且返回一个可对数据库进行读/写操作的SQLiteDatabase对象</p>
</li>
<li><p>SQLiteOpenHelper构造方法（context, name, factory, version）</p>
<p>​        参数一：Context；    参数二：数据库名；    参数三：Cursor游标（null）    参数四：版本号</p>
<h4 id="2-新建-MyDatabaseHelper-继承自SQLiteOpenHelper"><a href="#2-新建-MyDatabaseHelper-继承自SQLiteOpenHelper" class="headerlink" title="2. 新建 MyDatabaseHelper 继承自SQLiteOpenHelper"></a>2. 新建 <font color="cornflowerblue">MyDatabaseHelper</font> 继承自SQLiteOpenHelper</h4><h5 id="重写oncreate"><a href="#重写oncreate" class="headerlink" title="重写oncreate()"></a>重写<font color="orange">oncreate()</font></h5></li>
</ul>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031132951195.png" alt="image-20201031132951195"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031133055726.png" alt="image-20201031133055726"></p>
<h4 id="3-创建数据库"><a href="#3-创建数据库" class="headerlink" title="3. 创建数据库"></a>3. 创建数据库</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031133544744.png" alt="image-20201031133544744"></p>
<h3 id="二、升级数据库"><a href="#二、升级数据库" class="headerlink" title="二、升级数据库"></a>二、升级数据库</h3><h4 id="1-在初始化时新执行一条SQL语句，新建一个Category表格"><a href="#1-在初始化时新执行一条SQL语句，新建一个Category表格" class="headerlink" title="1.在初始化时新执行一条SQL语句，新建一个Category表格"></a>1.在初始化时新执行一条SQL语句，新建一个Category表格</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134002931.png" alt="image-20201031134002931"></p>
<h4 id="2-重写onUpgrade"><a href="#2-重写onUpgrade" class="headerlink" title="2.重写onUpgrade()"></a>2.重写<font color="orange">onUpgrade()</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134120838.png" alt="image-20201031134120838"></p>
<p>​    升级时，如果表格存在，先删除掉再调用onCreate()重写创建</p>
<h4 id="3-更新数据库"><a href="#3-更新数据库" class="headerlink" title="3. 更新数据库"></a>3. 更新数据库</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134454199.png" alt="image-20201031134454199"></p>
<h3 id="三、添加数据-insert"><a href="#三、添加数据-insert" class="headerlink" title="三、添加数据 insert()"></a>三、添加数据 <font color="cornflowerblue">insert()</font></h3><h4 id="1-参数"><a href="#1-参数" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二：用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL，一般我们用不到这个功能，直接传入null即可</li>
<li>参数三：<font color="orange">ContentValues</font>对象，它提供了一系列的<font color="orange">put()</font>方法重载，用于向Contentvalues中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。</li>
</ul>
<h4 id="2-添加数据"><a href="#2-添加数据" class="headerlink" title="2.添加数据"></a>2.添加数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031140101787.png" alt="image-20201031140101787"></p>
<h3 id="四、更新数据-updata"><a href="#四、更新数据-updata" class="headerlink" title="四、更新数据 updata()"></a>四、更新数据 <font color="cornflowerblue">updata()</font></h3><h4 id="1-参数-1"><a href="#1-参数-1" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二：<font color="orange">ContentValues</font>对象，组装更新的数据</li>
<li>参数三、参数四：约束更新某一行或某几行的数据</li>
</ul>
<h4 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2.更新数据"></a>2.更新数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031140634673.png" alt="image-20201031140634673"></p>
<h5 id="更新Book表格中，name为“The-Da-Vinci-Code”-的价格为10-99"><a href="#更新Book表格中，name为“The-Da-Vinci-Code”-的价格为10-99" class="headerlink" title="更新Book表格中，name为“The Da Vinci Code” 的价格为10.99"></a>更新Book表格中，name为“The Da Vinci Code” 的价格为10.99</h5><h3 id="五、删除数据-delete"><a href="#五、删除数据-delete" class="headerlink" title="五、删除数据 delete()"></a>五、删除数据 <font color="cornflowerblue">delete()</font></h3><h4 id="1-参数-2"><a href="#1-参数-2" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二、参数三：约束删除某一行或某几行的数据</li>
</ul>
<h4 id="2-删除数据"><a href="#2-删除数据" class="headerlink" title="2.删除数据"></a>2.删除数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141159367.png" alt="image-20201031141159367"></p>
<h5 id="删除Book表格中，Pages大于500页的数据"><a href="#删除Book表格中，Pages大于500页的数据" class="headerlink" title="删除Book表格中，Pages大于500页的数据"></a>删除Book表格中，Pages大于500页的数据</h5><h3 id="六、查询数据-query"><a href="#六、查询数据-query" class="headerlink" title="六、查询数据 query()"></a>六、查询数据 <font color="cornflowerblue">query()</font></h3><h4 id="1-参数-3"><a href="#1-参数-3" class="headerlink" title="1.参数"></a>1.参数</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141347771.png" alt="image-20201031141347771"></p>
<h4 id="2-查询数据"><a href="#2-查询数据" class="headerlink" title="2.查询数据"></a>2.查询数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141717750.png" alt="image-20201031141717750"></p>
<h5 id="通过返回的Cursor对象来获取数据，moveToFirst-将游标移动到第一行位置；-getColunmIndex-获取某一列的位置索引"><a href="#通过返回的Cursor对象来获取数据，moveToFirst-将游标移动到第一行位置；-getColunmIndex-获取某一列的位置索引" class="headerlink" title="通过返回的Cursor对象来获取数据，moveToFirst():将游标移动到第一行位置； getColunmIndex():获取某一列的位置索引"></a>通过返回的Cursor对象来获取数据，<font color="orange">moveToFirst()</font>:将游标移动到第一行位置；<font color="orange"> getColunmIndex()</font>:获取某一列的位置索引</h5><h1 id="第七章-跨程序共享数据——探究内容提供器"><a href="#第七章-跨程序共享数据——探究内容提供器" class="headerlink" title="第七章 跨程序共享数据——探究内容提供器"></a>第七章 跨程序共享数据——探究内容提供器</h1><h2 id="内容提供器简介"><a href="#内容提供器简介" class="headerlink" title="内容提供器简介"></a>内容提供器简介</h2><h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><h3 id="一、危险权限"><a href="#一、危险权限" class="headerlink" title="一、危险权限"></a>一、危险权限</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201109144301759.png" alt="image-20201109144301759"></p>
<p>危险权限需要进行运行时权限处理，普通权限只要在AndroidMainfest.xml清单文件中添加一下权限声明就行</p>
<h3 id="二、运行时权限处理步骤"><a href="#二、运行时权限处理步骤" class="headerlink" title="二、运行时权限处理步骤"></a>二、<font color="cornflowerblue">运行时权限处理步骤</font></h3><h4 id="1-第一步：判断用户是否已经授权"><a href="#1-第一步：判断用户是否已经授权" class="headerlink" title="1. 第一步：判断用户是否已经授权"></a>1. <font color="pink">第一步</font>：判断用户是否已经授权</h4><h5 id="（1）ContextCompat-checkSelfPermission-MainActivity-this-Manifest-permission-READ-CONTACTS"><a href="#（1）ContextCompat-checkSelfPermission-MainActivity-this-Manifest-permission-READ-CONTACTS" class="headerlink" title="（1）ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_CONTACTS)"></a>（1）<font color="red">ContextCompat.checkSelfPermission</font>(MainActivity.this, Manifest.permission.READ_CONTACTS)</h5><h5 id="（2）参数一：Context；-参数二：权限名"><a href="#（2）参数一：Context；-参数二：权限名" class="headerlink" title="（2）参数一：Context； 参数二：权限名"></a>（2）参数一：Context； 参数二：权限名</h5><h5 id="（3）将其返回值与PackageManager-PERMISSION-GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。"><a href="#（3）将其返回值与PackageManager-PERMISSION-GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。" class="headerlink" title="（3）将其返回值与PackageManager.PERMISSION_GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。"></a>（3）将其返回值与<font color="red">PackageManager.PERMISSION_GRANTED</font>做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。</h5><h4 id="2-第二步：如果未授权，申请授权"><a href="#2-第二步：如果未授权，申请授权" class="headerlink" title="2.第二步：如果未授权，申请授权"></a>2.<font color="pink">第二步</font>：如果未授权，申请授权</h4><h5 id="（1）ActivityCompat-requestPermissions-MainActivity-this-new-String-Manifest-permission-READ-CONTACTS-1"><a href="#（1）ActivityCompat-requestPermissions-MainActivity-this-new-String-Manifest-permission-READ-CONTACTS-1" class="headerlink" title="（1）ActivityCompat.requestPermissions(MainActivity.this, new String[]{ Manifest.permission. READ_CONTACTS }, 1);"></a>（1）<font color="red">ActivityCompat.requestPermissions</font>(MainActivity.this, new String[]{ Manifest.permission. READ_CONTACTS }, 1);</h5><h5 id="（2）参数一：Activity的实例；-参数二：权限名的String数组；"><a href="#（2）参数一：Activity的实例；-参数二：权限名的String数组；" class="headerlink" title="（2）参数一：Activity的实例；    参数二：权限名的String数组；"></a>（2）参数一：Activity的实例；    参数二：权限名的String数组；</h5><h5 id="权限三：请求码，唯一即可"><a href="#权限三：请求码，唯一即可" class="headerlink" title="权限三：请求码，唯一即可"></a>权限三：请求码，唯一即可</h5><h5 id="（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult-方法，对授权结果进行处理。"><a href="#（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult-方法，对授权结果进行处理。" class="headerlink" title="（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult()方法，对授权结果进行处理。"></a>（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult()方法，对授权结果进行处理。</h5><h4 id="3-第三步：处理用户授权结果"><a href="#3-第三步：处理用户授权结果" class="headerlink" title="3.第三步：处理用户授权结果"></a>3.<font color="pink">第三步</font>：处理用户授权结果</h4><h5 id="（1）-onRequestPermissionsResult-方法中，用户授权的结果封装在grantResults参数当中"><a href="#（1）-onRequestPermissionsResult-方法中，用户授权的结果封装在grantResults参数当中" class="headerlink" title="（1） onRequestPermissionsResult()方法中，用户授权的结果封装在grantResults参数当中"></a>（1）<font color="red"> onRequestPermissionsResult()</font>方法中，用户授权的结果封装在grantResults参数当中</h5><h5 id="（2）grantResults-length-gt-0-amp-amp-grantResults-0-PackageManager-PERMISSION-GRANTED说明用户允许授权"><a href="#（2）grantResults-length-gt-0-amp-amp-grantResults-0-PackageManager-PERMISSION-GRANTED说明用户允许授权" class="headerlink" title="（2）grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED说明用户允许授权"></a>（2）grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED说明用户允许授权</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111130523831.png" alt="image-20201111130523831"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111130532512.png" alt="image-20201111130532512"></p>
<h2 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h2><h3 id="一、应用程序间的数据共享"><a href="#一、应用程序间的数据共享" class="headerlink" title="一、应用程序间的数据共享"></a>一、应用程序间的数据共享</h3><h4 id="1-三个重要类"><a href="#1-三个重要类" class="headerlink" title="1.三个重要类"></a>1.三个重要类</h4><h5 id="（1）ContentProvider：内容提供者。"><a href="#（1）ContentProvider：内容提供者。" class="headerlink" title="（1）ContentProvider：内容提供者。"></a>（1）<font color="cornflowerblue">ContentProvider</font>：内容提供者。</h5><p>内容提供者的用法一般有两种：<br>一种是使用<font color="orange">现有的</font>内容提供器来读取和操作相应程序中的数据。<br>另一种是<font color="orange">创建自己的</font>内容提供器对其数据提供外部访问接口。</p>
<h5 id="（2）ContentResolver：内容访问者"><a href="#（2）ContentResolver：内容访问者" class="headerlink" title="（2）ContentResolver：内容访问者"></a>（2）<font color="cornflowerblue">ContentResolver</font>：内容访问者</h5><p>提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作。</p>
<h5 id="（3）Uri："><a href="#（3）Uri：" class="headerlink" title="（3）Uri："></a>（3）<font color="cornflowerblue">Uri</font>：</h5><p>不同于SQLiteDatabase， ContentResolver中增删改查方法不接收表名参数，而是使用一个Uri参数代替，这个参数称为内容Uri。</p>
<p>格式：<font color="red">scheme:/ /Authority / path / id</font></p>
<ul>
<li>scheme： content://是一个标准的前缀，表明了这个数据被内容提供者管理，它不会修改。</li>
<li>authority：用于唯一标识一个ContentProvider，外部调用者可以根据此标识访问该ContentProvider。通常可将Authority设置为包名和类名的全称，以保证唯一性。例如包名是com.example.app，则authority可以命名为com.example.app.provider。</li>
<li>path：用于对同一应用程序的不同的数据进行区分，通常添加到authority的后面，例如/table1, /table2。</li>
<li>id：数据集中的每一条记录都有一个唯一的id。如果Uri中包含需要获取的记录的id，则只对该记录进行操作；如果Uri中没有id，则表示操作数据集中的所有记录。</li>
<li><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132317186.png" alt="image-20201111132317186"></li>
</ul>
<h4 id="2-使用ContentResolver访问共享数据"><a href="#2-使用ContentResolver访问共享数据" class="headerlink" title="2.使用ContentResolver访问共享数据"></a>2.使用ContentResolver访问共享数据</h4><h5 id="ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作"><a href="#ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作" class="headerlink" title="ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作"></a>ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行<font color="red">CRUD</font>操作</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132443856.png" alt="image-20201111132443856"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132412264.png" alt="image-20201111132412264"></p>
<h4 id="3-查询-获取-内容提供者中指定的数据"><a href="#3-查询-获取-内容提供者中指定的数据" class="headerlink" title="3. 查询(获取)内容提供者中指定的数据"></a>3. <font color="cornflowerblue">查询</font>(获取)内容提供者中指定的数据</h4><h5 id="（1）首先，确定访问目标"><a href="#（1）首先，确定访问目标" class="headerlink" title="（1）首先，确定访问目标"></a>（1）首先，确定访问目标</h5><h5 id="Uri-uri-Uri-parse-“content-com-example-app-provider-table1”"><a href="#Uri-uri-Uri-parse-“content-com-example-app-provider-table1”" class="headerlink" title="Uri uri = Uri.parse(“content://com.example.app.provider/table1”);"></a>Uri uri = Uri.parse(“content://com.example.app.provider/table1”);</h5><p>（2）然后，查询：<br>获取ContentResolver，将Uri对象作为参数，调用query()方法得到一个cursor对象</p>
<h5 id="Cursor-cursor-getContentResolver-query-uri-projection-selection-selectionArgs-sortOrder"><a href="#Cursor-cursor-getContentResolver-query-uri-projection-selection-selectionArgs-sortOrder" class="headerlink" title="Cursor  cursor = getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder);"></a><font color="red">Cursor  cursor = getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder);</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132642375.png" alt="image-20201111132642375"></p>
<h5 id="（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。"><a href="#（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。" class="headerlink" title="（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。"></a>（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133026107.png" alt="image-20201111133026107"></p>
<h4 id="4-向内容提供者共享的table1中添加数据"><a href="#4-向内容提供者共享的table1中添加数据" class="headerlink" title="4. 向内容提供者共享的table1中添加数据"></a>4. 向内容提供者共享的table1中<font color="cornflowerblue">添加</font>数据</h4><h5 id="将待添加的数据组装到ContentValues，然后调用ContentResolver类insert-方法，将uri和ContentValues作为参数传入。"><a href="#将待添加的数据组装到ContentValues，然后调用ContentResolver类insert-方法，将uri和ContentValues作为参数传入。" class="headerlink" title="将待添加的数据组装到ContentValues，然后调用ContentResolver类insert()方法，将uri和ContentValues作为参数传入。"></a>将待添加的数据组装到ContentValues，然后调用ContentResolver类insert()方法，将uri和ContentValues作为参数传入。</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133121157.png" alt="image-20201111133121157"></p>
<h4 id="5-向内容提供者共享的table1中更新数据"><a href="#5-向内容提供者共享的table1中更新数据" class="headerlink" title="5. 向内容提供者共享的table1中更新数据"></a>5. 向内容提供者共享的table1中<font color="cornflowerblue">更新</font>数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133151906.png" alt="image-20201111133151906"></p>
<h4 id="6-向内容提供者共享的table1中删除数据"><a href="#6-向内容提供者共享的table1中删除数据" class="headerlink" title="6.向内容提供者共享的table1中删除数据"></a>6.向内容提供者共享的table1中<font color="cornflowerblue">删除</font>数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133224468.png" alt="image-20201111133224468"></p>
<h2 id="创建自己的内容提供器-（P260）"><a href="#创建自己的内容提供器-（P260）" class="headerlink" title="创建自己的内容提供器*（P260）"></a>创建自己的内容提供器*（P260）</h2><h3 id="一、重写其中6个抽象方法"><a href="#一、重写其中6个抽象方法" class="headerlink" title="一、重写其中6个抽象方法"></a>一、重写其中6个抽象方法</h3><h4 id="1-public-boolean-onCreate-：ContentProvider创建时调用。"><a href="#1-public-boolean-onCreate-：ContentProvider创建时调用。" class="headerlink" title="1.public boolean onCreate()：ContentProvider创建时调用。"></a>1.public boolean <font color="cornflowerblue">onCreate()</font>：ContentProvider创建时调用。</h4><h4 id="2-public-int-delete-…-：根据传入的Uri删除指定条件下的数据。"><a href="#2-public-int-delete-…-：根据传入的Uri删除指定条件下的数据。" class="headerlink" title="2. public int delete(…)：根据传入的Uri删除指定条件下的数据。"></a>2. public int <font color="cornflowerblue">delete(…)</font>：根据传入的Uri删除指定条件下的数据。</h4><h4 id="3-public-Uri-insert-…-：根据传入的Uri插入数据。"><a href="#3-public-Uri-insert-…-：根据传入的Uri插入数据。" class="headerlink" title="3.public Uri insert(…)：根据传入的Uri插入数据。"></a>3.public Uri <font color="cornflowerblue">insert(…)</font>：根据传入的Uri插入数据。</h4><h4 id="4-public-Cursor-query-…-：根据传入的Uri查询指定的数据。"><a href="#4-public-Cursor-query-…-：根据传入的Uri查询指定的数据。" class="headerlink" title="4. public Cursor query(…)：根据传入的Uri查询指定的数据。"></a>4. public Cursor <font color="cornflowerblue">query(…)</font>：根据传入的Uri查询指定的数据。</h4><h4 id="5-public-int-update-…-：根据传入的Uri更新指定的数据。"><a href="#5-public-int-update-…-：根据传入的Uri更新指定的数据。" class="headerlink" title="5.public int update(…)：根据传入的Uri更新指定的数据。"></a>5.public int <font color="cornflowerblue">update(…)</font>：根据传入的Uri更新指定的数据。</h4><h4 id="6-getType"><a href="#6-getType" class="headerlink" title="6.getType()"></a>6.<font color="red">getType()</font></h4><h3 id="二、Uri参数：确定调用方希望访问的数据或表"><a href="#二、Uri参数：确定调用方希望访问的数据或表" class="headerlink" title="二、Uri参数：确定调用方希望访问的数据或表"></a>二、Uri参数：确定调用方希望访问的数据或表</h3><h4 id="表：content-com-example-app-privder-table1"><a href="#表：content-com-example-app-privder-table1" class="headerlink" title="表：content://com.example.app.privder/table1/"></a>表：content://com.example.app.privder/table1/</h4><h4 id="数据：content-com-example-app-privder-table1"><a href="#数据：content-com-example-app-privder-table1" class="headerlink" title="数据：content://com.example.app.privder/table1/#"></a>数据：content://com.example.app.privder/table1/#</h4><h3 id="三、通过UriMatcher类解析Uri参数，确定调用的数据或表"><a href="#三、通过UriMatcher类解析Uri参数，确定调用的数据或表" class="headerlink" title="三、通过UriMatcher类解析Uri参数，确定调用的数据或表"></a>三、通过UriMatcher类解析Uri参数，确定调用的数据或表</h3><h4 id="首先将需要共享的数据或数据表的内容URI用addURI-方法添加到自定义的内容提供器中"><a href="#首先将需要共享的数据或数据表的内容URI用addURI-方法添加到自定义的内容提供器中" class="headerlink" title="首先将需要共享的数据或数据表的内容URI用addURI()方法添加到自定义的内容提供器中"></a>首先将需要共享的数据或数据表的内容URI用<font color="red">addURI()方法</font>添加到自定义的内容提供器中</h4><h4 id="然后，在query-方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。"><a href="#然后，在query-方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。" class="headerlink" title="然后，在query()方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。"></a>然后，在query()方法中调用UriMatcher的<font color="red">match方法</font>对传入的Uri对象进行解析，<font color="orange">返回某个能匹配这个Uri对象的自定义代码</font>，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117132442004.png" alt="image-20201117132442004"></p>
<h3 id="四、getType-方法"><a href="#四、getType-方法" class="headerlink" title="四、getType()方法"></a>四、getType()方法</h3><p>一个内容URI所对应的MIME字符串由3部分组成：    </p>
<ul>
<li>以vnd开头</li>
<li>如果内容URI以路径结尾，则后接android.cursor.<font color="red">dir</font>/，如果内容URI以id结尾，则后接android.cursor<font color="red">.item</font>/</li>
<li>最后接上vnd.<authority>.<path></path></authority></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;<span class="comment">//教材265页</span></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Implement this to handle requests for the MIME type of the data</span></span><br><span class="line">       <span class="comment">// at the given URI.</span></span><br><span class="line">       <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">           <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.book&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.category&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.category&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="内容观察者ContentObersver"><a href="#内容观察者ContentObersver" class="headerlink" title="内容观察者ContentObersver"></a>内容观察者ContentObersver</h2><h3 id="一、ContentObserver（内容观察者）"><a href="#一、ContentObserver（内容观察者）" class="headerlink" title="一、ContentObserver（内容观察者）"></a>一、ContentObserver（内容观察者）</h3><h4 id="1-目的是观察-捕捉-特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器-Trigger-，当ContentObserver所观察的Uri发生变化时，便会触发它。"><a href="#1-目的是观察-捕捉-特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器-Trigger-，当ContentObserver所观察的Uri发生变化时，便会触发它。" class="headerlink" title="1.目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它。"></a>1.目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它。</h4><h4 id="2-触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri-MIME-Type有关的。"><a href="#2-触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri-MIME-Type有关的。" class="headerlink" title="2.触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri MIME Type有关的。"></a>2.触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri MIME Type有关的。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117133208124.png" alt="image-20201117133208124"></p>
<h4 id="3-当A应用程序的数据发生变化时，A应用程序调用notifyChange-方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange-方法。"><a href="#3-当A应用程序的数据发生变化时，A应用程序调用notifyChange-方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange-方法。" class="headerlink" title="3.当A应用程序的数据发生变化时，A应用程序调用notifyChange()方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange()方法。"></a>3.当A应用程序的数据发生变化时，A应用程序调用notifyChange()方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange()方法。</h4><h3 id="二、ContentObserver的几个常用的方法"><a href="#二、ContentObserver的几个常用的方法" class="headerlink" title="二、ContentObserver的几个常用的方法"></a>二、ContentObserver的几个常用的方法</h3><h4 id="1-构造方法-public-void-ContentObserver-Handler-handler"><a href="#1-构造方法-public-void-ContentObserver-Handler-handler" class="headerlink" title="1.构造方法 public void ContentObserver(Handler handler)"></a>1.构造方法 public void<font color="cornflowerblue"> ContentObserver(Handler handler)</font></h4><p>​        所有ContentObserver的派生类都需要调用该构造方法.<br>参数：handler，Handler对象。可以是主线程Handler(这时候可以更新UI )，也可以是任何Handler对象。</p>
<h4 id="2-void-onChange-boolean-selfChange"><a href="#2-void-onChange-boolean-selfChange" class="headerlink" title="2.void onChange(boolean selfChange)"></a>2.void <font color="cornflowerblue">onChange(boolean selfChange)</font></h4><p>​        观察到的Uri发生变化时，回调该方法去处理。<br>所有ContentObserver的派生类都需要重载该方法去处理逻辑。</p>
<h1 id="第八章-丰富你的程序——运用手机多媒体"><a href="#第八章-丰富你的程序——运用手机多媒体" class="headerlink" title="第八章 丰富你的程序——运用手机多媒体"></a>第八章 丰富你的程序——运用手机多媒体</h1><h2 id="播放多媒体文件"><a href="#播放多媒体文件" class="headerlink" title="播放多媒体文件"></a>播放多媒体文件</h2><h3 id="一、播放音频"><a href="#一、播放音频" class="headerlink" title="一、播放音频"></a>一、播放音频</h3><h4 id="1-MediaPlayer类"><a href="#1-MediaPlayer类" class="headerlink" title="1.MediaPlayer类"></a>1.<font color="cornflowerblue">MediaPlayer</font>类</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124130455169.png" alt="image-20201124130455169"></p>
<h4 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2.工作流程"></a>2.工作流程</h4><ul>
<li><h5 id="创建MediaPlayer对象；"><a href="#创建MediaPlayer对象；" class="headerlink" title="创建MediaPlayer对象；"></a>创建MediaPlayer对象；</h5></li>
<li><h5 id="初始化设置音频文件路径：setDataSource"><a href="#初始化设置音频文件路径：setDataSource" class="headerlink" title="初始化设置音频文件路径：setDataSource()"></a>初始化设置音频文件路径：setDataSource()</h5></li>
<li><h5 id="使MediaPlayer进入准备状态：pepare"><a href="#使MediaPlayer进入准备状态：pepare" class="headerlink" title="使MediaPlayer进入准备状态：pepare()"></a>使MediaPlayer进入准备状态：pepare()</h5></li>
<li><h5 id="开始播放音频：start"><a href="#开始播放音频：start" class="headerlink" title="开始播放音频：start()"></a>开始播放音频：start()</h5></li>
<li><h5 id="暂停播放音频：pause"><a href="#暂停播放音频：pause" class="headerlink" title="暂停播放音频：pause()"></a>暂停播放音频：pause()</h5></li>
<li><h5 id="停止播放音频：reset-setDataSource-pepare"><a href="#停止播放音频：reset-setDataSource-pepare" class="headerlink" title="停止播放音频：reset(), setDataSource(), pepare()"></a>停止播放音频：reset(), setDataSource(), pepare()</h5></li>
</ul>
<h1 id="第九章-看看精彩的技术——使用网络技术"><a href="#第九章-看看精彩的技术——使用网络技术" class="headerlink" title="第九章 看看精彩的技术——使用网络技术"></a>第九章 看看精彩的技术——使用网络技术</h1><h2 id="Android常见的网络通信方式"><a href="#Android常见的网络通信方式" class="headerlink" title="Android常见的网络通信方式"></a>Android常见的网络通信方式</h2><h3 id="一、基于TCP协议"><a href="#一、基于TCP协议" class="headerlink" title="一、基于TCP协议"></a>一、基于TCP协议</h3><p>（1）针对TCP的 Socket、ServerSocket<br>（2）针对UDP的DatagramSocket、DatagramPackage<br>（3）Apache Mina框架</p>
<h3 id="二、基于Http协议"><a href="#二、基于Http协议" class="headerlink" title="二、基于Http协议"></a>二、基于Http协议</h3><p>HttpURLConnection、HttpClient、AsyncHttpClient框架等</p>
<h3 id="三、直接使用-WebKit-访问网络"><a href="#三、直接使用-WebKit-访问网络" class="headerlink" title="三、直接使用 WebKit 访问网络"></a>三、直接使用 WebKit 访问网络</h3><h3 id="四、使用网络通信框架"><a href="#四、使用网络通信框架" class="headerlink" title="四、使用网络通信框架"></a>四、使用网络通信框架</h3><p>OkHttp，Volley，Retrofit</p>
<h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><h3 id="一、通信协议"><a href="#一、通信协议" class="headerlink" title="一、通信协议"></a>一、通信协议</h3><h4 id="1-计算机网络实现通信必须遵循守一些约定。核心要素包括："><a href="#1-计算机网络实现通信必须遵循守一些约定。核心要素包括：" class="headerlink" title="1.计算机网络实现通信必须遵循守一些约定。核心要素包括："></a>1.计算机网络实现通信必须遵循守一些约定。核心要素包括：</h4><h5 id="（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；"><a href="#（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；" class="headerlink" title="（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；"></a>（1）<font color="cornflowerblue">语义</font>：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；</h5><h5 id="（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；"><a href="#（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；" class="headerlink" title="（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；"></a>（2）<font color="cornflowerblue">语法</font>：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；</h5><h5 id="（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。"><a href="#（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。" class="headerlink" title="（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。"></a>（3）<font color="cornflowerblue">时序</font>：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。</h5><h4 id="2-常见的通信协议"><a href="#2-常见的通信协议" class="headerlink" title="2.常见的通信协议"></a>2.常见的通信协议</h4><ul>
<li>TCP/IP, IPX/SPX, NetBEUI, RS-232-C等</li>
<li>TCP/IP 是最基本的通信协议。</li>
<li>TCP/IP是一组协议的集合，是一组协议集合的简称。</li>
</ul>
<h3 id="二、TCP-IP-协议集"><a href="#二、TCP-IP-协议集" class="headerlink" title="二、TCP/IP 协议集"></a>二、TCP/IP 协议集</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214220514420.png" alt="image-20201214220514420"></p>
<h4 id="1-以QQ数据传输为例"><a href="#1-以QQ数据传输为例" class="headerlink" title="1.以QQ数据传输为例"></a>1.以QQ数据传输为例</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214220704145.png" alt="image-20201214220704145"></p>
<h4 id="2-TCP与UDP，传输层"><a href="#2-TCP与UDP，传输层" class="headerlink" title="2.TCP与UDP，传输层"></a>2.TCP与UDP，传输层</h4><h5 id="1、TCP面向连接（如打电话要先拨号建立连接）-UDP是无连接的，即发送数据之前不需要建立连接。"><a href="#1、TCP面向连接（如打电话要先拨号建立连接）-UDP是无连接的，即发送数据之前不需要建立连接。" class="headerlink" title="1、TCP面向连接（如打电话要先拨号建立连接）; UDP是无连接的，即发送数据之前不需要建立连接。"></a>1、<font color="red">TCP面向连接</font>（如打电话要先拨号建立连接）;<font color="red"> UDP是无连接的</font>，即发送数据之前不需要建立连接。</h5><h5 id="2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达-UDP尽最大努力交付，即不保证可靠交付。"><a href="#2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达-UDP尽最大努力交付，即不保证可靠交付。" class="headerlink" title="2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保证可靠交付。"></a>2、<font color="red">TCP提供可靠的服务</font>。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; <font color="red">UDP尽最大努力交付，即不保证可靠交付</font>。</h5><h5 id="3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流-UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。"><a href="#3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流-UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。" class="headerlink" title="3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。"></a>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</h5><h5 id="4、每一条TCP连接只能是点到点的-UDP支持一对一，一对多，多对一和多对多的交互通信。"><a href="#4、每一条TCP连接只能是点到点的-UDP支持一对一，一对多，多对一和多对多的交互通信。" class="headerlink" title="4、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信。"></a>4、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信。</h5><h5 id="5、TCP首部开销20字节-UDP的首部开销小，只有8个字节。"><a href="#5、TCP首部开销20字节-UDP的首部开销小，只有8个字节。" class="headerlink" title="5、TCP首部开销20字节;UDP的首部开销小，只有8个字节。"></a>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节。</h5><h5 id="6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。"><a href="#6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。" class="headerlink" title="6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。"></a>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</h5><h4 id="3-HTTP，应用层"><a href="#3-HTTP，应用层" class="headerlink" title="3.HTTP，应用层"></a>3.HTTP，应用层</h4><h5 id="（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。"><a href="#（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。" class="headerlink" title="（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。"></a>（1）Http是一个基于<font color="red">请求与响应，无状态的，应用层的</font>协议，常基于<font color="red">TCP</font>协议传输数据。</h5><h5 id="（2）用于定义Web浏览器与Web服务器之间交换数据的过程。"><a href="#（2）用于定义Web浏览器与Web服务器之间交换数据的过程。" class="headerlink" title="（2）用于定义Web浏览器与Web服务器之间交换数据的过程。"></a>（2）用于定义Web浏览器与Web服务器之间交换数据的过程。</h5><h5 id="（3）四个基于：请求与响应、无状态、应用层、TCP"><a href="#（3）四个基于：请求与响应、无状态、应用层、TCP" class="headerlink" title="（3）四个基于：请求与响应、无状态、应用层、TCP"></a>（3）四个基于：请求与响应、无状态、应用层、TCP</h5><h2 id="基于TCP协议的网络通信"><a href="#基于TCP协议的网络通信" class="headerlink" title="基于TCP协议的网络通信"></a>基于TCP协议的网络通信</h2><h3 id="一、IP地址、端口"><a href="#一、IP地址、端口" class="headerlink" title="一、IP地址、端口"></a>一、IP地址、端口</h3><h4 id="1-IP地址"><a href="#1-IP地址" class="headerlink" title="1.IP地址"></a>1.<font color="cornflowerblue">IP地址</font></h4><h5 id="IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192-168-0-0-1。"><a href="#IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192-168-0-0-1。" class="headerlink" title="IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192.168.0.0.1。"></a>IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192.168.0.0.1。</h5><h4 id="2-端口"><a href="#2-端口" class="headerlink" title="2.端口"></a>2.<font color="cornflowerblue">端口</font></h4><h5 id="端口号用来标记一台电脑中的不同应用程序。"><a href="#端口号用来标记一台电脑中的不同应用程序。" class="headerlink" title="端口号用来标记一台电脑中的不同应用程序。"></a>端口号用来标记一台电脑中的不同应用程序。</h5><h5 id="端口号范围是0-65535，其中0-1023是系统专用"><a href="#端口号范围是0-65535，其中0-1023是系统专用" class="headerlink" title="端口号范围是0-65535，其中0~1023是系统专用"></a>端口号范围是0-<font color="orange">65535</font>，其中0~1023是系统专用</h5><h3 id="二、Socket编程"><a href="#二、Socket编程" class="headerlink" title="二、Socket编程"></a>二、Socket编程</h3><p>略</p>
<h2 id="基于Http协议的网络通信"><a href="#基于Http协议的网络通信" class="headerlink" title="基于Http协议的网络通信"></a>基于Http协议的网络通信</h2><h3 id="一、HTTP协议工作原理"><a href="#一、HTTP协议工作原理" class="headerlink" title="一、HTTP协议工作原理"></a>一、HTTP协议工作原理</h3><h4 id="1-建立连接："><a href="#1-建立连接：" class="headerlink" title="1.建立连接："></a>1.<font color="cornflowerblue">建立连接</font>：</h4><p>客户机与服务器建立连接。输入网址、打开网页或单击超级链接。</p>
<h4 id="2-发送请求："><a href="#2-发送请求：" class="headerlink" title="2.发送请求："></a>2.<font color="cornflowerblue">发送请求</font>：</h4><p>客户机向服务器发送请求，格式为：<strong>统一资源标识符</strong>（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p>
<h4 id="3-响应请求："><a href="#3-响应请求：" class="headerlink" title="3.响应请求："></a>3.<font color="cornflowerblue">响应请求</font>：</h4><p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
<h4 id="4-接收响应："><a href="#4-接收响应：" class="headerlink" title="4.接收响应："></a>4.<font color="cornflowerblue">接收响应</font>：</h4><p>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后与服务器断开连接。</p>
<h3 id="二、HTTP请求报文"><a href="#二、HTTP请求报文" class="headerlink" title="二、HTTP请求报文"></a>二、HTTP<strong>请求报文</strong></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215125047712.png" alt="image-20201215125047712"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215124600803.png" alt="image-20201215124600803"></p>
<h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.<font color="cornflowerblue">请求行</font></h4><h5 id="（1）请求方法"><a href="#（1）请求方法" class="headerlink" title="（1）请求方法"></a>（1）请求方法</h5><p>HTTP/1.1 定义的请求方法有8种，最常的两种GET和POST。</p>
<h5 id="（2）请求地址"><a href="#（2）请求地址" class="headerlink" title="（2）请求地址"></a>（2）请求地址</h5><p>URL:<font color="orange">统一资源定位符</font>，是一种资源位置的抽象唯一识别方法。<br>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;<br>端口和路径有时可以省略（HTTP默认端口号是80），有时会带参数，GET请求</p>
<h5 id="（3）版本协议"><a href="#（3）版本协议" class="headerlink" title="（3）版本协议"></a>（3）版本协议</h5><p>格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p>
<h4 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2.请求头部"></a>2.<font color="cornflowerblue">请求头部</font></h4><h5 id="（1）由键值对组成，每行一对，关键字和值用英文冒号“-”分隔。"><a href="#（1）由键值对组成，每行一对，关键字和值用英文冒号“-”分隔。" class="headerlink" title="（1）由键值对组成，每行一对，关键字和值用英文冒号“:”分隔。"></a>（1）由<font color="red">键值对</font>组成，每行一对，关键字和值用英文冒号“:”分隔。</h5><h5 id="（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有："><a href="#（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有：" class="headerlink" title="（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有："></a>（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215125315165.png" alt="image-20201215125315165"></p>
<h5 id="（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。"><a href="#（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。" class="headerlink" title="（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。"></a>（3）请求头部的最后<font color="red">会有一个空行，表示请求头部结束</font>，接下来为请求数据，这一行非常重要，必不可少。</h5><h4 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3.请求数据"></a>3.<font color="cornflowerblue">请求数据</font></h4><h5 id="（1）可选部分，比如GET请求就没有请求数据。"><a href="#（1）可选部分，比如GET请求就没有请求数据。" class="headerlink" title="（1）可选部分，比如GET请求就没有请求数据。"></a>（1）可选部分，比如GET请求就没有请求数据。</h5><h5 id="（2）HTTP的请求方式包括GET-POST-PUT-HEAD-DELETE-TRACE-CONNECT-OPTIONS等，最常用的发送请求的方式主要有-get-和-post两种"><a href="#（2）HTTP的请求方式包括GET-POST-PUT-HEAD-DELETE-TRACE-CONNECT-OPTIONS等，最常用的发送请求的方式主要有-get-和-post两种" class="headerlink" title="（2）HTTP的请求方式包括GET,POST, PUT ,HEAD, DELETE, TRACE, CONNECT, OPTIONS等，最常用的发送请求的方式主要有 get 和 post两种"></a>（2）HTTP的请求方式包括GET,POST, PUT ,HEAD, DELETE, TRACE, CONNECT, OPTIONS等，最常用的发送请求的方式主要有 get 和 post两种</h5><h4 id="4-GET与POST"><a href="#4-GET与POST" class="headerlink" title="4. GET与POST"></a>4. GET与POST</h4><h5 id="（1）get"><a href="#（1）get" class="headerlink" title="（1）get"></a>（1）get</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215130633494.png" alt="image-20201215130633494"></p>
<h5 id="（2）post"><a href="#（2）post" class="headerlink" title="（2）post"></a>（2）post</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111436244.png" alt="image-20201216111436244"></p>
<h5 id="3-注意"><a href="#3-注意" class="headerlink" title="(3)注意"></a>(3)注意</h5><ul>
<li>GET 和 POST 两种请求方式都可以发送数据的，只是<font color="orange">发送机制</font>font&gt;不一样。</li>
<li>另外GET安全性非常低，Post<font color="orange">安全性较高</font>， 但是GET<font color="orange">执行效率</font>却比Post方法好。</li>
<li>一般<font color="orange">查询</font>的时候我们用<font color="orange">GET</font>，数据<font color="orange">增删改</font>的时候用<font color="orange">POST</font>。</li>
</ul>
<h5 id="4-其他区别"><a href="#4-其他区别" class="headerlink" title="(4)其他区别"></a>(4)其他区别</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111723498.png" alt="image-20201216111723498"></p>
<h3 id="三、HTTP响应报文"><a href="#三、HTTP响应报文" class="headerlink" title="三、HTTP响应报文"></a>三、HTTP响应报文</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111852290.png" alt="image-20201216111852290"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111859563.png" alt="image-20201216111859563"></p>
<h4 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1.状态行"></a>1.状态行</h4><h5 id="（1）由3部分组成，分别为：协议版本，状态码，状态码描述）"><a href="#（1）由3部分组成，分别为：协议版本，状态码，状态码描述）" class="headerlink" title="（1）由3部分组成，分别为：协议版本，状态码，状态码描述）"></a>（1）由3部分组成，分别为：协议版本，<font color="red">状态码</font>，状态码描述）</h5><h5 id="（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述"><a href="#（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述" class="headerlink" title="（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述"></a>（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述</h5><h5 id="（3）常见状态码"><a href="#（3）常见状态码" class="headerlink" title="（3）常见状态码"></a>（3）常见状态码</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112057996.png" alt="image-20201216112057996"></p>
<h5 id="2-响应头部"><a href="#2-响应头部" class="headerlink" title="2.响应头部"></a>2.响应头部</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112237974.png" alt="image-20201216112237974"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112254577.png" alt="image-20201216112254577"></p>
<h3 id="四、基于HTTP的网络编程"><a href="#四、基于HTTP的网络编程" class="headerlink" title="四、基于HTTP的网络编程"></a>四、基于HTTP的网络编程</h3><p>（HyperText Transfer protocol）<font color="cornflowerblue">超文本传输协议</font></p>
<h4 id="1-通过URL获取网络资源"><a href="#1-通过URL获取网络资源" class="headerlink" title="1.通过URL获取网络资源"></a>1.通过URL获取网络资源</h4><h5 id="（1）URL（Unifrom-Resource-Locator）统一资源定位器"><a href="#（1）URL（Unifrom-Resource-Locator）统一资源定位器" class="headerlink" title="（1）URL（Unifrom Resource Locator）统一资源定位器"></a>（1）URL（Unifrom Resource Locator）<font color="cornflowerblue">统一资源定位器</font></h5><p>可以定位到互联网的资源上。如果用户已经知道网络上某个资源的URL(如图片、音乐和视频文件等)，那么就可以直接通过使用URL来进行网络连接，获得资源</p>
<h5 id="（2）资源获取过程："><a href="#（2）资源获取过程：" class="headerlink" title="（2）资源获取过程："></a>（2）资源获取过程：</h5><ol>
<li>创建URL对象。</li>
<li>调用常用的方法来获取对应的资源。例如，使用<font color="red">openStream()</font>方法，打开与此URL的连接，并返回读取到的数据流。</li>
<li>将获得的数据流进行处理。例如，显示到ImageView上。</li>
</ol>
<p>说明：openStream() 实际是通过<font color="red">openConnection()</font>方法获取URLConnection对象，然后调用<font color="red">getInputStream()</font>方法，这个方法会隐式的调用connect() 方法发送连接请求。</p>
<p>URL url = new URL( “ …”);</p>
<p>HttpURLConnection connection = (HttpURLConnection) url.openConnection();</p>
<p>InputStream in = connection.getInputStream();</p>
<p>等加于</p>
<p>URL url = new URL( “ …”);</p>
<p>InputStream in = url.openStream();</p>
<h5 id="3-URL类常用的方法"><a href="#3-URL类常用的方法" class="headerlink" title="(3)URL类常用的方法"></a>(3)URL类常用的方法</h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216113912830.png" alt="image-20201216113912830">

<h5 id="（4）案例：图片资源获取并显示"><a href="#（4）案例：图片资源获取并显示" class="headerlink" title="（4）案例：图片资源获取并显示"></a>（4）案例：图片资源获取并显示</h5><p>1.布局文件：新建项目URLDemo，在布局文件中，准备一个ImageView控件。</p>
<p>2.初始化并准备异步任务类。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216114237925.png" alt="image-20201216114237925"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216114246080.png" alt="image-20201216114246080"></p>
<p>3.<strong>获取网络资源</strong>：在doInBackground()方法中执行联网以获取网络资源，获取到的图片信息作为返回结果，传给onPostExecute()中的参数</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216120334545.png" alt="image-20201216120334545"></p>
<p>4.<strong>资源显示</strong>：在onPostExecute()方法中进行图片显示。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216120421728.png" alt="image-20201216120421728"></p>
<p>5.增加上网权限。</p>
<p>&lt;uses-permission android:”android.permission.INTERNET”/&gt;</p>
<h4 id="2-通过URLConnection获取网络资源"><a href="#2-通过URLConnection获取网络资源" class="headerlink" title="2.通过URLConnection获取网络资源"></a>2.通过URLConnection获取网络资源</h4><h5 id="（1）URL-对象提供了openConnection-方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。"><a href="#（1）URL-对象提供了openConnection-方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。" class="headerlink" title="（1）URL 对象提供了openConnection()方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。"></a>（1）URL 对象提供了<font color="cornflowerblue">openConnection()</font>方法返回一个<font color="cornflowerblue">URLConnection</font>对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。</h5><h5 id="（2）实现步骤"><a href="#（2）实现步骤" class="headerlink" title="（2）实现步骤"></a>（2）实现步骤</h5><ol>
<li>创建<font color="orange">URL对象</font>。</li>
<li>建立与URL的连接：由于<font color="orange">URLConnection</font>为抽象类，其对象不能直接实例化，通常通过<font color="orange">openConnection</font>方法获得。</li>
<li>获取返回的<font color="orange">InputStream</font>。</li>
<li>将InputStream进行处理：例如，显示到相应的控件上。</li>
<li>关闭流操作</li>
</ol>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217124051779.png" alt="image-20201217124051779"></p>
<h5 id="（3）URLConnection常用方法"><a href="#（3）URLConnection常用方法" class="headerlink" title="（3）URLConnection常用方法"></a>（3）URLConnection常用方法</h5><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public int <font color="red">getContentLength</font>()</td>
<td>获得文件的长度</td>
</tr>
<tr>
<td>public String getContentType()</td>
<td>获得文件的类型</td>
</tr>
<tr>
<td>public long getDate()</td>
<td>获得文件创建的时间</td>
</tr>
<tr>
<td>public long getLastModified()</td>
<td>获得文件最后修改的时间</td>
</tr>
<tr>
<td>public InputStream <font color="red">getInputStream()</font></td>
<td>获得输入流，以便读取文件的数据</td>
</tr>
<tr>
<td>public OutputStream getOutputStream()</td>
<td>获得输出流，以便输出数据</td>
</tr>
<tr>
<td>public void <font color="red">setRequestProperty(String key,String value)</font></td>
<td>设置请求属性值</td>
</tr>
<tr>
<td>connect()</td>
<td>打开到此URL引用的资源的通信连接(如果尚未建立连接)，如果已打开连接(此时connected()为true)，则忽略该调用</td>
</tr>
</tbody></table>
<h4 id="3-使用HttpURLConnection获取网络资源"><a href="#3-使用HttpURLConnection获取网络资源" class="headerlink" title="3.使用HttpURLConnection获取网络资源"></a>3.使用HttpURLConnection获取网络资源</h4><h5 id="（1）HttpURLConnection常用方法"><a href="#（1）HttpURLConnection常用方法" class="headerlink" title="（1）HttpURLConnection常用方法"></a>（1）HttpURLConnection常用方法</h5><p>HttpURLConnection是URLConnection的子类</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>InputStream <font color="red">getInputStream()</font></td>
<td>返回从此处打开的连接读取的输入流</td>
</tr>
<tr>
<td>OutputStream getOutputStream()</td>
<td>返回写入到此连接的输出流</td>
</tr>
<tr>
<td>String <font color="red">getRequestMethod()</font></td>
<td>获取请求方法</td>
</tr>
<tr>
<td>int getResponseCode()</td>
<td>获取状态码</td>
</tr>
<tr>
<td>void setRequestMethod(String method)</td>
<td>设置URL请求的方法</td>
</tr>
<tr>
<td>void setDoInput(boolean doinput)</td>
<td>设置输入流</td>
</tr>
<tr>
<td>void setDoOutput(boolean dooutput)</td>
<td>设置输出流</td>
</tr>
<tr>
<td>void setUseCaches(boolean usecaches)</td>
<td>设置连接是否使用任何可用的缓存</td>
</tr>
<tr>
<td>void disconnect()</td>
<td>关闭连接</td>
</tr>
</tbody></table>
<h5 id="（2）GET方式：将参数放在url后一起传递"><a href="#（2）GET方式：将参数放在url后一起传递" class="headerlink" title="（2）GET方式：将参数放在url后一起传递"></a>（2）GET方式：将参数放在url后一起传递</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125144443.png" alt="image-20201217125144443"></p>
<h5 id="（2）POST方法"><a href="#（2）POST方法" class="headerlink" title="（2）POST方法"></a>（2）POST方法</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125444529.png" alt="image-20201217125444529"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125635416.png" alt="image-20201217125635416"></p>
<h2 id="使用WebView控件"><a href="#使用WebView控件" class="headerlink" title="使用WebView控件"></a>使用WebView控件</h2><h3 id="1-Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个-控件"><a href="#1-Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个-控件" class="headerlink" title="1.Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个 控件"></a>1.Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个 控件</h3><h3 id="2-WebView-网页视图-常用方法"><a href="#2-WebView-网页视图-常用方法" class="headerlink" title="2.WebView(网页视图)常用方法"></a>2.WebView(<font color="cornflowerblue">网页视图</font>)常用方法</h3><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>loadUrl(String url)</td>
<td>打开一个指定的Web资源页面</td>
</tr>
<tr>
<td>loadData(String data, StringmimeType,String encoding)</td>
<td>显示HTML格式的网页内容</td>
</tr>
<tr>
<td>getSettings()</td>
<td>获取WebView的设置对象</td>
</tr>
<tr>
<td>addJavascriptInterface()</td>
<td>将一个对象添加到JavaScript的全局对象Window中</td>
</tr>
<tr>
<td>clearCache()</td>
<td>清除缓存</td>
</tr>
<tr>
<td>destory()</td>
<td>销毁WebView</td>
</tr>
</tbody></table>
<h3 id="3-在应用中嵌入浏览器展示网页，并进行解析"><a href="#3-在应用中嵌入浏览器展示网页，并进行解析" class="headerlink" title="3.在应用中嵌入浏览器展示网页，并进行解析"></a>3.在应用中嵌入浏览器展示网页，并进行解析</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217130452896.png" alt="image-20201217130452896"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217130553473.png" alt="image-20201217130553473"></p>
<h2 id="使用OKHttp获取网络资源"><a href="#使用OKHttp获取网络资源" class="headerlink" title="使用OKHttp获取网络资源"></a>使用OKHttp获取网络资源</h2><h3 id="1-GET请求"><a href="#1-GET请求" class="headerlink" title="1.GET请求"></a>1.GET请求</h3><h4 id="（1）添加依赖"><a href="#（1）添加依赖" class="headerlink" title="（1）添加依赖"></a>（1）添加依赖</h4><h4 id="implementation-‘com-squareup-okhttp3-okhttp-3-10-0’"><a href="#implementation-‘com-squareup-okhttp3-okhttp-3-10-0’" class="headerlink" title="implementation ‘com.squareup.okhttp3:okhttp:3.10.0’"></a><font color="pink">implementation ‘com.squareup.okhttp3:okhttp:3.10.0’</font></h4><h4 id="（2）声明访问Internet的权限"><a href="#（2）声明访问Internet的权限" class="headerlink" title="（2）声明访问Internet的权限"></a>（2）声明访问Internet的权限</h4><h4 id="-9"><a href="#-9" class="headerlink" title></a><font color="red"><uses-permission android:name="android.permission.INTERNET"></uses-permission></font></h4><p>在application标签中添加<font color="red"> android:usesCleartextTraffic=”true”</font></p>
<h4 id="（3）创建-OkHttpClient实例"><a href="#（3）创建-OkHttpClient实例" class="headerlink" title="（3）创建 OkHttpClient实例"></a>（3）创建 OkHttpClient实例</h4><p><font color="red">OkHttpClient okHttpClient = new OkHttpClient();</font></p>
<h4 id="（4）构造Request对象。"><a href="#（4）构造Request对象。" class="headerlink" title="（4）构造Request对象。"></a>（4）构造Request对象。</h4><p><font color="red">final Request request = new Request.Builder() .url(url).get() </font>   //默认</p>
<p>就是GET请求，可以不写 .build();</p>
<h4 id="（5）构建Call对象"><a href="#（5）构建Call对象" class="headerlink" title="（5）构建Call对象"></a>（5）构建Call对象</h4><p><font color="red">Call call = okHttpClient.newCall(request);</font></p>
<h4 id="（6）-发送请求并获取服务器返回的数据。"><a href="#（6）-发送请求并获取服务器返回的数据。" class="headerlink" title="（6） 发送请求并获取服务器返回的数据。"></a>（6） 发送请求并获取服务器返回的数据。</h4><ul>
<li><h5 id="同步Get方法："><a href="#同步Get方法：" class="headerlink" title="同步Get方法："></a>同步Get方法：</h5></li>
</ul>
<h5 id="通过Call-execute-方法提交请求，放在子线程中执行，或者使用异步任务的方式"><a href="#通过Call-execute-方法提交请求，放在子线程中执行，或者使用异步任务的方式" class="headerlink" title="通过Call.execute()方法提交请求，放在子线程中执行，或者使用异步任务的方式"></a>通过<font color="red">Call.execute()</font>方法提交请求，放在<font color="orange">子线程</font>中执行，或者使用异步任务的方式</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217131925515.png" alt="image-20201217131925515"></p>
<ul>
<li><h5 id="异步Get方法："><a href="#异步Get方法：" class="headerlink" title="异步Get方法："></a>异步Get方法：</h5></li>
</ul>
<h5 id="通过Call-enqueue-Callback-方法来提交异步请求"><a href="#通过Call-enqueue-Callback-方法来提交异步请求" class="headerlink" title="通过Call.enqueue(Callback)方法来提交异步请求"></a>通过<font color="red">Call.enqueue(Callback)</font>方法来提交异步请求</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132051946.png" alt="image-20201217132051946"></p>
<h3 id="2-POST请求"><a href="#2-POST请求" class="headerlink" title="2.POST请求"></a>2.POST请求</h3><h4 id="（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如："><a href="#（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如：" class="headerlink" title="（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如："></a>（1）与上述GET请求相比，需要先构造一个<font color="red">RequestBody对象</font>用来存放待提交的数据，例如：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132351988.png" alt="image-20201217132351988"></p>
<h4 id="（2）然后在Request-Builder中调用一下post-方法，并将RequestBody对象传入："><a href="#（2）然后在Request-Builder中调用一下post-方法，并将RequestBody对象传入：" class="headerlink" title="（2）然后在Request.Builder中调用一下post()方法，并将RequestBody对象传入："></a>（2）然后在Request.Builder中调用一下post()方法，并将RequestBody对象传入：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132423939.png" alt="image-20201217132423939"></p>
<h4 id="（3）登录案例"><a href="#（3）登录案例" class="headerlink" title="（3）登录案例"></a>（3）登录案例</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133135117.png" alt="image-20201217133135117"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133213142.png" alt="image-20201217133213142"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133219867.png" alt="image-20201217133219867"></p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="一、JSON数据"><a href="#一、JSON数据" class="headerlink" title="一、JSON数据"></a>一、JSON数据</h3><h4 id="1-JSON-JavaScript-Object-Notation-是JavaScript的一个子集，是一种轻量级的数据交换格式。"><a href="#1-JSON-JavaScript-Object-Notation-是JavaScript的一个子集，是一种轻量级的数据交换格式。" class="headerlink" title="1.JSON(JavaScript Object Notation) 是JavaScript的一个子集，是一种轻量级的数据交换格式。"></a>1.JSON(JavaScript Object Notation) 是JavaScript的一个子集，是一种<font color="cornflowerblue">轻量级的数据交换格式</font>。</h4><h4 id="2-JSON的结构基于以下两点："><a href="#2-JSON的结构基于以下两点：" class="headerlink" title="2.JSON的结构基于以下两点："></a>2.JSON的结构基于以下两点：</h4><h5 id="（1）”名称-值”对的集合-：不同语言中，它被理解为对象-object-，记录-record-，结构-struct-，字典-dictionary-，哈希表-hash-table-，键列表-keyed-list-等。"><a href="#（1）”名称-值”对的集合-：不同语言中，它被理解为对象-object-，记录-record-，结构-struct-，字典-dictionary-，哈希表-hash-table-，键列表-keyed-list-等。" class="headerlink" title="（1）”名称/值”对的集合 ：不同语言中，它被理解为对象(object)，记录(record)，结构(struct)，字典(dictionary)，哈希表(hash table)，键列表(keyed list)等。"></a>（1）”名称/值”对的集合 ：不同语言中，它被理解为对象(object)，记录(record)，结构(struct)，字典(dictionary)，哈希表(hash table)，键列表(keyed list)等。</h5><h5 id="（2）值的有序列表：-多数语言中被理解为数组-array-。"><a href="#（2）值的有序列表：-多数语言中被理解为数组-array-。" class="headerlink" title="（2）值的有序列表： 多数语言中被理解为数组(array)。"></a>（2）值的有序列表： 多数语言中被理解为数组(array)。</h5><h4 id="3-JSON的形式主要有以下两种："><a href="#3-JSON的形式主要有以下两种：" class="headerlink" title="3.JSON的形式主要有以下两种："></a>3.JSON的形式主要有以下两种：</h4><h5 id="（1）对象"><a href="#（1）对象" class="headerlink" title="（1）对象"></a>（1）<font color="red">对象</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093521448.png" alt="image-20201219093521448"></p>
<h5 id="（2）数组"><a href="#（2）数组" class="headerlink" title="（2）数组"></a>（2）<font color="red">数组</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093539871.png" alt="image-20201219093539871"></p>
<h3 id="二、使用JSONObject解析JSON数据"><a href="#二、使用JSONObject解析JSON数据" class="headerlink" title="二、使用JSONObject解析JSON数据"></a>二、使用JSONObject解析JSON数据</h3><h4 id="1-案例：CityCodeDemo"><a href="#1-案例：CityCodeDemo" class="headerlink" title="1. 案例：CityCodeDemo"></a>1. 案例：CityCodeDemo</h4><p>通过Spinner控件，读取中国的城市名称，并通过选择获得该城市对应的编码值。</p>
<h5 id="1-准备JSON数据-创建assets目录"><a href="#1-准备JSON数据-创建assets目录" class="headerlink" title="(1)准备JSON数据,创建assets目录"></a>(1)准备JSON数据,创建assets目录</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093921547.png" alt="image-20201219093921547"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094342080.png" alt="image-20201219094342080"></p>
<h5 id="2-布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。"><a href="#2-布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。" class="headerlink" title="(2)布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。"></a>(2)布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。</h5><h5 id="3-启动异步任务，进行文件读取"><a href="#3-启动异步任务，进行文件读取" class="headerlink" title="(3)启动异步任务，进行文件读取"></a>(3)启动异步任务，进行文件读取</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094525406.png" alt="image-20201219094525406"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219095314825.png" alt="image-20201219095314825"></p>
<h5 id="（4）定义实体类。装载JSON的解析结果"><a href="#（4）定义实体类。装载JSON的解析结果" class="headerlink" title="（4）定义实体类。装载JSON的解析结果"></a>（4）定义实体类。装载JSON的解析结果</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094831461.png" alt="image-20201219094831461"></p>
<h5 id="（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表"><a href="#（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表" class="headerlink" title="（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表"></a>（5）<font color="red">解析JSON内容。将字符串转换为对应的CityCode实体对象列表</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219095531426.png" alt="image-20201219095531426"></p>
<h5 id="（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听"><a href="#（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听" class="headerlink" title="（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听"></a>（6）绑定界面控件。将解析得到的List<CityCode>通过适配器，绑定到spinner控件上，并设置子项监听</CityCode></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219100105438.png" alt="image-20201219100105438"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219100112597.png" alt="image-20201219100112597"></p>
<h4 id="2-安卓的资源文件assets"><a href="#2-安卓的资源文件assets" class="headerlink" title="2.安卓的资源文件assets"></a>2.安卓的资源文件assets</h4><h5 id="（1）Android资源文件的存放位置有三种："><a href="#（1）Android资源文件的存放位置有三种：" class="headerlink" title="（1）Android资源文件的存放位置有三种："></a>（1）Android资源文件的存放位置有三种：</h5><ul>
<li><h5 id="res目录下存放的可编译的资源文件；"><a href="#res目录下存放的可编译的资源文件；" class="headerlink" title="res目录下存放的可编译的资源文件；"></a><font color="orange">res</font>目录下存放的<font color="orange">可编译的资源文件</font>；</h5></li>
<li><h5 id="assets目录下存放的原生资源文件；"><a href="#assets目录下存放的原生资源文件；" class="headerlink" title="assets目录下存放的原生资源文件；"></a><font color="orange">assets</font>目录下存放的<font color="orange">原生资源文件</font>；</h5></li>
<li><h5 id="res-raw目录下存放的原生资源文件"><a href="#res-raw目录下存放的原生资源文件" class="headerlink" title="res/raw目录下存放的原生资源文件"></a><font color="orange">res/raw</font>目录下存放的<font color="orange">原生资源文件</font></h5></li>
</ul>
<h5 id="（2）assets与res-raw相同之处"><a href="#（2）assets与res-raw相同之处" class="headerlink" title="（2）assets与res/raw相同之处"></a>（2）assets与res/raw<font color="cornflowerblue">相同</font>之处</h5><ol>
<li>都可以用于放置APP所需的固定文件</li>
<li>该文件被打包到APK中时，不会被编码到二进制文件</li>
</ol>
<h5 id="（3）assets与res-raw不同之处"><a href="#（3）assets与res-raw不同之处" class="headerlink" title="（3）assets与res/raw不同之处"></a>（3）assets与res/raw<font color="cornflowerblue">不同</font>之处</h5><ol>
<li>assets目录不会被映射到R中，因此，资源无法通过R.id方式获取，必须要通过AssetManager进行操作与获取；res/raw目录下的资源会被映射到R中，可以通过getResource()方法获取资源。</li>
<li>多级目录：assets下可以有多级目录，res/raw下不可以有多级目录。</li>
</ol>
<h3 id="三、使用Goole-Gson解析JSON数据"><a href="#三、使用Goole-Gson解析JSON数据" class="headerlink" title="三、使用Goole Gson解析JSON数据"></a>三、使用Goole Gson解析JSON数据</h3><h4 id="1-Gson概述"><a href="#1-Gson概述" class="headerlink" title="1.Gson概述"></a>1.Gson概述</h4><h5 id="（1）Gson的解析非常简单-必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。"><a href="#（1）Gson的解析非常简单-必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。" class="headerlink" title="（1）Gson的解析非常简单:必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。"></a>（1）Gson的解析非常简单:必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。</h5><h5 id="（2）Gson有两个重要的方法"><a href="#（2）Gson有两个重要的方法" class="headerlink" title="（2）Gson有两个重要的方法"></a>（2）Gson有两个重要的方法</h5><p><font color="red">toJson（）</font>：序列化Java对象成JSON字符串</p>
<p><font color="red">fromJson()</font>：反序列化对象成Java对象</p>
<h4 id="2-解析Json数据"><a href="#2-解析Json数据" class="headerlink" title="2.解析Json数据"></a>2.解析Json数据</h4><h5 id="（1）准备一个Person类"><a href="#（1）准备一个Person类" class="headerlink" title="（1）准备一个Person类"></a>（1）准备一个Person类</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101538843.png" alt="image-20201219101538843"></p>
<h5 id="（2））toJson-方法用于将bean对象换为Json数据"><a href="#（2））toJson-方法用于将bean对象换为Json数据" class="headerlink" title="（2））toJson()方法用于将bean对象换为Json数据"></a>（2））toJson()方法用于将bean对象换为Json数据</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101558372.png" alt="image-20201219101558372"></p>
<h5 id="（3）fromJson-方法用于将Json数据转换为bean对象"><a href="#（3）fromJson-方法用于将Json数据转换为bean对象" class="headerlink" title="（3）fromJson()方法用于将Json数据转换为bean对象"></a>（3）fromJson()方法用于将Json数据转换为bean对象</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101620318.png" alt="image-20201219101620318"></p>
<h2 id="网络通信框架Volley"><a href="#网络通信框架Volley" class="headerlink" title="网络通信框架Volley"></a>网络通信框架Volley</h2><h3 id="一、Volley概述"><a href="#一、Volley概述" class="headerlink" title="一、Volley概述"></a>一、Volley概述</h3><h4 id="1-Volley特别适合数据量不大但通信频繁的场景"><a href="#1-Volley特别适合数据量不大但通信频繁的场景" class="headerlink" title="1.Volley特别适合数据量不大但通信频繁的场景"></a>1.Volley特别适合<font color="cornflowerblue">数据量不大但通信频繁</font>的场景</h4><h4 id="2-不使用Volley，从网上下载资源的步骤大致如下："><a href="#2-不使用Volley，从网上下载资源的步骤大致如下：" class="headerlink" title="2.不使用Volley，从网上下载资源的步骤大致如下："></a>2.不使用Volley，从网上下载资源的步骤大致如下：</h4><h5 id="（1）首先，在AsyncTask的doInBackground-中，使用HttpURLConnection从服务器获取相关资源。"><a href="#（1）首先，在AsyncTask的doInBackground-中，使用HttpURLConnection从服务器获取相关资源。" class="headerlink" title="（1）首先，在AsyncTask的doInBackground()中，使用HttpURLConnection从服务器获取相关资源。"></a>（1）首先，在AsyncTask的doInBackground()中，使用HttpURLConnection从服务器获取相关资源。</h5><h5 id="（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute-里设置到相应的控件中。"><a href="#（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute-里设置到相应的控件中。" class="headerlink" title="（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute()里设置到相应的控件中。"></a>（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute()里设置到相应的控件中。</h5><h5 id="而在Volley下，上述只需要一个函数就可以完成上述步骤"><a href="#而在Volley下，上述只需要一个函数就可以完成上述步骤" class="headerlink" title="而在Volley下，上述只需要一个函数就可以完成上述步骤"></a>而在Volley下，上述只需要一个函数就可以完成上述步骤</h5><h3 id="二、Volley的使用步骤"><a href="#二、Volley的使用步骤" class="headerlink" title="二、Volley的使用步骤"></a>二、Volley的使用步骤</h3><h4 id="1-声明RequestQueue"><a href="#1-声明RequestQueue" class="headerlink" title="1.声明RequestQueue"></a>1.声明<font color="cornflowerblue">RequestQueue</font></h4><h4 id="2-为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象"><a href="#2-为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象" class="headerlink" title="2.为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象"></a>2.为了获得请求的响应，我们需要根据响应的结果，<font color="cornflowerblue">调用不同的Request对象</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102328576.png" alt="image-20201219102328576"></p>
<h3 id="三、通过Volley获取字符串"><a href="#三、通过Volley获取字符串" class="headerlink" title="三、通过Volley获取字符串"></a>三、通过Volley获取字符串</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102423614.png" alt="image-20201219102423614"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102436859.png" alt="image-20201219102436859"></p>
<h3 id="四、通过Volley获取JSON数据"><a href="#四、通过Volley获取JSON数据" class="headerlink" title="四、通过Volley获取JSON数据"></a>四、通过Volley获取JSON数据</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102603231.png" alt="image-20201219102603231"></p>
<h3 id="五、通过Volley获取图片资源"><a href="#五、通过Volley获取图片资源" class="headerlink" title="五、通过Volley获取图片资源"></a>五、通过Volley获取图片资源</h3><h4 id="1-ImageRequest"><a href="#1-ImageRequest" class="headerlink" title="1.ImageRequest"></a>1.ImageRequest</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102644623.png" alt="image-20201219102644623"></p>
<h4 id="2-ImageLoader"><a href="#2-ImageLoader" class="headerlink" title="2.ImageLoader"></a>2.ImageLoader</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102720895.png" alt="image-20201219102720895"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102741316.png" alt="image-20201219102741316"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102801828.png" alt="image-20201219102801828"></p>
<h1 id="第十章-后台默默劳动者——服务"><a href="#第十章-后台默默劳动者——服务" class="headerlink" title="第十章 后台默默劳动者——服务"></a>第十章 后台默默劳动者——服务</h1><h2 id="Android多线程编程"><a href="#Android多线程编程" class="headerlink" title="Android多线程编程"></a>Android多线程编程</h2><h3 id="一、线程概述"><a href="#一、线程概述" class="headerlink" title="一、线程概述"></a>一、线程概述</h3><h4 id="1-Android系统中，App运行后默认创建一个线程，即主线程。"><a href="#1-Android系统中，App运行后默认创建一个线程，即主线程。" class="headerlink" title="1.Android系统中，App运行后默认创建一个线程，即主线程。"></a>1.Android系统中，App运行后默认创建一个线程，即<font color="red">主线程</font>。</h4><p>​        ——Activity、Service和BroadcastReceiver都是工作在主线程上。</p>
<h4 id="2-主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。"><a href="#2-主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。" class="headerlink" title="2.主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。"></a>2.主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做<font color="red">UI线程</font>。</h4><pre><code> 主线程中任何耗时的操作都会的降低用户界面的响应速度，甚至导致用户界面失去响应。
</code></pre>
<p>例如，发起一条网络请求时，考虑到网速等其他原因，服务器未必会立刻响应我们的请求</p>
<p>​    较好的解决方法是<font color="orange">将耗时的处理过程转移到子线程上</font>，这样可以避免负责界面更新的主线程（UI线程）无法处理界面事件，从而避免用户界面长时间失去响应。</p>
<h3 id="二、主线程和子线程"><a href="#二、主线程和子线程" class="headerlink" title="二、主线程和子线程"></a>二、主线程和子线程</h3><h4 id="1-主线程"><a href="#1-主线程" class="headerlink" title="1.主线程"></a>1.主线程</h4><ul>
<li><p>UI线程，负责处理与UI相关的事件，并把事件分发到对应的组件进行处理。</p>
</li>
<li><p>应用首次启动时，Android会启动一个Linux进程和一个主线程。</p>
</li>
<li><p>Android <font color="red">UI操作必须在UI线程中执行</font>。由于Android的UI是单线程(Single-threaded)的，当其任务繁重时，则需要其他线程来进行配合工作。</p>
</li>
</ul>
<h4 id="2-子线程"><a href="#2-子线程" class="headerlink" title="2.子线程"></a>2.子线程</h4><ul>
<li>非UI线程即为子线程，子线程一般都是<font color="red">后台线程</font>。</li>
<li>运用子线程的场合：进行数据、系统等其他非UI的操作或者把所有运行慢的、耗时的操作移出主线程，放到子线程中。</li>
<li>通常，子线程需要开发人员对其进行定义、启动、终止等操作控制。</li>
</ul>
<h3 id="三、同步与异步"><a href="#三、同步与异步" class="headerlink" title="三、同步与异步"></a>三、同步与异步</h3><h4 id="1-同步：需要等待放回结果"><a href="#1-同步：需要等待放回结果" class="headerlink" title="1.同步：需要等待放回结果"></a>1.同步：需要等待放回结果</h4><h4 id="异步：不需要等待返回结果"><a href="#异步：不需要等待返回结果" class="headerlink" title="异步：不需要等待返回结果"></a>异步：不需要等待返回结果</h4><h4 id="2-无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。"><a href="#2-无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。" class="headerlink" title="2.无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。"></a>2.无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要<font color="red">线程间通讯</font>的方法来实现在其他线程中发消息给主线程处理（更新UI）。</h4><h3 id="四、线程间通讯"><a href="#四、线程间通讯" class="headerlink" title="四、线程间通讯"></a>四、线程间通讯</h3><h4 id="1-Activity-runOnUiThread-Runnable"><a href="#1-Activity-runOnUiThread-Runnable" class="headerlink" title="1) Activity.runOnUiThread(Runnable)"></a>1) Activity.runOnUiThread(Runnable)</h4><h4 id="2-View-post-Runnable-View-postDelay-Runnable-long"><a href="#2-View-post-Runnable-View-postDelay-Runnable-long" class="headerlink" title="2) View.post(Runnable) ;View.postDelay(Runnable , long)"></a>2) View.post(Runnable) ;View.postDelay(Runnable , long)</h4><h4 id="3-Handler"><a href="#3-Handler" class="headerlink" title="3) Handler"></a>3) <font color="red">Handler</font></h4><h4 id="post-postDelay"><a href="#post-postDelay" class="headerlink" title="post, postDelay"></a><font color="red">post, postDelay</font></h4><h4 id="sendMessage-handleMessage"><a href="#sendMessage-handleMessage" class="headerlink" title="sendMessage, handleMessage"></a><font color="red">sendMessage, handleMessage</font></h4><h4 id="4-AsyncTask"><a href="#4-AsyncTask" class="headerlink" title="4) AsyncTask"></a>4) <font color="red">AsyncTask</font></h4><h4 id="5-广播"><a href="#5-广播" class="headerlink" title="5) 广播"></a>5) <font color="cornflowerblue">广播</font></h4><h3 id="五、线程的状态和生命周期"><a href="#五、线程的状态和生命周期" class="headerlink" title="五、线程的状态和生命周期"></a>五、线程的状态和生命周期</h3><ol>
<li><h4 id="创建状态"><a href="#创建状态" class="headerlink" title="创建状态"></a>创建状态</h4><p>用new运算符创建一个Thread类或子类的<font color="orange">实例对象</font>，但此时还未对这个线程分配任何资源</p>
</li>
<li><h4 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h4><p>分配系统资源，由<font color="orange">start()启动</font>方法来完成</p>
</li>
<li><h4 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h4><p>当可运行状态的线程被调度并获得CPU等资源。<font color="orange">进入run()</font>方法。</p>
</li>
<li><h4 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h4><p>由于人为或系统的原因，线程必须停止运行，以后还可以恢复运行的状态称为阻塞状态。</p>
</li>
<li><h4 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h4><p>run()方法完成或调用<font color="orange">stop()</font>或<font color="orange">destroy()</font>方法，不能继续运行。</p>
</li>
</ol>
<h3 id="六、线程的基本用法"><a href="#六、线程的基本用法" class="headerlink" title="六、线程的基本用法"></a>六、线程的基本用法</h3><h4 id="1-创建线程的方法"><a href="#1-创建线程的方法" class="headerlink" title="1. 创建线程的方法"></a>1. 创建线程的方法</h4><h5 id="（1）方法一：通过继承Thread类创建线程"><a href="#（1）方法一：通过继承Thread类创建线程" class="headerlink" title="（1）方法一：通过继承Thread类创建线程"></a>（1）方法一：通过<font color="red">继承Thread类</font>创建线程</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124132913675.png" alt="image-20201124132913675"></p>
<h5 id="（2）方法二：通过实现Runnable接口来创建线程"><a href="#（2）方法二：通过实现Runnable接口来创建线程" class="headerlink" title="（2）方法二：通过实现Runnable接口来创建线程"></a>（2）方法二：通过<font color="red">实现Runnable接口</font>来创建线程</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124133310441.png" alt="image-20201124133310441"></p>
<h5 id="（3）方法三：不实现Runnable接口，直接使用匿名类的方式"><a href="#（3）方法三：不实现Runnable接口，直接使用匿名类的方式" class="headerlink" title="（3）方法三：不实现Runnable接口，直接使用匿名类的方式"></a>（3）方法三：不实现Runnable接口，直接<font color="red">使用匿名类</font>的方式</h5><h5 id="（方式二的简化）"><a href="#（方式二的简化）" class="headerlink" title="（方式二的简化）"></a>（方式二的简化）</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124133439513.png" alt="image-20201124133439513"></p>
<h4 id="2-线程的运行与停止"><a href="#2-线程的运行与停止" class="headerlink" title="2.线程的运行与停止"></a>2.线程的运行与停止</h4><h5 id="（1）myThread-interrupt"><a href="#（1）myThread-interrupt" class="headerlink" title="（1）myThread. interrupt ();"></a>（1）myThread<font color="cornflowerblue">. interrupt ();</font></h5><p>​        线程启动后并获得资源后，即可进入运行状态，执行run()方法中的业务逻辑。<br>在run()方法返回后，线程<font color="orange">自动终止</font>。</p>
<p>或者由主线程通知子线程终止，一般<font color="orange">调用interrupt()方法</font>通告线程准备终止</p>
<h5 id="（2）Thread-interrupted"><a href="#（2）Thread-interrupted" class="headerlink" title="（2）Thread.interrupted()"></a>（2）Thread.<font color="cornflowerblue">interrupted()</font></h5><p>​        interrupt()方法改变了线程内部的一个布尔值，可在run()方法检测到这个布尔值的改变，从而<font color="orange">在适当的时候释放资源和终止</font>线程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">run</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">while</span>(!Thread.<span class="built_in">interrupted</span>())&#123;</span><br><span class="line">         ...	<span class="comment">//未调用myThread.interrupt()时循环执行</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="七、异步消息处理机制（Handler-Message）"><a href="#七、异步消息处理机制（Handler-Message）" class="headerlink" title="七、异步消息处理机制（Handler + Message）"></a>七、异步消息处理机制（Handler + Message）</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140620842.png" alt="image-20201124140620842"></p>
<h4 id="1-异步消息处理流程"><a href="#1-异步消息处理流程" class="headerlink" title="1.异步消息处理流程"></a>1.异步消息处理流程</h4><h5 id="（1）主线程：创建Handler对象，重写handleMessage方法"><a href="#（1）主线程：创建Handler对象，重写handleMessage方法" class="headerlink" title="（1）主线程：创建Handler对象，重写handleMessage方法"></a>（1）主线程：创建Handler对象，重写handleMessage方法</h5><h5 id="（2）子线程：创建Message对象，发送消息"><a href="#（2）子线程：创建Message对象，发送消息" class="headerlink" title="（2）子线程：创建Message对象，发送消息"></a>（2）子线程：创建Message对象，发送消息</h5><p>​                当子线程需要进行UI操作时，就<font color="orange">创建Message</font>对象，并通过Handler的            <font color="orange">sendMessage()方法</font>（参数是Message对象），将将这条消息发送出去。            这条待处理的消息会被 添加到主线程的<font color="orange">MessageQueue</font>中。</p>
<h5 id="（3）主线程：处理消息，回调handleMessage"><a href="#（3）主线程：处理消息，回调handleMessage" class="headerlink" title="（3）主线程：处理消息，回调handleMessage"></a>（3）主线程：处理消息，回调handleMessage</h5><p>​            主线程通过<font color="orange">Looper管理</font>MessageQueue，不断地尝试从消息队列中取出    待处理消息进行处理，取出消息时就会回调 Handler的<font color="orange">handlerMessage()</font>方法</p>
<p>​        </p>
<h4 id="2-Hander类"><a href="#2-Hander类" class="headerlink" title="2.Hander类"></a>2.<font color="cornflowerblue">Hander</font>类</h4><p>使用Hnadler类的sendMessage()方法把一个包含消息数据的Message对象压入到消息队列。其它可选方法还包括：<br>sendEmptyMessage(int)<br>sendMessage(Message)<br>sendMessageAtTime(Message,long)<br>sendMessageDelayed(Message,long)</p>
<h4 id="3-Message类"><a href="#3-Message类" class="headerlink" title="3.Message类"></a>3.<font color="cornflowerblue">Message</font>类</h4><h5 id="（1）Message对象："><a href="#（1）Message对象：" class="headerlink" title="（1）Message对象："></a>（1）Message对象：</h5><p>推荐使用<font color="red">Message.obtain()</font> 静态方法从消息池中获取一个Message对象。<br>如果消息池为空， 将使用构造方法实例化一个新Message，以利于消息资源的利用。<br>一般并不推荐直接使用它的构造方法</p>
<h5 id="（2）用来封装所发送消息的值："><a href="#（2）用来封装所发送消息的值：" class="headerlink" title="（2）用来封装所发送消息的值："></a>（2）用来封装所发送消息的值：</h5><p>int arg1：参数一，用于传递不复杂的数据，复杂数据使用setData()传递。<br>int arg2：参数二，用于传递不复杂的数据，复杂数据使用setData()传递。<br>Object obj：传递一个任意的对象。<br>int what：定义的消息码，一般用于设定消息的标志。</p>
<h5 id="3-传递复杂数据-setData"><a href="#3-传递复杂数据-setData" class="headerlink" title="(3)传递复杂数据 setData()"></a>(3)传递复杂数据 setData()</h5><p>​    –void setData( Bundle bundle)</p>
<p>​    –Bundle getData()</p>
<h4 id="2-案例实现：幸运大抽奖（方式一）"><a href="#2-案例实现：幸运大抽奖（方式一）" class="headerlink" title="2.案例实现：幸运大抽奖（方式一）"></a>2.案例实现：幸运大抽奖（方式一）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140746244.png" alt="image-20201124140746244"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140752579.png" alt="image-20201124140752579"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140759685.png" alt="image-20201124140759685"></p>
<h3 id="八、异步消息处理机制（Handler-Post）"><a href="#八、异步消息处理机制（Handler-Post）" class="headerlink" title="八、异步消息处理机制（Handler + Post）"></a>八、异步消息处理机制（Handler + Post）</h3><h4 id="1-Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。-在主线程中执行"><a href="#1-Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。-在主线程中执行" class="headerlink" title="1. Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。(在主线程中执行)"></a>1. Handler也可以把一个<font color="cornflowerblue">Runnable对象</font>压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。(<font color="red">在主线程中执行</font>)</h4><h5 id="（1）把一个Runnable对象入队到消息队列-方法有："><a href="#（1）把一个Runnable对象入队到消息队列-方法有：" class="headerlink" title="（1）把一个Runnable对象入队到消息队列,方法有："></a>（1）把一个Runnable对象入队到消息队列,方法有：</h5><ul>
<li><p><font color="red">post</font>(Runnable)</p>
</li>
<li><p>postAtTime(Runnable,long)</p>
</li>
<li><p>postDelayed(Runnable,long)</p>
</li>
</ul>
<h5 id="2-从消息队列中移除一个Runnable对象"><a href="#2-从消息队列中移除一个Runnable对象" class="headerlink" title="(2)从消息队列中移除一个Runnable对象"></a>(2)从消息队列中移除一个Runnable对象</h5><p>​            void <font color="red">removeCallbacks</font>(Runnable r)</p>
<h4 id="2-对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run-方法。一般在这个run-方法中写入需要在UI线程上的操作。"><a href="#2-对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run-方法。一般在这个run-方法中写入需要在UI线程上的操作。" class="headerlink" title="2.对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run()方法。一般在这个run()方法中写入需要在UI线程上的操作。"></a>2.对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，<font color="red">重写run()方法</font>。一般在这个run()方法中写入<font color="red">需要在UI线程上的操作</font>。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201130202655320.png" alt="image-20201130202655320"></p>
<h4 id="3-案例实现：幸运大抽奖（方式二）"><a href="#3-案例实现：幸运大抽奖（方式二）" class="headerlink" title="3. 案例实现：幸运大抽奖（方式二）"></a>3. 案例实现：幸运大抽奖（方式二）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201130203252201.png" alt="image-20201130203252201"></p>
<h2 id="服务的原理和用途"><a href="#服务的原理和用途" class="headerlink" title="服务的原理和用途"></a>服务的原理和用途</h2><h3 id="一、启动服务的两种状态"><a href="#一、启动服务的两种状态" class="headerlink" title="一、启动服务的两种状态"></a>一、启动服务的两种状态</h3><h4 id="1-启动状态：通过Context的startService-启动service"><a href="#1-启动状态：通过Context的startService-启动service" class="headerlink" title="1.启动状态：通过Context的startService()启动service"></a>1.<font color="cornflowerblue">启动状态</font>：通过Context的<font color="red">startService()</font>启动service</h4><h5 id="一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService-或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁"><a href="#一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService-或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁" class="headerlink" title="一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService()或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁"></a>一旦启动，服务即<font color="orange">可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响</font>，除非手动调用stopService()或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁</h5><h4 id="2-绑定状态：通过Context的bindService-绑定Service"><a href="#2-绑定状态：通过Context的bindService-绑定Service" class="headerlink" title="2.绑定状态：通过Context的bindService()绑定Service"></a>2.<font color="cornflowerblue">绑定状态</font>：通过Context的<font color="red">bindService()</font>绑定Service</h4><p>​        <font color="orange">绑定服务提供了一个客户端-服务器接口，允许调用方与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。</font> 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个调用方可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁</p>
<h3 id="二、在清单文件中的声明"><a href="#二、在清单文件中的声明" class="headerlink" title="二、在清单文件中的声明"></a>二、在清单文件中的声明</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201125094605395.png" alt="image-20201125094605395"></p>
<h3 id="四、使用Service"><a href="#四、使用Service" class="headerlink" title="四、使用Service"></a>四、使用Service</h3><h4 id="1-首先要创建服务，必须创建-Service-的子类（或使用它的一个现有子类如IntentService）。"><a href="#1-首先要创建服务，必须创建-Service-的子类（或使用它的一个现有子类如IntentService）。" class="headerlink" title="1.首先要创建服务，必须创建 Service 的子类（或使用它的一个现有子类如IntentService）。"></a>1.首先要创建服务，必须<font color="red">创建 Service 的子类</font>（或使用它的一个现有子类如IntentService）。</h4><h4 id="2-类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。"><a href="#2-类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。" class="headerlink" title="2.类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。"></a>2.类似Activity，Service有自己的生命周期，因此在实现中需要<font color="red">重写一些回调方法</font>，以处理服务生命周期的某些关键过程。</h4><h4 id="3-随后，组件-例如活动-以启动或者绑定方式启动服务，服务开始其生命过程"><a href="#3-随后，组件-例如活动-以启动或者绑定方式启动服务，服务开始其生命过程" class="headerlink" title="3.随后，组件(例如活动)以启动或者绑定方式启动服务，服务开始其生命过程"></a>3.随后，组件(例如活动)以<font color="red">启动或者绑定方式启动服务</font>，服务开始其生命过程</h4><h3 id="五、Service中常用回调方法"><a href="#五、Service中常用回调方法" class="headerlink" title="五、Service中常用回调方法"></a>五、Service中常用回调方法</h3><h4 id="1-abstract-IBinder-onBind-Intent-intent"><a href="#1-abstract-IBinder-onBind-Intent-intent" class="headerlink" title="1.abstract IBinder onBind(Intent intent)"></a>1.abstract IBinder <font color="cornflowerblue">onBind</font>(Intent intent)</h4><p>该方法是一个抽象方法，所有Service子类必须实现该方法。该方法将返回一个IBinder对象，应用程序可<font color="red">通过该对象与Service组件通信</font>；</p>
<h4 id="2-void-onCreate"><a href="#2-void-onCreate" class="headerlink" title="2.void onCreate()"></a>2.void <font color="cornflowerblue">onCreate()</font></h4><p>当Service<font color="red">第一次被创建时</font>，将立即回调该方法；</p>
<h4 id="3-void-onDestroy"><a href="#3-void-onDestroy" class="headerlink" title="3.void onDestroy()"></a>3.void <font color="cornflowerblue">onDestroy()</font></h4><p>当Service<font color="red">被关闭之前</font>，将回调该方法</p>
<h4 id="4-void-onStartCommand-Intent-intent-int-flags-int-startId"><a href="#4-void-onStartCommand-Intent-intent-int-flags-int-startId" class="headerlink" title="4.void onStartCommand(Intent intent,int flags,int startId)"></a>4.void <font color="cornflowerblue">onStartCommand(Intent intent,int flags,int startId)</font></h4><p>每次客户端调用startService(Intent intent)方法<font color="red">启动</font>该Service时<font color="red">都会回调</font>onStartCommand()方法</p>
<h4 id="5-boolean-onUnbind-Intent-intent"><a href="#5-boolean-onUnbind-Intent-intent" class="headerlink" title="5.boolean onUnbind(Intent intent)"></a>5.boolean <font color="cornflowerblue">onUnbind(Intent intent)</font></h4><p>当该Service上绑定的所有客户端都<font color="red">断开连接</font>时将会回调该方法。</p>
<h3 id="六、活动的生命周期"><a href="#六、活动的生命周期" class="headerlink" title="六、活动的生命周期"></a>六、活动的生命周期</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201125095321429.png" alt="image-20201125095321429"></p>
<h2 id="启动方式启动服务"><a href="#启动方式启动服务" class="headerlink" title="启动方式启动服务"></a>启动方式启动服务</h2><h3 id="一、StartService生命周期及进程相关"><a href="#一、StartService生命周期及进程相关" class="headerlink" title="一、StartService生命周期及进程相关"></a>一、StartService生命周期及进程相关</h3><h4 id="1-对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。"><a href="#1-对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。" class="headerlink" title="1.对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。"></a>1.对于同一类型的Service，<font color="red">Service实例永远只存在一个</font>，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。</h4><h4 id="2-以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService-或服务本身调用stopSelf-才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service"><a href="#2-以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService-或服务本身调用stopSelf-才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service" class="headerlink" title="2.以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService(..)或服务本身调用stopSelf(..)才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service"></a>2.以启动方式运行的服务，其<font color="red">生命周期是独立的，与Client本身的生命周期没有任何关系</font>，只有Client调用stopService(..)或服务本身调用stopSelf(..)才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service</h4><h4 id="3-Client-A-通过startService-启动Service后-可以在其他Client（如Client-B、Client-C）通过调用stopService-结束此Service"><a href="#3-Client-A-通过startService-启动Service后-可以在其他Client（如Client-B、Client-C）通过调用stopService-结束此Service" class="headerlink" title="3.Client A 通过startService(..)启动Service后,可以在其他Client（如Client B、Client C）通过调用stopService(..)结束此Service"></a>3.Client A 通过<font color="red">startService(..)</font>启动Service后,可以在其他Client（如Client B、Client C）通过调用<font color="red">stopService(..)结束</font>此Service</h4><h4 id="4-Client调用stopService-时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService-无需做当前Service是否有效的判断。"><a href="#4-Client调用stopService-时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService-无需做当前Service是否有效的判断。" class="headerlink" title="4.Client调用stopService(..)时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService(..)无需做当前Service是否有效的判断。"></a>4.Client调用stopService(..)时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService(..)<font color="red">无需做当前Service是否有效的判断。</font></h4><h4 id="5-startService-Intent-serviceIntent-，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。"><a href="#5-startService-Intent-serviceIntent-，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。" class="headerlink" title="5.startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。"></a>5.startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用<font color="red">显示Intent</font>。当处于不同App时，只能使用隐式Intent。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111515792.png" alt="image-20201214111515792"></p>
<h3 id="二、Client与Service通信相关"><a href="#二、Client与Service通信相关" class="headerlink" title="二、Client与Service通信相关"></a>二、Client与Service通信相关</h3><h4 id="1-启动Service时"><a href="#1-启动Service时" class="headerlink" title="1.启动Service时"></a>1.启动Service时</h4><h5 id="当Client调用startService-Intent-serviceIntent-启动Service时，Client可以将参数通过Intent直接传递给Service。"><a href="#当Client调用startService-Intent-serviceIntent-启动Service时，Client可以将参数通过Intent直接传递给Service。" class="headerlink" title="当Client调用startService(Intent serviceIntent)启动Service时，Client可以将参数通过Intent直接传递给Service。"></a>当Client调用startService(Intent serviceIntent)<font color="red">启动Service</font>时，Client可以<font color="red">将参数通过Intent直接传递</font>给Service。</h5><h4 id="2-Service执行过程中"><a href="#2-Service执行过程中" class="headerlink" title="2.Service执行过程中"></a>2.Service执行过程中</h4><h5 id="Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。"><a href="#Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。" class="headerlink" title="Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。"></a><font color="red">Service执行过程</font>中，如果需要将参数传递给Client，一般可以通过<font color="red">借助于发送广播</font>的方式（此时，Client需要注册此广播）。</h5><h2 id="绑定方式启动服务"><a href="#绑定方式启动服务" class="headerlink" title="绑定方式启动服务"></a>绑定方式启动服务</h2><h3 id="一、三个基本特征"><a href="#一、三个基本特征" class="headerlink" title="一、三个基本特征"></a>一、三个基本特征</h3><h4 id="1-C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器"><a href="#1-C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器" class="headerlink" title="1.C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器"></a>1.<font color="cornflowerblue">C-S模式</font>：绑定状态的服务代表着客户端-服务器接口中的<font color="orange">服务器</font></h4><h4 id="2-交互与通信：当其他组件（如-Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信-。"><a href="#2-交互与通信：当其他组件（如-Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信-。" class="headerlink" title="2.交互与通信：当其他组件（如 Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信 。"></a>2.<font color="cornflowerblue">交互与通信</font>：当其他组件（如 Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，<font color="orange">或者调用Service（服务端）的方法</font>，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信 。</h4><h4 id="3-生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件-如Activity-服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主-如Activity-解除绑定后，绑定服务就会被销毁。"><a href="#3-生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件-如Activity-服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主-如Activity-解除绑定后，绑定服务就会被销毁。" class="headerlink" title="3.生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主(如Activity)解除绑定后，绑定服务就会被销毁。"></a>3.<font color="cornflowerblue">生命周期</font>：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说所有<font color="orange">宿主(如Activity)解除绑定后，绑定服务就会被销毁</font>。</h4><h3 id="二、BindService生命周期"><a href="#二、BindService生命周期" class="headerlink" title="二、BindService生命周期"></a>二、BindService生命周期</h3><h4 id="1-onBind方法只被调用一次。（当调用bindService-方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind-方法。"><a href="#1-onBind方法只被调用一次。（当调用bindService-方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind-方法。" class="headerlink" title="1.onBind方法只被调用一次。（当调用bindService()方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind()方法。"></a>1.onBind方法只被调用一次。（当调用<font color="orange">bindService()</font>方法是）Service第一次被创建时会执行<font color="red">onCreate</font>方法，之后自动调用<font color="red">onBind()</font>方法。</h4><h4 id="2-当调用unBindService-方法时，Service会依次执行onUnbind-、onDestroy-方法结束生命周期"><a href="#2-当调用unBindService-方法时，Service会依次执行onUnbind-、onDestroy-方法结束生命周期" class="headerlink" title="2.当调用unBindService()方法时，Service会依次执行onUnbind()、onDestroy()方法结束生命周期"></a>2.当调用<font color="orange">unBindService()</font>方法时，Service会依次执行<font color="red">onUnbind()</font>、<font color="red">onDestroy()</font>方法结束生命周期</h4><h4 id="3-如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService-解除绑定。"><a href="#3-如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService-解除绑定。" class="headerlink" title="3.如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService()解除绑定。"></a>3.如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService()解除绑定。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/577f98926daf5.jpg" alt="img"></p>
<h3 id="三、一般流程！！！"><a href="#三、一般流程！！！" class="headerlink" title="三、一般流程！！！"></a>三、一般流程！！！</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111833380.png" alt="image-20201214111833380"></p>
<h4 id="1-服务端，Service中"><a href="#1-服务端，Service中" class="headerlink" title="1.服务端，Service中"></a>1.服务端，Service中</h4><h5 id="（1）创建Binder子类，返回服务实例对象"><a href="#（1）创建Binder子类，返回服务实例对象" class="headerlink" title="（1）创建Binder子类，返回服务实例对象"></a>（1）<font color="cornflowerblue">创建Binder子类，返回服务实例对象</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110207275.png" alt="image-20201214110207275"></p>
<h5 id="（2）在onBind-中返回Mybinder的实例对象iBinder"><a href="#（2）在onBind-中返回Mybinder的实例对象iBinder" class="headerlink" title="（2）在onBind()中返回Mybinder的实例对象iBinder"></a>（2）<font color="cornflowerblue">在onBind()中返回Mybinder的实例对象iBinder</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110333487.png" alt="image-20201214110333487"></p>
<h4 id="2-客户端，Activity中"><a href="#2-客户端，Activity中" class="headerlink" title="2.客户端，Activity中"></a>2.客户端，Activity中</h4><h5 id="（1）创建ServiceConnection实例，在onServiceConnected-中接收返回的Binder-实例，通过Binder实例的getService-方法获取服务实例myService"><a href="#（1）创建ServiceConnection实例，在onServiceConnected-中接收返回的Binder-实例，通过Binder实例的getService-方法获取服务实例myService" class="headerlink" title="（1）创建ServiceConnection实例，在onServiceConnected 中接收返回的Binder 实例，通过Binder实例的getService()方法获取服务实例myService"></a>（1）<font color="cornflowerblue">创建ServiceConnection实例，在onServiceConnected 中接收返回的Binder 实例，通过Binder实例的getService()方法获取服务实例myService</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110911643.png" alt="image-20201214110911643"></p>
<h5 id="2-绑定之后可以通过myService方法调用服务中的方法"><a href="#2-绑定之后可以通过myService方法调用服务中的方法" class="headerlink" title="(2)绑定之后可以通过myService方法调用服务中的方法"></a>(2)<font color="cornflowerblue">绑定之后可以通过myService方法调用服务中的方法</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111553877.png" alt="image-20201214111553877"></p>
<h5 id="（3）解除绑定"><a href="#（3）解除绑定" class="headerlink" title="（3）解除绑定"></a>（3）<font color="cornflowerblue">解除绑定</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111631223.png" alt="image-20201214111631223"></p>
<p><font color="red">注：也可以将服务中的方法写在内部类mybinder中，在活动的ServiceConnect实例的onServiceConnected()中获取myBinder实例，通过这个实例调用服务中的方法。（不推荐）</font></p>
<h2 id="混合使用启动方式和绑定方式"><a href="#混合使用启动方式和绑定方式" class="headerlink" title="混合使用启动方式和绑定方式"></a>混合使用启动方式和绑定方式</h2><h3 id="一、混合开启服务"><a href="#一、混合开启服务" class="headerlink" title="一、混合开启服务"></a>一、混合开启服务</h3><p>既然<font color="red">start开启的服务不能调用方法，bind方式开启的服务生命力又很弱</font>，那么能否两种方式的有点么？答案当然是肯定的，否则服务的应用能力就太弱了。</p>
<ol>
<li><h4 id="通过startService-方式开启服务-只能通过调用stopService停止"><a href="#通过startService-方式开启服务-只能通过调用stopService停止" class="headerlink" title="通过startService()方式开启服务(只能通过调用stopService停止)"></a>通过startService()方式开启服务(只能通过调用stopService停止)</h4></li>
<li><h4 id="通过bindService进行绑定，以进行服务的方法调用-当需要的时候"><a href="#通过bindService进行绑定，以进行服务的方法调用-当需要的时候" class="headerlink" title="通过bindService进行绑定，以进行服务的方法调用(当需要的时候)"></a>通过bindService进行绑定，以进行服务的方法调用(当需要的时候)</h4></li>
<li><h4 id="通过unbindService进行解绑-不需要调用方法了，在UI线程被销毁之前解绑"><a href="#通过unbindService进行解绑-不需要调用方法了，在UI线程被销毁之前解绑" class="headerlink" title="通过unbindService进行解绑(不需要调用方法了，在UI线程被销毁之前解绑)"></a>通过unbindService进行解绑(不需要调用方法了，在UI线程被销毁之前解绑)</h4></li>
<li><h4 id="通过stopService停止服务"><a href="#通过stopService停止服务" class="headerlink" title="通过stopService停止服务"></a>通过stopService停止服务</h4></li>
</ol>
<p>这样我们就可以灵活的使用Service，<font color="red">当需要的时候可以随时进行调用，不要的时候又可以长期运行于后台而不用保留UI线程</font>。这也是服务最常见的用法。</p>
<h3 id="二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。"><a href="#二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。" class="headerlink" title="二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。"></a>二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。</h3><h3 id="三、如果想停止服务，必须调用stopService，并且所有调用-bindService-的-Context调用unbindService解绑-或者之前调用-bindService-的-Context-不存在了。"><a href="#三、如果想停止服务，必须调用stopService，并且所有调用-bindService-的-Context调用unbindService解绑-或者之前调用-bindService-的-Context-不存在了。" class="headerlink" title="三、如果想停止服务，必须调用stopService，并且所有调用 bindService 的 Context调用unbindService解绑,或者之前调用 bindService 的 Context 不存在了。"></a>三、如果想停止服务，必须<font color="cornflowerblue">调用stopService</font>，并且所有调用 bindService 的 Context调用<font color="cornflowerblue">unbindService</font><font color="orange">解绑</font>,或者之前调用 bindService 的 Context<font color="orange"> 不存在</font>了。</h3><h2 id="服务的更多使用技巧"><a href="#服务的更多使用技巧" class="headerlink" title="服务的更多使用技巧"></a>服务的更多使用技巧</h2><h3 id="一、使用前台服务"><a href="#一、使用前台服务" class="headerlink" title="一、使用前台服务"></a>一、使用前台服务</h3><h4 id="1-服务运行在后台，优先级低，系统内存不足时，可能会被回收。"><a href="#1-服务运行在后台，优先级低，系统内存不足时，可能会被回收。" class="headerlink" title="1.服务运行在后台，优先级低，系统内存不足时，可能会被回收。"></a>1.服务运行在后台，优先级低，系统内存不足时，<font color="red">可能会被回收</font>。</h4><p>如果希望服务<font color="red">可以一直保持运行状态</font>，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台服务。</p>
<h4 id="2-与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。"><a href="#2-与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。" class="headerlink" title="2.与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。"></a>2.<font color="cornflowerblue">与普通服务相比</font>：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。</h4><h4 id="3-startForeground-和stopForeground-方法"><a href="#3-startForeground-和stopForeground-方法" class="headerlink" title="3.startForeground()和stopForeground()方法"></a>3.<font color="cornflowerblue">startForeground()</font>和<font color="cornflowerblue">stopForeground()</font>方法</h4><p>startForeground(1,notification);</p>
<h3 id="二、使用IntentService"><a href="#二、使用IntentService" class="headerlink" title="二、使用IntentService"></a>二、使用IntentService</h3><p>（未完待续……）</p>
]]></content>
      <categories>
        <category>《 Android基础》</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>《Android小菜》</title>
    <url>/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/</url>
    <content><![CDATA[<div class="note success modern"><p><strong>前言：</strong>目录结构还有待优化，可直接ctrl+F搜索有无需要了解的内容<br>本笔记属于个人初学android过程时总结，如有错误或者图片缺失，还请留言指正，十分感谢！<br>仅供学习参考，如需转载请注明来自[Durango]: <a href="http://www.durango.cn/">www.durango.cn</a></p>
</div>



<h1 id="第一章-控件与布局"><a href="#第一章-控件与布局" class="headerlink" title="第一章 控件与布局"></a>第一章 控件与布局</h1><h2 id="一、界面的美化-Shape和Selector例举"><a href="#一、界面的美化-Shape和Selector例举" class="headerlink" title="一、界面的美化(Shape和Selector例举)"></a>一、界面的美化(Shape和Selector例举)</h2><h3 id="1-背景颜色的渐变"><a href="#1-背景颜色的渐变" class="headerlink" title="1.背景颜色的渐变"></a>1.背景颜色的<font color="cornflowerblue">渐变</font></h3><h4 id="res-rawable-background-login-xml-整个布局的背景，渐变背景"><a href="#res-rawable-background-login-xml-整个布局的背景，渐变背景" class="headerlink" title="res/ rawable/ background_login.xml, 整个布局的背景，渐变背景"></a>res/ rawable/ background_login.xml, 整个布局的背景，渐变背景</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line"> &lt;gradient</span><br><span class="line"> android:angle=&quot;90&quot;</span><br><span class="line"> android:endColor=&quot;#FF72CAE1&quot;</span><br><span class="line"> android:startColor=&quot;#FFACDAE5&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-单色填充带圆角-按钮、局部的布局"><a href="#2-单色填充带圆角-按钮、局部的布局" class="headerlink" title="2.单色填充带圆角(按钮、局部的布局)"></a>2.单色填充带<font color="cornflowerblue">圆角</font>(按钮、局部的布局)</h3><h4 id="res-rawable-background-login-div-xml-登录框部分的背景，单色填充，带圆角"><a href="#res-rawable-background-login-div-xml-登录框部分的背景，单色填充，带圆角" class="headerlink" title="res/ rawable/background_login_div.xml, 登录框部分的背景，单色填充，带圆角"></a><strong>res/ rawable/background_login_div.xml,</strong> 登录框部分的背景，单色填充，带圆角</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line"> &lt;solid android:color=&quot;#55FFFFFF&quot; /&gt;</span><br><span class="line"> &lt;corners</span><br><span class="line"> android:bottomLeftRadius=&quot;10dp&quot;</span><br><span class="line"> android:bottomRightRadius=&quot;10dp&quot;</span><br><span class="line"> android:topLeftRadius=&quot;10dp&quot;</span><br><span class="line"> android:topRightRadius=&quot;10dp&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>



<h3 id="3-文本框不同状态的背景设置"><a href="#3-文本框不同状态的背景设置" class="headerlink" title="3.文本框不同状态的背景设置"></a>3.文本框<font color="cornflowerblue">不同状态的背景</font>设置</h3><h4 id="res-drawable-edit-login-xml-两个编辑输入框的背景，edit-login-是一个-selector，针对正在输入和其它状态设-置不同的背景图片，login-input-和-input-over-是-res-drawable-目录下的两张-png-图片-Educoder-平台已经共享-，名-字分别是-input-over-9-png-和-input-input-9-png"><a href="#res-drawable-edit-login-xml-两个编辑输入框的背景，edit-login-是一个-selector，针对正在输入和其它状态设-置不同的背景图片，login-input-和-input-over-是-res-drawable-目录下的两张-png-图片-Educoder-平台已经共享-，名-字分别是-input-over-9-png-和-input-input-9-png" class="headerlink" title="res/drawable/edit_login.xml**, 两个编辑输入框的背景，edit_login 是一个 selector，针对正在输入和其它状态设 置不同的背景图片，login_input 和 input_over 是 res/drawable 目录下的两张 png 图片(Educoder 平台已经共享)，名 字分别是 input_over.9.png 和 input_input.9.png"></a>res/drawable/edit_login.xml**, 两个编辑输入框的背景，edit_login 是一个 selector，针对正在输入和其它状态设 置不同的背景图片，login_input 和 input_over 是 res/drawable 目录下的两张 png 图片(Educoder 平台已经共享)，名 字分别是 input_over.9.png 和 input_input.9.png</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;item </span><br><span class="line">	 android:state_enabled=&quot;false&quot;</span><br><span class="line"> 	android:drawable=&quot;@drawable/login_input&quot;/&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:state_focused=&quot;true&quot;</span><br><span class="line"> 	android:drawable=&quot;@drawable/input_over&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>



<h3 id="4-按钮不同状态的文字颜色"><a href="#4-按钮不同状态的文字颜色" class="headerlink" title="4.按钮不同状态的文字颜色"></a>4.按钮<font color="cornflowerblue">不同状态的文字颜色</font></h3><h4 id="res-drawable-text-btn-selector-xml-两个按钮的-textColor-属性，这是按钮的文本颜色，这是一个-selector，使得按钮在不同状态下的文字颜色显示不同。"><a href="#res-drawable-text-btn-selector-xml-两个按钮的-textColor-属性，这是按钮的文本颜色，这是一个-selector，使得按钮在不同状态下的文字颜色显示不同。" class="headerlink" title="res/drawable/text_btn_selector.xml, 两个按钮的 textColor 属性，这是按钮的文本颜色，这是一个 selector，使得按钮在不同状态下的文字颜色显示不同。"></a><strong>res/drawable/text_btn_selector.xml</strong>, 两个按钮的 textColor 属性，这是按钮的文本颜色，这是一个 selector，使得按钮在不同状态下的文字颜色显示不同。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"> 		&lt;!-- 当前窗口失去焦点时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/black&quot; </span><br><span class="line"> 	android:state_window_focused=&quot;false&quot; /&gt;</span><br><span class="line">		 &lt;!-- 不可用时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/background_light&quot; 				  			android:state_enabled=&quot;false&quot; /&gt;</span><br><span class="line"> 		 &lt;!-- 按压时 --&gt;</span><br><span class="line"> &lt;item android:color=&quot;@android:color/holo_blue_light&quot;  		           		    	   android:state_pressed=&quot;true&quot; /&gt;</span><br><span class="line"> 		&lt;!-- 被选中时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/holo_green_dark&quot;</span><br><span class="line"> 	android:state_selected=&quot;true&quot; /&gt;</span><br><span class="line"> 		&lt;!-- 被激活时 --&gt;</span><br><span class="line"> &lt;item </span><br><span class="line"> 	android:color=&quot;@android:color/holo_green_light&quot; 	</span><br><span class="line"> 	android:state_activated=&quot;true&quot; /&gt;</span><br><span class="line">		&lt;!-- 默认时 --&gt;</span><br><span class="line"> &lt;item android:color=&quot;@android:color/white&quot; /&gt;</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>



<h2 id="二、Shape"><a href="#二、Shape" class="headerlink" title="二、Shape"></a>二、Shape</h2><h3 id="1-Shape可以画四种图形"><a href="#1-Shape可以画四种图形" class="headerlink" title="1.Shape可以画四种图形"></a>1.Shape可以画四种图形</h3><h4 id="矩形（rectangle）、椭圆（oval）、线（line）、圆环（ring）。"><a href="#矩形（rectangle）、椭圆（oval）、线（line）、圆环（ring）。" class="headerlink" title="矩形（rectangle）、椭圆（oval）、线（line）、圆环（ring）。"></a>矩形（<font color="red">rectangle</font>）、椭圆（<font color="red">oval</font>）、线（<font color="red">line</font>）、圆环（<font color="red">ring</font>）。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shape xmIns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">	android:shape=&quot;rectangle&quot;&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-五种效果（利用-xml-文件描述，作为一种资源，放于drawable目-录。）"><a href="#2-五种效果（利用-xml-文件描述，作为一种资源，放于drawable目-录。）" class="headerlink" title="2.五种效果（利用 xml 文件描述，作为一种资源，放于drawable目                        录。）"></a>2.五种效果（利用 xml 文件描述，作为一种<font color="orange">资源</font>，放于drawable目                        录。）</h3><h4 id="（1）solid：填充"><a href="#（1）solid：填充" class="headerlink" title="（1）solid：填充"></a>（1）<font color="red">solid</font>：填充</h4><pre><code>                        android:color指定填充的颜色；
</code></pre>
<h4 id="（2）-gradient：渐变"><a href="#（2）-gradient：渐变" class="headerlink" title="（2） gradient：渐变"></a>（2） <font color="red">gradient</font>：渐变</h4><ul>
<li><h4 id="android-startColor和android-endColor-分别为起始和结束颜色"><a href="#android-startColor和android-endColor-分别为起始和结束颜色" class="headerlink" title="android:startColor和android:endColor 分别为起始和结束颜色"></a>android:startColor和android:endColor 分别为起始和结束颜色</h4></li>
<li><h4 id="android-angle-是渐变角度，必须为45的整数倍。"><a href="#android-angle-是渐变角度，必须为45的整数倍。" class="headerlink" title="android:angle 是渐变角度，必须为45的整数倍。"></a>android:angle 是渐变角度，必须为45的整数倍。</h4></li>
<li><h4 id="android-type-”linear”，线性渐变-默认"><a href="#android-type-”linear”，线性渐变-默认" class="headerlink" title="android:type=”linear”，线性渐变(默认)"></a>android:type=”linear”，线性渐变(默认)</h4></li>
<li><h4 id="android-type-”radial”，径向渐变"><a href="#android-type-”radial”，径向渐变" class="headerlink" title="android:type=”radial”，径向渐变"></a>android:type=”radial”，径向渐变</h4></li>
<li><h4 id="android-gradientRadius-”50”，径向渐变需要指定半径"><a href="#android-gradientRadius-”50”，径向渐变需要指定半径" class="headerlink" title="android:gradientRadius=”50”，径向渐变需要指定半径"></a>android:gradientRadius=”50”，径向渐变需要指定半径</h4></li>
</ul>
<h4 id="（3）-stroke：描边"><a href="#（3）-stroke：描边" class="headerlink" title="（3） stroke：描边"></a>（3）<font color="red"> stroke</font>：描边</h4><ul>
<li><h4 id="android-width-”2dp”-描边的宽度"><a href="#android-width-”2dp”-描边的宽度" class="headerlink" title="android:width=”2dp”  描边的宽度"></a>android:width=”2dp”  描边的宽度</h4></li>
<li><h4 id="android-color-描边的颜色"><a href="#android-color-描边的颜色" class="headerlink" title="android:color  描边的颜色"></a>android:color  描边的颜色</h4></li>
<li><h4 id="还可以把描边为虚线的形式，设置方式为："><a href="#还可以把描边为虚线的形式，设置方式为：" class="headerlink" title="还可以把描边为虚线的形式，设置方式为："></a>还可以把描边为<font color="orange">虚线</font>的形式，设置方式为：</h4><p>android:dashWidth=”5dp”<br>android:dashGap=”3dp”</p>
</li>
</ul>
<h4 id="（4）corners：圆角"><a href="#（4）corners：圆角" class="headerlink" title="（4）corners：圆角"></a>（4）<font color="red">corners</font>：圆角</h4><ul>
<li><h4 id="android-Radius-”20dp”-设置四个角的半径"><a href="#android-Radius-”20dp”-设置四个角的半径" class="headerlink" title="android:Radius=”20dp”               设置四个角的半径"></a>android:Radius=”20dp”               设置四个角的半径</h4></li>
<li><h4 id="android-topLeftRadius-”20dp”-设置左上角的半径"><a href="#android-topLeftRadius-”20dp”-设置左上角的半径" class="headerlink" title="android:topLeftRadius=”20dp”         设置左上角的半径"></a>android:topLeftRadius=”20dp”         设置左上角的半径</h4></li>
<li><h4 id="android-topRightRadius-”20dp”-设置右上角的半径"><a href="#android-topRightRadius-”20dp”-设置右上角的半径" class="headerlink" title="android:topRightRadius=”20dp”        设置右上角的半径"></a>android:topRightRadius=”20dp”        设置右上角的半径</h4></li>
<li><h4 id="android-bottomLeftRadius-”20dp”-设置右下角的半径"><a href="#android-bottomLeftRadius-”20dp”-设置右下角的半径" class="headerlink" title="android:bottomLeftRadius=”20dp”      设置右下角的半径"></a>android:bottomLeftRadius=”20dp”      设置右下角的半径</h4></li>
<li><h4 id="android-bottomRightRadius-”20dp”-设置左下角的半径"><a href="#android-bottomRightRadius-”20dp”-设置左下角的半径" class="headerlink" title="android:bottomRightRadius=”20dp”     设置左下角的半径"></a>android:bottomRightRadius=”20dp”     设置左下角的半径</h4></li>
</ul>
<h4 id="（5）padding：间隔"><a href="#（5）padding：间隔" class="headerlink" title="（5）padding：间隔"></a>（5）<font color="red">padding</font>：间隔</h4><h5 id="可以设置上下左右四个方向的间隔。"><a href="#可以设置上下左右四个方向的间隔。" class="headerlink" title="可以设置上下左右四个方向的间隔。"></a>可以设置上下左右四个方向的间隔。</h5><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200922232849670.png" alt="image-20200922232849670"></p>
<h2 id="三、Selector"><a href="#三、Selector" class="headerlink" title="三、Selector"></a>三、Selector</h2><h3 id="1-以Button为例，关键状态属性如下："><a href="#1-以Button为例，关键状态属性如下：" class="headerlink" title="1.以Button为例，关键状态属性如下："></a>1.以Button为例，关键状态属性如下：</h3><table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>android:<strong>state_selected</strong></td>
<td>设置是否选中状态，true表示已选中，false表示未选中</td>
</tr>
<tr>
<td>android:<strong>state_focused</strong></td>
<td>设置是否获得焦点状态，true表示获得焦点，默认为false，表示未获得焦点</td>
</tr>
<tr>
<td>android:<strong>state_pressed</strong></td>
<td>设置是否按压状态，一般在true时设置该属性，表示已按压状态，默认为false</td>
</tr>
<tr>
<td>android:<strong>state_enabled</strong></td>
<td>设置是否响应事件,指所有事件；一般只在false时设置该属性，表示不可用状态</td>
</tr>
<tr>
<td>android:<strong>state_activated</strong>:</td>
<td>设置是否被激活状态，true表示被激活，false表示未激活，API Level 11及以上才支持，可通过代码调用控件的setActivated(boolean)方法设置是否激活该控件</td>
</tr>
</tbody></table>
<h3 id="2-示例：text-btn-selector-xml的代码，用于按钮的文本颜色t"><a href="#2-示例：text-btn-selector-xml的代码，用于按钮的文本颜色t" class="headerlink" title="2.示例：text_btn_selector.xml的代码，用于按钮的文本颜色t"></a>2.示例：text_btn_selector.xml的代码，用于按钮的文本颜色t</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- 不可用时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/background_light&quot;</span><br><span class="line">    	android:state_enabled=&quot;false&quot; /&gt;</span><br><span class="line">    &lt;!-- 按压时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/holo_blue_light&quot; </span><br><span class="line">    	android:state_pressed=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;!-- 被选中时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/holo_green_dark&quot;</span><br><span class="line">    	android:state_selected=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;!-- 被激活时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/holo_green_light&quot;</span><br><span class="line">    	android:state_activated=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;!-- 默认时 --&gt;</span><br><span class="line">    &lt;item android:color=&quot;@android:color/white&quot; /&gt;</span><br><span class="line">&lt;/selector&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="在控件中引用-android-background-”-drawable-bg-btn-selector”"><a href="#在控件中引用-android-background-”-drawable-bg-btn-selector”" class="headerlink" title="在控件中引用 android:background=”@drawable/bg_btn_selector”"></a>在控件中引用 <font color="red">android:background=”@drawable/bg_btn_selector”</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Button </span><br><span class="line">    android:id=&quot;@+id/btn_default&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_margin=&quot;8dp&quot;</span><br><span class="line">    android:background=&lt;Button </span><br><span class="line">    android:id=&quot;@+id/btn_default&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_margin=&quot;8dp&quot;</span><br><span class="line">    android:background=&quot;@drawable/bg_btn_selector&quot;</span><br><span class="line">    android:text=&quot;默认按钮&quot;</span><br><span class="line">    android:textColor=&quot;@color/text_btn_selector&quot; /&gt;</span><br><span class="line">&quot;</span><br><span class="line">    android:text=&quot;默认按钮&quot;</span><br><span class="line">    android:textColor=&quot;@color/text_btn_selector&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923134625276.png" alt="image-20200923134625276" style="zoom: 80%;">



<h2 id="四、登录布局和背景优化"><a href="#四、登录布局和背景优化" class="headerlink" title="四、登录布局和背景优化"></a>四、登录布局和背景优化</h2><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135110680.png" alt="image-20200923135110680"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135119943.png" alt="image-20200923135119943"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135127485.png" alt="image-20200923135127485"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135145022.png" alt="image-20200923135145022"></p>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923135612629.png" alt="image-20200923135612629" style="zoom:50%;">





<h2 id="五、View概念"><a href="#五、View概念" class="headerlink" title="五、View概念"></a>五、View概念</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul>
<li><h4 id="多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。"><a href="#多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。" class="headerlink" title="多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。"></a>多个视图组件（View）可以存放在一个视图容器（ViewGroup）中，该容器可以与其他视图组件共同存放在另一个视图容器当中，但是一个界面文件必须有且仅有一个容器作为根节点。</h4></li>
<li><h4 id="Android应用的界面都是由View和ViewGroup对象构建的，"><a href="#Android应用的界面都是由View和ViewGroup对象构建的，" class="headerlink" title="Android应用的界面都是由View和ViewGroup对象构建的，"></a>Android应用的界面都是由View和ViewGroup对象构建的，</h4></li>
<li><h4 id="ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。"><a href="#ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。" class="headerlink" title="ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。"></a>ViewGroup继承了View类，也可以当成普通的View来使用，但主要还是当成容器来使用。</h4></li>
</ul>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923140230137.png" alt="image-20200923140230137" style="zoom: 67%;">



<h3 id="2-View类的常用属性与方法"><a href="#2-View类的常用属性与方法" class="headerlink" title="2.View类的常用属性与方法"></a>2.View类的常用属性与方法</h3><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923140315637.png" alt="image-20200923140315637"></p>
<h3 id="3-用户界面组件包widget"><a href="#3-用户界面组件包widget" class="headerlink" title="3.用户界面组件包widget"></a>3.用户界面组件包widget</h3><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20200923140439546.png" alt="image-20200923140439546" style="zoom:80%;">





<h1 id="第二章-Android-列表"><a href="#第二章-Android-列表" class="headerlink" title="第二章 Android 列表"></a>第二章 Android 列表</h1><h2 id="一、AdapterView及其子类"><a href="#一、AdapterView及其子类" class="headerlink" title="一、AdapterView及其子类"></a>一、AdapterView及其子类</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002124214084.png" alt="image-20201002124214084" style="zoom: 50%;"></h3><h3 id="2-AdapterView子类"><a href="#2-AdapterView子类" class="headerlink" title="2.AdapterView子类"></a>2.AdapterView子类</h3><ul>
<li><h4 id="ListView：列表，通常含有一个TextView控件。"><a href="#ListView：列表，通常含有一个TextView控件。" class="headerlink" title="ListView：列表，通常含有一个TextView控件。"></a>ListView：列表，通常含有一个TextView控件。</h4></li>
<li><h4 id="Spinner：下拉列表，给用户提供选择。"><a href="#Spinner：下拉列表，给用户提供选择。" class="headerlink" title="Spinner：下拉列表，给用户提供选择。"></a>Spinner：下拉列表，给用户提供选择。</h4></li>
<li><h4 id="Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。"><a href="#Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。" class="headerlink" title="Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。"></a>Gallery：缩略图，是一个可以把子项以中心锁定，水平滚动的列表。</h4></li>
<li><h4 id="GridView：网格图，以表格形式显示资源，可以左右滑动的。"><a href="#GridView：网格图，以表格形式显示资源，可以左右滑动的。" class="headerlink" title="GridView：网格图，以表格形式显示资源，可以左右滑动的。"></a>GridView：网格图，以表格形式显示资源，可以左右滑动的。</h4></li>
</ul>
<h2 id="二、ListView"><a href="#二、ListView" class="headerlink" title="二、ListView"></a>二、ListView</h2><h3 id="1-XML属性"><a href="#1-XML属性" class="headerlink" title="1.XML属性"></a>1.XML属性</h3><table>
<thead>
<tr>
<th><strong>XML****属性</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>android:divider</strong></td>
<td>设置分割条样式（颜色或者Drawable对象）</td>
</tr>
<tr>
<td><strong>android:dividerHeight</strong></td>
<td>设置分割条高度</td>
</tr>
<tr>
<td><font color="red">android:entries（数据源）</font></td>
<td>指定一个数组资源，用来填充ListView项</td>
</tr>
<tr>
<td><strong>android:footerDividersEnabled</strong></td>
<td>设置为false，则不在footer view之前绘制分割条</td>
</tr>
<tr>
<td><strong>android:headerDividersEnabled</strong></td>
<td>设置为false，则不在header view之后绘制分割条</td>
</tr>
<tr>
<td><strong>android:scrollbars</strong></td>
<td>设置是否显示滚动条</td>
</tr>
<tr>
<td><strong>android:fadingEdge</strong></td>
<td>设置是否去除ListView滑到顶部和底部时边缘的黑色阴影</td>
</tr>
<tr>
<td><strong>android:listSelector</strong></td>
<td>设置是否去除点击颜色</td>
</tr>
<tr>
<td><strong>android:cacheColorHint</strong></td>
<td>设置ListView去除滑动颜色</td>
</tr>
</tbody></table>
<h3 id="2-最简单的用法"><a href="#2-最简单的用法" class="headerlink" title="2.最简单的用法"></a>2.最简单的用法</h3><h4 id="布局文件中添加LsitView组件，然后在values-strings-xml文件中填加string-array的数组元素。然后通过android-entries调用加载数组资源，填充ListView项。"><a href="#布局文件中添加LsitView组件，然后在values-strings-xml文件中填加string-array的数组元素。然后通过android-entries调用加载数组资源，填充ListView项。" class="headerlink" title="布局文件中添加LsitView组件，然后在values/ strings.xml文件中填加string-array的数组元素。然后通过android:entries调用加载数组资源，填充ListView项。"></a>布局文件中添加LsitView组件，然后在values/ strings.xml文件中填加<font color="red">string-array</font>的数组元素。然后通过<font color="red">android:entries</font>调用加载数组资源，填充ListView项。</h4><h3 id="3-M-V-C原理"><a href="#3-M-V-C原理" class="headerlink" title="3.M-V-C原理"></a>3.M-V-C原理</h3><h4 id="（1）数据模型M-Model）存放数据-来自数组、列表、数据库-，利用控制器C（Controller）将数据显示在视图V（View）上。"><a href="#（1）数据模型M-Model）存放数据-来自数组、列表、数据库-，利用控制器C（Controller）将数据显示在视图V（View）上。" class="headerlink" title="（1）数据模型M(Model）存放数据(来自数组、列表、数据库)，利用控制器C（Controller）将数据显示在视图V（View）上。"></a>（1）数据模型M(Model）存放数据(来自数组、列表、数据库)，利用控制器C（Controller）将数据显示在视图V（View）上。</h4><h4 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点:"></a>（2）特点:</h4><ul>
<li><h4 id="将前端显示和后端数据分离"><a href="#将前端显示和后端数据分离" class="headerlink" title="将前端显示和后端数据分离"></a>将前端显示和后端数据分离</h4></li>
<li><h4 id="内容不能通过-ListView-add的形式添加列表项，需指定一个Adapter对象，-通过它获得显示数据"><a href="#内容不能通过-ListView-add的形式添加列表项，需指定一个Adapter对象，-通过它获得显示数据" class="headerlink" title="内容不能通过 ListView.add的形式添加列表项，需指定一个Adapter对象，    通过它获得显示数据"></a>内容不能通过 ListView.add的形式添加列表项，需指定一个Adapter对象，    通过它获得显示数据</h4></li>
<li><h4 id="数据源相当于-MVC-框架中的M（模型）"><a href="#数据源相当于-MVC-框架中的M（模型）" class="headerlink" title="数据源相当于 MVC 框架中的M（模型）"></a>数据源相当于 MVC 框架中的<font color="red">M</font>（模型）</h4></li>
<li><h4 id="ListView-相当于-MVC-框架中的V（视图）"><a href="#ListView-相当于-MVC-框架中的V（视图）" class="headerlink" title="ListView 相当于 MVC 框架中的V（视图）"></a>ListView 相当于 MVC 框架中的<font color="red">V</font>（视图）</h4></li>
<li><h4 id="Adapter-相当于-MVC-框架中的C（控制器）"><a href="#Adapter-相当于-MVC-框架中的C（控制器）" class="headerlink" title="Adapter 相当于 MVC 框架中的C（控制器）"></a>Adapter 相当于 MVC 框架中的<font color="red">C</font>（控制器）</h4></li>
</ul>
<h2 id="三、Adapter接口"><a href="#三、Adapter接口" class="headerlink" title="三、Adapter接口"></a>三、Adapter接口</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002125728655.png" alt="image-20201002125728655" style="zoom:50%;"></h3><h3 id="2-Adapter常用的实现类如下："><a href="#2-Adapter常用的实现类如下：" class="headerlink" title="2.Adapter常用的实现类如下："></a>2.Adapter常用的实现类如下：</h3><h4 id="1-ArrayAdapter：支持泛型操作，最为简单，一般用于将字符串数组或者任意对象-toString-数组绑定为列表项的数据源。"><a href="#1-ArrayAdapter：支持泛型操作，最为简单，一般用于将字符串数组或者任意对象-toString-数组绑定为列表项的数据源。" class="headerlink" title="(1)ArrayAdapter：支持泛型操作，最为简单，一般用于将字符串数组或者任意对象(toString)数组绑定为列表项的数据源。"></a>(1)ArrayAdapter：支持<font color="red">泛型</font>操作，最为简单，一般用于将<font color="red">字符串数组</font>或者任意对象(toString)数组绑定为列表项的数据源。</h4><h4 id="2-SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的列表项视图组件上，可以自定义出各种效果。"><a href="#2-SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的列表项视图组件上，可以自定义出各种效果。" class="headerlink" title="(2)SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的列表项视图组件上，可以自定义出各种效果。"></a>(2)SimpleAdapter：易于使用，可以将一组静态数据映射到使用XML定义的<font color="red">列表项</font>视图组件上，可以自定义出各种效果。</h4><h4 id="3-SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。"><a href="#3-SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。" class="headerlink" title="(3)SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。"></a>(3)SimpleCursorAdapter：与SimpleAdapter类似，用于绑定游标（直接从数据库取出数据）作为列表项的数据源。</h4><h4 id="4-BaseAdapter：是一个抽象类，继承它需要实现一些方法，具有较高的灵活性"><a href="#4-BaseAdapter：是一个抽象类，继承它需要实现一些方法，具有较高的灵活性" class="headerlink" title="(4)BaseAdapter：是一个抽象类，继承它需要实现一些方法，具有较高的灵活性"></a>(4)BaseAdapter：是一个<font color="red">抽象类</font>，继承它需要实现一些方法，具有较高的<font color="red">灵活性</font></h4><h2 id="四、ArrayAdapter"><a href="#四、ArrayAdapter" class="headerlink" title="四、ArrayAdapter"></a>四、ArrayAdapter</h2><h3 id="1-实现步骤："><a href="#1-实现步骤：" class="headerlink" title="1.实现步骤："></a>1.实现步骤：</h3><h4 id="（1）创建新项目：项目名称ArrayAdapterDemo。"><a href="#（1）创建新项目：项目名称ArrayAdapterDemo。" class="headerlink" title="（1）创建新项目：项目名称ArrayAdapterDemo。"></a>（1）创建新项目：项目名称ArrayAdapterDemo。</h4><h4 id="（2）在string-xml创建一个string-array，存储栏目信息。-M"><a href="#（2）在string-xml创建一个string-array，存储栏目信息。-M" class="headerlink" title="（2）在string.xml创建一个string-array，存储栏目信息。(M)"></a>（2）在string.xml创建一个<font color="red">string-array</font>，存储栏目信息。(M)</h4><h4 id="（3）在布局中添加ListView控件。-V"><a href="#（3）在布局中添加ListView控件。-V" class="headerlink" title="（3）在布局中添加ListView控件。(V)"></a>（3）在布局中添加ListView控件。(V)</h4><h4 id="（4）在MainActivity-Java设置布局中ListView的Adapter-C"><a href="#（4）在MainActivity-Java设置布局中ListView的Adapter-C" class="headerlink" title="（4）在MainActivity.Java设置布局中ListView的Adapter:(C)"></a>（4）在MainActivity.Java设置布局中ListView的Adapter:(C)</h4><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><h5 id="视图-M"><a href="#视图-M" class="headerlink" title="//视图  M"></a>//视图  M</h5><h4 id="ListView-listView-ListView-findViewById-R-id-news-category"><a href="#ListView-listView-ListView-findViewById-R-id-news-category" class="headerlink" title="ListView listView = (ListView) findViewById(R.id.news_category);"></a>ListView listView = (ListView) findViewById(R.id.news_category);</h4><h5 id="数据：strings-xml-V"><a href="#数据：strings-xml-V" class="headerlink" title="//数据：strings.xml  V"></a>//数据：strings.xml  V</h5><h4 id="String-mData-getResources-getStringArray-R-array-news-category"><a href="#String-mData-getResources-getStringArray-R-array-news-category" class="headerlink" title="String [ ] mData = getResources().getStringArray(R.array.news_category);"></a>String [ ] mData = <font color="orange">getResources().getStringArray(R.array.news_category);</font></h4><h5 id="桥接：Adapter-C"><a href="#桥接：Adapter-C" class="headerlink" title="//桥接：Adapter  C"></a>//桥接：Adapter  C</h5><h4 id="ArrayAdapter-adapter-new-ArrayAdapter-lt-gt-this-android-R-layout-simple-list-item-1-mData"><a href="#ArrayAdapter-adapter-new-ArrayAdapter-lt-gt-this-android-R-layout-simple-list-item-1-mData" class="headerlink" title="ArrayAdapter adapter = new ArrayAdapter&lt;&gt;(this, android.R.layout.simple_list_item_1, mData);"></a>ArrayAdapter<String> adapter = new ArrayAdapter&lt;&gt;(this, android.R.layout.simple_list_item_1, mData);</String></h4><h4 id="listView-setAdapter-adapter"><a href="#listView-setAdapter-adapter" class="headerlink" title="listView.setAdapter(adapter);"></a>listView.setAdapter(adapter);</h4><p>​    </p>
<h3 id="3-监听器"><a href="#3-监听器" class="headerlink" title="3.监听器"></a>3.监听器</h3><p>、<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002130844609.png" alt="image-20201002130844609"></p>
<h2 id="五、SimpleAdapter"><a href="#五、SimpleAdapter" class="headerlink" title="五、SimpleAdapter"></a>五、SimpleAdapter</h2><h3 id="1-实现步骤：-1"><a href="#1-实现步骤：-1" class="headerlink" title="1.实现步骤："></a>1.实现步骤：</h3><h4 id="（1）创建新项目：项目名称SimpleAdapterDemo。"><a href="#（1）创建新项目：项目名称SimpleAdapterDemo。" class="headerlink" title="（1）创建新项目：项目名称SimpleAdapterDemo。"></a>（1）创建新项目：项目名称SimpleAdapterDemo。</h4><h4 id="（2）ListView的子项布局："><a href="#（2）ListView的子项布局：" class="headerlink" title="（2）ListView的子项布局："></a>（2）ListView的<font color="red">子项布局</font>：</h4><h4 id="用来显示列表的每一行内容的xml文件。自定义一个布局-listview-item-xml。"><a href="#用来显示列表的每一行内容的xml文件。自定义一个布局-listview-item-xml。" class="headerlink" title="用来显示列表的每一行内容的xml文件。自定义一个布局:listview_item.xml。"></a>用来显示列表的每一行内容的xml文件。<font color="orange">自定义一个布局:listview_item.xml。</font></h4><h4 id="（3）数据准备"><a href="#（3）数据准备" class="headerlink" title="（3）数据准备"></a>（3）数据准备</h4><h4 id="一般使用HashMap构成的List，List的每一个元素（map）用于填充ListView-的一个item。HashMap的每个键值数据映射到布局文件中对应id的组件上。"><a href="#一般使用HashMap构成的List，List的每一个元素（map）用于填充ListView-的一个item。HashMap的每个键值数据映射到布局文件中对应id的组件上。" class="headerlink" title="一般使用HashMap构成的List，List的每一个元素（map）用于填充ListView    的一个item。HashMap的每个键值数据映射到布局文件中对应id的组件上。"></a>一般使用<font color="orange">HashMap构成的List</font>，List的每一个元素（map）用于填充ListView    的一个item。HashMap的每个键值数据<font color="orange">映射</font>到布局文件中对应id的组件上。</h4><h4 id="（4）数据适配：创建SimpleAdapter并设置"><a href="#（4）数据适配：创建SimpleAdapter并设置" class="headerlink" title="（4）数据适配：创建SimpleAdapter并设置"></a>（4）数据适配：创建SimpleAdapter并设置</h4><h4 id="参数依次是：this，getData-，子项布局文件的ID，HashMap的键值数组，布局文件的组件id。"><a href="#参数依次是：this，getData-，子项布局文件的ID，HashMap的键值数组，布局文件的组件id。" class="headerlink" title="参数依次是：this，getData()，子项布局文件的ID，HashMap的键值数组，布局文件的组件id。"></a>参数依次是：<font color="orange">this，getData()，子项布局文件的ID，HashMap的键值数组，布局文件的组件id</font>。</h4><h4 id="第4个参数的键值序列与第5个参数的组件id序列一一对应。"><a href="#第4个参数的键值序列与第5个参数的组件id序列一一对应。" class="headerlink" title="第4个参数的键值序列与第5个参数的组件id序列一一对应。"></a>第4个参数的键值序列与第5个参数的组件id序列一一对应。</h4><h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><h4 id="子项布局"><a href="#子项布局" class="headerlink" title="子项布局"></a>子项布局</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002131857410.png" alt="image-20201002131857410"></p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132023296.png" alt="image-20201002132023296"></p>
<h4 id="数据适配"><a href="#数据适配" class="headerlink" title="数据适配"></a>数据适配</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132215242.png" alt="image-20201002132215242"></p>
<h3 id="3-子项点击事件"><a href="#3-子项点击事件" class="headerlink" title="3.子项点击事件"></a>3.子项点击事件</h3><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132331890.png" alt="image-20201002132331890">

<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002132425472.png" alt="image-20201002132425472">



<h2 id="六、BaseAdapter"><a href="#六、BaseAdapter" class="headerlink" title="六、BaseAdapter"></a>六、BaseAdapter</h2><h3 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h3><h4 id="（1）创建新项目：项目名称BaseAdapterDemo。"><a href="#（1）创建新项目：项目名称BaseAdapterDemo。" class="headerlink" title="（1）创建新项目：项目名称BaseAdapterDemo。"></a>（1）创建新项目：项目名称BaseAdapterDemo。</h4><h4 id="（2）ListView的子项布局：-listview-item-bt-xml"><a href="#（2）ListView的子项布局：-listview-item-bt-xml" class="headerlink" title="（2）ListView的子项布局： listview_item_bt.xml"></a>（2）ListView的子项布局： listview_item_bt.xml</h4><p>​        一个ImageView，两个TextView和一个ImageButton。</p>
<h4 id="（3）设置自定义适配器MyAdapter"><a href="#（3）设置自定义适配器MyAdapter" class="headerlink" title="（3）设置自定义适配器MyAdapter"></a>（3）设置自定义适配器<font color="red">MyAdapter</font></h4><p>​        <font color="cornflowerblue">MyAdapter继承BaseAdapter</font>，需要重写<font color="orange">getCount(), getView()</font>等方法。<br>​                ListView在绘制的时候，系统首先调用getCount()函数，根据返回值得到ListView的长度，然后根据            这个长度调用getView()逐一绘制每一行。<br>​        在getView中使用了<font color="cornflowerblue">ViewHolder类</font>和对象。<br>​                使用ViewHolder可以进行性能优化，对控件实例进行缓存。ViewHolder是一个内部类，其中包含了单个项目布局中的各个控件。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002133333488.png" alt="image-20201002133333488"></h3><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002133841796.png" alt="image-20201002133841796"></p>
<h4 id="mInflater-LayoutInflater-from-getContext"><a href="#mInflater-LayoutInflater-from-getContext" class="headerlink" title="mInflater = LayoutInflater.from( getContext() )"></a><font color="cornflowerblue">mInflater = LayoutInflater.from( getContext() )</font></h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134333722.png" alt="image-20201002134333722"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134657576.png" alt="image-20201002134657576"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134926677.png" alt="image-20201002134926677"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135612766.png" alt="image-20201002135612766"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002134944464.png" alt="image-20201002134944464"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135159245.png" alt="image-20201002135159245"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135718003.png" alt="image-20201002135718003"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201002135725265.png" alt="image-20201002135725265"></p>
<h2 id="七、RecyclerView-补充"><a href="#七、RecyclerView-补充" class="headerlink" title="七、RecyclerView(补充)"></a>七、RecyclerView(补充)</h2><h3 id="1-定义子项布局：采用CardView布局进行美化。"><a href="#1-定义子项布局：采用CardView布局进行美化。" class="headerlink" title="1.定义子项布局：采用CardView布局进行美化。"></a>1.定义子项布局：采用CardView布局进行美化。</h3><h4 id="（1）新建cardview-bt-xml（类似于前一例中的listview-item-bt-xml）"><a href="#（1）新建cardview-bt-xml（类似于前一例中的listview-item-bt-xml）" class="headerlink" title="（1）新建cardview_bt.xml（类似于前一例中的listview_item_bt.xml）"></a>（1）新建cardview_bt.xml（类似于前一例中的listview_item_bt.xml）</h4><p>定义cardCornerRadius=”5dp”, elevation = “1dp”<br>CardView 继承于Framelayout，不能直接放置各类控件，否则各类控件将会重叠在一起，因此一般在CardView布局中嵌套其它布局，在其中放置放置其它控件</p>
<h4 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201009121547035.png" alt="image-20201009121547035"></h4><h3 id="2-getAdapterPosition-获取当前点击项的position序号"><a href="#2-getAdapterPosition-获取当前点击项的position序号" class="headerlink" title="2.getAdapterPosition(); 获取当前点击项的position序号"></a>2.<font color="cornflowerblue">getAdapterPosition()</font>; 获取当前点击项的position序号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">holder.fruitItemView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        int position=holder.getAdapterPosition();   //获取当前点击项的position序号</span><br><span class="line">        Fruit fruit=mFruitList.get(position);       //获取当前点击项的Fruit实例</span><br><span class="line">        new AlertDialog.Builder(parent.getContext()).setTitle(&quot;营养价值：&quot;)</span><br><span class="line">                .setMessage(fruit.nutrition)</span><br><span class="line">                .setPositiveButton(&quot;ok&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-定位子项到第一项"><a href="#3-定位子项到第一项" class="headerlink" title="3.定位子项到第一项"></a>3.定位子项到第一项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int positions=fruitList.indexOf(fruit); //获取对象序号</span><br><span class="line">recyclerView.scrollToPosition(positions);</span><br><span class="line">LinearLayoutManager layoutManager1=(LinearLayoutManager)recyclerView.getLayoutManager();</span><br><span class="line">layoutManager1.scrollToPositionWithOffset(positions,0);     //对象定位到第一项</span><br></pre></td></tr></table></figure>



<h3 id="4-List按某个属性重新排序"><a href="#4-List按某个属性重新排序" class="headerlink" title="4.List按某个属性重新排序"></a>4.List按某个属性重新排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case R.id.like_order_up:</span><br><span class="line">    Collections.sort(fruitList, new Comparator&lt;Fruit&gt;() &#123;       //按喜爱度升序排序</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Fruit o1, Fruit o2) &#123;</span><br><span class="line">            return o1.likeNumber.compareTo(o2.likeNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    adapter.notifyDataSetChanged();     //刷新适配器</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case R.id.like_order_down:</span><br><span class="line">    Collections.sort(fruitList, new Comparator&lt;Fruit&gt;() &#123;       //按喜爱度降序排序</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Fruit o1, Fruit o2) &#123;</span><br><span class="line">            return o2.likeNumber.compareTo(o1.likeNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    adapter.notifyDataSetChanged();     //刷新适配器</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>





<h1 id="第三章-数据存储"><a href="#第三章-数据存储" class="headerlink" title="第三章 数据存储"></a>第三章 数据存储</h1><h2 id="一、数据持久化"><a href="#一、数据持久化" class="headerlink" title="一、数据持久化"></a>一、数据持久化</h2><h3 id="1-数据存储方式"><a href="#1-数据存储方式" class="headerlink" title="1.数据存储方式"></a>1.数据存储方式</h3><ul>
<li><font color="red">文件存储</font></li>
<li><font color="red">SharedPreferences</font></li>
<li><font color="red">SQLite数据库</font></li>
</ul>
<h3 id="2-Android内部存储和外部存储"><a href="#2-Android内部存储和外部存储" class="headerlink" title="2.Android内部存储和外部存储"></a>2.Android内部存储和外部存储</h3><h4 id="（1）内存（Memory）："><a href="#（1）内存（Memory）：" class="headerlink" title="（1）内存（Memory）："></a>（1）内存（Memory）：</h4><p>​            RAM，类似于PC的内存条</p>
<h4 id="（2）内部存储（Internal-Storage）："><a href="#（2）内部存储（Internal-Storage）：" class="headerlink" title="（2）内部存储（Internal Storage）："></a>（2）内部存储（Internal Storage）：</h4><p>​            机身固有存储，类似于PC的硬盘 </p>
<h4 id="（3）外部存储（External-Storage）："><a href="#（3）外部存储（External-Storage）：" class="headerlink" title="（3）外部存储（External Storage）："></a>（3）外部存储（External Storage）：</h4><p>​                早期的Android设备(4.4之前) 指SDCard(扩展卡)，类似于PC上的U盘。</p>
<p>​        之后随着技术的进步，机身存储得到了快速增大(8G以上)，此时的外部存储是<font color="orange">概念级别的“外部存储”</font>，机        身<font color="red">固有的存储</font>有一部分被划分为“内部存储”，另一部分被划分为“外部存储”，但其实都是机身固有存储。        后期的外部存储也包括了SDCard。<br>​        所以不管Android手机是否有可移动的SDCard，他们总是有外部存储和内部存储。</p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20210601224438335.png" alt="image-20210601224438335"></p>
<h3 id="3-几个重要文件夹"><a href="#3-几个重要文件夹" class="headerlink" title="3.几个重要文件夹"></a>3.几个重要文件夹</h3><h4 id="打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹"><a href="#打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹" class="headerlink" title="打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：data文件夹、mnt文件夹、sdcard 文件夹、storage文件夹"></a>打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：<font color="red">data</font>文件夹、<font color="red">mnt</font>文件夹、<font color="red">sdcard</font> 文件夹、<font color="red">storage</font>文件夹</h4><h3 id="4-内部存储data"><a href="#4-内部存储data" class="headerlink" title="4.内部存储data"></a>4.<font color="cornflowerblue">内部存储data</font></h3><h4 id="1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："><a href="#1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：" class="headerlink" title="(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："></a>(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：</h4><ul>
<li><h5 id="文件夹app：存放着我们所有安装的app的apk文件"><a href="#文件夹app：存放着我们所有安装的app的apk文件" class="headerlink" title="文件夹app：存放着我们所有安装的app的apk文件"></a>文件夹<font color="red">app</font>：存放着我们所有安装的app的apk文件</h5></li>
<li><h5 id="文件夹data：一些包名，展开后，"><a href="#文件夹data：一些包名，展开后，" class="headerlink" title="文件夹data：一些包名，展开后，"></a>文件夹<font color="red">data</font>：一些包名，展开后，</h5><p>data/data/包名/<font color="orange">shared_prefs</font>(SharedPreference存储方式)</p>
<pre><code>data/data/包名/&lt;font color=&#39;orange&#39;&gt;databases&lt;/font&gt;（数据库存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;files&lt;/font&gt;（文件存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;cache&lt;/font&gt;
</code></pre>
</li>
</ul>
<h4 id="（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data"><a href="#（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data" class="headerlink" title="（2）路径的访问：Environment.getDataDirectory()获取内部存储根路径。/data"></a>（2）路径的访问：<font color="red">Environment.getDataDirectory()</font>获取内部存储根路径。/data</h4><h4 id="3-几点："><a href="#3-几点：" class="headerlink" title="(3)几点："></a>(3)几点：</h4><ol>
<li><h4 id="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"><a href="#系统默认只在内部存储中创建cache目录，并且此时cache目录是空的" class="headerlink" title="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"></a>系统默认<font color="orange">只在内部存储中创建cache目录</font>，并且此时cache目录是空的</h4></li>
<li><h4 id="此外，还可以根据需要自动创建：shared-prefs，databases，files目录"><a href="#此外，还可以根据需要自动创建：shared-prefs，databases，files目录" class="headerlink" title="此外，还可以根据需要自动创建：shared_prefs，databases，files目录"></a>此外，还可以根据需要<font color="orange">自动创建</font>：shared_prefs，databases，files目录</h4><p>但files可以<font color="orange">手动创建</font>，而shared_prefs，databases不能</p>
</li>
<li><h4 id="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"><a href="#别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。" class="headerlink" title="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"></a>别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。</h4></li>
</ol>
<h4 id="（4）内部存储的API"><a href="#（4）内部存储的API" class="headerlink" title="（4）内部存储的API"></a>（4）内部存储的API</h4><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028153632199.png" alt="image-20201028153632199" style="zoom:80%;">





<h3 id="5-外部存储storage"><a href="#5-外部存储storage" class="headerlink" title="5.外部存储storage"></a>5.<font color="cornflowerblue">外部存储storage</font></h3><h4 id="1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"><a href="#1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。" class="headerlink" title="(1)一般是/storage/emulated/0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"></a>(1)一般是<font color="red">/storage/emulated/0</font>也有可能是其它文件夹，不同厂家不同版本有可能不一样。</h4><h4 id="storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy"><a href="#storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy" class="headerlink" title="/storage/sdcard0，/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy"></a><font color="red">/storage/sdcard0，</font>/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy</h4><ul>
<li><h5 id="公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等"><a href="#公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等" class="headerlink" title="公有目录：10大类，比如DCIM,Download等这些系统创建的文件夹。storage/emulated/0/Download等"></a><font color="red">公有目录</font>：10大类，比如DCIM,Download等这些系统创建的文件夹。<font color="orange">storage/emulated/0/Download</font>等</h5></li>
<li><h5 id="私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。"><a href="#私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。" class="headerlink" title="私有目录：Android文件夹，打开后有data文件夹。storage/emulated/0/Android/data/包名 文件夹：里面包含了许多包名组成的文件夹。"></a><font color="red">私有目录</font>：Android文件夹，打开后有<font color="red">data</font>文件夹。<font color="orange">storage/emulated/0/Android/data/包名 文件夹</font>：里面包含了许多包名组成的文件夹。</h5><h4 id="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"><a href="#（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。" class="headerlink" title="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"></a>（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的<font color="green">数据会一并删除</font>。</h4><p>如果直接在<font color="red">根目录</font>（<font color="orange">/storage/emulated/0</font>）下创建一个应用的文件夹，这样当该应用被卸载后，这些数据还保留在外部存储中，<font color="green">留下垃圾数据</font>。</p>
</li>
</ul>
<h4 id="（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。"><a href="#（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。" class="headerlink" title="（3）路径的访问：Environment.getExternalStorageDirectory()：获取机身存储的外部存储根路径。"></a>（3）路径的访问：<font color="red">Environment.getExternalStorageDirectory()</font>：获取机身存储的外部存储根路径。</h4><h4 id="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"><a href="#（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录" class="headerlink" title="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"></a>（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要<font color="red">手动创建私有目录</font></h4><h5 id="context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件"><a href="#context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件" class="headerlink" title="context.getExternalFilesDir(…)：在storage/emulated/0/Android/data/包名/files 中创建文件"></a>context.<font color="orange">getExternalFilesDir(…)</font>：在storage/emulated/0/Android/data/包名/files 中创建文件</h5><p>​    context.<font color="orange">getExternalCacheDir() </font>：在storage/emulated/0/Android/data/包名/cache 中创建文件</p>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028154738508.png" alt="image-20201028154738508" style="zoom:80%;">

<h3 id="6-内部存储与外部存储比较"><a href="#6-内部存储与外部存储比较" class="headerlink" title="6.内部存储与外部存储比较"></a>6.内部存储与外部存储比较</h3><p>​        外部存储目录空间较大，而内部存储空间有限<br>​        部分目录不会被自动创建，需要手动创建<br>​        两者<font color="red">都不需要权限</font><br>​        两者<font color="red">都会随着App的卸载而会自动被删除</font><br>​        对于内部存储，<font color="orange">只有</font>本App才可以访问<br>​        对于外部私有目录，本App可以直接访问，而其它App在自 Android 7.0 开始，系统对应用私有目录的访问权限进一步限制。其他 App 无法通过 file:// 这种形式的 Uri 直接读写该目录下的文件内容，而是通过 FileProvider 访问。<br>​        需要注意的是：由于用户可以直接查看并操作外部私有存储目录，那么也就意味着我们在操作这个目录下的文件的时候一定要做好异常和判空处理。</p>
<h3 id="7-数据存储与清除"><a href="#7-数据存储与清除" class="headerlink" title="7.数据存储与清除"></a>7.数据存储与清除</h3><h4 id="（1）数据存储："><a href="#（1）数据存储：" class="headerlink" title="（1）数据存储："></a>（1）数据存储：</h4><ul>
<li><p>默认情况下，存储在<font color="red">内部存储</font>：<br><font color="orange">data/app</font>：用户APP安装目录，存放apk；</p>
<p><font color="orange">data/data/包名/</font>：存放应用程序的数据</p>
</li>
<li><p>数据可以存放到指定的<font color="red">外部存储</font>：</p>
<p><font color="orange">/storage/sdcard</font>（共有目录）</p>
<p><font color="orange">/storage/sdcard0/Android/data/包名/</font>（私有目录）</p>
<h4 id="（2）清除数据："><a href="#（2）清除数据：" class="headerlink" title="（2）清除数据："></a>（2）清除数据：</h4></li>
</ul>
<h5 id="删除对应包中的cache，files，lib，shared-prefs，datbBases等等"><a href="#删除对应包中的cache，files，lib，shared-prefs，datbBases等等" class="headerlink" title="删除对应包中的cache，files，lib，shared_prefs，datbBases等等"></a>删除<font color="red">对应包中的</font><font color="cornflowerblue">cache</font>，files，lib，shared_prefs，datbBases等等</h5><p>​        （清除<font color="red">data/data/packagename中的</font>cache，files，lib， databases，shared_prefs等等）</p>
<p>​        （清除<font color="red">storage/emulated/0/Android/data/packagenam中的</font>文件）</p>
<h4 id="3-清除缓存："><a href="#3-清除缓存：" class="headerlink" title="(3) 清除缓存："></a>(3) 清除缓存：</h4><h5 id="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"><a href="#删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。" class="headerlink" title="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"></a>删除的是App运行过程中所产生的<font color="red">临时数据</font>，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在<font color="red">内存</font>中。</h5><h2 id="二、文件存储"><a href="#二、文件存储" class="headerlink" title="二、文件存储"></a>二、文件存储</h2><h3 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1.内部存储"></a>1.内部存储</h3><h4 id="（1）存："><a href="#（1）存：" class="headerlink" title="（1）存："></a>（1）存：</h4><ul>
<li>方法1：使用 context.getFilesDir() 获取内部存储data/data/包名/files目录，然后创建文件，最后利用文件(全路径)新建FileOutputStream对象进行文件写入。<br>FileOutputStream fileOutputStream = new FileOutputStream(filePathName);</li>
</ul>
<img src="《Android小菜》//image-20201028160019136.png" alt="image-20201028160019136" style="zoom:80%;">

<ul>
<li>方法2：直接使用Context.openFileOutput()方法(只需要文件名)获取FileOutputStream对象，进行文件写入。</li>
</ul>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028160258040.png" alt="image-20201028160258040" style="zoom:80%;">

<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028160348975.png" alt="image-20201028160348975" style="zoom:80%;">

<h4 id="（2）取："><a href="#（2）取：" class="headerlink" title="（2）取："></a>（2）取：</h4><ul>
<li>方法1：使用context.getFilesDir() 获取内部存储data/data/包名/files目录，然后利用文件(全路径)创建FileInputStream对象，进行内容读取。<br>FileInputStream fileInputStream = new FileInputStream(filePathName);</li>
</ul>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20210601224213396.png" alt="image-20210601224213396"></p>
<ul>
<li>方法2：直接使用Context. openFileInput()方法(只需要文件名)获取FileInputStream对象，进行文件内容读取。<br>FileInputStream fileInputStream = openFileInput(fileName);</li>
</ul>
<img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028160853113.png" alt="image-20201028160853113" style="zoom:80%;">

<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20210601224250308.png" alt="image-20210601224250308"></p>
<h3 id="2-外部存储"><a href="#2-外部存储" class="headerlink" title="2.外部存储"></a>2.外部存储</h3><h4 id="（1）外部根目录："><a href="#（1）外部根目录：" class="headerlink" title="（1）外部根目录："></a>（1）外部根目录：</h4><p>使用 <font color="red">Environment.getExternalStorageDirectory()</font> 获取</p>
<p>一般是/storage/emulated/0</p>
<h4 id="（2）外部公有目录："><a href="#（2）外部公有目录：" class="headerlink" title="（2）外部公有目录："></a>（2）外部公有目录：</h4><p>使用<font color="red">Environment.getExternalStoragePublicDirectory</font>获取</p>
<p>/storage/emulated/0/Music</p>
<p>针对外部<font color="red">共有目录、根目录</font>等位置的存取需要<font color="orange">添加权限</font>，Android 6.0 之后还需要做运行时权限申请。针对外部<font color="red">私有目录</font>的存取则<font color="orange">不需要添加权限</font>。<br>默认情况下，Android系统<font color="red">不会</font>为我们的App在外部存储中创建私有路径，需要<font color="red">手动创建</font>。<br>外部私有目录在App卸载时同步删除。</p>
<p>​    </p>
<h4 id="（3）获取外部私有目录"><a href="#（3）获取外部私有目录" class="headerlink" title="（3）获取外部私有目录"></a>（3）获取外部私有目录</h4><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028162002693.png" alt="image-20201028162002693" style="zoom:80%;">





<h4 id="（4）存："><a href="#（4）存：" class="headerlink" title="（4）存："></a>（4）存：</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028162420940.png" alt="image-20201028162420940"></p>
<h4 id="（5）取："><a href="#（5）取：" class="headerlink" title="（5）取："></a>（5）取：</h4><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028162532386.png" alt="image-20201028162532386"></p>
<h2 id="二、SharedPreferences存储"><a href="#二、SharedPreferences存储" class="headerlink" title="二、SharedPreferences存储"></a>二、SharedPreferences存储</h2><h3 id="1-获取SharedPreferences对象"><a href="#1-获取SharedPreferences对象" class="headerlink" title="1.获取SharedPreferences对象"></a>1.获取<font color="cornflowerblue">SharedPreferences对象</font></h3><h4 id="1-Context-getSharedPreferences-方法"><a href="#1-Context-getSharedPreferences-方法" class="headerlink" title="(1) Context . getSharedPreferences()方法 "></a>(1) <font color="red">Context . getSharedPreferences()方法 </font></h4><p>​        此方法接受两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个。SharedPreferences 文件都是存放在 /data/data/&lt;包名&gt;/shared_prefs/ 目录下的。<br>​        第二个参数用于<font color="orange">指定操作模式</font>，主要为 MODE_PRIVATE（默认操作模式） 和 MODE_MULTI_PROCESS（多进程读写） 。</p>
<h4 id="2-Activity-类中的-getPreferences-方法"><a href="#2-Activity-类中的-getPreferences-方法" class="headerlink" title="(2)Activity 类中的 getPreferences() 方法"></a>(2)<font color="red">Activity 类中的 getPreferences() 方法</font></h4><p>这个方法和 Context 中的 getSharedPreferences() 方法类似，不过它只接收一个操作模式参数，使用这个方法时<font color="orange">会自动将当前活动的类名作为 SharedPreferences 的文件名</font>。</p>
<h4 id="3-PreferenceManager-类中的-getDefaultSharedPreferences-方法"><a href="#3-PreferenceManager-类中的-getDefaultSharedPreferences-方法" class="headerlink" title="(3) PreferenceManager 类中的 getDefaultSharedPreferences() 方法"></a>(3)<font color="red"> PreferenceManager 类中的 getDefaultSharedPreferences() 方法</font></h4><p>这是一个<font color="orange">静态方法</font>，它接收一个 Context 参数，并自动<font color="orange">使用当前应用程序的包名作为前缀</font>来命名 SharedPreferences 文件。</p>
<h3 id="2-通过SharedPreferences对象获取到Editor对象存数据"><a href="#2-通过SharedPreferences对象获取到Editor对象存数据" class="headerlink" title="2.通过SharedPreferences对象获取到Editor对象存数据"></a>2.通过SharedPreferences对象获取到<font color="cornflowerblue">Editor对象</font>存数据</h3><h4 id="（1）SharePreferences-Editor-editor-shared-edit"><a href="#（1）SharePreferences-Editor-editor-shared-edit" class="headerlink" title="（1）SharePreferences.Editor  editor = shared.edit();"></a>（1）SharePreferences.Editor  editor = shared.<font color="red">edit();</font></h4><p>调用 SharedPreferences 对象的 edit() 方法来获取一个 SharePreferences.Editor 对象。</p>
<h4 id="（2）editor-putString"><a href="#（2）editor-putString" class="headerlink" title="（2）editor.putString( )"></a>（2）editor<font color="red">.putString( )</font></h4><p>向 SharedPreferences.Editor 对象中添加数据，如果添加一个字符串则使用 editor.putString() 方法，以此类推。</p>
<h4 id="（3）editor-commit-editor-apply"><a href="#（3）editor-commit-editor-apply" class="headerlink" title="（3）editor.commit()  editor.apply()"></a>（3）<font color="red">editor.commit()  editor.apply()</font></h4><p>调用 editor.commit() 方法或者editor.apply()方法将添加的数据提交，从而完成数据存储操作。</p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164007127.png" alt="image-20201028164007127"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164138241.png" alt="image-20201028164138241"></p>
<h3 id="3-SharePreferences读取与删除数据"><a href="#3-SharePreferences读取与删除数据" class="headerlink" title="3.SharePreferences读取与删除数据"></a>3.SharePreferences<font color="cornflowerblue">读取与删除</font>数据</h3><p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164251857.png" alt="image-20201028164251857"></p>
<p><img src="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/image-20201028164334426.png" alt="image-20201028164334426">****</p>
]]></content>
      <categories>
        <category>《 Android基础》</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验七-Telnet与EIGRP</title>
    <url>/2021/06/04/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Telnet%E4%B8%8EEIGRP/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>了解Telnet与EIGRP（增强内部网关路由协议）基本原理；</p>
<p>掌握路由器Telnet远程登录的配置以及主机访问远程虚拟终端的方法；</p>
<p>掌握EIGRP路由协议的基本配置；</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>· Cisco Packet Tracer    </p>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>（1）新建Packet Tracer拓扑图（如图）；</p>
<p>（2）配置路由器启动Telnet服务；</p>
<p>（3）通过主机远程登录路由器；</p>
<p>（4）远程登录并配置路由器的EIGRP协议，实现网络连通。</p>
<h1 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h1><p>1.新建packet tracer网络拓扑图</p>
<p><img src="/2021/06/04/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Telnet%E4%B8%8EEIGRP/wps1.jpg" alt="img"> </p>
<p>2.配置路由器启动Telnet服务的基本流程</p>
<p>（通过配置线连接PC主机RS232和路由器console接口进行配置）</p>
<p>（1）设置“特权模式”使能加密密码：</p>
<p>Router(config)#enable secret 123</p>
<p>（2）设置控制台（console配置线）密码：</p>
<p>Router(config)#line console 0</p>
<p>Router(config-line)#password 456</p>
<p>Router(config-line)#login</p>
<p>Router(config-line)#exit</p>
<p>（3）设置远程登陆密码：</p>
<p>Router(config)#line vty 0 4</p>
<p>Router(config-line)#password 789</p>
<p>Router(config-line)#login</p>
<p>Router(config-line)#exit</p>
<p>3通过PC主机远程登录到路由器</p>
<p>PC&gt;telnet 202.192.0.254</p>
<p>Password: 789</p>
<p>Router&gt;enable</p>
<p>Password: 123</p>
<p>Router#</p>
<p>4.远程登录并配置路由器的EIGRP协议</p>
<p>Router#conf t</p>
<p>Router(config)#router eigrp 100                            //启动EIGRP路由协议</p>
<p>Router(config-router)#network 202.192.0.0        //宣告直连主类网络号</p>
<p>Router(config-router)#network 202.192.1.0</p>
<h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p>（1）远程登录并配置配置EIGRP协议</p>
<p><img src="/2021/06/04/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Telnet%E4%B8%8EEIGRP/wps2.jpg" alt="img"> </p>
<p>（2）配置完成后的路由表</p>
<p><img src="/2021/06/04/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Telnet%E4%B8%8EEIGRP/wps3.jpg" alt="img"> </p>
<p>（3）测试连通性</p>
<p><img src="/2021/06/04/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-Telnet%E4%B8%8EEIGRP/wps4.jpg" alt="img"> </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>Telnet协议是<a href="https://baike.baidu.com/item/TCP/IP%E5%8D%8F%E8%AE%AE">TCP/IP协议</a>族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>工作的能力。在<a href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF/1903878">终端</a>使用者的电脑上使用telnet程序，用它连接到<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>。<a href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF/1903878">终端</a>使用者可以在telnet程序中输入命令，这些命令会在<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>。要开始一个telnet会话，必须输入用户名和密码来登录<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>。Telnet是常用的<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/934368">远程控制</a>Web<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>的方法。</p>
</li>
<li><p>EIGRP:Enhanced Interior Gateway Routing Protocol 即增强内部<a href="https://baike.baidu.com/item/%E7%BD%91%E5%85%B3">网关</a><a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1">路由</a>协议。也翻译为 加强型<a href="https://baike.baidu.com/item/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/234910">内部网关路由协议</a>。 EIGRP是Cisco公司的私有协议（2013年已经公有化）。 EIGRP结合了链路状态和<a href="https://baike.baidu.com/item/%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F">距离矢量</a>型<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/5569697">路由选择协议</a>的Cisco专用协议，采用弥散修正算法（DUAL）来实现<a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%94%B6%E6%95%9B/6202142">快速收敛</a>，可以不发送定期的路由更新<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF/111163">信息</a>以减少<a href="https://baike.baidu.com/item/%E5%B8%A6%E5%AE%BD/266879">带宽</a>的占用，支持Appletalk、IP、Novell和NetWare等多种网络层协议。</p>
</li>
<li><p>EIGRP优点：快速收敛、部分更新、支持多种网络层协议、使用组播和单播、支持变长子网掩码（VLSM）和CIDR、无缝连接数据链路层协议和拓扑结构、配置简单</p>
</li>
</ol>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>标签外挂</title>
    <url>/2021/06/09/%E6%A0%87%E7%AD%BE%E5%A4%96%E6%8C%82/</url>
    <content><![CDATA[<h1 id="Note-Bootstrap-Callout"><a href="#Note-Bootstrap-Callout" class="headerlink" title="Note (Bootstrap Callout)"></a>Note (Bootstrap Callout)</h1><h2 id="用法一："><a href="#用法一：" class="headerlink" title="用法一："></a>用法一：</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">名称</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">class</td>
<td>【可选】标识，不同的标识有不同的配色（ default / primary / success / info / warning / danger ）</td>
</tr>
<tr>
<td align="center">no-icon</td>
<td>【可选】不显示 icon</td>
</tr>
<tr>
<td align="center">style</td>
<td>【可选】可以覆盖配置中的 style（simple/modern/flat/disabled）</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="simple"><a href="#simple" class="headerlink" title="simple"></a>simple</h3></li>
</ul>
<div class="note simple"><p>默认 提示块标签</p>
</div>

<div class="note default simple"><p>default 提示块标签</p>
</div>

<div class="note primary simple"><p>primary 提示块标签</p>
</div>

<div class="note success simple"><p>success 提示块标签</p>
</div>

<div class="note info simple"><p>info 提示块标签</p>
</div>

<div class="note warning simple"><p>warning 提示块标签</p>
</div>

<div class="note danger simple"><p>danger 提示块标签</p>
</div>



<ul>
<li><h3 id="modern"><a href="#modern" class="headerlink" title="modern"></a>modern</h3></li>
</ul>
<div class="note modern"><p>默认 提示块标签</p>
</div>

<div class="note default modern"><p>default 提示块标签</p>
</div>

<div class="note primary modern"><p>primary 提示块标签</p>
</div>

<div class="note success modern"><p>success 提示块标签</p>
</div>

<div class="note info modern"><p>info 提示块标签</p>
</div>

<div class="note warning modern"><p>warning 提示块标签</p>
</div>

<div class="note danger modern"><p>danger 提示块标签</p>
</div>



<ul>
<li><h3 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h3></li>
</ul>
<div class="note flat"><p>默认 提示块标签</p>
</div>

<div class="note default flat"><p>default 提示块标签</p>
</div>

<div class="note primary flat"><p>primary 提示块标签</p>
</div>

<div class="note success flat"><p>success 提示块标签</p>
</div>

<div class="note info flat"><p>info 提示块标签</p>
</div>

<div class="note warning flat"><p>warning 提示块标签</p>
</div>

<div class="note danger flat"><p>danger 提示块标签</p>
</div>



<ul>
<li><h3 id="disabled"><a href="#disabled" class="headerlink" title="disabled"></a>disabled</h3></li>
</ul>
<div class="note disabled"><p>默认 提示块标签</p>
</div>

<div class="note default disabled"><p>default 提示块标签</p>
</div>

<div class="note primary disabled"><p>primary 提示块标签</p>
</div>

<div class="note success disabled"><p>success 提示块标签</p>
</div>

<div class="note info disabled"><p>info 提示块标签</p>
</div>

<div class="note warning disabled"><p>warning 提示块标签</p>
</div>

<div class="note danger disabled"><p>danger 提示块标签</p>
</div>



<h2 id="用法二"><a href="#用法二" class="headerlink" title="用法二"></a>用法二</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>【可选】顔色(default / blue / pink / red / purple / orange / green)</td>
</tr>
<tr>
<td>icon</td>
<td>【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td>
</tr>
<tr>
<td>style</td>
<td>【可选】可以覆盖配置中的 style<br>（simple/modern/flat/disabled）</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="simple-1"><a href="#simple-1" class="headerlink" title="simple"></a>simple</h3></li>
</ul>
<div class="note icon simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="modern-1"><a href="#modern-1" class="headerlink" title="modern"></a>modern</h3></li>
</ul>
<div class="note icon modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="flat-1"><a href="#flat-1" class="headerlink" title="flat"></a>flat</h3></li>
</ul>
<div class="note icon flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="disabled-1"><a href="#disabled-1" class="headerlink" title="disabled"></a>disabled</h3></li>
</ul>
<div class="note icon disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue icon disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>

<div class="note pink icon disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>

<div class="note red icon disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange icon disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple icon disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>

<div class="note green icon disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>



<ul>
<li><h3 id="no-icon"><a href="#no-icon" class="headerlink" title="no-icon"></a>no-icon</h3></li>
</ul>
<div class="note no-icon simple"><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note blue no-icon simple"><p>2021年快到了….</p>
</div>

<div class="note pink no-icon simple"><p>小心开车 安全至上</p>
</div>

<div class="note red no-icon simple"><p>这是三片呢？还是四片？</p>
</div>

<div class="note orange no-icon simple"><p>你是刷 Visa 还是 UnionPay</p>
</div>

<div class="note purple no-icon simple"><p>剪刀石头布</p>
</div>

<div class="note green no-icon simple"><p>前端最讨厌的浏览器</p>
</div>

]]></content>
      <categories>
        <category>《hexo》</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Android进阶-RecyclerView</title>
    <url>/2021/06/09/Android%E8%BF%9B%E9%98%B6-RecyclerView/</url>
    <content><![CDATA[<div class="note green icon flat"><i class="note-icon fab fa-android"></i><p>前言：RecyclerView是Android5.0的一个新特性，包含在support-v7包中，用来替代ListView和GridView，是一个强大的滑动组件，而且可以实现瀑布流布局，它具有更加高度的解耦性、异常的灵活性和更高的效率，可以通过设置LayoutManager，ItemDecoration，ItemAnimator实现你想要的效果。</p>
</div>

<h2 id="配置build-gradle"><a href="#配置build-gradle" class="headerlink" title="配置build.gradle"></a>配置build.gradle</h2><ul>
<li>添加依赖包</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	...</span><br><span class="line">    implementation &#x27;androidx.appcompat:appcompat:1.2.0&#x27;</span><br><span class="line">    implementation &#x27;androidx.recyclerview:recyclerview:1.1.0&#x27;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用RecyclerView"><a href="#使用RecyclerView" class="headerlink" title="使用RecyclerView"></a>使用RecyclerView</h2><ul>
<li>布局文件中引入</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/id_recyclerview&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>活动中配置RecyclerView</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">mRecyclerView=(RecyclerView) findViewById(R.id.id_recyclerview);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置布局管理器</span></span><br><span class="line">mRecyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置item增加和删除时的动画</span></span><br><span class="line">mRecyclerView.setItemAnimator(<span class="keyword">new</span> DefaultItemAnimator());</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置适配器</span></span><br><span class="line">mList=createList();</span><br><span class="line">mHomeAdapter=<span class="keyword">new</span> HomeAdapter(mList, <span class="keyword">this</span>);</span><br><span class="line">mRecyclerView.setAdapter(mHomeAdapter);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建自定义适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">HomeAdapter</span>.<span class="title">MyViewHolder</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; mList;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeAdapter</span><span class="params">(List&lt;String&gt; mList, Context mContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mList = mList;</span><br><span class="line">        <span class="keyword">this</span>.mContext = mContext;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//删除条目信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeData</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        mList.remove(position);</span><br><span class="line">        notifyItemRemoved(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建自定义MyViewHolder</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyViewHolder <span class="title">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取条目（子项）布局的View对象</span></span><br><span class="line">        View view = LayoutInflater.from(mContext).inflate(R.layout.item_recycler, parent, <span class="keyword">false</span>);	</span><br><span class="line">        MyViewHolder holder = <span class="keyword">new</span> MyViewHolder(view);</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过创建的MyViewHolder实例，绑定（设置）子项布局各个组件上的数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="keyword">final</span> MyViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        holder.tv.setText(mList.get(position));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取子项的个数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        TextView tv;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyViewHolder</span><span class="params">(<span class="meta">@NonNull</span> View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            <span class="comment">//获取子项布局的各个组件</span></span><br><span class="line">            tv = (TextView) itemView.findViewById(R.id.tv_item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="设置分割线"><a href="#设置分割线" class="headerlink" title="设置分割线"></a>设置分割线</h2><ul>
<li>继承RecyclerView.ItemDecoration来自定义分割线</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DividerItemDecoration</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ItemDecoration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] ATTRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">            android.R.attr.listDivider              </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HORINZONTAL_LIST = LinearLayoutManager.HORIZONTAL;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERTICAL_LIST = LinearLayoutManager.VERTICAL;</span><br><span class="line">    <span class="keyword">private</span> Drawable mDivider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mOrientation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DividerItemDecoration</span><span class="params">(Context context, <span class="keyword">int</span> orientation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(ATTRS);     <span class="comment">//？？？？</span></span><br><span class="line">        mDivider = a.getDrawable(<span class="number">0</span>);</span><br><span class="line">        a.recycle();</span><br><span class="line">        setOrientation(orientation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOrientation</span><span class="params">(<span class="keyword">int</span> orientation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (orientation != HORINZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid orientation!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mOrientation = orientation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(<span class="meta">@NonNull</span> Canvas c, <span class="meta">@NonNull</span> RecyclerView parent, <span class="meta">@NonNull</span> RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(c, parent, state);</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL_LIST) &#123;</span><br><span class="line">            drawVertical(c, parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            drawHorinzontal(c, parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawHorinzontal</span><span class="params">(Canvas c, RecyclerView parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = parent.getPaddingLeft();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> right = parent.getWidth() - parent.getPaddingRight();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = parent.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = parent.getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = child.getBottom() + params.bottomMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> bottom = top + mDivider.getIntrinsicHeight();</span><br><span class="line">            mDivider.setBounds(left, top, right, bottom);</span><br><span class="line">            mDivider.draw(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawVertical</span><span class="params">(Canvas c, RecyclerView parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = parent.getPaddingTop();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = parent.getHeight() - parent.getPaddingBottom();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = parent.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = parent.getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = child.getRight() + params.rightMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> right = left + mDivider.getIntrinsicWidth();</span><br><span class="line">            mDivider.setBounds(left, top, right, bottom);</span><br><span class="line">            mDivider.draw(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffsets</span><span class="params">(<span class="meta">@NonNull</span> Rect outRect, <span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> RecyclerView parent, <span class="meta">@NonNull</span> RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.getItemOffsets(outRect, view, parent, state);</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL_LIST) &#123;</span><br><span class="line">            outRect.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, mDivider.getIntrinsicHeight());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outRect.set(<span class="number">0</span>, <span class="number">0</span>, mDivider.getIntrinsicWidth(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加分割线</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mRecyclerView.addItemDecoration(<span class="keyword">new</span> DividerItemDecoration(MainActivity.<span class="keyword">this</span>,DividerItemDecoration.HORINZONTAL_LIST));</span><br></pre></td></tr></table></figure>



<h2 id="自定义点击事件"><a href="#自定义点击事件" class="headerlink" title="自定义点击事件"></a>自定义点击事件</h2><div class="note info simple"><p>整体思路：</p>
<p>（1）在适配器在中创建一个自定义点击事件接听接口，声明一个接听接口变量，定义一个实例化该接口变量的函数；</p>
<p>（2）在主函数中，实例化一个自定义监听接口，并实现其中未定义的抽象方法（点击时的效果），并传给适配器；</p>
<p>（3）回到适配器其中，在回调的onClick()方法中，只有接听接口变量实例化了，才会调用其中实现了的抽象方法；</p>
<p>这种做法好处是：将接口定义与实现的分离，将点击事件定义的具体实现交给了主活动，在具体需要用到该适配器的时候才实现点击效果，这样，该自定义适配器类可以适用于多个不同点击效果的RecyclerView，只需要调用适配器的接口变量实例化函数。</p>
<p>这种设计思路是“接口的回调机制”<br><a href="https://blog.csdn.net/u012966861/article/details/52778841?utm_source=itdadao&amp;utm_medium=referral">https://blog.csdn.net/u012966861/article/details/52778841?utm_source=itdadao&amp;utm_medium=referral</a></p>
</div>

<ul>
<li>在HomeAdapter自定义OnItemClickListener接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   OnItemClickListener mOnItemClickListener;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnItemClickListener</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">onItemLongClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">……</span><br><span class="line">   <span class="comment">//实例化监听接口</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnItemClickListener</span><span class="params">(OnItemClickListener onItemClickListener)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.mOnItemClickListener = onItemClickListener;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主函数中，实现自定义监听接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//想要有不同的点击效果，可以定义多个setListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//实现按钮点击事件的自定义监听接口</span></span><br><span class="line">        mHomeAdapter.setOnItemClickListener(<span class="keyword">new</span> HomeAdapter.OnItemClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;点击了第&quot;</span>+(position+<span class="number">1</span>)+<span class="string">&quot;条&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemLongClick</span><span class="params">(View view, <span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>)</span><br><span class="line">                        .setTitle(<span class="string">&quot;确认要删除吗？&quot;</span>)</span><br><span class="line">                        .setNegativeButton(<span class="string">&quot;取消&quot;</span>,<span class="keyword">null</span>)</span><br><span class="line">                        .setPositiveButton(<span class="string">&quot;确认&quot;</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                                mHomeAdapter.removeData(position);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在适配器中调用接口中的方法</p>
<p>需要适配器类implements View.OnClickListener, View.OnLongClickListener</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MyViewHolder <span class="title">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        view.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        view.setOnLongClickListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mOnItemClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mOnItemClickListener.onItemClick(v, (<span class="keyword">int</span>) v.getTag());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLongClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mOnItemClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mOnItemClickListener.onItemLongClick(v, (<span class="keyword">int</span>) v.getTag());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>《Android进阶》</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像复习笔记</title>
    <url>/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><ul>
<li><p>1.数字图像：<br>一幅图像可定义为一个二维函数f(x,y),其中x和y是<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间(平面)坐标</span></span>,而在任何一对空间坐标(x, y)处的幅值f称为图像在该点处的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">强度或灰度</span></span>。当x, y和灰度值f是有限的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">离散数值</span></span>时，我们称该图像为数字图像。</p>
</li>
<li><p>2.数字图像处理：<br>是指借助于<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数字计算机</span></span>来处理数字图像。</p>
</li>
<li><p>3.像素：<br>数字图像是由有限数量的（二维的）元素组成的，每个元素都有一个特定的位置(x,y)和幅值f(x,y)。这些元素称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图画元素、图像元素或像素</span></span>。</p>
</li>
<li><p>4.图像增强：<br>对一幅图像进行某种操作，使其结果在特定应用中比原始图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">更适合</span></span>进行处理</p>
</li>
<li><p>5.图像复原：<br>图像复原也是改进图像外观的一个处理领域。然而，与图像增强不同，图像增强是<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">主观的</span></span>，而图像复原是<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">客观的;</span></span>;在某种意义上说，复原技术倾向于以<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像退化的数学或概率模型</span></span>为基础。另一方面，增强以<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">什么是好的增强效果</span></span>这种人的主观偏爱为基础。</p>
</li>
<li><p>6.图像处理系统基本组成结构：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数字化</span></span>设备（数码相机、数码摄像机）、图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">处理</span></span>设备（计算机和存储系统）、图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">输出</span></span>设备（打印机）</p>
</li>
<li><p>7.图像存储系统：<br>（1）图像文件格式体系：<br>互联网用：GIF、JPG<br>印 刷 用：TIF、JPG、TAG 、PCX<br>国际标准：TIF、JPG、BMP<br>（2）图像存储体系：(分级存储)<br>内存存储： 处理时使用<br>硬盘存储：处理、备份时用<br>备份存储：光盘、磁带<br>网络存储：SAN、 NAS</p>
</li>
<li><p>8.数字图像处理应用领域：传统领域（医学、地理学、生物学、军事）；最新领域（指纹识别、人脸识别、图像检索等）</p>
</li>
</ul>
<h1 id="第二章-数值图像基础"><a href="#第二章-数值图像基础" class="headerlink" title="第二章 数值图像基础"></a>第二章 数值图像基础</h1><div class="note info blue modern"><p><strong>两个名词解释</strong></p>
</div>

<ul>
<li><p>1.为了产生一幅数字图像，需要把连续的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">感知数据</span></span>转化为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数字形式</span></span>，这包括两种处理：取样和量化</p>
</li>
<li><p>2.取样：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间坐标</span></span>的数字化；(对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">坐标值</span></span>进行数字化)<br>量化：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">函数值（灰度值</span></span>的数字化；（对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">幅值</span></span>进行数字化）</p>
</li>
<li><p>3.非统一的图像的采样<br>在灰级变化<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">尖锐的</span></span>区域，用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">细腻的</span></span>采样，<br>在灰度级比较<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">平滑的</span></span>区域，用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">粗糙的</span></span>采样</p>
</li>
<li><p>4.非统一的图像的量化<br>✓ 在<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">边界附近</span></span>（灰度级变化尖锐）使用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">较少</span></span>的灰度级。剩余的灰度级可用于灰度级变化比较<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">平滑</span></span>的区域<br>✓ 避免或减少由于量化的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">太粗糙</span></span>，在灰度级变化比较平滑的区域出现<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">假轮廓</span></span>的现象</p>
</li>
<li><p>5.通常，图像在任何坐标(x,y)处的值记为f(x,y)，其中x和y都是整数。由一幅图像的坐标张成的实平面部分称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间域</span></span>，x和 y称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间变量或空间坐标</span></span>。</p>
</li>
<li><p>6.灰度跨越的值域非正式地称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">动态范围</span></span>。</p>
</li>
<li><p>7.空间分别率：图像中可辨别的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">最小细节</span></span>的度量，其中每单位<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">距离线对数</span></span>和每单位<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">距离点数</span></span>（像素数）都是最通用的度量。<br>灰度分别率：可分辨的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">最小灰度级</span></span>变化。</p>
</li>
<li><p>8.数字图像的表示包括：图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">描述信息</span></span>（如图像高度和宽度）、图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: 查看答案">查看答案
  </button><span class="hide-content">数据</span></span>（顺序存放的连续数据）</p>
</li>
<li><p>9.图像的质量包括：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">层次、对比度、清晰度</span></span><br>(1)层次：图像实际拥有的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">灰度级</span></span>的数量（灰度级：表示像素<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">明暗程度</span></span>的整数量） 图像的实际层次越多，视觉效果就越好。<br>(2)对比度：一幅图像中<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">灰度反差</span></span>的大小（对比度=最大亮度/最小亮度）<br>(3)与清晰度相关的主要因素：亮度、对比度、尺寸大小、细微层次、颜色饱和度</p>
</li>
<li><p>10.4邻域：像素p(x,y)的4邻域是： (x+1,y)；(x-1,y)；(x,y+1)；(x,y-1)。用N4(p)表示像素p的4邻域 </p>
<p>D邻域定义：像素p(x,y)的D邻域是对角上的点 (x+1,y+1)；(x+1,y-1)；(x-<br>1,y+1)；(x-1,y-1)<br>用ND(p)表示像素p的D邻域</p>
<p>8邻域定义：像素p(x,y)的8邻域是：<br>4邻域的点 ＋ D邻域的点<br>用N8(p)表示像素p的8邻域。 N<del>8</del>(p) = N<del>4</del>(p) + N<del>D</del>(p) </p>
</li>
<li><p>10.连通性：是描述区域和边界的重要概念。<br>两个像素连通的两个必要条件是：（1）两个像素<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">位置是否相邻</span></span>；（2）两个像素的灰度值是否满足<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">特定的相似性准则</span></span>（或者是否相等）</p>
</li>
<li><p>11.像素的连通性：<br>(1)4连通：对于具有值V的像素p和q，如果q在集合N4(p)中，则称这两个像素是4 连通的<br>(2)8连通：对于具有值V的像素p和q，如果q在 集 合N8(p)中，则称这两个像素是8连通的<br>(3)对 于 具 有 值 V 的 像 素 p 和 q ，<br>如 果<br>I.q在集合N4(p)中，或<br>II. q在集合ND(p)中，并且N4(p)与N4(q)的交集为空（没有值V的像素） 则称这两个像素是m连通的，即4连通和D连通的混合连通。</p>
</li>
<li><p>12.像素p(x,y)和q(s,t)间的欧式距离:<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623151831018.png" alt="image-20210623151831018"></p>
</li>
</ul>
<p>  对于这个距离计算法，具有与(x,y) 距离小于等于某个值r的像素是：包含在以(x,y)为圆心，以r为半径的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">圆平面</span></span></p>
<ul>
<li><p>13.像素p(x,y)和q(s,t)之间的D4距离(城市距离、街区距离)：<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620200645833.png" alt="image-20210620200645833"><br>具有与(x,y)距离小于等于某个值r的那些像素形成一个<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">菱形</span></span></p>
</li>
<li><p>14.q(s,t)之间的D8距离（棋盘距离）：<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620200655280.png" alt="image-20210620200655280"><br>具有与(x,y)距离小于等于某个值r的那些像素形成一个<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">正方形</span></span></p>
</li>
</ul>
<h1 id="第三章-灰度变换和空间滤波"><a href="#第三章-灰度变换和空间滤波" class="headerlink" title="第三章 灰度变换和空间滤波"></a>第三章 灰度变换和空间滤波</h1><div class="note info blue modern"><p><strong>两个名词解释+一个简答 +程序</strong></p>
</div>

<ul>
<li><p>1.图像增强分为两类：<br>(1)空间域处理：对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像像素</span></span>直接处理<br>(2)频率域处理：修改图像的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">傅里叶变换</span></span><br>2.灰度变换函数:g(x,y)=T[f(x,y)] 或 s = T(r)</p>
</li>
<li><p>3.一些基本的灰度变换函数：<br>（1）反转变换：<font color="red">s = (L-1) - r</font><br>作用：黑的变白，白的变黑（特别适合用于增强嵌入在一幅图像暗区域中的白色或灰色细节，特别是当黑色面积在尺寸上占主导时）<br>（2）对数变换：<font color="red">s = c log(1+r)</font><br>有时原图的动态范围太大，超出某些显示设备的允许动态范围，如直接使用原图，则一部分细节可能丢失, 解决办法是对原图进行灰度压缩，如对数变换</p>
<p>作用：灰度压缩/扩展，对数函数有个重要特征，即它能压缩像素值变化较大的图像的动态范围。</p>
</li>
</ul>
<p>（3）幂次变换：<font color="red">s = c ^r^  </font></p>
<p>  γ&lt;1 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">提高灰度级</span></span>，在正比函数上方，使图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">变亮 </span></span><br>  γ&gt;1 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">降低灰度级</span></span>，在正比函数下方，使图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">变暗</span></span></p>
<ul>
<li><p>4.直方图的定义：h(r<del>k</del>)= n<del>k</del>    p(r<del>k</del>)= n<del>k</del>/n<br>第二种定义的好处：<br>✓ 使函数值正则化到[0,1]区间，成为实数函数 ；<br>✓ 函数值的范围与像素的总数无关 ；<br>✓ 给出灰度级rk在图像中出现的概率密度统计</p>
</li>
<li><p>补充：</p>
<ul>
<li>暗图像：直方图的分量集中在灰度级的低端</li>
<li>亮图像：直方图的分量集中在灰度级的高端</li>
<li>低对比度图像：具有较窄的直方图，且集中在灰度级的中部</li>
<li>高对比度图像：具有较宽的直方图，直方图的分量覆盖了很宽的灰度级范围，且像素没有分布不均匀</li>
</ul>
</li>
<li><p>5.直方图的均衡化：基本思想是把原始图的直方图变换为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">均匀分布</span></span>的形式，这样就增加了像素灰度值的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">动态范围</span></span>，从而达到增强图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">整体对比度</span></span>的效果 </p>
</li>
<li><p>6.直方图均衡化公式：s=T(r)    0&lt;=r&lt;=1<br>T(r)满足下列两个条件：<br>（1）T(r)在区间0≤r≤1中为单值且单调递增<br>（2）当0≤r≤1时,0≤T(r)≤1</p>
<p>条件（1）保证输出灰度不少于相应的输入灰度，防止灰度反变换时产生的人为缺陷</p>
<p>条件（2）保证灰度的输出范围与输入范围一致，且是一对一的映射关系，防止二义性</p>
</li>
<li><p>7.对于连续灰度值：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201010302.png" alt="image-20210620201010302"><br>对于离散灰度值:<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201019248.png" alt="image-20210620201019248"><br>(P76 【例3.5】！)</p>
</li>
<li><p>8.直方图规定化：希望处理后的图像具有<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">规定的直方图形状</span></span>，这种用于产生处理后有特殊直方图的方法，称为直方图匹配或直方图规定化。<br>（P80 【例 3.8】）</p>
</li>
<li><p>9.镜头检测方法：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">连续帧相减、直方图相减、时空切片分析</span></span></p>
</li>
<li><p>10.镜头：是指一系列连续记录的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像帧</span></span>，用于表示一个时间段或相同地点连续的动作。</p>
</li>
<li><p>11.连续帧相减：<br>(1)算法原理：计算相邻两帧<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">像素</span></span>变化的数目。当超过设定的阈值时，即找到镜头的边缘。<br>(2)缺点：对摄像机运动敏感，如放缩、平移<br>(3)解决办法：通过滤波器的使用来降低。在比较一帧的每个像素前，用它的邻近区域的平均值来代替，这也就过滤了输入图像的一些噪声。</p>
</li>
<li><p>12.直方图相减<br>(1)算法原理：统计相邻两帧中所有像素在不同灰度上的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">分布差异</span></span>，当差异的累加值超过阈值T时，即检测到镜头边缘。<br>(2)优点：对对象运动不敏感，因为直方图忽略了帧内的空间变化。<br>(3)缺点：可能两个图像有类似的直方图但却是完全不同的内容。然而这种事件概率是足够低的。</p>
</li>
<li><p>13.空间滤波和空间滤波器的定义 使用<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间模板</span></span>进行的图像处理，被称为 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间滤波</span></span>。模板本身被称为<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">空间滤波器</span></span>（空间滤波器：邻域与预操作的集合）</p>
</li>
<li><p>14.<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201142147.png" alt="image-20210620201142147"></p>
</li>
</ul>
<p>其中w是滤波器系数，z是该系数对应的图像灰度值。</p>
<ul>
<li><p>15.平滑空间滤波器：<br>（1）线性滤波器：均值滤波器<br>（2）非线性滤波器：最大值滤波器、中值滤波器、最小值滤波器</p>
</li>
<li><p>16.均值滤波器：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">包含在滤波器邻域内像素的平均值</span></span> （用像素领域内的平均值代替该像素）<br>作用：减小图像灰度的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">“尖锐”</span></span>变化，减小<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">噪声</span></span>；边缘模糊<br>公式：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210620201443661.png" alt="image-20210620201443661"></p>
</li>
</ul>
<ul>
<li>17.统计排序滤波器：<br>是一种非线性滤波器，基于滤波器所在图像区域中<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">像素的排序</span></span>，由 <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">排序结果决定的值</span></span>代替中心像素的值</li>
</ul>
<p>（1）中值滤波器：用像素领域内的中间值代替该像素<br>①用途：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">去除噪声</span></span><br>②公式：R = mid {zk | k = 1,2,…,n}<br>③<br>特点：在去除噪音的同时，可以比较好地保留<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">边的锐度</span></span>和<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像的细节</span></span>（优于均值滤波器）<br>能够有效去除<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">脉冲噪声</span></span>：以黑白点叠加在图像上</p>
<p>（2）最大值滤波器：用像素领域内的最大值代替该像素<br>①用途：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">寻找最亮点</span></span><br>②公式：R = max {zk | k = 1,2,…,n} </p>
<p>（3）最小值滤波器：用像素领域内的最小值代替该像素<br>①用途：<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">寻找最暗点</span></span><br>②公式：R = min {zk | k = 1,2,…,n}</p>
<ul>
<li><p>18.锐化滤波器的应用：<br>突出图像中的细节，增强被模糊了的细节<br>✓ 印刷中的细微层次强调。弥补扫描对图像的钝化<br>✓ 超声探测成像，分辨率低，边缘模糊，通过锐化来改善<br>✓ 图像识别中，分割前的边缘提取<br>✓ 锐化处理恢复过度钝化、暴光不足的图像<br>✓ 尖端武器的目标识别、定位</p>
</li>
<li><p>19.二阶微分滤波器–拉普拉斯算子<br><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps1.jpg" alt="img"><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps2.jpg" alt="img"></p>
</li>
<li><p>20.一阶微分滤波器–梯度算子</p>
</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps3.jpg" alt="img"></p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps4.jpg" alt="img"></p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps5.jpg" alt="img"></p>
<h1 id="第六章-彩色图像处理"><a href="#第六章-彩色图像处理" class="headerlink" title="第六章 彩色图像处理"></a>第六章 彩色图像处理</h1><ul>
<li><p>1.为什么要研究彩色图像处理？<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">符合人类视觉特点：人类可以辨别几千种彩色色调和亮度；但相比之下只能辨别几十种灰度层次</span></span><br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">强有力的描绘子：常常可以简化从场景中提取和识别目标</span></span></p>
</li>
<li><p>2.彩色图像处理分为：全彩色图像处理、伪彩色图像处理</p>
</li>
<li><p>3.三原色：红、绿、蓝<br>二次色:    红+蓝=<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">深红M</span></span>        红+绿=<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">黄Y</span></span>        绿+蓝=<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">青色C</span></span></p>
</li>
<li><p>4.描述彩色光源质量的三个基本量：<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">辐射</span></span>（率）：从光源流出能量的总和，用瓦特（W）度量<br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">光强</span></span>：观察者从光源感知的（接收的）能量总和，用流明来度量<br>(3)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">亮度</span></span>：主观描绘子。实际上是不可能度量的，用来表示无色的强度概念。</p>
</li>
<li><p>5.用于区分不同颜色特性的基本量：<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">亮度</span></span>：具体表达了无色的强度概念<br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">色调</span></span>：是混合光波中与主波长有关的属性，表明观察者感知的主要颜色<br>(3)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">饱和度</span></span>：指的是相对纯净度，或一种颜色混合白光的数量。纯谱色是全饱和的。</p>
</li>
<li><p>6.彩色模型（彩色空间、彩色系统）<br>在某些标准下，用通常可以接收的方式方便地对彩色加以说明。本质上是对<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">坐标系统</span></span>和<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">子空间</span></span>的说明。</p>
<p>现在大多数的彩色模型不是面向硬件的，就是面向应用的。</p>
</li>
<li><p>7.RGB（红绿蓝模型）<br>(1)用于彩色监视器和一大类彩色视频摄像机；<br>(2)是图像<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">成像、显示、打印</span></span>等设备的基础<br>(3)面向硬件</p>
</li>
<li><p>8.CMY和CMYK（青、深红、黄、黑）<br>(1)用于彩色<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">打印机</span></span>和<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">复印机</span></span><br>(2)为什么用CMYK：等量的CMY原色产生黑色，但不纯</p>
</li>
<li><p>9.HSI（色调、饱和度、亮度）<br>(1)特点：<br>①I（亮度）分量与图像的彩色信息无关（解除分量中灰度I和颜色HS的联系）<br>②H和S分量与人感受颜色的方式是紧密联系的<br>(2)应用于计算机视觉、图像检索、视频检索</p>
</li>
<li><p>10.彩色空间转换</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623221945843.png" alt="image-20210623221945843"></p>
</li>
<li><p>11.什么叫伪彩色图像处理？</p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">也叫假彩色图像处理，根据一定的准则对灰度值赋予彩色的处理</span></span>



<p>为什么需要伪彩色图像处理？</p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">人类可以辨别几千种彩色色调和亮度；但相比之下只能辨别几十种灰度层次</span></span></li>
<li><p>12.怎样进行伪彩色图像处理？</p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">强度（强度）分层技术</span></span>、<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">灰度级到彩色的转换</span></span></li>
<li><p>13.全彩色图像处理分类<br>(1)分别处理每一分量，然后合成彩色图像<br>(2)直接对彩色像素处理</p>
</li>
<li><p>14补色：在彩色环上，与一种的色调H<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">直接相对立</span></span>的另外一种色调</p>
</li>
</ul>
<h1 id="第八章-图像压缩"><a href="#第八章-图像压缩" class="headerlink" title="第八章 图像压缩"></a>第八章 图像压缩</h1><ul>
<li><p>1.为什么需要图像压缩？<br>(1)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">图像的数据量通常很大，对存储、处理和传输带来许多问题</span></span><br>(2)<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">不断扩大的图像应用</span></span></p>
</li>
<li><p>2.图像压缩分类<br>(1)无损压缩：在压缩和解压缩过程中没有信息损失<br>(2)有损压缩：能取得较高的压缩率，但压缩后不能通过解压缩恢复原状</p>
</li>
<li><p>3.压缩方法：预测编码方法、变换编码方法</p>
</li>
<li><p>4.数据冗余：<br>数据是用来表示信息的。如果不同的方法为表示给定量的信息使用了不同的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">数据量</span></span>，那么使用较多数据量的方法中，有些数据必然是代表了无 用的信息，或者是重复地表示了其它数据已表示的信息，这就是数据冗余的概念</p>
</li>
<li><p>5.公式（相对数据冗余与压缩率的关系）</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps6.jpg" alt="img"><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps7.jpg" alt="img"></p>
</li>
<li><p>6.三种基本的数据冗余<br>（1）编码冗余<br>如果一个图像的灰度级编码，使用了多于<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">实际需要的编码符号</span></span>，就称该图像包含了编码冗余<br>（2）像素间冗余<br>对于一幅图像，很多<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">单个像素对视觉的贡献</span></span>是冗余的。它的值可以通过与它相邻的像素值为基础进行预测<br>（3）心理视觉冗余<br>有些信息在<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">通常的视觉过程中</span></span>通常的视觉过程中与另外一些信息相比并不那么重要，这些信息被认为是心理 视觉冗余的，去除这些信息并不会明显降低图像质量</p>
</li>
<li><p>7.保真度准则：<br>图像压缩可能会导致信息损失，需要有<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">评价信息损失</span></span>的测度，以描述解码图像相<br>对于原始图像的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">偏离程度</span></span>，这些测度称为保真度准则（量化信息丢失的本质的方法）<br>（1）均方根误差</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps8.jpg" alt="img"></p>
<p>（2）均方信噪比</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps9.jpg" alt="img"></p>
</li>
<li><p>8.图像压缩系统的功能流程图</p>
</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps10.jpg" alt="img"></p>
<ul>
<li>9.图像压缩系统模型（简）</li>
</ul>
<p>编码器：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps11.jpg" alt="img"></p>
<p>解码器：<img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps12.jpg" alt="img"></p>
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">转换器</span></span>（映射器）：减少像素间冗余
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">量化器</span></span>：减少心理视觉冗余，该步操作不可逆
<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">符号编码器</span></span>：减少编码冗余
<p>（进行无损压缩时，去掉量化器）</p>
<ul>
<li>10.信源的熵：<br>每个信源输出的平均信息。</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps13.jpg" alt="img"></p>
<ul>
<li><p>11.变长编码：<br>(1)减少编码冗余<br>(2)变长编码，即把<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">最短的码字</span></span>赋予给<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #04FF04;color: #fff">查看答案
  </button><span class="hide-content">出现概率最大</span></span>的灰度级</p>
</li>
<li><p>12.霍夫曼编码（步骤）<br>(1)第一步：将所有需要考虑的符号进行概率排序，并将最低概率的符号合并为一个符号来替代下次信源化简过程中的符号，从而创建一个信源化简系统；<br>(2)第二步：对每个化简后的信源进行编码，从小的信源开始一直编码到原始信源。<br>(3)P346 【例】</p>
</li>
<li><p>13.LZW编码（消除像素间冗余/空间冗余）<br>将原始数据中的重复字符串建立一个字串表，然后用该重复字串在字串表中的索引替代原始数据达到压缩的目的。<br>P351</p>
</li>
</ul>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><ul>
<li>补色和反色</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">im = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">im_converted_mat = np.zeros_like(im, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(im.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(im.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="comment"># 补色公式max(r,g,b)+min(r,g,b)-[r,g,b]</span></span><br><span class="line">        maxrgb = im[x][y].<span class="built_in">max</span>()</span><br><span class="line">        minrgb = im[x][y].<span class="built_in">min</span>()</span><br><span class="line">        im_converted_mat[x][y] = (<span class="built_in">int</span>(maxrgb) + <span class="built_in">int</span>(minrgb)) * np.ones(<span class="number">3</span>) - im[x][y]</span><br><span class="line"></span><br><span class="line"><span class="comment">#反色公式[255,255,255]-[r,g,b]</span></span><br><span class="line">im_converted_mat2 = np.ones_like(im) * <span class="number">255</span> - im</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;ori&#x27;</span>, im)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;buse&#x27;</span>, im_converted_mat)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;fanse&#x27;</span>, im_converted_mat2)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;buse.jpg&#x27;</span>, im_converted_mat)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;fanse.jpg&#x27;</span>, im_converted_mat2)</span><br><span class="line">cv2.waitKey()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<ul>
<li>直方图均衡化Histogram</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img=cv.imread(<span class="string">&quot;his.jpg&quot;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">gray_static=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">width,height=np.shape(img) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        gray_static[img[i,j]]+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">n=width*height</span><br><span class="line"></span><br><span class="line"><span class="comment">#pdf（概率密度函数）用来存储每个灰度值出现的概率（比例），像素个数/总像素个数</span></span><br><span class="line">pdf=[i/n <span class="keyword">for</span> i <span class="keyword">in</span> gray_static]</span><br><span class="line"></span><br><span class="line"><span class="comment">#cdf（累计分布函数），用来存储每个灰度值的累计分布函数值</span></span><br><span class="line">cdf=pdf</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    cdf[i]=cdf[i]+cdf[i-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#直方图均衡化转化</span></span><br><span class="line">img_t=np.copy(img)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(height):   </span><br><span class="line">        img_t[i,j]=<span class="number">255</span>*cdf[img[i,j]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制并显示直方图</span></span><br><span class="line">plt.hist(img.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"><span class="comment">#plt.show()</span></span><br><span class="line">plt.hist(img_t.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;img&#x27;</span>,img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;img_t&#x27;</span>,img_t)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<ul>
<li>均值滤波</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps14.jpg" alt="img"></p>
<ul>
<li>中值滤波</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps15.jpg" alt="img"></p>
<ul>
<li><p>锐化滤波</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps16.jpg" alt="img"></p>
</li>
</ul>
<ul>
<li><p>图像的熵</p>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/wps17.jpg" alt="img"></p>
</li>
</ul>
<ul>
<li>LZW-encode</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623235657253.png" alt="image-20210623235657253"></p>
<ul>
<li>LZW-decode</li>
</ul>
<p><img src="/2021/06/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210623235728790.png" alt="image-20210623235728790"></p>
]]></content>
      <categories>
        <category>《数字图像处理》</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多线程并发</title>
    <url>/2021/06/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>问题描述：1个父线程，并发生成N（N作为参数传入）个子线程。设定全局变量 g_sum=0，每个子进程在 0至200中随机选择一个数；</p>
<p>若子线程的进程ID是奇数则g_sum=g_sum-随机数，<br>若子线程的进程ID是偶数则g_sum=g_sum+随机数，</p>
<p>每个子线程对g_sum操作完成后都要通知父线程，父线程收到通知后输出“子线程{进程ID}对g_sum进行了[加/减]{随机数}操作，当前g_sum={新值}”，父进程将每次g_sum的新值进行记录，并对已记录的数组进行升序排列，每次重新排列后进行一次输出。</p>
</div>



<h1 id="想法一-回调方式"><a href="#想法一-回调方式" class="headerlink" title="想法一  回调方式"></a>想法一  回调方式</h1><ul>
<li><h2 id="ThreadTest-java"><a href="#ThreadTest-java" class="headerlink" title="ThreadTest.java"></a>ThreadTest.java</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> g_sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; g_sumList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Object o= <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.g_sumList.add(g_sum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *子线程回调函数 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> id 进程id</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> num 加或减的数值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> flag	加或减的标志</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callBack</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> num, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">		String mark = flag == <span class="number">1</span> ? <span class="string">&quot;加&quot;</span> : <span class="string">&quot;减&quot;</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;子线程&quot;</span> + id + <span class="string">&quot;:对g_num进行了&quot;</span> + mark + <span class="string">&quot;&quot;</span> + num + <span class="string">&quot;操作，当前g_sum=&quot;</span> + g_sum);</span><br><span class="line">		<span class="comment">//将值记录到列表并排序，输出</span></span><br><span class="line">		g_sumList.add(g_sum);</span><br><span class="line">		Collections.sort(g_sumList);</span><br><span class="line">		SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();		<span class="comment">// 格式化时间 </span></span><br><span class="line">        sdf.applyPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss a&quot;</span>);			<span class="comment">// a为am/pm的标记  </span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();								<span class="comment">// 获取当前时间 </span></span><br><span class="line">		System.out.println(sdf.format(date)+<span class="string">&quot; g_sum历史值升序为：&quot;</span>);</span><br><span class="line">		System.out.println(g_sumList);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建N个子线程</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">generateThreads</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> randomNum;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> id = <span class="number">1</span>; id &lt;= N; id++) &#123;</span><br><span class="line">			randomNum = (<span class="keyword">int</span>) (Math.random() * <span class="number">200</span>);</span><br><span class="line">			<span class="comment">//通过自定义的Runnable类创建线程</span></span><br><span class="line">			MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable(id, randomNum);</span><br><span class="line">			Thread t=<span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadTest test = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">		test.generateThreads(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="MyRunnable-java"><a href="#MyRunnable-java" class="headerlink" title="MyRunnable.java"></a>MyRunnable.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> randomNum;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> randomNum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.randomNum = randomNum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (ThreadTest.o) &#123;	<span class="comment">//加同步锁，防止多个线程对g_sum操作造成脏读</span></span><br><span class="line">			<span class="keyword">if</span> (id % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				ThreadTest.g_sum += randomNum;</span><br><span class="line">				ThreadTest.callBack(id, randomNum, <span class="number">1</span>);				</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ThreadTest.g_sum -= randomNum;</span><br><span class="line">				ThreadTest.callBack(id, randomNum, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2></li>
</ul>
<img src="/2021/06/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/image-20210623000217372.png" alt="image-20210623000217372" style="zoom:80%;">

<div class="note warning simple"><p>子线程和父线程之间其实并没有进行通信，打印信息的静态回调方法callBack()虽然是在主类中定义，但是却是在子线程中调用的，而不是子线程将信息传递并通知给主线程，然后主线程打印。</p>
</div>



<h1 id="想法二-消息队列"><a href="#想法二-消息队列" class="headerlink" title="想法二  消息队列"></a>想法二  消息队列</h1><ul>
<li><h2 id="ThreadTest-java-1"><a href="#ThreadTest-java-1" class="headerlink" title="ThreadTest.java"></a>ThreadTest.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> g_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Deque&lt;Message&gt; messageDeque = <span class="keyword">new</span> ArrayDeque();</span><br><span class="line"> 	<span class="keyword">public</span>  List&lt;Integer&gt; g_sumList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> Object lock= <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">super</span>();</span><br><span class="line"> 		<span class="keyword">this</span>.g_sumList.add(g_sum);</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">//N个子线程并发创建执行</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">generateThreads</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">int</span> randomNum;</span><br><span class="line"> 		<span class="keyword">for</span> (<span class="keyword">int</span> id = <span class="number">1</span>; id &lt;= N; id++) &#123;</span><br><span class="line"> 			randomNum = (<span class="keyword">int</span>) (Math.random() * <span class="number">200</span>);</span><br><span class="line"> 			<span class="comment">//通过自定义的Runnable类创建线程</span></span><br><span class="line"> 			MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable(id, randomNum);</span><br><span class="line"> 			Thread t=<span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line"> 			t.start();</span><br><span class="line"> 		&#125;		</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> 		System.out.print(<span class="string">&quot;请输入问题规模：&quot;</span>);</span><br><span class="line"> 		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> 		<span class="keyword">int</span> N = in.nextInt();</span><br><span class="line"> 		ThreadTest test = <span class="keyword">new</span> ThreadTest();</span><br><span class="line"> 		<span class="keyword">synchronized</span> (lock) &#123;						<span class="comment">//加同步锁</span></span><br><span class="line"> 			test.generateThreads(N);				<span class="comment">//在主线程中并发创建N个进程</span></span><br><span class="line"> 			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"> 				<span class="keyword">if</span>(messageDeque.isEmpty()) &#123;</span><br><span class="line"> 					lock.wait();					<span class="comment">//消息队列为空时，主线程阻塞等待，等待lock解锁</span></span><br><span class="line"> 				&#125;												</span><br><span class="line"> 				<span class="keyword">while</span>(!messageDeque.isEmpty()) &#123;		</span><br><span class="line"> 					<span class="comment">//主线程从消息队列中取出消息并打印</span></span><br><span class="line"> 					Message mess = messageDeque.pop();</span><br><span class="line"> 					System.out.println(<span class="string">&quot;子线程&quot;</span>+mess.tid+<span class="string">&quot;进行了&quot;</span>+mess.op+<span class="string">&quot;&quot;</span>+mess.randomNum+<span class="string">&quot;操作，当前g_sum=&quot;</span>+mess.g_sum);</span><br><span class="line"> 					<span class="comment">//将g_sum的历史值记录到列表并排序</span></span><br><span class="line"> 					test.g_sumList.add(mess.g_sum);</span><br><span class="line"> 					Collections.sort(test.g_sumList);</span><br><span class="line"> 					<span class="comment">//打印g_sum的历史值列表</span></span><br><span class="line"> 					System.out.println(mess.opeTime+<span class="string">&quot; g_sum历史值升序为：&quot;</span>);</span><br><span class="line"> 					System.out.println(test.g_sumList);</span><br><span class="line"> 					System.out.println();</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="MyRunnable-java-1"><a href="#MyRunnable-java-1" class="headerlink" title="MyRunnable.java"></a>MyRunnable.java</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tid;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> randomNum;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> randomNum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.tid = id;</span><br><span class="line">		<span class="keyword">this</span>.randomNum = randomNum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (ThreadTest.lock) &#123;						<span class="comment">//加同步锁，防止多个线程同时（并发）对g_sum操作造成脏读</span></span><br><span class="line">			SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();		<span class="comment">// 格式化时间 </span></span><br><span class="line">	        sdf.applyPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss a&quot;</span>);			<span class="comment">// a为am/pm的标记  								</span></span><br><span class="line">	        String opeTime = sdf.format(<span class="keyword">new</span> Date());			<span class="comment">// 获取当前时间 </span></span><br><span class="line">	        </span><br><span class="line">			<span class="keyword">if</span> (tid % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				ThreadTest.g_sum += randomNum;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//创建一个消息，并添加到消息队列</span></span><br><span class="line">				Message message = <span class="keyword">new</span> Message(tid, <span class="string">&quot;加&quot;</span>, randomNum,ThreadTest.g_sum,opeTime);</span><br><span class="line">				ThreadTest.messageDeque.add(message);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//解锁，唤醒主线程，可以从消息队列取消息啦</span></span><br><span class="line">				ThreadTest.lock.notifyAll();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ThreadTest.g_sum -= randomNum;</span><br><span class="line">							</span><br><span class="line">				Message message = <span class="keyword">new</span> Message(tid, <span class="string">&quot;减&quot;</span>, randomNum,ThreadTest.g_sum,opeTime);</span><br><span class="line">				ThreadTest.messageDeque.add(message);</span><br><span class="line">				</span><br><span class="line">				ThreadTest.lock.notifyAll();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> sleepTime = (<span class="keyword">int</span>)(Math.random() * <span class="number">500</span>);			<span class="comment">//让线程随机休眠一定时间</span></span><br><span class="line">				Thread.sleep(sleepTime);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//子线程传递给父线程的消息类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> tid;				<span class="comment">//子线程id</span></span><br><span class="line">		<span class="keyword">public</span> String op;			<span class="comment">//加或减操作</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> randomNum;		<span class="comment">//随机数</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> g_sum;			<span class="comment">//操作后的g_sum</span></span><br><span class="line">		<span class="keyword">public</span> String opeTime;		<span class="comment">//操作时的时间</span></span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> tid, String op, <span class="keyword">int</span> randomNum,<span class="keyword">int</span> g_sum ,String time)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.tid = tid;</span><br><span class="line">			<span class="keyword">this</span>.op = op;</span><br><span class="line">			<span class="keyword">this</span>.randomNum = randomNum;</span><br><span class="line">			<span class="keyword">this</span>.g_sum = g_sum;</span><br><span class="line">	        <span class="keyword">this</span>.opeTime=time;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2></li>
</ul>
<img src="/2021/06/22/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/image-20210623081306586.png" alt="image-20210623081306586" style="zoom: 80%;">

<div class="note success simple"><p>主线程并发创建N个子线程后，转为阻塞等待状态，等待lock解锁获得执行权且消息队列非空，然后一次性打印消息队列中已经存放的消息。</p>
<p>子线程在进行“加减”操作完成后，创建一个消息（包含线程id、随机数、操作类型、操作结果、操作时间信息），并把这个消息添加到消息队列（一个静态全局的队列），然后Notifiy（通知）唤醒主线程，通知它消息队列有消息可以打印了。</p>
</div>]]></content>
      <tags>
        <tag>多线程</tag>
        <tag>JAVA</tag>
        <tag>同步锁</tag>
      </tags>
  </entry>
  <entry>
    <title>网络实验八-无线路由器配置</title>
    <url>/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><p>掌握无线路由器的配置</p>
<p>掌握WireShake网络抓包和分析</p>
<p>掌握开启电脑IIS</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>· Cisco Packet Tracer     WireShake</p>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>（1）无线路由器的配置，包括设置SSID，密码，加密类型等信息</p>
<p>（2）WireShake网络抓包，分析账号和密码等数据信息</p>
<p>（3）开启电脑网络信息服务，搭建一个简单的网站，并测试访问 </p>
<h1 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h1><ul>
<li>1.掌握无线路由器配置    </li>
</ul>
<p>（1）新建packet tracer网络拓扑图（实验二为基础）</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps1.jpg" alt="img"> </p>
<p>（2）新增一个服务器和无线路由器，配置器基本信息，包括IP地址、子网掩码和默认网关</p>
<p>（3）通过一台主机Laptop2的WEB浏览器访问无线路由器的IP地址，授权登录（用户名和密码都是：admin）,登录到无线路由器的配置页面。在此可以完成路由器的一些配置，包括SSID，密码，网络模式，安全模式，管理者账号密码等。</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps2.jpg" alt="img">    <img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps3.jpg" alt="img"></p>
<p>（4）增加两台移动设备，连接WiFi，测试访问服务器</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps4.jpg" alt="img">    <img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps5.jpg" alt="img"></p>
<ul>
<li>2.网络抓包和分析</li>
</ul>
<p>（1）选择网络接口和过滤器，开始抓包</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps6.jpg" alt="img"> </p>
<p>（2）在浏览器中登录到教务系统</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps7.jpg" alt="img"> </p>
<p>（3）通过过滤器查找自己感兴趣的数据</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps8.jpg" alt="img"> </p>
<ul>
<li>3.开启电脑IIS</li>
</ul>
<p>（1）在控制面板–程序–启用或关闭Windows功能中开启IIS</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps9.jpg" alt="img"> </p>
<p>（2）在计算机管理中找到IIS服务，新建一个网站，选定好网站的物理路径，并将自己准备好的网站文件放入到该物理路径的文件夹下。</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps10.jpg" alt="img"> </p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps11.jpg" alt="img"> </p>
<p>（3）测试能否访问，在浏览器输入本机IPv4地址：172.19.160.1</p>
<p><img src="/2021/06/27/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE/wps12.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络实验总结</title>
    <url>/2021/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><div class="tabs" id="基本命令"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#基本命令-1">基本命令</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="基本命令-1"><ul>
<li>回车：进入非特权模式 &gt;</li>
<li>enable: 进入特权模式 Router#</li>
<li>configure terminal: 进入配置状态模式Router(config)#</li>
<li>interface fastEthernet 0/1：进入接口配置状态Router(config-if)#</li>
<li>ip address  202.168.1.254  255.255.255.0：配置接口IP地址</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h1><div class="tabs" id="配置路由器"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#配置路由器-1">静态配置</button></li><li class="tab"><button type="button" data-href="#配置路由器-2">RIP</button></li><li class="tab"><button type="button" data-href="#配置路由器-3">OSPF</button></li><li class="tab"><button type="button" data-href="#配置路由器-4">OSPF+RIP</button></li><li class="tab"><button type="button" data-href="#配置路由器-5">EIGRP</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="配置路由器-1"><ul>
<li><p>静态配置：(config)#ip route &lt;网络号&gt; &lt;掩码&gt; &lt;下一跳&gt;</p>
</li>
<li><p>RIP：</p>
<ul>
<li>(config)#router RIP<br>(config-router)#network 192.168.1.0<br>(config-router)#network 192.168.3.0<br>(config-router)#ver 2<br>(config-router)#no auto-summary</li>
</ul>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-2"><ul>
<li>RIP：<ul>
<li>(config)#router RIP<br>(config-router)#network 192.168.1.0<br>(config-router)#network 192.168.3.0<br>(config-router)#ver 2<br>(config-router)#no auto-summary</li>
</ul>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-3"><ul>
<li>–R3<br> (config)#router OSPF 100        //100是进程ID<br> (config-router)#network  192.168.1.0  0.0.0.255  area  1<br> (config-router)#network  192.168.4.0  0.0.0.255  area  1<br> （特别注意area不要弄错！！！）</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-4"><ul>
<li>在路由器R4上左侧配置RIP V2路由协议；右侧配置OSPF协议<br> —-R4<br> (config) #router ospf 100<br> (config-router) #network 192.168.3.0 0.0.0.255 area 2<br> (config-router) #network 192.168.7.0 0.0.0.255 area 2<br> (config-router) #redistribute rip metric 10 subnets  //将RIP路由重分布给OSPF路由协议<br> (config-router)#exit<br> (config) #router rip<br> (config-router) #network 192.168.7.0<br> (config-router) #ver 2<br> (config-router) #no auto-s<br> (config-router) #redistribute ospf 100 matric 10    //将OSPF路由重分布给RIP路由协议</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="配置路由器-5"><ul>
<li>Router#conf t<br> Router(config)#router eigrp 100                        //启动EIGRP路由协议<br> Router(config-router)#network 202.192.0.0        //宣告直连主类网络号<br> Router(config-router)#network 202.192.1.0</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="NAT地址转换"><a href="#NAT地址转换" class="headerlink" title="NAT地址转换"></a>NAT地址转换</h1><div class="tabs" id="nat地址转换"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#nat地址转换-1">NAT地址转换</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="nat地址转换-1"><ul>
<li>（1）定义NAT设备（路由器）的内外接口<br>  （config）int f0/0<br>  （config-if）ip nat inside<br>  （config）int f0/1<br>  （config-if）ip nat outside </li>
<li>（2）定义NAT地址池<br>  — ip nat pool pool-name start-ip  end-ip netmask 子网掩码<br>  （config）ip nat pool out 202.106.0.4  202.106.0.24 netmask 255.255.255.0  </li>
<li>（3）利用ACL(地址控制列表Address Control List)定义允许转换的本地地址列表<br>  — access-list ACL号 permit  &lt;网段&gt;  &lt;子网掩码反码&gt;<br>  （config）access-list 10 permit 192.168.0.0 0.0.0.255</li>
<li>（4）定义内部本地地址与内部全局地址的转换关系<br>  （config）ip nat inside source list 10 pool out</li>
<li>（5） 配置静态地址转换<br>  （config）ip nat inside source static 192.168.0.1  202.106.0.3<br>  （config）ip nat outside source static 202.106.0.3 192.168.0.1 </li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="FTP服务"><a href="#FTP服务" class="headerlink" title="FTP服务"></a>FTP服务</h1><div class="tabs" id="ftp服务"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ftp服务-1">FTP服务</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ftp服务-1"><ul>
<li>ftp FTP服务器域名</li>
<li>Username：</li>
<li>Password:</li>
<li>dir:查看文件</li>
<li>get 文件名：下载文件</li>
<li>put 文件名：上传文件</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h1 id="Telnet远程登录"><a href="#Telnet远程登录" class="headerlink" title="Telnet远程登录"></a>Telnet远程登录</h1><div class="tabs" id="telnet远程登录"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#telnet远程登录-1">Telnet远程登录</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="telnet远程登录-1"><ul>
<li><p>1.配置路由器启动Telnet服务的基本流程<br>（通过配置线连接PC主机RS232和路由器console接口进行配置）</p>
<p>（1）设置“特权模式”使能加密密码：<br>Router(config)#enable secret 123</p>
<p>（2）设置控制台（console配置线）密码：<br>Router(config)#line console 0<br>Router(config-line)#password 456<br>Router(config-line)#login<br>Router(config-line)#exit</p>
<p>（3）设置远程登陆密码：<br>Router(config)#line vty 0 4<br>Router(config-line)#password 789<br>Router(config-line)#login<br>Router(config-line)#exit</p>
</li>
<li><p>2.通过PC主机远程登录到路由器<br>PC&gt;telnet 202.192.0.254<br>Password: 789<br>Router&gt;enable<br>Password: 12<br>Router#</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>Cisco模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnGitBranch</title>
    <url>/2021/07/10/LearnGitBranch/</url>
    <content><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="Git-commit-提交"><a href="#Git-commit-提交" class="headerlink" title="Git commit(提交)"></a>Git commit(提交)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210707180217632.png" alt="image-20210707180217632"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180229217.png" alt="image-20210707180229217"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180240632.png" alt="image-20210707180240632"></p>
<h2 id="Git-Branch-分支"><a href="#Git-Branch-分支" class="headerlink" title="Git Branch(分支)"></a>Git Branch(分支)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210707180311964.png" alt="image-20210707180311964"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180321593.png" alt="image-20210707180321593"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180338498.png" alt="image-20210707180338498"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180354850.png" alt="image-20210707180354850"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180409051.png" alt="image-20210707180409051"></p>
<p><font color="red">git checkout -b bugFix</font></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708092926600.png" alt="image-20210708092926600"></p>
<h2 id="Git-Merge-合并1"><a href="#Git-Merge-合并1" class="headerlink" title="Git Merge(合并1)"></a>Git Merge(合并1)</h2><p>把<youBranch>合并到当前分支</youBranch></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180502520.png" alt="image-20210707180502520"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180520116.png" alt="image-20210707180520116"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180535801.png" alt="image-20210707180535801"></p>
<h2 id="Git-Rebase-合并2"><a href="#Git-Rebase-合并2" class="headerlink" title="Git Rebase(合并2)"></a>Git Rebase(合并2)</h2><p>把当前分支里的工作合并（复制）到<youbranch></youbranch></p>
<p>git rebase branch1 branch2：将分支2的提交合并到分支1</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180641790.png" alt="image-20210707180641790"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180657215.png" alt="image-20210707180657215"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707180715217.png" alt="image-20210707180715217"></p>
<h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="Git-checkout-在提交树上移动"><a href="#Git-checkout-在提交树上移动" class="headerlink" title="Git checkout(在提交树上移动)"></a>Git checkout(在提交树上移动)</h2><p>HEAD:是对当前提交记录的符号引用</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707181102379.png" alt="image-20210707181102379"></p>
<p>通过指定提交记录哈希值（如C1 C2）的方式在 Git 中移动</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182107038.png" alt="image-20210707182107038"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182131190.png" alt="image-20210707182131190"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182148057.png" alt="image-20210707182148057"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182202895.png" alt="image-20210707182202895"></p>
<h2 id="相对引用1（-）"><a href="#相对引用1（-）" class="headerlink" title="相对引用1（^）"></a>相对引用1（^）</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210707182718057.png" alt="image-20210707182718057"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182755760.png" alt="image-20210707182755760"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182857052.png" alt="image-20210707182857052"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182916539.png" alt="image-20210707182916539"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707182947454.png" alt="image-20210707182947454"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210707183002457.png" alt="image-20210707183002457"></p>
<h2 id="相对引用2（-）"><a href="#相对引用2（-）" class="headerlink" title="相对引用2（~）"></a>相对引用2（~）</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708094914804.png" alt="image-20210708094914804"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708094927037.png" alt="image-20210708094927037"></p>
<p>强制修改分支位置:git branch -f <yourbranch> <yourdestination></yourdestination></yourbranch></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708094944297.png" alt="image-20210708094944297"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708094957557.png" alt="image-20210708094957557"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708095006899.png" alt="image-20210708095006899"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708095740561.png" alt="image-20210708095740561"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708095752419.png" alt="image-20210708095752419"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -f main c6</span><br><span class="line">git checkout HEAD^</span><br><span class="line">git branch -f bugFix HEAD^</span><br></pre></td></tr></table></figure>



<h2 id="Git-reset-Git-revert-撤销变更"><a href="#Git-reset-Git-revert-撤销变更" class="headerlink" title="Git reset|Git revert(撤销变更)"></a>Git reset|Git revert(撤销变更)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708100028520.png" alt="image-20210708100028520"></p>
<ul>
<li>git Reset:用于本地</li>
</ul>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100107026.png" alt="image-20210708100107026"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100127317.png" alt="image-20210708100127317"></p>
<ul>
<li>git revert:用于远程，将记录的撤销（回退）记录加到当前分支记录</li>
</ul>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100137372.png" alt="image-20210708100137372"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708100205219.png" alt="image-20210708100205219"></p>
<h1 id="移动提交记录"><a href="#移动提交记录" class="headerlink" title="移动提交记录"></a>移动提交记录</h1><h2 id="Git-cherry-pick-整理提交记录"><a href="#Git-cherry-pick-整理提交记录" class="headerlink" title="Git cherry-pick(整理提交记录)"></a>Git cherry-pick(整理提交记录)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708101132784.png" alt="image-20210708101132784"></p>
<p>把一些提交号复制到当前位置</p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101213736.png" alt="image-20210708101213736"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101302552.png" alt="image-20210708101302552"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101313112.png" alt="image-20210708101313112"></p>
<h2 id="Git-rebase-i-交互式的-rebase"><a href="#Git-rebase-i-交互式的-rebase" class="headerlink" title="Git rebase -i (交互式的 rebase)"></a>Git rebase -i (交互式的 rebase)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708101514919.png" alt="image-20210708101514919"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101619930.png" alt="image-20210708101619930"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101644114.png" alt="image-20210708101644114"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101657579.png" alt="image-20210708101657579"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101750066.png" alt="image-20210708101750066"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708101847656.png" alt="image-20210708101847656"></p>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708102217807.png" alt="image-20210708102217807"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708102740387.png" alt="image-20210708102740387"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708102759444.png" alt="image-20210708102759444"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708102807847.png" alt="image-20210708102807847"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line"></span><br><span class="line">git cherry-pick c5 或 git cherry-pick bugFix</span><br></pre></td></tr></table></figure>



<h2 id="提交的技巧-1"><a href="#提交的技巧-1" class="headerlink" title="提交的技巧 #1"></a>提交的技巧 #1</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708103425969.png" alt="image-20210708103425969"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708103558144.png" alt="image-20210708103558144"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708104016852.png" alt="image-20210708104016852"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708104024797.png" alt="image-20210708104024797"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br><span class="line">调整C2 C3</span><br><span class="line">//进行一些小修改</span><br><span class="line">git commit --amend</span><br><span class="line">git rebase -i HEAD~2</span><br><span class="line">调整C2&#x27;&#x27; C3</span><br><span class="line">//将main移动到修改的最前端</span><br><span class="line">git rebase caption main</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/10/LearnGitBranch/image-20210708104217724.png" alt="image-20210708104217724"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105041296.png" alt="image-20210708105041296"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105110953.png" alt="image-20210708105110953"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105235499.png" alt="image-20210708105235499"></p>
<h2 id="提交的技巧-2"><a href="#提交的技巧-2" class="headerlink" title="提交的技巧 #2"></a>提交的技巧 #2</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708105329986.png" alt="image-20210708105329986"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105350522.png" alt="image-20210708105350522"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105409069.png" alt="image-20210708105409069"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708105427238.png" alt="image-20210708105427238"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git cherry-pick C2</span><br><span class="line">git commit --amend</span><br><span class="line">git cherry-pick C3</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/10/LearnGitBranch/image-20210708110350766.png" alt="image-20210708110350766"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110400360.png" alt="image-20210708110400360"></p>
<h2 id="Git-Tags"><a href="#Git-Tags" class="headerlink" title="Git Tags"></a>Git Tags</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708110500402.png" alt="image-20210708110500402"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110931071.png" alt="image-20210708110931071"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110943859.png" alt="image-20210708110943859"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708110956301.png" alt="image-20210708110956301"></p>
<h2 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708111252981.png" alt="image-20210708111252981"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708111345615.png" alt="image-20210708111345615"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708111406212.png" alt="image-20210708111406212"></p>
<h1 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h1><h2 id="多分支-rebase"><a href="#多分支-rebase" class="headerlink" title="多分支 rebase"></a>多分支 rebase</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708113031307.png" alt="image-20210708113031307"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708113047650.png" alt="image-20210708113047650"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708113057624.png" alt="image-20210708113057624"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase main bugFix</span><br><span class="line">git rebase bugFIx side</span><br><span class="line">git rebase side another</span><br><span class="line">git rebase another main</span><br></pre></td></tr></table></figure>



<h2 id="选择父提交记录"><a href="#选择父提交记录" class="headerlink" title="选择父提交记录"></a>选择父提交记录</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708122019936.png" alt="image-20210708122019936"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122034460.png" alt="image-20210708122034460"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122053452.png" alt="image-20210708122053452"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122106658.png" alt="image-20210708122106658"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122508583.png" alt="image-20210708122508583"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708122747166.png" alt="image-20210708122747166"></p>
<p>^num是横向移动；~num是纵向移动</p>
<h2 id="纠缠不清的分支"><a href="#纠缠不清的分支" class="headerlink" title="纠缠不清的分支"></a>纠缠不清的分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708124214014.png" alt="image-20210708124214014"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708125303011.png" alt="image-20210708125303011"><img src="/2021/07/10/LearnGitBranch/image-20210708125313507.png" alt="image-20210708125313507"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick C4 C3 C2</span><br><span class="line">git checkout two</span><br><span class="line">git cherry-pick C5 C4 C3 C2</span><br><span class="line">git branch -f three C2</span><br></pre></td></tr></table></figure>



<h1 id="Push-amp-Pull-——-Git-远程仓库！"><a href="#Push-amp-Pull-——-Git-远程仓库！" class="headerlink" title="Push &amp; Pull —— Git 远程仓库！"></a>Push &amp; Pull —— Git 远程仓库！</h1><h2 id="Git-clone"><a href="#Git-clone" class="headerlink" title="Git clone"></a>Git clone</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708131220533.png" alt="image-20210708131220533"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131436712.png" alt="image-20210708131436712"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131503803.png" alt="image-20210708131503803"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131528770.png" alt="image-20210708131528770"></p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708131730919.png" alt="image-20210708131730919"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131814248.png" alt="image-20210708131814248"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131823958.png" alt="image-20210708131823958"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708131851696.png" alt="image-20210708131851696"></p>
<h2 id="Git-Fetch-抓取"><a href="#Git-Fetch-抓取" class="headerlink" title="Git Fetch(抓取)"></a>Git Fetch(抓取)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708132039850.png" alt="image-20210708132039850"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132118768.png" alt="image-20210708132118768"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132146200.png" alt="image-20210708132146200"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132156470.png" alt="image-20210708132156470"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132324194.png" alt="image-20210708132324194"></p>
<h2 id="Git-Pull（拉取-抓取-合并）"><a href="#Git-Pull（拉取-抓取-合并）" class="headerlink" title="Git Pull（拉取=抓取+合并）"></a>Git Pull（拉取=抓取+合并）</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708132614877.png" alt="image-20210708132614877"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132632183.png" alt="image-20210708132632183"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132732130.png" alt="image-20210708132732130"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132745265.png" alt="image-20210708132745265"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708132847811.png" alt="image-20210708132847811"></p>
<p>git pull=git fetch + git merge</p>
<h2 id="模拟团队合作"><a href="#模拟团队合作" class="headerlink" title="模拟团队合作"></a>模拟团队合作</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708133042614.png" alt="image-20210708133042614"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133055142.png" alt="image-20210708133055142"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133104029.png" alt="image-20210708133104029"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133141450.png" alt="image-20210708133141450"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133506924.png" alt="image-20210708133506924"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133517625.png" alt="image-20210708133517625"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone</span><br><span class="line">git fakeTeamwork 2 </span><br><span class="line">git commit </span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>



<h2 id="Git-Push-推送"><a href="#Git-Push-推送" class="headerlink" title="Git Push(推送)"></a>Git Push(推送)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708133828791.png" alt="image-20210708133828791"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133844106.png" alt="image-20210708133844106"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708133914152.png" alt="image-20210708133914152"></p>
<h2 id="偏离的工作"><a href="#偏离的工作" class="headerlink" title="偏离的工作"></a>偏离的工作</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708134026480.png" alt="image-20210708134026480"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134033083.png" alt="image-20210708134033083"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134200396.png" alt="image-20210708134200396"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134240816.png" alt="image-20210708134240816"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134253823.png" alt="image-20210708134253823"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134308393.png" alt="image-20210708134308393"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134516265.png" alt="image-20210708134516265"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134544127.png" alt="image-20210708134544127"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134640963.png" alt="image-20210708134640963"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134741663.png" alt="image-20210708134741663"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134812644.png" alt="image-20210708134812644"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708134828932.png" alt="image-20210708134828932"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708135720602.png" alt="image-20210708135720602"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull = git fetch + git merge</span><br><span class="line"></span><br><span class="line">git pull --rebase = git fetch + git rebase</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/10/LearnGitBranch/image-20210708140648399.png" alt="image-20210708140648399"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708140710442.png" alt="image-20210708140710442"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708140725614.png" alt="image-20210708140725614"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141024342.png" alt="image-20210708141024342"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141038183.png" alt="image-20210708141038183"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fake&#x27; Teamwork</span><br><span class="line">objective</span><br><span class="line">git commit</span><br><span class="line">git pull --rebase</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h2 id="远程服务器拒绝-Remote-Rejected"><a href="#远程服务器拒绝-Remote-Rejected" class="headerlink" title="远程服务器拒绝!(Remote Rejected)"></a>远程服务器拒绝!(Remote Rejected)</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708141215295.png" alt="image-20210708141215295"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141250110.png" alt="image-20210708141250110"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708141325847.png" alt="image-20210708141325847"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142008765.png" alt="image-20210708142008765"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142015998.png" alt="image-20210708142015998"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard o/main</span><br><span class="line">➊在本程序中默认的行为是--hard 硬重置，可</span><br><span class="line">以尽情省略掉那个选项以避免麻烦!但是要记录</span><br><span class="line">Git中默认的是--mixed。</span><br><span class="line">$ git checkout -b feature C2</span><br><span class="line">$ git push origin feature</span><br><span class="line">0 local branch &quot;feature&quot; set to track</span><br><span class="line">remote branch &quot;o/ feature&quot;</span><br></pre></td></tr></table></figure>



<h1 id="关于-origin-和它的周边-——-Git-远程仓库高级操作"><a href="#关于-origin-和它的周边-——-Git-远程仓库高级操作" class="headerlink" title="关于 origin 和它的周边 —— Git 远程仓库高级操作"></a>关于 origin 和它的周边 —— Git 远程仓库高级操作</h1><h2 id="合并特性分支"><a href="#合并特性分支" class="headerlink" title="合并特性分支"></a>合并特性分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708142416567.png" alt="image-20210708142416567"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142507101.png" alt="image-20210708142507101"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142610921.png" alt="image-20210708142610921"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708142622769.png" alt="image-20210708142622769"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708143546325.png" alt="image-20210708143546325"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708143555630.png" alt="image-20210708143555630"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git rebase o/main side1</span><br><span class="line">$ git rebase side1 side2</span><br><span class="line">$ git rebase side2 side3</span><br><span class="line">$ git rebase side3 main</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>



<h2 id="合并远程仓库"><a href="#合并远程仓库" class="headerlink" title="合并远程仓库"></a>合并远程仓库</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708144023265.png" alt="image-20210708144023265"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144057908.png" alt="image-20210708144057908"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144131116.png" alt="image-20210708144131116"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144802230.png" alt="image-20210708144802230"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708144811391.png" alt="image-20210708144811391"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull</span><br><span class="line">git merge side1</span><br><span class="line">git merge side2</span><br><span class="line">git merge side3</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h2 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708145247050.png" alt="image-20210708145247050"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145254765.png" alt="image-20210708145254765"></p>
<h3 id="1-git-checkout-b-foo-o-main"><a href="#1-git-checkout-b-foo-o-main" class="headerlink" title="1. git checkout -b foo o/main"></a>1. git checkout -b foo o/main</h3><p><img src="/2021/07/10/LearnGitBranch/image-20210708145407891.png" alt="image-20210708145407891"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145459743.png" alt="image-20210708145459743"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145531527.png" alt="image-20210708145531527"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145546365.png" alt="image-20210708145546365"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145612482.png" alt="image-20210708145612482"></p>
<h3 id="2-git-branch-u-o-main-foo"><a href="#2-git-branch-u-o-main-foo" class="headerlink" title="2.git branch -u o/main foo"></a>2.git branch -u o/main foo</h3><p><img src="/2021/07/10/LearnGitBranch/image-20210708145630700.png" alt="image-20210708145630700"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708145825968.png" alt="image-20210708145825968"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708150403153.png" alt="image-20210708150403153"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708150412005.png" alt="image-20210708150412005"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b side o/main</span><br><span class="line">git commit</span><br><span class="line">git pull --rebase</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h2 id="Git-Push-的参数"><a href="#Git-Push-的参数" class="headerlink" title="Git Push 的参数"></a>Git Push 的参数</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708150947720.png" alt="image-20210708150947720"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151031205.png" alt="image-20210708151031205"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151130836.png" alt="image-20210708151130836"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151209286.png" alt="image-20210708151209286"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151219562.png" alt="image-20210708151219562"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151234915.png" alt="image-20210708151234915"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151308955.png" alt="image-20210708151308955"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151359962.png" alt="image-20210708151359962"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151407109.png" alt="image-20210708151407109"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin main</span><br><span class="line">git push origin foo</span><br></pre></td></tr></table></figure>



<h2 id="lt-place-gt-参数详解"><a href="#lt-place-gt-参数详解" class="headerlink" title="&lt;place&gt;参数详解"></a><code>&lt;place&gt;</code>参数详解</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708151517814.png" alt="image-20210708151517814"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151558370.png" alt="image-20210708151558370"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151630372.png" alt="image-20210708151630372"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151713402.png" alt="image-20210708151713402"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708151724079.png" alt="image-20210708151724079"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152005397.png" alt="image-20210708152005397"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152017612.png" alt="image-20210708152017612"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin main^:foo</span><br><span class="line">git push origin foo:main</span><br></pre></td></tr></table></figure>



<h2 id="Git-fetch-的参数"><a href="#Git-fetch-的参数" class="headerlink" title="Git fetch 的参数"></a>Git fetch 的参数</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708152517963.png" alt="image-20210708152517963"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152526401.png" alt="image-20210708152526401"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152550967.png" alt="image-20210708152550967"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152623538.png" alt="image-20210708152623538"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152648161.png" alt="image-20210708152648161"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152724640.png" alt="image-20210708152724640"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152754538.png" alt="image-20210708152754538"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152807081.png" alt="image-20210708152807081"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152821953.png" alt="image-20210708152821953"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152832652.png" alt="image-20210708152832652"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152844370.png" alt="image-20210708152844370"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708152855544.png" alt="image-20210708152855544"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708153609012.png" alt="image-20210708153609012"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708153618871.png" alt="image-20210708153618871"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin main~1:foo</span><br><span class="line">git fetch origin foo:main</span><br><span class="line">git checkout foo</span><br><span class="line">git merge main</span><br></pre></td></tr></table></figure>



<h2 id="古怪的-lt-source-gt"><a href="#古怪的-lt-source-gt" class="headerlink" title="古怪的 &lt;source&gt;"></a>古怪的 <code>&lt;source&gt;</code></h2><p> <img src="/2021/07/10/LearnGitBranch/image-20210708154016519.png" alt="image-20210708154016519"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154055142.png" alt="image-20210708154055142"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154118967.png" alt="image-20210708154118967"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154128060.png" alt="image-20210708154128060"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154143579.png" alt="image-20210708154143579"></p>
<h2 id="Git-pull-参数"><a href="#Git-pull-参数" class="headerlink" title="Git pull 参数"></a>Git pull 参数</h2><p><img src="/2021/07/10/LearnGitBranch/image-20210708154252617.png" alt="image-20210708154252617"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154310504.png" alt="image-20210708154310504"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154322563.png" alt="image-20210708154322563"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154340066.png" alt="image-20210708154340066"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154417895.png" alt="image-20210708154417895"></p>
<p><img src="/2021/07/10/LearnGitBranch/image-20210708154431000.png" alt="image-20210708154431000"></p>
]]></content>
      <categories>
        <category>《Git》</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>图解</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础篇</title>
    <url>/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​        数据库是一个按<font color="red">数据结构</font>来存储和管理数据的计算机软件系统。数据库的概念实际包括两层意思：</p>
<p>​    （1）数据库是一个实体，它是能够合理保管数据的“仓库”，用户在该“仓库”中存放要管理的事务数据，“数据”和“库”两个概念结合成为数据库。</p>
<p>​    （2）数据库是数据管理的新方法和技术，它能更合适的组织数据、更方便的维护数据、更严密的控制数据和更有效的利用数据。</p>
<h3 id="2-数据库管理系统"><a href="#2-数据库管理系统" class="headerlink" title="2.数据库管理系统"></a>2.数据库管理系统</h3><p>​        数据库管理系统是数据库系统的核心组成部分，主要完成对数据库的操作与管理功能，实现数据库对象的创建、数据库存储数据的<font color="red">（CRUD）查询、添加、修改与删除</font>操作和数据库的用户管理、权限管理等。它的安全直接关系到整个数据库系统的安全。</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210715161617639-1626619077152.png" alt="image-20210715161617639"></p>
<h3 id="3-关系型数据库-VS-非关系型数据库（NoSQL）"><a href="#3-关系型数据库-VS-非关系型数据库（NoSQL）" class="headerlink" title="3.关系型数据库 VS 非关系型数据库（NoSQL）"></a>3.关系型数据库 VS 非关系型数据库（NoSQL）</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">关系型数据库</th>
<th align="center">非关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td align="center">举例</td>
<td align="center">Mysql、SqlServer</td>
<td align="center">Redis、Memcache、MongoDB</td>
</tr>
<tr>
<td align="center">语言</td>
<td align="center">SQL</td>
<td align="center">没有统一标准</td>
</tr>
<tr>
<td align="center">存储方式</td>
<td align="center">行列表</td>
<td align="center">键值对、图、文档等</td>
</tr>
<tr>
<td align="center">存储结构</td>
<td align="center">结构化</td>
<td align="center">动态结构</td>
</tr>
<tr>
<td align="center">扩展方式</td>
<td align="center">纵向扩展能力</td>
<td align="center">横向扩展能力</td>
</tr>
</tbody></table>
<h3 id="4-结构化查询语言SQL"><a href="#4-结构化查询语言SQL" class="headerlink" title="4.结构化查询语言SQL"></a>4.结构化查询语言SQL</h3><ul>
<li><p>专门用来和数据库通信的语言</p>
</li>
<li><p>优点</p>
<ul>
<li>不是特定数据库提供商专有的，几乎所有的DBMS都支持SQL</li>
<li>简单易学</li>
<li>使用灵活</li>
</ul>
</li>
<li><p>类型</p>
<ul>
<li><p>DML（Data Manipulation Language):数据<font color="red">操纵</font>语句，用于CRUD数据库记录，并检查数据完整性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>：	添加数据到数据库中</span><br><span class="line">UPDATE：	修改数据库中的数据</span><br><span class="line"><span class="keyword">DELETE</span>：	删除数据库中的数据</span><br><span class="line"><span class="keyword">SELECT</span>：	选择（查询）数据</span><br></pre></td></tr></table></figure></li>
<li><p>DDL（Data Definition Language):数据<font color="red">定义</font>语句，用于库和表的创建、修改、删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>：创建数据库表</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>：更改表结构、添加、删除、修改列长度</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>：删除表</span><br><span class="line"><span class="keyword">CREATE</span> INDEX：在表上建立索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX：删除索引</span><br></pre></td></tr></table></figure></li>
<li><p>DCL（Data Control Language):数据<font color="red">控制</font>语句，用于定义用户的访问权限和安全级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>：授予访问权限</span><br><span class="line"><span class="keyword">REVOKE</span>：撤销访问权限</span><br><span class="line"><span class="keyword">COMMIT</span>：提交事务处理</span><br><span class="line"><span class="keyword">ROLLBACK</span>：事务处理回退</span><br><span class="line"><span class="keyword">SAVEPOINT</span>：设置保存点</span><br><span class="line">LOCK：对数据库的特定部分进行锁定</span><br></pre></td></tr></table></figure></li>
<li><p>TCL（Transaction Control Language）：<font color="red">事务控制</font>font&gt;语言</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>	事务提交</span><br><span class="line"><span class="keyword">rollback</span> 事务回滚</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716155635092-1626619077153.png" alt="image-20210716155635092"></p>
<h3 id="1-介绍与安装"><a href="#1-介绍与安装" class="headerlink" title="1.介绍与安装"></a>1.介绍与安装</h3><p>MySQL是一款流行的开源数据库。它也是一个关系型数据库管理系统，2008年，mysql被sun公司收购，2009年sun公司被oracle公司收购，自此两个主流的数据库都归Oracle公司收购。</p>
<ul>
<li><p>MySQL的主要优势如下：</p>
<ol>
<li>运行速度快。mysql 体积小，命令执行速度快。</li>
<li>使用成本低。mysql是开源的，且提供免费版本，对大多数用户来说大大降低了使用成本。</li>
<li>容易使用。与其他大型数据库的设置和管理相比，其复杂程度较低，易于使用。</li>
<li>可移植性。MySQL 能够运行于多种系统平台上，如window，linux，unix等。</li>
<li>适用更多用户。mysql支持最常用的数据管理功能，适用于中小型企业甚至大型</li>
</ol>
</li>
<li><p>[安装]: <a href="https://blog.csdn.net/qq_38269362/article/details/107283338">https://blog.csdn.net/qq_38269362/article/details/107283338</a></p>
</li>
</ul>
<h3 id="2-MySQL服务的启动和停止"><a href="#2-MySQL服务的启动和停止" class="headerlink" title="2.MySQL服务的启动和停止"></a>2.MySQL服务的启动和停止</h3><p>所谓MySQL服务是指一系列关于MySQL软件的后台进程，只有启动了MySQL服务才能对mysql软件进行操作。</p>
<ul>
<li><p>方式一：右击计算机图标，在’管理’命令中打开计算机管理,选择服务和应用程序，点击服务节点。选择MySQL。</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716143306352-1626619077153.png" alt="image-20210716143306352"></p>
</li>
<li><p>方式二：通过dos窗口命令行（管理员身份运行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br><span class="line">net stop mysql</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-MySQL服务的登录和退出"><a href="#3-MySQL服务的登录和退出" class="headerlink" title="3.MySQL服务的登录和退出"></a>3.MySQL服务的登录和退出</h3><ul>
<li><p>方式一：通过mysql自带的客户端（MySQL 5.5 Command Line Client 仅限于root用户）</p>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716144530148-1626619077153.png" alt="image-20210716144530148"></p>
</li>
<li><p>方式二：通过Windows自带的客户端</p>
<ul>
<li><p>登录：<font color="red">mysql 【-h 主机名 -P 端口号 】-u 用户名 -p【密码】</font></p>
</li>
<li><p>退出：<font color="red">exit 或ctrl+C</font></p>
</li>
</ul>
<p><img src="/2021/07/18/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20210716145007179-1626619077153.png" alt="image-20210716145007179"></p>
</li>
</ul>
<h3 id="4-MySQL常见命令"><a href="#4-MySQL常见命令" class="headerlink" title="4.MySQL常见命令"></a>4.MySQL常见命令</h3><p>​    注：sql命令以分号结尾</p>
<ul>
<li><h4 id="查看当前所有的数据库"><a href="#查看当前所有的数据库" class="headerlink" title="查看当前所有的数据库"></a>查看当前所有的数据库</h4><p><font color="red">show databases;</font></p>
</li>
<li><h4 id="打开指定的库"><a href="#打开指定的库" class="headerlink" title="打开指定的库"></a>打开指定的库</h4><p><font color="red">use 库名;</font></p>
</li>
<li><h4 id="查看当前库的所有表"><a href="#查看当前库的所有表" class="headerlink" title="查看当前库的所有表"></a>查看当前库的所有表</h4><p><font color="red">show tables;</font></p>
</li>
<li><h4 id="查看其它库的所有表"><a href="#查看其它库的所有表" class="headerlink" title="查看其它库的所有表"></a>查看其它库的所有表</h4><p><font color="red">show tables from 库名;</font></p>
</li>
<li><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p><font color="red">create table 表名(</font></p>
<p><font color="red">列名 列类型,</font><br><font color="red">列名 列类型，</font><br><font color="red">…    …);&lt;/</font></p>
</li>
<li><h4 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h4><p><font color="red">desc 表名;</font>font&gt;</p>
</li>
<li><h4 id="查看sql服务器版本"><a href="#查看sql服务器版本" class="headerlink" title="查看sql服务器版本"></a>查看sql服务器版本</h4><ul>
<li>sql命令:select version();</li>
<li>dos命令:mysql –version 或 mysql –V</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看当前所有数据库</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#打开指定数据库</span><br><span class="line">mysql<span class="operator">&gt;</span> use information_schema;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">#查看当前库中所有表</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_information_schema          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> CHARACTER_SETS                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> COLLATIONS                            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> COLLATION_CHARACTER_SET_APPLICABILITY <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> COLUMNS                               <span class="operator">|</span></span><br><span class="line">......</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="number">37</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#查看指定库中所有表</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables <span class="keyword">from</span> mysql;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_mysql           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> columns_priv              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> db                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> event                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> func                      <span class="operator">|</span></span><br><span class="line">......</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">24</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.06</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use test;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#在当前库创建表</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> stu_info(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="type">int</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> name <span class="type">varchar</span>(<span class="number">20</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_test <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> stu_info       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#查看指定表的表结构</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">#查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">#插入</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> stu_info (id,name) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;zlx&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> stu_info (id,name) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;zzx&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> frome stu_info;</span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;frome stu_info&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> zzx  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">mysql<span class="operator">&gt;</span> update stu_info <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;lili&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> lili <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> stu_info <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_info;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> zlx  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> version();</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> version() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5.5</span><span class="number">.15</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> exit</span><br><span class="line">Bye</span><br><span class="line"></span><br><span class="line">C:\Windows\system32<span class="operator">&gt;</span>mysql <span class="comment">--version</span></span><br><span class="line">mysql  Ver <span class="number">14.14</span> Distrib <span class="number">5.5</span><span class="number">.15</span>, <span class="keyword">for</span> Win32 (x86)</span><br></pre></td></tr></table></figure>



<h3 id="5-MySQL语法规范"><a href="#5-MySQL语法规范" class="headerlink" title="5.MySQL语法规范"></a>5.MySQL语法规范</h3><ul>
<li>1.不区分大小写,但建议关键字大写，表名、列名小写</li>
<li>2.每条命令最好用分号结尾（\g也可以）<br>3.每条命令根据需要，可以进行缩进 或换行（建议关键字单独一行）</li>
<li>4.注释<pre><code>单行注释：#注释文字
单行注释：-- 注释文字
多行注释：/* 注释文字  */
</code></pre>
</li>
</ul>
<h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><p>数据库结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(myemployees) --&gt;B[departments]</span><br><span class="line">  A --&gt; C[employees]</span><br><span class="line">  A --&gt; D[jobs]</span><br><span class="line">  A --&gt; E[locations]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h3><ul>
<li><font color="red">select  要查询的字段|表达式|常量值|函数  from  表名;</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语法：select 要查询的字段|表达式|常量值|函数 from 表名;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#(<span class="number">1</span>)查询表中单个字段</span><br><span class="line"><span class="keyword">SELECT</span> `last_name` <span class="keyword">FROM</span> employees ;</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)查询表中多个字段</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  `last_name`,</span><br><span class="line">  `salary`,</span><br><span class="line">  `email` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">#(<span class="number">3</span>)查询所有字段 </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#(<span class="number">4</span>)查询常量值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">#(<span class="number">5</span>)查询表达式</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">%</span><span class="number">98</span></span><br><span class="line"></span><br><span class="line">#(<span class="number">6</span>)查询函数</span><br><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"></span><br><span class="line">#(<span class="number">7</span>)为字段起别名</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-便于理解</span></span><br><span class="line"><span class="comment">-如果要查询的字段有重名的情况，使用别名可以区分开来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#方式<span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">%</span><span class="number">98</span> <span class="keyword">AS</span> 结果</span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> 姓,first_name <span class="keyword">AS</span> 名 <span class="keyword">FROM</span> employees</span><br><span class="line">#方式<span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name 姓, first_name 名 <span class="keyword">FROM</span> employees</span><br><span class="line">#别名中含特殊符号(用双引号)</span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">AS</span> &quot;out put&quot; <span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#(<span class="number">8</span>)去重(关键字：<span class="keyword">distinct</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#（<span class="number">9</span>）<span class="operator">+</span>号的作用</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">select 100+90;两个操作数都为数值型，则做加法运算</span></span><br><span class="line"><span class="comment">其中一方为字符型，试图将字符型转换为数值型</span></span><br><span class="line"><span class="comment">select &#x27;100&#x27;+90;	=190</span></span><br><span class="line"><span class="comment">select &#x27;John&#x27;+90;	=0+90=90</span></span><br><span class="line"><span class="comment">select null+90;只要其中一方为null,则结果肯定为null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#(<span class="number">10</span>)拼接(关键字：concat)</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(last_name,first_name) <span class="keyword">AS</span> 姓名 <span class="keyword">FROM</span> employees</span><br></pre></td></tr></table></figure>



<h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h3><ul>
<li><p><font color="red">语法：select  查询字段  from  表名  while 筛选条件;  </font></p>
</li>
<li><p>条件表达式：&gt;  &lt;  &gt;=  &lt;=  =  !=  &lt;&gt;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按条件表达式筛选</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例一：查询工资<span class="operator">&gt;</span><span class="number">12000</span>的员工信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	salary<span class="operator">&gt;</span><span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line">#案例二：查询部门编号不等于<span class="number">90</span>的员工名和部门编号</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	department_id</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	department_id<span class="operator">&lt;&gt;</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>逻辑表达式：</p>
<ul>
<li><p>and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false</p>
</li>
<li><p>or(||)：两个条件只要有一个成立，结果为true，否则为false</p>
</li>
<li><p>not(!)：如果条件成立，则not后为false，否则为true</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按逻辑表达式筛选</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例一：查询工资在<span class="number">10000</span>到<span class="number">20000</span>之间的员工名、工资以及奖金</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span> 	</span><br><span class="line">	salary<span class="operator">&gt;=</span><span class="number">10000</span> <span class="keyword">AND</span> salary<span class="operator">&lt;=</span><span class="number">20000</span>;</span><br><span class="line">	</span><br><span class="line">#案例二：查询部门编号不是在<span class="number">90</span>到<span class="number">110</span>之间，或者工资高于<span class="number">15000</span>的员工信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">NOT</span>(department_id<span class="operator">&gt;=</span><span class="number">90</span> <span class="keyword">AND</span> department_id<span class="operator">&lt;=</span><span class="number">110</span>) <span class="keyword">OR</span> salary<span class="operator">&gt;</span><span class="number">15000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>模糊查询：</p>
<ul>
<li><p>like</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">-------like</span></span><br><span class="line">#案例一：查询员工名字以s开头的员工信息（通配符：<span class="operator">%</span>任意多个字符，_任意单个字符）</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	last_name <span class="keyword">LIKE</span> <span class="string">&#x27;s%&#x27;</span></span><br><span class="line"></span><br><span class="line">#案例二：查询员工名字中第三个字符为i,第四个字符为e的员工名和工资</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	last_name <span class="keyword">LIKE</span> <span class="string">&#x27;__i_e%&#x27;</span> </span><br><span class="line">	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">转义字符 \</span></span><br><span class="line"><span class="comment">自定义转义字符 &#x27;$&#x27; ESCAPE &#x27;$&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>between and</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">--------between and（可以替换 &lt;  and  &gt;）</span></span><br><span class="line">#案例：查询员工号在<span class="number">100</span>到<span class="number">120</span>之间的员工信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	employee_id <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">120</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>in</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">------in（可以替换 = or = or = ……）</span></span><br><span class="line">#案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个的员工名和工种编号</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	job_id<span class="operator">=</span><span class="string">&#x27;IT_PROG&#x27;</span> <span class="keyword">OR</span> job_id<span class="operator">=</span><span class="string">&#x27;AD_VP&#x27;</span> <span class="keyword">OR</span> job_id<span class="operator">=</span><span class="string">&#x27;AD_PRES&#x27;</span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	job_id <span class="keyword">IN</span> (<span class="string">&#x27;IT_PROG&#x27;</span>,<span class="string">&#x27;AD_VP&#x27;</span>,<span class="string">&#x27;AD_PRES&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>is null | is not null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">----is （not）null</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断null值不能用 = 和 &lt;&gt;,而要用 is 和 is not</span></span><br><span class="line"><span class="comment">也可以用安全等于 &lt;=&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#案例一：查询没有奖金的员工名和奖金率</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span></span><br><span class="line">	</span><br><span class="line">#案例二：查询有奖金的员工名和奖金率</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">	</span><br><span class="line">#案例三：查询员工号为<span class="number">176</span>的姓名、部门号和年薪</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">年薪=salary*12*(1+年薪率)</span></span><br><span class="line"><span class="comment">年薪率可能为NULL，为NULL时当作0</span></span><br><span class="line"><span class="comment">年薪=salary*12*(1+IFNULL(commission_pct,0))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	department_id,</span><br><span class="line">	salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">AS</span> 年薪</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3.排序查询"></a>3.排序查询</h3><ul>
<li><p><font color="red">语法：select  要查询的东西  from  表 【where 条件】 order by 排序的字段|表达式|别名|函数 【asc|desc】</font>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语法:</span></span><br><span class="line"><span class="comment">select 要查询的东西</span></span><br><span class="line"><span class="comment">from 表</span></span><br><span class="line"><span class="comment">【where 条件】</span></span><br><span class="line"><span class="comment">order by 排序的字段|表达式|别名|函数 【asc|desc】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#案例一：查询员工信息，要求按工资从高到低排序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">#案例二：查询部门编号<span class="operator">&gt;=</span><span class="number">90</span>的员工信息，按入职时间的先后排序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&gt;=</span> <span class="number">90</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hiredate <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">#案例三：按年薪高低显示员工的信息和年薪【按表达式<span class="operator">|</span>别名排序】</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#案例四：按姓名的长度显示员工信姓名和工资【按函数排序】</span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(last_name) 姓名长度,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> LENGTH(last_name) <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#案例五：查询员工信息，要求先按工资升序排序，如果工资相同，再按员工编号降序排序【按多个字段排序】</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>,employee_id <span class="keyword">DESC</span>;			</span><br></pre></td></tr></table></figure>

<p>​                       </p>
</li>
</ul>
<h3 id="4-单行函数"><a href="#4-单行函数" class="headerlink" title="4.单行函数"></a>4.单行函数</h3><ul>
<li>字符函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#(<span class="number">1</span>)length()：获取参数值的字节个数(汉字占<span class="number">3</span>个字节)</span><br><span class="line"><span class="keyword">select</span> length(<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> length(<span class="string">&#x27;张三丰&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)concat():拼接字符串</span><br><span class="line"><span class="keyword">select</span> concat(last_name,<span class="string">&#x27;_&#x27;</span>,first_name) <span class="keyword">from</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">3</span>)<span class="built_in">upper</span>()、<span class="built_in">lower</span>():转换为大<span class="operator">/</span>小写</span><br><span class="line"><span class="keyword">select</span> concat(<span class="built_in">upper</span>(last_name),<span class="built_in">lower</span>(first_name)) 姓名 <span class="keyword">from</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">4</span>)substr():截取字符串	注意：索引从<span class="number">1</span>开始</span><br><span class="line">#<span class="comment">--截取从指定索引处开始后面所有字符</span></span><br><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;李莫愁爱上了陆展元&#x27;</span>,<span class="number">7</span>) output;</span><br><span class="line"></span><br><span class="line">#<span class="comment">--截取从指定索引处开始指定长度字符</span></span><br><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;李莫愁爱上了陆展元&#x27;</span>,<span class="number">1</span>,<span class="number">3</span>) output;</span><br><span class="line"></span><br><span class="line">#案例：姓名中首字符大写，其他字符小写，用—连接，显示处理</span><br><span class="line"><span class="keyword">select</span> concat(<span class="built_in">upper</span>(substr(last_name,<span class="number">1</span>,<span class="number">1</span>)),substr(last_name,<span class="number">2</span>),<span class="string">&#x27;-&#x27;</span>,<span class="built_in">lower</span>(first_name))</span><br><span class="line"><span class="keyword">as</span> 姓名 <span class="keyword">from</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">5</span>)instr():返回字串第一次出现的索引，如果找不到则返回<span class="number">0</span></span><br><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;杨不悔爱上了殷六侠&#x27;</span>,<span class="string">&#x27;爱上&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">6</span>)<span class="built_in">trim</span>():去除字符串前后空格或指定字符</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27;     张翠山     &#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;aaaaaaa张aaa翠山aaaaa&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">7</span>)lpad():用指定字符串左填充到指定长度</span><br><span class="line"><span class="keyword">select</span> lpad(<span class="string">&#x27;殷素素&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;&amp;&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">8</span>)rpad():用指定字符串右填充到指定长度</span><br><span class="line"><span class="keyword">select</span> rpad(<span class="string">&#x27;殷素素&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;$&#x27;</span>) <span class="keyword">as</span> output;</span><br><span class="line"></span><br><span class="line">#(<span class="number">9</span>)replace():替换字符串</span><br><span class="line"><span class="keyword">select</span> replace(<span class="string">&#x27;张无忌爱上了周芷若周芷若&#x27;</span>,<span class="string">&#x27;周芷若&#x27;</span>,<span class="string">&#x27;赵敏&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>数学函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#(<span class="number">1</span>)round:四舍五入</span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.55</span>);</span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.235</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)ceil:向上取整,返回<span class="operator">&gt;=</span>该参数的最小整数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">-2.1</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">3</span>)floor:向下取整，返回<span class="operator">&lt;=</span>该参数的最大整</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">-9.99</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">4</span>)<span class="keyword">truncate</span>:截断</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">-1.2234</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">#(<span class="number">5</span>)mod:取余函数</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">取余原理：</span></span><br><span class="line"><span class="comment">mod(a,b):= a-(a/b)*b</span></span><br><span class="line"><span class="comment">mod(-10,-3)=-10-(-10/-3)*(-3)=-10-(-9)=-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">10</span>,<span class="number">-3</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>日期函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#now 返回当前系统日期<span class="operator">+</span>时间</span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"></span><br><span class="line">#curdate 返回当前日期</span><br><span class="line"><span class="keyword">SELECT</span> CURDATE();</span><br><span class="line"></span><br><span class="line">#curtime 返回当前时间</span><br><span class="line"><span class="keyword">SELECT</span> CURTIME();</span><br><span class="line"></span><br><span class="line">#获取指定部分的年、月、日、小时、分、秒</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW()) 年;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="string">&#x27;1999-10-10&#x27;</span>) 年;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(NOW()) 月;</span><br><span class="line"><span class="keyword">SELECT</span> MONTHNAME(NOW()) 月名;</span><br><span class="line"></span><br><span class="line">#将字符串转换为日期</span><br><span class="line"><span class="keyword">SELECT</span> STR_TO_DATE(<span class="string">&#x27;3-3-1999&#x27;</span>,<span class="string">&#x27;%c-%d-%Y&#x27;</span>) <span class="keyword">AS</span> out_put</span><br><span class="line"></span><br><span class="line">#将日期转换为字符</span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(hiredate,<span class="string">&#x27;%m月/%d日 %y年&#x27;</span>) <span class="keyword">AS</span> out_put</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>流程控制函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#(<span class="number">1</span>)if函数：if <span class="keyword">else</span> 效果</span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">10</span><span class="operator">&lt;</span><span class="number">5</span>,<span class="string">&#x27;小&#x27;</span>,<span class="string">&#x27;大&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct,</span><br><span class="line">	IF(commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span>,<span class="string">&#x27;没有奖金&#x27;</span>,<span class="string">&#x27;有奖金&#x27;</span>) <span class="keyword">AS</span> 备注</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#(<span class="number">2</span>)<span class="keyword">case</span>函数：作为一个新字段，与前面字段用逗号隔开</span><br><span class="line">#<span class="comment">--switch case的效果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">case 要判断的表达式</span></span><br><span class="line"><span class="comment">when 常量1 then 要显示的值1或语句1；</span></span><br><span class="line"><span class="comment">when 常量2 then 要显示的值2或语句2；</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">else 要显示的值n或语句n;</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="comment">部门号=30，显示工资1.1倍</span></span><br><span class="line"><span class="comment">部门号=40，显示工资1.2倍</span></span><br><span class="line"><span class="comment">部门号=50，显示工资1.3倍</span></span><br><span class="line"><span class="comment">其他部门，显示原工资</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">AS</span> 原始工资,department_id,</span><br><span class="line"><span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">30</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">40</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">50</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.3</span></span><br><span class="line"><span class="keyword">ELSE</span> salary</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">AS</span> 新工资</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="comment">--多重if的效果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">case </span></span><br><span class="line"><span class="comment">when 表达式1 then 要显示的值1或语句1；</span></span><br><span class="line"><span class="comment">when 表达式2 then 要显示的值2或语句2；</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">else 要显示的值n或语句n;</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例：查询工资级别，要求</span></span><br><span class="line"><span class="comment">工资&gt;20000,显示A级别</span></span><br><span class="line"><span class="comment">工资&gt;15000，显示B级别</span></span><br><span class="line"><span class="comment">工资&lt;15000,显示C级别</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,</span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">20000</span> <span class="keyword">THEN</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> 工资级别</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br></pre></td></tr></table></figure>



<h3 id="5-分组函数"><a href="#5-分组函数" class="headerlink" title="5.分组函数"></a>5.分组函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：做统计使用，又称为聚合函数、统计函数或组函数</span></span><br><span class="line"><span class="comment">sum 求和、avg 平均值、max 最大值、min 最小值、count 计算个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#<span class="number">1.</span>简单使用</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">AS</span> 工资总和 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> 最高工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) <span class="keyword">AS</span> 最低工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> 平均工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(salary) <span class="keyword">AS</span> 有工资的人数 <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary)<span class="operator">/</span><span class="built_in">COUNT</span>(salary) <span class="keyword">AS</span> 平均工资 <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>参数支持那些类型</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sum,avg 一般处理数值型；</span></span><br><span class="line"><span class="comment">max,min,count 可以处理任何类型；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(last_name),<span class="built_in">AVG</span>(last_name) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(last_name),<span class="built_in">MIN</span>(last_name) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>以上分组函数都忽略<span class="keyword">null</span>值；</span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="built_in">COUNT</span>(commission_pct)<span class="operator">-</span><span class="built_in">COUNT</span>(salary)<span class="operator">&lt;&gt;</span><span class="number">0</span>,<span class="string">&#x27;不相等&#x27;</span>,<span class="string">&#x27;相等&#x27;</span>) </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span>和<span class="keyword">distinct</span>搭配</span><br><span class="line">#查看有几种工资</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> salary) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#<span class="number">5.</span>count函数的详细介绍</span><br><span class="line">#统计表的行数（不忽略<span class="keyword">null</span>值）</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> employees;	#除了<span class="number">1</span>可以是任意常量值</span><br><span class="line"></span><br><span class="line">#<span class="number">6.</span>和分组函数一同查询的字段要求是<span class="keyword">group</span> <span class="keyword">by</span>后的字段</span><br></pre></td></tr></table></figure>

<p>​        </p>
<h3 id="6-分组查询"><a href="#6-分组查询" class="headerlink" title="6.分组查询"></a>6.分组查询</h3><ul>
<li><p>语法：<font color="red">select column,group_function(column)</font><br> <font color="red">from table</font></p>
<pre><code>       &lt;font color=&#39;red&#39;&gt; [where condition]&lt;/font&gt;
        &lt;font color=&#39;red&#39;&gt;[group by group_by_expression]&lt;/font&gt;
        &lt;font color=&#39;red&#39;&gt;[order by column]&lt;/font&gt;
        &lt;font color=&#39;red&#39;&gt;[having condition]&lt;/font&gt; 
</code></pre>
</li>
<li><p>tip:</p>
<ul>
<li>查询列表比较特殊，要求是分组函数和group by后出现的字段(每个…)；</li>
<li>先按照where筛选条件进行分组，然后根据分组函数查询对应的值,最后进行having筛选</li>
</ul>
</li>
<li><p>简单的分组查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询每个部门的平均工资</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) 平均工资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(salary) <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询每个工种的最高工资</span><br><span class="line"><span class="keyword">SELECT</span> job_id,<span class="built_in">MAX</span>(salary) 最高工资</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"></span><br><span class="line">#案例<span class="number">3</span>：查询每个位置上的部门个数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),location_id</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> location_id</span><br></pre></td></tr></table></figure>

<p>​        </p>
</li>
<li><p>where筛选条件：先where筛选再分组，where筛选是在未分组的原始表上进行的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#案例1：查询邮箱中包含a字符，每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE email LIKE &#x27;%a%&#x27;</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">#案例2：查询每个领导手下有奖金的员工的最高工资</span><br><span class="line">SELECT MAX(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager_id;</span><br></pre></td></tr></table></figure></li>
<li><p>having筛选条件：先查询在having筛选，having筛选是在查询结果集上进行的    </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询哪个部门的员工个数大于<span class="number">2</span></span><br><span class="line">#错误写法：<span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span>是筛选的整个原始表</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) 员工个数</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line">#正确写法：（<span class="number">1</span>）先分组查询每个部门的员工个数；（<span class="number">2</span>）根据结果再过滤查询员工个数大于<span class="number">2</span>的部门</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) 员工个数</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>混合筛选条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#案例<span class="number">1</span>：查询每个工种&quot;有奖金的&quot;员工的&quot;最高工资&gt;12000的&quot;工种编号和最高工资</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">筛选条件1：有奖金的</span></span><br><span class="line"><span class="comment">筛选条件2：最高工资&gt;12000</span></span><br><span class="line"><span class="comment">分组条件：每个工种</span></span><br><span class="line"><span class="comment">思路：先筛选出有奖金的项，按照工种分组，查询出每个分组的最高工资和工种编号，最后从结果集筛选出最高工资大于12000的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> job_id,<span class="built_in">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span><span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line">#案例<span class="number">2</span>：查询“领导编号<span class="operator">&gt;</span><span class="number">102</span>的“每个领导手下的”最低工资<span class="operator">&gt;</span><span class="number">5000</span>的“领导编号以及最低工资</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">筛选条件1：领导编号&gt;102</span></span><br><span class="line"><span class="comment">筛选条件2：最低工资&gt;5000</span></span><br><span class="line"><span class="comment">分组条件：每个领导</span></span><br><span class="line"><span class="comment">思路：先筛选领导编号&gt;102的项，按照领导编号分组，查询出领导编号和最低工资，最后从结果集筛选出最低工资&lt;5000的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> manager_id,<span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id<span class="operator">&gt;</span><span class="number">102</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary)<span class="operator">&gt;</span><span class="number">5000</span>；</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-连接查询"><a href="#7-连接查询" class="headerlink" title="7.连接查询"></a>7.连接查询</h3><h3 id="8-子查询"><a href="#8-子查询" class="headerlink" title="8.子查询"></a>8.子查询</h3><h3 id="9-分页查询"><a href="#9-分页查询" class="headerlink" title="9.分页查询"></a>9.分页查询</h3><h3 id="10-union联合查询"><a href="#10-union联合查询" class="headerlink" title="10.union联合查询"></a>10.union联合查询</h3>]]></content>
      <categories>
        <category>《MySQL》</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="第一章-Linux的目录结构"><a href="#第一章-Linux的目录结构" class="headerlink" title="第一章 Linux的目录结构"></a>第一章 Linux的目录结构</h3><h4 id="1-1-基本介绍"><a href="#1-1-基本介绍" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h4><ul>
<li><p>在 Linux 世界里，<font color="orange">一切皆文件</font></p>
</li>
<li><p>linux 的文件系统是采用级层式的<font color="orange">树状目录结构</font>，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。</p>
</li>
<li><p>结构图：</p>
<p><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="img"></p>
<p><img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210720151643657.png" alt="image-20210720151643657"></p>
</li>
</ul>
<h4 id="1-2-目录介绍"><a href="#1-2-目录介绍" class="headerlink" title="1.2 目录介绍"></a>1.2 目录介绍</h4><ul>
<li><p><strong>/bin</strong>：(usr/bin)<font color="red">[重点]</font><br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最<font color="orange">经常使用的命令</font>。</p>
</li>
<li><p><strong>/boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些<font color="orange">链接文件</font>以及<a href="https://zhidao.baidu.com/question/383464901.html">镜像文件</a>。</p>
</li>
<li><p><strong>/dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的(一切皆是文件)。</p>
</li>
<li><p><strong>/etc：</strong><font color="red">[重点]</font><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的<font color="orange">系统管理</font>所需要的配置文件和子目录。</p>
</li>
<li><p><strong>/home</strong>：<font color="red">[重点]</font><br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p>
</li>
<li><p><strong>/lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的<font color="orange">动态连接共享库</font>，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库</p>
</li>
<li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><strong>/mnt</strong>：<font color="red">[重点]</font><br>系统提供该目录是为了让用户<font color="orange">临时挂载别的文件系统</font>的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><p><strong>/opt</strong>：<font color="red">[重点]</font><br>opt 是 optional(可选) 的缩写，这是给主机<font color="orange">额外安装软件</font>所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是<font color="orange">当前内核运行状态</font>的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all  </span><br></pre></td></tr></table></figure></li>
<li><p><strong>/root</strong>：<font color="red">[重点]</font><br>该目录为系统管理员，也称作超级权限者的用户主目录</p>
</li>
<li><p><strong>/run</strong>：<br>是一个临时文件系统，<font color="orange">存储系统启动以来的信息</font>。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
<li><p><strong>/sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的<font color="orange">系统管理程序</font>。</p>
</li>
<li><p><strong>/srv</strong>：<br>该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys</strong>：</p>
<p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>/usr</strong>：<br>usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，<font color="orange">用户的很多应用程序和文件</font>都放在这个目录下，类似于 windows 下的 program files 目录。</p>
<ul>
<li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/usr/local：</strong><font color="red">[重点]</font></p>
<p>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</p>
</li>
</ul>
</li>
<li><p><strong>/var</strong>：<font color="red">[重点]</font><br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>/media</strong>：<font color="red">[重点]</font><br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/selinux</strong>：<br>这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
</ul>
<h4 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h4><ol>
<li>Linux有且只有一个根目录 /</li>
<li>Linux的各个目录的内容是规划好的，不要乱放文件</li>
<li>Linux以文件形式管理我们的设备，一切皆文件</li>
<li>几个特殊目录的标识：<ul>
<li>根目录：**/ **</li>
<li>当前目录：**. or ./**</li>
<li>上一级目录：**.. or ../**</li>
<li>家目录：**~ or ~/**</li>
</ul>
</li>
</ol>
<h3 id="第二章-Linux常用命令"><a href="#第二章-Linux常用命令" class="headerlink" title="第二章 Linux常用命令"></a>第二章 Linux常用命令</h3><h4 id="2-0-通配符与命令格式"><a href="#2-0-通配符与命令格式" class="headerlink" title="2.0 通配符与命令格式"></a>2.0 通配符与命令格式</h4><h5 id="1-通配符"><a href="#1-通配符" class="headerlink" title="(1)通配符"></a>(1)通配符</h5><ul>
<li>*：匹配0或多个任意字符</li>
<li>？：匹配单个任意字符</li>
<li>[ ]：匹配一组字符中的单个，如[1-5] [a-f]</li>
</ul>
<h5 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="(2)命令格式"></a>(2)命令格式</h5><p>​    命令格式 ：命令 [-选项] [参数] </p>
<p>​    例 ： ls -la /etc </p>
<p>​    说明：1）个别命令使用不遵循此格式</p>
<p>​               2）当有多个选项时，可以写在一起</p>
<p>​               3）简化选项与完整选项-a 等于 –all</p>
<h4 id="2-1-文件处理命令"><a href="#2-1-文件处理命令" class="headerlink" title="2.1 文件处理命令"></a>2.1 文件处理命令</h4><h5 id="1-ls"><a href="#1-ls" class="headerlink" title="(1) ls"></a>(1) <font color="red">ls</font></h5><ul>
<li><p>命令英文原意：list </p>
</li>
<li><p>功能描述：显示目录文件</p>
</li>
<li><p>命令所在路径：/bin/ls </p>
</li>
<li><p>执行权限：所有用户</p>
</li>
<li><p>语法：ls 选项[-ald] [文件或目录] </p>
<ul>
<li><font color="orange">-a </font>（–all）显示所有文件，包括隐藏文件</li>
<li><font color="orange">-l</font> (–list) 详细信息显示（权限，所有者等）</li>
<li>-m (–format=commas) 用逗号分隔的列表显示</li>
<li>-d 查看目录属性</li>
<li>-1（–format=single-column）用单独一列的方式查看结果</li>
<li>-r (–reverse) 以反序来显示</li>
<li>-X (–sort==extension) 根据文件扩展名进行字母顺序排序</li>
<li><font color="orange">-t</font> (–sort==time) 根据日期和时间排序</li>
<li>-<font color="orange">S</font> (–sort==size) 根据文件大小排序</li>
<li><font color="orange">-h</font> (–human-readable) 用 K M G 显示文件大小</li>
<li>-R （–recursive）递归遍历目录，显示该目录及其子目录的内容</li>
<li>-F (–classify) 显示文件的类型，*代表可执行文件，/代表目录</li>
<li>–color 用不同颜色显示文件类型，绿：可执行文件，蓝：文件夹，黑：普通</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">举例：</span></span><br><span class="line">ls -al		#显示所有文件详细信息</span><br><span class="line">ls -alh		#显示所有文件详细信息（包括文件大小）</span><br><span class="line">ls -alhS	#按文件大小排序显示所有文件详细信息</span><br></pre></td></tr></table></figure>

<p>tip: 显示详细信息第一列字符 -rwxr-xr-x含义，分为四个字段- rwx r-x r-x</p>
<ul>
<li>第一个字段：- 表示二进制文件，d 表示目录，l 表示软链接文件</li>
<li>第二个字段：u所有者权限。r、w、x分别表示读、写、执行，- 表示无对应权限</li>
<li>第三个字段：g所属组权限</li>
<li>第四个字段：o其他人权限</li>
</ul>
</li>
</ul>
<h4 id="2-2-目录处理命令"><a href="#2-2-目录处理命令" class="headerlink" title="2.2 目录处理命令"></a>2.2 目录处理命令</h4><h5 id="（1）mkdir"><a href="#（1）mkdir" class="headerlink" title="（1）mkdir"></a>（1）<font color="red">mkdir</font></h5><ul>
<li><p>命令英文原意：<font color="orange">m</font>a<font color="orange">k</font>e <font color="orange">dir</font>ectories </p>
</li>
<li><p>命令所在路径：/bin/mkdir </p>
</li>
<li><p>执行权限：所有用户</p>
</li>
<li><p>语法：mkdir -p  [目录名]</p>
</li>
<li><p>功能描述：创建新目录    -p 递归创建( -p 可以递归创建 在没有一级目录的情况下新创建二级目录)</p>
</li>
<li><p>tip：创建目录 在/tmp/目录下创建临时文件 只能创建/tmp/……二级目录</p>
</li>
<li><p>范例： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p /tmp/Japan/boduo    <span class="comment">#(不存在Japan目录，所以要用-p递归创建)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir /tmp/Japan/longze /tmp/Japan/cangjing</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）rmdir"><a href="#（2）rmdir" class="headerlink" title="（2）rmdir"></a>（2）<font color="red">rmdir</font></h5><ul>
<li><p>命令英文原意：<font color="orange">r</font>emove e<font color="orange">m</font>pty <font color="orange">dir</font>ectories </p>
</li>
<li><p>命令所在路径：/bin/rmdir </p>
</li>
<li><p>执行权限：所有用户</p>
</li>
<li><p>语法：rmdir [目录名] </p>
</li>
<li><p>功能描述： 删除空目录，只能删除没有文件的空目录 （不经常使用）</p>
</li>
<li><p>范例： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rmdir /tmp/Japan/boduo</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（3）cd"><a href="#（3）cd" class="headerlink" title="（3）cd"></a>（3）<font color="red">cd</font></h5><ul>
<li><p>命令英文原意：<font color="orange">c</font>hange <font color="orange">d</font>irectory </p>
</li>
<li><p>命令所在路径：shell 内置</p>
</li>
<li><p>命令执行权限：所有用户</p>
</li>
<li><p>语法：cd [目录] </p>
</li>
<li><p>功能描述：切换目录</p>
</li>
<li><p>范例： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /tmp/Japan/boduo <span class="comment">#切换到指定目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .. <span class="comment">#回到上一级目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> / <span class="comment">#回到根目录</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（4）pwd"><a href="#（4）pwd" class="headerlink" title="（4）pwd "></a>（4）<font color="red">pwd </font></h5><ul>
<li>命令英文原意： <font color="orange">p</font>rint <font color="orange">w</font>orking <font color="orange">d</font>irectory </li>
<li>命令所在路径：/bin/pwd </li>
<li>执行权限：所有用户</li>
<li>语法：pwd </li>
<li>功能描述：显示当前目录</li>
<li>范例：$ pwd </li>
</ul>
<h5 id="（5）cp"><a href="#（5）cp" class="headerlink" title="（5）cp"></a>（5）<font color="red">cp</font></h5><ul>
<li><p>命令英文原意：<font color="orange">c</font>o<font color="orange">p</font>y </p>
</li>
<li><p>命令所在路径：/bin/cp </p>
</li>
<li><p>执行权限：所有用户</p>
</li>
<li><p>语法：cp -rp [原文件或目录] [目标目录] </p>
<ul>
<li>-r 复制目录</li>
<li>-p 保留文件属性，比如保留创建时间，日志文件的复制需要用到</li>
</ul>
</li>
<li><p>功能描述：复制文件或目录</p>
</li>
<li><p>范例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp -r /tmp/Japan/cangjing /root</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">将目录/tmp/Japan/cangjing 复制到目录/root 下</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -rp /tmp/Japan/boduo /tmp/Japan/longze /root</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">将/tmp/Japan 目录下的 boduo 和 longze 目录复制到/root 下，保持目录属性</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（6）rm"><a href="#（6）rm" class="headerlink" title="（6）rm"></a>（6）<font color="red">rm</font></h5><ul>
<li>命令英文原意：<font color="orange">r</font>e<font color="orange">m</font>ove </li>
</ul>
<ul>
<li>命令所在路径：/bin/rm </li>
</ul>
<ul>
<li>执行权限：所有用户</li>
</ul>
<ul>
<li><p>语法：rm -rf [文件或目录] </p>
<ul>
<li>-r 删除目录，一般是rm -rf 连着用</li>
<li>-f 强制执行，不在询问</li>
</ul>
</li>
<li><p>功能描述：删除文件</p>
</li>
</ul>
<ul>
<li><p>范例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm /tmp/yum.log</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">删除文件/tmp/yum.log</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf /tmp/Japan/longze</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">删除目录/tmp/Japan/longze</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-3-文件处理命令"><a href="#2-3-文件处理命令" class="headerlink" title="2.3 文件处理命令"></a>2.3 文件处理命令</h4><h5 id="1-touch"><a href="#1-touch" class="headerlink" title="(1) touch"></a>(1) <font color="red">touch</font></h5><ul>
<li><p>命令所在路径：/bin/touch </p>
</li>
<li><p>执行权限：所有用户</p>
</li>
<li><p>语法：touch [文件名] 或 touch[绝对路径+文件名]</p>
</li>
<li><p>功能描述：创建空文件</p>
</li>
<li><p>范例： $ touch Japanlovestory.list</p>
</li>
</ul>
<h5 id="2-cat"><a href="#2-cat" class="headerlink" title="(2) cat"></a>(2) <font color="red">cat</font></h5><ul>
<li><p>命令所在路径：/bin/cat </p>
</li>
<li><p>执行权限：所有用户</p>
</li>
<li><p>语法：cat [文件名] </p>
</li>
<li><p>功能描述：显示文件内容 </p>
<ul>
<li> -n 显示行号</li>
<li> -A 显示隐藏字符</li>
</ul>
</li>
<li><p>范例： </p>
<ul>
<li>$ cat /etc/issue </li>
<li>$ cat -n /etc/services</li>
</ul>
</li>
</ul>
<h5 id="3-more"><a href="#3-more" class="headerlink" title="(3) more"></a>(3) <font color="red">more</font></h5><ul>
<li><p>命令所在路径：/bin/more </p>
</li>
<li><p>执行权限：所有用户</p>
</li>
<li><p>语法：more [文件名] </p>
<ul>
<li> (空格) 或 f 翻页 </li>
<li> (Enter) 换行 </li>
<li> q 或 Q 退出</li>
</ul>
</li>
<li><p>功能描述：分页显示文件内容,合长的文件内容</p>
</li>
<li><p>范例： $ more /etc/services</p>
</li>
</ul>
<h5 id="4-less"><a href="#4-less" class="headerlink" title="(4) less"></a>(4) <font color="red">less</font></h5><ul>
<li><p>命令所在路径：/usr/bin/less 执行权限：所有用户</p>
</li>
<li><p>语法：less [文件名] </p>
</li>
<li><p>功能描述：分页显示文件内容（可向上翻页）</p>
</li>
<li><p>范例： $ less /etc/services</p>
</li>
<li><p><strong>tips: 按下 / 后可以搜索,会反显高亮 按 q 退出（more 也可以）</strong></p>
</li>
</ul>
<h5 id="5-head"><a href="#5-head" class="headerlink" title="(5) head"></a>(5) <font color="red">head</font></h5><ul>
<li><p>命令所在路径：/usr/bin/head </p>
</li>
<li><p>执行权限：所有用户</p>
</li>
<li><p>语法：head [文件名] </p>
</li>
<li><p>功能描述：显示文件前面几行 </p>
<ul>
<li>-n 指定行数</li>
</ul>
</li>
<li><p>范例： $ head -n 20 /etc/services</p>
</li>
</ul>
<h5 id="6-tail"><a href="#6-tail" class="headerlink" title="(6) tail"></a>(6) <font color="red">tail</font></h5><ul>
<li><p>命令所在路径：/usr/bin/tail </p>
</li>
<li><p>执行权限：所有用户</p>
</li>
<li><p>语法：tail [文件名] </p>
</li>
<li><p>功能描述：显示文件后面几行 </p>
<ul>
<li> -n 指定行数 </li>
<li> -f 动态显示文件末尾内容</li>
</ul>
</li>
<li><p>范例： $ tail -n 18 /etc/services</p>
</li>
</ul>
<h3 id="第十章-Shell基础"><a href="#第十章-Shell基础" class="headerlink" title="第十章 Shell基础"></a>第十章 Shell基础</h3><h4 id="10-1-Shell概述"><a href="#10-1-Shell概述" class="headerlink" title="10.1 Shell概述"></a>10.1 Shell概述</h4><ul>
<li><p>Shell是什么</p>
<ul>
<li><p>Shell是一个<font color="orange">命令行解释器</font>，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来 启动、挂起、停止甚至是编写一些程序。</p>
<img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210721142803916.png" alt="image-20210721142803916" style="zoom:50%;"></li>
<li><p>Shell还是一个功能相当强大的<font color="orange">编程语言</font>， 易编写，易调试，灵活性较强。Shell是解释执行的<font color="orange">脚本语言</font>，在Shell中可以直接调用Linux系统命令。</p>
</li>
</ul>
</li>
<li><p>Shell的分类</p>
<ul>
<li><p><font color="orange">Bourne Shell</font>:从1979起Unix就开始使用 Bourne Shell，Bourne Shell的主文件名为 sh。</p>
</li>
<li><p><font color="orange">C Shell</font>: C Shell主要在BSD版的Unix系 统中使用，其语法和C语言相类似而得名</p>
<p>Shell的两种主要语法类型有Bourne和C， 这两种语法彼此不兼容。</p>
<p>Bourne家族主要 包括sh、ksh、Bash、psh、zsh;</p>
<p>C家族主 要包括:csh、tcsh</p>
<p>Bash: Bash与sh兼容，现在使用的Linux 就是使用Bash作为<font color="orange">用户的基本Shell</font>。</p>
</li>
<li><p>Linux支持的Shell<br>/etc/shells<br>会显示：/bin/sh、/bin/bash、/sbin/nologin、/bin/tcsh、/bin/csh<br>都是Linux支持的Shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ cat /etc/shells</span><br><span class="line"><span class="meta">#</span><span class="bash"> Pathnames of valid login shells.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See shells(5) <span class="keyword">for</span> details.</span></span><br><span class="line"></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/bin/zsh</span><br><span class="line">/usr/bin/git-shell</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="10-2-Shell脚本的执行方式"><a href="#10-2-Shell脚本的执行方式" class="headerlink" title="10.2 Shell脚本的执行方式"></a>10.2 Shell脚本的执行方式</h4><h5 id="（1）echo-输出命令"><a href="#（1）echo-输出命令" class="headerlink" title="（1）echo 输出命令"></a>（1）<font color="red">echo </font>输出命令</h5><ul>
<li><p>#echo [选项] [输出内容] </p>
</li>
<li><p><font color="orange">-e</font>: 支持反斜线控制的转义字符</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">控制字符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="center">输出\本身</td>
</tr>
<tr>
<td align="center">\a</td>
<td align="center">输出警告音</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">退格键，也就是向左删除键</td>
</tr>
<tr>
<td align="center">\c</td>
<td align="center">取消输出行末的换行符。和“-n”选项一致</td>
</tr>
<tr>
<td align="center">\e</td>
<td align="center">ESCAPE键</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="center">换页符</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">换行符</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">回车键</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">制表符，也就是Tab键</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="center">垂直制表符</td>
</tr>
<tr>
<td align="center">\0nnn</td>
<td align="center">按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数</td>
</tr>
<tr>
<td align="center">\xhh</td>
<td align="center">按照十六进制ASCII码表输出字符。其中hh是两位十六进制数</td>
</tr>
</tbody></table>
<ul>
<li><p>例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">\b退格删除左侧字符$ <span class="built_in">echo</span> -e <span class="string">&#x27;ab\bc&#x27;</span>ac<span class="comment">#\t制表符 \n换行符$ echo -e &#x27;a\tb\tc\nd\te\tf&#x27;a	b	cd	e	f#\x按照十六进制ASCII码表输出字符$ echo -e &#x27;\x61\t\x62\t\x63&#x27;a	b	c$ echo -e &#x27;\e[1;31m abcd \e[0m&#x27; abcd #因为\e[1; 表示开启颜色区别 \e[0m 表示结束颜色区别 31m表示红色 还有其他：#30m=黑色，31m=红色，32m=绿色，33m=黄色，34m=蓝色，35m=洋红，36m=青色，#37m=白色</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）第一个脚本"><a href="#（2）第一个脚本" class="headerlink" title="（2）第一个脚本"></a>（2）第一个脚本</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~$ ls公共  模板  视频  图片  文档  下载  音乐  桌面$ <span class="built_in">cd</span> 文档$ ls$ mkdir 脚本练习$ <span class="built_in">cd</span> 脚本练习$ vim hello.sh$ sh hello.shWelcome to linux world!hhh</span></span><br></pre></td></tr></table></figure>


<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash#This is my first program#Author:zlxecho -e &#x27;Welcome to linux world!\nhhh&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意：在这一段脚本中，#!/bin/Bash这一句是个例外，他并不是注释，是标识，说明以下语句是Shell脚本，解释器是/bin/bash</p>
<h5 id="（5）执行脚本"><a href="#（5）执行脚本" class="headerlink" title="（5）执行脚本"></a>（5）执行脚本</h5><ul>
<li><p>赋予执行权限，直接运行</p>
<ul>
<li>chmod 755 hello.sh</li>
<li>./hello.sh</li>
</ul>
</li>
<li><p>通过Bash调用执行脚本</p>
<ul>
<li>bash hello.sh</li>
<li>或 sh hello.sh  (不需要执行权限就可以执行)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform 脚本练习]$ ./hello.shbash: ./hello.sh: 权限不够[zlx@zlx-vmwarevirtualplatform 脚本练习]$ chmod 755 hello.sh[zlx@zlx-vmwarevirtualplatform 脚本练习]$ ./hello.shWelcome to linux world!hh[zlx@zlx-vmwarevirtualplatform 脚本练习]$ sh hello.shWelcome to linux world!hh</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="10-3-Bash的基本功能"><a href="#10-3-Bash的基本功能" class="headerlink" title="10.3 Bash的基本功能"></a>10.3 Bash的基本功能</h4><h5 id="（1）-历史命令history与命令补全"><a href="#（1）-历史命令history与命令补全" class="headerlink" title="（1） 历史命令history与命令补全"></a>（1） 历史命令<font color="red">history</font>与命令补全</h5><ul>
<li><p><strong>历史命令</strong></p>
<ul>
<li><p>history [选项] [历史命令保存文件] </p>
</li>
<li><p>选项： </p>
<ul>
<li><p>-c： 清空历史命令 </p>
</li>
<li><p>-w： 把缓存中的历史命令写入历史命令保存文件 <font color="orange">~/.bash_history </font></p>
<p>历史命令默认会保存 1000 条,可以在环境变量配置文件/etc/profile 中进行修改</p>
</li>
</ul>
</li>
<li><p>历史命令的调用</p>
<ul>
<li><p>使用<font color="orange">上、下箭头</font>调用以前的历史命令</p>
</li>
<li><p>使用“<font color="orange">!n</font>”重复执行第 n 条历史命令</p>
</li>
<li><p>使用“<font color="orange">!!</font>”重复执行上一条命令</p>
</li>
<li><p>使用“<font color="orange">!字串</font>”重复执行最后一条以该字串开头的命令 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ ls公共  模板  视频  图片  文档  下载  音乐  桌面[zlx@zlx-vmwarevirtualplatform ~]$ !!ls公共  模板  视频  图片  文档  下载  音乐  桌面[zlx@zlx-vmwarevirtualplatform ~]$ !lls公共  模板  视频  图片  文档  下载  音乐  桌面</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>命令与文件补全</strong><ul>
<li> 在 Bash 中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或文件时，按“Tab”键就会自动进行补全</li>
</ul>
</li>
</ul>
<h5 id="（2）命令别名alias与常用快捷键"><a href="#（2）命令别名alias与常用快捷键" class="headerlink" title="（2）命令别名alias与常用快捷键"></a>（2）命令别名<font color="red">alias</font>与常用快捷键</h5><ul>
<li><p><strong>命令别名</strong></p>
<ul>
<li>alias 别名=’原命令’         #设定命令别名 </li>
<li>alias        #查询命令别名 </li>
</ul>
</li>
<li><p><strong>命令执行时顺序</strong></p>
<ul>
<li>1 第一顺位执行用<font color="orange">绝对路径或相对路径</font>执行的命令。</li>
<li>2 第二顺位执行<font color="orange">别名</font>。</li>
<li>3 第三顺位执行 <font color="orange">Bash</font>font&gt; 的内部命令。</li>
<li>4 第四顺位执行按照<font color="orange">$PATH 环境变量定义的目录查找顺序</font>找到的第一个命令。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ alias vi=&#x27;vim&#x27;[zlx@zlx-vmwarevirtualplatform ~]$ aliasalias cp=&#x27;cp -i&#x27;alias df=&#x27;df -h&#x27;alias egrep=&#x27;egrep --colour=auto&#x27;alias fgrep=&#x27;fgrep --colour=auto&#x27;alias free=&#x27;free -m&#x27;alias grep=&#x27;grep --colour=auto&#x27;alias home=&#x27;cd ~&#x27;alias ls=&#x27;ls --color=auto&#x27;alias more=&#x27;less&#x27;alias np=&#x27;nano -w PKGBUILD&#x27;alias vi=&#x27;vim&#x27;#再执行vi时不会调用PATH目录中命令，因为别名的优先级比PATH高#输出系统环境变量定义的目录[zlx@zlx-vmwarevirtualplatform ~]$ echo $PATH/home/zlx/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/var/lib/snapd/snap/bin#查询某条命令所在目录[zlx@zlx-vmwarevirtualplatform ~]$ whereis lsls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz[zlx@zlx-vmwarevirtualplatform ~]$ whereis vivi: /usr/bin/vi /usr/share/man/man1/vi.1.gz /usr/share/man/man1p/vi.1p.gz[zlx@zlx-vmwarevirtualplatform ~]$ whereis vimvim: /usr/bin/vim /usr/share/vim /usr/share/man/man1/vim.1.gz</span><br></pre></td></tr></table></figure></li>
<li><p><strong>让别名永久生效</strong></p>
<ul>
<li>vim /root/.bashrc</li>
</ul>
</li>
<li><p><strong>删除别名</strong></p>
<ul>
<li>unalias 别名</li>
</ul>
</li>
<li><p><strong>Bash 常用快捷键</strong></p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font color="cornflowerblue">ctrl+a</font></td>
<td align="center">把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移 动到命令行开头时使用。</td>
</tr>
<tr>
<td align="center"><font color="cornflowerblue">ctrl+e</font></td>
<td align="center">把光标移动到命令行结尾。</td>
</tr>
<tr>
<td align="center"><font color="cornflowerblue">ctrl+c</font></td>
<td align="center">强制终止当前的命令。</td>
</tr>
<tr>
<td align="center"><font color="cornflowerblue">ctrl+l</font></td>
<td align="center">清屏，相当于clear命令。</td>
</tr>
<tr>
<td align="center"><font color="cornflowerblue">ctrl+u</font></td>
<td align="center">删除或<font color="red">剪切</font>光标之<font color="red">前</font>的命令。我输入了一行很长的命令，不用使用退 格键一个一个字符的删除，使用这个快捷键会更加方便</td>
</tr>
<tr>
<td align="center">ctrl+k</td>
<td align="center">删除或剪切光标之<font color="red">后</font>的内容。</td>
</tr>
<tr>
<td align="center"><font color="cornflowerblue">ctrl+y</font></td>
<td align="center"><font color="red">粘贴</font> ctrl+U或ctrl+K剪切的内容。</td>
</tr>
<tr>
<td align="center"><font color="cornflowerblue">ctrl+r</font></td>
<td align="center">在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入 搜索内容，就会从历史命令中搜索。</td>
</tr>
<tr>
<td align="center"><font color="cornflowerblue">ctrl+d</font></td>
<td align="center">退出当前终端。</td>
</tr>
<tr>
<td align="center">ctrl+z</td>
<td align="center">暂停，并放入后台。这个快捷键牵扯工作管理的内容，我们在系统管 理章节详细介绍。</td>
</tr>
<tr>
<td align="center">ctrl+s</td>
<td align="center">暂停屏幕输出。</td>
</tr>
<tr>
<td align="center">ctrl+q</td>
<td align="center">恢复屏幕输出。</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="（3）输入输出重定向"><a href="#（3）输入输出重定向" class="headerlink" title="（3）输入输出重定向"></a>（3）输入输出重定向</h5><ul>
<li><p><strong>标准输入输出</strong></p>
<img src="/2021/07/20/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210722132956166.png" alt="image-20210722132956166" style="zoom:50%;"></li>
<li><p><strong><font color="red">输出重定向&gt;&gt;</font></strong></p>
<p>就是改变输出方向，比如由屏幕输出到文件，非常有用</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>标准输出重定向</td>
<td>命令 &gt; 文件</td>
<td>以<font color="red">覆盖</font>的方式，把命令的正确输出输出到指定的文件或设备当中。</td>
</tr>
<tr>
<td>标准输出重定向</td>
<td>命令 &gt;&gt; 文件</td>
<td>以<font color="red">追加</font>的方式，把命令的正确输出输出到指定的文 件或设备当中。</td>
</tr>
<tr>
<td>标准错误输出重定向</td>
<td>错误命令 2&gt;文件</td>
<td>以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。</td>
</tr>
<tr>
<td>标准错误输出重定向</td>
<td>错误命令 2&gt;&gt;文件</td>
<td>以追加的方式，把命令的错误输出输出到指定的文件或设备当中。</td>
</tr>
</tbody></table>
<p>tip:在输入报错文件中 2和&gt;&gt;必选<font color="red">连着写</font>,标准错误输出不常用</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>正确输出和错误输出同时保存</td>
<td>命令 &gt; 文件 2&gt;&amp;1</td>
<td>以覆盖的方式，把正确输出和错误输出都保存到同 一个文件当中。</td>
</tr>
<tr>
<td>正确输出和错误输出同时保存</td>
<td>命令 &gt;&gt; 文件 2&gt;&amp;1</td>
<td>以追加的方式，把正确输出和错误输出都保存到同 一个文件当中。</td>
</tr>
<tr>
<td>正确输出和错误输出同时保存</td>
<td>命令 &amp;&gt; 文件</td>
<td>以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中</td>
</tr>
<tr>
<td>正确输出和错误输出同时保存</td>
<td>命令 &amp;&gt;&gt; 文件</td>
<td>以追加的方式，把正确输出和错误输出都保存到同一个文件当中。</td>
</tr>
<tr>
<td>正确输出和错误输出同时保存</td>
<td>命令 &gt;&gt; 文件1 2&gt;&gt;文件2</td>
<td>把正确的输出追加到文件1中，把错误的输出追加到文件2中。</td>
</tr>
</tbody></table>
<p>tip:命令 &gt;&gt; 文件 2&gt;&amp;1 ，命令 &amp;&gt;&gt;文件 两种保存都一样，只不过是格式不同<br>有一个用法：<br>命令 &amp;&gt;/dev/unll 不管命令是否正确，直接丢人这个文件夹，不保存任何数据，在写shell脚本时有用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ ls &gt;&gt; ./文档/cdx</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ cat ./文档/cdx</span><br><span class="line">公共</span><br><span class="line">模板</span><br><span class="line">视频</span><br><span class="line">图片</span><br><span class="line">文档</span><br><span class="line">下载</span><br><span class="line">音乐</span><br><span class="line">桌面</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ lst</span><br><span class="line">bash: lst：未找到命令</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ lst 2&gt;&gt; ./文档/cdx</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ cat ./文档/cdx</span><br><span class="line">公共</span><br><span class="line">模板</span><br><span class="line">视频</span><br><span class="line">图片</span><br><span class="line">文档</span><br><span class="line">下载</span><br><span class="line">音乐</span><br><span class="line">桌面</span><br><span class="line">bash: lst：未找到命令</span><br><span class="line"></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ ls &amp;&gt;&gt; ./文档/cdx1</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ lst &amp;&gt;&gt; ./文档/cdx1</span><br><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ cat ./文档/cdx1</span><br><span class="line">公共</span><br><span class="line">模板</span><br><span class="line">视频</span><br><span class="line">图片</span><br><span class="line">文档</span><br><span class="line">下载</span><br><span class="line">音乐</span><br><span class="line">桌面</span><br><span class="line">bash: lst：未找到命令</span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color="red">输入重定向WC</font></strong></p>
<p>不通过键盘输入，通过文件输入，在实际中用的不多，用在给源码包打补丁</p>
<ul>
<li><p>wc [选项] [文件名] :统计某个文件输入的行数、单词数、字节数</p>
</li>
<li><p>选项</p>
<ul>
<li>-c 统计字节数</li>
<li>-w 统计单词数</li>
<li>-l 统计行数</li>
</ul>
</li>
<li><p>用法：<br>命令 <font color="red">&lt; 文件</font> ：把文件作为命令的输入<br>命令<font color="red"> &lt;&lt; 标识符 内容  标识符</font>：把标识符之间内容作为命令的输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">统计行数、单词数、字符数</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ wc</span><br><span class="line">jdign ing</span><br><span class="line">jgidn ingd </span><br><span class="line">jiiji</span><br><span class="line">jis9e      3       6      33</span><br><span class="line"><span class="meta">#</span><span class="bash">统计输入文件</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ wc &lt; ./文档/cdx</span><br><span class="line"> 9 10 84</span><br><span class="line"><span class="meta">#</span><span class="bash">统计输入文件行数</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ wc -l &lt; ./文档/cdx</span><br><span class="line">9</span><br><span class="line"><span class="meta">#</span><span class="bash">以quit为标识符，统计内容</span></span><br><span class="line">[zlx@zlx-vmwarevirtualplatform ~]$ wc &lt;&lt; quit</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> jdig</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> jidigj jidg</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> jig</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> quit</span></span><br><span class="line">      3       4      21</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="10-4-Bash的变量"><a href="#10-4-Bash的变量" class="headerlink" title="10.4 Bash的变量"></a>10.4 Bash的变量</h4><h4 id="10-5-Bash的运算符-1"><a href="#10-5-Bash的运算符-1" class="headerlink" title="10.5 Bash的运算符-1"></a>10.5 Bash的运算符-1</h4><h4 id="10-6-Bash的运算符-2"><a href="#10-6-Bash的运算符-2" class="headerlink" title="10.6 Bash的运算符-2"></a>10.6 Bash的运算符-2</h4>]]></content>
      <categories>
        <category>《Linux》</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习笔记</title>
    <url>/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="Go语言概述"><a href="#Go语言概述" class="headerlink" title="Go语言概述"></a>Go语言概述</h3><h4 id="1-Go语言简介"><a href="#1-Go语言简介" class="headerlink" title="1.Go语言简介"></a>1.Go语言简介</h4><ul>
<li><p>Go 是一个开源的编程语言，它能让<font color="cornflowerblue">构造简单、可靠且高效的软件</font>font&gt;变得容易。</p>
</li>
<li><p>Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。</p>
</li>
</ul>
<h4 id="2-Go语言特色"><a href="#2-Go语言特色" class="headerlink" title="2.Go语言特色"></a>2.Go语言特色</h4><ul>
<li>简洁、快速、安全</li>
<li>并行、有趣、开源</li>
<li>内存管理、v数组安全、编译迅速</li>
</ul>
<h4 id="3-Go-语言用途"><a href="#3-Go-语言用途" class="headerlink" title="3.Go 语言用途"></a>3.Go 语言用途</h4><ul>
<li><p>Go 语言被设计成一门应用于搭载 <font color="cornflowerblue">Web 服务器</font>，<font color="cornflowerblue">存储集群</font>或类似用途的<font color="cornflowerblue">巨型中央服务器</font>的系统编程语言。</p>
</li>
<li><p>对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了<font color="cornflowerblue">海量并行的支持</font>，这对于游戏服务端的开发而言是再好不过了。</p>
</li>
</ul>
<h3 id="Go语言结构"><a href="#Go语言结构" class="headerlink" title="Go语言结构"></a>Go语言结构</h3><h4 id="1-Hello-World-实例"><a href="#1-Hello-World-实例" class="headerlink" title="1.Hello World 实例"></a>1.Hello World 实例</h4><p>（1）Go 语言的基础组成有以下几个部分：</p>
<ul>
<li>包声明</li>
<li>引入包</li>
<li>函数</li>
<li>变量</li>
<li>语句 &amp; 表达式</li>
<li>注释</li>
</ul>
<p>（2）接下来让我们来看下简单的代码，该代码输出了”Hello World!”:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 这是我的第一个简单的程序 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）让我们来看下以上程序的各个部分：</p>
<ol>
<li><em>package main</em> 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</li>
<li><em>import “fmt”</em> 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），<font color="red">fmt 包实现了格式化 IO（输入/输出）的函数</font>。</li>
<li>下一行 <em>func main()</em> 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</li>
<li>/<em>…</em>/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li>
<li><em>fmt.Println(…)</em> 可以将字符串输出到控制台，并在最后自动增加换行字符 \n。<br>使用 fmt.Print(“hello, world\n”) 可以得到相同的结果。<br>Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</li>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个<font color="red">大写字母开头</font>，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 <font color="red">public</font>）；标识符如果<font color="red">以小写字母开头</font>，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 <font color="red">private</font> ）。</li>
</ol>
<h4 id="2-执行-Go-程序"><a href="#2-执行-Go-程序" class="headerlink" title="2.执行 Go 程序"></a>2.执行 Go 程序</h4><p>（1）让我们来看下如何编写 Go 代码并执行它。步骤如下：</p>
<ul>
<li>打开编辑器如Sublime2，将以上代码添加到编辑器中。</li>
<li>将以上代码保存为 <em>hello.go</em></li>
<li>打开命令行，并进入程序文件保存的目录中。</li>
<li>输入命令 <em>go run hello.go</em> 并按回车执行代码。</li>
</ul>
<p>（2）如果操作正确你将在屏幕上看到 <em>“Hello World!”</em> 字样的输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run hello.<span class="keyword">go</span></span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>



<h3 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h3><h4 id="1-行分隔符"><a href="#1-行分隔符" class="headerlink" title="1.行分隔符"></a>1.行分隔符</h4><ul>
<li><p>在 Go 程序中，<font color="red">一行代表一个语句结束</font>。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。</p>
</li>
<li><p>如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。</p>
</li>
</ul>
<h4 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h4><ul>
<li><p>注释不会被编译，每一个包应该有相关注释。</p>
</li>
<li><p>单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。如：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Author by w3cschoolW3Cschool教程</span></span><br><span class="line"><span class="comment"> 我是多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h4 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3.关键字"></a>3.关键字</h4><p>（1）下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p>
<table>
<thead>
<tr>
<th>break</th>
<th>default</th>
<th>func</th>
<th>interface</th>
<th>select</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td>defer</td>
<td>go</td>
<td>map</td>
<td>struct</td>
</tr>
<tr>
<td>chan</td>
<td>else</td>
<td>goto</td>
<td>package</td>
<td>switch</td>
</tr>
<tr>
<td>const</td>
<td>fallthrough</td>
<td>if</td>
<td>range</td>
<td>type</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>import</td>
<td>return</td>
<td>var</td>
</tr>
</tbody></table>
<p>（2）除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：</p>
<table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody><tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody></table>
<h3 id="Go语言数据类型"><a href="#Go语言数据类型" class="headerlink" title="Go语言数据类型"></a>Go语言数据类型</h3><h4 id="1-Go-语言数据类型"><a href="#1-Go-语言数据类型" class="headerlink" title="1.Go 语言数据类型"></a>1.Go 语言数据类型</h4><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>数字类型</strong> 整型 int 和浮点型 float，Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) 联合体类型 (union)(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型(i) Channel 类型</td>
</tr>
</tbody></table>
<h4 id="2-数字类型"><a href="#2-数字类型" class="headerlink" title="2.数字类型"></a>2.数字类型</h4><ul>
<li>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<ul>
<li>浮点型：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>float32</strong> IEEE-754 32位浮点型数</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>float64</strong> IEEE-754 64位浮点型数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>complex64</strong> 32 位实数和虚数</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>complex128</strong> 64 位实数和虚数</td>
</tr>
</tbody></table>
<h4 id="3-其他数字类型"><a href="#3-其他数字类型" class="headerlink" title="3.其他数字类型"></a>3.其他数字类型</h4><p>以下列出了其他更多的数字类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>byte</strong> 类似 uint8</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>rune</strong> 类似 int32</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>uint</strong> 32 或 64 位</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>int</strong> 与 uint 一样大小</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>uintptr</strong> 无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<h3 id="Go语言变量"><a href="#Go语言变量" class="headerlink" title="Go语言变量"></a>Go语言变量</h3><h4 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1.变量声明"></a>1.变量声明</h4><p>（1）第一种，指定变量类型，先声明后赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var v_name v_type</span></span><br><span class="line"><span class="comment">//v_name = value</span></span><br></pre></td></tr></table></figure>

<p>（2）第二种，根据值自行判定变量类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var v_name = value</span></span><br></pre></td></tr></table></figure>

<p>（3）第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v_name := value</span></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">c : = <span class="number">10</span></span><br></pre></td></tr></table></figure>



<h4 id="2-多变量声明"><a href="#2-多变量声明" class="headerlink" title="2.多变量声明"></a>2.多变量声明</h4><p>（1）类型相同多个变量, 非全局变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">//和python很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">//出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）类型不同的多个变量，全局变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>（3）实例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">b = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">c := <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d, e, f <span class="keyword">int</span></span><br><span class="line">d, e, f = <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span></span><br><span class="line"></span><br><span class="line">g, h, i := <span class="number">18</span>, <span class="number">19</span>, “work”</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    j <span class="keyword">int</span></span><br><span class="line">    k <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">j = <span class="number">21</span></span><br><span class="line">k = <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="3-值类型和引用类型"><a href="#3-值类型和引用类型" class="headerlink" title="3.值类型和引用类型"></a>3.值类型和引用类型</h4><p>（1）所有像 int、float、bool 和 string 这些基本类型都属于<font color="red">值类型</font>，使用这些类型的变量直接指向存在内存中的值：</p>
<p><img src="/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/201611202341534498.png" alt="img"></p>
<p>当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，如：<code>j = i</code>，实际上是在内存中将 i 的值进行了拷贝：</p>
<p><img src="/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/201611202342229643.png" alt="img"></p>
<p>你可以通过 &amp;i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。</p>
<p>内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。</p>
<p>（2）更复杂的数据通常会需要使用多个字，这些数据一般使用<font color="red">引用类型</font>保存。</p>
<p>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</p>
<p><img src="/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/201611202342474583.png" alt="img"></p>
<p>这个内存地址为称之为指针，这个指针实际上也被存在另外的某一个字中。</p>
<p>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。</p>
<p>当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。</p>
<p>如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</p>
<h3 id="Go语言常量"><a href="#Go语言常量" class="headerlink" title="Go语言常量"></a>Go语言常量</h3><h4 id="1-常量的定义格式"><a href="#1-常量的定义格式" class="headerlink" title="1.常量的定义格式"></a>1.常量的定义格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const identifier [type] = value</span><br></pre></td></tr></table></figure>

<p>（1）你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p>
<ul>
<li>显式类型定义： <code>const b string = &quot;abc&quot;</code></li>
<li>隐式类型定义： <code>const b = &quot;abc&quot;</code></li>
</ul>
<p>（2）多个相同类型的声明可以简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const c_name1, c_name2 = value1, value2</span><br></pre></td></tr></table></figure>



<h4 id="2-iota"><a href="#2-iota" class="headerlink" title="2.iota"></a>2.iota</h4><p>（1）iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p>
<p>（2）在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。</p>
<p>（4）iota 可以被用作枚举值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>（5）iota 用法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> ha ha <span class="number">100</span> <span class="number">100</span> <span class="number">7</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言运算符"><a href="#Go语言运算符" class="headerlink" title="Go语言运算符"></a>Go语言运算符</h3><p>略</p>
<h3 id="Go语言条件语句"><a href="#Go语言条件语句" class="headerlink" title="Go语言条件语句"></a>Go语言条件语句</h3><p>Go 语言提供了以下几种条件判断语句：</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-if-statement.html">if 语句</a></td>
<td align="left"><strong>if 语句</strong> 由一个布尔表达式后紧跟一个或多个语句组成。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-if-else-statement.html">if…else 语句</a></td>
<td align="left"><strong>if 语句</strong> 后可以使用可选的 <strong>else 语句</strong>, else 语句中的表达式在布尔表达式为 false 时执行。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-nested-if-statements.html">if 嵌套语句</a></td>
<td align="left">你可以在 <strong>if</strong> 或 <strong>else if</strong> 语句中嵌入一个或多个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-switch-statement.html">switch 语句</a></td>
<td align="left"><strong>switch</strong> 语句用于基于不同条件执行不同动作。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-select-statement.html">select 语句</a></td>
<td align="left"><strong>select</strong> 语句类似于 <strong>switch</strong> 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</td>
</tr>
</tbody></table>
<h4 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;   <span class="comment">/* 在布尔表达式为 true 时执行 */</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-if…else语句"><a href="#2-if…else语句" class="headerlink" title="2.if…else语句"></a>2.if…else语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;   <span class="comment">/* 在布尔表达式为 true 时执行 */</span>&#125; <span class="keyword">else</span> &#123;  <span class="comment">/* 在布尔表达式为 false 时执行 */</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-if嵌套语句"><a href="#3-if嵌套语句" class="headerlink" title="3.if嵌套语句"></a>3.if嵌套语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 <span class="number">1</span> &#123;   <span class="comment">/* 在布尔表达式 1 为 true 时执行 */</span>   <span class="keyword">if</span> 布尔表达式 <span class="number">2</span> &#123;      <span class="comment">/* 在布尔表达式 2 为 true 时执行 */</span>   &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4.switch语句"></a>4.switch语句</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;    <span class="keyword">case</span> val1:        ...    <span class="keyword">case</span> val2:        ...    <span class="keyword">default</span>:        ...&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-select语句"><a href="#5-select语句" class="headerlink" title="5.select语句"></a>5.select语句</h4><p><a href="https://blog.csdn.net/zhonglinzhang/article/details/45913443">参考：select用法</a></p>
<p>（1）select是Go中的一个控制结构，类似于用于通信的switch语句。<font color="red">每个case必须是一个通信操作</font>，要么是发送要么是接收。</p>
<p><strong>select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。</strong></p>
<p>（2）语法</p>
<p>Go 编程语言中 select 语句的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &#123;    case communication clause  :       statement(s);          case communication clause  :       statement(s);     /* 你可以定义任意数量的 case */    default : /* 可选 */       statement(s);&#125;</span><br></pre></td></tr></table></figure>

<p>以下描述了 select 语句的语法：</p>
<ul>
<li><p>每个case都必须是一个通信</p>
</li>
<li><p>所有channel表达式都会被求值</p>
</li>
<li><p>所有被发送的表达式都会被求值</p>
</li>
<li><p>如果任意某个通信可以进行，它就执行；其他被忽略。</p>
</li>
<li><p>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。</p>
<p>否则：</p>
<ol>
<li>如果有default子句，则执行该语句。</li>
<li>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</li>
</ol>
</li>
</ul>
<p>（3）实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var c1, c2, c3 chan int</span><br><span class="line">   var i1, i2 int</span><br><span class="line">   select &#123;</span><br><span class="line">      case i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(&quot;received &quot;, i1, &quot; from c1\n&quot;)</span><br><span class="line">      case c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\n&quot;)</span><br><span class="line">      case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3</span><br><span class="line">         if ok &#123;</span><br><span class="line">            fmt.Printf(&quot;received &quot;, i3, &quot; from c3\n&quot;)</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            fmt.Printf(&quot;c3 is closed\n&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">      default:</span><br><span class="line">         fmt.Printf(&quot;no communication\n&quot;)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no communication</span><br></pre></td></tr></table></figure>



<h3 id="GO语言循环语句"><a href="#GO语言循环语句" class="headerlink" title="GO语言循环语句"></a>GO语言循环语句</h3><h4 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1.for循环"></a>1.for循环</h4><p>（1）和 C 语言的 for 一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for init; condition; post &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>（2）和 C 的 while 一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for condition &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>（3）和 C 的 for(;;) 一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for &#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>init： 一般为赋值表达式，给控制变量赋初值；</li>
<li>condition： 关系表达式或逻辑表达式，循环控制条件；</li>
<li>post： 一般为赋值表达式，给控制变量增量或减量。</li>
</ul>
<p>（3）for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for key, value := range oldMap &#123;    newMap[key] = value&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">15</span>   <span class="keyword">var</span> a <span class="keyword">int</span>   numbers := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;    <span class="comment">/* for 循环 */</span>   <span class="keyword">for</span> a := <span class="number">0</span>; a &lt; <span class="number">10</span>; a++ &#123;      fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)   &#125;   <span class="keyword">for</span> a &lt; b &#123;      a++      fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)      &#125;   <span class="keyword">for</span> i,x:= <span class="keyword">range</span> numbers &#123;      fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i,x)   &#125;   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-循环嵌套"><a href="#2-循环嵌套" class="headerlink" title="2.循环嵌套"></a>2.循环嵌套</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for [condition |  ( init; condition; increment ) | Range]&#123;   for [condition |  ( init; condition; increment ) | Range]   &#123;      statement(s);   &#125;   statement(s);&#125;</span><br></pre></td></tr></table></figure>

<p>实例:</p>
<p>以下实例使用循环嵌套来输出 2 到 100 间的素数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   <span class="comment">/* 定义局部变量 */</span>   <span class="keyword">var</span> i, j <span class="keyword">int</span>   <span class="keyword">for</span> i=<span class="number">2</span>; i &lt; <span class="number">100</span>; i++ &#123;      <span class="keyword">for</span> j=<span class="number">2</span>; j &lt;= (i/j); j++ &#123;         <span class="keyword">if</span>(i%j==<span class="number">0</span>) &#123;            <span class="keyword">break</span>; <span class="comment">// 如果发现因子，则不是素数         &#125;      &#125;      if(j &gt; (i/j)) &#123;         fmt.Printf(&quot;%d  是素数\n&quot;, i);      &#125;   &#125;  &#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="3-循环控制语句"><a href="#3-循环控制语句" class="headerlink" title="3.循环控制语句"></a>3.循环控制语句</h4><p>GO 语言支持以下几种循环控制语句：</p>
<table>
<thead>
<tr>
<th align="left">控制语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-break-statement.html">break 语句</a></td>
<td align="left">经常用于中断当前 for 循环或跳出 switch 语句</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-continue-statement.html">continue 语句</a></td>
<td align="left">跳过当前循环的剩余语句，然后继续进行下一轮循环。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-goto-statement.html">goto 语句</a></td>
<td align="left">将控制转移到被标记的语句。</td>
</tr>
</tbody></table>
<h4 id="Go语言函数"><a href="#Go语言函数" class="headerlink" title="Go语言函数"></a>Go语言函数</h4><h4 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1.函数定义"></a>1.函数定义</h4><p>（1）Go 语言函数定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func function_name( [parameter list] ) [return_types]&#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）函数定义解析：</p>
<ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parameter list]：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<p>（3）实例</p>
<p>以下实例为 max() 函数的代码，该函数传入两个整型参数 num1 和 num2，并返回这两个参数的最大值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2.函数调用"></a>2.函数调用</h4><p>当创建函数时，你定义了函数需要做什么，通过调用改函数来执行指定任务。</p>
<p>调用函数，向函数传递参数，并返回值，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   <span class="comment">/* 定义局部变量 */</span>   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span>   <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span>   <span class="keyword">var</span> ret <span class="keyword">int</span>   <span class="comment">/* 调用函数并返回最大值 */</span>   ret = max(a, b)   fmt.Printf( <span class="string">&quot;最大值是 : %d\n&quot;</span>, ret )&#125;<span class="comment">/* 函数返回两个数的最大值 */</span><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;   <span class="comment">/* 定义局部变量 */</span>   <span class="keyword">var</span> result <span class="keyword">int</span>   <span class="keyword">if</span> (num1 &gt; num2) &#123;      result = num1   &#125; <span class="keyword">else</span> &#123;      result = num2   &#125;   <span class="keyword">return</span> result &#125;</span><br></pre></td></tr></table></figure>

<p>以上实例在 main() 函数中调用 max（）函数，执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最大值是 : 200</span><br></pre></td></tr></table></figure>



<h4 id="3-函数返回多个值"><a href="#3-函数返回多个值" class="headerlink" title="3.函数返回多个值"></a>3.函数返回多个值</h4><p>Go 函数可以返回多个值，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;   <span class="keyword">return</span> y, x&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   a, b := swap(<span class="string">&quot;Mahesh&quot;</span>, <span class="string">&quot;Kumar&quot;</span>)   fmt.Println(a, b)&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kumar Mahesh</span><br></pre></td></tr></table></figure>



<h4 id="4-函数参数"><a href="#4-函数参数" class="headerlink" title="4.函数参数"></a>4.函数参数</h4><p>函数如果使用参数，该变量可称为函数的形参。</p>
<p>形参就像定义在函数体内的局部变量。</p>
<p>调用函数，可以通过两种方式来传递参数：</p>
<table>
<thead>
<tr>
<th align="left">传递类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-call-by-value.html">值传递</a></td>
<td align="left">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-call-by-reference.html">引用传递</a></td>
<td align="left">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td>
</tr>
</tbody></table>
<p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p>
<h4 id="5-函数用法"><a href="#5-函数用法" class="headerlink" title="5.函数用法"></a>5.函数用法</h4><table>
<thead>
<tr>
<th align="left">函数用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-as-values.html">函数作为值</a></td>
<td align="left">函数定义后可作为值来使用</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-function-closures.html">闭包</a></td>
<td align="left">闭包是匿名函数，可在动态编程中使用</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-method.html">方法</a></td>
<td align="left">方法就是一个包含了接受者的函数</td>
</tr>
</tbody></table>
<p>（1）函数作为值</p>
<p>Go 语言可以很灵活的创建函数，并作为值使用。以下实例中我们在定义的函数中初始化一个变量，该函数仅仅是为了使用内置函数 math.sqrt() ，实例为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明函数变量 */</span></span><br><span class="line">   getSquareRoot := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用函数 */</span></span><br><span class="line">   fmt.Println(getSquareRoot(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>（2）闭包</p>
<p>Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<p>以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;   i:=<span class="number">0</span>   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;      i+=<span class="number">1</span>     <span class="keyword">return</span> i     &#125;&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span>   nextNumber := getSequence()     <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span>   fmt.Println(nextNumber())   fmt.Println(nextNumber())   fmt.Println(nextNumber())      <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span>   nextNumber1 := getSequence()     fmt.Println(nextNumber1())   fmt.Println(nextNumber1())&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>（3）方法</p>
<h3 id="Go语言变量作用域"><a href="#Go语言变量作用域" class="headerlink" title="Go语言变量作用域"></a>Go语言变量作用域</h3><p>略</p>
<h3 id="Go语言数组"><a href="#Go语言数组" class="headerlink" title="Go语言数组"></a>Go语言数组</h3><h4 id="1-声明数组"><a href="#1-声明数组" class="headerlink" title="1.声明数组"></a>1.声明数组</h4><p>Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure>

<p>以上为一维数组的定义方式。数组长度必须是整数且大于 0。例如以下定义了数组 balance 长度为 10 类型为 float32：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var balance [10] float32</span><br></pre></td></tr></table></figure>



<h4 id="2-初始化数组"><a href="#2-初始化数组" class="headerlink" title="2.初始化数组"></a>2.初始化数组</h4><ul>
<li><p>方式一</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   <span class="comment">//不允许写成 var arr [3]int = &#123;1,2,3&#125;</span></span><br><span class="line">   fmt.Println(arr) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;   <span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span>   arr[<span class="number">0</span>] = <span class="number">1</span>   arr[<span class="number">1</span>] = <span class="number">2</span>   arr[<span class="number">2</span>] = <span class="number">3</span>   fmt.Println(arr) <span class="comment">//[1 2 3]&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>方式三<br>这是方式一的一种简化形式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;	<span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;	fmt.Println(arr) <span class="comment">//[1 2 3]&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>方式四<br>方式一的简化形式，也是用得最多的一种方式。</p>
<p>注意：:=符号只允许在函数中使用，即只能在声明局部变量的时候使用，而var没有这个限制。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;	arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;	fmt.Println(arr) <span class="comment">//[1 2 3]&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>方式五<br>让编译器根据初始值的个数自行推断数组的长度。以…来代替[]中的数字，注意若[]中为空则表示为切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(arr) <span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式六<br>利用指定索引值的方式来初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">4</span>:<span class="number">3</span>&#125; <span class="comment">//例如 0:1 表示数组下标0对应的值为1</span></span><br><span class="line">	fmt.Println(arr) <span class="comment">// [1 0 0 0 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr[<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1[<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr1[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">arr3 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr4 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">arr5 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Go语言指针"><a href="#Go语言指针" class="headerlink" title="Go语言指针"></a>Go语言指针</h3><h4 id="1-什么是指针"><a href="#1-什么是指针" class="headerlink" title="1.什么是指针"></a>1.什么是指针</h4><p>（1）一个指针变量可以指向任何一个值的内存地址。</p>
<p>（2）类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。（3）以下是有效的指针声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 指向整型*/</span><span class="keyword">var</span> fp *<span class="keyword">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure>

<p>本例中这是一个指向 int 和 float32 的指针。</p>
<h4 id="2-如何使用指针"><a href="#2-如何使用指针" class="headerlink" title="2.如何使用指针"></a>2.如何使用指针</h4><p>（1）指针使用流程：</p>
<ul>
<li>定义指针变量。</li>
<li>为指针变量赋值。</li>
<li>访问指针变量中指向地址的值。</li>
</ul>
<p>（2）在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   <span class="keyword">var</span> a <span class="keyword">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span>   <span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 声明指针变量 */</span>   ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span>   fmt.Printf(<span class="string">&quot;a 变量的地址是: %x\n&quot;</span>, &amp;a  )   <span class="comment">/* 指针变量的存储地址 */</span>   fmt.Printf(<span class="string">&quot;ip 变量的存储地址: %x\n&quot;</span>, ip )   <span class="comment">/* 使用指针访问值 */</span>   fmt.Printf(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip )&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a 变量的地址是: <span class="number">20818</span>a220ip 变量的存储地址: <span class="number">20818</span>a220*ip 变量的值: <span class="number">20</span></span><br></pre></td></tr></table></figure>



<h4 id="3-Go-空指针"><a href="#3-Go-空指针" class="headerlink" title="3.Go 空指针"></a>3.Go 空指针</h4><p>（1）当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p>
<p>​        nil 指针也称为空指针。</p>
<p>​        nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p>
<p>（2）一个指针变量通常缩写为 ptr。</p>
<p>​    查看以下实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   <span class="keyword">var</span>  ptr *<span class="keyword">int</span>   fmt.Printf(<span class="string">&quot;ptr 的值为 : %x\n&quot;</span>, ptr  )&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ptr 的值为 : 0</span><br></pre></td></tr></table></figure>

<p>（3）空指针判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(ptr != nil)     /* ptr 不是空指针 */</span><br><span class="line">if(ptr == nil)    /* ptr 是空指针 */</span><br></pre></td></tr></table></figure>



<h4 id="4-Go指针更多内容"><a href="#4-Go指针更多内容" class="headerlink" title="4.Go指针更多内容"></a>4.Go指针更多内容</h4><p>接下来我们将为大家介绍Go语言中更多的指针应用：</p>
<table>
<thead>
<tr>
<th align="left">内容</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-array-of-pointers.html">Go 指针数组</a></td>
<td align="left">你可以定义一个指针数组来存储地址</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-pointer-to-pointer.html">Go 指向指针的指针</a></td>
<td align="left">Go 支持指向指针的指针</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/go/go-passing-pointers-to-functions.html">Go 像函数传递指针参数</a></td>
<td align="left">通过引用或地址传参，在函数调用时可以改变其值</td>
</tr>
</tbody></table>
<h3 id="Go语言结构体"><a href="#Go语言结构体" class="headerlink" title="Go语言结构体"></a>Go语言结构体</h3><h4 id="1-定义结构体"><a href="#1-定义结构体" class="headerlink" title="1.定义结构体"></a>1.定义结构体</h4><p>（1）结构体定义需要使用<font color="red"> type</font> 和 <font color="red">struct </font>语句。struct 语句定义一个新的数据类型，结构体有中一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-访问结构体成员"><a href="#2-访问结构体成员" class="headerlink" title="2.访问结构体成员"></a>2.访问结构体成员</h4><p>（1）如果要访问结构体成员，需要使用点号 (.) 操作符，格式为：<font color="red">“结构体.成员名”</font>。</p>
<p>结构体类型变量使用struct关键字定义，实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* 声明 Book2 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 title : %s\n&quot;</span>, Book1.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 author : %s\n&quot;</span>, Book1.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 subject : %s\n&quot;</span>, Book1.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 book_id : %d\n&quot;</span>, Book1.book_id)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 title : %s\n&quot;</span>, Book2.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 author : %s\n&quot;</span>, Book2.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 subject : %s\n&quot;</span>, Book2.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 book_id : %d\n&quot;</span>, Book2.book_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Book <span class="number">1</span> title : Go 语言</span><br><span class="line">Book <span class="number">1</span> author : www.w3cschool.cn</span><br><span class="line">Book <span class="number">1</span> subject : Go 语言教程</span><br><span class="line">Book <span class="number">1</span> book_id : <span class="number">6495407</span></span><br><span class="line">Book <span class="number">2</span> title : Python 教程</span><br><span class="line">Book <span class="number">2</span> author : www.w3cschool.cn</span><br><span class="line">Book <span class="number">2</span> subject : Python 语言教程</span><br><span class="line">Book <span class="number">2</span> book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>



<h4 id="3-结构体作为函数参数"><a href="#3-结构体作为函数参数" class="headerlink" title="3.结构体作为函数参数"></a>3.结构体作为函数参数</h4><p>（1）你可以向其他数据类型一样将结构体类型作为参数传递给函数。并以以上实例的方式访问结构体变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* 声明 Book2 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   printBook(Book1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   printBook(Book2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Book title : Go 语言</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Go 语言教程</span><br><span class="line">Book book_id : <span class="number">6495407</span></span><br><span class="line">Book title : Python 教程</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Python 语言教程</span><br><span class="line">Book book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>



<h4 id="4-结构体指针"><a href="#4-结构体指针" class="headerlink" title="4.结构体指针"></a>4.结构体指针</h4><p>（1）你可以定义指向结构体的指针类似于其他指针变量，格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br></pre></td></tr></table></figure>

<p>（2）以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>

<p>（3）使用结构体指针访问结构体成员，使用 “.” 操作符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer.title;</span><br></pre></td></tr></table></figure>

<p>（4）接下来让我们使用结构体指针重写以上实例，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* Declare Book1 of type Book */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* Declare Book2 of type Book */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.w3cschool.cn&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   printBook(&amp;Book1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   printBook(&amp;Book2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book *Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Book title : Go 语言</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Go 语言教程</span><br><span class="line">Book book_id : <span class="number">6495407</span></span><br><span class="line">Book title : Python 教程</span><br><span class="line">Book author : www.w3cschool.cn</span><br><span class="line">Book subject : Python 语言教程</span><br><span class="line">Book book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言切片（Slice）"><a href="#Go语言切片（Slice）" class="headerlink" title="Go语言切片（Slice）"></a>Go语言切片（Slice）</h3><h4 id="1-定义切片"><a href="#1-定义切片" class="headerlink" title="1.定义切片"></a>1.定义切片</h4><p>（1）你可以声明一个未指定大小的数组来定义切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>（2）或使用<font color="red">make()函数</font>来创建切片:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">也可以简写为</span><br><span class="line"></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>

<p>（3）也可以指定容量，其中capacity为可选参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">type</span>, length, capacity)</span><br></pre></td></tr></table></figure>

<p>这里 len 是数组的长度并且也是切片的初始长度。</p>
<h4 id="2-切片初始化"><a href="#2-切片初始化" class="headerlink" title="2.切片初始化"></a>2.切片初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s :=[] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125; </span><br></pre></td></tr></table></figure>

<p>（1）直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[:] </span><br></pre></td></tr></table></figure>

<p>（2）初始化切片s,是数组arr的引用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:endIndex] </span><br></pre></td></tr></table></figure>

<p>（3）将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:] </span><br></pre></td></tr></table></figure>

<p>（4）缺省endIndex时将表示一直到arr的最后一个元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[:endIndex] </span><br></pre></td></tr></table></figure>

<p>（5）缺省startIndex时将表示从arr的第一个元素开始</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := s[startIndex:endIndex] </span><br></pre></td></tr></table></figure>

<p>（6）通过切片s初始化切片s1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>) </span><br></pre></td></tr></table></figure>

<p>（7）通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</p>
<h4 id="3-len-和-cap-函数"><a href="#3-len-和-cap-函数" class="headerlink" title="3.len() 和 cap() 函数"></a>3.len() 和 cap() 函数</h4><p>（1）切片是可索引的，并且可以由 len() 方法获取长度。</p>
<p>（2）切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>
<p>（3）以下为具体实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">3</span> <span class="built_in">cap</span>=<span class="number">5</span> slice=[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<h4 id="4-空-nil-切片"><a href="#4-空-nil-切片" class="headerlink" title="4.空(nil)切片"></a>4.空(nil)切片</h4><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> slice=[]</span><br><span class="line">切片是空的</span><br></pre></td></tr></table></figure>



<h4 id="5-切片截取"><a href="#5-切片截取" class="headerlink" title="5.切片截取"></a>5.切片截取</h4><p>可以通过设置下限及上限来设置截取切片 **[lower-bound:upper-bound]**，实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;   </span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers ==&quot;</span>, numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[1:4] ==&quot;</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[:3] ==&quot;</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[4:] ==&quot;</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]</span><br><span class="line">numbers == [0 1 2 3 4 5 6 7 8]</span><br><span class="line">numbers[1:4] == [1 2 3]</span><br><span class="line">numbers[:3] == [0 1 2]</span><br><span class="line">numbers[4:] == [4 5 6 7 8]</span><br><span class="line">len=0 cap=5 slice=[]</span><br><span class="line">len=2 cap=9 slice=[0 1]</span><br><span class="line">len=3 cap=7 slice=[2 3 4]</span><br></pre></td></tr></table></figure>



<h4 id="6-append-和-copy-函数"><a href="#6-append-和-copy-函数" class="headerlink" title="6.append() 和 copy() 函数"></a>6.append() 和 copy() 函数</h4><p>（1）如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p>
<p>（2）下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> slice=[]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">1</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">2</span> slice=[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">8</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">16</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<h3 id="Go语言范围（Range"><a href="#Go语言范围（Range" class="headerlink" title="Go语言范围（Range)"></a>Go语言范围（Range)</h3><h4 id="1-Go-语言范围"><a href="#1-Go-语言范围" class="headerlink" title="1.Go 语言范围"></a>1.Go 语言范围</h4><p>（1）Go 语言中 range 关键字用于for循环中迭代数组(array)、切片(slice)、链表(channel)或集合(map)的元素。</p>
<p>（2）在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值，对于映射，它返回下一个键值对的键。</p>
<p>（2）Range返回一个值或两个值。如果在Range表达式的左侧只使用了一个值，则该值是下表中的第一个值。</p>
<table>
<thead>
<tr>
<th>Range表达式</th>
<th>第一个值</th>
<th>第二个值[可选的]</th>
</tr>
</thead>
<tbody><tr>
<td>Array 或者 slice a [n]E</td>
<td>索引 i int</td>
<td>a[i] E</td>
</tr>
<tr>
<td>String s string type</td>
<td>索引 i int</td>
<td>rune int</td>
</tr>
<tr>
<td>map m map[K]V</td>
<td>键 k K</td>
<td>值 m[k] V</td>
</tr>
<tr>
<td>channel c chan E</td>
<td>元素 e E</td>
<td>none</td>
</tr>
</tbody></table>
<p>（4）实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//(1)这是我们使用range去求一个slice的和。使用数组跟这个很类似</span></span><br><span class="line">    nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum:&quot;</span>, sum)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(2)在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;index:&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(3)range也可以用在map的键值对上。</span></span><br><span class="line">    kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(4)range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;go&quot;</span> &#123;</span><br><span class="line">        fmt.Println(i, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum: <span class="number">9</span></span><br><span class="line">index: <span class="number">1</span></span><br><span class="line">a -&gt; apple</span><br><span class="line">b -&gt; banana</span><br><span class="line"><span class="number">0</span> <span class="number">103</span></span><br><span class="line"><span class="number">1</span> <span class="number">111</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言Map（集合）"><a href="#Go语言Map（集合）" class="headerlink" title="Go语言Map（集合）"></a>Go语言Map（集合）</h3><h4 id="1-定义-Map"><a href="#1-定义-Map" class="headerlink" title="1.定义 Map"></a>1.定义 Map</h4><p>（1）可以使用<font color="red">内建函数 make </font>也可以使用 <font color="red">map 关键字</font>来定义 Map:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable = <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure>

<p>（2）如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p>
<p>（3）实例</p>
<p>下面实例演示了创建和使用map:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">   <span class="comment">/* 创建集合 */</span></span><br><span class="line">   countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* map 插入 key-value 对，各个国家对应的首都 */</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;France&quot;</span>] = <span class="string">&quot;Paris&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Italy&quot;</span>] = <span class="string">&quot;Rome&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Japan&quot;</span>] = <span class="string">&quot;Tokyo&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;India&quot;</span>] = <span class="string">&quot;New Delhi&quot;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 使用 key 输出 map 值 */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 查看元素在集合中是否存在 */</span></span><br><span class="line">   captial, ok := countryCapitalMap[<span class="string">&quot;United States&quot;</span>]</span><br><span class="line">   <span class="comment">/* 如果 ok 是 true, 则存在，否则不存在 */</span></span><br><span class="line">   <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is&quot;</span>, captial)  </span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is not present&quot;</span>) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Capital of France is Paris</span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br><span class="line">Capital of United States is not present</span><br></pre></td></tr></table></figure>



<h4 id="2-delete-函数"><a href="#2-delete-函数" class="headerlink" title="2.delete() 函数"></a>2.delete() 函数</h4><p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key。实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">   <span class="comment">/* 创建 map */</span></span><br><span class="line">   countryCapitalMap := <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">string</span> &#123;<span class="string">&quot;France&quot;</span>:<span class="string">&quot;Paris&quot;</span>,<span class="string">&quot;Italy&quot;</span>:<span class="string">&quot;Rome&quot;</span>,<span class="string">&quot;Japan&quot;</span>:<span class="string">&quot;Tokyo&quot;</span>,<span class="string">&quot;India&quot;</span>:<span class="string">&quot;New Delhi&quot;</span>&#125;</span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">&quot;原始 map&quot;</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 删除元素 */</span></span><br><span class="line">   <span class="built_in">delete</span>(countryCapitalMap,<span class="string">&quot;France&quot;</span>);</span><br><span class="line">   fmt.Println(<span class="string">&quot;Entry for France is deleted&quot;</span>)  </span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">&quot;删除元素后 map&quot;</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例运行结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">原始 mapCapital of France is ParisCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New DelhiEntry <span class="keyword">for</span> France is deleted删除元素后 mapCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New Delhi</span><br></pre></td></tr></table></figure>



<h3 id="Go语言递归函数"><a href="#Go语言递归函数" class="headerlink" title="Go语言递归函数"></a>Go语言递归函数</h3><h4 id="1-Go-语言递归函数"><a href="#1-Go-语言递归函数" class="headerlink" title="1.Go 语言递归函数"></a>1.Go 语言递归函数</h4><p>递归，就是在运行的过程中调用自己。</p>
<p>语法格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> &#123;   recursion() <span class="comment">/* 函数调用自身 */</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   recursion()&#125;</span><br></pre></td></tr></table></figure>

<p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。</p>
<p>递归函数对于解决数学上的问题是非常有用的，就像计算阶乘，生成斐波那契数列等。</p>
<h4 id="2-阶乘"><a href="#2-阶乘" class="headerlink" title="2.阶乘"></a>2.阶乘</h4><p>以下实例通过 Go 语言的递归函数实例阶乘：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">    result = <span class="number">1</span>;   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = x * Factorial(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">15</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d 的阶乘是 %d\n&quot;</span>, i, Factorial(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span> 的阶乘是 <span class="number">1307674368000</span></span><br></pre></td></tr></table></figure>



<h4 id="3-斐波那契数列"><a href="#3-斐波那契数列" class="headerlink" title="3.斐波那契数列"></a>3.斐波那契数列</h4><p>以下实例通过 Go 语言的递归函数实现斐波那契数列：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n<span class="number">-2</span>) + fibonacci(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">       fmt.Printf(<span class="string">&quot;%d\t&quot;</span>, fibonacci(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">5</span>   <span class="number">8</span>   <span class="number">13</span>  <span class="number">21</span>  <span class="number">34</span></span><br></pre></td></tr></table></figure>



<h3 id="Go语言类型转换"><a href="#Go语言类型转换" class="headerlink" title="Go语言类型转换"></a>Go语言类型转换</h3><h4 id="1-Go-语言类型转换"><a href="#1-Go-语言类型转换" class="headerlink" title="1.Go 语言类型转换"></a>1.Go 语言类型转换</h4><p>（1）类型转换用于将一种数据类型的变量转换为另外一种类型的变量。Go 语言类型转换基本格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure>

<p>type_name 为类型，expression 为表达式。</p>
<p>（2）实例</p>
<p>以下实例中将整型转化为浮点型，并计算结果，将结果赋值给浮点型变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">17</span></span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">   <span class="keyword">var</span> mean <span class="keyword">float32</span></span><br><span class="line">   </span><br><span class="line">   mean = <span class="keyword">float32</span>(sum)/<span class="keyword">float32</span>(count)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;mean 的值为: %f\n&quot;</span>,mean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mean 的值为: <span class="number">3.400000</span></span><br></pre></td></tr></table></figure>



<h4 id="2-go-不支持隐式转换类型"><a href="#2-go-不支持隐式转换类型" class="headerlink" title="2.go 不支持隐式转换类型"></a>2.go 不支持隐式转换类型</h4><p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int32</span></span><br><span class="line">    b = a</span><br><span class="line">    fmt.Printf(<span class="string">&quot;b 为 : %d&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cannot use a (<span class="keyword">type</span> <span class="keyword">int64</span>) as <span class="keyword">type</span> <span class="keyword">int32</span> in assignment</span><br><span class="line">cannot use b (<span class="keyword">type</span> <span class="keyword">int32</span>) as <span class="keyword">type</span> <span class="keyword">string</span> in argument to fmt.Printf</span><br></pre></td></tr></table></figure>

<p>但是如果改成 <code>b = int32(a) </code>就不会报错了:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int32</span></span><br><span class="line">    b = <span class="keyword">int32</span>(a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;b 为 : %d&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="GO语言接口"><a href="#GO语言接口" class="headerlink" title="GO语言接口"></a>GO语言接口</h3><h4 id="1-Go-语言接口"><a href="#1-Go-语言接口" class="headerlink" title="1.Go 语言接口"></a>1.Go 语言接口</h4><p>（1）Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p>
<p>实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_name1</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_namen</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个接口Phone，接口里面有一个方法call()。然后我们在main函数里面定义了一个Phone类型变量，并分别为之赋值为NokiaPhone和IPhone。然后调用call()方法，输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">I am Nokia, I can call you!</span><br><span class="line">I am iPhone, I can call you!</span><br></pre></td></tr></table></figure>

<p>（2）</p>
<ul>
<li><a href="https://www.cnblogs.com/itogo/p/8645486.html">参考1</a></li>
<li><a href="https://blog.csdn.net/lipenghandsome/article/details/105916687">参考2</a></li>
</ul>
<h3 id="GO语言错误处理"><a href="#GO语言错误处理" class="headerlink" title="GO语言错误处理"></a>GO语言错误处理</h3><h4 id="1-Go-错误处理"><a href="#1-Go-错误处理" class="headerlink" title="1.Go 错误处理"></a>1.Go 错误处理</h4><p>（1）Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p>
<p>error类型是一个接口类型，这是它的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）我们可以在编码中通过实现 error 接口类型来生成错误信息。</p>
<p>函数通常在最后的返回值中返回错误信息。使用<font color="red">errors.New </font>可返回一个错误信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）在下面的例子中，我们在调用Sqrt的时候传递的一个负数，然后就得到了non-nil的error对象，将此对象与nil比较，结果为true，所以fmt.Println(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err:= Sqrt(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 DivideError 结构</span></span><br><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">    dividee <span class="keyword">int</span></span><br><span class="line">    divider <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `error` 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(de *DivideError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    strFormat := <span class="string">`</span></span><br><span class="line"><span class="string">    Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="string">    dividee: %d</span></span><br><span class="line"><span class="string">    divider: 0</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(strFormat, de.dividee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 `int` 类型除法运算的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(varDividee <span class="keyword">int</span>, varDivider <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>, errorMsg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> varDivider == <span class="number">0</span> &#123;</span><br><span class="line">            dData := DivideError&#123;</span><br><span class="line">                    dividee: varDividee,</span><br><span class="line">                    divider: varDivider,</span><br><span class="line">            &#125;</span><br><span class="line">            errorMsg = dData.Error()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> varDividee / varDivider, <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况</span></span><br><span class="line">    <span class="keyword">if</span> result, errorMsg := Divide(<span class="number">100</span>, <span class="number">10</span>); errorMsg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;100/10 = &quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当被除数为零的时候会返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span> _, errorMsg := Divide(<span class="number">100</span>, <span class="number">0</span>); errorMsg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;errorMsg is: &quot;</span>, errorMsg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>/<span class="number">10</span> =  <span class="number">10</span></span><br><span class="line">errorMsg is:  </span><br><span class="line">   Cannot proceed, the divider is zero.</span><br><span class="line">  dividee: <span class="number">100</span></span><br><span class="line">  divider: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>（4）</p>
<ul>
<li><a href="https://blog.csdn.net/m0_38004619/article/details/98968097">Go语言中的异常处理</a></li>
<li><a href="https://www.jianshu.com/p/f30da01eea97">Golang错误和异常处理的正确姿势</a></li>
</ul>
]]></content>
      <categories>
        <category>《Golang》</category>
      </categories>
      <tags>
        <tag>Go语言</tag>
      </tags>
  </entry>
</search>
