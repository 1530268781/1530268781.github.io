<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《第一行代码-笔记》 | Welcome to Durango's blog!</title><meta name="keywords" content="Android"><meta name="author" content="Durango,1530268781@qq.com"><meta name="copyright" content="Durango"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在初学android过程中，对于《第一行代码2》的个人笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《第一行代码-笔记》">
<meta property="og:url" content="https://www.durango.cn/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/index.html">
<meta property="og:site_name" content="Welcome to Durango&#39;s blog!">
<meta property="og:description" content="在初学android过程中，对于《第一行代码2》的个人笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.durango.cn/img/android_img.jpg">
<meta property="article:published_time" content="2021-05-31T04:37:24.000Z">
<meta property="article:modified_time" content="2021-05-31T14:50:01.968Z">
<meta property="article:author" content="Durango">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.durango.cn/img/android_img.jpg"><link rel="shortcut icon" href="/img/avatar2.jpg"><link rel="canonical" href="https://www.durango.cn/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":1000,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Durango","link":"链接: ","source":"来源: Welcome to Durango's blog!","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《第一行代码-笔记》',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-31 22:50:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/android_img.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Welcome to Durango's blog!</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《第一行代码-笔记》</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-31T04:37:24.000Z" title="发表于 2021-05-31 12:37:24">2021-05-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-31T14:50:01.968Z" title="更新于 2021-05-31 22:50:01">2021-05-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E3%80%8A-Android%E5%9F%BA%E7%A1%80%E3%80%8B/">《 Android基础》</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《第一行代码-笔记》"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="note warning modern"><p><strong>前言：</strong>目录结构还有待优化，可直接ctrl+F搜索有无需要了解的内容<br>本笔记属于个人初学android过程时总结，如有错误或者图片缺失，还请留言指正，十分感谢！<br>仅供学习参考，如需转载请注明来自[Durango]: <a href="http://www.durango.cn/">www.durango.cn</a></p>
</div>




<h1 id="第一章-第一行代码"><a href="#第一章-第一行代码" class="headerlink" title="第一章     第一行代码"></a>第一章     <strong>第一行代码</strong></h1><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><h3 id="Linux内核层、系统运行库、应用架构层、应用层"><a href="#Linux内核层、系统运行库、应用架构层、应用层" class="headerlink" title="Linux内核层、系统运行库、应用架构层、应用层"></a>Linux内核层、系统运行库、应用架构层、应用层</h3><h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><h3 id="活动（Activity）、服务（Service）、广播接收器（Broadcast-Receiver）、-内容提供者（Content-Provider"><a href="#活动（Activity）、服务（Service）、广播接收器（Broadcast-Receiver）、-内容提供者（Content-Provider" class="headerlink" title="活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、        内容提供者（Content Provider)"></a>活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、        内容提供者（Content Provider)</h3><h2 id="APP目录"><a href="#APP目录" class="headerlink" title="APP目录"></a>APP目录</h2><ul>
<li>1.build: 一些编译时自动生成的文件</li>
</ul>
<h4 id="2-libs-第三方jar包"><a href="#2-libs-第三方jar包" class="headerlink" title="2.libs: 第三方jar包"></a>2.libs: 第三方jar包</h4><h4 id="3-androidTest-测试用例，自动化监测"><a href="#3-androidTest-测试用例，自动化监测" class="headerlink" title="3.androidTest: 测试用例，自动化监测"></a>3.androidTest: 测试用例，自动化监测</h4><h4 id="4-java-放置Java代码"><a href="#4-java-放置Java代码" class="headerlink" title="4.java: 放置Java代码"></a>4.<font color="red">java</font>: 放置Java代码</h4><h4 id="5-res-资源文件"><a href="#5-res-资源文件" class="headerlink" title="5.res: 资源文件"></a>5<font color="red">.res</font>: 资源文件</h4><p>​                drawable: 图片</p>
<p>​                layout: 布局文件</p>
<p>​                values: 字符串</p>
<h4 id="6-AndroidMainfest-xml-项目配置文件，四大活动必须在此注册！"><a href="#6-AndroidMainfest-xml-项目配置文件，四大活动必须在此注册！" class="headerlink" title="6.AndroidMainfest.xml: 项目配置文件，四大活动必须在此注册！"></a>6.AndroidMainfest.xml: 项目配置文件，四大活动必须在此注册！</h4><p>​    ……</p>
<h2 id="主活动"><a href="#主活动" class="headerlink" title="主活动"></a>主活动</h2><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200912223928217.png" alt="image-20200912223928217"></p>
<h2 id="引入布局"><a href="#引入布局" class="headerlink" title="引入布局"></a><font color="red">引入布局</font></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView( R.layout.hello_world_layout)</span><br></pre></td></tr></table></figure>



<h2 id="资源的引用"><a href="#资源的引用" class="headerlink" title="资源的引用"></a><font color="red">资源的引用</font></h2><h4 id="1-代码中"><a href="#1-代码中" class="headerlink" title="1.代码中"></a>1.代码中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R.string.hello_world</span><br></pre></td></tr></table></figure>

<p>​        R .类型 .名称</p>
<h4 id="2-XML中"><a href="#2-XML中" class="headerlink" title="2.XML中"></a>2.XML中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@.string.hello_world</span><br></pre></td></tr></table></figure>

<p>​    @ .类型 .名称</p>
<h3 id="定义id-id-名称"><a href="#定义id-id-名称" class="headerlink" title="定义id: @+id/名称"></a>定义id: @+id/名称</h3><h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><h4 id="（p26）"><a href="#（p26）" class="headerlink" title="（p26）"></a>（p26）</h4><h1 id="第二章-探究活动"><a href="#第二章-探究活动" class="headerlink" title="第二章 探究活动"></a>第二章 探究活动</h1><h2 id="活动是什么"><a href="#活动是什么" class="headerlink" title="活动是什么"></a>活动是什么</h2><h2 id="活动的基本用法"><a href="#活动的基本用法" class="headerlink" title="活动的基本用法"></a>活动的基本用法</h2><h3 id="一、手动创建活动"><a href="#一、手动创建活动" class="headerlink" title="一、手动创建活动"></a>一、手动创建活动</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172254284.png" alt="image-20200913172254284"></p>
<h3 id="二、创建和加载布局"><a href="#二、创建和加载布局" class="headerlink" title="二、创建和加载布局"></a>二、创建和加载布局</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172406723.png" alt="image-20200913172406723"></p>
<p>​                                                                                    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913172431922.png" alt="image-20200913172431922"></p>
<h4 id="添加按钮："><a href="#添加按钮：" class="headerlink" title="添加按钮："></a><font color="orange">添加按钮：</font></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">	android:id=&quot;@+id/button_1&quot;</span><br><span class="line">	android:layout_width=&quot;match_parent&quot;</span><br><span class="line">	android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">	android:text=&quot;Button 1&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="加载布局："><a href="#加载布局：" class="headerlink" title="加载布局："></a><font color="orange">加载布局：</font></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(R.layout.布局文件名)</span><br></pre></td></tr></table></figure>

<h3 id="三、在AndroidManifest文件中注册"><a href="#三、在AndroidManifest文件中注册" class="headerlink" title="三、在AndroidManifest文件中注册"></a>三、在AndroidManifest文件中注册</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174606232.png" alt="image-20200913174606232"></p>
<h3 id="四、在活动中使用Toast提醒"><a href="#四、在活动中使用Toast提醒" class="headerlink" title="四、在活动中使用Toast提醒"></a>四、在活动中使用Toast提醒</h3><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174713039.png" alt="image-20200913174713039"></p>
<h3 id="五、在活动中使用Menu"><a href="#五、在活动中使用Menu" class="headerlink" title="五、在活动中使用Menu"></a>五、在活动中使用Menu</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913174848093.png" alt="image-20200913174848093"></h4><p>2.然后在main.xml文件中添加(创建两个菜单项)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;item</span><br><span class="line">	android:id=&quot;@+id/add_itme&quot;</span><br><span class="line">	android:title=&quot;Add&quot;/&gt;</span><br><span class="line">&lt;item</span><br><span class="line">	android:id=&quot;@+id/remove_itme&quot;</span><br><span class="line">	android:title=&quot;Remove&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-重写onCreateOptionMenu（）方法"><a href="#3-重写onCreateOptionMenu（）方法" class="headerlink" title="3.重写onCreateOptionMenu（）方法"></a>3.重写<font color="orange">onCreateOptionMenu（）</font>方法</h4><h4 id="在Java代码中使用快捷键-”Ctrl-O“"><a href="#在Java代码中使用快捷键-”Ctrl-O“" class="headerlink" title="在Java代码中使用快捷键 ”Ctrl+O“"></a>在Java代码中使用快捷键 ”Ctrl+O“</h4><p>​                                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913175533827.png" alt="image-20200913175533827"></p>
<h4 id="4-重写onOptionsItemSelected"><a href="#4-重写onOptionsItemSelected" class="headerlink" title="4.重写onOptionsItemSelected"></a>4.重写<font color="orange">onOptionsItemSelected</font></h4><p>​                                    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913180038921.png" alt="image-20200913180038921"></p>
<h3 id="六、摧毁一个活动"><a href="#六、摧毁一个活动" class="headerlink" title="六、摧毁一个活动"></a>六、摧毁一个活动</h3><h4 id="stop"><a href="#stop" class="headerlink" title="stop();"></a><font color="orange">stop();</font></h4><h2 id="使用Intent（意图）在活动之间穿梭"><a href="#使用Intent（意图）在活动之间穿梭" class="headerlink" title="使用Intent（意图）在活动之间穿梭"></a>使用Intent（意图）在活动之间穿梭</h2><h3 id="一、使用显式的Intent"><a href="#一、使用显式的Intent" class="headerlink" title="一、使用显式的Intent"></a>一、使用显式的Intent</h3><h4 id><a href="#" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913212452461.png" alt="image-20200913212452461"></h4><h4 id="首先构建一个Intent，传入FirstActivity-this作为上下文，传入SecondActicity-class作为目标活动，然后通过startActivity（）方法来执行这个Intent。"><a href="#首先构建一个Intent，传入FirstActivity-this作为上下文，传入SecondActicity-class作为目标活动，然后通过startActivity（）方法来执行这个Intent。" class="headerlink" title="首先构建一个Intent，传入FirstActivity.this作为上下文，传入SecondActicity.class作为目标活动，然后通过startActivity（）方法来执行这个Intent。"></a>首先构建一个Intent，传入FirstActivity.this作为<font color="orange">上下文</font>，传入SecondActicity.class作为<font color="orange">目标活动</font>，然后通过startActivity（）方法来执行这个Intent。</h4><h3 id="二、使用隐式的Intent（意图过滤器intent-filter"><a href="#二、使用隐式的Intent（意图过滤器intent-filter" class="headerlink" title="二、使用隐式的Intent（意图过滤器intent-filter)"></a>二、使用隐式的Intent（意图过滤器<font color="red">intent-filter</font>)</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913213406302.png" alt="image-20200913213406302"></h4><h4 id="-1"><a href="#-1" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913213734619.png" alt="image-20200913213734619"></h4><h4 id="2-DEFAULT是一种默认的category，在调用startActicity-方法时会自动将这个category添加到Intent中。"><a href="#2-DEFAULT是一种默认的category，在调用startActicity-方法时会自动将这个category添加到Intent中。" class="headerlink" title="2.DEFAULT是一种默认的category，在调用startActicity()方法时会自动将这个category添加到Intent中。"></a>2.DEFAULT是一种默认的category，在调用startActicity()方法时会自动将这个category添加到Intent中。</h4><h4 id="3-每个Intent只能指定一个action，却能指定多个category，这样增加："><a href="#3-每个Intent只能指定一个action，却能指定多个category，这样增加：" class="headerlink" title="3.每个Intent只能指定一个action，却能指定多个category，这样增加："></a>3.每个Intent只能指定一个action，却能指定多个category，这样增加：</h4><h4 id="intent-addCategory-“com-example-activity-MY-CATEGORY”-；"><a href="#intent-addCategory-“com-example-activity-MY-CATEGORY”-；" class="headerlink" title="intent.addCategory(“com.example.activity.MY_CATEGORY”)；"></a>intent.<font color="red">addCategory(“com.example.activity.MY_CATEGORY”)</font>；</h4><h4 id="4-然后在活动二的intent-filter中添加声明："><a href="#4-然后在活动二的intent-filter中添加声明：" class="headerlink" title="4.然后在活动二的intent-filter中添加声明："></a>4.然后在活动二的intent-filter中添加声明：</h4><h4 id="lt-category-android-name-”com-example-activity-MY-CATEGORY”"><a href="#lt-category-android-name-”com-example-activity-MY-CATEGORY”" class="headerlink" title="&lt;category android:name=”com.example.activity.MY_CATEGORY”"></a><font color="red">&lt;category android:name=”com.example.activity.MY_CATEGORY”</font></h4><h4 id="5-只有-lt-action-gt-和-lt-category-gt-同时匹配上-Intent中指定的-action-和-category-时，这个活动才能响应该Intent"><a href="#5-只有-lt-action-gt-和-lt-category-gt-同时匹配上-Intent中指定的-action-和-category-时，这个活动才能响应该Intent" class="headerlink" title="5.只有&lt;action&gt;和&lt;category&gt;同时匹配上 Intent中指定的 action 和 category 时，这个活动才能响应该Intent"></a>5.<font color="orange">只有&lt;action&gt;和&lt;category&gt;同时匹配上 Intent中指定的 action 和 category 时，这个活动才能响应该Intent</font></h4><h3 id="三、更多隐式的Intent"><a href="#三、更多隐式的Intent" class="headerlink" title="三、更多隐式的Intent"></a>三、更多隐式的Intent</h3><h4 id="1-使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动"><a href="#1-使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动" class="headerlink" title="1.使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动"></a>1.使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动</h4><p>​            <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200913220158511.png" alt="image-20200913220158511"></p>
<h5 id="（1）这里我们首先指定了Intent的action是Intent-ACTION-VIEW，这是一个Android系统内置的动作，其常量值为-android-intent-action-VIEW。"><a href="#（1）这里我们首先指定了Intent的action是Intent-ACTION-VIEW，这是一个Android系统内置的动作，其常量值为-android-intent-action-VIEW。" class="headerlink" title="（1）这里我们首先指定了Intent的action是Intent.ACTION_VIEW，这是一个Android系统内置的动作，其常量值为                android.intent.action.VIEW。"></a>（1）这里我们首先指定了Intent的action是<font color="red">Intent.ACTION_VIEW</font>，这是一个Android系统内置的动作，其常量值为                android.intent.action.VIEW。</h5><h5 id="（2）然后通过Uri-parse-方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData-方法将这个uri对象-传递进去。"><a href="#（2）然后通过Uri-parse-方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData-方法将这个uri对象-传递进去。" class="headerlink" title="（2）然后通过Uri.parse()方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData()方法将这个uri对象                传递进去。"></a>（2）然后通过<font color="red">Uri.parse()</font>方法，将一个网址字符串解析成一个Uri对象，再调用Intent的<font color="red">setData()</font>方法将这个uri对象                传递进去。</h5><h5 id="（3）可能你会对setData-部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，-主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri-parse-方法中解析产生的。"><a href="#（3）可能你会对setData-部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，-主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri-parse-方法中解析产生的。" class="headerlink" title="（3）可能你会对setData()部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，                主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri.parse()方法中解析产生的。"></a>（3）可能你会对<font color="red">setData()</font>部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，                主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri.parse()方法中解析产生的。</h5><h4 id="2-与此对应，我们还可以在-lt-intent-filter-gt-标签中再配置一个-lt-data-gt-标签，用于更精确地"><a href="#2-与此对应，我们还可以在-lt-intent-filter-gt-标签中再配置一个-lt-data-gt-标签，用于更精确地" class="headerlink" title="2.与此对应，我们还可以在&lt;intent-filter&gt;标签中再配置一个&lt;data&gt;标签，用于更精确地"></a>2.与此对应，我们还可以在&lt;intent-filter&gt;标签中再配置一个&lt;<font color="red">data</font>&gt;标签，用于更精确地</h4><pre><code>            指定当前活动能够响应什么类型的数据。\&lt;data&gt;标签中主要可以配置以下内容。
            android:scheme。用于指定数据的协议部分，如上例中的http部分。
            android:host。用于指定数据的主机名部分，如上例中的www.baidu.com部分。
            android:port。用于指定数据的端口部分，一般紧随在主机名之后。
            android:path。用于指定主机名和端口之后的部分,如一段网址中跟在域名之后的内容。
            android:mimeType。用于指定可以处理的数据类型,允许使用通配符的方式进行指定。
</code></pre>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><h5 id="这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了"><a href="#这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了" class="headerlink" title="这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了"></a>这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了</h5><h3 id="四、向下一个活动传递数据"><a href="#四、向下一个活动传递数据" class="headerlink" title="四、向下一个活动传递数据"></a>四、<font color="red">向下一个活动传递数据</font></h3><h4 id="1-通过Intent的putExtra-方法携带数据"><a href="#1-通过Intent的putExtra-方法携带数据" class="headerlink" title="1.通过Intent的putExtra()方法携带数据"></a>1.通过Intent的<font color="orange">putExtra()</font>方法携带数据</h4><h4 id="-2"><a href="#-2" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915194843260.png" alt="image-20200915194843260"></h4><h6 id="putExtra-“extra-data”-data-第一个参数是“键”，第二个参数是“数据”"><a href="#putExtra-“extra-data”-data-第一个参数是“键”，第二个参数是“数据”" class="headerlink" title="*putExtra(“extra_data”, data)*第一个参数是“键”，第二个参数是“数据”"></a>*<font color="orange">putExtra(“extra_data”, data)</font>*第一个参数是<strong>“键”</strong>，第二个参数是“数据”</h6><h4 id="2-通过Intent的getStringExtra-键-获取数据"><a href="#2-通过Intent的getStringExtra-键-获取数据" class="headerlink" title="2.通过Intent的getStringExtra(键)获取数据"></a>2.通过Intent的<font color="orange">getStringExtra(键)</font>获取数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915200007173.png" alt="image-20200915200007173"></p>
<h5 id="getStringExtra-getIntExtra-getBooleanExtra"><a href="#getStringExtra-getIntExtra-getBooleanExtra" class="headerlink" title="getStringExtra() / getIntExtra() / getBooleanExtra()"></a><font color="orange">getStringExtra() / getIntExtra() / getBooleanExtra()</font></h5><h3 id="五、返回数据给上一个活动"><a href="#五、返回数据给上一个活动" class="headerlink" title="五、返回数据给上一个活动"></a>五、<font color="red">返回数据给上一个活动</font></h3><h4 id="1-通过startActivityForResult（）来启动SecondActivity"><a href="#1-通过startActivityForResult（）来启动SecondActivity" class="headerlink" title="1.通过startActivityForResult（）来启动SecondActivity"></a>1.通过<font color="orange">startActivityForResult（）</font>来启动SecondActivity</h4><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915213454637.png" alt="image-20200915213454637"></p>
<h4 id="2-使用setResult（）返回数据"><a href="#2-使用setResult（）返回数据" class="headerlink" title="2.使用setResult（）返回数据"></a>2.使用<font color="orange">setResult（）</font>返回数据</h4><p>​                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915213859847.png" alt="image-20200915213859847"></p>
<h4 id="3-在FirstActivity中重写-onActivityResult（）"><a href="#3-在FirstActivity中重写-onActivityResult（）" class="headerlink" title="3.在FirstActivity中重写 onActivityResult（）"></a>3.在FirstActivity中重写<font color="orange"> onActivityResult（）</font></h4><p>​                <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200915214529345.png" alt="image-20200915214529345"></p>
<ol>
<li>首先通过检查requCode来判断数据来源，（FirstActivity可能调用startActivityForResult()去启动很多不同的活动，每个活动都会回调到活动的onActivityResult()中）。</li>
<li>然后通过resultCode来判断处理结果是否成功（RESULT_OK|RESULT_CANCELED）</li>
<li>最后通过 getStringExtra(键)来获取data携带的数据。</li>
</ol>
<h3 id="六、Bundle与Intent结合传递大量数据"><a href="#六、Bundle与Intent结合传递大量数据" class="headerlink" title="六、Bundle与Intent结合传递大量数据"></a>六、<font color="cornflowerblue">Bundle与Intent结合传递大量数据</font></h3><h4 id="1-传数据"><a href="#1-传数据" class="headerlink" title="1,传数据"></a>1,传数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">bundle.putString(&quot;date_string&quot;,&quot;some thing you just typed&quot;);</span><br><span class="line">bundle.putInt(&quot;data_Int&quot;,256);</span><br><span class="line">Intent intent = new Intent(...);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h4 id="2-取数据"><a href="#2-取数据" class="headerlink" title="2.取数据"></a>2.取数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent  intent = getIntent();</span><br><span class="line">Bundle bundle = indent.getExtres();</span><br><span class="line">String str = bundle.getString(&quot;data_string&quot;);</span><br><span class="line">int in = bundle.getInt(&quot;data_Int&quot;);</span><br></pre></td></tr></table></figure>



<h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><h3 id="一、返回栈"><a href="#一、返回栈" class="headerlink" title="一、返回栈"></a>一、返回栈</h3><p>其实Android是使用任务(Task）来管理活动的，一个任务就是一组存放在栈里的活动的集其实Android是使用任务(Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈(Back Stack )。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中人栈，并处于栈顶的位置。而每当我们按下Back键或调用finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个人栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。</p>
<h3 id="二、活动状态"><a href="#二、活动状态" class="headerlink" title="二、活动状态"></a>二、活动状态</h3><h4 id="1-运行状态"><a href="#1-运行状态" class="headerlink" title="1.运行状态"></a>1.<font color="cornflowerblue">运行状态</font></h4><h5 id="当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。"><a href="#当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。" class="headerlink" title="当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。"></a>当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。</h5><h4 id="2-暂停状态"><a href="#2-暂停状态" class="headerlink" title="2.暂停状态"></a>2.<font color="cornflowerblue">暂停状态</font></h4><h5 id="当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。"><a href="#当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。" class="headerlink" title="当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。"></a>当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。</h5><h4 id="3-停止状态"><a href="#3-停止状态" class="headerlink" title="3.停止状态"></a>3.<font color="cornflowerblue">停止状态</font></h4><h5 id="当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保-存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可-能会被系统回收。"><a href="#当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保-存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可-能会被系统回收。" class="headerlink" title="当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保    存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可    能会被系统回收。"></a>当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保    存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可    能会被系统回收。</h5><h4 id="4-摧毁状态"><a href="#4-摧毁状态" class="headerlink" title="4.摧毁状态"></a>4.<font color="cornflowerblue">摧毁状态</font></h4><h5 id="当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证-手机的内存充足。"><a href="#当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证-手机的内存充足。" class="headerlink" title="当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证    手机的内存充足。"></a>当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证    手机的内存充足。</h5><h3 id="三、活动的生存期"><a href="#三、活动的生存期" class="headerlink" title="三、活动的生存期"></a>三、活动的生存期</h3><h4 id="1-oncCreat-活动第一次被创建时调用"><a href="#1-oncCreat-活动第一次被创建时调用" class="headerlink" title="1.oncCreat(): 活动第一次被创建时调用"></a>1.oncCreat(): 活动第一次被创建时调用</h4><h4 id="2-onStart-在活动由不可见变为可见时调用"><a href="#2-onStart-在活动由不可见变为可见时调用" class="headerlink" title="2.onStart(): 在活动由不可见变为可见时调用"></a>2.onStart(): 在活动由不可见变为可见时调用</h4><h4 id="3-onResume-在活动准备好和用户进行交互时调用"><a href="#3-onResume-在活动准备好和用户进行交互时调用" class="headerlink" title="3.onResume(): 在活动准备好和用户进行交互时调用"></a>3.onResume(): 在活动准备好和用户进行交互时调用</h4><h4 id="4-onPause-在系统准备启动或者恢复另一个活动时调用"><a href="#4-onPause-在系统准备启动或者恢复另一个活动时调用" class="headerlink" title="4.onPause(): 在系统准备启动或者恢复另一个活动时调用"></a>4.onPause(): 在系统准备启动或者恢复另一个活动时调用</h4><h4 id="5-onStop-在活动完全不可见时调用"><a href="#5-onStop-在活动完全不可见时调用" class="headerlink" title="5.onStop(): 在活动完全不可见时调用"></a>5.onStop(): 在活动完全不可见时调用</h4><h4 id="6-onDestory-在活动被销毁时调用"><a href="#6-onDestory-在活动被销毁时调用" class="headerlink" title="6.onDestory(): 在活动被销毁时调用"></a>6.onDestory(): 在活动被销毁时调用</h4><h4 id="7-onRestart-在活动由停止状态变为运行状态时调用"><a href="#7-onRestart-在活动由停止状态变为运行状态时调用" class="headerlink" title="7.onRestart(): 在活动由停止状态变为运行状态时调用"></a>7.onRestart(): 在活动由停止状态变为运行状态时调用</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200919221411685.png" alt="image-20200919221411685" style="zoom: 67%;">

<p>​    完整生存期：onCreate() → onDestory()</p>
<p>​    可见生存期：onStart() → onStop()</p>
<p>​    前台生存期：onResume() → onPause()</p>
<h3 id="四、体验活动的生命周期"><a href="#四、体验活动的生命周期" class="headerlink" title="四、体验活动的生命周期"></a>四、体验活动的生命周期</h3><h4 id="1-新建两个活动分别为-NormalActicity-和-DialogActivity"><a href="#1-新建两个活动分别为-NormalActicity-和-DialogActivity" class="headerlink" title="1.新建两个活动分别为 NormalActicity 和 DialogActivity"></a>1.新建两个活动分别为 NormalActicity 和 DialogActivity</h4><h4 id="2-修改对话框活动的主题："><a href="#2-修改对话框活动的主题：" class="headerlink" title="2.修改对话框活动的主题："></a>2.修改对话框活动的主题：</h4><ol>
<li><h5 id="AppCompatActivity-android-theme-”-style-Theme-AppCompat-Dialog”"><a href="#AppCompatActivity-android-theme-”-style-Theme-AppCompat-Dialog”" class="headerlink" title="AppCompatActivity: android:theme=”@style/Theme.AppCompat.Dialog”"></a><font color="red">AppCompatActivity</font>: <strong>android:theme=”@style/Theme.AppCompat.Dialog”</strong></h5></li>
<li><h5 id="Activity-android-theme-”-android-style-Theme-Dialog”"><a href="#Activity-android-theme-”-android-style-Theme-Dialog”" class="headerlink" title="Activity:android:theme=”@android:style/Theme.Dialog”"></a><font color="red">Activity:android</font>:<strong>theme=”@android:style/Theme.Dialog”</strong></h5></li>
</ol>
<h4 id="3-在主活动中打印日志（充分利用日志过滤器）"><a href="#3-在主活动中打印日志（充分利用日志过滤器）" class="headerlink" title="3.在主活动中打印日志（充分利用日志过滤器）"></a>3.在主活动中打印日志（充分利用日志过滤器）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200919222550069.png" alt="image-20200919222550069"></p>
<h5 id="（1）可以看到，MainActivity-第一次被创建时会依次执行-onCreate-、onStart-和-onResume-方法；"><a href="#（1）可以看到，MainActivity-第一次被创建时会依次执行-onCreate-、onStart-和-onResume-方法；" class="headerlink" title="（1）可以看到，MainActivity 第一次被创建时会依次执行 onCreate()、onStart() 和 onResume()方法；"></a>（1）可以看到，MainActivity 第一次被创建时会依次执行 onCreate()、onStart() 和 onResume()方法；</h5><h5 id="（2）启动NormalActivity-会执行-onPause-和-onStop-因为NormalActivity已经完全遮住MainActivity了；"><a href="#（2）启动NormalActivity-会执行-onPause-和-onStop-因为NormalActivity已经完全遮住MainActivity了；" class="headerlink" title="（2）启动NormalActivity,会执行 onPause() 和 onStop(),因为NormalActivity已经完全遮住MainActivity了；"></a>（2）启动NormalActivity,会执行 onPause() 和 onStop(),因为NormalActivity已经完全遮住MainActivity了；</h5><h5 id="（3）返回MainActivity，会执行-onRestart-、onStart-和onResume"><a href="#（3）返回MainActivity，会执行-onRestart-、onStart-和onResume" class="headerlink" title="（3）返回MainActivity，会执行 onRestart()、onStart()和onResume();"></a>（3）返回MainActivity，会执行 onRestart()、onStart()和onResume();</h5><h5 id="（4）启动DialogActivity-只会执行onPause-方法，因为此时MainActivity没有完全遮住；"><a href="#（4）启动DialogActivity-只会执行onPause-方法，因为此时MainActivity没有完全遮住；" class="headerlink" title="（4）启动DialogActivity,只会执行onPause()方法，因为此时MainActivity没有完全遮住；"></a>（4）启动DialogActivity,只会执行onPause()方法，因为此时MainActivity没有完全遮住；</h5><h5 id="（5）返回MainActivity-只会执行onResume。"><a href="#（5）返回MainActivity-只会执行onResume。" class="headerlink" title="（5）返回MainActivity,只会执行onResume。"></a>（5）返回MainActivity,只会执行onResume。</h5><h3 id="五、活动被回收了怎么办"><a href="#五、活动被回收了怎么办" class="headerlink" title="五、活动被回收了怎么办"></a>五、活动被回收了怎么办</h3><h4 id="1-问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate-创建一个新的实例，造成数据的丢失。"><a href="#1-问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate-创建一个新的实例，造成数据的丢失。" class="headerlink" title="1.问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate()创建一个新的实例，造成数据的丢失。"></a>1.问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate()创建一个新的实例，造成数据的丢失。</h4><h4 id="2-通过onSaveInstanceState-回调方法保存数据"><a href="#2-通过onSaveInstanceState-回调方法保存数据" class="headerlink" title="2.通过onSaveInstanceState()回调方法保存数据"></a>2.通过<font color="red">onSaveInstanceState()</font>回调方法保存数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@0verride</span><br><span class="line">protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">	super.onSaveInstancestate(outState);</span><br><span class="line">	string tempData - &quot;Something you just typed&quot;;</span><br><span class="line">	outState.putString( &quot;data_key&quot; , tempData) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="-3"><a href="#-3" class="headerlink" title></a></h4><h4 id="3-在onCreate-中取值"><a href="#3-在onCreate-中取值" class="headerlink" title="3.在onCreate()中取值"></a>3.在onCreate()中取值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (savedInstancestate != null)&#123;</span><br><span class="line">	String tempData = savedInstanceState.getString(&quot;data_key&quot;);</span><br><span class="line">	Log.d(TAG,tempData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="活动的启动模式-（launchMode"><a href="#活动的启动模式-（launchMode" class="headerlink" title="活动的启动模式 （launchMode)"></a>活动的启动模式 （launchMode)</h2><h3 id="一、standard"><a href="#一、standard" class="headerlink" title="一、standard"></a>一、standard</h3><h4 id="1-standard是活动默认的启动模式"><a href="#1-standard是活动默认的启动模式" class="headerlink" title="1.standard是活动默认的启动模式"></a>1.standard是活动默认的启动模式</h4><p>​        每当启动一个新的活动，它就会在返回栈中人栈，并处于栈顶的位置。对于使用standard模式的活动，</p>
<p>​        系统不会在乎这个活动是否已经在返回栈中存在<font color="red">，每次启动都会创建该活动的一个新的实例</font>。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131226413.png" alt="image-20200922131226413" style="zoom: 67%;"></h4><h3 id="二、singleTop"><a href="#二、singleTop" class="headerlink" title="二、singleTop"></a>二、singleTop</h3><h4 id="1-当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。"><a href="#1-当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。" class="headerlink" title="1.当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。"></a>1.当活动的启动模式指定为singleTop，在启动活动时如果发现<font color="red">返回栈的栈顶已经是该活动</font>，则认为可以<font color="red">直接使用</font>它，不会再创建新的活动实例。</h4><h4 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131614840.png" alt="image-20200922131614840" style="zoom: 67%;"></h4><h3 id="三、singleTask"><a href="#三、singleTask" class="headerlink" title="三、singleTask"></a>三、singleTask</h3><h4 id="1-当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。"><a href="#1-当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。" class="headerlink" title="1.当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。"></a>1.当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则<font color="red">直接使用该实例，并把在这个活动之上的所有活动统统出栈</font>，如果没有发现就会创建一个新的活动实例。</h4><h4 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922131805919.png" alt="image-20200922131805919" style="zoom: 67%;"></h4><h3 id="四、singleInstance"><a href="#四、singleInstance" class="headerlink" title="四、singleInstance"></a>四、singleInstance</h3><h4 id="1-指定为singleInstance的活动会启动一个新的返回栈，"><a href="#1-指定为singleInstance的活动会启动一个新的返回栈，" class="headerlink" title="1.指定为singleInstance的活动会启动一个新的返回栈，"></a>1.指定为singleInstance的活动会启动一个新的返回栈，</h4><p>在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了<font color="red">共享活动实例</font>的问题。</p>
<h4 id="2-3"><a href="#2-3" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922132137611.png" alt="image-20200922132137611" style="zoom:67%;"></h4><h2 id="活动的最佳实践"><a href="#活动的最佳实践" class="headerlink" title="活动的最佳实践"></a>活动的最佳实践</h2><h1 id="第三章-UI开发的点点滴滴"><a href="#第三章-UI开发的点点滴滴" class="headerlink" title="第三章 UI开发的点点滴滴"></a>第三章 UI开发的点点滴滴</h1><h2 id="如何编写程序界面"><a href="#如何编写程序界面" class="headerlink" title="如何编写程序界面"></a>如何编写程序界面</h2><h2 id="常用控件的使用方法"><a href="#常用控件的使用方法" class="headerlink" title="常用控件的使用方法"></a>常用控件的使用方法</h2><h3 id="一、TextView"><a href="#一、TextView" class="headerlink" title="一、TextView"></a>一、<font color="cornflowerblue">TextView</font></h3><h4 id="1-文本对齐方式-gravity"><a href="#1-文本对齐方式-gravity" class="headerlink" title="1.文本对齐方式(gravity)"></a>1.文本对齐方式(<font color="red">gravity</font>)</h4><h5 id="android-gravity-”center-top-bottom-left-right”"><a href="#android-gravity-”center-top-bottom-left-right”" class="headerlink" title="android: gravity=”center|top|bottom|left|right”"></a>android: gravity=”center|top|bottom|left|right”</h5><h4 id="2-文本颜色，大小（textColor、textSize）"><a href="#2-文本颜色，大小（textColor、textSize）" class="headerlink" title="2.文本颜色，大小（textColor、textSize）"></a>2.文本颜色，大小（<font color="red">textColor、textSize</font>）</h4><h5 id="字体以“sp”为单位"><a href="#字体以“sp”为单位" class="headerlink" title="字体以“sp”为单位"></a>字体以“sp”为单位</h5><h4 id="3-文本标签TextView其它的XML文件元素"><a href="#3-文本标签TextView其它的XML文件元素" class="headerlink" title="3.文本标签TextView其它的XML文件元素"></a>3.文本标签TextView其它的XML文件元素</h4><table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:autoLink</td>
<td>设置是否当文本为URL链接/email/电话号码/map时，文本显示为可单击的链接。可选值(none/web/email/phone/map/all)</td>
</tr>
<tr>
<td>android:autoText</td>
<td>如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。</td>
</tr>
<tr>
<td>android:linksClickable</td>
<td>设置链接是否单击连接，即使设置了autoLink。</td>
</tr>
<tr>
<td>android:maxLength</td>
<td>限制显示的文本长度，超出部分不显示。</td>
</tr>
<tr>
<td>android:lines</td>
<td>设置文本的行数，设置两行就显示两行，即使第二行没有数据。</td>
</tr>
<tr>
<td>android:maxLines</td>
<td>设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。</td>
</tr>
<tr>
<td>android:minLines</td>
<td>设置文本的最小行数，与lines类似。</td>
</tr>
<tr>
<td>android:lineSpacingExtra</td>
<td>设置行间距。</td>
</tr>
<tr>
<td>android:lineSpacingMultiplier</td>
<td>设置行间距的倍数。如”1.2”</td>
</tr>
<tr>
<td>android:textColor</td>
<td>设置文本颜色</td>
</tr>
<tr>
<td>android:textColorLink</td>
<td>文字链接的颜色.</td>
</tr>
<tr>
<td>android:textStyle</td>
<td>设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开</td>
</tr>
<tr>
<td>android:maxHeight</td>
<td>设置文本区域的最大高度</td>
</tr>
<tr>
<td>android:minHeight</td>
<td>设置文本区域的最小高度</td>
</tr>
<tr>
<td>android:minWidth</td>
<td>设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。</td>
</tr>
<tr>
<td>android:maxWidth</td>
<td>设置文本区域的最大宽度</td>
</tr>
</tbody></table>
<h3 id="二、Button"><a href="#二、Button" class="headerlink" title="二、Button"></a>二、<font color="cornflowerblue">Button</font></h3><h4 id="1-自动进行大小写转换（textAllCaps"><a href="#1-自动进行大小写转换（textAllCaps" class="headerlink" title="1.自动进行大小写转换（textAllCaps)"></a>1.自动进行大小写转换（<font color="red">textAllCaps</font>)</h4><h5 id="android-textALlCaps-”false-true”"><a href="#android-textALlCaps-”false-true”" class="headerlink" title="android: textALlCaps:”false|true”"></a>android: textALlCaps:”false|true”</h5><h4 id="2-4种事件监听器的注册方式"><a href="#2-4种事件监听器的注册方式" class="headerlink" title="2. 4种事件监听器的注册方式"></a>2. 4种事件监听器的注册方式</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141303023.png" alt="image-20200923141303023" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141336930.png" alt="image-20200923141336930" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141506965.png" alt="image-20200923141506965" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141521823.png" alt="image-20200923141521823" style="zoom:67%;">



<h3 id="三、EditText"><a href="#三、EditText" class="headerlink" title="三、EditText"></a>三、<font color="cornflowerblue">EditText</font></h3><h4 id="1-提示性文字（hint"><a href="#1-提示性文字（hint" class="headerlink" title="1.提示性文字（hint)"></a>1.提示性文字（<font color="red">hint</font>)</h4><h4 id="2-最大行数（maxLines）"><a href="#2-最大行数（maxLines）" class="headerlink" title="2.最大行数（maxLines）"></a>2.最大行数（<font color="red">maxLines</font>）</h4><h4 id="3-密码框（android-inputType-”TextPassword”）"><a href="#3-密码框（android-inputType-”TextPassword”）" class="headerlink" title="3.密码框（android: inputType=”TextPassword”）"></a>3.密码框（<font color="red">android: inputType=”TextPassword”</font>）</h4><h4 id="4-获取文本内容（-getText-toString-）"><a href="#4-获取文本内容（-getText-toString-）" class="headerlink" title="4.获取文本内容（,,, .getText().toString( )  ）"></a>4.获取文本内容（<font color="red">,,, .getText().toString( )</font>  ）</h4><h4 id="5-输入框EditText-其它的XML文件元素"><a href="#5-输入框EditText-其它的XML文件元素" class="headerlink" title="5.输入框EditText 其它的XML文件元素"></a>5.输入框EditText 其它的XML文件元素</h4><table>
<thead>
<tr>
<th><strong>属性名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>android:<strong>imeOptions</strong></td>
<td><strong>设置软键盘的<strong><strong>Enter</strong></strong>键</strong>。有如下值可设置：normal，actionUnspecified，actionNone，actionGo，actionSearch，actionSend，actionNext，actionDone，flagNoExtractUi，flagNoAccessoryAction，flagNoEnterAction。可用’|’设置多个。这里仅设置显示图标之用。</td>
</tr>
<tr>
<td>android:imeActionId</td>
<td>设置IME动作ID，在onEditorAction中捕获判断进行逻辑操作。</td>
</tr>
<tr>
<td>android:imeActionLabel</td>
<td>设置IME动作标签。但是不能保证一定会使用，猜想在输入法扩展的时候应该有用。</td>
</tr>
<tr>
<td>android:<strong>singleLine</strong></td>
<td>设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=”test_ singleLine “ android:singleLine=”true” android:layout_width=”20dp” 将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行</td>
</tr>
<tr>
<td>android:<strong>maxlines</strong></td>
<td>指定 EditText 的最大行数，当输入的内容超过指定最大行数时，文本就会向上滚动，而不继续拉伸EditText</td>
</tr>
</tbody></table>
<h3 id="四、ImageView"><a href="#四、ImageView" class="headerlink" title="四、ImageView"></a>四、<font color="cornflowerblue">ImageView</font></h3><h4 id="1-android-src"><a href="#1-android-src" class="headerlink" title="1.android:src"></a>1.android:src</h4><h4 id="2-android-background"><a href="#2-android-background" class="headerlink" title="2. android:background"></a>2. android:background</h4><h4 id="3-setImageResource-方法"><a href="#3-setImageResource-方法" class="headerlink" title="3.setImageResource()方法"></a>3.setImageResource()方法</h4><h3 id="五、ProgressBar-进度条"><a href="#五、ProgressBar-进度条" class="headerlink" title="五、ProgressBar (进度条)"></a>五、<font color="cornflowerblue">ProgressBar </font>(进度条)</h3><h4 id="1-（控件通用属性）visibility-”visiblle-invisible-gone”"><a href="#1-（控件通用属性）visibility-”visiblle-invisible-gone”" class="headerlink" title="1.（控件通用属性）visibility=”visiblle|invisible|gone”"></a>1.（控件通用属性）<font color="red">visibility</font>=”visiblle|invisible|gone”</h4><h4 id="2-代码中获取-控制控件可见性"><a href="#2-代码中获取-控制控件可见性" class="headerlink" title="2.代码中获取/控制控件可见性"></a>2.代码中获取/控制控件可见性</h4><p>​            获取：getVisibility()</p>
<p>​            设置：setVisibility(<font color="red">View.VISIBLE|View.INVISIBLE|View.GONE</font>)</p>
<h4 id="3-水平进度条"><a href="#3-水平进度条" class="headerlink" title="3.水平进度条"></a>3.水平进度条</h4><h5 id="（1）style-”-android-attr-progressBarStyleHorizontal”-类别"><a href="#（1）style-”-android-attr-progressBarStyleHorizontal”-类别" class="headerlink" title="（1）style=”?android:attr/progressBarStyleHorizontal”    //类别"></a>（1）style=”?android:attr/progressBarStyleHorizontal”    //类别</h5><h5 id="android-max-”100”-进度条最大值"><a href="#android-max-”100”-进度条最大值" class="headerlink" title="android:max=”100”    //进度条最大值"></a>android:max=”100”    //进度条最大值</h5><h5 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922172028074.png" alt="image-20200922172028074" style="zoom:50%;"></h5><h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><h4 id="-4"><a href="#-4" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141825784.png" alt="image-20200923141825784" style="zoom:50%;"></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923141850913.png" alt="image-20200923141850913" style="zoom:50%;">

<h3 id="六、AlterDialog（对话框）"><a href="#六、AlterDialog（对话框）" class="headerlink" title="六、AlterDialog（对话框）"></a>六、<font color="cornflowerblue">AlterDialog</font>（对话框）</h3><h4 id="1-AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog-一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示"><a href="#1-AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog-一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示" class="headerlink" title="1.AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示:"></a>1.AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示:</h4><h4 id="2-4"><a href="#2-4" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922172454707.png" alt="image-20200922172454707" style="zoom:67%;"></h4><p>​            首先通过<font color="red">AlertDialog.Builder</font>创建一个AlertDialog 的实例,然后可以为这个对话框设置标题、<br>​    内容、可否取消等属性，接下来调用<font color="red">setPositiveButton()</font>方法为对话框设置确定按钮的点击<br>​    事件，调用<font color="red">setNegativeButton()</font>方法设置取消按钮的点击事件，最后调用<font color="red">show()</font>方法将对话<br>​    框显示出来。</p>
<h3 id="七、ProgressDialog-带进度条的提示框"><a href="#七、ProgressDialog-带进度条的提示框" class="headerlink" title="七、ProgressDialog(带进度条的提示框)"></a>七、<font color="cornflowerblue">ProgressDialog</font>(带进度条的提示框)</h3><h4 id="1-ProgressDialog-和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog-会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog-也比较相似"><a href="#1-ProgressDialog-和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog-会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog-也比较相似" class="headerlink" title="1.ProgressDialog 和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog 也比较相似"></a>1.ProgressDialog 和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog 也比较相似</h4><h4 id="2-5"><a href="#2-5" class="headerlink" title="2."></a>2.<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20200922173459763.png" alt="image-20200922173459763" style="zoom:67%;"></h4><p>注意，如果在<font color="red">setCancelable()中传人了false</font>，表示ProgressDialog是不能通过Back键<br>取消掉的，这时你就一定要在代码中做好控制，当数据加载完成后必须要调用ProgressDialog 的<br>dismiss()方法来关闭对话框，否则ProgressDialog将会一直存在。</p>
<h3 id="八、RadioButton-单选按钮-和-Checkbox-复选框"><a href="#八、RadioButton-单选按钮-和-Checkbox-复选框" class="headerlink" title="八、RadioButton(单选按钮) 和 Checkbox(复选框)"></a>八、<font color="cornflowerblue">RadioButton(单选按钮) 和 Checkbox(复选框)</font></h3><h3 id="九、Spinner-下拉框"><a href="#九、Spinner-下拉框" class="headerlink" title="九、Spinner (下拉框)"></a>九、<font color="cornflowerblue">Spinner (下拉框)</font></h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142240994.png" alt="image-20200923142240994" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142315034.png" alt="image-20200923142315034" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200923142334764.png" alt="image-20200923142334764" style="zoom:67%;">



<h2 id="详解4种基本布局"><a href="#详解4种基本布局" class="headerlink" title="详解4种基本布局"></a>详解4种基本布局</h2><h3 id="一、线性布局（LinearLayout）"><a href="#一、线性布局（LinearLayout）" class="headerlink" title="一、线性布局（LinearLayout）"></a>一、线性布局（<font color="cornflowerblue">LinearLayout</font>）</h3><h4 id="1-排列方向orientation"><a href="#1-排列方向orientation" class="headerlink" title="1.排列方向orientation"></a>1.排列方向<font color="red">orientation</font></h4><h5 id="1-horizontal-2-vertical"><a href="#1-horizontal-2-vertical" class="headerlink" title="(1)horizontal        (2)vertical"></a>(1)horizontal        (2)vertical</h5><p>​    </p>
<h4 id="2-对齐方式"><a href="#2-对齐方式" class="headerlink" title="2.对齐方式"></a>2.对齐方式</h4><h5 id="（1）gravity-文字在控件中的对齐方式"><a href="#（1）gravity-文字在控件中的对齐方式" class="headerlink" title="（1）gravity: 文字在控件中的对齐方式"></a>（1）gravity: <font color="orange">文字在控件中</font>的对齐方式</h5><h5 id="（2）layout-gravity-控件在布局中的对齐方式"><a href="#（2）layout-gravity-控件在布局中的对齐方式" class="headerlink" title="（2）layout_gravity: 控件在布局中的对齐方式"></a>（2）<font color="red">layout_gravity</font>: <font color="orange">控件在布局中</font>的对齐方式</h5><p>​                top、bottom、left、right、center_vertical、center_horizontal</p>
<p>​        <strong>！注意</strong>：LinearLayout的排列方向是horizontal时，只有垂直方向上的对齐方式才会生效，因为此时    水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式。同样的道理，当LinearLayout的排列方向是vertical时，只有水平方向上的对齐方式才会生效。</p>
<h4 id="3-重要属性-layout-weight"><a href="#3-重要属性-layout-weight" class="headerlink" title="3.重要属性 layout_weight"></a>3.重要属性 <font color="red">layout_weight</font></h4><h5 id="1-允许我们使用比例的方式来指定控件的大小-它在手机屏幕的适配性方面可以起到非常重要"><a href="#1-允许我们使用比例的方式来指定控件的大小-它在手机屏幕的适配性方面可以起到非常重要" class="headerlink" title="(1)允许我们使用比例的方式来指定控件的大小,它在手机屏幕的适配性方面可以起到非常重要"></a>(1)允许我们使用<font color="red">比例的方式</font>来指定控件的大小,它在手机屏幕的适配性方面可以起到非常重要</h5><h5 id="2-定义水平-垂直方向的比例时，需要指定layout-width-”0dp”-layout-height-”0dp”"><a href="#2-定义水平-垂直方向的比例时，需要指定layout-width-”0dp”-layout-height-”0dp”" class="headerlink" title="(2)定义水平/垂直方向的比例时，需要指定layout_width=”0dp”/layout_height=”0dp”"></a>(2)定义水平/垂直方向的比例时，需要指定<font color="red">layout_width=”0dp”/layout_height=”0dp”</font></h5><h5 id="-5"><a href="#-5" class="headerlink" title></a></h5><h3 id="二、相对布局"><a href="#二、相对布局" class="headerlink" title="二、相对布局"></a>二、相对布局</h3><h4 id="1-相对于父布局进行定位"><a href="#1-相对于父布局进行定位" class="headerlink" title="1.相对于父布局进行定位"></a>1.相对于<font color="red">父布局</font>进行定位</h4><table>
<thead>
<tr>
<th align="left"><strong>属性声明</strong></th>
<th align="center"><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>android:layout_alignParentLeft</strong></td>
<td align="center">是否跟父布局左对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentRight</strong></td>
<td align="center">是否跟父布局右对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentTop</strong></td>
<td align="center">是否跟父布局顶部对齐</td>
</tr>
<tr>
<td align="left"><strong>android:layout_alignParentBottom</strong></td>
<td align="center">是否跟父布局底部对齐</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerHorizontal</strong></td>
<td align="center">在父布局中水平居中</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerVertical</strong></td>
<td align="center">在父布局中垂直居中</td>
</tr>
<tr>
<td align="left"><strong>Layout_centerInParent</strong></td>
<td align="center">在父布局的中间位置</td>
</tr>
</tbody></table>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922224343384.png" alt="image-20200922224343384" style="zoom: 33%;">



<h4 id="2-相对于兄弟组件定位"><a href="#2-相对于兄弟组件定位" class="headerlink" title="2.相对于兄弟组件定位"></a>2.相对于<font color="red">兄弟组件</font>定位</h4><p>​        </p>
<table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>android:layout_toRightOf</strong>=“控件id”</td>
<td>在指定控件右边</td>
</tr>
<tr>
<td><strong>android:layout_toLeftOf</strong>=“控件id”</td>
<td>在指定控件左边</td>
</tr>
<tr>
<td><strong>android:layout_above</strong>=“控件id”</td>
<td>在指定控件上边</td>
</tr>
<tr>
<td><strong>android:layout_below=“控件id”</strong></td>
<td>在指定控件下边</td>
</tr>
<tr>
<td><strong>android:layout_alignBaseline</strong>=“控件id”</td>
<td>与指定控件水平对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignLeft</strong>=“控件id”</td>
<td>与指定控件左对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignRight</strong>=“控件id”</td>
<td>与指定控件右对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignTop</strong>=“控件id”</td>
<td>与指定控件顶部对齐</td>
</tr>
<tr>
<td><strong>android:layout_alignBottom</strong>=“控件id”</td>
<td>与指定控件底部对齐</td>
</tr>
</tbody></table>
<h4 id="3-margin-偏移-：设置组件与相对于的边距"><a href="#3-margin-偏移-：设置组件与相对于的边距" class="headerlink" title="3. margin(偏移)：设置组件与相对于的边距"></a>3.<font color="red"> margin(偏移)</font>：设置组件与相对于的边距</h4><table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>layout_margin</strong></td>
<td>设置组件上下左右的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginLeft</strong></td>
<td>设置组件离左边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginRight</strong></td>
<td>设置组件离右边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginTop</strong></td>
<td>设置组件离上边的偏移量</td>
</tr>
<tr>
<td><strong>layout_marginBottom</strong></td>
<td>设置组件离下边的偏移量</td>
</tr>
</tbody></table>
<h4 id="4-padding-填充-：设置组件内部元素间的边距"><a href="#4-padding-填充-：设置组件内部元素间的边距" class="headerlink" title="4.padding(填充)：设置组件内部元素间的边距"></a>4.<font color="red">padding(填充)</font>：设置组件内部元素间的边距</h4><table>
<thead>
<tr>
<th><strong>属性声明</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>padding</strong></td>
<td>设置组件上下左右的偏移量</td>
</tr>
<tr>
<td><strong>paddingLeft</strong></td>
<td>设置组件离左边的偏移量</td>
</tr>
<tr>
<td><strong>paddingRight</strong></td>
<td>设置组件离右边的偏移量</td>
</tr>
<tr>
<td><strong>paddingTop</strong></td>
<td>设置组件离上边的偏移量</td>
</tr>
<tr>
<td><strong>paddingBottom</strong></td>
<td>设置组件离下边的偏移量</td>
</tr>
</tbody></table>
<h5 id="！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。"><a href="#！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。" class="headerlink" title="！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。"></a>！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。</h5><h3 id="三、帧布局"><a href="#三、帧布局" class="headerlink" title="三、帧布局"></a>三、帧布局</h3><h3 id="四、百分百布局"><a href="#四、百分百布局" class="headerlink" title="四、百分百布局"></a>四、百分百布局</h3><h4 id="1-percentFrameLayout-继承了FrameLayout的全部特性"><a href="#1-percentFrameLayout-继承了FrameLayout的全部特性" class="headerlink" title="1.percentFrameLayout: 继承了FrameLayout的全部特性"></a>1.<font color="red">percentFrameLayout</font>: 继承了FrameLayout的全部特性</h4><h4 id="percentRelativeLayout-继承了RelativeLayout的全部特性"><a href="#percentRelativeLayout-继承了RelativeLayout的全部特性" class="headerlink" title="percentRelativeLayout: 继承了RelativeLayout的全部特性"></a><font color="red">percentRelativeLayout</font>: 继承了RelativeLayout的全部特性</h4><h4 id="2-设置组件的宽高"><a href="#2-设置组件的宽高" class="headerlink" title="2.设置组件的宽高"></a>2.设置组件的宽高</h4><h5 id="app-layout-widthPercent-”-”"><a href="#app-layout-widthPercent-”-”" class="headerlink" title="app: layout_widthPercent=”..%”"></a>app: <font color="red">layout_widthPercent</font>=”..%”</h5><h5 id="app-layout-heightPercent-“-”"><a href="#app-layout-heightPercent-“-”" class="headerlink" title="app: layout_heightPercent=“..%”"></a>app: layout_heightPercent=“..%”</h5><h4 id="3-在项目的build-gradle中添加百分比布局库的依赖-保证百分比布局在Android所有系统版本上的兼容性"><a href="#3-在项目的build-gradle中添加百分比布局库的依赖-保证百分比布局在Android所有系统版本上的兼容性" class="headerlink" title="3.在项目的build.gradle中添加百分比布局库的依赖,保证百分比布局在Android所有系统版本上的兼容性"></a>3.在项目的build.gradle中添加百分比布局库的依赖,保证百分比布局在Android所有系统版本上的兼容性</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922230757044.png" alt="image-20200922230757044"></p>
<h4 id="4-使用百分比布局"><a href="#4-使用百分比布局" class="headerlink" title="4.使用百分比布局"></a>4.使用百分比布局</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200922230933563.png" alt="image-20200922230933563"></p>
<h2 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h2><h3 id="1-引入布局"><a href="#1-引入布局" class="headerlink" title="1.引入布局"></a>1.引入布局</h3><h4 id="（1）创建一个标题栏布局title-xml文件"><a href="#（1）创建一个标题栏布局title-xml文件" class="headerlink" title="（1）创建一个标题栏布局title.xml文件"></a>（1）创建一个标题栏布局title.xml文件</h4><h4 id="（2）在活动中引用-lt-include-layout-“-layout-title”-gt"><a href="#（2）在活动中引用-lt-include-layout-“-layout-title”-gt" class="headerlink" title="（2）在活动中引用  &lt;include layout = “@layout/title”/ &gt;"></a>（2）在活动中引用  <font color="red">&lt;include layout = “@layout/title”/ &gt;</font></h4><h4 id="3-隐藏系统自带的标题栏"><a href="#3-隐藏系统自带的标题栏" class="headerlink" title="(3) 隐藏系统自带的标题栏"></a>(3) 隐藏系统自带的标题栏</h4><h4 id="ActionBar-actionbar-getSupportActionBar"><a href="#ActionBar-actionbar-getSupportActionBar" class="headerlink" title="ActionBar actionbar = getSupportActionBar("></a><font color="red">ActionBar actionbar = getSupportActionBar(</font></h4><pre><code>    &lt;font color=&#39;red&#39;&gt;if (actionbar !=null) &#123;&lt;/font&gt;
        &lt;font color=&#39;red&#39;&gt;actionbar.hide( );&lt;/font&gt;
    &lt;font color=&#39;red&#39;&gt;&#125;&lt;/font&gt;
</code></pre>
<h3 id="2-创建自定义控件（布局）"><a href="#2-创建自定义控件（布局）" class="headerlink" title="2.创建自定义控件（布局）"></a>2.创建自定义控件（布局）</h3><h4 id="（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题-但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。"><a href="#（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题-但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。" class="headerlink" title="（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题,但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。"></a>（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题,但是如果布局中有一些控件<font color="red">要求能够响应事件</font>，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用<font color="red">自定义控件</font>的方式来解决。</h4><h4 id="（2）创建一个自定义布局类-TitleLayout-包含组件的响应事件"><a href="#（2）创建一个自定义布局类-TitleLayout-包含组件的响应事件" class="headerlink" title="（2）创建一个自定义布局类 TitleLayout(包含组件的响应事件)"></a>（2）创建一个自定义布局类 TitleLayout(包含组件的响应事件)</h4><p>public class TitleLayout extends LinearLayout {</p>
<p>​    public TitleLayout(Context context，AttributeSet attrs) {<br>​            super(context,attrs);<br>​            <font color="red">LayoutInflater.from(context).inflate(R.layout.title, this);</font>    //动态加载布局文件</p>
<p>​                                                                        //布局id， 父布局</p>
<p>​            Button titleBack = (Button) findViewById(R.id.title_back);<br>​            Button titleEdit = (Button) findViewById(R.id.title_edit);<br>​            titleBack.setOnclickListener(new onclickListener(){<br>​                @override<br>​                public void onclick(View v) {<br>​                        <font color="red">( (Activity) getContext()).finish();</font>    //结束此次活动<br>​                }<br>​            });<br>​            titleEdit.setonclickListener(new OnclickListener() {<br>​                @override<br>​                public void onclick(View v){<br>​                Toast.makeText(getContext()，”You clicked Edit button”,<br>​                Toast.LENGTH_SHORT).show();<br>​                });</p>
<p>​        }</p>
<p>}</p>
<h4 id="3-在布局文件中添加这个自定义控件"><a href="#3-在布局文件中添加这个自定义控件" class="headerlink" title="3.在布局文件中添加这个自定义控件"></a>3.在布局文件中添加这个自定义控件</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20200930140657613.png" alt="image-20200930140657613"></p>
<h5 id="添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我"><a href="#添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我" class="headerlink" title="添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我"></a>添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我</h5><pre><code>们需要指明&lt;font color=&#39;red&#39;&gt;控件的完整类名&lt;/font&gt;，&lt;font color=&#39;red&#39;&gt;包名在这里是不可以省略的&lt;/font&gt;。
</code></pre>
<h2 id="最常用和最难用的控件——ListView"><a href="#最常用和最难用的控件——ListView" class="headerlink" title="最常用和最难用的控件——ListView"></a>最常用和最难用的控件——ListView</h2><h3 id="一、ListView的简单用法"><a href="#一、ListView的简单用法" class="headerlink" title="一、ListView的简单用法"></a>一、ListView的简单用法</h3><h4 id="1-在布局中加入ListView控件"><a href="#1-在布局中加入ListView控件" class="headerlink" title="1.在布局中加入ListView控件"></a>1.在布局中加入ListView控件</h4><p>​        <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193319537.png" alt="image-20201001193319537" style="zoom:67%;"></p>
<h4 id="2-准备数据（M）"><a href="#2-准备数据（M）" class="headerlink" title="2.准备数据（M）"></a>2.准备数据（M）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193518241.png" alt="image-20201001193518241"></p>
<h4 id="3-准备视图（V）"><a href="#3-准备视图（V）" class="headerlink" title="3.准备视图（V）"></a>3.准备视图（V）</h4><h5 id="ListView-listView-ListView-findViewById-R-id-list-view"><a href="#ListView-listView-ListView-findViewById-R-id-list-view" class="headerlink" title="ListView listView = (ListView) findViewById(R.id.list_view);"></a>ListView listView = (ListView) findViewById(R.id.list_view);</h5><h4 id="4-准备适配器-C"><a href="#4-准备适配器-C" class="headerlink" title="4.准备适配器(C)"></a>4.准备适配器(C)</h4><h5 id="ArrayAdapter-lt-String-gt-adapter-new-ArrayAdapter-lt-String-gt-MainActivity-this，-android-R-layout-simple-list-item-1-data"><a href="#ArrayAdapter-lt-String-gt-adapter-new-ArrayAdapter-lt-String-gt-MainActivity-this，-android-R-layout-simple-list-item-1-data" class="headerlink" title="ArrayAdapter&lt; String &gt;  adapter = new ArrayAdapter&lt; String&gt;(MainActivity.this，            android.R.layout.simple_list_item_1, data);"></a>ArrayAdapter&lt; String &gt;  adapter = new ArrayAdapter&lt; String&gt;(MainActivity.this，            android.R.layout.simple_list_item_1, data);</h5><ul>
<li>​    <font color="red">参数一：当前活动上下文</font></li>
<li>​    <font color="red">参数二：子项布局ID</font></li>
<li>​    <font color="red">参数三：数据数组</font></li>
</ul>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001193946230.png" alt="image-20201001193946230" style="zoom:67%;">



<h3 id="二、定制ListView的界面"><a href="#二、定制ListView的界面" class="headerlink" title="二、定制ListView的界面"></a>二、定制ListView的界面</h3><h4 id="1-新建一个Fruit类，作为适配器的适配类型"><a href="#1-新建一个Fruit类，作为适配器的适配类型" class="headerlink" title="1.新建一个Fruit类，作为适配器的适配类型"></a>1.新建一个Fruit类，作为适配器的<font color="cornflowerblue">适配类型</font></h4><p>​    public class Fruit {<br>​            private String name;<br>​            private int imageId;</p>
<p>​            public Fruit(String name，int imageId) {<br>​                    this.name = name;<br>​                    this.imageId = imageId;<br>​            }<br>​            public String getName( ) {<br>​                    return name;</p>
<p>​            }</p>
<p>​            public int getImageId( ) {<br>​                    return imageId;</p>
<p>​            }</p>
<p>​    }</p>
<h4 id="2-自定义子项布局fruit-item-xml"><a href="#2-自定义子项布局fruit-item-xml" class="headerlink" title="2.自定义子项布局fruit_item.xml"></a>2.<font color="cornflowerblue">自定义子项布局</font>fruit_item.xml</h4><h5 id="-6"><a href="#-6" class="headerlink" title></a></h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201001194813625.png" alt="image-20201001194813625" style="zoom:67%;">



<h4 id="3-自定义适配器MyAdapter"><a href="#3-自定义适配器MyAdapter" class="headerlink" title="3.自定义适配器MyAdapter"></a>3.<font color="cornflowerblue">自定义适配器</font>MyAdapter</h4><p>​    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001195642103.png" alt="image-20201001195642103"></p>
<p>​    <img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001195931382.png" alt="image-20201001195931382"></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200025598.png" alt="image-20201001200025598" style="zoom:67%;">

<h4 id="-7"><a href="#-7" class="headerlink" title></a></h4><h4 id="4-初始化数据，创建数据列表"><a href="#4-初始化数据，创建数据列表" class="headerlink" title="4.初始化数据，创建数据列表"></a>4.初始化数据，创建数据列表</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200303132.png" alt="image-20201001200303132" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201001200312627.png" alt="image-20201001200312627" style="zoom: 80%;">



<h3 id="四、提升ListView的运行效率"><a href="#四、提升ListView的运行效率" class="headerlink" title="四、提升ListView的运行效率"></a>四、提升ListView的运行效率</h3><h4 id="1-重用convertView"><a href="#1-重用convertView" class="headerlink" title="1.重用convertView"></a>1.重用<font color="red">convertView</font></h4><h3 id="-8"><a href="#-8" class="headerlink" title></a><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201004105237701.png" alt="image-20201004105237701" style="zoom: 80%;"></h3><h4 id="2-内部类ViewHolder对控件实例进行缓存"><a href="#2-内部类ViewHolder对控件实例进行缓存" class="headerlink" title="2.内部类ViewHolder对控件实例进行缓存"></a>2.内部类ViewHolder对控件实例进行缓存</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004105406460.png" alt="image-20201004105406460" style="zoom:80%;">

<h2 id="更强大的滚轮控件——RecyclerView"><a href="#更强大的滚轮控件——RecyclerView" class="headerlink" title="更强大的滚轮控件——RecyclerView"></a>更强大的滚轮控件——RecyclerView</h2><h3 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h3><h4 id="1-首先需要在项目的build-gradle中添加相应的依赖库"><a href="#1-首先需要在项目的build-gradle中添加相应的依赖库" class="headerlink" title="1.首先需要在项目的build.gradle中添加相应的依赖库"></a>1.首先需要在项目的build.gradle中添加相应的<font color="red">依赖库</font></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004130717161.png" alt="image-20201004130717161" style="zoom:80%;">

<h4 id="2-在布局中引用"><a href="#2-在布局中引用" class="headerlink" title="2.在布局中引用"></a>2.在布局中引用</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004130855069.png" alt="image-20201004130855069" style="zoom:80%;">



<h4 id="3-准备Fruit类、fruit-item-xml、"><a href="#3-准备Fruit类、fruit-item-xml、" class="headerlink" title="3.准备Fruit类、fruit_item.xml、"></a>3.准备Fruit类、fruit_item.xml、</h4><h4 id="4-为RecycleView准备一个适配器FruitAdapter-继承自RecyclerView-Adapter-并将泛型指定为FruitAdapter-ViewHolder"><a href="#4-为RecycleView准备一个适配器FruitAdapter-继承自RecyclerView-Adapter-并将泛型指定为FruitAdapter-ViewHolder" class="headerlink" title="4.为RecycleView准备一个适配器FruitAdapter,继承自RecyclerView.Adapter,并将泛型指定为FruitAdapter.ViewHolder"></a>4.为RecycleView准备一个适配器<font color="red">FruitAdapter</font>,继承自<font color="cornflowerblue">RecyclerView.Adapter,</font>并将泛型指定为<font color="cornflowerblue">FruitAdapter.ViewHolder</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004132129131.png" alt="image-20201004132129131"></p>
<h4 id="5-在活动中使用RecyclerView"><a href="#5-在活动中使用RecyclerView" class="headerlink" title="5.在活动中使用RecyclerView"></a>5.在活动中使用RecyclerView</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004160217803.png" alt="image-20201004160217803" style="zoom:80%;">

<h3 id="二、实现横向滚动和瀑布流布局"><a href="#二、实现横向滚动和瀑布流布局" class="headerlink" title="二、实现横向滚动和瀑布流布局"></a>二、实现横向滚动和瀑布流布局</h3><h4 id="1-横向滚动"><a href="#1-横向滚动" class="headerlink" title="1.横向滚动"></a>1.横向滚动</h4><h5 id="layoutManager-setOrientation-LineatLayoutManager-HORIZONTAL"><a href="#layoutManager-setOrientation-LineatLayoutManager-HORIZONTAL" class="headerlink" title="layoutManager.setOrientation(LineatLayoutManager.HORIZONTAL);"></a>layoutManager.<font color="red">setOrientation(LineatLayoutManager.HORIZONTAL);</font></h5><h4 id="2-瀑布流布局-StaggeredGridLayoutManager"><a href="#2-瀑布流布局-StaggeredGridLayoutManager" class="headerlink" title="2.瀑布流布局 StaggeredGridLayoutManager"></a>2.瀑布流布局 <font color="cornflowerblue">StaggeredGridLayoutManager</font></h4><h5 id="StaggeredGridLayoutManager-layoutManager-new-StaggeredGridLayoutManager-3-StaggeredGridLayoutManager-VERTICAL"><a href="#StaggeredGridLayoutManager-layoutManager-new-StaggeredGridLayoutManager-3-StaggeredGridLayoutManager-VERTICAL" class="headerlink" title="StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager (3, StaggeredGridLayoutManager.VERTICAL);"></a>StaggeredGridLayoutManager layoutManager = new <font color="red">StaggeredGridLayoutManager (3, StaggeredGridLayoutManager.VERTICAL)</font>;</h5><h5 id="recycleView-setLayoutManager-layoutManager"><a href="#recycleView-setLayoutManager-layoutManager" class="headerlink" title="recycleView.setLayoutManager(layoutManager);"></a>recycleView.setLayoutManager(layoutManager);</h5><p>​        </p>
<p>​    小技巧：设置不同长度文本</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004161014946.png" alt="image-20201004161014946" style="zoom:80%;">



<h3 id="三、RecyclerView的点击事件"><a href="#三、RecyclerView的点击事件" class="headerlink" title="三、RecyclerView的点击事件"></a>三、RecyclerView的点击事件</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201004161141203.png" alt="image-20201004161141203"></p>
<h1 id="第四章-探究碎片"><a href="#第四章-探究碎片" class="headerlink" title="第四章 探究碎片"></a>第四章 探究碎片</h1><h2 id="碎片是什么"><a href="#碎片是什么" class="headerlink" title="碎片是什么"></a>碎片是什么</h2><h2 id="碎片的使用方式"><a href="#碎片的使用方式" class="headerlink" title="碎片的使用方式"></a>碎片的使用方式</h2><h3 id="一、静态使用Fragment"><a href="#一、静态使用Fragment" class="headerlink" title="一、静态使用Fragment"></a>一、<font color="cornflowerblue">静态使用</font>Fragment</h3><h4 id="1-这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。"><a href="#1-这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。" class="headerlink" title="1. 这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。"></a>1. 这是使用Fragment最简单的一种方式，把Fragment当成<font color="red">普通的控件</font>，直接写在Activity的布局文件中。</h4><h4 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h4><h5 id="（1）创建碎片布局文件-fragment-master-xml"><a href="#（1）创建碎片布局文件-fragment-master-xml" class="headerlink" title="（1）创建碎片布局文件 fragment_master.xml"></a>（1）创建碎片布局文件 <font color="orange">fragment_master.xml</font></h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153418988.png" alt="image-20201013153418988" style="zoom:80%;">

<h5 id="（2）创建碎片类MasterFragment-Java"><a href="#（2）创建碎片类MasterFragment-Java" class="headerlink" title="（2）创建碎片类MasterFragment.Java"></a>（2）创建碎片类<font color="orange">MasterFragment.Java</font></h5><p>​        使用inflater.inflate适配布局。实际应用中，也可以添加动态获取信息，绑定到布局控件中。</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153554997.png" alt="image-20201013153554997" style="zoom:80%;">

<p>​        ！补充：（1）（2）也可以通过<font color="red">向导新建</font>来实现</p>
<h5 id="（3）在布局文件中直接用创建好的Fragment控件"><a href="#（3）在布局文件中直接用创建好的Fragment控件" class="headerlink" title="（3）在布局文件中直接用创建好的Fragment控件"></a>（3）在布局文件中直接用创建好的Fragment控件</h5><p>​        要通过android:name 属性来显示的<font color="red">指明要添加的碎片类名</font></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013153856622.png" alt="image-20201013153856622" style="zoom:80%;">



<h3 id="二、动态添加Fragment"><a href="#二、动态添加Fragment" class="headerlink" title="二、动态添加Fragment"></a>二、<font color="cornflowerblue">动态添加</font>Fragment</h3><h4 id="1-程序运行时根据具体情况，动态地添加Fragment到Activity活动中。"><a href="#1-程序运行时根据具体情况，动态地添加Fragment到Activity活动中。" class="headerlink" title="1.程序运行时根据具体情况，动态地添加Fragment到Activity活动中。"></a>1.程序运行时根据具体情况，<font color="red">动态地添加</font>Fragment到Activity活动中。</h4><h4 id="2-Fragment事务："><a href="#2-Fragment事务：" class="headerlink" title="2.Fragment事务："></a>2.<font color="orange">Fragment事务</font>：</h4><h5 id="（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。"><a href="#（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。" class="headerlink" title="（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。"></a>（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。</h5><pre><code>    （2）Android提供了&lt;font color=&#39;pink&#39;&gt;FragmentManager类&lt;/font&gt;管理Fragment：
    在Activity运行过程中，通过FragmentManager开启事务，通过调用&lt;font color=&#39;red&#39;&gt;add()，remove(), replace()&lt;/font&gt;实        现动态添加、删除、替换Fragement。
    FragmentManager使用&lt;font color=&#39;pink&#39;&gt;FragmentTransaction类&lt;/font&gt;来管理事务
</code></pre>
<h4 id="3-实现步骤"><a href="#3-实现步骤" class="headerlink" title="3.实现步骤"></a>3.实现步骤</h4><h5 id="（1）在上例基础上，新建一个碎片布局-fragment-another-xml及其类AnotherFragment-java"><a href="#（1）在上例基础上，新建一个碎片布局-fragment-another-xml及其类AnotherFragment-java" class="headerlink" title="（1）在上例基础上，新建一个碎片布局 fragment_another.xml及其类AnotherFragment.java"></a>（1）在上例基础上，新建一个碎片布局 fragment_another.xml及其类AnotherFragment.java</h5><h5 id="（2）修改MainActivity的布局文件acitivty-main-xml"><a href="#（2）修改MainActivity的布局文件acitivty-main-xml" class="headerlink" title="（2）修改MainActivity的布局文件acitivty_main.xml:"></a>（2）修改MainActivity的布局文件acitivty_main.xml:</h5><p>​            将右侧碎片替换成一个<font color="red">FrameLayout</font>布局。<br>​            <font color="orange">动态加载碎片时需要指定容器，一般使用FrameLayout。</font><br>​            随后可在代码中向FrameLayout中动态地添加碎片，在第一次运行时加载DetailFragement，单击按            钮后加载AnotherFragment</p>
<p>​        </p>
<h5 id="（3）在代码证动态加载碎片控件"><a href="#（3）在代码证动态加载碎片控件" class="headerlink" title="（3）在代码证动态加载碎片控件"></a>（3）在代码证动态加载碎片控件</h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155307418.png" alt="image-20201013155307418" style="zoom: 67%;">



<p>​        或者</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155506638.png" alt="image-20201013155506638" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013155515431.png" alt="image-20201013155515431" style="zoom:80%;">

<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201013160047336.png" alt="image-20201013160047336"></p>
<h4 id="4-在碎片中模拟返回栈"><a href="#4-在碎片中模拟返回栈" class="headerlink" title="4.在碎片中模拟返回栈"></a>4.在碎片中模拟返回栈</h4><h5 id="addToBackStack-用于将一个事务添加到返回栈"><a href="#addToBackStack-用于将一个事务添加到返回栈" class="headerlink" title="addToBackStack()用于将一个事务添加到返回栈"></a><font color="red">addToBackStack()</font>用于将一个事务添加到返回栈</h5><h4 id="5-碎片和活动之间进行通信"><a href="#5-碎片和活动之间进行通信" class="headerlink" title="5.碎片和活动之间进行通信"></a>5.碎片和活动之间进行通信</h4><h5 id="（1）在活动中获取碎片实例："><a href="#（1）在活动中获取碎片实例：" class="headerlink" title="（1）在活动中获取碎片实例："></a>（1）<font color="cornflowerblue">在活动中获取碎片实例：</font></h5><p>FramengtManager fm = getSupportFramengtManager();<br>DetailFragment frag = (DetailFragment)fm.<font color="red">findFragmentById</font>(R.id.fragment_detail);</p>
<h5 id="（2）在碎片中访问活动中的方法："><a href="#（2）在碎片中访问活动中的方法：" class="headerlink" title="（2）在碎片中访问活动中的方法："></a>（2）<font color="cornflowerblue">在碎片中访问活动中的方法：</font></h5><p>在碎片中直接通过调用getActivity()方法获得和当前碎片相关联的活动实例，例如：<br>MainActivity activity = (MainActivity)<font color="red">getActivity()</font>;</p>
<h2 id="碎片的生命周期"><a href="#碎片的生命周期" class="headerlink" title="碎片的生命周期"></a>碎片的生命周期</h2><h3 id="一、碎片的状态"><a href="#一、碎片的状态" class="headerlink" title="一、碎片的状态"></a>一、碎片的状态</h3><h4 id="1-运行状态："><a href="#1-运行状态：" class="headerlink" title="1.运行状态："></a>1.运行状态：</h4><p>当嵌入该Fragment的Activity是处于运行状态的，并且该Fragment是可见的，那么该Fragment是处于运行状态的。</p>
<h4 id="2-暂停状态："><a href="#2-暂停状态：" class="headerlink" title="2.暂停状态："></a>2.暂停状态：</h4><p>当嵌入该Fragment的Activity是处于暂停状态时，那么该Fragment也是处于暂停状态的。</p>
<h4 id="3-停止状态："><a href="#3-停止状态：" class="headerlink" title="3.停止状态："></a>3.停止状态：</h4><p>当嵌入该Fragment的Activity是处于停止状态时，那么该Fragment也会进入停止状态。<br>或者通过调用FragmentTransation的remove()、replace()方法将Fragment从Activity中移除，但如果在事务提交前调用addToBackStack()方法添加到返回栈，这时的碎片进入到停止状态。进入停止状态的碎片有可能被系统回收。但在回收前如果又被置于前台(从返回栈中返回)，将不需要被创建。</p>
<h4 id="4-销毁状态："><a href="#4-销毁状态：" class="headerlink" title="4.销毁状态："></a>4.销毁状态：</h4><p>当嵌入该Fragment的Activity是被销毁时，该Fragment进入到销毁状态。<br>或者通过调用FragmentTransation的remove()、replace()方法将Fragment从Activity中移除，但在事务提交前没有调用addToBackStack()方法添加到返回栈，这时的碎片进行到销毁状态。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194148649.png" alt="image-20201014194148649" style="zoom: 50%;"><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194253899.png" alt="image-20201014194253899" style="zoom: 67%;"></p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014194329244.png" alt="image-20201014194329244" style="zoom:67%;">



<h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><h3 id="layout-large-文件夹"><a href="#layout-large-文件夹" class="headerlink" title="layout - large 文件夹"></a>layout <font color="red">- large</font> 文件夹</h3><h3 id="layout-sw600dp文件夹"><a href="#layout-sw600dp文件夹" class="headerlink" title="layout - sw600dp文件夹"></a>layout<font color="red"> - sw600dp</font>文件夹</h3><h2 id="简易版的新闻应用"><a href="#简易版的新闻应用" class="headerlink" title="简易版的新闻应用"></a>简易版的新闻应用</h2><h3 id="一、准备一个新闻实体类-News-java"><a href="#一、准备一个新闻实体类-News-java" class="headerlink" title="一、准备一个新闻实体类 News.java"></a>一、准备一个新闻实体类 <font color="cornflowerblue">News.java</font></h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201014194855870.png" alt="image-20201014194855870" style="zoom:67%;">

<h3 id="二、接着新建布局文件news-content-frag-xml，用于作为内容碎片类的布局"><a href="#二、接着新建布局文件news-content-frag-xml，用于作为内容碎片类的布局" class="headerlink" title="二、接着新建布局文件news_content_frag.xml，用于作为内容碎片类的布局"></a>二、接着新建布局文件<font color="cornflowerblue">news_content_frag.xml</font>，用于作为<font color="cornflowerblue">内容碎片类</font>的布局</h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195315804.png" alt="image-20201014195315804" style="zoom:67%;">



<h3 id="三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment"><a href="#三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment" class="headerlink" title="三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment"></a>三、然后再新建一个<font color="cornflowerblue">内容碎片类NewsContentFragment</font>，继承自Fragment</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195546698.png" alt="image-20201014195546698"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014195955104.png" alt="image-20201014195955104"></p>
<h3 id="四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击-com-example-fragmentbestpractice"><a href="#四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击-com-example-fragmentbestpractice" class="headerlink" title="四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击 com.example.fragmentbestpractice"></a>四、这样我们就把<font color="cornflowerblue">新闻内容的碎片和布局都创建好了</font>，但是它们都是在双页模式中使用的，如果<font color="red">想在单页模式中使用</font>的话，我们还需要再创建一个活动。右击 com.example.fragmentbestpractice</h3><p>包→New→Activity-→Empty Activity，新建一个NewsContentActivity，并将布局名指定成<br>news_content，然后修改news_content.xml中的代码，如下所示:</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014200437146.png" alt="image-20201014200437146"></p>
<h3 id="五、然后修改NewsContentActivity中的代码，如下所示"><a href="#五、然后修改NewsContentActivity中的代码，如下所示" class="headerlink" title="五、然后修改NewsContentActivity中的代码，如下所示:"></a>五、然后修改<font color="cornflowerblue">NewsContentActivity</font>中的代码，如下所示:</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014201305152.png" alt="image-20201014201305152"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014201739780.png" alt="image-20201014201739780"></p>
<h3 id="六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news-title-frag-xml"><a href="#六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news-title-frag-xml" class="headerlink" title="六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news title frag.xml"></a>六、接下来还需要再创建一个用于显示<font color="cornflowerblue">新闻列表碎片类的布局</font>，新建<font color="cornflowerblue">news title frag.xml</font></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202002701.png" alt="image-20201014202002701"></p>
<h3 id="七、新建news-item-xml作为RecyclerView子项的布局"><a href="#七、新建news-item-xml作为RecyclerView子项的布局" class="headerlink" title="七、新建news_item.xml作为RecyclerView子项的布局"></a>七、新建<font color="cornflowerblue">news_item.xml</font>作为RecyclerView子项的布局</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202257283.png" alt="image-20201014202257283"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014202303375.png" alt="image-20201014202303375"></p>
<h3 id="八、既然新闻列表和子项的布局都已经创建好了-那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示"><a href="#八、既然新闻列表和子项的布局都已经创建好了-那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示" class="headerlink" title="八、既然新闻列表和子项的布局都已经创建好了,那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示:"></a>八、既然新闻列表和子项的布局都已经创建好了,那么接下来我们就需要一个用于展示新闻列表的地方。这里新建<font color="cornflowerblue">NewsTitleFragment</font>作为<font color="cornflowerblue">新闻列表的碎片类</font>，代码如下所示:</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014203519438.png" alt="image-20201014203519438"></p>
<h3 id="九、创建两个模式的主活动布局"><a href="#九、创建两个模式的主活动布局" class="headerlink" title="九、创建两个模式的主活动布局"></a>九、创建两个模式的<font color="cornflowerblue">主活动布局</font></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014203644781.png" alt="image-20201014203644781"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014204051184.png" alt="image-20201014204051184"></p>
<h3 id="十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示"><a href="#十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示" class="headerlink" title="十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示:"></a>十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中<font color="cornflowerblue">新建一个内部类NewsAdapter</font>来作为RecyclerView的<font color="cornflowerblue">适配器</font>，如下所示:</h3><h4 id="（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）"><a href="#（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）" class="headerlink" title="（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）"></a><font color="red">（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）</font></h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014205746854.png" alt="image-20201014205746854" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210158025.png" alt="image-20201014210158025" style="zoom: 67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210210198.png" alt="image-20201014210210198" style="zoom:67%;">



<h3 id="十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示"><a href="#十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示" class="headerlink" title="十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示:"></a>十一、现在还剩最后一步收尾工作，就是向RecyclerView中<font color="cornflowerblue">填充数据</font>了。修改NewsTitle-Fragment中的代码，如下所示:</h3><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210535588.png" alt="image-20201014210535588" style="zoom:67%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201014210606503.png" alt="image-20201014210606503" style="zoom:67%;">







<h1 id="第五章-全局大喇叭——详解广播机制"><a href="#第五章-全局大喇叭——详解广播机制" class="headerlink" title="第五章 全局大喇叭——详解广播机制"></a>第五章 全局大喇叭——详解广播机制</h1><h2 id="广播机制简介"><a href="#广播机制简介" class="headerlink" title="广播机制简介"></a>广播机制简介</h2><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117133937067.png" alt="image-20201117133937067"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117134653797.png" alt="image-20201117134653797"></p>
<h3 id="一、一种传输信息的机制"><a href="#一、一种传输信息的机制" class="headerlink" title="一、一种传输信息的机制"></a>一、一种传输信息的机制</h3><h4 id="广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。"><a href="#广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。" class="headerlink" title="广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。"></a>广播消息可以是<font color="red">应用程序的数据信息</font>，也可以是<font color="red">Android的系统消息</font>，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。</h4><h4 id="Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。"><a href="#Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。" class="headerlink" title="Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。"></a>Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。</h4><h4 id="接收广播需要专门的广播接收器（Broadcast-Reciever）。"><a href="#接收广播需要专门的广播接收器（Broadcast-Reciever）。" class="headerlink" title="接收广播需要专门的广播接收器（Broadcast Reciever）。"></a>接收广播需要专门的广播接收器（Broadcast Reciever）。</h4><h4 id="广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。"><a href="#广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。" class="headerlink" title="广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。"></a>广播接收器通过<font color="red">设置好的过滤器</font>监听特定的广播消息然后进行响应。</h4><h3 id="二、广播的类型"><a href="#二、广播的类型" class="headerlink" title="二、广播的类型"></a>二、广播的类型</h3><h4 id="1-标准广播"><a href="#1-标准广播" class="headerlink" title="1.标准广播"></a>1.<font color="cornflowerblue">标准广播</font></h4><p>​        异步执行。在广播发出之后，所有的广播接收器都会在同一时刻接收到这条广播消息。</p>
<h4 id="2-有序广播"><a href="#2-有序广播" class="headerlink" title="2.有序广播"></a>2.有序广播</h4><h5 id="同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。"><a href="#同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。" class="headerlink" title="同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。"></a>同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。</h5><h5 id="广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。"><a href="#广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。" class="headerlink" title="广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。"></a>广播接收器是有先后顺序，<font color="red">优先级</font>高的广播接收器就可以先收到广播消息。</h5><h5 id="优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。"><a href="#优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。" class="headerlink" title="优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。"></a>优先级高的广播接收器可以<font color="red">截断</font>正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。</h5><h2 id="BroadcastReceiver介绍"><a href="#BroadcastReceiver介绍" class="headerlink" title="BroadcastReceiver介绍"></a>BroadcastReceiver介绍</h2><h3 id="一、BroadcastReceiver"><a href="#一、BroadcastReceiver" class="headerlink" title="一、BroadcastReceiver"></a>一、BroadcastReceiver</h3><h4 id="1-本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。"><a href="#1-本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。" class="headerlink" title="1.本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。"></a>1.本质上是一种<font color="red">全局监听器</font>，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。</h4><h4 id="2-BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如："><a href="#2-BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如：" class="headerlink" title="2. BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如："></a>2. BroadcastReceiver用于<font color="red">接收指定的广播</font>，通过<font color="red">设置过滤器</font>监听感兴趣的广播消息后进行响应，例如：</h4><p>启动Activity作为响应，或者通过NotificationManager提醒用户，或者启动Service等等。<br>自身并不实现图形用户界面。</p>
<h3 id="二、Broadcast开发过程"><a href="#二、Broadcast开发过程" class="headerlink" title="二、Broadcast开发过程"></a>二、Broadcast开发过程</h3><h4 id="1-定义广播接收器"><a href="#1-定义广播接收器" class="headerlink" title="1.定义广播接收器"></a>1.<font color="cornflowerblue">定义广播接收器</font></h4><h5 id="继承BroadcastReceiver基类，实现onReceiver方法："><a href="#继承BroadcastReceiver基类，实现onReceiver方法：" class="headerlink" title="继承BroadcastReceiver基类，实现onReceiver方法："></a>继承BroadcastReceiver基类，实现onReceiver方法：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135128320.png" alt="image-20201117135128320"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135631266.png" alt="image-20201117135631266"></p>
<h4 id="2-注册广播接收器"><a href="#2-注册广播接收器" class="headerlink" title="2.注册广播接收器"></a>2.<font color="cornflowerblue">注册广播接收器</font></h4><h5 id="（1）静态注册："><a href="#（1）静态注册：" class="headerlink" title="（1）静态注册："></a>（1）<font color="red">静态注册</font>：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135302391.png" alt="image-20201117135302391"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140345059.png" alt="image-20201117140345059"></p>
<h5 id="（2）动态注册：（可定义为内部类）"><a href="#（2）动态注册：（可定义为内部类）" class="headerlink" title="（2）动态注册：（可定义为内部类）"></a>（2）<font color="red">动态注册</font>：（可定义为内部类）</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117135729313.png" alt="image-20201117135729313"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140330496.png" alt="image-20201117140330496"></p>
<h4 id="3-BroadcastReceiver响应"><a href="#3-BroadcastReceiver响应" class="headerlink" title="3.BroadcastReceiver响应"></a>3.BroadcastReceiver响应</h4><h5 id="（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive-方法，onReceive-方法执行完后，BroadcastReceiver的实例就会被销毁。"><a href="#（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive-方法，onReceive-方法执行完后，BroadcastReceiver的实例就会被销毁。" class="headerlink" title="（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive()方法，onReceive()方法执行完后，BroadcastReceiver的实例就会被销毁。"></a>（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并<font color="orange">自动触发它的onReceive()方法</font>，onReceive()方法执行完后，BroadcastReceiver的实例就会<font color="orange">被销毁</font>。</h5><h5 id="（2）-如果BroadcastReceiver的onReceive-方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive-方法里执行一些耗时的操作，否则会弹出ANR（Application-No-Response）对话框。"><a href="#（2）-如果BroadcastReceiver的onReceive-方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive-方法里执行一些耗时的操作，否则会弹出ANR（Application-No-Response）对话框。" class="headerlink" title="（2） 如果BroadcastReceiver的onReceive()方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive()方法里执行一些耗时的操作，否则会弹出ANR（Application No Response）对话框。"></a>（2） 如果BroadcastReceiver的onReceive()方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive()方法里执行一些耗时的操作，否则会弹出ANR（Application No Response）对话框。</h5><h2 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h2><h3 id="一、标准广播："><a href="#一、标准广播：" class="headerlink" title="一、标准广播："></a>一、标准广播：</h3><h4 id="1-是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast-Intent的传播。"><a href="#1-是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast-Intent的传播。" class="headerlink" title="1.是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播。"></a>1.是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播。</h4><h4 id="2-Intent-intent-new-Intent-“com-example-broadcasttest-MY-BROADCAST”"><a href="#2-Intent-intent-new-Intent-“com-example-broadcasttest-MY-BROADCAST”" class="headerlink" title="2. Intent intent = new Intent(“com.example.broadcasttest.MY_BROADCAST”);"></a>2. Intent intent = new Intent(“com.example.broadcasttest.MY_BROADCAST”);</h4><h4 id="sendBroadcast-intent"><a href="#sendBroadcast-intent" class="headerlink" title="sendBroadcast(intent);"></a><font color="red">sendBroadcast(intent);</font></h4><p>​            </p>
<h3 id="二、有序广播："><a href="#二、有序广播：" class="headerlink" title="二、有序广播："></a>二、有序广播：</h3><h4 id="1-该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast-方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras-Bundle-bundle-方法）。"><a href="#1-该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast-方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras-Bundle-bundle-方法）。" class="headerlink" title="1.该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast()方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras(Bundle bundle)方法）。"></a>1.该广播的接收者将<font color="red">按预先声明的优先级</font>依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast()方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras(Bundle bundle)方法）。</h4><h4 id="2-Intent-intent-new-Intent-“iet-jxufe-cn-android-OrderedBroadcastTest”"><a href="#2-Intent-intent-new-Intent-“iet-jxufe-cn-android-OrderedBroadcastTest”" class="headerlink" title="2. Intent intent=new Intent(“iet.jxufe.cn.android.OrderedBroadcastTest”);"></a>2. Intent intent=new Intent(“iet.jxufe.cn.android.OrderedBroadcastTest”);</h4><pre><code>        &lt;font color=&#39;red&#39;&gt;endOrderedBroadcast(intent,null);&lt;/font&gt;
    3.优先级设置
</code></pre>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117140951277.png" alt="image-20201117140951277"></p>
<h2 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h2><h3 id="一、Android本地广播机制："><a href="#一、Android本地广播机制：" class="headerlink" title="一、Android本地广播机制："></a>一、Android本地广播机制：</h3><h4 id="广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播"><a href="#广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播" class="headerlink" title="广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播"></a>广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播</h4><h4 id="方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。"><a href="#方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。" class="headerlink" title="方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。"></a>方法：使用<font color="cornflowerblue">LocalBroadcastManager</font>对广播进行管理，对发送广播和注册广播接收器进行管理。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117141401456.png" alt="image-20201117141401456"></p>
<h1 id="第六章-数据存储全方案–持久化技术"><a href="#第六章-数据存储全方案–持久化技术" class="headerlink" title="第六章 数据存储全方案–持久化技术"></a>第六章 数据存储全方案–持久化技术</h1><h2 id="持久化技术简介"><a href="#持久化技术简介" class="headerlink" title="持久化技术简介"></a>持久化技术简介</h2><h3 id="1-数据存储方式"><a href="#1-数据存储方式" class="headerlink" title="1.数据存储方式"></a>1.数据存储方式</h3><ul>
<li><font color="red">文件存储</font></li>
<li><font color="red">SharedPreferences</font></li>
<li><font color="red">SQLite数据库</font></li>
</ul>
<h3 id="2-Android内部存储和外部存储"><a href="#2-Android内部存储和外部存储" class="headerlink" title="2.Android内部存储和外部存储"></a>2.Android内部存储和外部存储</h3><h4 id="（1）内存（Memory）："><a href="#（1）内存（Memory）：" class="headerlink" title="（1）内存（Memory）："></a>（1）内存（Memory）：</h4><p>​            RAM，类似于PC的内存条</p>
<h4 id="（2）内部存储（Internal-Storage）："><a href="#（2）内部存储（Internal-Storage）：" class="headerlink" title="（2）内部存储（Internal Storage）："></a>（2）内部存储（Internal Storage）：</h4><p>​            机身固有存储，类似于PC的硬盘 </p>
<h4 id="（3）外部存储（External-Storage）："><a href="#（3）外部存储（External-Storage）：" class="headerlink" title="（3）外部存储（External Storage）："></a>（3）外部存储（External Storage）：</h4><p>​                早期的Android设备(4.4之前) 指SDCard(扩展卡)，类似于PC上的U盘。</p>
<p>​        之后随着技术的进步，机身存储得到了快速增大(8G以上)，此时的外部存储是<font color="orange">概念级别的“外部存储”</font>，机        身<font color="red">固有的存储</font>有一部分被划分为“内部存储”，另一部分被划分为“外部存储”，但其实都是机身固有存储。        后期的外部存储也包括了SDCard。<br>​        所以不管Android手机是否有可移动的SDCard，他们总是有外部存储和内部存储。</p>
<h3 id="3-几个重要文件夹"><a href="#3-几个重要文件夹" class="headerlink" title="3.几个重要文件夹"></a>3.几个重要文件夹</h3><h4 id="打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹"><a href="#打开DDMS（Dalvik-Debug-Monitor-Service），有一个Device-File-Explorer：data文件夹、mnt文件夹、sdcard-文件夹、storage文件夹" class="headerlink" title="打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：data文件夹、mnt文件夹、sdcard 文件夹、storage文件夹"></a>打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：<font color="red">data</font>文件夹、<font color="red">mnt</font>文件夹、<font color="red">sdcard</font> 文件夹、<font color="red">storage</font>文件夹</h4><h3 id="4-内部存储data"><a href="#4-内部存储data" class="headerlink" title="4.内部存储data"></a>4.<font color="cornflowerblue">内部存储data</font></h3><h4 id="1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："><a href="#1-data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：" class="headerlink" title="(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹："></a>(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：</h4><ul>
<li><h5 id="文件夹app：存放着我们所有安装的app的apk文件"><a href="#文件夹app：存放着我们所有安装的app的apk文件" class="headerlink" title="文件夹app：存放着我们所有安装的app的apk文件"></a>文件夹<font color="red">app</font>：存放着我们所有安装的app的apk文件</h5></li>
<li><h5 id="文件夹data：一些包名，展开后，"><a href="#文件夹data：一些包名，展开后，" class="headerlink" title="文件夹data：一些包名，展开后，"></a>文件夹<font color="red">data</font>：一些包名，展开后，</h5><p>data/data/包名/<font color="orange">shared_prefs</font>(SharedPreference存储方式)</p>
<pre><code>data/data/包名/&lt;font color=&#39;orange&#39;&gt;databases&lt;/font&gt;（数据库存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;files&lt;/font&gt;（文件存储方式）
data/data/包名/&lt;font color=&#39;orange&#39;&gt;cache&lt;/font&gt;
</code></pre>
</li>
</ul>
<h4 id="（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data"><a href="#（2）路径的访问：Environment-getDataDirectory-获取内部存储根路径。-data" class="headerlink" title="（2）路径的访问：Environment.getDataDirectory()获取内部存储根路径。/data"></a>（2）路径的访问：<font color="red">Environment.getDataDirectory()</font>获取内部存储根路径。/data</h4><h4 id="3-几点："><a href="#3-几点：" class="headerlink" title="(3)几点："></a>(3)几点：</h4><ol>
<li><h4 id="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"><a href="#系统默认只在内部存储中创建cache目录，并且此时cache目录是空的" class="headerlink" title="系统默认只在内部存储中创建cache目录，并且此时cache目录是空的"></a>系统默认<font color="orange">只在内部存储中创建cache目录</font>，并且此时cache目录是空的</h4></li>
<li><h4 id="此外，还可以根据需要自动创建：shared-prefs，databases，files目录"><a href="#此外，还可以根据需要自动创建：shared-prefs，databases，files目录" class="headerlink" title="此外，还可以根据需要自动创建：shared_prefs，databases，files目录"></a>此外，还可以根据需要<font color="orange">自动创建</font>：shared_prefs，databases，files目录</h4><p>但files可以<font color="orange">手动创建</font>，而shared_prefs，databases不能</p>
</li>
<li><h4 id="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"><a href="#别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。" class="headerlink" title="别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。"></a>别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。</h4></li>
</ol>
<h4 id="（4）内部存储的API"><a href="#（4）内部存储的API" class="headerlink" title="（4）内部存储的API"></a>（4）内部存储的API</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028153632199.png" alt="image-20201028153632199" style="zoom:80%;">





<h3 id="5-外部存储storage"><a href="#5-外部存储storage" class="headerlink" title="5.外部存储storage"></a>5.<font color="cornflowerblue">外部存储storage</font></h3><h4 id="1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"><a href="#1-一般是-storage-emulated-0也有可能是其它文件夹，不同厂家不同版本有可能不一样。" class="headerlink" title="(1)一般是/storage/emulated/0也有可能是其它文件夹，不同厂家不同版本有可能不一样。"></a>(1)一般是<font color="red">/storage/emulated/0</font>也有可能是其它文件夹，不同厂家不同版本有可能不一样。</h4><h4 id="storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy"><a href="#storage-sdcard0，-sdcard，-mnt-sdcard，-storage-emulated-0，-storage-emulated-legacy" class="headerlink" title="/storage/sdcard0，/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy"></a><font color="red">/storage/sdcard0，</font>/sdcard，/mnt/sdcard，/storage/emulated/0，/storage/emulated/legacy</h4><ul>
<li><h5 id="公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等"><a href="#公有目录：10大类，比如DCIM-Download等这些系统创建的文件夹。storage-emulated-0-Download等" class="headerlink" title="公有目录：10大类，比如DCIM,Download等这些系统创建的文件夹。storage/emulated/0/Download等"></a><font color="red">公有目录</font>：10大类，比如DCIM,Download等这些系统创建的文件夹。<font color="orange">storage/emulated/0/Download</font>等</h5></li>
<li><h5 id="私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。"><a href="#私有目录：Android文件夹，打开后有data文件夹。storage-emulated-0-Android-data-包名-文件夹：里面包含了许多包名组成的文件夹。" class="headerlink" title="私有目录：Android文件夹，打开后有data文件夹。storage/emulated/0/Android/data/包名 文件夹：里面包含了许多包名组成的文件夹。"></a><font color="red">私有目录</font>：Android文件夹，打开后有<font color="red">data</font>文件夹。<font color="orange">storage/emulated/0/Android/data/包名 文件夹</font>：里面包含了许多包名组成的文件夹。</h5><h4 id="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"><a href="#（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。" class="headerlink" title="（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。"></a>（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的<font color="green">数据会一并删除</font>。</h4><p>如果直接在<font color="red">根目录</font>（<font color="orange">/storage/emulated/0</font>）下创建一个应用的文件夹，这样当该应用被卸载后，这些数据还保留在外部存储中，<font color="green">留下垃圾数据</font>。</p>
</li>
</ul>
<h4 id="（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。"><a href="#（3）路径的访问：Environment-getExternalStorageDirectory-：获取机身存储的外部存储根路径。" class="headerlink" title="（3）路径的访问：Environment.getExternalStorageDirectory()：获取机身存储的外部存储根路径。"></a>（3）路径的访问：<font color="red">Environment.getExternalStorageDirectory()</font>：获取机身存储的外部存储根路径。</h4><h4 id="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"><a href="#（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录" class="headerlink" title="（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录"></a>（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要<font color="red">手动创建私有目录</font></h4><h5 id="context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件"><a href="#context-getExternalFilesDir-…-：在storage-emulated-0-Android-data-包名-files-中创建文件" class="headerlink" title="context.getExternalFilesDir(…)：在storage/emulated/0/Android/data/包名/files 中创建文件"></a>context.<font color="orange">getExternalFilesDir(…)</font>：在storage/emulated/0/Android/data/包名/files 中创建文件</h5><p>​    context.<font color="orange">getExternalCacheDir() </font>：在storage/emulated/0/Android/data/包名/cache 中创建文件</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028154738508.png" alt="image-20201028154738508" style="zoom:80%;">

<h3 id="6-内部存储与外部存储比较"><a href="#6-内部存储与外部存储比较" class="headerlink" title="6.内部存储与外部存储比较"></a>6.内部存储与外部存储比较</h3><p>​        外部存储目录空间较大，而内部存储空间有限<br>​        部分目录不会被自动创建，需要手动创建<br>​        两者<font color="red">都不需要权限</font><br>​        两者<font color="red">都会随着App的卸载而会自动被删除</font><br>​        对于内部存储，<font color="orange">只有</font>本App才可以访问<br>​        对于外部私有目录，本App可以直接访问，而其它App在自 Android 7.0 开始，系统对应用私有目录的访问权限进一步限制。其他 App 无法通过 file:// 这种形式的 Uri 直接读写该目录下的文件内容，而是通过 FileProvider 访问。<br>​        需要注意的是：由于用户可以直接查看并操作外部私有存储目录，那么也就意味着我们在操作这个目录下的文件的时候一定要做好异常和判空处理。</p>
<h3 id="7-数据存储与清除"><a href="#7-数据存储与清除" class="headerlink" title="7.数据存储与清除"></a>7.数据存储与清除</h3><h4 id="（1）数据存储："><a href="#（1）数据存储：" class="headerlink" title="（1）数据存储："></a>（1）数据存储：</h4><ul>
<li><p>默认情况下，存储在<font color="red">内部存储</font>：<br><font color="orange">data/app</font>：用户APP安装目录，存放apk；</p>
<p><font color="orange">data/data/包名/</font>：存放应用程序的数据</p>
</li>
<li><p>数据可以存放到指定的<font color="red">外部存储</font>：</p>
<p><font color="orange">/storage/sdcard</font>（共有目录）</p>
<p><font color="orange">/storage/sdcard0/Android/data/包名/</font>（私有目录）</p>
<h4 id="（2）清除数据："><a href="#（2）清除数据：" class="headerlink" title="（2）清除数据："></a>（2）清除数据：</h4></li>
</ul>
<h5 id="删除对应包中的cache，files，lib，shared-prefs，datbBases等等"><a href="#删除对应包中的cache，files，lib，shared-prefs，datbBases等等" class="headerlink" title="删除对应包中的cache，files，lib，shared_prefs，datbBases等等"></a>删除<font color="red">对应包中的</font><font color="cornflowerblue">cache</font>，files，lib，shared_prefs，datbBases等等</h5><p>​        （清除<font color="red">data/data/packagename中的</font>cache，files，lib， databases，shared_prefs等等）</p>
<p>​        （清除<font color="red">storage/emulated/0/Android/data/packagenam中的</font>文件）</p>
<h4 id="3-清除缓存："><a href="#3-清除缓存：" class="headerlink" title="(3) 清除缓存："></a>(3) 清除缓存：</h4><h5 id="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"><a href="#删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。" class="headerlink" title="删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。"></a>删除的是App运行过程中所产生的<font color="red">临时数据</font>，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在<font color="red">内存</font>中。</h5><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="1-内部存储"><a href="#1-内部存储" class="headerlink" title="1.内部存储"></a>1.内部存储</h3><h4 id="（1）存："><a href="#（1）存：" class="headerlink" title="（1）存："></a>（1）存：</h4><p>方法1：使用 context.getFilesDir() 获取内部存储data/data/包名/files目录，然后创建文件，最后利用文件(全路径)新建FileOutputStream对象进行文件写入。<br>FileOutputStream fileOutputStream = new FileOutputStream(filePathName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160019136.png" alt="image-20201028160019136" style="zoom:80%;">

<p>方法2：直接使用Context.openFileOutput()方法(只需要文件名)获取FileOutputStream对象，进行文件写入。</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/QQPCmgr/Desktop/Typora%25E7%25AC%2594%25E8%25AE%25B0/%25E3%2580%258A%25E7%25AC%25AC%25E4%25B8%2580%25E8%25A1%258C%25E4%25BB%25A3%25E7%25A0%2581%25E3%2580%258B.assets/image-20201028160258040.png" alt="image-20201028160258040" style="zoom:80%;">

<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160348975.png" alt="image-20201028160348975" style="zoom:80%;">

<h4 id="（2）取："><a href="#（2）取：" class="headerlink" title="（2）取："></a>（2）取：</h4><p>方法1：使用context.getFilesDir() 获取内部存储data/data/包名/files目录，然后利用文件(全路径)创建FileInputStream对象，进行内容读取。<br>FileInputStream fileInputStream = new FileInputStream(filePathName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/myBlog\source\_posts\安卓数据存储之文件存储\3.png" alt="image-20201028160834999" style="zoom:80%;">

<p>方法2：直接使用Context. openFileInput()方法(只需要文件名)获取FileInputStream对象，进行文件内容读取。<br>FileInputStream fileInputStream = openFileInput(fileName);</p>
<img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028160853113.png" alt="image-20201028160853113" style="zoom:80%;">

<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20210531224957336.png" alt="image-20210531224957336"></p>
<h3 id="2-外部存储"><a href="#2-外部存储" class="headerlink" title="2.外部存储"></a>2.外部存储</h3><h4 id="（1）外部根目录："><a href="#（1）外部根目录：" class="headerlink" title="（1）外部根目录："></a>（1）外部根目录：</h4><p>使用 <font color="red">Environment.getExternalStorageDirectory()</font> 获取</p>
<p>一般是/storage/emulated/0</p>
<h4 id="（2）外部公有目录："><a href="#（2）外部公有目录：" class="headerlink" title="（2）外部公有目录："></a>（2）外部公有目录：</h4><p>使用<font color="red">Environment.getExternalStoragePublicDirectory</font>获取</p>
<p>/storage/emulated/0/Music</p>
<p>针对外部<font color="red">共有目录、根目录</font>等位置的存取需要<font color="orange">添加权限</font>，Android 6.0 之后还需要做运行时权限申请。针对外部<font color="red">私有目录</font>的存取则<font color="orange">不需要添加权限</font>。<br>默认情况下，Android系统<font color="red">不会</font>为我们的App在外部存储中创建私有路径，需要<font color="red">手动创建</font>。<br>外部私有目录在App卸载时同步删除。</p>
<p>​    </p>
<h4 id="（3）获取外部私有目录"><a href="#（3）获取外部私有目录" class="headerlink" title="（3）获取外部私有目录"></a>（3）获取外部私有目录</h4><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162002693.png" alt="image-20201028162002693" style="zoom:80%;">





<h4 id="（4）存："><a href="#（4）存：" class="headerlink" title="（4）存："></a>（4）存：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162420940.png" alt="image-20201028162420940"></p>
<h4 id="（5）取："><a href="#（5）取：" class="headerlink" title="（5）取："></a>（5）取：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028162532386.png" alt="image-20201028162532386"></p>
<h2 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h2><h3 id="1-获取SharedPreferences对象"><a href="#1-获取SharedPreferences对象" class="headerlink" title="1.获取SharedPreferences对象"></a>1.获取<font color="cornflowerblue">SharedPreferences对象</font></h3><h4 id="1-Context-getSharedPreferences-方法"><a href="#1-Context-getSharedPreferences-方法" class="headerlink" title="(1) Context . getSharedPreferences()方法 "></a>(1) <font color="red">Context . getSharedPreferences()方法 </font></h4><p>​        此方法接受两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个。SharedPreferences 文件都是存放在 /data/data/&lt;包名&gt;/shared_prefs/ 目录下的。<br>​        第二个参数用于<font color="orange">指定操作模式</font>，主要为 MODE_PRIVATE（默认操作模式） 和 MODE_MULTI_PROCESS（多进程读写） 。</p>
<h4 id="2-Activity-类中的-getPreferences-方法"><a href="#2-Activity-类中的-getPreferences-方法" class="headerlink" title="(2)Activity 类中的 getPreferences() 方法"></a>(2)<font color="red">Activity 类中的 getPreferences() 方法</font></h4><p>这个方法和 Context 中的 getSharedPreferences() 方法类似，不过它只接收一个操作模式参数，使用这个方法时<font color="orange">会自动将当前活动的类名作为 SharedPreferences 的文件名</font>。</p>
<h4 id="3-PreferenceManager-类中的-getDefaultSharedPreferences-方法"><a href="#3-PreferenceManager-类中的-getDefaultSharedPreferences-方法" class="headerlink" title="(3) PreferenceManager 类中的 getDefaultSharedPreferences() 方法"></a>(3)<font color="red"> PreferenceManager 类中的 getDefaultSharedPreferences() 方法</font></h4><p>这是一个<font color="orange">静态方法</font>，它接收一个 Context 参数，并自动<font color="orange">使用当前应用程序的包名作为前缀</font>来命名 SharedPreferences 文件。</p>
<h3 id="2-通过SharedPreferences对象获取到Editor对象存数据"><a href="#2-通过SharedPreferences对象获取到Editor对象存数据" class="headerlink" title="2.通过SharedPreferences对象获取到Editor对象存数据"></a>2.通过SharedPreferences对象获取到<font color="cornflowerblue">Editor对象</font>存数据</h3><h4 id="（1）SharePreferences-Editor-editor-shared-edit"><a href="#（1）SharePreferences-Editor-editor-shared-edit" class="headerlink" title="（1）SharePreferences.Editor  editor = shared.edit();"></a>（1）SharePreferences.Editor  editor = shared.<font color="red">edit();</font></h4><p>调用 SharedPreferences 对象的 edit() 方法来获取一个 SharePreferences.Editor 对象。</p>
<h4 id="（2）editor-putString"><a href="#（2）editor-putString" class="headerlink" title="（2）editor.putString( )"></a>（2）editor<font color="red">.putString( )</font></h4><p>向 SharedPreferences.Editor 对象中添加数据，如果添加一个字符串则使用 editor.putString() 方法，以此类推。</p>
<h4 id="（3）editor-commit-editor-apply"><a href="#（3）editor-commit-editor-apply" class="headerlink" title="（3）editor.commit()  editor.apply()"></a>（3）<font color="red">editor.commit()  editor.apply()</font></h4><p>调用 editor.commit() 方法或者editor.apply()方法将添加的数据提交，从而完成数据存储操作。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164007127.png" alt="image-20201028164007127"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164138241.png" alt="image-20201028164138241"></p>
<h3 id="3-SharePreferences读取与删除数据"><a href="#3-SharePreferences读取与删除数据" class="headerlink" title="3.SharePreferences读取与删除数据"></a>3.SharePreferences<font color="cornflowerblue">读取与删除</font>数据</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164251857.png" alt="image-20201028164251857"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201028164334426.png" alt="image-20201028164334426"></p>
<h2 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h2><h3 id="一、创建数据库"><a href="#一、创建数据库" class="headerlink" title="一、创建数据库"></a>一、创建数据库</h3><h4 id="1-SQLiteOpenHelper-帮助类"><a href="#1-SQLiteOpenHelper-帮助类" class="headerlink" title="1.  SQLiteOpenHelper 帮助类"></a>1. <font color="cornflowerblue"> SQLiteOpenHelper</font> 帮助类</h4><ul>
<li><p>重写onCreate() 和 onUpgrade() 方法，分别在这两个方法实现创建、更新数据库的逻辑；</p>
</li>
<li><p>两个重要的实例方法：getReadableDatabase() 和 getWritableDatabese() ,这两个方法都可以创建或打开一个现有数据库（不存在则创建），并且返回一个可对数据库进行读/写操作的SQLiteDatabase对象</p>
</li>
<li><p>SQLiteOpenHelper构造方法（context, name, factory, version）</p>
<p>​        参数一：Context；    参数二：数据库名；    参数三：Cursor游标（null）    参数四：版本号</p>
<h4 id="2-新建-MyDatabaseHelper-继承自SQLiteOpenHelper"><a href="#2-新建-MyDatabaseHelper-继承自SQLiteOpenHelper" class="headerlink" title="2. 新建 MyDatabaseHelper 继承自SQLiteOpenHelper"></a>2. 新建 <font color="cornflowerblue">MyDatabaseHelper</font> 继承自SQLiteOpenHelper</h4><h5 id="重写oncreate"><a href="#重写oncreate" class="headerlink" title="重写oncreate()"></a>重写<font color="orange">oncreate()</font></h5></li>
</ul>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031132951195.png" alt="image-20201031132951195"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031133055726.png" alt="image-20201031133055726"></p>
<h4 id="3-创建数据库"><a href="#3-创建数据库" class="headerlink" title="3. 创建数据库"></a>3. 创建数据库</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031133544744.png" alt="image-20201031133544744"></p>
<h3 id="二、升级数据库"><a href="#二、升级数据库" class="headerlink" title="二、升级数据库"></a>二、升级数据库</h3><h4 id="1-在初始化时新执行一条SQL语句，新建一个Category表格"><a href="#1-在初始化时新执行一条SQL语句，新建一个Category表格" class="headerlink" title="1.在初始化时新执行一条SQL语句，新建一个Category表格"></a>1.在初始化时新执行一条SQL语句，新建一个Category表格</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134002931.png" alt="image-20201031134002931"></p>
<h4 id="2-重写onUpgrade"><a href="#2-重写onUpgrade" class="headerlink" title="2.重写onUpgrade()"></a>2.重写<font color="orange">onUpgrade()</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134120838.png" alt="image-20201031134120838"></p>
<p>​    升级时，如果表格存在，先删除掉再调用onCreate()重写创建</p>
<h4 id="3-更新数据库"><a href="#3-更新数据库" class="headerlink" title="3. 更新数据库"></a>3. 更新数据库</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031134454199.png" alt="image-20201031134454199"></p>
<h3 id="三、添加数据-insert"><a href="#三、添加数据-insert" class="headerlink" title="三、添加数据 insert()"></a>三、添加数据 <font color="cornflowerblue">insert()</font></h3><h4 id="1-参数"><a href="#1-参数" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二：用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL，一般我们用不到这个功能，直接传入null即可</li>
<li>参数三：<font color="orange">ContentValues</font>对象，它提供了一系列的<font color="orange">put()</font>方法重载，用于向Contentvalues中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。</li>
</ul>
<h4 id="2-添加数据"><a href="#2-添加数据" class="headerlink" title="2.添加数据"></a>2.添加数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031140101787.png" alt="image-20201031140101787"></p>
<h3 id="四、更新数据-updata"><a href="#四、更新数据-updata" class="headerlink" title="四、更新数据 updata()"></a>四、更新数据 <font color="cornflowerblue">updata()</font></h3><h4 id="1-参数-1"><a href="#1-参数-1" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二：<font color="orange">ContentValues</font>对象，组装更新的数据</li>
<li>参数三、参数四：约束更新某一行或某几行的数据</li>
</ul>
<h4 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2.更新数据"></a>2.更新数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031140634673.png" alt="image-20201031140634673"></p>
<h5 id="更新Book表格中，name为“The-Da-Vinci-Code”-的价格为10-99"><a href="#更新Book表格中，name为“The-Da-Vinci-Code”-的价格为10-99" class="headerlink" title="更新Book表格中，name为“The Da Vinci Code” 的价格为10.99"></a>更新Book表格中，name为“The Da Vinci Code” 的价格为10.99</h5><h3 id="五、删除数据-delete"><a href="#五、删除数据-delete" class="headerlink" title="五、删除数据 delete()"></a>五、删除数据 <font color="cornflowerblue">delete()</font></h3><h4 id="1-参数-2"><a href="#1-参数-2" class="headerlink" title="1.参数"></a>1.参数</h4><ul>
<li>参数一：表名</li>
<li>参数二、参数三：约束删除某一行或某几行的数据</li>
</ul>
<h4 id="2-删除数据"><a href="#2-删除数据" class="headerlink" title="2.删除数据"></a>2.删除数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141159367.png" alt="image-20201031141159367"></p>
<h5 id="删除Book表格中，Pages大于500页的数据"><a href="#删除Book表格中，Pages大于500页的数据" class="headerlink" title="删除Book表格中，Pages大于500页的数据"></a>删除Book表格中，Pages大于500页的数据</h5><h3 id="六、查询数据-query"><a href="#六、查询数据-query" class="headerlink" title="六、查询数据 query()"></a>六、查询数据 <font color="cornflowerblue">query()</font></h3><h4 id="1-参数-3"><a href="#1-参数-3" class="headerlink" title="1.参数"></a>1.参数</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141347771.png" alt="image-20201031141347771"></p>
<h4 id="2-查询数据"><a href="#2-查询数据" class="headerlink" title="2.查询数据"></a>2.查询数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201031141717750.png" alt="image-20201031141717750"></p>
<h5 id="通过返回的Cursor对象来获取数据，moveToFirst-将游标移动到第一行位置；-getColunmIndex-获取某一列的位置索引"><a href="#通过返回的Cursor对象来获取数据，moveToFirst-将游标移动到第一行位置；-getColunmIndex-获取某一列的位置索引" class="headerlink" title="通过返回的Cursor对象来获取数据，moveToFirst():将游标移动到第一行位置； getColunmIndex():获取某一列的位置索引"></a>通过返回的Cursor对象来获取数据，<font color="orange">moveToFirst()</font>:将游标移动到第一行位置；<font color="orange"> getColunmIndex()</font>:获取某一列的位置索引</h5><h1 id="第七章-跨程序共享数据——探究内容提供器"><a href="#第七章-跨程序共享数据——探究内容提供器" class="headerlink" title="第七章 跨程序共享数据——探究内容提供器"></a>第七章 跨程序共享数据——探究内容提供器</h1><h2 id="内容提供器简介"><a href="#内容提供器简介" class="headerlink" title="内容提供器简介"></a>内容提供器简介</h2><h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><h3 id="一、危险权限"><a href="#一、危险权限" class="headerlink" title="一、危险权限"></a>一、危险权限</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201109144301759.png" alt="image-20201109144301759"></p>
<p>危险权限需要进行运行时权限处理，普通权限只要在AndroidMainfest.xml清单文件中添加一下权限声明就行</p>
<h3 id="二、运行时权限处理步骤"><a href="#二、运行时权限处理步骤" class="headerlink" title="二、运行时权限处理步骤"></a>二、<font color="cornflowerblue">运行时权限处理步骤</font></h3><h4 id="1-第一步：判断用户是否已经授权"><a href="#1-第一步：判断用户是否已经授权" class="headerlink" title="1. 第一步：判断用户是否已经授权"></a>1. <font color="pink">第一步</font>：判断用户是否已经授权</h4><h5 id="（1）ContextCompat-checkSelfPermission-MainActivity-this-Manifest-permission-READ-CONTACTS"><a href="#（1）ContextCompat-checkSelfPermission-MainActivity-this-Manifest-permission-READ-CONTACTS" class="headerlink" title="（1）ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_CONTACTS)"></a>（1）<font color="red">ContextCompat.checkSelfPermission</font>(MainActivity.this, Manifest.permission.READ_CONTACTS)</h5><h5 id="（2）参数一：Context；-参数二：权限名"><a href="#（2）参数一：Context；-参数二：权限名" class="headerlink" title="（2）参数一：Context； 参数二：权限名"></a>（2）参数一：Context； 参数二：权限名</h5><h5 id="（3）将其返回值与PackageManager-PERMISSION-GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。"><a href="#（3）将其返回值与PackageManager-PERMISSION-GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。" class="headerlink" title="（3）将其返回值与PackageManager.PERMISSION_GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。"></a>（3）将其返回值与<font color="red">PackageManager.PERMISSION_GRANTED</font>做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。</h5><h4 id="2-第二步：如果未授权，申请授权"><a href="#2-第二步：如果未授权，申请授权" class="headerlink" title="2.第二步：如果未授权，申请授权"></a>2.<font color="pink">第二步</font>：如果未授权，申请授权</h4><h5 id="（1）ActivityCompat-requestPermissions-MainActivity-this-new-String-Manifest-permission-READ-CONTACTS-1"><a href="#（1）ActivityCompat-requestPermissions-MainActivity-this-new-String-Manifest-permission-READ-CONTACTS-1" class="headerlink" title="（1）ActivityCompat.requestPermissions(MainActivity.this, new String[]{ Manifest.permission. READ_CONTACTS }, 1);"></a>（1）<font color="red">ActivityCompat.requestPermissions</font>(MainActivity.this, new String[]{ Manifest.permission. READ_CONTACTS }, 1);</h5><h5 id="（2）参数一：Activity的实例；-参数二：权限名的String数组；"><a href="#（2）参数一：Activity的实例；-参数二：权限名的String数组；" class="headerlink" title="（2）参数一：Activity的实例；    参数二：权限名的String数组；"></a>（2）参数一：Activity的实例；    参数二：权限名的String数组；</h5><h5 id="权限三：请求码，唯一即可"><a href="#权限三：请求码，唯一即可" class="headerlink" title="权限三：请求码，唯一即可"></a>权限三：请求码，唯一即可</h5><h5 id="（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult-方法，对授权结果进行处理。"><a href="#（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult-方法，对授权结果进行处理。" class="headerlink" title="（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult()方法，对授权结果进行处理。"></a>（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult()方法，对授权结果进行处理。</h5><h4 id="3-第三步：处理用户授权结果"><a href="#3-第三步：处理用户授权结果" class="headerlink" title="3.第三步：处理用户授权结果"></a>3.<font color="pink">第三步</font>：处理用户授权结果</h4><h5 id="（1）-onRequestPermissionsResult-方法中，用户授权的结果封装在grantResults参数当中"><a href="#（1）-onRequestPermissionsResult-方法中，用户授权的结果封装在grantResults参数当中" class="headerlink" title="（1） onRequestPermissionsResult()方法中，用户授权的结果封装在grantResults参数当中"></a>（1）<font color="red"> onRequestPermissionsResult()</font>方法中，用户授权的结果封装在grantResults参数当中</h5><h5 id="（2）grantResults-length-gt-0-amp-amp-grantResults-0-PackageManager-PERMISSION-GRANTED说明用户允许授权"><a href="#（2）grantResults-length-gt-0-amp-amp-grantResults-0-PackageManager-PERMISSION-GRANTED说明用户允许授权" class="headerlink" title="（2）grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED说明用户允许授权"></a>（2）grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED说明用户允许授权</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111130523831.png" alt="image-20201111130523831"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111130532512.png" alt="image-20201111130532512"></p>
<h2 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h2><h3 id="一、应用程序间的数据共享"><a href="#一、应用程序间的数据共享" class="headerlink" title="一、应用程序间的数据共享"></a>一、应用程序间的数据共享</h3><h4 id="1-三个重要类"><a href="#1-三个重要类" class="headerlink" title="1.三个重要类"></a>1.三个重要类</h4><h5 id="（1）ContentProvider：内容提供者。"><a href="#（1）ContentProvider：内容提供者。" class="headerlink" title="（1）ContentProvider：内容提供者。"></a>（1）<font color="cornflowerblue">ContentProvider</font>：内容提供者。</h5><p>内容提供者的用法一般有两种：<br>一种是使用<font color="orange">现有的</font>内容提供器来读取和操作相应程序中的数据。<br>另一种是<font color="orange">创建自己的</font>内容提供器对其数据提供外部访问接口。</p>
<h5 id="（2）ContentResolver：内容访问者"><a href="#（2）ContentResolver：内容访问者" class="headerlink" title="（2）ContentResolver：内容访问者"></a>（2）<font color="cornflowerblue">ContentResolver</font>：内容访问者</h5><p>提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作。</p>
<h5 id="（3）Uri："><a href="#（3）Uri：" class="headerlink" title="（3）Uri："></a>（3）<font color="cornflowerblue">Uri</font>：</h5><p>不同于SQLiteDatabase， ContentResolver中增删改查方法不接收表名参数，而是使用一个Uri参数代替，这个参数称为内容Uri。</p>
<p>格式：<font color="red">scheme:/ /Authority / path / id</font></p>
<ul>
<li>scheme： content://是一个标准的前缀，表明了这个数据被内容提供者管理，它不会修改。</li>
<li>authority：用于唯一标识一个ContentProvider，外部调用者可以根据此标识访问该ContentProvider。通常可将Authority设置为包名和类名的全称，以保证唯一性。例如包名是com.example.app，则authority可以命名为com.example.app.provider。</li>
<li>path：用于对同一应用程序的不同的数据进行区分，通常添加到authority的后面，例如/table1, /table2。</li>
<li>id：数据集中的每一条记录都有一个唯一的id。如果Uri中包含需要获取的记录的id，则只对该记录进行操作；如果Uri中没有id，则表示操作数据集中的所有记录。</li>
<li><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132317186.png" alt="image-20201111132317186"></li>
</ul>
<h4 id="2-使用ContentResolver访问共享数据"><a href="#2-使用ContentResolver访问共享数据" class="headerlink" title="2.使用ContentResolver访问共享数据"></a>2.使用ContentResolver访问共享数据</h4><h5 id="ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作"><a href="#ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作" class="headerlink" title="ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作"></a>ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行<font color="red">CRUD</font>操作</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132443856.png" alt="image-20201111132443856"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132412264.png" alt="image-20201111132412264"></p>
<h4 id="3-查询-获取-内容提供者中指定的数据"><a href="#3-查询-获取-内容提供者中指定的数据" class="headerlink" title="3. 查询(获取)内容提供者中指定的数据"></a>3. <font color="cornflowerblue">查询</font>(获取)内容提供者中指定的数据</h4><h5 id="（1）首先，确定访问目标"><a href="#（1）首先，确定访问目标" class="headerlink" title="（1）首先，确定访问目标"></a>（1）首先，确定访问目标</h5><h5 id="Uri-uri-Uri-parse-“content-com-example-app-provider-table1”"><a href="#Uri-uri-Uri-parse-“content-com-example-app-provider-table1”" class="headerlink" title="Uri uri = Uri.parse(“content://com.example.app.provider/table1”);"></a>Uri uri = Uri.parse(“content://com.example.app.provider/table1”);</h5><p>（2）然后，查询：<br>获取ContentResolver，将Uri对象作为参数，调用query()方法得到一个cursor对象</p>
<h5 id="Cursor-cursor-getContentResolver-query-uri-projection-selection-selectionArgs-sortOrder"><a href="#Cursor-cursor-getContentResolver-query-uri-projection-selection-selectionArgs-sortOrder" class="headerlink" title="Cursor  cursor = getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder);"></a><font color="red">Cursor  cursor = getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder);</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111132642375.png" alt="image-20201111132642375"></p>
<h5 id="（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。"><a href="#（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。" class="headerlink" title="（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。"></a>（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133026107.png" alt="image-20201111133026107"></p>
<h4 id="4-向内容提供者共享的table1中添加数据"><a href="#4-向内容提供者共享的table1中添加数据" class="headerlink" title="4. 向内容提供者共享的table1中添加数据"></a>4. 向内容提供者共享的table1中<font color="cornflowerblue">添加</font>数据</h4><h5 id="将待添加的数据组装到ContentValues，然后调用ContentResolver类insert-方法，将uri和ContentValues作为参数传入。"><a href="#将待添加的数据组装到ContentValues，然后调用ContentResolver类insert-方法，将uri和ContentValues作为参数传入。" class="headerlink" title="将待添加的数据组装到ContentValues，然后调用ContentResolver类insert()方法，将uri和ContentValues作为参数传入。"></a>将待添加的数据组装到ContentValues，然后调用ContentResolver类insert()方法，将uri和ContentValues作为参数传入。</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133121157.png" alt="image-20201111133121157"></p>
<h4 id="5-向内容提供者共享的table1中更新数据"><a href="#5-向内容提供者共享的table1中更新数据" class="headerlink" title="5. 向内容提供者共享的table1中更新数据"></a>5. 向内容提供者共享的table1中<font color="cornflowerblue">更新</font>数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133151906.png" alt="image-20201111133151906"></p>
<h4 id="6-向内容提供者共享的table1中删除数据"><a href="#6-向内容提供者共享的table1中删除数据" class="headerlink" title="6.向内容提供者共享的table1中删除数据"></a>6.向内容提供者共享的table1中<font color="cornflowerblue">删除</font>数据</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201111133224468.png" alt="image-20201111133224468"></p>
<h2 id="创建自己的内容提供器-（P260）"><a href="#创建自己的内容提供器-（P260）" class="headerlink" title="创建自己的内容提供器*（P260）"></a>创建自己的内容提供器*（P260）</h2><h3 id="一、重写其中6个抽象方法"><a href="#一、重写其中6个抽象方法" class="headerlink" title="一、重写其中6个抽象方法"></a>一、重写其中6个抽象方法</h3><h4 id="1-public-boolean-onCreate-：ContentProvider创建时调用。"><a href="#1-public-boolean-onCreate-：ContentProvider创建时调用。" class="headerlink" title="1.public boolean onCreate()：ContentProvider创建时调用。"></a>1.public boolean <font color="cornflowerblue">onCreate()</font>：ContentProvider创建时调用。</h4><h4 id="2-public-int-delete-…-：根据传入的Uri删除指定条件下的数据。"><a href="#2-public-int-delete-…-：根据传入的Uri删除指定条件下的数据。" class="headerlink" title="2. public int delete(…)：根据传入的Uri删除指定条件下的数据。"></a>2. public int <font color="cornflowerblue">delete(…)</font>：根据传入的Uri删除指定条件下的数据。</h4><h4 id="3-public-Uri-insert-…-：根据传入的Uri插入数据。"><a href="#3-public-Uri-insert-…-：根据传入的Uri插入数据。" class="headerlink" title="3.public Uri insert(…)：根据传入的Uri插入数据。"></a>3.public Uri <font color="cornflowerblue">insert(…)</font>：根据传入的Uri插入数据。</h4><h4 id="4-public-Cursor-query-…-：根据传入的Uri查询指定的数据。"><a href="#4-public-Cursor-query-…-：根据传入的Uri查询指定的数据。" class="headerlink" title="4. public Cursor query(…)：根据传入的Uri查询指定的数据。"></a>4. public Cursor <font color="cornflowerblue">query(…)</font>：根据传入的Uri查询指定的数据。</h4><h4 id="5-public-int-update-…-：根据传入的Uri更新指定的数据。"><a href="#5-public-int-update-…-：根据传入的Uri更新指定的数据。" class="headerlink" title="5.public int update(…)：根据传入的Uri更新指定的数据。"></a>5.public int <font color="cornflowerblue">update(…)</font>：根据传入的Uri更新指定的数据。</h4><h4 id="6-getType"><a href="#6-getType" class="headerlink" title="6.getType()"></a>6.<font color="red">getType()</font></h4><h3 id="二、Uri参数：确定调用方希望访问的数据或表"><a href="#二、Uri参数：确定调用方希望访问的数据或表" class="headerlink" title="二、Uri参数：确定调用方希望访问的数据或表"></a>二、Uri参数：确定调用方希望访问的数据或表</h3><h4 id="表：content-com-example-app-privder-table1"><a href="#表：content-com-example-app-privder-table1" class="headerlink" title="表：content://com.example.app.privder/table1/"></a>表：content://com.example.app.privder/table1/</h4><h4 id="数据：content-com-example-app-privder-table1"><a href="#数据：content-com-example-app-privder-table1" class="headerlink" title="数据：content://com.example.app.privder/table1/#"></a>数据：content://com.example.app.privder/table1/#</h4><h3 id="三、通过UriMatcher类解析Uri参数，确定调用的数据或表"><a href="#三、通过UriMatcher类解析Uri参数，确定调用的数据或表" class="headerlink" title="三、通过UriMatcher类解析Uri参数，确定调用的数据或表"></a>三、通过UriMatcher类解析Uri参数，确定调用的数据或表</h3><h4 id="首先将需要共享的数据或数据表的内容URI用addURI-方法添加到自定义的内容提供器中"><a href="#首先将需要共享的数据或数据表的内容URI用addURI-方法添加到自定义的内容提供器中" class="headerlink" title="首先将需要共享的数据或数据表的内容URI用addURI()方法添加到自定义的内容提供器中"></a>首先将需要共享的数据或数据表的内容URI用<font color="red">addURI()方法</font>添加到自定义的内容提供器中</h4><h4 id="然后，在query-方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。"><a href="#然后，在query-方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。" class="headerlink" title="然后，在query()方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。"></a>然后，在query()方法中调用UriMatcher的<font color="red">match方法</font>对传入的Uri对象进行解析，<font color="orange">返回某个能匹配这个Uri对象的自定义代码</font>，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117132442004.png" alt="image-20201117132442004"></p>
<h3 id="四、getType-方法"><a href="#四、getType-方法" class="headerlink" title="四、getType()方法"></a>四、getType()方法</h3><p>一个内容URI所对应的MIME字符串由3部分组成：    </p>
<ul>
<li>以vnd开头</li>
<li>如果内容URI以路径结尾，则后接android.cursor.<font color="red">dir</font>/，如果内容URI以id结尾，则后接android.cursor<font color="red">.item</font>/</li>
<li>最后接上vnd.<authority>.<path></path></authority></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;<span class="comment">//教材265页</span></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Implement this to handle requests for the MIME type of the data</span></span><br><span class="line">       <span class="comment">// at the given URI.</span></span><br><span class="line">       <span class="keyword">switch</span> (uriMatcher.match(uri)) &#123;</span><br><span class="line">           <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.book&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> CATEGORY_DIR:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.category&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> CATEGORY_ITEM:</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.category&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="内容观察者ContentObersver"><a href="#内容观察者ContentObersver" class="headerlink" title="内容观察者ContentObersver"></a>内容观察者ContentObersver</h2><h3 id="一、ContentObserver（内容观察者）"><a href="#一、ContentObserver（内容观察者）" class="headerlink" title="一、ContentObserver（内容观察者）"></a>一、ContentObserver（内容观察者）</h3><h4 id="1-目的是观察-捕捉-特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器-Trigger-，当ContentObserver所观察的Uri发生变化时，便会触发它。"><a href="#1-目的是观察-捕捉-特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器-Trigger-，当ContentObserver所观察的Uri发生变化时，便会触发它。" class="headerlink" title="1.目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它。"></a>1.目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它。</h4><h4 id="2-触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri-MIME-Type有关的。"><a href="#2-触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri-MIME-Type有关的。" class="headerlink" title="2.触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri MIME Type有关的。"></a>2.触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri MIME Type有关的。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201117133208124.png" alt="image-20201117133208124"></p>
<h4 id="3-当A应用程序的数据发生变化时，A应用程序调用notifyChange-方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange-方法。"><a href="#3-当A应用程序的数据发生变化时，A应用程序调用notifyChange-方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange-方法。" class="headerlink" title="3.当A应用程序的数据发生变化时，A应用程序调用notifyChange()方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange()方法。"></a>3.当A应用程序的数据发生变化时，A应用程序调用notifyChange()方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange()方法。</h4><h3 id="二、ContentObserver的几个常用的方法"><a href="#二、ContentObserver的几个常用的方法" class="headerlink" title="二、ContentObserver的几个常用的方法"></a>二、ContentObserver的几个常用的方法</h3><h4 id="1-构造方法-public-void-ContentObserver-Handler-handler"><a href="#1-构造方法-public-void-ContentObserver-Handler-handler" class="headerlink" title="1.构造方法 public void ContentObserver(Handler handler)"></a>1.构造方法 public void<font color="cornflowerblue"> ContentObserver(Handler handler)</font></h4><p>​        所有ContentObserver的派生类都需要调用该构造方法.<br>参数：handler，Handler对象。可以是主线程Handler(这时候可以更新UI )，也可以是任何Handler对象。</p>
<h4 id="2-void-onChange-boolean-selfChange"><a href="#2-void-onChange-boolean-selfChange" class="headerlink" title="2.void onChange(boolean selfChange)"></a>2.void <font color="cornflowerblue">onChange(boolean selfChange)</font></h4><p>​        观察到的Uri发生变化时，回调该方法去处理。<br>所有ContentObserver的派生类都需要重载该方法去处理逻辑。</p>
<h1 id="第八章-丰富你的程序——运用手机多媒体"><a href="#第八章-丰富你的程序——运用手机多媒体" class="headerlink" title="第八章 丰富你的程序——运用手机多媒体"></a>第八章 丰富你的程序——运用手机多媒体</h1><h2 id="播放多媒体文件"><a href="#播放多媒体文件" class="headerlink" title="播放多媒体文件"></a>播放多媒体文件</h2><h3 id="一、播放音频"><a href="#一、播放音频" class="headerlink" title="一、播放音频"></a>一、播放音频</h3><h4 id="1-MediaPlayer类"><a href="#1-MediaPlayer类" class="headerlink" title="1.MediaPlayer类"></a>1.<font color="cornflowerblue">MediaPlayer</font>类</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124130455169.png" alt="image-20201124130455169"></p>
<h4 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2.工作流程"></a>2.工作流程</h4><ul>
<li><h5 id="创建MediaPlayer对象；"><a href="#创建MediaPlayer对象；" class="headerlink" title="创建MediaPlayer对象；"></a>创建MediaPlayer对象；</h5></li>
<li><h5 id="初始化设置音频文件路径：setDataSource"><a href="#初始化设置音频文件路径：setDataSource" class="headerlink" title="初始化设置音频文件路径：setDataSource()"></a>初始化设置音频文件路径：setDataSource()</h5></li>
<li><h5 id="使MediaPlayer进入准备状态：pepare"><a href="#使MediaPlayer进入准备状态：pepare" class="headerlink" title="使MediaPlayer进入准备状态：pepare()"></a>使MediaPlayer进入准备状态：pepare()</h5></li>
<li><h5 id="开始播放音频：start"><a href="#开始播放音频：start" class="headerlink" title="开始播放音频：start()"></a>开始播放音频：start()</h5></li>
<li><h5 id="暂停播放音频：pause"><a href="#暂停播放音频：pause" class="headerlink" title="暂停播放音频：pause()"></a>暂停播放音频：pause()</h5></li>
<li><h5 id="停止播放音频：reset-setDataSource-pepare"><a href="#停止播放音频：reset-setDataSource-pepare" class="headerlink" title="停止播放音频：reset(), setDataSource(), pepare()"></a>停止播放音频：reset(), setDataSource(), pepare()</h5></li>
</ul>
<h1 id="第九章-看看精彩的技术——使用网络技术"><a href="#第九章-看看精彩的技术——使用网络技术" class="headerlink" title="第九章 看看精彩的技术——使用网络技术"></a>第九章 看看精彩的技术——使用网络技术</h1><h2 id="Android常见的网络通信方式"><a href="#Android常见的网络通信方式" class="headerlink" title="Android常见的网络通信方式"></a>Android常见的网络通信方式</h2><h3 id="一、基于TCP协议"><a href="#一、基于TCP协议" class="headerlink" title="一、基于TCP协议"></a>一、基于TCP协议</h3><p>（1）针对TCP的 Socket、ServerSocket<br>（2）针对UDP的DatagramSocket、DatagramPackage<br>（3）Apache Mina框架</p>
<h3 id="二、基于Http协议"><a href="#二、基于Http协议" class="headerlink" title="二、基于Http协议"></a>二、基于Http协议</h3><p>HttpURLConnection、HttpClient、AsyncHttpClient框架等</p>
<h3 id="三、直接使用-WebKit-访问网络"><a href="#三、直接使用-WebKit-访问网络" class="headerlink" title="三、直接使用 WebKit 访问网络"></a>三、直接使用 WebKit 访问网络</h3><h3 id="四、使用网络通信框架"><a href="#四、使用网络通信框架" class="headerlink" title="四、使用网络通信框架"></a>四、使用网络通信框架</h3><p>OkHttp，Volley，Retrofit</p>
<h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><h3 id="一、通信协议"><a href="#一、通信协议" class="headerlink" title="一、通信协议"></a>一、通信协议</h3><h4 id="1-计算机网络实现通信必须遵循守一些约定。核心要素包括："><a href="#1-计算机网络实现通信必须遵循守一些约定。核心要素包括：" class="headerlink" title="1.计算机网络实现通信必须遵循守一些约定。核心要素包括："></a>1.计算机网络实现通信必须遵循守一些约定。核心要素包括：</h4><h5 id="（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；"><a href="#（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；" class="headerlink" title="（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；"></a>（1）<font color="cornflowerblue">语义</font>：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；</h5><h5 id="（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；"><a href="#（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；" class="headerlink" title="（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；"></a>（2）<font color="cornflowerblue">语法</font>：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；</h5><h5 id="（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。"><a href="#（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。" class="headerlink" title="（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。"></a>（3）<font color="cornflowerblue">时序</font>：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。</h5><h4 id="2-常见的通信协议"><a href="#2-常见的通信协议" class="headerlink" title="2.常见的通信协议"></a>2.常见的通信协议</h4><ul>
<li>TCP/IP, IPX/SPX, NetBEUI, RS-232-C等</li>
<li>TCP/IP 是最基本的通信协议。</li>
<li>TCP/IP是一组协议的集合，是一组协议集合的简称。</li>
</ul>
<h3 id="二、TCP-IP-协议集"><a href="#二、TCP-IP-协议集" class="headerlink" title="二、TCP/IP 协议集"></a>二、TCP/IP 协议集</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214220514420.png" alt="image-20201214220514420"></p>
<h4 id="1-以QQ数据传输为例"><a href="#1-以QQ数据传输为例" class="headerlink" title="1.以QQ数据传输为例"></a>1.以QQ数据传输为例</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214220704145.png" alt="image-20201214220704145"></p>
<h4 id="2-TCP与UDP，传输层"><a href="#2-TCP与UDP，传输层" class="headerlink" title="2.TCP与UDP，传输层"></a>2.TCP与UDP，传输层</h4><h5 id="1、TCP面向连接（如打电话要先拨号建立连接）-UDP是无连接的，即发送数据之前不需要建立连接。"><a href="#1、TCP面向连接（如打电话要先拨号建立连接）-UDP是无连接的，即发送数据之前不需要建立连接。" class="headerlink" title="1、TCP面向连接（如打电话要先拨号建立连接）; UDP是无连接的，即发送数据之前不需要建立连接。"></a>1、<font color="red">TCP面向连接</font>（如打电话要先拨号建立连接）;<font color="red"> UDP是无连接的</font>，即发送数据之前不需要建立连接。</h5><h5 id="2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达-UDP尽最大努力交付，即不保证可靠交付。"><a href="#2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达-UDP尽最大努力交付，即不保证可靠交付。" class="headerlink" title="2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保证可靠交付。"></a>2、<font color="red">TCP提供可靠的服务</font>。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; <font color="red">UDP尽最大努力交付，即不保证可靠交付</font>。</h5><h5 id="3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流-UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。"><a href="#3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流-UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。" class="headerlink" title="3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。"></a>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</h5><h5 id="4、每一条TCP连接只能是点到点的-UDP支持一对一，一对多，多对一和多对多的交互通信。"><a href="#4、每一条TCP连接只能是点到点的-UDP支持一对一，一对多，多对一和多对多的交互通信。" class="headerlink" title="4、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信。"></a>4、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信。</h5><h5 id="5、TCP首部开销20字节-UDP的首部开销小，只有8个字节。"><a href="#5、TCP首部开销20字节-UDP的首部开销小，只有8个字节。" class="headerlink" title="5、TCP首部开销20字节;UDP的首部开销小，只有8个字节。"></a>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节。</h5><h5 id="6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。"><a href="#6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。" class="headerlink" title="6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。"></a>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</h5><h4 id="3-HTTP，应用层"><a href="#3-HTTP，应用层" class="headerlink" title="3.HTTP，应用层"></a>3.HTTP，应用层</h4><h5 id="（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。"><a href="#（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。" class="headerlink" title="（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。"></a>（1）Http是一个基于<font color="red">请求与响应，无状态的，应用层的</font>协议，常基于<font color="red">TCP</font>协议传输数据。</h5><h5 id="（2）用于定义Web浏览器与Web服务器之间交换数据的过程。"><a href="#（2）用于定义Web浏览器与Web服务器之间交换数据的过程。" class="headerlink" title="（2）用于定义Web浏览器与Web服务器之间交换数据的过程。"></a>（2）用于定义Web浏览器与Web服务器之间交换数据的过程。</h5><h5 id="（3）四个基于：请求与响应、无状态、应用层、TCP"><a href="#（3）四个基于：请求与响应、无状态、应用层、TCP" class="headerlink" title="（3）四个基于：请求与响应、无状态、应用层、TCP"></a>（3）四个基于：请求与响应、无状态、应用层、TCP</h5><h2 id="基于TCP协议的网络通信"><a href="#基于TCP协议的网络通信" class="headerlink" title="基于TCP协议的网络通信"></a>基于TCP协议的网络通信</h2><h3 id="一、IP地址、端口"><a href="#一、IP地址、端口" class="headerlink" title="一、IP地址、端口"></a>一、IP地址、端口</h3><h4 id="1-IP地址"><a href="#1-IP地址" class="headerlink" title="1.IP地址"></a>1.<font color="cornflowerblue">IP地址</font></h4><h5 id="IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192-168-0-0-1。"><a href="#IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192-168-0-0-1。" class="headerlink" title="IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192.168.0.0.1。"></a>IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192.168.0.0.1。</h5><h4 id="2-端口"><a href="#2-端口" class="headerlink" title="2.端口"></a>2.<font color="cornflowerblue">端口</font></h4><h5 id="端口号用来标记一台电脑中的不同应用程序。"><a href="#端口号用来标记一台电脑中的不同应用程序。" class="headerlink" title="端口号用来标记一台电脑中的不同应用程序。"></a>端口号用来标记一台电脑中的不同应用程序。</h5><h5 id="端口号范围是0-65535，其中0-1023是系统专用"><a href="#端口号范围是0-65535，其中0-1023是系统专用" class="headerlink" title="端口号范围是0-65535，其中0~1023是系统专用"></a>端口号范围是0-<font color="orange">65535</font>，其中0~1023是系统专用</h5><h3 id="二、Socket编程"><a href="#二、Socket编程" class="headerlink" title="二、Socket编程"></a>二、Socket编程</h3><p>略</p>
<h2 id="基于Http协议的网络通信"><a href="#基于Http协议的网络通信" class="headerlink" title="基于Http协议的网络通信"></a>基于Http协议的网络通信</h2><h3 id="一、HTTP协议工作原理"><a href="#一、HTTP协议工作原理" class="headerlink" title="一、HTTP协议工作原理"></a>一、HTTP协议工作原理</h3><h4 id="1-建立连接："><a href="#1-建立连接：" class="headerlink" title="1.建立连接："></a>1.<font color="cornflowerblue">建立连接</font>：</h4><p>客户机与服务器建立连接。输入网址、打开网页或单击超级链接。</p>
<h4 id="2-发送请求："><a href="#2-发送请求：" class="headerlink" title="2.发送请求："></a>2.<font color="cornflowerblue">发送请求</font>：</h4><p>客户机向服务器发送请求，格式为：<strong>统一资源标识符</strong>（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p>
<h4 id="3-响应请求："><a href="#3-响应请求：" class="headerlink" title="3.响应请求："></a>3.<font color="cornflowerblue">响应请求</font>：</h4><p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
<h4 id="4-接收响应："><a href="#4-接收响应：" class="headerlink" title="4.接收响应："></a>4.<font color="cornflowerblue">接收响应</font>：</h4><p>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后与服务器断开连接。</p>
<h3 id="二、HTTP请求报文"><a href="#二、HTTP请求报文" class="headerlink" title="二、HTTP请求报文"></a>二、HTTP<strong>请求报文</strong></h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215125047712.png" alt="image-20201215125047712"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215124600803.png" alt="image-20201215124600803"></p>
<h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.<font color="cornflowerblue">请求行</font></h4><h5 id="（1）请求方法"><a href="#（1）请求方法" class="headerlink" title="（1）请求方法"></a>（1）请求方法</h5><p>HTTP/1.1 定义的请求方法有8种，最常的两种GET和POST。</p>
<h5 id="（2）请求地址"><a href="#（2）请求地址" class="headerlink" title="（2）请求地址"></a>（2）请求地址</h5><p>URL:<font color="orange">统一资源定位符</font>，是一种资源位置的抽象唯一识别方法。<br>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;<br>端口和路径有时可以省略（HTTP默认端口号是80），有时会带参数，GET请求</p>
<h5 id="（3）版本协议"><a href="#（3）版本协议" class="headerlink" title="（3）版本协议"></a>（3）版本协议</h5><p>格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p>
<h4 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2.请求头部"></a>2.<font color="cornflowerblue">请求头部</font></h4><h5 id="（1）由键值对组成，每行一对，关键字和值用英文冒号“-”分隔。"><a href="#（1）由键值对组成，每行一对，关键字和值用英文冒号“-”分隔。" class="headerlink" title="（1）由键值对组成，每行一对，关键字和值用英文冒号“:”分隔。"></a>（1）由<font color="red">键值对</font>组成，每行一对，关键字和值用英文冒号“:”分隔。</h5><h5 id="（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有："><a href="#（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有：" class="headerlink" title="（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有："></a>（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有：</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215125315165.png" alt="image-20201215125315165"></p>
<h5 id="（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。"><a href="#（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。" class="headerlink" title="（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。"></a>（3）请求头部的最后<font color="red">会有一个空行，表示请求头部结束</font>，接下来为请求数据，这一行非常重要，必不可少。</h5><h4 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3.请求数据"></a>3.<font color="cornflowerblue">请求数据</font></h4><h5 id="（1）可选部分，比如GET请求就没有请求数据。"><a href="#（1）可选部分，比如GET请求就没有请求数据。" class="headerlink" title="（1）可选部分，比如GET请求就没有请求数据。"></a>（1）可选部分，比如GET请求就没有请求数据。</h5><h5 id="（2）HTTP的请求方式包括GET-POST-PUT-HEAD-DELETE-TRACE-CONNECT-OPTIONS等，最常用的发送请求的方式主要有-get-和-post两种"><a href="#（2）HTTP的请求方式包括GET-POST-PUT-HEAD-DELETE-TRACE-CONNECT-OPTIONS等，最常用的发送请求的方式主要有-get-和-post两种" class="headerlink" title="（2）HTTP的请求方式包括GET,POST, PUT ,HEAD, DELETE, TRACE, CONNECT, OPTIONS等，最常用的发送请求的方式主要有 get 和 post两种"></a>（2）HTTP的请求方式包括GET,POST, PUT ,HEAD, DELETE, TRACE, CONNECT, OPTIONS等，最常用的发送请求的方式主要有 get 和 post两种</h5><h4 id="4-GET与POST"><a href="#4-GET与POST" class="headerlink" title="4. GET与POST"></a>4. GET与POST</h4><h5 id="（1）get"><a href="#（1）get" class="headerlink" title="（1）get"></a>（1）get</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201215130633494.png" alt="image-20201215130633494"></p>
<h5 id="（2）post"><a href="#（2）post" class="headerlink" title="（2）post"></a>（2）post</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111436244.png" alt="image-20201216111436244"></p>
<h5 id="3-注意"><a href="#3-注意" class="headerlink" title="(3)注意"></a>(3)注意</h5><ul>
<li>GET 和 POST 两种请求方式都可以发送数据的，只是<font color="orange">发送机制</font>font&gt;不一样。</li>
<li>另外GET安全性非常低，Post<font color="orange">安全性较高</font>， 但是GET<font color="orange">执行效率</font>却比Post方法好。</li>
<li>一般<font color="orange">查询</font>的时候我们用<font color="orange">GET</font>，数据<font color="orange">增删改</font>的时候用<font color="orange">POST</font>。</li>
</ul>
<h5 id="4-其他区别"><a href="#4-其他区别" class="headerlink" title="(4)其他区别"></a>(4)其他区别</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111723498.png" alt="image-20201216111723498"></p>
<h3 id="三、HTTP响应报文"><a href="#三、HTTP响应报文" class="headerlink" title="三、HTTP响应报文"></a>三、HTTP响应报文</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111852290.png" alt="image-20201216111852290"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216111859563.png" alt="image-20201216111859563"></p>
<h4 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1.状态行"></a>1.状态行</h4><h5 id="（1）由3部分组成，分别为：协议版本，状态码，状态码描述）"><a href="#（1）由3部分组成，分别为：协议版本，状态码，状态码描述）" class="headerlink" title="（1）由3部分组成，分别为：协议版本，状态码，状态码描述）"></a>（1）由3部分组成，分别为：协议版本，<font color="red">状态码</font>，状态码描述）</h5><h5 id="（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述"><a href="#（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述" class="headerlink" title="（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述"></a>（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述</h5><h5 id="（3）常见状态码"><a href="#（3）常见状态码" class="headerlink" title="（3）常见状态码"></a>（3）常见状态码</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112057996.png" alt="image-20201216112057996"></p>
<h5 id="2-响应头部"><a href="#2-响应头部" class="headerlink" title="2.响应头部"></a>2.响应头部</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112237974.png" alt="image-20201216112237974"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216112254577.png" alt="image-20201216112254577"></p>
<h3 id="四、基于HTTP的网络编程"><a href="#四、基于HTTP的网络编程" class="headerlink" title="四、基于HTTP的网络编程"></a>四、基于HTTP的网络编程</h3><p>（HyperText Transfer protocol）<font color="cornflowerblue">超文本传输协议</font></p>
<h4 id="1-通过URL获取网络资源"><a href="#1-通过URL获取网络资源" class="headerlink" title="1.通过URL获取网络资源"></a>1.通过URL获取网络资源</h4><h5 id="（1）URL（Unifrom-Resource-Locator）统一资源定位器"><a href="#（1）URL（Unifrom-Resource-Locator）统一资源定位器" class="headerlink" title="（1）URL（Unifrom Resource Locator）统一资源定位器"></a>（1）URL（Unifrom Resource Locator）<font color="cornflowerblue">统一资源定位器</font></h5><p>可以定位到互联网的资源上。如果用户已经知道网络上某个资源的URL(如图片、音乐和视频文件等)，那么就可以直接通过使用URL来进行网络连接，获得资源</p>
<h5 id="（2）资源获取过程："><a href="#（2）资源获取过程：" class="headerlink" title="（2）资源获取过程："></a>（2）资源获取过程：</h5><ol>
<li>创建URL对象。</li>
<li>调用常用的方法来获取对应的资源。例如，使用<font color="red">openStream()</font>方法，打开与此URL的连接，并返回读取到的数据流。</li>
<li>将获得的数据流进行处理。例如，显示到ImageView上。</li>
</ol>
<p>说明：openStream() 实际是通过<font color="red">openConnection()</font>方法获取URLConnection对象，然后调用<font color="red">getInputStream()</font>方法，这个方法会隐式的调用connect() 方法发送连接请求。</p>
<p>URL url = new URL( “ …”);</p>
<p>HttpURLConnection connection = (HttpURLConnection) url.openConnection();</p>
<p>InputStream in = connection.getInputStream();</p>
<p>等加于</p>
<p>URL url = new URL( “ …”);</p>
<p>InputStream in = url.openStream();</p>
<h5 id="3-URL类常用的方法"><a href="#3-URL类常用的方法" class="headerlink" title="(3)URL类常用的方法"></a>(3)URL类常用的方法</h5><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216113912830.png" alt="image-20201216113912830">

<h5 id="（4）案例：图片资源获取并显示"><a href="#（4）案例：图片资源获取并显示" class="headerlink" title="（4）案例：图片资源获取并显示"></a>（4）案例：图片资源获取并显示</h5><p>1.布局文件：新建项目URLDemo，在布局文件中，准备一个ImageView控件。</p>
<p>2.初始化并准备异步任务类。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216114237925.png" alt="image-20201216114237925"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216114246080.png" alt="image-20201216114246080"></p>
<p>3.<strong>获取网络资源</strong>：在doInBackground()方法中执行联网以获取网络资源，获取到的图片信息作为返回结果，传给onPostExecute()中的参数</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216120334545.png" alt="image-20201216120334545"></p>
<p>4.<strong>资源显示</strong>：在onPostExecute()方法中进行图片显示。</p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201216120421728.png" alt="image-20201216120421728"></p>
<p>5.增加上网权限。</p>
<p>&lt;uses-permission android:”android.permission.INTERNET”/&gt;</p>
<h4 id="2-通过URLConnection获取网络资源"><a href="#2-通过URLConnection获取网络资源" class="headerlink" title="2.通过URLConnection获取网络资源"></a>2.通过URLConnection获取网络资源</h4><h5 id="（1）URL-对象提供了openConnection-方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。"><a href="#（1）URL-对象提供了openConnection-方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。" class="headerlink" title="（1）URL 对象提供了openConnection()方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。"></a>（1）URL 对象提供了<font color="cornflowerblue">openConnection()</font>方法返回一个<font color="cornflowerblue">URLConnection</font>对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。</h5><h5 id="（2）实现步骤"><a href="#（2）实现步骤" class="headerlink" title="（2）实现步骤"></a>（2）实现步骤</h5><ol>
<li>创建<font color="orange">URL对象</font>。</li>
<li>建立与URL的连接：由于<font color="orange">URLConnection</font>为抽象类，其对象不能直接实例化，通常通过<font color="orange">openConnection</font>方法获得。</li>
<li>获取返回的<font color="orange">InputStream</font>。</li>
<li>将InputStream进行处理：例如，显示到相应的控件上。</li>
<li>关闭流操作</li>
</ol>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217124051779.png" alt="image-20201217124051779"></p>
<h5 id="（3）URLConnection常用方法"><a href="#（3）URLConnection常用方法" class="headerlink" title="（3）URLConnection常用方法"></a>（3）URLConnection常用方法</h5><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public int <font color="red">getContentLength</font>()</td>
<td>获得文件的长度</td>
</tr>
<tr>
<td>public String getContentType()</td>
<td>获得文件的类型</td>
</tr>
<tr>
<td>public long getDate()</td>
<td>获得文件创建的时间</td>
</tr>
<tr>
<td>public long getLastModified()</td>
<td>获得文件最后修改的时间</td>
</tr>
<tr>
<td>public InputStream <font color="red">getInputStream()</font></td>
<td>获得输入流，以便读取文件的数据</td>
</tr>
<tr>
<td>public OutputStream getOutputStream()</td>
<td>获得输出流，以便输出数据</td>
</tr>
<tr>
<td>public void <font color="red">setRequestProperty(String key,String value)</font></td>
<td>设置请求属性值</td>
</tr>
<tr>
<td>connect()</td>
<td>打开到此URL引用的资源的通信连接(如果尚未建立连接)，如果已打开连接(此时connected()为true)，则忽略该调用</td>
</tr>
</tbody></table>
<h4 id="3-使用HttpURLConnection获取网络资源"><a href="#3-使用HttpURLConnection获取网络资源" class="headerlink" title="3.使用HttpURLConnection获取网络资源"></a>3.使用HttpURLConnection获取网络资源</h4><h5 id="（1）HttpURLConnection常用方法"><a href="#（1）HttpURLConnection常用方法" class="headerlink" title="（1）HttpURLConnection常用方法"></a>（1）HttpURLConnection常用方法</h5><p>HttpURLConnection是URLConnection的子类</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>InputStream <font color="red">getInputStream()</font></td>
<td>返回从此处打开的连接读取的输入流</td>
</tr>
<tr>
<td>OutputStream getOutputStream()</td>
<td>返回写入到此连接的输出流</td>
</tr>
<tr>
<td>String <font color="red">getRequestMethod()</font></td>
<td>获取请求方法</td>
</tr>
<tr>
<td>int getResponseCode()</td>
<td>获取状态码</td>
</tr>
<tr>
<td>void setRequestMethod(String method)</td>
<td>设置URL请求的方法</td>
</tr>
<tr>
<td>void setDoInput(boolean doinput)</td>
<td>设置输入流</td>
</tr>
<tr>
<td>void setDoOutput(boolean dooutput)</td>
<td>设置输出流</td>
</tr>
<tr>
<td>void setUseCaches(boolean usecaches)</td>
<td>设置连接是否使用任何可用的缓存</td>
</tr>
<tr>
<td>void disconnect()</td>
<td>关闭连接</td>
</tr>
</tbody></table>
<h5 id="（2）GET方式：将参数放在url后一起传递"><a href="#（2）GET方式：将参数放在url后一起传递" class="headerlink" title="（2）GET方式：将参数放在url后一起传递"></a>（2）GET方式：将参数放在url后一起传递</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125144443.png" alt="image-20201217125144443"></p>
<h5 id="（2）POST方法"><a href="#（2）POST方法" class="headerlink" title="（2）POST方法"></a>（2）POST方法</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125444529.png" alt="image-20201217125444529"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217125635416.png" alt="image-20201217125635416"></p>
<h2 id="使用WebView控件"><a href="#使用WebView控件" class="headerlink" title="使用WebView控件"></a>使用WebView控件</h2><h3 id="1-Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个-控件"><a href="#1-Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个-控件" class="headerlink" title="1.Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个 控件"></a>1.Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个 控件</h3><h3 id="2-WebView-网页视图-常用方法"><a href="#2-WebView-网页视图-常用方法" class="headerlink" title="2.WebView(网页视图)常用方法"></a>2.WebView(<font color="cornflowerblue">网页视图</font>)常用方法</h3><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>loadUrl(String url)</td>
<td>打开一个指定的Web资源页面</td>
</tr>
<tr>
<td>loadData(String data, StringmimeType,String encoding)</td>
<td>显示HTML格式的网页内容</td>
</tr>
<tr>
<td>getSettings()</td>
<td>获取WebView的设置对象</td>
</tr>
<tr>
<td>addJavascriptInterface()</td>
<td>将一个对象添加到JavaScript的全局对象Window中</td>
</tr>
<tr>
<td>clearCache()</td>
<td>清除缓存</td>
</tr>
<tr>
<td>destory()</td>
<td>销毁WebView</td>
</tr>
</tbody></table>
<h3 id="3-在应用中嵌入浏览器展示网页，并进行解析"><a href="#3-在应用中嵌入浏览器展示网页，并进行解析" class="headerlink" title="3.在应用中嵌入浏览器展示网页，并进行解析"></a>3.在应用中嵌入浏览器展示网页，并进行解析</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217130452896.png" alt="image-20201217130452896"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217130553473.png" alt="image-20201217130553473"></p>
<h2 id="使用OKHttp获取网络资源"><a href="#使用OKHttp获取网络资源" class="headerlink" title="使用OKHttp获取网络资源"></a>使用OKHttp获取网络资源</h2><h3 id="1-GET请求"><a href="#1-GET请求" class="headerlink" title="1.GET请求"></a>1.GET请求</h3><h4 id="（1）添加依赖"><a href="#（1）添加依赖" class="headerlink" title="（1）添加依赖"></a>（1）添加依赖</h4><h4 id="implementation-‘com-squareup-okhttp3-okhttp-3-10-0’"><a href="#implementation-‘com-squareup-okhttp3-okhttp-3-10-0’" class="headerlink" title="implementation ‘com.squareup.okhttp3:okhttp:3.10.0’"></a><font color="pink">implementation ‘com.squareup.okhttp3:okhttp:3.10.0’</font></h4><h4 id="（2）声明访问Internet的权限"><a href="#（2）声明访问Internet的权限" class="headerlink" title="（2）声明访问Internet的权限"></a>（2）声明访问Internet的权限</h4><h4 id="-9"><a href="#-9" class="headerlink" title></a><font color="red"><uses-permission android:name="android.permission.INTERNET"></uses-permission></font></h4><p>在application标签中添加<font color="red"> android:usesCleartextTraffic=”true”</font></p>
<h4 id="（3）创建-OkHttpClient实例"><a href="#（3）创建-OkHttpClient实例" class="headerlink" title="（3）创建 OkHttpClient实例"></a>（3）创建 OkHttpClient实例</h4><p><font color="red">OkHttpClient okHttpClient = new OkHttpClient();</font></p>
<h4 id="（4）构造Request对象。"><a href="#（4）构造Request对象。" class="headerlink" title="（4）构造Request对象。"></a>（4）构造Request对象。</h4><p><font color="red">final Request request = new Request.Builder() .url(url).get() </font>   //默认</p>
<p>就是GET请求，可以不写 .build();</p>
<h4 id="（5）构建Call对象"><a href="#（5）构建Call对象" class="headerlink" title="（5）构建Call对象"></a>（5）构建Call对象</h4><p><font color="red">Call call = okHttpClient.newCall(request);</font></p>
<h4 id="（6）-发送请求并获取服务器返回的数据。"><a href="#（6）-发送请求并获取服务器返回的数据。" class="headerlink" title="（6） 发送请求并获取服务器返回的数据。"></a>（6） 发送请求并获取服务器返回的数据。</h4><ul>
<li><h5 id="同步Get方法："><a href="#同步Get方法：" class="headerlink" title="同步Get方法："></a>同步Get方法：</h5></li>
</ul>
<h5 id="通过Call-execute-方法提交请求，放在子线程中执行，或者使用异步任务的方式"><a href="#通过Call-execute-方法提交请求，放在子线程中执行，或者使用异步任务的方式" class="headerlink" title="通过Call.execute()方法提交请求，放在子线程中执行，或者使用异步任务的方式"></a>通过<font color="red">Call.execute()</font>方法提交请求，放在<font color="orange">子线程</font>中执行，或者使用异步任务的方式</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217131925515.png" alt="image-20201217131925515"></p>
<ul>
<li><h5 id="异步Get方法："><a href="#异步Get方法：" class="headerlink" title="异步Get方法："></a>异步Get方法：</h5></li>
</ul>
<h5 id="通过Call-enqueue-Callback-方法来提交异步请求"><a href="#通过Call-enqueue-Callback-方法来提交异步请求" class="headerlink" title="通过Call.enqueue(Callback)方法来提交异步请求"></a>通过<font color="red">Call.enqueue(Callback)</font>方法来提交异步请求</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132051946.png" alt="image-20201217132051946"></p>
<h3 id="2-POST请求"><a href="#2-POST请求" class="headerlink" title="2.POST请求"></a>2.POST请求</h3><h4 id="（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如："><a href="#（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如：" class="headerlink" title="（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如："></a>（1）与上述GET请求相比，需要先构造一个<font color="red">RequestBody对象</font>用来存放待提交的数据，例如：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132351988.png" alt="image-20201217132351988"></p>
<h4 id="（2）然后在Request-Builder中调用一下post-方法，并将RequestBody对象传入："><a href="#（2）然后在Request-Builder中调用一下post-方法，并将RequestBody对象传入：" class="headerlink" title="（2）然后在Request.Builder中调用一下post()方法，并将RequestBody对象传入："></a>（2）然后在Request.Builder中调用一下post()方法，并将RequestBody对象传入：</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217132423939.png" alt="image-20201217132423939"></p>
<h4 id="（3）登录案例"><a href="#（3）登录案例" class="headerlink" title="（3）登录案例"></a>（3）登录案例</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133135117.png" alt="image-20201217133135117"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133213142.png" alt="image-20201217133213142"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201217133219867.png" alt="image-20201217133219867"></p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="一、JSON数据"><a href="#一、JSON数据" class="headerlink" title="一、JSON数据"></a>一、JSON数据</h3><h4 id="1-JSON-JavaScript-Object-Notation-是JavaScript的一个子集，是一种轻量级的数据交换格式。"><a href="#1-JSON-JavaScript-Object-Notation-是JavaScript的一个子集，是一种轻量级的数据交换格式。" class="headerlink" title="1.JSON(JavaScript Object Notation) 是JavaScript的一个子集，是一种轻量级的数据交换格式。"></a>1.JSON(JavaScript Object Notation) 是JavaScript的一个子集，是一种<font color="cornflowerblue">轻量级的数据交换格式</font>。</h4><h4 id="2-JSON的结构基于以下两点："><a href="#2-JSON的结构基于以下两点：" class="headerlink" title="2.JSON的结构基于以下两点："></a>2.JSON的结构基于以下两点：</h4><h5 id="（1）”名称-值”对的集合-：不同语言中，它被理解为对象-object-，记录-record-，结构-struct-，字典-dictionary-，哈希表-hash-table-，键列表-keyed-list-等。"><a href="#（1）”名称-值”对的集合-：不同语言中，它被理解为对象-object-，记录-record-，结构-struct-，字典-dictionary-，哈希表-hash-table-，键列表-keyed-list-等。" class="headerlink" title="（1）”名称/值”对的集合 ：不同语言中，它被理解为对象(object)，记录(record)，结构(struct)，字典(dictionary)，哈希表(hash table)，键列表(keyed list)等。"></a>（1）”名称/值”对的集合 ：不同语言中，它被理解为对象(object)，记录(record)，结构(struct)，字典(dictionary)，哈希表(hash table)，键列表(keyed list)等。</h5><h5 id="（2）值的有序列表：-多数语言中被理解为数组-array-。"><a href="#（2）值的有序列表：-多数语言中被理解为数组-array-。" class="headerlink" title="（2）值的有序列表： 多数语言中被理解为数组(array)。"></a>（2）值的有序列表： 多数语言中被理解为数组(array)。</h5><h4 id="3-JSON的形式主要有以下两种："><a href="#3-JSON的形式主要有以下两种：" class="headerlink" title="3.JSON的形式主要有以下两种："></a>3.JSON的形式主要有以下两种：</h4><h5 id="（1）对象"><a href="#（1）对象" class="headerlink" title="（1）对象"></a>（1）<font color="red">对象</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093521448.png" alt="image-20201219093521448"></p>
<h5 id="（2）数组"><a href="#（2）数组" class="headerlink" title="（2）数组"></a>（2）<font color="red">数组</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093539871.png" alt="image-20201219093539871"></p>
<h3 id="二、使用JSONObject解析JSON数据"><a href="#二、使用JSONObject解析JSON数据" class="headerlink" title="二、使用JSONObject解析JSON数据"></a>二、使用JSONObject解析JSON数据</h3><h4 id="1-案例：CityCodeDemo"><a href="#1-案例：CityCodeDemo" class="headerlink" title="1. 案例：CityCodeDemo"></a>1. 案例：CityCodeDemo</h4><p>通过Spinner控件，读取中国的城市名称，并通过选择获得该城市对应的编码值。</p>
<h5 id="1-准备JSON数据-创建assets目录"><a href="#1-准备JSON数据-创建assets目录" class="headerlink" title="(1)准备JSON数据,创建assets目录"></a>(1)准备JSON数据,创建assets目录</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219093921547.png" alt="image-20201219093921547"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094342080.png" alt="image-20201219094342080"></p>
<h5 id="2-布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。"><a href="#2-布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。" class="headerlink" title="(2)布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。"></a>(2)布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。</h5><h5 id="3-启动异步任务，进行文件读取"><a href="#3-启动异步任务，进行文件读取" class="headerlink" title="(3)启动异步任务，进行文件读取"></a>(3)启动异步任务，进行文件读取</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094525406.png" alt="image-20201219094525406"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219095314825.png" alt="image-20201219095314825"></p>
<h5 id="（4）定义实体类。装载JSON的解析结果"><a href="#（4）定义实体类。装载JSON的解析结果" class="headerlink" title="（4）定义实体类。装载JSON的解析结果"></a>（4）定义实体类。装载JSON的解析结果</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219094831461.png" alt="image-20201219094831461"></p>
<h5 id="（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表"><a href="#（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表" class="headerlink" title="（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表"></a>（5）<font color="red">解析JSON内容。将字符串转换为对应的CityCode实体对象列表</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219095531426.png" alt="image-20201219095531426"></p>
<h5 id="（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听"><a href="#（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听" class="headerlink" title="（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听"></a>（6）绑定界面控件。将解析得到的List<CityCode>通过适配器，绑定到spinner控件上，并设置子项监听</CityCode></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219100105438.png" alt="image-20201219100105438"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219100112597.png" alt="image-20201219100112597"></p>
<h4 id="2-安卓的资源文件assets"><a href="#2-安卓的资源文件assets" class="headerlink" title="2.安卓的资源文件assets"></a>2.安卓的资源文件assets</h4><h5 id="（1）Android资源文件的存放位置有三种："><a href="#（1）Android资源文件的存放位置有三种：" class="headerlink" title="（1）Android资源文件的存放位置有三种："></a>（1）Android资源文件的存放位置有三种：</h5><ul>
<li><h5 id="res目录下存放的可编译的资源文件；"><a href="#res目录下存放的可编译的资源文件；" class="headerlink" title="res目录下存放的可编译的资源文件；"></a><font color="orange">res</font>目录下存放的<font color="orange">可编译的资源文件</font>；</h5></li>
<li><h5 id="assets目录下存放的原生资源文件；"><a href="#assets目录下存放的原生资源文件；" class="headerlink" title="assets目录下存放的原生资源文件；"></a><font color="orange">assets</font>目录下存放的<font color="orange">原生资源文件</font>；</h5></li>
<li><h5 id="res-raw目录下存放的原生资源文件"><a href="#res-raw目录下存放的原生资源文件" class="headerlink" title="res/raw目录下存放的原生资源文件"></a><font color="orange">res/raw</font>目录下存放的<font color="orange">原生资源文件</font></h5></li>
</ul>
<h5 id="（2）assets与res-raw相同之处"><a href="#（2）assets与res-raw相同之处" class="headerlink" title="（2）assets与res/raw相同之处"></a>（2）assets与res/raw<font color="cornflowerblue">相同</font>之处</h5><ol>
<li>都可以用于放置APP所需的固定文件</li>
<li>该文件被打包到APK中时，不会被编码到二进制文件</li>
</ol>
<h5 id="（3）assets与res-raw不同之处"><a href="#（3）assets与res-raw不同之处" class="headerlink" title="（3）assets与res/raw不同之处"></a>（3）assets与res/raw<font color="cornflowerblue">不同</font>之处</h5><ol>
<li>assets目录不会被映射到R中，因此，资源无法通过R.id方式获取，必须要通过AssetManager进行操作与获取；res/raw目录下的资源会被映射到R中，可以通过getResource()方法获取资源。</li>
<li>多级目录：assets下可以有多级目录，res/raw下不可以有多级目录。</li>
</ol>
<h3 id="三、使用Goole-Gson解析JSON数据"><a href="#三、使用Goole-Gson解析JSON数据" class="headerlink" title="三、使用Goole Gson解析JSON数据"></a>三、使用Goole Gson解析JSON数据</h3><h4 id="1-Gson概述"><a href="#1-Gson概述" class="headerlink" title="1.Gson概述"></a>1.Gson概述</h4><h5 id="（1）Gson的解析非常简单-必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。"><a href="#（1）Gson的解析非常简单-必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。" class="headerlink" title="（1）Gson的解析非常简单:必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。"></a>（1）Gson的解析非常简单:必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。</h5><h5 id="（2）Gson有两个重要的方法"><a href="#（2）Gson有两个重要的方法" class="headerlink" title="（2）Gson有两个重要的方法"></a>（2）Gson有两个重要的方法</h5><p><font color="red">toJson（）</font>：序列化Java对象成JSON字符串</p>
<p><font color="red">fromJson()</font>：反序列化对象成Java对象</p>
<h4 id="2-解析Json数据"><a href="#2-解析Json数据" class="headerlink" title="2.解析Json数据"></a>2.解析Json数据</h4><h5 id="（1）准备一个Person类"><a href="#（1）准备一个Person类" class="headerlink" title="（1）准备一个Person类"></a>（1）准备一个Person类</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101538843.png" alt="image-20201219101538843"></p>
<h5 id="（2））toJson-方法用于将bean对象换为Json数据"><a href="#（2））toJson-方法用于将bean对象换为Json数据" class="headerlink" title="（2））toJson()方法用于将bean对象换为Json数据"></a>（2））toJson()方法用于将bean对象换为Json数据</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101558372.png" alt="image-20201219101558372"></p>
<h5 id="（3）fromJson-方法用于将Json数据转换为bean对象"><a href="#（3）fromJson-方法用于将Json数据转换为bean对象" class="headerlink" title="（3）fromJson()方法用于将Json数据转换为bean对象"></a>（3）fromJson()方法用于将Json数据转换为bean对象</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219101620318.png" alt="image-20201219101620318"></p>
<h2 id="网络通信框架Volley"><a href="#网络通信框架Volley" class="headerlink" title="网络通信框架Volley"></a>网络通信框架Volley</h2><h3 id="一、Volley概述"><a href="#一、Volley概述" class="headerlink" title="一、Volley概述"></a>一、Volley概述</h3><h4 id="1-Volley特别适合数据量不大但通信频繁的场景"><a href="#1-Volley特别适合数据量不大但通信频繁的场景" class="headerlink" title="1.Volley特别适合数据量不大但通信频繁的场景"></a>1.Volley特别适合<font color="cornflowerblue">数据量不大但通信频繁</font>的场景</h4><h4 id="2-不使用Volley，从网上下载资源的步骤大致如下："><a href="#2-不使用Volley，从网上下载资源的步骤大致如下：" class="headerlink" title="2.不使用Volley，从网上下载资源的步骤大致如下："></a>2.不使用Volley，从网上下载资源的步骤大致如下：</h4><h5 id="（1）首先，在AsyncTask的doInBackground-中，使用HttpURLConnection从服务器获取相关资源。"><a href="#（1）首先，在AsyncTask的doInBackground-中，使用HttpURLConnection从服务器获取相关资源。" class="headerlink" title="（1）首先，在AsyncTask的doInBackground()中，使用HttpURLConnection从服务器获取相关资源。"></a>（1）首先，在AsyncTask的doInBackground()中，使用HttpURLConnection从服务器获取相关资源。</h5><h5 id="（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute-里设置到相应的控件中。"><a href="#（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute-里设置到相应的控件中。" class="headerlink" title="（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute()里设置到相应的控件中。"></a>（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute()里设置到相应的控件中。</h5><h5 id="而在Volley下，上述只需要一个函数就可以完成上述步骤"><a href="#而在Volley下，上述只需要一个函数就可以完成上述步骤" class="headerlink" title="而在Volley下，上述只需要一个函数就可以完成上述步骤"></a>而在Volley下，上述只需要一个函数就可以完成上述步骤</h5><h3 id="二、Volley的使用步骤"><a href="#二、Volley的使用步骤" class="headerlink" title="二、Volley的使用步骤"></a>二、Volley的使用步骤</h3><h4 id="1-声明RequestQueue"><a href="#1-声明RequestQueue" class="headerlink" title="1.声明RequestQueue"></a>1.声明<font color="cornflowerblue">RequestQueue</font></h4><h4 id="2-为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象"><a href="#2-为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象" class="headerlink" title="2.为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象"></a>2.为了获得请求的响应，我们需要根据响应的结果，<font color="cornflowerblue">调用不同的Request对象</font></h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102328576.png" alt="image-20201219102328576"></p>
<h3 id="三、通过Volley获取字符串"><a href="#三、通过Volley获取字符串" class="headerlink" title="三、通过Volley获取字符串"></a>三、通过Volley获取字符串</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102423614.png" alt="image-20201219102423614"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102436859.png" alt="image-20201219102436859"></p>
<h3 id="四、通过Volley获取JSON数据"><a href="#四、通过Volley获取JSON数据" class="headerlink" title="四、通过Volley获取JSON数据"></a>四、通过Volley获取JSON数据</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102603231.png" alt="image-20201219102603231"></p>
<h3 id="五、通过Volley获取图片资源"><a href="#五、通过Volley获取图片资源" class="headerlink" title="五、通过Volley获取图片资源"></a>五、通过Volley获取图片资源</h3><h4 id="1-ImageRequest"><a href="#1-ImageRequest" class="headerlink" title="1.ImageRequest"></a>1.ImageRequest</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102644623.png" alt="image-20201219102644623"></p>
<h4 id="2-ImageLoader"><a href="#2-ImageLoader" class="headerlink" title="2.ImageLoader"></a>2.ImageLoader</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102720895.png" alt="image-20201219102720895"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102741316.png" alt="image-20201219102741316"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201219102801828.png" alt="image-20201219102801828"></p>
<h1 id="第十章-后台默默劳动者——服务"><a href="#第十章-后台默默劳动者——服务" class="headerlink" title="第十章 后台默默劳动者——服务"></a>第十章 后台默默劳动者——服务</h1><h2 id="Android多线程编程"><a href="#Android多线程编程" class="headerlink" title="Android多线程编程"></a>Android多线程编程</h2><h3 id="一、线程概述"><a href="#一、线程概述" class="headerlink" title="一、线程概述"></a>一、线程概述</h3><h4 id="1-Android系统中，App运行后默认创建一个线程，即主线程。"><a href="#1-Android系统中，App运行后默认创建一个线程，即主线程。" class="headerlink" title="1.Android系统中，App运行后默认创建一个线程，即主线程。"></a>1.Android系统中，App运行后默认创建一个线程，即<font color="red">主线程</font>。</h4><p>​        ——Activity、Service和BroadcastReceiver都是工作在主线程上。</p>
<h4 id="2-主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。"><a href="#2-主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。" class="headerlink" title="2.主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。"></a>2.主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做<font color="red">UI线程</font>。</h4><pre><code> 主线程中任何耗时的操作都会的降低用户界面的响应速度，甚至导致用户界面失去响应。
</code></pre>
<p>例如，发起一条网络请求时，考虑到网速等其他原因，服务器未必会立刻响应我们的请求</p>
<p>​    较好的解决方法是<font color="orange">将耗时的处理过程转移到子线程上</font>，这样可以避免负责界面更新的主线程（UI线程）无法处理界面事件，从而避免用户界面长时间失去响应。</p>
<h3 id="二、主线程和子线程"><a href="#二、主线程和子线程" class="headerlink" title="二、主线程和子线程"></a>二、主线程和子线程</h3><h4 id="1-主线程"><a href="#1-主线程" class="headerlink" title="1.主线程"></a>1.主线程</h4><ul>
<li><p>UI线程，负责处理与UI相关的事件，并把事件分发到对应的组件进行处理。</p>
</li>
<li><p>应用首次启动时，Android会启动一个Linux进程和一个主线程。</p>
</li>
<li><p>Android <font color="red">UI操作必须在UI线程中执行</font>。由于Android的UI是单线程(Single-threaded)的，当其任务繁重时，则需要其他线程来进行配合工作。</p>
</li>
</ul>
<h4 id="2-子线程"><a href="#2-子线程" class="headerlink" title="2.子线程"></a>2.子线程</h4><ul>
<li>非UI线程即为子线程，子线程一般都是<font color="red">后台线程</font>。</li>
<li>运用子线程的场合：进行数据、系统等其他非UI的操作或者把所有运行慢的、耗时的操作移出主线程，放到子线程中。</li>
<li>通常，子线程需要开发人员对其进行定义、启动、终止等操作控制。</li>
</ul>
<h3 id="三、同步与异步"><a href="#三、同步与异步" class="headerlink" title="三、同步与异步"></a>三、同步与异步</h3><h4 id="1-同步：需要等待放回结果"><a href="#1-同步：需要等待放回结果" class="headerlink" title="1.同步：需要等待放回结果"></a>1.同步：需要等待放回结果</h4><h4 id="异步：不需要等待返回结果"><a href="#异步：不需要等待返回结果" class="headerlink" title="异步：不需要等待返回结果"></a>异步：不需要等待返回结果</h4><h4 id="2-无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。"><a href="#2-无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。" class="headerlink" title="2.无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。"></a>2.无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要<font color="red">线程间通讯</font>的方法来实现在其他线程中发消息给主线程处理（更新UI）。</h4><h3 id="四、线程间通讯"><a href="#四、线程间通讯" class="headerlink" title="四、线程间通讯"></a>四、线程间通讯</h3><h4 id="1-Activity-runOnUiThread-Runnable"><a href="#1-Activity-runOnUiThread-Runnable" class="headerlink" title="1) Activity.runOnUiThread(Runnable)"></a>1) Activity.runOnUiThread(Runnable)</h4><h4 id="2-View-post-Runnable-View-postDelay-Runnable-long"><a href="#2-View-post-Runnable-View-postDelay-Runnable-long" class="headerlink" title="2) View.post(Runnable) ;View.postDelay(Runnable , long)"></a>2) View.post(Runnable) ;View.postDelay(Runnable , long)</h4><h4 id="3-Handler"><a href="#3-Handler" class="headerlink" title="3) Handler"></a>3) <font color="red">Handler</font></h4><h4 id="post-postDelay"><a href="#post-postDelay" class="headerlink" title="post, postDelay"></a><font color="red">post, postDelay</font></h4><h4 id="sendMessage-handleMessage"><a href="#sendMessage-handleMessage" class="headerlink" title="sendMessage, handleMessage"></a><font color="red">sendMessage, handleMessage</font></h4><h4 id="4-AsyncTask"><a href="#4-AsyncTask" class="headerlink" title="4) AsyncTask"></a>4) <font color="red">AsyncTask</font></h4><h4 id="5-广播"><a href="#5-广播" class="headerlink" title="5) 广播"></a>5) <font color="cornflowerblue">广播</font></h4><h3 id="五、线程的状态和生命周期"><a href="#五、线程的状态和生命周期" class="headerlink" title="五、线程的状态和生命周期"></a>五、线程的状态和生命周期</h3><ol>
<li><h4 id="创建状态"><a href="#创建状态" class="headerlink" title="创建状态"></a>创建状态</h4><p>用new运算符创建一个Thread类或子类的<font color="orange">实例对象</font>，但此时还未对这个线程分配任何资源</p>
</li>
<li><h4 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h4><p>分配系统资源，由<font color="orange">start()启动</font>方法来完成</p>
</li>
<li><h4 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h4><p>当可运行状态的线程被调度并获得CPU等资源。<font color="orange">进入run()</font>方法。</p>
</li>
<li><h4 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h4><p>由于人为或系统的原因，线程必须停止运行，以后还可以恢复运行的状态称为阻塞状态。</p>
</li>
<li><h4 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h4><p>run()方法完成或调用<font color="orange">stop()</font>或<font color="orange">destroy()</font>方法，不能继续运行。</p>
</li>
</ol>
<h3 id="六、线程的基本用法"><a href="#六、线程的基本用法" class="headerlink" title="六、线程的基本用法"></a>六、线程的基本用法</h3><h4 id="1-创建线程的方法"><a href="#1-创建线程的方法" class="headerlink" title="1. 创建线程的方法"></a>1. 创建线程的方法</h4><h5 id="（1）方法一：通过继承Thread类创建线程"><a href="#（1）方法一：通过继承Thread类创建线程" class="headerlink" title="（1）方法一：通过继承Thread类创建线程"></a>（1）方法一：通过<font color="red">继承Thread类</font>创建线程</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124132913675.png" alt="image-20201124132913675"></p>
<h5 id="（2）方法二：通过实现Runnable接口来创建线程"><a href="#（2）方法二：通过实现Runnable接口来创建线程" class="headerlink" title="（2）方法二：通过实现Runnable接口来创建线程"></a>（2）方法二：通过<font color="red">实现Runnable接口</font>来创建线程</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124133310441.png" alt="image-20201124133310441"></p>
<h5 id="（3）方法三：不实现Runnable接口，直接使用匿名类的方式"><a href="#（3）方法三：不实现Runnable接口，直接使用匿名类的方式" class="headerlink" title="（3）方法三：不实现Runnable接口，直接使用匿名类的方式"></a>（3）方法三：不实现Runnable接口，直接<font color="red">使用匿名类</font>的方式</h5><h5 id="（方式二的简化）"><a href="#（方式二的简化）" class="headerlink" title="（方式二的简化）"></a>（方式二的简化）</h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124133439513.png" alt="image-20201124133439513"></p>
<h4 id="2-线程的运行与停止"><a href="#2-线程的运行与停止" class="headerlink" title="2.线程的运行与停止"></a>2.线程的运行与停止</h4><h5 id="（1）myThread-interrupt"><a href="#（1）myThread-interrupt" class="headerlink" title="（1）myThread. interrupt ();"></a>（1）myThread<font color="cornflowerblue">. interrupt ();</font></h5><p>​        线程启动后并获得资源后，即可进入运行状态，执行run()方法中的业务逻辑。<br>在run()方法返回后，线程<font color="orange">自动终止</font>。</p>
<p>或者由主线程通知子线程终止，一般<font color="orange">调用interrupt()方法</font>通告线程准备终止</p>
<h5 id="（2）Thread-interrupted"><a href="#（2）Thread-interrupted" class="headerlink" title="（2）Thread.interrupted()"></a>（2）Thread.<font color="cornflowerblue">interrupted()</font></h5><p>​        interrupt()方法改变了线程内部的一个布尔值，可在run()方法检测到这个布尔值的改变，从而<font color="orange">在适当的时候释放资源和终止</font>线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">run</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">while</span>(!Thread.<span class="built_in">interrupted</span>())&#123;</span><br><span class="line">         ...	<span class="comment">//未调用myThread.interrupt()时循环执行</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="七、异步消息处理机制（Handler-Message）"><a href="#七、异步消息处理机制（Handler-Message）" class="headerlink" title="七、异步消息处理机制（Handler + Message）"></a>七、异步消息处理机制（Handler + Message）</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140620842.png" alt="image-20201124140620842"></p>
<h4 id="1-异步消息处理流程"><a href="#1-异步消息处理流程" class="headerlink" title="1.异步消息处理流程"></a>1.异步消息处理流程</h4><h5 id="（1）主线程：创建Handler对象，重写handleMessage方法"><a href="#（1）主线程：创建Handler对象，重写handleMessage方法" class="headerlink" title="（1）主线程：创建Handler对象，重写handleMessage方法"></a>（1）主线程：创建Handler对象，重写handleMessage方法</h5><h5 id="（2）子线程：创建Message对象，发送消息"><a href="#（2）子线程：创建Message对象，发送消息" class="headerlink" title="（2）子线程：创建Message对象，发送消息"></a>（2）子线程：创建Message对象，发送消息</h5><p>​                当子线程需要进行UI操作时，就<font color="orange">创建Message</font>对象，并通过Handler的            <font color="orange">sendMessage()方法</font>（参数是Message对象），将将这条消息发送出去。            这条待处理的消息会被 添加到主线程的<font color="orange">MessageQueue</font>中。</p>
<h5 id="（3）主线程：处理消息，回调handleMessage"><a href="#（3）主线程：处理消息，回调handleMessage" class="headerlink" title="（3）主线程：处理消息，回调handleMessage"></a>（3）主线程：处理消息，回调handleMessage</h5><p>​            主线程通过<font color="orange">Looper管理</font>MessageQueue，不断地尝试从消息队列中取出    待处理消息进行处理，取出消息时就会回调 Handler的<font color="orange">handlerMessage()</font>方法</p>
<p>​        </p>
<h4 id="2-Hander类"><a href="#2-Hander类" class="headerlink" title="2.Hander类"></a>2.<font color="cornflowerblue">Hander</font>类</h4><p>使用Hnadler类的sendMessage()方法把一个包含消息数据的Message对象压入到消息队列。其它可选方法还包括：<br>sendEmptyMessage(int)<br>sendMessage(Message)<br>sendMessageAtTime(Message,long)<br>sendMessageDelayed(Message,long)</p>
<h4 id="3-Message类"><a href="#3-Message类" class="headerlink" title="3.Message类"></a>3.<font color="cornflowerblue">Message</font>类</h4><h5 id="（1）Message对象："><a href="#（1）Message对象：" class="headerlink" title="（1）Message对象："></a>（1）Message对象：</h5><p>推荐使用<font color="red">Message.obtain()</font> 静态方法从消息池中获取一个Message对象。<br>如果消息池为空， 将使用构造方法实例化一个新Message，以利于消息资源的利用。<br>一般并不推荐直接使用它的构造方法</p>
<h5 id="（2）用来封装所发送消息的值："><a href="#（2）用来封装所发送消息的值：" class="headerlink" title="（2）用来封装所发送消息的值："></a>（2）用来封装所发送消息的值：</h5><p>int arg1：参数一，用于传递不复杂的数据，复杂数据使用setData()传递。<br>int arg2：参数二，用于传递不复杂的数据，复杂数据使用setData()传递。<br>Object obj：传递一个任意的对象。<br>int what：定义的消息码，一般用于设定消息的标志。</p>
<h5 id="3-传递复杂数据-setData"><a href="#3-传递复杂数据-setData" class="headerlink" title="(3)传递复杂数据 setData()"></a>(3)传递复杂数据 setData()</h5><p>​    –void setData( Bundle bundle)</p>
<p>​    –Bundle getData()</p>
<h4 id="2-案例实现：幸运大抽奖（方式一）"><a href="#2-案例实现：幸运大抽奖（方式一）" class="headerlink" title="2.案例实现：幸运大抽奖（方式一）"></a>2.案例实现：幸运大抽奖（方式一）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140746244.png" alt="image-20201124140746244"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140752579.png" alt="image-20201124140752579"></p>
<p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201124140759685.png" alt="image-20201124140759685"></p>
<h3 id="八、异步消息处理机制（Handler-Post）"><a href="#八、异步消息处理机制（Handler-Post）" class="headerlink" title="八、异步消息处理机制（Handler + Post）"></a>八、异步消息处理机制（Handler + Post）</h3><h4 id="1-Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。-在主线程中执行"><a href="#1-Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。-在主线程中执行" class="headerlink" title="1. Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。(在主线程中执行)"></a>1. Handler也可以把一个<font color="cornflowerblue">Runnable对象</font>压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。(<font color="red">在主线程中执行</font>)</h4><h5 id="（1）把一个Runnable对象入队到消息队列-方法有："><a href="#（1）把一个Runnable对象入队到消息队列-方法有：" class="headerlink" title="（1）把一个Runnable对象入队到消息队列,方法有："></a>（1）把一个Runnable对象入队到消息队列,方法有：</h5><ul>
<li><p><font color="red">post</font>(Runnable)</p>
</li>
<li><p>postAtTime(Runnable,long)</p>
</li>
<li><p>postDelayed(Runnable,long)</p>
</li>
</ul>
<h5 id="2-从消息队列中移除一个Runnable对象"><a href="#2-从消息队列中移除一个Runnable对象" class="headerlink" title="(2)从消息队列中移除一个Runnable对象"></a>(2)从消息队列中移除一个Runnable对象</h5><p>​            void <font color="red">removeCallbacks</font>(Runnable r)</p>
<h4 id="2-对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run-方法。一般在这个run-方法中写入需要在UI线程上的操作。"><a href="#2-对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run-方法。一般在这个run-方法中写入需要在UI线程上的操作。" class="headerlink" title="2.对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run()方法。一般在这个run()方法中写入需要在UI线程上的操作。"></a>2.对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，<font color="red">重写run()方法</font>。一般在这个run()方法中写入<font color="red">需要在UI线程上的操作</font>。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201130202655320.png" alt="image-20201130202655320"></p>
<h4 id="3-案例实现：幸运大抽奖（方式二）"><a href="#3-案例实现：幸运大抽奖（方式二）" class="headerlink" title="3. 案例实现：幸运大抽奖（方式二）"></a>3. 案例实现：幸运大抽奖（方式二）</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201130203252201.png" alt="image-20201130203252201"></p>
<h2 id="服务的原理和用途"><a href="#服务的原理和用途" class="headerlink" title="服务的原理和用途"></a>服务的原理和用途</h2><h3 id="一、启动服务的两种状态"><a href="#一、启动服务的两种状态" class="headerlink" title="一、启动服务的两种状态"></a>一、启动服务的两种状态</h3><h4 id="1-启动状态：通过Context的startService-启动service"><a href="#1-启动状态：通过Context的startService-启动service" class="headerlink" title="1.启动状态：通过Context的startService()启动service"></a>1.<font color="cornflowerblue">启动状态</font>：通过Context的<font color="red">startService()</font>启动service</h4><h5 id="一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService-或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁"><a href="#一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService-或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁" class="headerlink" title="一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService()或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁"></a>一旦启动，服务即<font color="orange">可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响</font>，除非手动调用stopService()或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁</h5><h4 id="2-绑定状态：通过Context的bindService-绑定Service"><a href="#2-绑定状态：通过Context的bindService-绑定Service" class="headerlink" title="2.绑定状态：通过Context的bindService()绑定Service"></a>2.<font color="cornflowerblue">绑定状态</font>：通过Context的<font color="red">bindService()</font>绑定Service</h4><p>​        <font color="orange">绑定服务提供了一个客户端-服务器接口，允许调用方与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。</font> 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个调用方可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁</p>
<h3 id="二、在清单文件中的声明"><a href="#二、在清单文件中的声明" class="headerlink" title="二、在清单文件中的声明"></a>二、在清单文件中的声明</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201125094605395.png" alt="image-20201125094605395"></p>
<h3 id="四、使用Service"><a href="#四、使用Service" class="headerlink" title="四、使用Service"></a>四、使用Service</h3><h4 id="1-首先要创建服务，必须创建-Service-的子类（或使用它的一个现有子类如IntentService）。"><a href="#1-首先要创建服务，必须创建-Service-的子类（或使用它的一个现有子类如IntentService）。" class="headerlink" title="1.首先要创建服务，必须创建 Service 的子类（或使用它的一个现有子类如IntentService）。"></a>1.首先要创建服务，必须<font color="red">创建 Service 的子类</font>（或使用它的一个现有子类如IntentService）。</h4><h4 id="2-类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。"><a href="#2-类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。" class="headerlink" title="2.类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。"></a>2.类似Activity，Service有自己的生命周期，因此在实现中需要<font color="red">重写一些回调方法</font>，以处理服务生命周期的某些关键过程。</h4><h4 id="3-随后，组件-例如活动-以启动或者绑定方式启动服务，服务开始其生命过程"><a href="#3-随后，组件-例如活动-以启动或者绑定方式启动服务，服务开始其生命过程" class="headerlink" title="3.随后，组件(例如活动)以启动或者绑定方式启动服务，服务开始其生命过程"></a>3.随后，组件(例如活动)以<font color="red">启动或者绑定方式启动服务</font>，服务开始其生命过程</h4><h3 id="五、Service中常用回调方法"><a href="#五、Service中常用回调方法" class="headerlink" title="五、Service中常用回调方法"></a>五、Service中常用回调方法</h3><h4 id="1-abstract-IBinder-onBind-Intent-intent"><a href="#1-abstract-IBinder-onBind-Intent-intent" class="headerlink" title="1.abstract IBinder onBind(Intent intent)"></a>1.abstract IBinder <font color="cornflowerblue">onBind</font>(Intent intent)</h4><p>该方法是一个抽象方法，所有Service子类必须实现该方法。该方法将返回一个IBinder对象，应用程序可<font color="red">通过该对象与Service组件通信</font>；</p>
<h4 id="2-void-onCreate"><a href="#2-void-onCreate" class="headerlink" title="2.void onCreate()"></a>2.void <font color="cornflowerblue">onCreate()</font></h4><p>当Service<font color="red">第一次被创建时</font>，将立即回调该方法；</p>
<h4 id="3-void-onDestroy"><a href="#3-void-onDestroy" class="headerlink" title="3.void onDestroy()"></a>3.void <font color="cornflowerblue">onDestroy()</font></h4><p>当Service<font color="red">被关闭之前</font>，将回调该方法</p>
<h4 id="4-void-onStartCommand-Intent-intent-int-flags-int-startId"><a href="#4-void-onStartCommand-Intent-intent-int-flags-int-startId" class="headerlink" title="4.void onStartCommand(Intent intent,int flags,int startId)"></a>4.void <font color="cornflowerblue">onStartCommand(Intent intent,int flags,int startId)</font></h4><p>每次客户端调用startService(Intent intent)方法<font color="red">启动</font>该Service时<font color="red">都会回调</font>onStartCommand()方法</p>
<h4 id="5-boolean-onUnbind-Intent-intent"><a href="#5-boolean-onUnbind-Intent-intent" class="headerlink" title="5.boolean onUnbind(Intent intent)"></a>5.boolean <font color="cornflowerblue">onUnbind(Intent intent)</font></h4><p>当该Service上绑定的所有客户端都<font color="red">断开连接</font>时将会回调该方法。</p>
<h3 id="六、活动的生命周期"><a href="#六、活动的生命周期" class="headerlink" title="六、活动的生命周期"></a>六、活动的生命周期</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201125095321429.png" alt="image-20201125095321429"></p>
<h2 id="启动方式启动服务"><a href="#启动方式启动服务" class="headerlink" title="启动方式启动服务"></a>启动方式启动服务</h2><h3 id="一、StartService生命周期及进程相关"><a href="#一、StartService生命周期及进程相关" class="headerlink" title="一、StartService生命周期及进程相关"></a>一、StartService生命周期及进程相关</h3><h4 id="1-对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。"><a href="#1-对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。" class="headerlink" title="1.对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。"></a>1.对于同一类型的Service，<font color="red">Service实例永远只存在一个</font>，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。</h4><h4 id="2-以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService-或服务本身调用stopSelf-才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service"><a href="#2-以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService-或服务本身调用stopSelf-才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service" class="headerlink" title="2.以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService(..)或服务本身调用stopSelf(..)才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service"></a>2.以启动方式运行的服务，其<font color="red">生命周期是独立的，与Client本身的生命周期没有任何关系</font>，只有Client调用stopService(..)或服务本身调用stopSelf(..)才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service</h4><h4 id="3-Client-A-通过startService-启动Service后-可以在其他Client（如Client-B、Client-C）通过调用stopService-结束此Service"><a href="#3-Client-A-通过startService-启动Service后-可以在其他Client（如Client-B、Client-C）通过调用stopService-结束此Service" class="headerlink" title="3.Client A 通过startService(..)启动Service后,可以在其他Client（如Client B、Client C）通过调用stopService(..)结束此Service"></a>3.Client A 通过<font color="red">startService(..)</font>启动Service后,可以在其他Client（如Client B、Client C）通过调用<font color="red">stopService(..)结束</font>此Service</h4><h4 id="4-Client调用stopService-时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService-无需做当前Service是否有效的判断。"><a href="#4-Client调用stopService-时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService-无需做当前Service是否有效的判断。" class="headerlink" title="4.Client调用stopService(..)时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService(..)无需做当前Service是否有效的判断。"></a>4.Client调用stopService(..)时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService(..)<font color="red">无需做当前Service是否有效的判断。</font></h4><h4 id="5-startService-Intent-serviceIntent-，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。"><a href="#5-startService-Intent-serviceIntent-，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。" class="headerlink" title="5.startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。"></a>5.startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用<font color="red">显示Intent</font>。当处于不同App时，只能使用隐式Intent。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111515792.png" alt="image-20201214111515792"></p>
<h3 id="二、Client与Service通信相关"><a href="#二、Client与Service通信相关" class="headerlink" title="二、Client与Service通信相关"></a>二、Client与Service通信相关</h3><h4 id="1-启动Service时"><a href="#1-启动Service时" class="headerlink" title="1.启动Service时"></a>1.启动Service时</h4><h5 id="当Client调用startService-Intent-serviceIntent-启动Service时，Client可以将参数通过Intent直接传递给Service。"><a href="#当Client调用startService-Intent-serviceIntent-启动Service时，Client可以将参数通过Intent直接传递给Service。" class="headerlink" title="当Client调用startService(Intent serviceIntent)启动Service时，Client可以将参数通过Intent直接传递给Service。"></a>当Client调用startService(Intent serviceIntent)<font color="red">启动Service</font>时，Client可以<font color="red">将参数通过Intent直接传递</font>给Service。</h5><h4 id="2-Service执行过程中"><a href="#2-Service执行过程中" class="headerlink" title="2.Service执行过程中"></a>2.Service执行过程中</h4><h5 id="Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。"><a href="#Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。" class="headerlink" title="Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。"></a><font color="red">Service执行过程</font>中，如果需要将参数传递给Client，一般可以通过<font color="red">借助于发送广播</font>的方式（此时，Client需要注册此广播）。</h5><h2 id="绑定方式启动服务"><a href="#绑定方式启动服务" class="headerlink" title="绑定方式启动服务"></a>绑定方式启动服务</h2><h3 id="一、三个基本特征"><a href="#一、三个基本特征" class="headerlink" title="一、三个基本特征"></a>一、三个基本特征</h3><h4 id="1-C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器"><a href="#1-C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器" class="headerlink" title="1.C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器"></a>1.<font color="cornflowerblue">C-S模式</font>：绑定状态的服务代表着客户端-服务器接口中的<font color="orange">服务器</font></h4><h4 id="2-交互与通信：当其他组件（如-Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信-。"><a href="#2-交互与通信：当其他组件（如-Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信-。" class="headerlink" title="2.交互与通信：当其他组件（如 Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信 。"></a>2.<font color="cornflowerblue">交互与通信</font>：当其他组件（如 Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，<font color="orange">或者调用Service（服务端）的方法</font>，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信 。</h4><h4 id="3-生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件-如Activity-服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主-如Activity-解除绑定后，绑定服务就会被销毁。"><a href="#3-生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件-如Activity-服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主-如Activity-解除绑定后，绑定服务就会被销毁。" class="headerlink" title="3.生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主(如Activity)解除绑定后，绑定服务就会被销毁。"></a>3.<font color="cornflowerblue">生命周期</font>：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说所有<font color="orange">宿主(如Activity)解除绑定后，绑定服务就会被销毁</font>。</h4><h3 id="二、BindService生命周期"><a href="#二、BindService生命周期" class="headerlink" title="二、BindService生命周期"></a>二、BindService生命周期</h3><h4 id="1-onBind方法只被调用一次。（当调用bindService-方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind-方法。"><a href="#1-onBind方法只被调用一次。（当调用bindService-方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind-方法。" class="headerlink" title="1.onBind方法只被调用一次。（当调用bindService()方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind()方法。"></a>1.onBind方法只被调用一次。（当调用<font color="orange">bindService()</font>方法是）Service第一次被创建时会执行<font color="red">onCreate</font>方法，之后自动调用<font color="red">onBind()</font>方法。</h4><h4 id="2-当调用unBindService-方法时，Service会依次执行onUnbind-、onDestroy-方法结束生命周期"><a href="#2-当调用unBindService-方法时，Service会依次执行onUnbind-、onDestroy-方法结束生命周期" class="headerlink" title="2.当调用unBindService()方法时，Service会依次执行onUnbind()、onDestroy()方法结束生命周期"></a>2.当调用<font color="orange">unBindService()</font>方法时，Service会依次执行<font color="red">onUnbind()</font>、<font color="red">onDestroy()</font>方法结束生命周期</h4><h4 id="3-如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService-解除绑定。"><a href="#3-如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService-解除绑定。" class="headerlink" title="3.如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService()解除绑定。"></a>3.如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService()解除绑定。</h4><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/577f98926daf5.jpg" alt="img"></p>
<h3 id="三、一般流程！！！"><a href="#三、一般流程！！！" class="headerlink" title="三、一般流程！！！"></a>三、一般流程！！！</h3><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111833380.png" alt="image-20201214111833380"></p>
<h4 id="1-服务端，Service中"><a href="#1-服务端，Service中" class="headerlink" title="1.服务端，Service中"></a>1.服务端，Service中</h4><h5 id="（1）创建Binder子类，返回服务实例对象"><a href="#（1）创建Binder子类，返回服务实例对象" class="headerlink" title="（1）创建Binder子类，返回服务实例对象"></a>（1）<font color="cornflowerblue">创建Binder子类，返回服务实例对象</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110207275.png" alt="image-20201214110207275"></p>
<h5 id="（2）在onBind-中返回Mybinder的实例对象iBinder"><a href="#（2）在onBind-中返回Mybinder的实例对象iBinder" class="headerlink" title="（2）在onBind()中返回Mybinder的实例对象iBinder"></a>（2）<font color="cornflowerblue">在onBind()中返回Mybinder的实例对象iBinder</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110333487.png" alt="image-20201214110333487"></p>
<h4 id="2-客户端，Activity中"><a href="#2-客户端，Activity中" class="headerlink" title="2.客户端，Activity中"></a>2.客户端，Activity中</h4><h5 id="（1）创建ServiceConnection实例，在onServiceConnected-中接收返回的Binder-实例，通过Binder实例的getService-方法获取服务实例myService"><a href="#（1）创建ServiceConnection实例，在onServiceConnected-中接收返回的Binder-实例，通过Binder实例的getService-方法获取服务实例myService" class="headerlink" title="（1）创建ServiceConnection实例，在onServiceConnected 中接收返回的Binder 实例，通过Binder实例的getService()方法获取服务实例myService"></a>（1）<font color="cornflowerblue">创建ServiceConnection实例，在onServiceConnected 中接收返回的Binder 实例，通过Binder实例的getService()方法获取服务实例myService</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214110911643.png" alt="image-20201214110911643"></p>
<h5 id="2-绑定之后可以通过myService方法调用服务中的方法"><a href="#2-绑定之后可以通过myService方法调用服务中的方法" class="headerlink" title="(2)绑定之后可以通过myService方法调用服务中的方法"></a>(2)<font color="cornflowerblue">绑定之后可以通过myService方法调用服务中的方法</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111553877.png" alt="image-20201214111553877"></p>
<h5 id="（3）解除绑定"><a href="#（3）解除绑定" class="headerlink" title="（3）解除绑定"></a>（3）<font color="cornflowerblue">解除绑定</font></h5><p><img src="/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/image-20201214111631223.png" alt="image-20201214111631223"></p>
<p><font color="red">注：也可以将服务中的方法写在内部类mybinder中，在活动的ServiceConnect实例的onServiceConnected()中获取myBinder实例，通过这个实例调用服务中的方法。（不推荐）</font></p>
<h2 id="混合使用启动方式和绑定方式"><a href="#混合使用启动方式和绑定方式" class="headerlink" title="混合使用启动方式和绑定方式"></a>混合使用启动方式和绑定方式</h2><h3 id="一、混合开启服务"><a href="#一、混合开启服务" class="headerlink" title="一、混合开启服务"></a>一、混合开启服务</h3><p>既然<font color="red">start开启的服务不能调用方法，bind方式开启的服务生命力又很弱</font>，那么能否两种方式的有点么？答案当然是肯定的，否则服务的应用能力就太弱了。</p>
<ol>
<li><h4 id="通过startService-方式开启服务-只能通过调用stopService停止"><a href="#通过startService-方式开启服务-只能通过调用stopService停止" class="headerlink" title="通过startService()方式开启服务(只能通过调用stopService停止)"></a>通过startService()方式开启服务(只能通过调用stopService停止)</h4></li>
<li><h4 id="通过bindService进行绑定，以进行服务的方法调用-当需要的时候"><a href="#通过bindService进行绑定，以进行服务的方法调用-当需要的时候" class="headerlink" title="通过bindService进行绑定，以进行服务的方法调用(当需要的时候)"></a>通过bindService进行绑定，以进行服务的方法调用(当需要的时候)</h4></li>
<li><h4 id="通过unbindService进行解绑-不需要调用方法了，在UI线程被销毁之前解绑"><a href="#通过unbindService进行解绑-不需要调用方法了，在UI线程被销毁之前解绑" class="headerlink" title="通过unbindService进行解绑(不需要调用方法了，在UI线程被销毁之前解绑)"></a>通过unbindService进行解绑(不需要调用方法了，在UI线程被销毁之前解绑)</h4></li>
<li><h4 id="通过stopService停止服务"><a href="#通过stopService停止服务" class="headerlink" title="通过stopService停止服务"></a>通过stopService停止服务</h4></li>
</ol>
<p>这样我们就可以灵活的使用Service，<font color="red">当需要的时候可以随时进行调用，不要的时候又可以长期运行于后台而不用保留UI线程</font>。这也是服务最常见的用法。</p>
<h3 id="二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。"><a href="#二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。" class="headerlink" title="二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。"></a>二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。</h3><h3 id="三、如果想停止服务，必须调用stopService，并且所有调用-bindService-的-Context调用unbindService解绑-或者之前调用-bindService-的-Context-不存在了。"><a href="#三、如果想停止服务，必须调用stopService，并且所有调用-bindService-的-Context调用unbindService解绑-或者之前调用-bindService-的-Context-不存在了。" class="headerlink" title="三、如果想停止服务，必须调用stopService，并且所有调用 bindService 的 Context调用unbindService解绑,或者之前调用 bindService 的 Context 不存在了。"></a>三、如果想停止服务，必须<font color="cornflowerblue">调用stopService</font>，并且所有调用 bindService 的 Context调用<font color="cornflowerblue">unbindService</font><font color="orange">解绑</font>,或者之前调用 bindService 的 Context<font color="orange"> 不存在</font>了。</h3><h2 id="服务的更多使用技巧"><a href="#服务的更多使用技巧" class="headerlink" title="服务的更多使用技巧"></a>服务的更多使用技巧</h2><h3 id="一、使用前台服务"><a href="#一、使用前台服务" class="headerlink" title="一、使用前台服务"></a>一、使用前台服务</h3><h4 id="1-服务运行在后台，优先级低，系统内存不足时，可能会被回收。"><a href="#1-服务运行在后台，优先级低，系统内存不足时，可能会被回收。" class="headerlink" title="1.服务运行在后台，优先级低，系统内存不足时，可能会被回收。"></a>1.服务运行在后台，优先级低，系统内存不足时，<font color="red">可能会被回收</font>。</h4><p>如果希望服务<font color="red">可以一直保持运行状态</font>，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台服务。</p>
<h4 id="2-与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。"><a href="#2-与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。" class="headerlink" title="2.与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。"></a>2.<font color="cornflowerblue">与普通服务相比</font>：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。</h4><h4 id="3-startForeground-和stopForeground-方法"><a href="#3-startForeground-和stopForeground-方法" class="headerlink" title="3.startForeground()和stopForeground()方法"></a>3.<font color="cornflowerblue">startForeground()</font>和<font color="cornflowerblue">stopForeground()</font>方法</h4><p>startForeground(1,notification);</p>
<h3 id="二、使用IntentService"><a href="#二、使用IntentService" class="headerlink" title="二、使用IntentService"></a>二、使用IntentService</h3><p>（未完待续……）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:1530268781@qq.com">Durango</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.durango.cn/2021/05/31/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E7%AC%94%E8%AE%B0%E3%80%8B/">https://www.durango.cn/2021/05/31/《第一行代码-笔记》/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.durango.cn" target="_blank">Welcome to Durango's blog!</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post_share"><div class="social-share" data-image="/img/android_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/01/%E3%80%8AAndroid%E5%B0%8F%E8%8F%9C%E3%80%8B/"><img class="prev-cover" src="/img/android_img2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《Android小菜》</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-FTP%E4%B8%8EEmail%E6%9C%8D%E5%8A%A1/"><img class="next-cover" src="/img/network.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">网络实验六-FTP与Email服务</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/06/01/《Android小菜》/" title="《Android小菜》"><img class="cover" src="/img/android_img2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-01</div><div class="title">《Android小菜》</div></div></a></div><div><a href="/2021/06/09/Android进阶-RecyclerView/" title="Android进阶-RecyclerView"><img class="cover" src="/img/android_img3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-09</div><div class="title">Android进阶-RecyclerView</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">第一章     第一行代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">Android系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E5%B1%82%E3%80%81%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E5%BA%93%E3%80%81%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E5%B1%82%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.1.1.</span> <span class="toc-text">Linux内核层、系统运行库、应用架构层、应用层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">四大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89%E3%80%81%E6%9C%8D%E5%8A%A1%EF%BC%88Service%EF%BC%89%E3%80%81%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8%EF%BC%88Broadcast-Receiver%EF%BC%89%E3%80%81-%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85%EF%BC%88Content-Provider"><span class="toc-number">1.2.1.</span> <span class="toc-text">活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、        内容提供者（Content Provider)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APP%E7%9B%AE%E5%BD%95"><span class="toc-number">1.3.</span> <span class="toc-text">APP目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-libs-%E7%AC%AC%E4%B8%89%E6%96%B9jar%E5%8C%85"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">2.libs: 第三方jar包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-androidTest-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9B%91%E6%B5%8B"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">3.androidTest: 测试用例，自动化监测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-java-%E6%94%BE%E7%BD%AEJava%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">4.java: 放置Java代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-res-%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">5.res: 资源文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-AndroidMainfest-xml-%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E5%9B%9B%E5%A4%A7%E6%B4%BB%E5%8A%A8%E5%BF%85%E9%A1%BB%E5%9C%A8%E6%AD%A4%E6%B3%A8%E5%86%8C%EF%BC%81"><span class="toc-number">1.3.0.5.</span> <span class="toc-text">6.AndroidMainfest.xml: 项目配置文件，四大活动必须在此注册！</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%B4%BB%E5%8A%A8"><span class="toc-number">1.4.</span> <span class="toc-text">主活动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%B8%83%E5%B1%80"><span class="toc-number">1.5.</span> <span class="toc-text">引入布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">资源的引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E4%B8%AD"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">1.代码中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-XML%E4%B8%AD"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">2.XML中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89id-id-%E5%90%8D%E7%A7%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">定义id: @+id&#x2F;名称</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7"><span class="toc-number">1.7.</span> <span class="toc-text">日志工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88p26%EF%BC%89"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">（p26）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8E%A2%E7%A9%B6%E6%B4%BB%E5%8A%A8"><span class="toc-number">2.</span> <span class="toc-text">第二章 探究活动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">活动是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">活动的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E6%B4%BB%E5%8A%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">一、手动创建活动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8A%A0%E8%BD%BD%E5%B8%83%E5%B1%80"><span class="toc-number">2.2.2.</span> <span class="toc-text">二、创建和加载布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%8C%89%E9%92%AE%EF%BC%9A"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">添加按钮：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%B8%83%E5%B1%80%EF%BC%9A"><span class="toc-number">2.2.3.</span> <span class="toc-text">加载布局：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9C%A8AndroidManifest%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B3%A8%E5%86%8C"><span class="toc-number">2.2.4.</span> <span class="toc-text">三、在AndroidManifest文件中注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B8%AD%E4%BD%BF%E7%94%A8Toast%E6%8F%90%E9%86%92"><span class="toc-number">2.2.5.</span> <span class="toc-text">四、在活动中使用Toast提醒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B8%AD%E4%BD%BF%E7%94%A8Menu"><span class="toc-number">2.2.6.</span> <span class="toc-text">五、在活动中使用Menu</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">1.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%87%8D%E5%86%99onCreateOptionMenu%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">3.重写onCreateOptionMenu（）方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8Java%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE-%E2%80%9DCtrl-O%E2%80%9C"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">在Java代码中使用快捷键 ”Ctrl+O“</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%87%8D%E5%86%99onOptionsItemSelected"><span class="toc-number">2.2.6.4.</span> <span class="toc-text">4.重写onOptionsItemSelected</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%91%A7%E6%AF%81%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8"><span class="toc-number">2.2.7.</span> <span class="toc-text">六、摧毁一个活动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stop"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">stop();</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Intent%EF%BC%88%E6%84%8F%E5%9B%BE%EF%BC%89%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B9%8B%E9%97%B4%E7%A9%BF%E6%A2%AD"><span class="toc-number">2.3.</span> <span class="toc-text">使用Intent（意图）在活动之间穿梭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8%E6%98%BE%E5%BC%8F%E7%9A%84Intent"><span class="toc-number">2.3.1.</span> <span class="toc-text">一、使用显式的Intent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.3.1.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAIntent%EF%BC%8C%E4%BC%A0%E5%85%A5FirstActivity-this%E4%BD%9C%E4%B8%BA%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8C%E4%BC%A0%E5%85%A5SecondActicity-class%E4%BD%9C%E4%B8%BA%E7%9B%AE%E6%A0%87%E6%B4%BB%E5%8A%A8%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87startActivity%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E6%9D%A5%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B8%AAIntent%E3%80%82"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">首先构建一个Intent，传入FirstActivity.this作为上下文，传入SecondActicity.class作为目标活动，然后通过startActivity（）方法来执行这个Intent。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E7%9A%84Intent%EF%BC%88%E6%84%8F%E5%9B%BE%E8%BF%87%E6%BB%A4%E5%99%A8intent-filter"><span class="toc-number">2.3.2.</span> <span class="toc-text">二、使用隐式的Intent（意图过滤器intent-filter)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">1.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-1"><span class="toc-number">2.3.2.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-DEFAULT%E6%98%AF%E4%B8%80%E7%A7%8D%E9%BB%98%E8%AE%A4%E7%9A%84category%EF%BC%8C%E5%9C%A8%E8%B0%83%E7%94%A8startActicity-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86%E8%BF%99%E4%B8%AAcategory%E6%B7%BB%E5%8A%A0%E5%88%B0Intent%E4%B8%AD%E3%80%82"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">2.DEFAULT是一种默认的category，在调用startActicity()方法时会自动将这个category添加到Intent中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%AF%8F%E4%B8%AAIntent%E5%8F%AA%E8%83%BD%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AAaction%EF%BC%8C%E5%8D%B4%E8%83%BD%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AAcategory%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%A2%9E%E5%8A%A0%EF%BC%9A"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">3.每个Intent只能指定一个action，却能指定多个category，这样增加：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#intent-addCategory-%E2%80%9Ccom-example-activity-MY-CATEGORY%E2%80%9D-%EF%BC%9B"><span class="toc-number">2.3.2.5.</span> <span class="toc-text">intent.addCategory(“com.example.activity.MY_CATEGORY”)；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%84%B6%E5%90%8E%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%BA%8C%E7%9A%84intent-filter%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A3%B0%E6%98%8E%EF%BC%9A"><span class="toc-number">2.3.2.6.</span> <span class="toc-text">4.然后在活动二的intent-filter中添加声明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-category-android-name-%E2%80%9Dcom-example-activity-MY-CATEGORY%E2%80%9D"><span class="toc-number">2.3.2.7.</span> <span class="toc-text">&lt;category android:name&#x3D;”com.example.activity.MY_CATEGORY”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8F%AA%E6%9C%89-lt-action-gt-%E5%92%8C-lt-category-gt-%E5%90%8C%E6%97%B6%E5%8C%B9%E9%85%8D%E4%B8%8A-Intent%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84-action-%E5%92%8C-category-%E6%97%B6%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%B4%BB%E5%8A%A8%E6%89%8D%E8%83%BD%E5%93%8D%E5%BA%94%E8%AF%A5Intent"><span class="toc-number">2.3.2.8.</span> <span class="toc-text">5.只有&lt;action&gt;和&lt;category&gt;同时匹配上 Intent中指定的 action 和 category 时，这个活动才能响应该Intent</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9B%B4%E5%A4%9A%E9%9A%90%E5%BC%8F%E7%9A%84Intent"><span class="toc-number">2.3.3.</span> <span class="toc-text">三、更多隐式的Intent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E7%9A%84Intent%E4%B8%8D%E4%BB%85%E8%83%BD%E5%90%AF%E5%8A%A8%E8%87%AA%E5%B7%B1%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B4%BB%E5%8A%A8%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%90%AF%E5%8A%A8%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B4%BB%E5%8A%A8"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">1.使用隐式的Intent不仅能启动自己程序的活动，还可以启动其他程序的活动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E9%A6%96%E5%85%88%E6%8C%87%E5%AE%9A%E4%BA%86Intent%E7%9A%84action%E6%98%AFIntent-ACTION-VIEW%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AAAndroid%E7%B3%BB%E7%BB%9F%E5%86%85%E7%BD%AE%E7%9A%84%E5%8A%A8%E4%BD%9C%EF%BC%8C%E5%85%B6%E5%B8%B8%E9%87%8F%E5%80%BC%E4%B8%BA-android-intent-action-VIEW%E3%80%82"><span class="toc-number">2.3.3.1.1.</span> <span class="toc-text">（1）这里我们首先指定了Intent的action是Intent.ACTION_VIEW，这是一个Android系统内置的动作，其常量值为                android.intent.action.VIEW。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87Uri-parse-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B0%86%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E6%88%90%E4%B8%80%E4%B8%AAUri%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%86%8D%E8%B0%83%E7%94%A8Intent%E7%9A%84setData-%E6%96%B9%E6%B3%95%E5%B0%86%E8%BF%99%E4%B8%AAuri%E5%AF%B9%E8%B1%A1-%E4%BC%A0%E9%80%92%E8%BF%9B%E5%8E%BB%E3%80%82"><span class="toc-number">2.3.3.1.2.</span> <span class="toc-text">（2）然后通过Uri.parse()方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData()方法将这个uri对象                传递进去。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8F%AF%E8%83%BD%E4%BD%A0%E4%BC%9A%E5%AF%B9setData-%E9%83%A8%E5%88%86%E6%84%9F%E8%A7%89%E5%88%B0%E9%99%8C%E7%94%9F%EF%BC%8C%E8%BF%99%E6%98%AF%E6%88%91%E4%BB%AC%E5%89%8D%E9%9D%A2%E6%B2%A1%E6%9C%89%E8%AE%B2%E5%88%B0%E7%9A%84%E3%80%82%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%B6%E5%AE%9E%E5%B9%B6%E4%B8%8D%E5%A4%8D%E6%9D%82%EF%BC%8C%E5%AE%83%E6%8E%A5%E6%94%B6%E4%B8%80%E4%B8%AAuri%E5%AF%B9%E8%B1%A1%EF%BC%8C-%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8DIntent%E6%AD%A3%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%80%8C%E8%BF%99%E4%BA%9B%E6%95%B0%E6%8D%AE%E9%80%9A%E5%B8%B8%E9%83%BD%E6%98%AF%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BD%A2%E5%BC%8F%E4%BC%A0%E4%BA%BA%E5%88%B0Uri-parse-%E6%96%B9%E6%B3%95%E4%B8%AD%E8%A7%A3%E6%9E%90%E4%BA%A7%E7%94%9F%E7%9A%84%E3%80%82"><span class="toc-number">2.3.3.1.3.</span> <span class="toc-text">（3）可能你会对setData()部分感觉到陌生，这是我们前面没有讲到的。这个方法其实并不复杂，它接收一个uri对象，                主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传人到Uri.parse()方法中解析产生的。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8E%E6%AD%A4%E5%AF%B9%E5%BA%94%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8-lt-intent-filter-gt-%E6%A0%87%E7%AD%BE%E4%B8%AD%E5%86%8D%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA-lt-data-gt-%E6%A0%87%E7%AD%BE%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%9B%B4%E7%B2%BE%E7%A1%AE%E5%9C%B0"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">2.与此对应，我们还可以在&lt;intent-filter&gt;标签中再配置一个&lt;data&gt;标签，用于更精确地</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">3.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%99%E6%A0%B7ThirdActivity%E5%B0%B1%E8%83%BD%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%80%E6%A0%B7%E5%93%8D%E5%BA%94%E4%B8%80%E4%B8%AA%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E7%9A%84Intent%E4%BA%86"><span class="toc-number">2.3.3.3.1.</span> <span class="toc-text">这样ThirdActivity就能和浏览器一样响应一个打开网页的Intent了</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%90%91%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.4.</span> <span class="toc-text">四、向下一个活动传递数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87Intent%E7%9A%84putExtra-%E6%96%B9%E6%B3%95%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">1.通过Intent的putExtra()方法携带数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-2"><span class="toc-number">2.3.4.2.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#putExtra-%E2%80%9Cextra-data%E2%80%9D-data-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E2%80%9C%E9%94%AE%E2%80%9D%EF%BC%8C%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E2%80%9C%E6%95%B0%E6%8D%AE%E2%80%9D"><span class="toc-number">2.3.4.2.0.1.</span> <span class="toc-text">*putExtra(“extra_data”, data)*第一个参数是“键”，第二个参数是“数据”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87Intent%E7%9A%84getStringExtra-%E9%94%AE-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">2.通过Intent的getStringExtra(键)获取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#getStringExtra-getIntExtra-getBooleanExtra"><span class="toc-number">2.3.4.3.1.</span> <span class="toc-text">getStringExtra() &#x2F; getIntExtra() &#x2F; getBooleanExtra()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%BB%99%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8"><span class="toc-number">2.3.5.</span> <span class="toc-text">五、返回数据给上一个活动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87startActivityForResult%EF%BC%88%EF%BC%89%E6%9D%A5%E5%90%AF%E5%8A%A8SecondActivity"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">1.通过startActivityForResult（）来启动SecondActivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8setResult%EF%BC%88%EF%BC%89%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">2.使用setResult（）返回数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8FirstActivity%E4%B8%AD%E9%87%8D%E5%86%99-onActivityResult%EF%BC%88%EF%BC%89"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">3.在FirstActivity中重写 onActivityResult（）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81Bundle%E4%B8%8EIntent%E7%BB%93%E5%90%88%E4%BC%A0%E9%80%92%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.6.</span> <span class="toc-text">六、Bundle与Intent结合传递大量数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">1,传数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">2.取数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.4.</span> <span class="toc-text">活动的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BF%94%E5%9B%9E%E6%A0%88"><span class="toc-number">2.4.1.</span> <span class="toc-text">一、返回栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B4%BB%E5%8A%A8%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.2.</span> <span class="toc-text">二、活动状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">1.运行状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8%E6%9C%AA%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88%E7%9A%84%E6%A0%88%E9%A1%B6%E6%97%B6%EF%BC%8C%E8%BF%99%E6%97%B6%E6%B4%BB%E5%8A%A8%E5%B0%B1%E5%A4%84%E4%BA%8E%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E3%80%82"><span class="toc-number">2.4.2.1.1.</span> <span class="toc-text">当一个活动未与返回栈的栈顶时，这时活动就处于运行状态。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9A%82%E5%81%9C%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">2.暂停状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8%E4%B8%8D%E5%86%8D%E5%A4%84%E4%BA%8E%E6%A0%88%E9%A1%B6%E4%BD%8D%E7%BD%AE%EF%BC%8C%E4%BD%86%E4%BB%8D%E7%84%B6%E5%8F%AF%E8%A7%81%E6%97%B6%EF%BC%8C%E8%BF%99%E6%97%B6%E6%B4%BB%E5%8A%A8%E5%B0%B1%E8%BF%9B%E5%85%A5%E4%BA%86%E6%9A%82%E5%81%9C%E7%8A%B6%E6%80%81%E3%80%82"><span class="toc-number">2.4.2.2.1.</span> <span class="toc-text">当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%81%9C%E6%AD%A2%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">3.停止状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8%E4%B8%8D%E5%86%8D%E5%A4%84%E4%BA%8E%E6%A0%88%E9%A1%B6%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%8C%E5%85%A8%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%B0%B1%E8%BF%9B%E5%85%A5%E4%BA%86%E5%81%9C%E6%AD%A2%E7%8A%B6%E6%80%81%E3%80%82%E7%B3%BB%E7%BB%9F%E4%BB%8D%E7%84%B6%E4%BC%9A%E4%B8%BA%E8%BF%99%E7%A7%8D%E6%B4%BB%E5%8A%A8%E4%BF%9D-%E5%AD%98%E7%9B%B8%E5%BA%94%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%AE%8C%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%9A%84%EF%BC%8C%E5%BD%93%E5%85%B6%E4%BB%96%E5%9C%B0%E6%96%B9%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E6%97%B6%EF%BC%8C%E5%A4%84%E4%BA%8E%E5%81%9C%E6%AD%A2%E7%8A%B6%E6%80%81%E7%9A%84%E6%B4%BB%E5%8A%A8%E6%9C%89%E5%8F%AF-%E8%83%BD%E4%BC%9A%E8%A2%AB%E7%B3%BB%E7%BB%9F%E5%9B%9E%E6%94%B6%E3%80%82"><span class="toc-number">2.4.2.3.1.</span> <span class="toc-text">当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保    存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可    能会被系统回收。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%91%A7%E6%AF%81%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">4.摧毁状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8%E4%BB%8E%E8%BF%94%E5%9B%9E%E6%A0%88%E4%B8%AD%E7%A7%BB%E9%99%A4%E5%90%8E%E5%B0%B1%E5%8F%98%E6%88%90%E4%BA%86%E9%94%80%E6%AF%81%E7%8A%B6%E6%80%81%E3%80%82%E7%B3%BB%E7%BB%9F%E4%BC%9A%E6%9C%80%E5%80%BE%E5%90%91%E4%BA%8E%E5%9B%9E%E6%94%B6%E5%A4%84%E4%BA%8E%E8%BF%99%E7%A7%8D%E7%8A%B6%E6%80%81%E7%9A%84%E6%B4%BB%E5%8A%A8%EF%BC%8C%E4%BB%8E%E8%80%8C%E4%BF%9D%E8%AF%81-%E6%89%8B%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%85%85%E8%B6%B3%E3%80%82"><span class="toc-number">2.4.2.4.1.</span> <span class="toc-text">当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证    手机的内存充足。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">2.4.3.</span> <span class="toc-text">三、活动的生存期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-oncCreat-%E6%B4%BB%E5%8A%A8%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E5%88%9B%E5%BB%BA%E6%97%B6%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">1.oncCreat(): 活动第一次被创建时调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-onStart-%E5%9C%A8%E6%B4%BB%E5%8A%A8%E7%94%B1%E4%B8%8D%E5%8F%AF%E8%A7%81%E5%8F%98%E4%B8%BA%E5%8F%AF%E8%A7%81%E6%97%B6%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">2.onStart(): 在活动由不可见变为可见时调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-onResume-%E5%9C%A8%E6%B4%BB%E5%8A%A8%E5%87%86%E5%A4%87%E5%A5%BD%E5%92%8C%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E6%97%B6%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">3.onResume(): 在活动准备好和用户进行交互时调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-onPause-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E5%87%86%E5%A4%87%E5%90%AF%E5%8A%A8%E6%88%96%E8%80%85%E6%81%A2%E5%A4%8D%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8%E6%97%B6%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.3.4.</span> <span class="toc-text">4.onPause(): 在系统准备启动或者恢复另一个活动时调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-onStop-%E5%9C%A8%E6%B4%BB%E5%8A%A8%E5%AE%8C%E5%85%A8%E4%B8%8D%E5%8F%AF%E8%A7%81%E6%97%B6%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.3.5.</span> <span class="toc-text">5.onStop(): 在活动完全不可见时调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-onDestory-%E5%9C%A8%E6%B4%BB%E5%8A%A8%E8%A2%AB%E9%94%80%E6%AF%81%E6%97%B6%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.3.6.</span> <span class="toc-text">6.onDestory(): 在活动被销毁时调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-onRestart-%E5%9C%A8%E6%B4%BB%E5%8A%A8%E7%94%B1%E5%81%9C%E6%AD%A2%E7%8A%B6%E6%80%81%E5%8F%98%E4%B8%BA%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E6%97%B6%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.3.7.</span> <span class="toc-text">7.onRestart(): 在活动由停止状态变为运行状态时调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%93%E9%AA%8C%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.4.4.</span> <span class="toc-text">四、体验活动的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B0%E5%BB%BA%E4%B8%A4%E4%B8%AA%E6%B4%BB%E5%8A%A8%E5%88%86%E5%88%AB%E4%B8%BA-NormalActicity-%E5%92%8C-DialogActivity"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">1.新建两个活动分别为 NormalActicity 和 DialogActivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%B4%BB%E5%8A%A8%E7%9A%84%E4%B8%BB%E9%A2%98%EF%BC%9A"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">2.修改对话框活动的主题：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AppCompatActivity-android-theme-%E2%80%9D-style-Theme-AppCompat-Dialog%E2%80%9D"><span class="toc-number">2.4.4.2.1.</span> <span class="toc-text">AppCompatActivity: android:theme&#x3D;”@style&#x2F;Theme.AppCompat.Dialog”</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Activity-android-theme-%E2%80%9D-android-style-Theme-Dialog%E2%80%9D"><span class="toc-number">2.4.4.2.2.</span> <span class="toc-text">Activity:android:theme&#x3D;”@android:style&#x2F;Theme.Dialog”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8%E4%B8%BB%E6%B4%BB%E5%8A%A8%E4%B8%AD%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%EF%BC%88%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">3.在主活动中打印日志（充分利用日志过滤器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%8CMainActivity-%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E5%88%9B%E5%BB%BA%E6%97%B6%E4%BC%9A%E4%BE%9D%E6%AC%A1%E6%89%A7%E8%A1%8C-onCreate-%E3%80%81onStart-%E5%92%8C-onResume-%E6%96%B9%E6%B3%95%EF%BC%9B"><span class="toc-number">2.4.4.3.1.</span> <span class="toc-text">（1）可以看到，MainActivity 第一次被创建时会依次执行 onCreate()、onStart() 和 onResume()方法；</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%90%AF%E5%8A%A8NormalActivity-%E4%BC%9A%E6%89%A7%E8%A1%8C-onPause-%E5%92%8C-onStop-%E5%9B%A0%E4%B8%BANormalActivity%E5%B7%B2%E7%BB%8F%E5%AE%8C%E5%85%A8%E9%81%AE%E4%BD%8FMainActivity%E4%BA%86%EF%BC%9B"><span class="toc-number">2.4.4.3.2.</span> <span class="toc-text">（2）启动NormalActivity,会执行 onPause() 和 onStop(),因为NormalActivity已经完全遮住MainActivity了；</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%BF%94%E5%9B%9EMainActivity%EF%BC%8C%E4%BC%9A%E6%89%A7%E8%A1%8C-onRestart-%E3%80%81onStart-%E5%92%8ConResume"><span class="toc-number">2.4.4.3.3.</span> <span class="toc-text">（3）返回MainActivity，会执行 onRestart()、onStart()和onResume();</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%90%AF%E5%8A%A8DialogActivity-%E5%8F%AA%E4%BC%9A%E6%89%A7%E8%A1%8ConPause-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%AD%A4%E6%97%B6MainActivity%E6%B2%A1%E6%9C%89%E5%AE%8C%E5%85%A8%E9%81%AE%E4%BD%8F%EF%BC%9B"><span class="toc-number">2.4.4.3.4.</span> <span class="toc-text">（4）启动DialogActivity,只会执行onPause()方法，因为此时MainActivity没有完全遮住；</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E8%BF%94%E5%9B%9EMainActivity-%E5%8F%AA%E4%BC%9A%E6%89%A7%E8%A1%8ConResume%E3%80%82"><span class="toc-number">2.4.4.3.5.</span> <span class="toc-text">（5）返回MainActivity,只会执行onResume。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B4%BB%E5%8A%A8%E8%A2%AB%E5%9B%9E%E6%94%B6%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">2.4.5.</span> <span class="toc-text">五、活动被回收了怎么办</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%EF%BC%9A%E5%BD%93%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8%E8%BF%9B%E5%85%A5%E5%81%9C%E6%AD%A2%E7%8A%B6%E6%80%81%E6%97%B6%EF%BC%8C%E5%8F%AF%E8%83%BD%E8%A2%AB%E7%B3%BB%E7%BB%9F%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%86%8D%E6%AC%A1%E8%BF%94%E5%9B%9E%E8%AF%A5%E6%B4%BB%E5%8A%A8%E6%97%B6%E4%BC%9A%E9%80%9A%E8%BF%87onCreate-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%8C%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A2%E5%A4%B1%E3%80%82"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">1.问题：当一个活动进入停止状态时，可能被系统回收，再次返回该活动时会通过onCreate()创建一个新的实例，造成数据的丢失。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87onSaveInstanceState-%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="toc-number">2.4.5.2.</span> <span class="toc-text">2.通过onSaveInstanceState()回调方法保存数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-3"><span class="toc-number">2.4.5.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8onCreate-%E4%B8%AD%E5%8F%96%E5%80%BC"><span class="toc-number">2.4.5.4.</span> <span class="toc-text">3.在onCreate()中取值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-%EF%BC%88launchMode"><span class="toc-number">2.5.</span> <span class="toc-text">活动的启动模式 （launchMode)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81standard"><span class="toc-number">2.5.1.</span> <span class="toc-text">一、standard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-standard%E6%98%AF%E6%B4%BB%E5%8A%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">1.standard是活动默认的启动模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">2.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81singleTop"><span class="toc-number">2.5.2.</span> <span class="toc-text">二、singleTop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BD%93%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E6%8C%87%E5%AE%9A%E4%B8%BAsingleTop%EF%BC%8C%E5%9C%A8%E5%90%AF%E5%8A%A8%E6%B4%BB%E5%8A%A8%E6%97%B6%E5%A6%82%E6%9E%9C%E5%8F%91%E7%8E%B0%E8%BF%94%E5%9B%9E%E6%A0%88%E7%9A%84%E6%A0%88%E9%A1%B6%E5%B7%B2%E7%BB%8F%E6%98%AF%E8%AF%A5%E6%B4%BB%E5%8A%A8%EF%BC%8C%E5%88%99%E8%AE%A4%E4%B8%BA%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%86%8D%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%AE%9E%E4%BE%8B%E3%80%82"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">1.当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">2.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81singleTask"><span class="toc-number">2.5.3.</span> <span class="toc-text">三、singleTask</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BD%93%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E6%8C%87%E5%AE%9A%E4%B8%BAsingleTask%EF%BC%8C%E6%AF%8F%E6%AC%A1%E5%90%AF%E5%8A%A8%E8%AF%A5%E6%B4%BB%E5%8A%A8%E6%97%B6%E7%B3%BB%E7%BB%9F%E9%A6%96%E5%85%88%E4%BC%9A%E5%9C%A8%E8%BF%94%E5%9B%9E%E6%A0%88%E4%B8%AD%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%AF%A5%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%8F%91%E7%8E%B0%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E5%88%99%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%B9%B6%E6%8A%8A%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%B4%BB%E5%8A%A8%E4%B9%8B%E4%B8%8A%E7%9A%84%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E7%BB%9F%E7%BB%9F%E5%87%BA%E6%A0%88%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%8F%91%E7%8E%B0%E5%B0%B1%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%AE%9E%E4%BE%8B%E3%80%82"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">1.当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">2.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81singleInstance"><span class="toc-number">2.5.4.</span> <span class="toc-text">四、singleInstance</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8C%87%E5%AE%9A%E4%B8%BAsingleInstance%E7%9A%84%E6%B4%BB%E5%8A%A8%E4%BC%9A%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E6%A0%88%EF%BC%8C"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">1.指定为singleInstance的活动会启动一个新的返回栈，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">2.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.6.</span> <span class="toc-text">活动的最佳实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-UI%E5%BC%80%E5%8F%91%E7%9A%84%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4"><span class="toc-number">3.</span> <span class="toc-text">第三章 UI开发的点点滴滴</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F%E7%95%8C%E9%9D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">如何编写程序界面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">常用控件的使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81TextView"><span class="toc-number">3.2.1.</span> <span class="toc-text">一、TextView</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F-gravity"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">1.文本对齐方式(gravity)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#android-gravity-%E2%80%9Dcenter-top-bottom-left-right%E2%80%9D"><span class="toc-number">3.2.1.1.1.</span> <span class="toc-text">android: gravity&#x3D;”center|top|bottom|left|right”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%87%E6%9C%AC%E9%A2%9C%E8%89%B2%EF%BC%8C%E5%A4%A7%E5%B0%8F%EF%BC%88textColor%E3%80%81textSize%EF%BC%89"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">2.文本颜色，大小（textColor、textSize）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E4%BD%93%E4%BB%A5%E2%80%9Csp%E2%80%9D%E4%B8%BA%E5%8D%95%E4%BD%8D"><span class="toc-number">3.2.1.2.1.</span> <span class="toc-text">字体以“sp”为单位</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BETextView%E5%85%B6%E5%AE%83%E7%9A%84XML%E6%96%87%E4%BB%B6%E5%85%83%E7%B4%A0"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">3.文本标签TextView其它的XML文件元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Button"><span class="toc-number">3.2.2.</span> <span class="toc-text">二、Button</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%EF%BC%88textAllCaps"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">1.自动进行大小写转换（textAllCaps)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#android-textALlCaps-%E2%80%9Dfalse-true%E2%80%9D"><span class="toc-number">3.2.2.1.1.</span> <span class="toc-text">android: textALlCaps:”false|true”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E7%A7%8D%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">2. 4种事件监听器的注册方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81EditText"><span class="toc-number">3.2.3.</span> <span class="toc-text">三、EditText</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8F%90%E7%A4%BA%E6%80%A7%E6%96%87%E5%AD%97%EF%BC%88hint"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">1.提示性文字（hint)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%80%E5%A4%A7%E8%A1%8C%E6%95%B0%EF%BC%88maxLines%EF%BC%89"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">2.最大行数（maxLines）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%86%E7%A0%81%E6%A1%86%EF%BC%88android-inputType-%E2%80%9DTextPassword%E2%80%9D%EF%BC%89"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">3.密码框（android: inputType&#x3D;”TextPassword”）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%88-getText-toString-%EF%BC%89"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">4.获取文本内容（,,, .getText().toString( )  ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BE%93%E5%85%A5%E6%A1%86EditText-%E5%85%B6%E5%AE%83%E7%9A%84XML%E6%96%87%E4%BB%B6%E5%85%83%E7%B4%A0"><span class="toc-number">3.2.3.5.</span> <span class="toc-text">5.输入框EditText 其它的XML文件元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ImageView"><span class="toc-number">3.2.4.</span> <span class="toc-text">四、ImageView</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-android-src"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">1.android:src</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-android-background"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">2. android:background</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-setImageResource-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.4.3.</span> <span class="toc-text">3.setImageResource()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81ProgressBar-%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="toc-number">3.2.5.</span> <span class="toc-text">五、ProgressBar (进度条)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%EF%BC%88%E6%8E%A7%E4%BB%B6%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7%EF%BC%89visibility-%E2%80%9Dvisiblle-invisible-gone%E2%80%9D"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">1.（控件通用属性）visibility&#x3D;”visiblle|invisible|gone”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%8E%B7%E5%8F%96-%E6%8E%A7%E5%88%B6%E6%8E%A7%E4%BB%B6%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">2.代码中获取&#x2F;控制控件可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B0%B4%E5%B9%B3%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">3.水平进度条</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89style-%E2%80%9D-android-attr-progressBarStyleHorizontal%E2%80%9D-%E7%B1%BB%E5%88%AB"><span class="toc-number">3.2.5.3.1.</span> <span class="toc-text">（1）style&#x3D;”?android:attr&#x2F;progressBarStyleHorizontal”    &#x2F;&#x2F;类别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#android-max-%E2%80%9D100%E2%80%9D-%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">3.2.5.3.2.</span> <span class="toc-text">android:max&#x3D;”100”    &#x2F;&#x2F;进度条最大值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89"><span class="toc-number">3.2.5.3.3.</span> <span class="toc-text">（2）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4"><span class="toc-number">3.2.5.4.</span> <span class="toc-text">4.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-4"><span class="toc-number">3.2.5.5.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81AlterDialog%EF%BC%88%E5%AF%B9%E8%AF%9D%E6%A1%86%EF%BC%89"><span class="toc-number">3.2.6.</span> <span class="toc-text">六、AlterDialog（对话框）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-AlertDialog%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%BD%93%E5%89%8D%E7%9A%84%E7%95%8C%E9%9D%A2%E5%BC%B9%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%AF%9D%E6%A1%86%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%98%AF%E7%BD%AE%E9%A1%B6%E4%BA%8E%E6%89%80%E6%9C%89%E7%95%8C%E9%9D%A2%E5%85%83%E7%B4%A0%E4%B9%8B%E4%B8%8A%E7%9A%84%EF%BC%8C%E8%83%BD%E5%A4%9F%E5%B1%8F%E8%94%BD%E6%8E%89%E5%85%B6%E4%BB%96%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BA%A4%E4%BA%92%E8%83%BD%E5%8A%9B%EF%BC%8C%E5%9B%A0%E6%AD%A4AlertDialog-%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E7%94%A8%E4%BA%8E%E6%8F%90%E7%A4%BA%E4%B8%80%E4%BA%9B%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E5%AE%B9%E6%88%96%E8%80%85%E8%AD%A6%E5%91%8A%E4%BF%A1%E6%81%AF%E3%80%82%E6%AF%94%E5%A6%82%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%E7%94%A8%E6%88%B7%E8%AF%AF%E5%88%A0%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9%EF%BC%8C%E5%9C%A8%E5%88%A0%E9%99%A4%E5%89%8D%E5%BC%B9%E5%87%BA%E4%B8%80%E4%B8%AA%E7%A1%AE%E8%AE%A4%E5%AF%B9%E8%AF%9D%E6%A1%86%E3%80%82%E4%B8%8B%E9%9D%A2%E6%88%91%E4%BB%AC%E6%9D%A5%E5%AD%A6%E4%B9%A0%E4%B8%80%E5%AE%83%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%8C%E4%BF%AE%E6%94%B9MainActivity%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA"><span class="toc-number">3.2.6.1.</span> <span class="toc-text">1.AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。下面我们来学习一它的用法，修改MainActivity中的代码，如下所示:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4"><span class="toc-number">3.2.6.2.</span> <span class="toc-text">2.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81ProgressDialog-%E5%B8%A6%E8%BF%9B%E5%BA%A6%E6%9D%A1%E7%9A%84%E6%8F%90%E7%A4%BA%E6%A1%86"><span class="toc-number">3.2.7.</span> <span class="toc-text">七、ProgressDialog(带进度条的提示框)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ProgressDialog-%E5%92%8CAlertDialog%E6%9C%89%E7%82%B9%E7%B1%BB%E4%BC%BC%EF%BC%8C%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%9C%A8%E7%95%8C%E9%9D%A2%E4%B8%8A%E5%BC%B9%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%AF%9D%E6%A1%86%EF%BC%8C%E9%83%BD%E8%83%BD%E5%A4%9F%E5%B1%8F%E8%94%BD%E6%8E%89%E5%85%B6%E4%BB%96%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BA%A4%E4%BA%92%E8%83%BD%E5%8A%9B%E3%80%82%E4%B8%8D%E5%90%8C%E7%9A%84%E6%98%AF%EF%BC%8CProgressDialog-%E4%BC%9A%E5%9C%A8%E5%AF%B9%E8%AF%9D%E6%A1%86%E4%B8%AD%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E5%BA%A6%E6%9D%A1%EF%BC%8C%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E8%A1%A8%E7%A4%BA%E5%BD%93%E5%89%8D%E6%93%8D%E4%BD%9C%E6%AF%94%E8%BE%83%E8%80%97%E6%97%B6%EF%BC%8C%E8%AE%A9%E7%94%A8%E6%88%B7%E8%80%90%E5%BF%83%E5%9C%B0%E7%AD%89%E5%BE%85%E3%80%82%E5%AE%83%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8CAlertDialog-%E4%B9%9F%E6%AF%94%E8%BE%83%E7%9B%B8%E4%BC%BC"><span class="toc-number">3.2.7.1.</span> <span class="toc-text">1.ProgressDialog 和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。它的用法和AlertDialog 也比较相似</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5"><span class="toc-number">3.2.7.2.</span> <span class="toc-text">2.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81RadioButton-%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE-%E5%92%8C-Checkbox-%E5%A4%8D%E9%80%89%E6%A1%86"><span class="toc-number">3.2.8.</span> <span class="toc-text">八、RadioButton(单选按钮) 和 Checkbox(复选框)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Spinner-%E4%B8%8B%E6%8B%89%E6%A1%86"><span class="toc-number">3.2.9.</span> <span class="toc-text">九、Spinner (下拉框)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A34%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80"><span class="toc-number">3.3.</span> <span class="toc-text">详解4种基本布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80%EF%BC%88LinearLayout%EF%BC%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">一、线性布局（LinearLayout）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8E%92%E5%88%97%E6%96%B9%E5%90%91orientation"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">1.排列方向orientation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-horizontal-2-vertical"><span class="toc-number">3.3.1.1.1.</span> <span class="toc-text">(1)horizontal        (2)vertical</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">2.对齐方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89gravity-%E6%96%87%E5%AD%97%E5%9C%A8%E6%8E%A7%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.1.2.1.</span> <span class="toc-text">（1）gravity: 文字在控件中的对齐方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89layout-gravity-%E6%8E%A7%E4%BB%B6%E5%9C%A8%E5%B8%83%E5%B1%80%E4%B8%AD%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.1.2.2.</span> <span class="toc-text">（2）layout_gravity: 控件在布局中的对齐方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7-layout-weight"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">3.重要属性 layout_weight</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%81%E8%AE%B8%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E6%AF%94%E4%BE%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E6%8C%87%E5%AE%9A%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F-%E5%AE%83%E5%9C%A8%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95%E7%9A%84%E9%80%82%E9%85%8D%E6%80%A7%E6%96%B9%E9%9D%A2%E5%8F%AF%E4%BB%A5%E8%B5%B7%E5%88%B0%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81"><span class="toc-number">3.3.1.3.1.</span> <span class="toc-text">(1)允许我们使用比例的方式来指定控件的大小,它在手机屏幕的适配性方面可以起到非常重要</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E6%B0%B4%E5%B9%B3-%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E7%9A%84%E6%AF%94%E4%BE%8B%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9Alayout-width-%E2%80%9D0dp%E2%80%9D-layout-height-%E2%80%9D0dp%E2%80%9D"><span class="toc-number">3.3.1.3.2.</span> <span class="toc-text">(2)定义水平&#x2F;垂直方向的比例时，需要指定layout_width&#x3D;”0dp”&#x2F;layout_height&#x3D;”0dp”</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-5"><span class="toc-number">3.3.1.3.3.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80"><span class="toc-number">3.3.2.</span> <span class="toc-text">二、相对布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%9B%B8%E5%AF%B9%E4%BA%8E%E7%88%B6%E5%B8%83%E5%B1%80%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">1.相对于父布局进行定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">2.相对于兄弟组件定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-margin-%E5%81%8F%E7%A7%BB-%EF%BC%9A%E8%AE%BE%E7%BD%AE%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%9B%B8%E5%AF%B9%E4%BA%8E%E7%9A%84%E8%BE%B9%E8%B7%9D"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">3. margin(偏移)：设置组件与相对于的边距</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-padding-%E5%A1%AB%E5%85%85-%EF%BC%9A%E8%AE%BE%E7%BD%AE%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E5%85%83%E7%B4%A0%E9%97%B4%E7%9A%84%E8%BE%B9%E8%B7%9D"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">4.padding(填充)：设置组件内部元素间的边距</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%81margin%E9%92%88%E5%AF%B9%E7%9A%84%E6%98%AF%E5%AE%B9%E5%99%A8%EF%BC%88%E5%B8%83%E5%B1%80%EF%BC%89%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%98%AF%E5%81%8F%E7%A7%BB%EF%BC%8C%E8%80%8Cpadding%E9%92%88%E5%AF%B9%E7%9A%84%E6%98%AF%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%98%AF%E5%A1%AB%E5%85%85%E3%80%82"><span class="toc-number">3.3.2.4.1.</span> <span class="toc-text">！margin针对的是容器（布局）中的组件，设置的是偏移，而padding针对的是组件中的元素，设置的是填充。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%A7%E5%B8%83%E5%B1%80"><span class="toc-number">3.3.3.</span> <span class="toc-text">三、帧布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%99%BE%E5%88%86%E7%99%BE%E5%B8%83%E5%B1%80"><span class="toc-number">3.3.4.</span> <span class="toc-text">四、百分百布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-percentFrameLayout-%E7%BB%A7%E6%89%BF%E4%BA%86FrameLayout%E7%9A%84%E5%85%A8%E9%83%A8%E7%89%B9%E6%80%A7"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">1.percentFrameLayout: 继承了FrameLayout的全部特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#percentRelativeLayout-%E7%BB%A7%E6%89%BF%E4%BA%86RelativeLayout%E7%9A%84%E5%85%A8%E9%83%A8%E7%89%B9%E6%80%A7"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">percentRelativeLayout: 继承了RelativeLayout的全部特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%BD%E9%AB%98"><span class="toc-number">3.3.4.3.</span> <span class="toc-text">2.设置组件的宽高</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#app-layout-widthPercent-%E2%80%9D-%E2%80%9D"><span class="toc-number">3.3.4.3.1.</span> <span class="toc-text">app: layout_widthPercent&#x3D;”..%”</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#app-layout-heightPercent-%E2%80%9C-%E2%80%9D"><span class="toc-number">3.3.4.3.2.</span> <span class="toc-text">app: layout_heightPercent&#x3D;“..%”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E7%9A%84build-gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%88%86%E6%AF%94%E5%B8%83%E5%B1%80%E5%BA%93%E7%9A%84%E4%BE%9D%E8%B5%96-%E4%BF%9D%E8%AF%81%E7%99%BE%E5%88%86%E6%AF%94%E5%B8%83%E5%B1%80%E5%9C%A8Android%E6%89%80%E6%9C%89%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E4%B8%8A%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">3.3.4.4.</span> <span class="toc-text">3.在项目的build.gradle中添加百分比布局库的依赖,保证百分比布局在Android所有系统版本上的兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E7%99%BE%E5%88%86%E6%AF%94%E5%B8%83%E5%B1%80"><span class="toc-number">3.3.4.5.</span> <span class="toc-text">4.使用百分比布局</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text">创建自定义控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E5%B8%83%E5%B1%80"><span class="toc-number">3.4.1.</span> <span class="toc-text">1.引入布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A0%87%E9%A2%98%E6%A0%8F%E5%B8%83%E5%B1%80title-xml%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">（1）创建一个标题栏布局title.xml文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B8%AD%E5%BC%95%E7%94%A8-lt-include-layout-%E2%80%9C-layout-title%E2%80%9D-gt"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">（2）在活动中引用  &lt;include layout &#x3D; “@layout&#x2F;title”&#x2F; &gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9A%90%E8%97%8F%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%9A%84%E6%A0%87%E9%A2%98%E6%A0%8F"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">(3) 隐藏系统自带的标题栏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActionBar-actionbar-getSupportActionBar"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">ActionBar actionbar &#x3D; getSupportActionBar(</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%88%E5%B8%83%E5%B1%80%EF%BC%89"><span class="toc-number">3.4.2.</span> <span class="toc-text">2.创建自定义控件（布局）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BC%95%E5%85%A5%E5%B8%83%E5%B1%80%E7%9A%84%E6%8A%80%E5%B7%A7%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E5%BC%95%E4%BA%BA%E5%B8%83%E5%B1%80%E7%9A%84%E6%8A%80%E5%B7%A7%E7%A1%AE%E5%AE%9E%E8%A7%A3%E5%86%B3%E4%BA%86%E9%87%8D%E5%A4%8D%E7%BC%96%E5%86%99%E5%B8%83%E5%B1%80%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98-%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9C%E5%B8%83%E5%B1%80%E4%B8%AD%E6%9C%89%E4%B8%80%E4%BA%9B%E6%8E%A7%E4%BB%B6%E8%A6%81%E6%B1%82%E8%83%BD%E5%A4%9F%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E6%98%AF%E9%9C%80%E8%A6%81%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%B4%BB%E5%8A%A8%E4%B8%AD%E4%B8%BA%E8%BF%99%E4%BA%9B%E6%8E%A7%E4%BB%B6%E5%8D%95%E7%8B%AC%E7%BC%96%E5%86%99%E2%80%93%E6%AC%A1%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%E6%AF%94%E5%A6%82%E8%AF%B4%E6%A0%87%E9%A2%98%E6%A0%8F%E4%B8%AD%E7%9A%84%E8%BF%94%E5%9B%9E%E6%8C%89%E9%92%AE%EF%BC%8C%E5%85%B6%E5%AE%9E%E4%B8%8D%E7%AE%A1%E6%98%AF%E5%9C%A8%E5%93%AA%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8%E4%B8%AD%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%8C%89%E9%92%AE%E7%9A%84%E5%8A%9F%E8%83%BD%E9%83%BD%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%8C%E5%8D%B3%E9%94%80%E6%AF%81%E5%BD%93%E5%89%8D%E6%B4%BB%E5%8A%A8%E3%80%82%E8%80%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8%E4%B8%AD%E9%83%BD%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E6%B3%A8%E5%86%8C%E4%B8%80%E9%81%8D%E8%BF%94%E5%9B%9E%E6%8C%89%E9%92%AE%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%97%A0%E7%96%91%E4%BC%9A%E5%A2%9E%E5%8A%A0%E5%BE%88%E5%A4%9A%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E6%9C%80%E5%A5%BD%E6%98%AF%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%A7%A3%E5%86%B3%E3%80%82"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">（1）引入布局的技巧出现的问题：引人布局的技巧确实解决了重复编写布局代码的问题,但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写–次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80%E7%B1%BB-TitleLayout-%E5%8C%85%E5%90%AB%E7%BB%84%E4%BB%B6%E7%9A%84%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">（2）创建一个自定义布局类 TitleLayout(包含组件的响应事件)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%BF%99%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">3.在布局文件中添加这个自定义控件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%92%8C%E6%B7%BB%E5%8A%A0%E6%99%AE%E9%80%9A%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87%E5%9C%A8%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91"><span class="toc-number">3.4.2.3.1.</span> <span class="toc-text">添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B8%B8%E7%94%A8%E5%92%8C%E6%9C%80%E9%9A%BE%E7%94%A8%E7%9A%84%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94ListView"><span class="toc-number">3.5.</span> <span class="toc-text">最常用和最难用的控件——ListView</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81ListView%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95"><span class="toc-number">3.5.1.</span> <span class="toc-text">一、ListView的简单用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%A8%E5%B8%83%E5%B1%80%E4%B8%AD%E5%8A%A0%E5%85%A5ListView%E6%8E%A7%E4%BB%B6"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">1.在布局中加入ListView控件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%EF%BC%88M%EF%BC%89"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">2.准备数据（M）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%87%86%E5%A4%87%E8%A7%86%E5%9B%BE%EF%BC%88V%EF%BC%89"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">3.准备视图（V）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ListView-listView-ListView-findViewById-R-id-list-view"><span class="toc-number">3.5.1.3.1.</span> <span class="toc-text">ListView listView &#x3D; (ListView) findViewById(R.id.list_view);</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%87%86%E5%A4%87%E9%80%82%E9%85%8D%E5%99%A8-C"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">4.准备适配器(C)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayAdapter-lt-String-gt-adapter-new-ArrayAdapter-lt-String-gt-MainActivity-this%EF%BC%8C-android-R-layout-simple-list-item-1-data"><span class="toc-number">3.5.1.4.1.</span> <span class="toc-text">ArrayAdapter&lt; String &gt;  adapter &#x3D; new ArrayAdapter&lt; String&gt;(MainActivity.this，            android.R.layout.simple_list_item_1, data);</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9A%E5%88%B6ListView%E7%9A%84%E7%95%8C%E9%9D%A2"><span class="toc-number">3.5.2.</span> <span class="toc-text">二、定制ListView的界面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAFruit%E7%B1%BB%EF%BC%8C%E4%BD%9C%E4%B8%BA%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E9%80%82%E9%85%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">1.新建一个Fruit类，作为适配器的适配类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%90%E9%A1%B9%E5%B8%83%E5%B1%80fruit-item-xml"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">2.自定义子项布局fruit_item.xml</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-6"><span class="toc-number">3.5.2.2.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%82%E9%85%8D%E5%99%A8MyAdapter"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">3.自定义适配器MyAdapter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-7"><span class="toc-number">3.5.2.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%97%E8%A1%A8"><span class="toc-number">3.5.2.5.</span> <span class="toc-text">4.初始化数据，创建数据列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8F%90%E5%8D%87ListView%E7%9A%84%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87"><span class="toc-number">3.5.3.</span> <span class="toc-text">四、提升ListView的运行效率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%87%8D%E7%94%A8convertView"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">1.重用convertView</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-8"><span class="toc-number">3.5.4.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E9%83%A8%E7%B1%BBViewHolder%E5%AF%B9%E6%8E%A7%E4%BB%B6%E5%AE%9E%E4%BE%8B%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">2.内部类ViewHolder对控件实例进行缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%BB%9A%E8%BD%AE%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94RecyclerView"><span class="toc-number">3.6.</span> <span class="toc-text">更强大的滚轮控件——RecyclerView</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">3.6.1.</span> <span class="toc-text">一、基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E5%9C%A8%E9%A1%B9%E7%9B%AE%E7%9A%84build-gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%BA%94%E7%9A%84%E4%BE%9D%E8%B5%96%E5%BA%93"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">1.首先需要在项目的build.gradle中添加相应的依赖库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8%E5%B8%83%E5%B1%80%E4%B8%AD%E5%BC%95%E7%94%A8"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">2.在布局中引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%87%86%E5%A4%87Fruit%E7%B1%BB%E3%80%81fruit-item-xml%E3%80%81"><span class="toc-number">3.6.1.3.</span> <span class="toc-text">3.准备Fruit类、fruit_item.xml、</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BARecycleView%E5%87%86%E5%A4%87%E4%B8%80%E4%B8%AA%E9%80%82%E9%85%8D%E5%99%A8FruitAdapter-%E7%BB%A7%E6%89%BF%E8%87%AARecyclerView-Adapter-%E5%B9%B6%E5%B0%86%E6%B3%9B%E5%9E%8B%E6%8C%87%E5%AE%9A%E4%B8%BAFruitAdapter-ViewHolder"><span class="toc-number">3.6.1.4.</span> <span class="toc-text">4.为RecycleView准备一个适配器FruitAdapter,继承自RecyclerView.Adapter,并将泛型指定为FruitAdapter.ViewHolder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B8%AD%E4%BD%BF%E7%94%A8RecyclerView"><span class="toc-number">3.6.1.5.</span> <span class="toc-text">5.在活动中使用RecyclerView</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E5%92%8C%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80"><span class="toc-number">3.6.2.</span> <span class="toc-text">二、实现横向滚动和瀑布流布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">1.横向滚动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#layoutManager-setOrientation-LineatLayoutManager-HORIZONTAL"><span class="toc-number">3.6.2.1.1.</span> <span class="toc-text">layoutManager.setOrientation(LineatLayoutManager.HORIZONTAL);</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80-StaggeredGridLayoutManager"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">2.瀑布流布局 StaggeredGridLayoutManager</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#StaggeredGridLayoutManager-layoutManager-new-StaggeredGridLayoutManager-3-StaggeredGridLayoutManager-VERTICAL"><span class="toc-number">3.6.2.2.1.</span> <span class="toc-text">StaggeredGridLayoutManager layoutManager &#x3D; new StaggeredGridLayoutManager (3, StaggeredGridLayoutManager.VERTICAL);</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#recycleView-setLayoutManager-layoutManager"><span class="toc-number">3.6.2.2.2.</span> <span class="toc-text">recycleView.setLayoutManager(layoutManager);</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81RecyclerView%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.6.3.</span> <span class="toc-text">三、RecyclerView的点击事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8E%A2%E7%A9%B6%E7%A2%8E%E7%89%87"><span class="toc-number">4.</span> <span class="toc-text">第四章 探究碎片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%8E%E7%89%87%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.</span> <span class="toc-text">碎片是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%8E%E7%89%87%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">碎片的使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%99%E6%80%81%E4%BD%BF%E7%94%A8Fragment"><span class="toc-number">4.2.1.</span> <span class="toc-text">一、静态使用Fragment</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%99%E6%98%AF%E4%BD%BF%E7%94%A8Fragment%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%8A%8AFragment%E5%BD%93%E6%88%90%E6%99%AE%E9%80%9A%E7%9A%84%E6%8E%A7%E4%BB%B6%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%86%99%E5%9C%A8Activity%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E4%B8%AD%E3%80%82"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">1. 这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">2.实现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E7%A2%8E%E7%89%87%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6-fragment-master-xml"><span class="toc-number">4.2.1.2.1.</span> <span class="toc-text">（1）创建碎片布局文件 fragment_master.xml</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%9B%E5%BB%BA%E7%A2%8E%E7%89%87%E7%B1%BBMasterFragment-Java"><span class="toc-number">4.2.1.2.2.</span> <span class="toc-text">（2）创建碎片类MasterFragment.Java</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%9C%A8%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9B%B4%E6%8E%A5%E7%94%A8%E5%88%9B%E5%BB%BA%E5%A5%BD%E7%9A%84Fragment%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.2.1.2.3.</span> <span class="toc-text">（3）在布局文件中直接用创建好的Fragment控件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0Fragment"><span class="toc-number">4.2.2.</span> <span class="toc-text">二、动态添加Fragment</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%B9%E6%8D%AE%E5%85%B7%E4%BD%93%E6%83%85%E5%86%B5%EF%BC%8C%E5%8A%A8%E6%80%81%E5%9C%B0%E6%B7%BB%E5%8A%A0Fragment%E5%88%B0Activity%E6%B4%BB%E5%8A%A8%E4%B8%AD%E3%80%82"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">1.程序运行时根据具体情况，动态地添加Fragment到Activity活动中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Fragment%E4%BA%8B%E5%8A%A1%EF%BC%9A"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">2.Fragment事务：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AF%B9Fragment%E8%BF%9B%E8%A1%8C%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E6%9B%BF%E6%8D%A2%E6%88%96%E6%89%A7%E8%A1%8C%E5%85%B6%E4%BB%96%E5%8A%A8%E4%BD%9C%EF%BC%8C%E5%8D%B3%E6%8F%90%E4%BA%A4%E7%BB%99Activity%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%8F%98%E5%8C%96%E3%80%82"><span class="toc-number">4.2.2.2.1.</span> <span class="toc-text">（1）对Fragment进行添加、移除、替换或执行其他动作，即提交给Activity的每一个变化。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">3.实现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9C%A8%E4%B8%8A%E4%BE%8B%E5%9F%BA%E7%A1%80%E4%B8%8A%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A2%8E%E7%89%87%E5%B8%83%E5%B1%80-fragment-another-xml%E5%8F%8A%E5%85%B6%E7%B1%BBAnotherFragment-java"><span class="toc-number">4.2.2.3.1.</span> <span class="toc-text">（1）在上例基础上，新建一个碎片布局 fragment_another.xml及其类AnotherFragment.java</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BF%AE%E6%94%B9MainActivity%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6acitivty-main-xml"><span class="toc-number">4.2.2.3.2.</span> <span class="toc-text">（2）修改MainActivity的布局文件acitivty_main.xml:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%AF%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%A2%8E%E7%89%87%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.2.2.3.3.</span> <span class="toc-text">（3）在代码证动态加载碎片控件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%9C%A8%E7%A2%8E%E7%89%87%E4%B8%AD%E6%A8%A1%E6%8B%9F%E8%BF%94%E5%9B%9E%E6%A0%88"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">4.在碎片中模拟返回栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#addToBackStack-%E7%94%A8%E4%BA%8E%E5%B0%86%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%BF%94%E5%9B%9E%E6%A0%88"><span class="toc-number">4.2.2.4.1.</span> <span class="toc-text">addToBackStack()用于将一个事务添加到返回栈</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%A2%8E%E7%89%87%E5%92%8C%E6%B4%BB%E5%8A%A8%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-number">4.2.2.5.</span> <span class="toc-text">5.碎片和活动之间进行通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%A2%8E%E7%89%87%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="toc-number">4.2.2.5.1.</span> <span class="toc-text">（1）在活动中获取碎片实例：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9C%A8%E7%A2%8E%E7%89%87%E4%B8%AD%E8%AE%BF%E9%97%AE%E6%B4%BB%E5%8A%A8%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.2.2.5.2.</span> <span class="toc-text">（2）在碎片中访问活动中的方法：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%8E%E7%89%87%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.3.</span> <span class="toc-text">碎片的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%A2%8E%E7%89%87%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.3.1.</span> <span class="toc-text">一、碎片的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">1.运行状态：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9A%82%E5%81%9C%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">2.暂停状态：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%81%9C%E6%AD%A2%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">3.停止状态：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%94%80%E6%AF%81%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">4.3.1.4.</span> <span class="toc-text">4.销毁状态：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">4.4.</span> <span class="toc-text">限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#layout-large-%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">4.4.1.</span> <span class="toc-text">layout - large 文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#layout-sw600dp%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">4.4.2.</span> <span class="toc-text">layout - sw600dp文件夹</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E7%89%88%E7%9A%84%E6%96%B0%E9%97%BB%E5%BA%94%E7%94%A8"><span class="toc-number">4.5.</span> <span class="toc-text">简易版的新闻应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E4%B8%80%E4%B8%AA%E6%96%B0%E9%97%BB%E5%AE%9E%E4%BD%93%E7%B1%BB-News-java"><span class="toc-number">4.5.1.</span> <span class="toc-text">一、准备一个新闻实体类 News.java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8E%A5%E7%9D%80%E6%96%B0%E5%BB%BA%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6news-content-frag-xml%EF%BC%8C%E7%94%A8%E4%BA%8E%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AE%B9%E7%A2%8E%E7%89%87%E7%B1%BB%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-number">4.5.2.</span> <span class="toc-text">二、接着新建布局文件news_content_frag.xml，用于作为内容碎片类的布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%84%B6%E5%90%8E%E5%86%8D%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%86%85%E5%AE%B9%E7%A2%8E%E7%89%87%E7%B1%BBNewsContentFragment%EF%BC%8C%E7%BB%A7%E6%89%BF%E8%87%AAFragment"><span class="toc-number">4.5.3.</span> <span class="toc-text">三、然后再新建一个内容碎片类NewsContentFragment，继承自Fragment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BF%99%E6%A0%B7%E6%88%91%E4%BB%AC%E5%B0%B1%E6%8A%8A%E6%96%B0%E9%97%BB%E5%86%85%E5%AE%B9%E7%9A%84%E7%A2%8E%E7%89%87%E5%92%8C%E5%B8%83%E5%B1%80%E9%83%BD%E5%88%9B%E5%BB%BA%E5%A5%BD%E4%BA%86%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E4%BB%AC%E9%83%BD%E6%98%AF%E5%9C%A8%E5%8F%8C%E9%A1%B5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%83%B3%E5%9C%A8%E5%8D%95%E9%A1%B5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E9%9C%80%E8%A6%81%E5%86%8D%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B4%BB%E5%8A%A8%E3%80%82%E5%8F%B3%E5%87%BB-com-example-fragmentbestpractice"><span class="toc-number">4.5.4.</span> <span class="toc-text">四、这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击 com.example.fragmentbestpractice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%84%B6%E5%90%8E%E4%BF%AE%E6%94%B9NewsContentActivity%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA"><span class="toc-number">4.5.5.</span> <span class="toc-text">五、然后修改NewsContentActivity中的代码，如下所示:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%BF%98%E9%9C%80%E8%A6%81%E5%86%8D%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BA%8E%E6%98%BE%E7%A4%BA%E6%96%B0%E9%97%BB%E5%88%97%E8%A1%A8%E7%A2%8E%E7%89%87%E7%B1%BB%E7%9A%84%E5%B8%83%E5%B1%80%EF%BC%8C%E6%96%B0%E5%BB%BAnews-title-frag-xml"><span class="toc-number">4.5.6.</span> <span class="toc-text">六、接下来还需要再创建一个用于显示新闻列表碎片类的布局，新建news title frag.xml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%96%B0%E5%BB%BAnews-item-xml%E4%BD%9C%E4%B8%BARecyclerView%E5%AD%90%E9%A1%B9%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-number">4.5.7.</span> <span class="toc-text">七、新建news_item.xml作为RecyclerView子项的布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%97%A2%E7%84%B6%E6%96%B0%E9%97%BB%E5%88%97%E8%A1%A8%E5%92%8C%E5%AD%90%E9%A1%B9%E7%9A%84%E5%B8%83%E5%B1%80%E9%83%BD%E5%B7%B2%E7%BB%8F%E5%88%9B%E5%BB%BA%E5%A5%BD%E4%BA%86-%E9%82%A3%E4%B9%88%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%88%91%E4%BB%AC%E5%B0%B1%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BA%8E%E5%B1%95%E7%A4%BA%E6%96%B0%E9%97%BB%E5%88%97%E8%A1%A8%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%82%E8%BF%99%E9%87%8C%E6%96%B0%E5%BB%BANewsTitleFragment%E4%BD%9C%E4%B8%BA%E6%96%B0%E9%97%BB%E5%88%97%E8%A1%A8%E7%9A%84%E7%A2%8E%E7%89%87%E7%B1%BB%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA"><span class="toc-number">4.5.8.</span> <span class="toc-text">八、既然新闻列表和子项的布局都已经创建好了,那么接下来我们就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为新闻列表的碎片类，代码如下所示:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%A4%E4%B8%AA%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%BB%E6%B4%BB%E5%8A%A8%E5%B8%83%E5%B1%80"><span class="toc-number">4.5.9.</span> <span class="toc-text">九、创建两个模式的主活动布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%9C%A8NewsTitleFragment%E4%B8%AD%E9%80%9A%E8%BF%87RecyclerView%E5%B0%86%E6%96%B0%E9%97%BB%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E3%80%82%E6%88%91%E4%BB%AC%E5%9C%A8NewsTitleFragment%E4%B8%AD%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%86%85%E9%83%A8%E7%B1%BBNewsAdapter%E6%9D%A5%E4%BD%9C%E4%B8%BARecyclerView%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%8C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA"><span class="toc-number">4.5.10.</span> <span class="toc-text">十、在NewsTitleFragment中通过RecyclerView将新闻列表展示出来。我们在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下所示:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E7%9B%B8%E5%BD%93%E4%BA%8E%E4%B9%8B%E5%89%8D%E5%9C%A8%E4%B8%BB%E6%B4%BB%E5%8A%A8%E4%B8%AD%E5%88%9B%E5%BB%BA%E2%80%9C%E9%80%82%E9%85%8D%E5%99%A8%E5%86%85%E9%83%A8%E7%B1%BB%E2%80%9D%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87%E8%BF%99%E9%87%8C%E5%9C%A8%E5%88%97%E8%A1%A8%E7%A2%8E%E7%89%87%E7%B1%BB%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%88%97%E8%A1%A8%EF%BC%8C%E5%88%9B%E5%BB%BA%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%8C%E5%86%8D%E7%84%B6%E5%90%8E%E5%9C%A8%E4%B8%BB%E6%B4%BB%E5%8A%A8%E5%B8%83%E5%B1%80%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E7%A2%8E%E7%89%87%E7%B1%BB%E6%8E%A7%E4%BB%B6%EF%BC%89"><span class="toc-number">4.5.10.1.</span> <span class="toc-text">（相当于之前在主活动中创建“适配器内部类”的情况，只不过这里在列表碎片类中添加列表，创建适配器，再然后在主活动布局中使用列表碎片类控件）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E7%8E%B0%E5%9C%A8%E8%BF%98%E5%89%A9%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5%E6%94%B6%E5%B0%BE%E5%B7%A5%E4%BD%9C%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%90%91RecyclerView%E4%B8%AD%E5%A1%AB%E5%85%85%E6%95%B0%E6%8D%AE%E4%BA%86%E3%80%82%E4%BF%AE%E6%94%B9NewsTitle-Fragment%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA"><span class="toc-number">4.5.11.</span> <span class="toc-text">十一、现在还剩最后一步收尾工作，就是向RecyclerView中填充数据了。修改NewsTitle-Fragment中的代码，如下所示:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%A8%E5%B1%80%E5%A4%A7%E5%96%87%E5%8F%AD%E2%80%94%E2%80%94%E8%AF%A6%E8%A7%A3%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">第五章 全局大喇叭——详解广播机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">广播机制简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%80%E7%A7%8D%E4%BC%A0%E8%BE%93%E4%BF%A1%E6%81%AF%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">5.1.1.</span> <span class="toc-text">一、一种传输信息的机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AFAndroid%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%EF%BC%8C%E6%AF%94%E5%A6%82%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%8F%98%E5%8C%96%E3%80%81%E7%94%B5%E6%B1%A0%E7%94%B5%E9%87%8F%E5%8F%98%E5%8C%96%E3%80%81%E6%8E%A5%E6%94%B6%E5%88%B0%E7%9A%84%E7%9F%AD%E4%BF%A1%E4%BF%A1%E6%81%AF%E6%88%96%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%8F%98%E5%8C%96%E7%AD%89%E3%80%82"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">广播消息可以是应用程序的数据信息，也可以是Android的系统消息，比如网络连接变化、电池电量变化、接收到的短信信息或系统设置的变化等。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%AF%B9%E8%87%AA%E5%B7%B1%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E5%B9%BF%E6%92%AD%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%86%8C%EF%BC%8C%E4%BE%BF%E4%BA%8E%E6%8E%A5%E6%94%B6%E5%B9%BF%E6%92%AD%E5%86%85%E5%AE%B9%E3%80%82"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">Android中的每个应用程序都可以对自己感兴趣的广播进行注册，便于接收广播内容。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E5%B9%BF%E6%92%AD%E9%9C%80%E8%A6%81%E4%B8%93%E9%97%A8%E7%9A%84%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8%EF%BC%88Broadcast-Reciever%EF%BC%89%E3%80%82"><span class="toc-number">5.1.1.3.</span> <span class="toc-text">接收广播需要专门的广播接收器（Broadcast Reciever）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE%E5%A5%BD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9B%91%E5%90%AC%E7%89%B9%E5%AE%9A%E7%9A%84%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF%E7%84%B6%E5%90%8E%E8%BF%9B%E8%A1%8C%E5%93%8D%E5%BA%94%E3%80%82"><span class="toc-number">5.1.1.4.</span> <span class="toc-text">广播接收器通过设置好的过滤器监听特定的广播消息然后进行响应。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B9%BF%E6%92%AD%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.2.</span> <span class="toc-text">二、广播的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%87%E5%87%86%E5%B9%BF%E6%92%AD"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">1.标准广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%89%E5%BA%8F%E5%B9%BF%E6%92%AD"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">2.有序广播</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E3%80%82%E5%9C%A8%E5%B9%BF%E6%92%AD%E5%8F%91%E5%87%BA%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%90%8C%E4%B8%80%E6%97%B6%E5%88%BB%E5%8F%AA%E4%BC%9A%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8%E8%83%BD%E5%A4%9F%E6%94%B6%E5%88%B0%E8%BF%99%E6%9D%A1%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF%EF%BC%8C%E5%BD%93%E8%BF%99%E4%B8%AA%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%EF%BC%8C%E5%B9%BF%E6%92%AD%E6%89%8D%E4%BC%9A%E7%BB%A7%E7%BB%AD%E4%BC%A0%E9%80%92%E3%80%82"><span class="toc-number">5.1.2.2.1.</span> <span class="toc-text">同步执行。在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8%E6%98%AF%E6%9C%89%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E7%9A%84%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%85%88%E6%94%B6%E5%88%B0%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF%E3%80%82"><span class="toc-number">5.1.2.2.2.</span> <span class="toc-text">广播接收器是有先后顺序，优先级高的广播接收器就可以先收到广播消息。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E7%9A%84%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8%E5%8F%AF%E4%BB%A5%E6%88%AA%E6%96%AD%E6%AD%A3%E5%9C%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%B9%BF%E6%92%AD%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%BC%98%E5%85%88%E7%BA%A7%E4%BD%8E%E7%9A%84%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8%E5%B0%86%E6%97%A0%E6%B3%95%E6%94%B6%E5%88%B0%E5%B9%BF%E6%92%AD%E4%BF%A1%E6%81%AF%E3%80%82"><span class="toc-number">5.1.2.2.3.</span> <span class="toc-text">优先级高的广播接收器可以截断正在传递的广播，因此优先级低的广播接收器将无法收到广播信息。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BroadcastReceiver%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.2.</span> <span class="toc-text">BroadcastReceiver介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81BroadcastReceiver"><span class="toc-number">5.2.1.</span> <span class="toc-text">一、BroadcastReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E4%B8%80%E7%A7%8D%E5%85%A8%E5%B1%80%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%8C%E7%94%A8%E4%BA%8E%E7%9B%91%E5%90%AC%E7%B3%BB%E7%BB%9F%E5%85%A8%E5%B1%80%E7%9A%84%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%AE%83%E5%8F%AF%E4%BB%A5%E9%9D%9E%E5%B8%B8%E6%96%B9%E4%BE%BF%E5%9C%B0%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E3%80%82"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">1.本质上是一种全局监听器，用于监听系统全局的广播消息，因此它可以非常方便地实现系统中不同组件之间的通信。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-BroadcastReceiver%E7%94%A8%E4%BA%8E%E6%8E%A5%E6%94%B6%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B9%BF%E6%92%AD%EF%BC%8C%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9B%91%E5%90%AC%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF%E5%90%8E%E8%BF%9B%E8%A1%8C%E5%93%8D%E5%BA%94%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9A"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">2. BroadcastReceiver用于接收指定的广播，通过设置过滤器监听感兴趣的广播消息后进行响应，例如：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Broadcast%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text">二、Broadcast开发过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">1.定义广播接收器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFBroadcastReceiver%E5%9F%BA%E7%B1%BB%EF%BC%8C%E5%AE%9E%E7%8E%B0onReceiver%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">5.2.2.1.1.</span> <span class="toc-text">继承BroadcastReceiver基类，实现onReceiver方法：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B3%A8%E5%86%8C%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">2.注册广播接收器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C%EF%BC%9A"><span class="toc-number">5.2.2.2.1.</span> <span class="toc-text">（1）静态注册：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%EF%BC%9A%EF%BC%88%E5%8F%AF%E5%AE%9A%E4%B9%89%E4%B8%BA%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89"><span class="toc-number">5.2.2.2.2.</span> <span class="toc-text">（2）动态注册：（可定义为内部类）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-BroadcastReceiver%E5%93%8D%E5%BA%94"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">3.BroadcastReceiver响应</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B3%A8%E5%86%8C%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E5%8D%B3%E5%8F%AF%E6%8E%A5%E6%94%B6%E7%9B%B8%E5%BA%94%E7%9A%84%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF%E3%80%82%E4%B8%80%E6%97%A6%E5%B9%BF%E6%92%AD%EF%BC%88Broadcast%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E5%90%8E%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B0%B1%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%AF%B9%E5%BA%94%E7%9A%84BroadcastReceiver%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%B9%B6%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91%E5%AE%83%E7%9A%84onReceive-%E6%96%B9%E6%B3%95%EF%BC%8ConReceive-%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%90%8E%EF%BC%8CBroadcastReceiver%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B0%B1%E4%BC%9A%E8%A2%AB%E9%94%80%E6%AF%81%E3%80%82"><span class="toc-number">5.2.2.3.1.</span> <span class="toc-text">（1）注册完成后，即可接收相应的广播消息。一旦广播（Broadcast）事件发生后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive()方法，onReceive()方法执行完后，BroadcastReceiver的实例就会被销毁。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E5%A6%82%E6%9E%9CBroadcastReceiver%E7%9A%84onReceive-%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E5%9C%A810%E7%A7%92%E5%86%85%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90%EF%BC%8CAndroid%E4%BC%9A%E8%AE%A4%E4%B8%BA%E8%AF%A5%E7%A8%8B%E5%BA%8F%E6%97%A0%E5%93%8D%E5%BA%94%E3%80%82%E6%89%80%E4%BB%A5%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84onReceive-%E6%96%B9%E6%B3%95%E9%87%8C%E6%89%A7%E8%A1%8C%E4%B8%80%E4%BA%9B%E8%80%97%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%90%A6%E5%88%99%E4%BC%9A%E5%BC%B9%E5%87%BAANR%EF%BC%88Application-No-Response%EF%BC%89%E5%AF%B9%E8%AF%9D%E6%A1%86%E3%80%82"><span class="toc-number">5.2.2.3.2.</span> <span class="toc-text">（2） 如果BroadcastReceiver的onReceive()方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在广播接收者的onReceive()方法里执行一些耗时的操作，否则会弹出ANR（Application No Response）对话框。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B9%BF%E6%92%AD"><span class="toc-number">5.3.</span> <span class="toc-text">发送自定义广播</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%87%E5%87%86%E5%B9%BF%E6%92%AD%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">一、标准广播：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%98%AF%E5%AE%8C%E5%85%A8%E5%BC%82%E6%AD%A5%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%90%8C%E4%B8%80%E6%97%B6%E5%88%BB%EF%BC%88%E9%80%BB%E8%BE%91%E4%B8%8A%EF%BC%89%E8%A2%AB%E6%89%80%E6%9C%89%E6%8E%A5%E6%94%B6%E8%80%85%E6%8E%A5%E6%94%B6%E5%88%B0%EF%BC%8C%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%9A%84%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83%E9%AB%98%E3%80%82%E4%BD%86%E7%BC%BA%E7%82%B9%E6%98%AF%E6%8E%A5%E6%94%B6%E8%80%85%E4%B8%8D%E8%83%BD%E5%B0%86%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E4%BC%A0%E9%80%92%E7%BB%99%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%A5%E6%94%B6%E8%80%85%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%97%A0%E6%B3%95%E7%BB%88%E6%AD%A2Broadcast-Intent%E7%9A%84%E4%BC%A0%E6%92%AD%E3%80%82"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">1.是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Intent-intent-new-Intent-%E2%80%9Ccom-example-broadcasttest-MY-BROADCAST%E2%80%9D"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">2. Intent intent &#x3D; new Intent(“com.example.broadcasttest.MY_BROADCAST”);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendBroadcast-intent"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">sendBroadcast(intent);</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9C%89%E5%BA%8F%E5%B9%BF%E6%92%AD%EF%BC%9A"><span class="toc-number">5.3.2.</span> <span class="toc-text">二、有序广播：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%A5%E5%B9%BF%E6%92%AD%E7%9A%84%E6%8E%A5%E6%94%B6%E8%80%85%E5%B0%86%E6%8C%89%E9%A2%84%E5%85%88%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E4%BE%9D%E6%AC%A1%E6%8E%A5%E6%94%B6%E5%B9%BF%E6%92%AD%E3%80%82%E6%9C%89%E5%BA%8F%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E8%80%85%E5%8F%AF%E4%BB%A5%E7%BB%88%E6%AD%A2%E5%B9%BF%E6%92%AD%E7%9A%84%E4%BC%A0%E6%92%AD%EF%BC%88%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8abortBroadcast-%E6%96%B9%E6%B3%95%EF%BC%89%EF%BC%8C%E5%B9%BF%E6%92%AD%E7%9A%84%E4%BC%A0%E6%92%AD%E4%B8%80%E6%97%A6%E7%BB%88%E6%AD%A2%EF%BC%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E6%8E%A5%E6%94%B6%E8%80%85%E5%B0%B1%E6%97%A0%E6%B3%95%E6%8E%A5%E6%94%B6%E5%88%B0%E5%B9%BF%E6%92%AD%E3%80%82%E5%8F%A6%E5%A4%96%EF%BC%8C%E5%B9%BF%E6%92%AD%E7%9A%84%E6%8E%A5%E6%94%B6%E8%80%85%E5%8F%AF%E4%BB%A5%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%BB%99%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%A5%E6%94%B6%E8%80%85%EF%BC%88%E9%80%9A%E8%BF%87setResultExtras-Bundle-bundle-%E6%96%B9%E6%B3%95%EF%BC%89%E3%80%82"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">1.该广播的接收者将按预先声明的优先级依次接收广播。有序广播接收者可以终止广播的传播（通过调用abortBroadcast()方法），广播的传播一旦终止，后面的接收者就无法接收到广播。另外，广播的接收者可以将数据传递给下一个接收者（通过setResultExtras(Bundle bundle)方法）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Intent-intent-new-Intent-%E2%80%9Ciet-jxufe-cn-android-OrderedBroadcastTest%E2%80%9D"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">2. Intent intent&#x3D;new Intent(“iet.jxufe.cn.android.OrderedBroadcastTest”);</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%B9%BF%E6%92%AD"><span class="toc-number">5.4.</span> <span class="toc-text">使用本地广播</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Android%E6%9C%AC%E5%9C%B0%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">5.4.1.</span> <span class="toc-text">一、Android本地广播机制：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E9%83%A8%E8%BF%9B%E8%A1%8C%E4%BC%A0%E9%80%92%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8%E4%B9%9F%E5%8F%AA%E8%83%BD%E6%8E%A5%E6%94%B6%E6%9D%A5%E8%87%AA%E6%9C%AC%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%91%E5%87%BA%E7%9A%84%E5%B9%BF%E6%92%AD"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">广播只能在应用程序内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A%E4%BD%BF%E7%94%A8LocalBroadcastManager%E5%AF%B9%E5%B9%BF%E6%92%AD%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%EF%BC%8C%E5%AF%B9%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD%E5%92%8C%E6%B3%A8%E5%86%8C%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E5%99%A8%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E3%80%82"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">方法：使用LocalBroadcastManager对广播进行管理，对发送广播和注册广播接收器进行管理。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%85%A8%E6%96%B9%E6%A1%88%E2%80%93%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">6.</span> <span class="toc-text">第六章 数据存储全方案–持久化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.</span> <span class="toc-text">持久化技术简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.数据存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Android%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-number">6.1.2.</span> <span class="toc-text">2.Android内部存储和外部存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%86%85%E5%AD%98%EF%BC%88Memory%EF%BC%89%EF%BC%9A"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">（1）内存（Memory）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%EF%BC%88Internal-Storage%EF%BC%89%EF%BC%9A"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">（2）内部存储（Internal Storage）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%EF%BC%88External-Storage%EF%BC%89%EF%BC%9A"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">（3）外部存储（External Storage）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">6.1.3.</span> <span class="toc-text">3.几个重要文件夹</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80DDMS%EF%BC%88Dalvik-Debug-Monitor-Service%EF%BC%89%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%AADevice-File-Explorer%EF%BC%9Adata%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%81mnt%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%81sdcard-%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%81storage%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">打开DDMS（Dalvik Debug Monitor Service），有一个Device File Explorer：data文件夹、mnt文件夹、sdcard 文件夹、storage文件夹</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8data"><span class="toc-number">6.1.4.</span> <span class="toc-text">4.内部存储data</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-data%E6%96%87%E4%BB%B6%E5%A4%B9%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E5%B8%B8%E8%AF%B4%E7%9A%84%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%EF%BC%8C%E6%89%93%E5%BC%80data%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%9A"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">(1)data文件夹就是我们常说的内部存储，打开data文件夹，有两个文件夹：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B9app%EF%BC%9A%E5%AD%98%E6%94%BE%E7%9D%80%E6%88%91%E4%BB%AC%E6%89%80%E6%9C%89%E5%AE%89%E8%A3%85%E7%9A%84app%E7%9A%84apk%E6%96%87%E4%BB%B6"><span class="toc-number">6.1.4.1.1.</span> <span class="toc-text">文件夹app：存放着我们所有安装的app的apk文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B9data%EF%BC%9A%E4%B8%80%E4%BA%9B%E5%8C%85%E5%90%8D%EF%BC%8C%E5%B1%95%E5%BC%80%E5%90%8E%EF%BC%8C"><span class="toc-number">6.1.4.1.2.</span> <span class="toc-text">文件夹data：一些包名，展开后，</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%B7%AF%E5%BE%84%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9AEnvironment-getDataDirectory-%E8%8E%B7%E5%8F%96%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E6%A0%B9%E8%B7%AF%E5%BE%84%E3%80%82-data"><span class="toc-number">6.1.4.2.</span> <span class="toc-text">（2）路径的访问：Environment.getDataDirectory()获取内部存储根路径。&#x2F;data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%87%A0%E7%82%B9%EF%BC%9A"><span class="toc-number">6.1.4.3.</span> <span class="toc-text">(3)几点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E5%8F%AA%E5%9C%A8%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E4%B8%AD%E5%88%9B%E5%BB%BAcache%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%AD%A4%E6%97%B6cache%E7%9B%AE%E5%BD%95%E6%98%AF%E7%A9%BA%E7%9A%84"><span class="toc-number">6.1.4.4.</span> <span class="toc-text">系统默认只在内部存储中创建cache目录，并且此时cache目录是空的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A4%E5%A4%96%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E9%9C%80%E8%A6%81%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%EF%BC%9Ashared-prefs%EF%BC%8Cdatabases%EF%BC%8Cfiles%E7%9B%AE%E5%BD%95"><span class="toc-number">6.1.4.5.</span> <span class="toc-text">此外，还可以根据需要自动创建：shared_prefs，databases，files目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%AB%E7%9A%84App%E5%87%A0%E4%B9%8E%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88%E9%83%BD%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%89%EF%BC%8C%E9%99%A4%E4%BA%86%E7%94%A8%E9%9D%9E%E6%B3%95%E6%89%8B%E6%AE%B5%E6%88%96%E8%80%85%E6%88%91%E4%BB%AC%E4%B8%BB%E5%8A%A8%E6%9A%B4%E9%9C%B2%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E6%96%87%E4%BB%B6%E4%BC%9A%E9%9A%8F%E7%9D%80App%E7%9A%84%E5%8D%B8%E8%BD%BD%E8%80%8C%E8%A2%AB%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4%E3%80%82"><span class="toc-number">6.1.4.6.</span> <span class="toc-text">别的App几乎无法访问内部存储中的数据（都是私有的），除了用非法手段或者我们主动暴露内部存储目录下的文件夹，文件会随着App的卸载而被系统自动删除。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E7%9A%84API"><span class="toc-number">6.1.4.7.</span> <span class="toc-text">（4）内部存储的API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8storage"><span class="toc-number">6.1.5.</span> <span class="toc-text">5.外部存储storage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E8%88%AC%E6%98%AF-storage-emulated-0%E4%B9%9F%E6%9C%89%E5%8F%AF%E8%83%BD%E6%98%AF%E5%85%B6%E5%AE%83%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E4%B8%8D%E5%90%8C%E5%8E%82%E5%AE%B6%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E6%9C%89%E5%8F%AF%E8%83%BD%E4%B8%8D%E4%B8%80%E6%A0%B7%E3%80%82"><span class="toc-number">6.1.5.1.</span> <span class="toc-text">(1)一般是&#x2F;storage&#x2F;emulated&#x2F;0也有可能是其它文件夹，不同厂家不同版本有可能不一样。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#storage-sdcard0%EF%BC%8C-sdcard%EF%BC%8C-mnt-sdcard%EF%BC%8C-storage-emulated-0%EF%BC%8C-storage-emulated-legacy"><span class="toc-number">6.1.5.2.</span> <span class="toc-text">&#x2F;storage&#x2F;sdcard0，&#x2F;sdcard，&#x2F;mnt&#x2F;sdcard，&#x2F;storage&#x2F;emulated&#x2F;0，&#x2F;storage&#x2F;emulated&#x2F;legacy</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E7%9B%AE%E5%BD%95%EF%BC%9A10%E5%A4%A7%E7%B1%BB%EF%BC%8C%E6%AF%94%E5%A6%82DCIM-Download%E7%AD%89%E8%BF%99%E4%BA%9B%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%82storage-emulated-0-Download%E7%AD%89"><span class="toc-number">6.1.5.2.1.</span> <span class="toc-text">公有目录：10大类，比如DCIM,Download等这些系统创建的文件夹。storage&#x2F;emulated&#x2F;0&#x2F;Download等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E7%9B%AE%E5%BD%95%EF%BC%9AAndroid%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E6%89%93%E5%BC%80%E5%90%8E%E6%9C%89data%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%82storage-emulated-0-Android-data-%E5%8C%85%E5%90%8D-%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%9A%E9%87%8C%E9%9D%A2%E5%8C%85%E5%90%AB%E4%BA%86%E8%AE%B8%E5%A4%9A%E5%8C%85%E5%90%8D%E7%BB%84%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%82"><span class="toc-number">6.1.5.2.2.</span> <span class="toc-text">私有目录：Android文件夹，打开后有data文件夹。storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;包名 文件夹：里面包含了许多包名组成的文件夹。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Google%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E6%88%91%E4%BB%ACApp%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%94%E8%AF%A5%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E7%9A%84%E7%A7%81%E6%9C%89%E7%9B%AE%E5%BD%95%EF%BC%88data%EF%BC%89%E4%B8%AD%E8%AF%A5App%E7%9A%84%E5%8C%85%E5%90%8D%E4%B8%8B%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%BD%93%E7%94%A8%E6%88%B7%E5%8D%B8%E8%BD%BD%E6%8E%89App%E4%B9%8B%E5%90%8E%EF%BC%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%80%E5%B9%B6%E5%88%A0%E9%99%A4%E3%80%82"><span class="toc-number">6.1.5.3.</span> <span class="toc-text">（2）Google官方建议我们App的数据应该存储在外部存储的私有目录（data）中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%B7%AF%E5%BE%84%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9AEnvironment-getExternalStorageDirectory-%EF%BC%9A%E8%8E%B7%E5%8F%96%E6%9C%BA%E8%BA%AB%E5%AD%98%E5%82%A8%E7%9A%84%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E6%A0%B9%E8%B7%AF%E5%BE%84%E3%80%82"><span class="toc-number">6.1.5.4.</span> <span class="toc-text">（3）路径的访问：Environment.getExternalStorageDirectory()：获取机身存储的外部存储根路径。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8CAndroid%E7%B3%BB%E7%BB%9F%E4%B8%8D%E4%BC%9A%E4%B8%BA%E6%88%91%E4%BB%AC%E7%9A%84App%E5%9C%A8%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9B%AE%E5%BD%95"><span class="toc-number">6.1.5.5.</span> <span class="toc-text">（4）默认情况下，Android系统不会为我们的App在外部存储中创建私有目录，需要手动创建私有目录</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#context-getExternalFilesDir-%E2%80%A6-%EF%BC%9A%E5%9C%A8storage-emulated-0-Android-data-%E5%8C%85%E5%90%8D-files-%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">6.1.5.5.1.</span> <span class="toc-text">context.getExternalFilesDir(…)：在storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;包名&#x2F;files 中创建文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E4%B8%8E%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E6%AF%94%E8%BE%83"><span class="toc-number">6.1.6.</span> <span class="toc-text">6.内部存储与外部存储比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%B8%85%E9%99%A4"><span class="toc-number">6.1.7.</span> <span class="toc-text">7.数据存储与清除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%9A"><span class="toc-number">6.1.7.1.</span> <span class="toc-text">（1）数据存储：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%B8%85%E9%99%A4%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-number">6.1.7.2.</span> <span class="toc-text">（2）清除数据：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AF%B9%E5%BA%94%E5%8C%85%E4%B8%AD%E7%9A%84cache%EF%BC%8Cfiles%EF%BC%8Clib%EF%BC%8Cshared-prefs%EF%BC%8CdatbBases%E7%AD%89%E7%AD%89"><span class="toc-number">6.1.7.2.1.</span> <span class="toc-text">删除对应包中的cache，files，lib，shared_prefs，datbBases等等</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="toc-number">6.1.7.3.</span> <span class="toc-text">(3) 清除缓存：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%9A%84%E6%98%AFApp%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%89%80%E4%BA%A7%E7%94%9F%E7%9A%84%E4%B8%B4%E6%97%B6%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%AF%94%E5%A6%82%E8%AF%BB%E5%85%A5%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%AE%A1%E7%AE%97%EF%BC%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AD%89%E7%AD%89%EF%BC%8C%E8%BF%99%E4%BA%9B%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%82%AF%E5%AE%9A%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%BE%88%E5%A4%9A%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E3%80%82"><span class="toc-number">6.1.7.3.1.</span> <span class="toc-text">删除的是App运行过程中所产生的临时数据，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.</span> <span class="toc-text">文件存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.内部存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AD%98%EF%BC%9A"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">（1）存：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8F%96%EF%BC%9A"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">（2）取：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.外部存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%A4%96%E9%83%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%EF%BC%9A"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">（1）外部根目录：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A4%96%E9%83%A8%E5%85%AC%E6%9C%89%E7%9B%AE%E5%BD%95%EF%BC%9A"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">（2）外部公有目录：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%8E%B7%E5%8F%96%E5%A4%96%E9%83%A8%E7%A7%81%E6%9C%89%E7%9B%AE%E5%BD%95"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">（3）获取外部私有目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%AD%98%EF%BC%9A"><span class="toc-number">6.2.2.4.</span> <span class="toc-text">（4）存：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%8F%96%EF%BC%9A"><span class="toc-number">6.2.2.5.</span> <span class="toc-text">（5）取：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SharedPreferences%E5%AD%98%E5%82%A8"><span class="toc-number">6.3.</span> <span class="toc-text">SharedPreferences存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96SharedPreferences%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.3.1.</span> <span class="toc-text">1.获取SharedPreferences对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Context-getSharedPreferences-%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">(1) Context . getSharedPreferences()方法 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Activity-%E7%B1%BB%E4%B8%AD%E7%9A%84-getPreferences-%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">(2)Activity 类中的 getPreferences() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-PreferenceManager-%E7%B1%BB%E4%B8%AD%E7%9A%84-getDefaultSharedPreferences-%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.1.3.</span> <span class="toc-text">(3) PreferenceManager 类中的 getDefaultSharedPreferences() 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87SharedPreferences%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E5%88%B0Editor%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.通过SharedPreferences对象获取到Editor对象存数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89SharePreferences-Editor-editor-shared-edit"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">（1）SharePreferences.Editor  editor &#x3D; shared.edit();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89editor-putString"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">（2）editor.putString( )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89editor-commit-editor-apply"><span class="toc-number">6.3.2.3.</span> <span class="toc-text">（3）editor.commit()  editor.apply()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SharePreferences%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.SharePreferences读取与删除数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQLite%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8"><span class="toc-number">6.4.</span> <span class="toc-text">SQLite数据库存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">6.4.1.</span> <span class="toc-text">一、创建数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-SQLiteOpenHelper-%E5%B8%AE%E5%8A%A9%E7%B1%BB"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">1.  SQLiteOpenHelper 帮助类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%B0%E5%BB%BA-MyDatabaseHelper-%E7%BB%A7%E6%89%BF%E8%87%AASQLiteOpenHelper"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">2. 新建 MyDatabaseHelper 继承自SQLiteOpenHelper</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99oncreate"><span class="toc-number">6.4.1.2.1.</span> <span class="toc-text">重写oncreate()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">3. 创建数据库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">6.4.2.</span> <span class="toc-text">二、升级数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%96%B0%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AACategory%E8%A1%A8%E6%A0%BC"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">1.在初始化时新执行一条SQL语句，新建一个Category表格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E5%86%99onUpgrade"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">2.重写onUpgrade()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">6.4.2.3.</span> <span class="toc-text">3. 更新数据库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE-insert"><span class="toc-number">6.4.3.</span> <span class="toc-text">三、添加数据 insert()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%82%E6%95%B0"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">1.参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">6.4.3.2.</span> <span class="toc-text">2.添加数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE-updata"><span class="toc-number">6.4.4.</span> <span class="toc-text">四、更新数据 updata()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%82%E6%95%B0-1"><span class="toc-number">6.4.4.1.</span> <span class="toc-text">1.参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="toc-number">6.4.4.2.</span> <span class="toc-text">2.更新数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0Book%E8%A1%A8%E6%A0%BC%E4%B8%AD%EF%BC%8Cname%E4%B8%BA%E2%80%9CThe-Da-Vinci-Code%E2%80%9D-%E7%9A%84%E4%BB%B7%E6%A0%BC%E4%B8%BA10-99"><span class="toc-number">6.4.4.2.1.</span> <span class="toc-text">更新Book表格中，name为“The Da Vinci Code” 的价格为10.99</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-delete"><span class="toc-number">6.4.5.</span> <span class="toc-text">五、删除数据 delete()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%82%E6%95%B0-2"><span class="toc-number">6.4.5.1.</span> <span class="toc-text">1.参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">6.4.5.2.</span> <span class="toc-text">2.删除数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4Book%E8%A1%A8%E6%A0%BC%E4%B8%AD%EF%BC%8CPages%E5%A4%A7%E4%BA%8E500%E9%A1%B5%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">6.4.5.2.1.</span> <span class="toc-text">删除Book表格中，Pages大于500页的数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE-query"><span class="toc-number">6.4.6.</span> <span class="toc-text">六、查询数据 query()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%82%E6%95%B0-3"><span class="toc-number">6.4.6.1.</span> <span class="toc-text">1.参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">6.4.6.2.</span> <span class="toc-text">2.查询数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%BF%94%E5%9B%9E%E7%9A%84Cursor%E5%AF%B9%E8%B1%A1%E6%9D%A5%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8CmoveToFirst-%E5%B0%86%E6%B8%B8%E6%A0%87%E7%A7%BB%E5%8A%A8%E5%88%B0%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BD%8D%E7%BD%AE%EF%BC%9B-getColunmIndex-%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%80%E5%88%97%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">6.4.6.2.1.</span> <span class="toc-text">通过返回的Cursor对象来获取数据，moveToFirst():将游标移动到第一行位置； getColunmIndex():获取某一列的位置索引</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%B7%A8%E7%A8%8B%E5%BA%8F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E6%8E%A2%E7%A9%B6%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">第七章 跨程序共享数据——探究内容提供器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.</span> <span class="toc-text">内容提供器简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90"><span class="toc-number">7.2.</span> <span class="toc-text">运行时权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8D%B1%E9%99%A9%E6%9D%83%E9%99%90"><span class="toc-number">7.2.1.</span> <span class="toc-text">一、危险权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.2.2.</span> <span class="toc-text">二、运行时权限处理步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E6%8E%88%E6%9D%83"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">1. 第一步：判断用户是否已经授权</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89ContextCompat-checkSelfPermission-MainActivity-this-Manifest-permission-READ-CONTACTS"><span class="toc-number">7.2.2.1.1.</span> <span class="toc-text">（1）ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_CONTACTS)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8F%82%E6%95%B0%E4%B8%80%EF%BC%9AContext%EF%BC%9B-%E5%8F%82%E6%95%B0%E4%BA%8C%EF%BC%9A%E6%9D%83%E9%99%90%E5%90%8D"><span class="toc-number">7.2.2.1.2.</span> <span class="toc-text">（2）参数一：Context； 参数二：权限名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%B0%86%E5%85%B6%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8EPackageManager-PERMISSION-GRANTED%E5%81%9A%E6%AF%94%E8%BE%83%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%9B%B8%E7%AD%89%EF%BC%8C%E8%AF%B4%E6%98%8E%E7%94%A8%E6%88%B7%E5%B7%B2%E7%BB%8F%E6%8E%88%E6%9D%83%EF%BC%8C%E4%B8%8D%E7%9B%B8%E7%AD%89%E8%A1%A8%E7%A4%BA%E7%94%A8%E6%88%B7%E6%B2%A1%E6%9C%89%E6%8E%88%E6%9D%83%E3%80%82"><span class="toc-number">7.2.2.1.3.</span> <span class="toc-text">（3）将其返回值与PackageManager.PERMISSION_GRANTED做比较，如果相等，说明用户已经授权，不相等表示用户没有授权。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%9C%AA%E6%8E%88%E6%9D%83%EF%BC%8C%E7%94%B3%E8%AF%B7%E6%8E%88%E6%9D%83"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">2.第二步：如果未授权，申请授权</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89ActivityCompat-requestPermissions-MainActivity-this-new-String-Manifest-permission-READ-CONTACTS-1"><span class="toc-number">7.2.2.2.1.</span> <span class="toc-text">（1）ActivityCompat.requestPermissions(MainActivity.this, new String[]{ Manifest.permission. READ_CONTACTS }, 1);</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8F%82%E6%95%B0%E4%B8%80%EF%BC%9AActivity%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%9B-%E5%8F%82%E6%95%B0%E4%BA%8C%EF%BC%9A%E6%9D%83%E9%99%90%E5%90%8D%E7%9A%84String%E6%95%B0%E7%BB%84%EF%BC%9B"><span class="toc-number">7.2.2.2.2.</span> <span class="toc-text">（2）参数一：Activity的实例；    参数二：权限名的String数组；</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%B8%89%EF%BC%9A%E8%AF%B7%E6%B1%82%E7%A0%81%EF%BC%8C%E5%94%AF%E4%B8%80%E5%8D%B3%E5%8F%AF"><span class="toc-number">7.2.2.2.3.</span> <span class="toc-text">权限三：请求码，唯一即可</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%B0%83%E7%94%A8%E8%AF%A5%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E5%BC%B9%E5%87%BA%E4%B8%80%E4%B8%AA%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E7%9A%84%E5%AF%B9%E8%AF%9D%E6%A1%86%EF%BC%8C%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E5%90%8C%E6%84%8F%E6%88%96%E8%80%85%E6%8B%92%E7%BB%9D%E6%88%91%E4%BB%AC%E7%9A%84%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E3%80%82%E7%94%A8%E6%88%B7%E5%81%9A%E5%87%BA%E9%80%89%E6%8B%A9%E5%90%8E%E5%B0%86%E5%9B%9E%E8%B0%83%E5%88%B0onRequestPermissionsResult-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AF%B9%E6%8E%88%E6%9D%83%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E3%80%82"><span class="toc-number">7.2.2.2.4.</span> <span class="toc-text">（3）调用该方法后，系统会弹出一个权限申请的对话框，用户可以选择同意或者拒绝我们的权限申请。用户做出选择后将回调到onRequestPermissionsResult()方法，对授权结果进行处理。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83%E7%BB%93%E6%9E%9C"><span class="toc-number">7.2.2.3.</span> <span class="toc-text">3.第三步：处理用户授权结果</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-onRequestPermissionsResult-%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83%E7%9A%84%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E5%9C%A8grantResults%E5%8F%82%E6%95%B0%E5%BD%93%E4%B8%AD"><span class="toc-number">7.2.2.3.1.</span> <span class="toc-text">（1） onRequestPermissionsResult()方法中，用户授权的结果封装在grantResults参数当中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89grantResults-length-gt-0-amp-amp-grantResults-0-PackageManager-PERMISSION-GRANTED%E8%AF%B4%E6%98%8E%E7%94%A8%E6%88%B7%E5%85%81%E8%AE%B8%E6%8E%88%E6%9D%83"><span class="toc-number">7.2.2.3.2.</span> <span class="toc-text">（2）grantResults.length &gt; 0 &amp;&amp; grantResults[0] &#x3D;&#x3D; PackageManager.PERMISSION_GRANTED说明用户允许授权</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.</span> <span class="toc-text">访问其他程序中的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">7.3.1.</span> <span class="toc-text">一、应用程序间的数据共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%B1%BB"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">1.三个重要类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89ContentProvider%EF%BC%9A%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85%E3%80%82"><span class="toc-number">7.3.1.1.1.</span> <span class="toc-text">（1）ContentProvider：内容提供者。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89ContentResolver%EF%BC%9A%E5%86%85%E5%AE%B9%E8%AE%BF%E9%97%AE%E8%80%85"><span class="toc-number">7.3.1.1.2.</span> <span class="toc-text">（2）ContentResolver：内容访问者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Uri%EF%BC%9A"><span class="toc-number">7.3.1.1.3.</span> <span class="toc-text">（3）Uri：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8ContentResolver%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">2.使用ContentResolver访问共享数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ContentResolver%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84%E6%96%B9%E6%B3%95%E5%AF%B9ContentProvider%E4%B8%AD%E5%85%B1%E4%BA%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8CCRUD%E6%93%8D%E4%BD%9C"><span class="toc-number">7.3.1.2.1.</span> <span class="toc-text">ContentResolver提供了一系列的方法对ContentProvider中共享的数据进行CRUD操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9F%A5%E8%AF%A2-%E8%8E%B7%E5%8F%96-%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">3. 查询(获取)内容提供者中指定的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A6%96%E5%85%88%EF%BC%8C%E7%A1%AE%E5%AE%9A%E8%AE%BF%E9%97%AE%E7%9B%AE%E6%A0%87"><span class="toc-number">7.3.1.3.1.</span> <span class="toc-text">（1）首先，确定访问目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Uri-uri-Uri-parse-%E2%80%9Ccontent-com-example-app-provider-table1%E2%80%9D"><span class="toc-number">7.3.1.3.2.</span> <span class="toc-text">Uri uri &#x3D; Uri.parse(“content:&#x2F;&#x2F;com.example.app.provider&#x2F;table1”);</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Cursor-cursor-getContentResolver-query-uri-projection-selection-selectionArgs-sortOrder"><span class="toc-number">7.3.1.3.3.</span> <span class="toc-text">Cursor  cursor &#x3D; getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder);</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9C%80%E5%90%8E%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%EF%BC%9A%E5%AF%B9%E8%BF%94%E5%9B%9E%E7%9A%84Cursor%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%EF%BC%8C%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8Ecursor%E5%AF%B9%E8%B1%A1%E4%B8%AD%E9%80%90%E4%B8%AA%E8%AF%BB%E5%8F%96%E5%87%BA%E6%9D%A5%E3%80%82"><span class="toc-number">7.3.1.3.4.</span> <span class="toc-text">（3）最后，结果处理：对返回的Cursor对象进行处理，将数据从cursor对象中逐个读取出来。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%90%91%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85%E5%85%B1%E4%BA%AB%E7%9A%84table1%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.1.4.</span> <span class="toc-text">4. 向内容提供者共享的table1中添加数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E5%BE%85%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%84%E8%A3%85%E5%88%B0ContentValues%EF%BC%8C%E7%84%B6%E5%90%8E%E8%B0%83%E7%94%A8ContentResolver%E7%B1%BBinsert-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B0%86uri%E5%92%8CContentValues%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5%E3%80%82"><span class="toc-number">7.3.1.4.1.</span> <span class="toc-text">将待添加的数据组装到ContentValues，然后调用ContentResolver类insert()方法，将uri和ContentValues作为参数传入。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%90%91%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85%E5%85%B1%E4%BA%AB%E7%9A%84table1%E4%B8%AD%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.1.5.</span> <span class="toc-text">5. 向内容提供者共享的table1中更新数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%90%91%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85%E5%85%B1%E4%BA%AB%E7%9A%84table1%E4%B8%AD%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.1.6.</span> <span class="toc-text">6.向内容提供者共享的table1中删除数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8-%EF%BC%88P260%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">创建自己的内容提供器*（P260）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%87%8D%E5%86%99%E5%85%B6%E4%B8%AD6%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.1.</span> <span class="toc-text">一、重写其中6个抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-public-boolean-onCreate-%EF%BC%9AContentProvider%E5%88%9B%E5%BB%BA%E6%97%B6%E8%B0%83%E7%94%A8%E3%80%82"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">1.public boolean onCreate()：ContentProvider创建时调用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-public-int-delete-%E2%80%A6-%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%BC%A0%E5%85%A5%E7%9A%84Uri%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%9D%A1%E4%BB%B6%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">7.4.1.2.</span> <span class="toc-text">2. public int delete(…)：根据传入的Uri删除指定条件下的数据。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-public-Uri-insert-%E2%80%A6-%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%BC%A0%E5%85%A5%E7%9A%84Uri%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">7.4.1.3.</span> <span class="toc-text">3.public Uri insert(…)：根据传入的Uri插入数据。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-public-Cursor-query-%E2%80%A6-%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%BC%A0%E5%85%A5%E7%9A%84Uri%E6%9F%A5%E8%AF%A2%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">7.4.1.4.</span> <span class="toc-text">4. public Cursor query(…)：根据传入的Uri查询指定的数据。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-public-int-update-%E2%80%A6-%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%BC%A0%E5%85%A5%E7%9A%84Uri%E6%9B%B4%E6%96%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">7.4.1.5.</span> <span class="toc-text">5.public int update(…)：根据传入的Uri更新指定的数据。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-getType"><span class="toc-number">7.4.1.6.</span> <span class="toc-text">6.getType()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Uri%E5%8F%82%E6%95%B0%EF%BC%9A%E7%A1%AE%E5%AE%9A%E8%B0%83%E7%94%A8%E6%96%B9%E5%B8%8C%E6%9C%9B%E8%AE%BF%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%96%E8%A1%A8"><span class="toc-number">7.4.2.</span> <span class="toc-text">二、Uri参数：确定调用方希望访问的数据或表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%EF%BC%9Acontent-com-example-app-privder-table1"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">表：content:&#x2F;&#x2F;com.example.app.privder&#x2F;table1&#x2F;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%EF%BC%9Acontent-com-example-app-privder-table1"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">数据：content:&#x2F;&#x2F;com.example.app.privder&#x2F;table1&#x2F;#</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%80%9A%E8%BF%87UriMatcher%E7%B1%BB%E8%A7%A3%E6%9E%90Uri%E5%8F%82%E6%95%B0%EF%BC%8C%E7%A1%AE%E5%AE%9A%E8%B0%83%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%96%E8%A1%A8"><span class="toc-number">7.4.3.</span> <span class="toc-text">三、通过UriMatcher类解析Uri参数，确定调用的数据或表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E5%B0%86%E9%9C%80%E8%A6%81%E5%85%B1%E4%BA%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%96%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%86%85%E5%AE%B9URI%E7%94%A8addURI-%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8%E4%B8%AD"><span class="toc-number">7.4.3.1.</span> <span class="toc-text">首先将需要共享的数据或数据表的内容URI用addURI()方法添加到自定义的内容提供器中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%84%B6%E5%90%8E%EF%BC%8C%E5%9C%A8query-%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8UriMatcher%E7%9A%84match%E6%96%B9%E6%B3%95%E5%AF%B9%E4%BC%A0%E5%85%A5%E7%9A%84Uri%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%9F%90%E4%B8%AA%E8%83%BD%E5%8C%B9%E9%85%8D%E8%BF%99%E4%B8%AAUri%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%88%A9%E7%94%A8%E8%BF%99%E4%B8%AA%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%88%A4%E6%96%AD%E5%87%BA%E8%B0%83%E7%94%A8%E6%96%B9%E6%9C%9F%E6%9C%9B%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AF%E5%93%AA%E5%BC%A0%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%86%E3%80%82"><span class="toc-number">7.4.3.2.</span> <span class="toc-text">然后，在query()方法中调用UriMatcher的match方法对传入的Uri对象进行解析，返回某个能匹配这个Uri对象的自定义代码，利用这个代码，自定义的内容提供器就可以判断出调用方期望访问的是哪张表中的数据了。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81getType-%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.4.</span> <span class="toc-text">四、getType()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E8%A7%82%E5%AF%9F%E8%80%85ContentObersver"><span class="toc-number">7.5.</span> <span class="toc-text">内容观察者ContentObersver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81ContentObserver%EF%BC%88%E5%86%85%E5%AE%B9%E8%A7%82%E5%AF%9F%E8%80%85%EF%BC%89"><span class="toc-number">7.5.1.</span> <span class="toc-text">一、ContentObserver（内容观察者）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%9B%AE%E7%9A%84%E6%98%AF%E8%A7%82%E5%AF%9F-%E6%8D%95%E6%8D%89-%E7%89%B9%E5%AE%9AUri%E5%BC%95%E8%B5%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E7%BB%A7%E8%80%8C%E5%81%9A%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%BA%94%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8C%E5%AE%83%E7%B1%BB%E4%BC%BC%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%AD%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8-Trigger-%EF%BC%8C%E5%BD%93ContentObserver%E6%89%80%E8%A7%82%E5%AF%9F%E7%9A%84Uri%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E6%97%B6%EF%BC%8C%E4%BE%BF%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%AE%83%E3%80%82"><span class="toc-number">7.5.1.1.</span> <span class="toc-text">1.目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%A6%E5%8F%91%E5%99%A8%E5%88%86%E4%B8%BA%E8%A1%A8%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E8%A1%8C%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%8C%E7%9B%B8%E5%BA%94%E5%9C%B0ContentObserver%E4%B9%9F%E5%88%86%E4%B8%BA%E2%80%9C%E8%A1%A8%E2%80%9DContentObserver%E3%80%81%E2%80%9C%E8%A1%8C%E2%80%9DContentObserver%EF%BC%8C%E5%BD%93%E7%84%B6%E8%BF%99%E6%98%AF%E4%B8%8E%E5%AE%83%E6%89%80%E7%9B%91%E5%90%AC%E7%9A%84Uri-MIME-Type%E6%9C%89%E5%85%B3%E7%9A%84%E3%80%82"><span class="toc-number">7.5.1.2.</span> <span class="toc-text">2.触发器分为表触发器、行触发器，相应地ContentObserver也分为“表”ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri MIME Type有关的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BD%93A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E6%97%B6%EF%BC%8CA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8notifyChange-%E6%96%B9%E6%B3%95%E5%90%91%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%EF%BC%8C%E7%84%B6%E5%90%8EC%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%A7%82%E5%AF%9F%E5%88%B0%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E6%97%B6%EF%BC%8C%E5%B0%B1%E4%BC%9A%E8%A7%A6%E5%8F%91ContentObserver%E7%9A%84onChange-%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">7.5.1.3.</span> <span class="toc-text">3.当A应用程序的数据发生变化时，A应用程序调用notifyChange()方法向消息中心发送消息，然后C应用程序观察到数据变化时，就会触发ContentObserver的onChange()方法。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ContentObserver%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.5.2.</span> <span class="toc-text">二、ContentObserver的几个常用的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-public-void-ContentObserver-Handler-handler"><span class="toc-number">7.5.2.1.</span> <span class="toc-text">1.构造方法 public void ContentObserver(Handler handler)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-void-onChange-boolean-selfChange"><span class="toc-number">7.5.2.2.</span> <span class="toc-text">2.void onChange(boolean selfChange)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E4%B8%B0%E5%AF%8C%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F%E2%80%94%E2%80%94%E8%BF%90%E7%94%A8%E6%89%8B%E6%9C%BA%E5%A4%9A%E5%AA%92%E4%BD%93"><span class="toc-number">8.</span> <span class="toc-text">第八章 丰富你的程序——运用手机多媒体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%92%AD%E6%94%BE%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6"><span class="toc-number">8.1.</span> <span class="toc-text">播放多媒体文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91"><span class="toc-number">8.1.1.</span> <span class="toc-text">一、播放音频</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-MediaPlayer%E7%B1%BB"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">1.MediaPlayer类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">2.工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAMediaPlayer%E5%AF%B9%E8%B1%A1%EF%BC%9B"><span class="toc-number">8.1.1.2.1.</span> <span class="toc-text">创建MediaPlayer对象；</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%EF%BC%9AsetDataSource"><span class="toc-number">8.1.1.2.2.</span> <span class="toc-text">初始化设置音频文件路径：setDataSource()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BFMediaPlayer%E8%BF%9B%E5%85%A5%E5%87%86%E5%A4%87%E7%8A%B6%E6%80%81%EF%BC%9Apepare"><span class="toc-number">8.1.1.2.3.</span> <span class="toc-text">使MediaPlayer进入准备状态：pepare()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91%EF%BC%9Astart"><span class="toc-number">8.1.1.2.4.</span> <span class="toc-text">开始播放音频：start()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9A%82%E5%81%9C%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91%EF%BC%9Apause"><span class="toc-number">8.1.1.2.5.</span> <span class="toc-text">暂停播放音频：pause()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91%EF%BC%9Areset-setDataSource-pepare"><span class="toc-number">8.1.1.2.6.</span> <span class="toc-text">停止播放音频：reset(), setDataSource(), pepare()</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%9C%8B%E7%9C%8B%E7%B2%BE%E5%BD%A9%E7%9A%84%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF"><span class="toc-number">9.</span> <span class="toc-text">第九章 看看精彩的技术——使用网络技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">9.1.</span> <span class="toc-text">Android常见的网络通信方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.1.1.</span> <span class="toc-text">一、基于TCP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E4%BA%8EHttp%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.1.2.</span> <span class="toc-text">二、基于Http协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-WebKit-%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C"><span class="toc-number">9.1.3.</span> <span class="toc-text">三、直接使用 WebKit 访问网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6"><span class="toc-number">9.1.4.</span> <span class="toc-text">四、使用网络通信框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">9.2.</span> <span class="toc-text">网络编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.2.1.</span> <span class="toc-text">一、通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1%E5%BF%85%E9%A1%BB%E9%81%B5%E5%BE%AA%E5%AE%88%E4%B8%80%E4%BA%9B%E7%BA%A6%E5%AE%9A%E3%80%82%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0%E5%8C%85%E6%8B%AC%EF%BC%9A"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">1.计算机网络实现通信必须遵循守一些约定。核心要素包括：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%AF%AD%E4%B9%89%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%86%B3%E5%AE%9A%E5%8F%8C%E6%96%B9%E5%AF%B9%E8%AF%9D%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8D%B3%E8%A7%84%E5%AE%9A%E9%80%9A%E4%BF%A1%E5%8F%8C%E6%96%B9%E8%A6%81%E5%8F%91%E5%87%BA%E4%BD%95%E7%A7%8D%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF%E3%80%81%E5%AE%8C%E6%88%90%E4%BD%95%E7%A7%8D%E5%8A%A8%E4%BD%9C%E5%8F%8A%E4%BD%9C%E5%87%BA%E4%BD%95%E7%A7%8D%E5%BA%94%E7%AD%94%EF%BC%9B"><span class="toc-number">9.2.1.1.1.</span> <span class="toc-text">（1）语义：用于决定双方对话的类型，即规定通信双方要发出何种控制信息、完成何种动作及作出何种应答；</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%AF%AD%E6%B3%95%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%86%B3%E5%AE%9A%E5%8F%8C%E6%96%B9%E5%AF%B9%E8%AF%9D%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%8C%E5%8D%B3%E8%A7%84%E5%AE%9A%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E6%A0%BC%E5%BC%8F%EF%BC%9B"><span class="toc-number">9.2.1.1.2.</span> <span class="toc-text">（2）语法：用于决定双方对话的格式，即规定数据与控制信息的结构和格式；</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%97%B6%E5%BA%8F%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%86%B3%E5%AE%9A%E9%80%9A%E4%BF%A1%E5%8F%8C%E6%96%B9%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%EF%BC%8C%E5%8D%B3%E7%A1%AE%E5%AE%9A%E9%80%9A%E4%BF%A1%E7%8A%B6%E6%80%81%E7%9A%84%E5%8F%98%E5%8C%96%E5%92%8C%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%A6%82%E9%80%9A%E4%BF%A1%E5%8F%8C%E5%8F%91%E7%9A%84%E5%BA%94%E7%AD%94%E5%85%B3%E7%B3%BB%E3%80%82"><span class="toc-number">9.2.1.1.3.</span> <span class="toc-text">（3）时序：用于决定通信双方的实现顺序，即确定通信状态的变化和过程，如通信双发的应答关系。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.2.1.2.</span> <span class="toc-text">2.常见的通信协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81TCP-IP-%E5%8D%8F%E8%AE%AE%E9%9B%86"><span class="toc-number">9.2.2.</span> <span class="toc-text">二、TCP&#x2F;IP 协议集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A5QQ%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%BA%E4%BE%8B"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">1.以QQ数据传输为例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TCP%E4%B8%8EUDP%EF%BC%8C%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">9.2.2.2.</span> <span class="toc-text">2.TCP与UDP，传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81TCP%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%EF%BC%88%E5%A6%82%E6%89%93%E7%94%B5%E8%AF%9D%E8%A6%81%E5%85%88%E6%8B%A8%E5%8F%B7%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%89-UDP%E6%98%AF%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%8C%E5%8D%B3%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E4%B9%8B%E5%89%8D%E4%B8%8D%E9%9C%80%E8%A6%81%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E3%80%82"><span class="toc-number">9.2.2.2.1.</span> <span class="toc-text">1、TCP面向连接（如打电话要先拨号建立连接）; UDP是无连接的，即发送数据之前不需要建立连接。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81TCP%E6%8F%90%E4%BE%9B%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E9%80%9A%E8%BF%87TCP%E8%BF%9E%E6%8E%A5%E4%BC%A0%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%97%A0%E5%B7%AE%E9%94%99%EF%BC%8C%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%8C%E4%B8%8D%E9%87%8D%E5%A4%8D%EF%BC%8C%E4%B8%94%E6%8C%89%E5%BA%8F%E5%88%B0%E8%BE%BE-UDP%E5%B0%BD%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E4%BA%A4%E4%BB%98%EF%BC%8C%E5%8D%B3%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BA%A4%E4%BB%98%E3%80%82"><span class="toc-number">9.2.2.2.2.</span> <span class="toc-text">2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保证可靠交付。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81TCP%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AFTCP%E6%8A%8A%E6%95%B0%E6%8D%AE%E7%9C%8B%E6%88%90%E4%B8%80%E8%BF%9E%E4%B8%B2%E6%97%A0%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%97%E8%8A%82%E6%B5%81-UDP%E6%98%AF%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87%E7%9A%84UDP%E6%B2%A1%E6%9C%89%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%8C%E5%9B%A0%E6%AD%A4%E7%BD%91%E7%BB%9C%E5%87%BA%E7%8E%B0%E6%8B%A5%E5%A1%9E%E4%B8%8D%E4%BC%9A%E4%BD%BF%E6%BA%90%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%8F%91%E9%80%81%E9%80%9F%E7%8E%87%E9%99%8D%E4%BD%8E%EF%BC%88%E5%AF%B9%E5%AE%9E%E6%97%B6%E5%BA%94%E7%94%A8%E5%BE%88%E6%9C%89%E7%94%A8%EF%BC%8C%E5%A6%82IP%E7%94%B5%E8%AF%9D%EF%BC%8C%E5%AE%9E%E6%97%B6%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE%E7%AD%89%EF%BC%89%E3%80%82"><span class="toc-number">9.2.2.2.3.</span> <span class="toc-text">3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%AF%8F%E4%B8%80%E6%9D%A1TCP%E8%BF%9E%E6%8E%A5%E5%8F%AA%E8%83%BD%E6%98%AF%E7%82%B9%E5%88%B0%E7%82%B9%E7%9A%84-UDP%E6%94%AF%E6%8C%81%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%92%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E4%BA%A4%E4%BA%92%E9%80%9A%E4%BF%A1%E3%80%82"><span class="toc-number">9.2.2.2.4.</span> <span class="toc-text">4、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81TCP%E9%A6%96%E9%83%A8%E5%BC%80%E9%94%8020%E5%AD%97%E8%8A%82-UDP%E7%9A%84%E9%A6%96%E9%83%A8%E5%BC%80%E9%94%80%E5%B0%8F%EF%BC%8C%E5%8F%AA%E6%9C%898%E4%B8%AA%E5%AD%97%E8%8A%82%E3%80%82"><span class="toc-number">9.2.2.2.5.</span> <span class="toc-text">5、TCP首部开销20字节;UDP的首部开销小，只有8个字节。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81TCP%E7%9A%84%E9%80%BB%E8%BE%91%E9%80%9A%E4%BF%A1%E4%BF%A1%E9%81%93%E6%98%AF%E5%85%A8%E5%8F%8C%E5%B7%A5%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BF%A1%E9%81%93%EF%BC%8CUDP%E5%88%99%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BF%A1%E9%81%93%E3%80%82"><span class="toc-number">9.2.2.2.6.</span> <span class="toc-text">6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-HTTP%EF%BC%8C%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">9.2.2.3.</span> <span class="toc-text">3.HTTP，应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Http%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%EF%BC%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%EF%BC%8C%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%B8%B8%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">9.2.2.3.1.</span> <span class="toc-text">（1）Http是一个基于请求与响应，无状态的，应用层的协议，常基于TCP协议传输数据。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%B9%89Web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8EWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-number">9.2.2.3.2.</span> <span class="toc-text">（2）用于定义Web浏览器与Web服务器之间交换数据的过程。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%9B%9B%E4%B8%AA%E5%9F%BA%E4%BA%8E%EF%BC%9A%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E3%80%81%E6%97%A0%E7%8A%B6%E6%80%81%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82%E3%80%81TCP"><span class="toc-number">9.2.2.3.3.</span> <span class="toc-text">（3）四个基于：请求与响应、无状态、应用层、TCP</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">9.3.</span> <span class="toc-text">基于TCP协议的网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81IP%E5%9C%B0%E5%9D%80%E3%80%81%E7%AB%AF%E5%8F%A3"><span class="toc-number">9.3.1.</span> <span class="toc-text">一、IP地址、端口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-IP%E5%9C%B0%E5%9D%80"><span class="toc-number">9.3.1.1.</span> <span class="toc-text">1.IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E7%94%A8%E6%9D%A5%E6%A0%87%E8%AE%B0%E5%94%AF%E4%B8%80%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%8D%E7%BD%AE%EF%BC%8CIP%E5%9C%B0%E5%9D%80%E6%98%AF32%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9A192-168-0-0-1%E3%80%82"><span class="toc-number">9.3.1.1.1.</span> <span class="toc-text">IP地址用来标记唯一的计算机位置，IP地址是32为二进制，例如：192.168.0.0.1。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AB%AF%E5%8F%A3"><span class="toc-number">9.3.1.2.</span> <span class="toc-text">2.端口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%94%A8%E6%9D%A5%E6%A0%87%E8%AE%B0%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E3%80%82"><span class="toc-number">9.3.1.2.1.</span> <span class="toc-text">端口号用来标记一台电脑中的不同应用程序。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%8C%83%E5%9B%B4%E6%98%AF0-65535%EF%BC%8C%E5%85%B6%E4%B8%AD0-1023%E6%98%AF%E7%B3%BB%E7%BB%9F%E4%B8%93%E7%94%A8"><span class="toc-number">9.3.1.2.2.</span> <span class="toc-text">端口号范围是0-65535，其中0~1023是系统专用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Socket%E7%BC%96%E7%A8%8B"><span class="toc-number">9.3.2.</span> <span class="toc-text">二、Socket编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EHttp%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">9.4.</span> <span class="toc-text">基于Http协议的网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81HTTP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">9.4.1.</span> <span class="toc-text">一、HTTP协议工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%9A"><span class="toc-number">9.4.1.1.</span> <span class="toc-text">1.建立连接：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%9A"><span class="toc-number">9.4.1.2.</span> <span class="toc-text">2.发送请求：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%93%8D%E5%BA%94%E8%AF%B7%E6%B1%82%EF%BC%9A"><span class="toc-number">9.4.1.3.</span> <span class="toc-text">3.响应请求：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8E%A5%E6%94%B6%E5%93%8D%E5%BA%94%EF%BC%9A"><span class="toc-number">9.4.1.4.</span> <span class="toc-text">4.接收响应：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">9.4.2.</span> <span class="toc-text">二、HTTP请求报文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E6%B1%82%E8%A1%8C"><span class="toc-number">9.4.2.1.</span> <span class="toc-text">1.请求行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.2.1.1.</span> <span class="toc-text">（1）请求方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80"><span class="toc-number">9.4.2.1.2.</span> <span class="toc-text">（2）请求地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%89%88%E6%9C%AC%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.4.2.1.3.</span> <span class="toc-text">（3）版本协议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8"><span class="toc-number">9.4.2.2.</span> <span class="toc-text">2.请求头部</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%94%B1%E9%94%AE%E5%80%BC%E5%AF%B9%E7%BB%84%E6%88%90%EF%BC%8C%E6%AF%8F%E8%A1%8C%E4%B8%80%E5%AF%B9%EF%BC%8C%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%80%BC%E7%94%A8%E8%8B%B1%E6%96%87%E5%86%92%E5%8F%B7%E2%80%9C-%E2%80%9D%E5%88%86%E9%9A%94%E3%80%82"><span class="toc-number">9.4.2.2.1.</span> <span class="toc-text">（1）由键值对组成，每行一对，关键字和值用英文冒号“:”分隔。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B3%E4%BA%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%85%B8%E5%9E%8B%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%9C%89%EF%BC%9A"><span class="toc-number">9.4.2.2.2.</span> <span class="toc-text">（2）请求头部通知服务器关于客户端请求的信息，典型的请求头有：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E7%9A%84%E6%9C%80%E5%90%8E%E4%BC%9A%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E8%A1%8C%EF%BC%8C%E8%A1%A8%E7%A4%BA%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9D%9F%EF%BC%8C%E6%8E%A5%E4%B8%8B%E6%9D%A5%E4%B8%BA%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%99%E4%B8%80%E8%A1%8C%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%8C%E5%BF%85%E4%B8%8D%E5%8F%AF%E5%B0%91%E3%80%82"><span class="toc-number">9.4.2.2.3.</span> <span class="toc-text">（3）请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE"><span class="toc-number">9.4.2.3.</span> <span class="toc-text">3.请求数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8F%AF%E9%80%89%E9%83%A8%E5%88%86%EF%BC%8C%E6%AF%94%E5%A6%82GET%E8%AF%B7%E6%B1%82%E5%B0%B1%E6%B2%A1%E6%9C%89%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">9.4.2.3.1.</span> <span class="toc-text">（1）可选部分，比如GET请求就没有请求数据。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89HTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%8C%85%E6%8B%ACGET-POST-PUT-HEAD-DELETE-TRACE-CONNECT-OPTIONS%E7%AD%89%EF%BC%8C%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%BB%E8%A6%81%E6%9C%89-get-%E5%92%8C-post%E4%B8%A4%E7%A7%8D"><span class="toc-number">9.4.2.3.2.</span> <span class="toc-text">（2）HTTP的请求方式包括GET,POST, PUT ,HEAD, DELETE, TRACE, CONNECT, OPTIONS等，最常用的发送请求的方式主要有 get 和 post两种</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-GET%E4%B8%8EPOST"><span class="toc-number">9.4.2.4.</span> <span class="toc-text">4. GET与POST</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89get"><span class="toc-number">9.4.2.4.1.</span> <span class="toc-text">（1）get</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89post"><span class="toc-number">9.4.2.4.2.</span> <span class="toc-text">（2）post</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%B3%A8%E6%84%8F"><span class="toc-number">9.4.2.4.3.</span> <span class="toc-text">(3)注意</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%85%B6%E4%BB%96%E5%8C%BA%E5%88%AB"><span class="toc-number">9.4.2.4.4.</span> <span class="toc-text">(4)其他区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">9.4.3.</span> <span class="toc-text">三、HTTP响应报文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%8A%B6%E6%80%81%E8%A1%8C"><span class="toc-number">9.4.3.1.</span> <span class="toc-text">1.状态行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%94%B13%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%8C%E5%88%86%E5%88%AB%E4%B8%BA%EF%BC%9A%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%EF%BC%8C%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%8C%E7%8A%B6%E6%80%81%E7%A0%81%E6%8F%8F%E8%BF%B0%EF%BC%89"><span class="toc-number">9.4.3.1.1.</span> <span class="toc-text">（1）由3部分组成，分别为：协议版本，状态码，状态码描述）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%85%B6%E4%B8%AD%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%E4%B8%8E%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E4%B8%80%E8%87%B4%EF%BC%8C%E7%8A%B6%E6%80%81%E7%A0%81%E6%8F%8F%E8%BF%B0%E6%98%AF%E5%AF%B9%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0"><span class="toc-number">9.4.3.1.2.</span> <span class="toc-text">（2）其中协议版本与请求报文一致，状态码描述是对状态码的简单描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">9.4.3.1.3.</span> <span class="toc-text">（3）常见状态码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%93%8D%E5%BA%94%E5%A4%B4%E9%83%A8"><span class="toc-number">9.4.3.1.4.</span> <span class="toc-text">2.响应头部</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">9.4.4.</span> <span class="toc-text">四、基于HTTP的网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87URL%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90"><span class="toc-number">9.4.4.1.</span> <span class="toc-text">1.通过URL获取网络资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89URL%EF%BC%88Unifrom-Resource-Locator%EF%BC%89%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E5%99%A8"><span class="toc-number">9.4.4.1.1.</span> <span class="toc-text">（1）URL（Unifrom Resource Locator）统一资源定位器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">9.4.4.1.2.</span> <span class="toc-text">（2）资源获取过程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-URL%E7%B1%BB%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.4.1.3.</span> <span class="toc-text">(3)URL类常用的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%B9%B6%E6%98%BE%E7%A4%BA"><span class="toc-number">9.4.4.1.4.</span> <span class="toc-text">（4）案例：图片资源获取并显示</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87URLConnection%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90"><span class="toc-number">9.4.4.2.</span> <span class="toc-text">2.通过URLConnection获取网络资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89URL-%E5%AF%B9%E8%B1%A1%E6%8F%90%E4%BE%9B%E4%BA%86openConnection-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAURLConnection%E5%AF%B9%E8%B1%A1%E3%80%82%E9%80%9A%E8%BF%87URLConnection%EF%BC%8C%E5%BB%BA%E7%AB%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8CURL%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%80%9F%E5%8A%A9%E4%BA%8E%E8%AF%A5URLConnection%E6%A1%A5%E6%A2%81%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%90%91URL%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E8%AF%BB%E5%8F%96URL%E8%B5%84%E6%BA%90%E3%80%82"><span class="toc-number">9.4.4.2.1.</span> <span class="toc-text">（1）URL 对象提供了openConnection()方法返回一个URLConnection对象。通过URLConnection，建立应用程序和URL之间的连接，借助于该URLConnection桥梁，可以向URL发送请求，读取URL资源。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.4.4.2.2.</span> <span class="toc-text">（2）实现步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89URLConnection%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.4.2.3.</span> <span class="toc-text">（3）URLConnection常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8HttpURLConnection%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90"><span class="toc-number">9.4.4.3.</span> <span class="toc-text">3.使用HttpURLConnection获取网络资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89HttpURLConnection%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.4.3.1.</span> <span class="toc-text">（1）HttpURLConnection常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89GET%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%8F%82%E6%95%B0%E6%94%BE%E5%9C%A8url%E5%90%8E%E4%B8%80%E8%B5%B7%E4%BC%A0%E9%80%92"><span class="toc-number">9.4.4.3.2.</span> <span class="toc-text">（2）GET方式：将参数放在url后一起传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89POST%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.4.3.3.</span> <span class="toc-text">（2）POST方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8WebView%E6%8E%A7%E4%BB%B6"><span class="toc-number">9.5.</span> <span class="toc-text">使用WebView控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Android%E5%86%85%E7%BD%AEwebkit%E5%86%85%E6%A0%B8%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%8C%E8%80%8CWebView%E5%88%99%E6%98%AF%E5%9C%A8%E8%BF%99%E4%B8%AA%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85%E5%90%8E%E7%9A%84%E4%B8%80%E4%B8%AA-%E6%8E%A7%E4%BB%B6"><span class="toc-number">9.5.1.</span> <span class="toc-text">1.Android内置webkit内核的高性能浏览器，而WebView则是在这个基础上进行封装后的一个 控件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-WebView-%E7%BD%91%E9%A1%B5%E8%A7%86%E5%9B%BE-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.5.2.</span> <span class="toc-text">2.WebView(网页视图)常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%A8%E5%BA%94%E7%94%A8%E4%B8%AD%E5%B5%8C%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B1%95%E7%A4%BA%E7%BD%91%E9%A1%B5%EF%BC%8C%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90"><span class="toc-number">9.5.3.</span> <span class="toc-text">3.在应用中嵌入浏览器展示网页，并进行解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8OKHttp%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90"><span class="toc-number">9.6.</span> <span class="toc-text">使用OKHttp获取网络资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-GET%E8%AF%B7%E6%B1%82"><span class="toc-number">9.6.1.</span> <span class="toc-text">1.GET请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="toc-number">9.6.1.1.</span> <span class="toc-text">（1）添加依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#implementation-%E2%80%98com-squareup-okhttp3-okhttp-3-10-0%E2%80%99"><span class="toc-number">9.6.1.2.</span> <span class="toc-text">implementation ‘com.squareup.okhttp3:okhttp:3.10.0’</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A3%B0%E6%98%8E%E8%AE%BF%E9%97%AEInternet%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">9.6.1.3.</span> <span class="toc-text">（2）声明访问Internet的权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-9"><span class="toc-number">9.6.1.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%88%9B%E5%BB%BA-OkHttpClient%E5%AE%9E%E4%BE%8B"><span class="toc-number">9.6.1.5.</span> <span class="toc-text">（3）创建 OkHttpClient实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%9E%84%E9%80%A0Request%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-number">9.6.1.6.</span> <span class="toc-text">（4）构造Request对象。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%9E%84%E5%BB%BACall%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.6.1.7.</span> <span class="toc-text">（5）构建Call对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%B9%B6%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">9.6.1.8.</span> <span class="toc-text">（6） 发送请求并获取服务器返回的数据。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5Get%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">9.6.1.8.1.</span> <span class="toc-text">同步Get方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Call-execute-%E6%96%B9%E6%B3%95%E6%8F%90%E4%BA%A4%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%94%BE%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">9.6.1.8.2.</span> <span class="toc-text">通过Call.execute()方法提交请求，放在子线程中执行，或者使用异步任务的方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5Get%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">9.6.1.8.3.</span> <span class="toc-text">异步Get方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Call-enqueue-Callback-%E6%96%B9%E6%B3%95%E6%9D%A5%E6%8F%90%E4%BA%A4%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">9.6.1.8.4.</span> <span class="toc-text">通过Call.enqueue(Callback)方法来提交异步请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-POST%E8%AF%B7%E6%B1%82"><span class="toc-number">9.6.2.</span> <span class="toc-text">2.POST请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%8E%E4%B8%8A%E8%BF%B0GET%E8%AF%B7%E6%B1%82%E7%9B%B8%E6%AF%94%EF%BC%8C%E9%9C%80%E8%A6%81%E5%85%88%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AARequestBody%E5%AF%B9%E8%B1%A1%E7%94%A8%E6%9D%A5%E5%AD%98%E6%94%BE%E5%BE%85%E6%8F%90%E4%BA%A4%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9A"><span class="toc-number">9.6.2.1.</span> <span class="toc-text">（1）与上述GET请求相比，需要先构造一个RequestBody对象用来存放待提交的数据，例如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%84%B6%E5%90%8E%E5%9C%A8Request-Builder%E4%B8%AD%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%8Bpost-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B9%B6%E5%B0%86RequestBody%E5%AF%B9%E8%B1%A1%E4%BC%A0%E5%85%A5%EF%BC%9A"><span class="toc-number">9.6.2.2.</span> <span class="toc-text">（2）然后在Request.Builder中调用一下post()方法，并将RequestBody对象传入：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B"><span class="toc-number">9.6.2.3.</span> <span class="toc-text">（3）登录案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON"><span class="toc-number">9.7.</span> <span class="toc-text">JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81JSON%E6%95%B0%E6%8D%AE"><span class="toc-number">9.7.1.</span> <span class="toc-text">一、JSON数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JSON-JavaScript-Object-Notation-%E6%98%AFJavaScript%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AD%90%E9%9B%86%EF%BC%8C%E6%98%AF%E4%B8%80%E7%A7%8D%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%A0%BC%E5%BC%8F%E3%80%82"><span class="toc-number">9.7.1.1.</span> <span class="toc-text">1.JSON(JavaScript Object Notation) 是JavaScript的一个子集，是一种轻量级的数据交换格式。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JSON%E7%9A%84%E7%BB%93%E6%9E%84%E5%9F%BA%E4%BA%8E%E4%BB%A5%E4%B8%8B%E4%B8%A4%E7%82%B9%EF%BC%9A"><span class="toc-number">9.7.1.2.</span> <span class="toc-text">2.JSON的结构基于以下两点：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E2%80%9D%E5%90%8D%E7%A7%B0-%E5%80%BC%E2%80%9D%E5%AF%B9%E7%9A%84%E9%9B%86%E5%90%88-%EF%BC%9A%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E4%B8%AD%EF%BC%8C%E5%AE%83%E8%A2%AB%E7%90%86%E8%A7%A3%E4%B8%BA%E5%AF%B9%E8%B1%A1-object-%EF%BC%8C%E8%AE%B0%E5%BD%95-record-%EF%BC%8C%E7%BB%93%E6%9E%84-struct-%EF%BC%8C%E5%AD%97%E5%85%B8-dictionary-%EF%BC%8C%E5%93%88%E5%B8%8C%E8%A1%A8-hash-table-%EF%BC%8C%E9%94%AE%E5%88%97%E8%A1%A8-keyed-list-%E7%AD%89%E3%80%82"><span class="toc-number">9.7.1.2.1.</span> <span class="toc-text">（1）”名称&#x2F;值”对的集合 ：不同语言中，它被理解为对象(object)，记录(record)，结构(struct)，字典(dictionary)，哈希表(hash table)，键列表(keyed list)等。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%80%BC%E7%9A%84%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A-%E5%A4%9A%E6%95%B0%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%A2%AB%E7%90%86%E8%A7%A3%E4%B8%BA%E6%95%B0%E7%BB%84-array-%E3%80%82"><span class="toc-number">9.7.1.2.2.</span> <span class="toc-text">（2）值的有序列表： 多数语言中被理解为数组(array)。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-JSON%E7%9A%84%E5%BD%A2%E5%BC%8F%E4%B8%BB%E8%A6%81%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%B8%A4%E7%A7%8D%EF%BC%9A"><span class="toc-number">9.7.1.3.</span> <span class="toc-text">3.JSON的形式主要有以下两种：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.7.1.3.1.</span> <span class="toc-text">（1）对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E7%BB%84"><span class="toc-number">9.7.1.3.2.</span> <span class="toc-text">（2）数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8JSONObject%E8%A7%A3%E6%9E%90JSON%E6%95%B0%E6%8D%AE"><span class="toc-number">9.7.2.</span> <span class="toc-text">二、使用JSONObject解析JSON数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A1%88%E4%BE%8B%EF%BC%9ACityCodeDemo"><span class="toc-number">9.7.2.1.</span> <span class="toc-text">1. 案例：CityCodeDemo</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%87%86%E5%A4%87JSON%E6%95%B0%E6%8D%AE-%E5%88%9B%E5%BB%BAassets%E7%9B%AE%E5%BD%95"><span class="toc-number">9.7.2.1.1.</span> <span class="toc-text">(1)准备JSON数据,创建assets目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%EF%BC%9A%E5%88%86%E5%88%AB%E5%87%86%E5%A4%87id%E4%B8%BAcityCode%E5%92%8CcityList%E7%9A%84TextView%E5%92%8CSpinner%E6%8E%A7%E4%BB%B6%EF%BC%8C%E4%BB%A5%E4%BE%BFActivity%E8%B0%83%E7%94%A8%E3%80%82"><span class="toc-number">9.7.2.1.2.</span> <span class="toc-text">(2)布局文件：分别准备id为cityCode和cityList的TextView和Spinner控件，以便Activity调用。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%90%AF%E5%8A%A8%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-number">9.7.2.1.3.</span> <span class="toc-text">(3)启动异步任务，进行文件读取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BD%93%E7%B1%BB%E3%80%82%E8%A3%85%E8%BD%BDJSON%E7%9A%84%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%9C"><span class="toc-number">9.7.2.1.4.</span> <span class="toc-text">（4）定义实体类。装载JSON的解析结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E8%A7%A3%E6%9E%90JSON%E5%86%85%E5%AE%B9%E3%80%82%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AF%B9%E5%BA%94%E7%9A%84CityCode%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1%E5%88%97%E8%A1%A8"><span class="toc-number">9.7.2.1.5.</span> <span class="toc-text">（5）解析JSON内容。将字符串转换为对应的CityCode实体对象列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E7%BB%91%E5%AE%9A%E7%95%8C%E9%9D%A2%E6%8E%A7%E4%BB%B6%E3%80%82%E5%B0%86%E8%A7%A3%E6%9E%90%E5%BE%97%E5%88%B0%E7%9A%84List%E9%80%9A%E8%BF%87%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%88%B0spinner%E6%8E%A7%E4%BB%B6%E4%B8%8A%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%AD%90%E9%A1%B9%E7%9B%91%E5%90%AC"><span class="toc-number">9.7.2.1.6.</span> <span class="toc-text">（6）绑定界面控件。将解析得到的List通过适配器，绑定到spinner控件上，并设置子项监听</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%89%E5%8D%93%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6assets"><span class="toc-number">9.7.2.2.</span> <span class="toc-text">2.安卓的资源文件assets</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Android%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE%E6%9C%89%E4%B8%89%E7%A7%8D%EF%BC%9A"><span class="toc-number">9.7.2.2.1.</span> <span class="toc-text">（1）Android资源文件的存放位置有三种：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#res%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%AD%98%E6%94%BE%E7%9A%84%E5%8F%AF%E7%BC%96%E8%AF%91%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%9B"><span class="toc-number">9.7.2.2.2.</span> <span class="toc-text">res目录下存放的可编译的资源文件；</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#assets%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%AD%98%E6%94%BE%E7%9A%84%E5%8E%9F%E7%94%9F%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%9B"><span class="toc-number">9.7.2.2.3.</span> <span class="toc-text">assets目录下存放的原生资源文件；</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#res-raw%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%AD%98%E6%94%BE%E7%9A%84%E5%8E%9F%E7%94%9F%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">9.7.2.2.4.</span> <span class="toc-text">res&#x2F;raw目录下存放的原生资源文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89assets%E4%B8%8Eres-raw%E7%9B%B8%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">9.7.2.2.5.</span> <span class="toc-text">（2）assets与res&#x2F;raw相同之处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89assets%E4%B8%8Eres-raw%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">9.7.2.2.6.</span> <span class="toc-text">（3）assets与res&#x2F;raw不同之处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8Goole-Gson%E8%A7%A3%E6%9E%90JSON%E6%95%B0%E6%8D%AE"><span class="toc-number">9.7.3.</span> <span class="toc-text">三、使用Goole Gson解析JSON数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Gson%E6%A6%82%E8%BF%B0"><span class="toc-number">9.7.3.1.</span> <span class="toc-text">1.Gson概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Gson%E7%9A%84%E8%A7%A3%E6%9E%90%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95-%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%80%E4%B8%AAJavaBean%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BF%99%E4%B8%AAJavaBean%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%E8%B7%9FJSON%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%80%E4%B8%80%E5%AF%B9%E5%BA%94%E7%9A%84%E3%80%82"><span class="toc-number">9.7.3.1.1.</span> <span class="toc-text">（1）Gson的解析非常简单:必须有一个JavaBean文件，这个JavaBean文件的内容跟JSON数据类型是一一对应的。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Gson%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.7.3.1.2.</span> <span class="toc-text">（2）Gson有两个重要的方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%A3%E6%9E%90Json%E6%95%B0%E6%8D%AE"><span class="toc-number">9.7.3.2.</span> <span class="toc-text">2.解析Json数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%87%86%E5%A4%87%E4%B8%80%E4%B8%AAPerson%E7%B1%BB"><span class="toc-number">9.7.3.2.1.</span> <span class="toc-text">（1）准备一个Person类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%EF%BC%89toJson-%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E5%B0%86bean%E5%AF%B9%E8%B1%A1%E6%8D%A2%E4%B8%BAJson%E6%95%B0%E6%8D%AE"><span class="toc-number">9.7.3.2.2.</span> <span class="toc-text">（2））toJson()方法用于将bean对象换为Json数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89fromJson-%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E5%B0%86Json%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%B8%BAbean%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.7.3.2.3.</span> <span class="toc-text">（3）fromJson()方法用于将Json数据转换为bean对象</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6Volley"><span class="toc-number">9.8.</span> <span class="toc-text">网络通信框架Volley</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Volley%E6%A6%82%E8%BF%B0"><span class="toc-number">9.8.1.</span> <span class="toc-text">一、Volley概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Volley%E7%89%B9%E5%88%AB%E9%80%82%E5%90%88%E6%95%B0%E6%8D%AE%E9%87%8F%E4%B8%8D%E5%A4%A7%E4%BD%86%E9%80%9A%E4%BF%A1%E9%A2%91%E7%B9%81%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">9.8.1.1.</span> <span class="toc-text">1.Volley特别适合数据量不大但通信频繁的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8D%E4%BD%BF%E7%94%A8Volley%EF%BC%8C%E4%BB%8E%E7%BD%91%E4%B8%8A%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%A4%A7%E8%87%B4%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">9.8.1.2.</span> <span class="toc-text">2.不使用Volley，从网上下载资源的步骤大致如下：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A6%96%E5%85%88%EF%BC%8C%E5%9C%A8AsyncTask%E7%9A%84doInBackground-%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8HttpURLConnection%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E3%80%82"><span class="toc-number">9.8.1.2.1.</span> <span class="toc-text">（1）首先，在AsyncTask的doInBackground()中，使用HttpURLConnection从服务器获取相关资源。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%84%B6%E5%90%8E%EF%BC%8C%E5%B0%86%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%96%87%E5%AD%97%E6%88%96%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E5%9C%A8AsyncTask%E7%B1%BB%E7%9A%84onPostExecute-%E9%87%8C%E8%AE%BE%E7%BD%AE%E5%88%B0%E7%9B%B8%E5%BA%94%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%AD%E3%80%82"><span class="toc-number">9.8.1.2.2.</span> <span class="toc-text">（2）然后，将下载的文字或图片资源在AsyncTask类的onPostExecute()里设置到相应的控件中。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%8C%E5%9C%A8Volley%E4%B8%8B%EF%BC%8C%E4%B8%8A%E8%BF%B0%E5%8F%AA%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%8C%E6%88%90%E4%B8%8A%E8%BF%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.8.1.2.3.</span> <span class="toc-text">而在Volley下，上述只需要一个函数就可以完成上述步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Volley%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.8.2.</span> <span class="toc-text">二、Volley的使用步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8ERequestQueue"><span class="toc-number">9.8.2.1.</span> <span class="toc-text">1.声明RequestQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BA%86%E8%8E%B7%E5%BE%97%E8%AF%B7%E6%B1%82%E7%9A%84%E5%93%8D%E5%BA%94%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%A0%B9%E6%8D%AE%E5%93%8D%E5%BA%94%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E8%B0%83%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84Request%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.8.2.2.</span> <span class="toc-text">2.为了获得请求的响应，我们需要根据响应的结果，调用不同的Request对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%80%9A%E8%BF%87Volley%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.8.3.</span> <span class="toc-text">三、通过Volley获取字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%80%9A%E8%BF%87Volley%E8%8E%B7%E5%8F%96JSON%E6%95%B0%E6%8D%AE"><span class="toc-number">9.8.4.</span> <span class="toc-text">四、通过Volley获取JSON数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%80%9A%E8%BF%87Volley%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90"><span class="toc-number">9.8.5.</span> <span class="toc-text">五、通过Volley获取图片资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ImageRequest"><span class="toc-number">9.8.5.1.</span> <span class="toc-text">1.ImageRequest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ImageLoader"><span class="toc-number">9.8.5.2.</span> <span class="toc-text">2.ImageLoader</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%90%8E%E5%8F%B0%E9%BB%98%E9%BB%98%E5%8A%B3%E5%8A%A8%E8%80%85%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1"><span class="toc-number">10.</span> <span class="toc-text">第十章 后台默默劳动者——服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">10.1.</span> <span class="toc-text">Android多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.1.</span> <span class="toc-text">一、线程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Android%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8CApp%E8%BF%90%E8%A1%8C%E5%90%8E%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%8D%B3%E4%B8%BB%E7%BA%BF%E7%A8%8B%E3%80%82"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">1.Android系统中，App运行后默认创建一个线程，即主线程。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%B4%9F%E8%B4%A3%E5%A4%84%E7%90%86%E4%B8%8EUI%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%B9%B6%E6%8A%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%EF%BC%8C%E9%80%9A%E5%B8%B8%E5%8F%88%E8%A2%AB%E5%8F%AB%E5%81%9AUI%E7%BA%BF%E7%A8%8B%E3%80%82"><span class="toc-number">10.1.1.2.</span> <span class="toc-text">2.主线程负责处理与UI相关的事件，并把相关的事件分发到对应的组件进行处理，通常又被叫做UI线程。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.1.2.</span> <span class="toc-text">二、主线程和子线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.1.2.1.</span> <span class="toc-text">1.主线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.1.2.2.</span> <span class="toc-text">2.子线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-number">10.1.3.</span> <span class="toc-text">三、同步与异步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%8C%E6%AD%A5%EF%BC%9A%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E6%94%BE%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">10.1.3.1.</span> <span class="toc-text">1.同步：需要等待放回结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%EF%BC%9A%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">10.1.3.2.</span> <span class="toc-text">异步：不需要等待返回结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%A0%E8%AE%BA%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%8F%AF%E8%83%BD%E6%AF%94%E8%BE%83%E8%80%97%E6%97%B6%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E6%94%BE%E5%88%B0%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86%E3%80%82%E5%A6%82%E6%9E%9C%E5%A4%84%E7%90%86%E7%9A%84%E7%BB%93%E6%9E%9C%E9%9C%80%E8%A6%81%E5%88%B7%E6%96%B0%E7%95%8C%E9%9D%A2%EF%BC%8C%E9%82%A3%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E7%9A%84%E6%96%B9%E6%B3%95%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%9C%A8%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%8F%91%E6%B6%88%E6%81%AF%E7%BB%99%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%EF%BC%88%E6%9B%B4%E6%96%B0UI%EF%BC%89%E3%80%82"><span class="toc-number">10.1.3.3.</span> <span class="toc-text">2.无论同步异步，如果事件处理可能比较耗时，就需要放到其他线程中处理。如果处理的结果需要刷新界面，那么需要线程间通讯的方法来实现在其他线程中发消息给主线程处理（更新UI）。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF"><span class="toc-number">10.1.4.</span> <span class="toc-text">四、线程间通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Activity-runOnUiThread-Runnable"><span class="toc-number">10.1.4.1.</span> <span class="toc-text">1) Activity.runOnUiThread(Runnable)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-View-post-Runnable-View-postDelay-Runnable-long"><span class="toc-number">10.1.4.2.</span> <span class="toc-text">2) View.post(Runnable) ;View.postDelay(Runnable , long)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Handler"><span class="toc-number">10.1.4.3.</span> <span class="toc-text">3) Handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#post-postDelay"><span class="toc-number">10.1.4.4.</span> <span class="toc-text">post, postDelay</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendMessage-handleMessage"><span class="toc-number">10.1.4.5.</span> <span class="toc-text">sendMessage, handleMessage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-AsyncTask"><span class="toc-number">10.1.4.6.</span> <span class="toc-text">4) AsyncTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B9%BF%E6%92%AD"><span class="toc-number">10.1.4.7.</span> <span class="toc-text">5) 广播</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">10.1.5.</span> <span class="toc-text">五、线程的状态和生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81"><span class="toc-number">10.1.5.1.</span> <span class="toc-text">创建状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81"><span class="toc-number">10.1.5.2.</span> <span class="toc-text">就绪状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-number">10.1.5.3.</span> <span class="toc-text">运行状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81"><span class="toc-number">10.1.5.4.</span> <span class="toc-text">阻塞状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81"><span class="toc-number">10.1.5.5.</span> <span class="toc-text">终止状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">10.1.6.</span> <span class="toc-text">六、线程的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.6.1.</span> <span class="toc-text">1. 创建线程的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.1.6.1.1.</span> <span class="toc-text">（1）方法一：通过继承Thread类创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.1.6.1.2.</span> <span class="toc-text">（2）方法二：通过实现Runnable接口来创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E4%B8%8D%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">10.1.6.1.3.</span> <span class="toc-text">（3）方法三：不实现Runnable接口，直接使用匿名类的方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%88%E6%96%B9%E5%BC%8F%E4%BA%8C%E7%9A%84%E7%AE%80%E5%8C%96%EF%BC%89"><span class="toc-number">10.1.6.1.4.</span> <span class="toc-text">（方式二的简化）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%81%9C%E6%AD%A2"><span class="toc-number">10.1.6.2.</span> <span class="toc-text">2.线程的运行与停止</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89myThread-interrupt"><span class="toc-number">10.1.6.2.1.</span> <span class="toc-text">（1）myThread. interrupt ();</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Thread-interrupted"><span class="toc-number">10.1.6.2.2.</span> <span class="toc-text">（2）Thread.interrupted()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88Handler-Message%EF%BC%89"><span class="toc-number">10.1.7.</span> <span class="toc-text">七、异步消息处理机制（Handler + Message）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">10.1.7.1.</span> <span class="toc-text">1.异步消息处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%BB%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%88%9B%E5%BB%BAHandler%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%87%8D%E5%86%99handleMessage%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.7.1.1.</span> <span class="toc-text">（1）主线程：创建Handler对象，重写handleMessage方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AD%90%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%88%9B%E5%BB%BAMessage%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">10.1.7.1.2.</span> <span class="toc-text">（2）子线程：创建Message对象，发送消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%B8%BB%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%EF%BC%8C%E5%9B%9E%E8%B0%83handleMessage"><span class="toc-number">10.1.7.1.3.</span> <span class="toc-text">（3）主线程：处理消息，回调handleMessage</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Hander%E7%B1%BB"><span class="toc-number">10.1.7.2.</span> <span class="toc-text">2.Hander类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Message%E7%B1%BB"><span class="toc-number">10.1.7.3.</span> <span class="toc-text">3.Message类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Message%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">10.1.7.3.1.</span> <span class="toc-text">（1）Message对象：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%94%A8%E6%9D%A5%E5%B0%81%E8%A3%85%E6%89%80%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%80%BC%EF%BC%9A"><span class="toc-number">10.1.7.3.2.</span> <span class="toc-text">（2）用来封装所发送消息的值：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BC%A0%E9%80%92%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE-setData"><span class="toc-number">10.1.7.3.3.</span> <span class="toc-text">(3)传递复杂数据 setData()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%B9%B8%E8%BF%90%E5%A4%A7%E6%8A%BD%E5%A5%96%EF%BC%88%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%89"><span class="toc-number">10.1.7.4.</span> <span class="toc-text">2.案例实现：幸运大抽奖（方式一）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88Handler-Post%EF%BC%89"><span class="toc-number">10.1.8.</span> <span class="toc-text">八、异步消息处理机制（Handler + Post）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Handler%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%8A%8A%E4%B8%80%E4%B8%AARunnable%E5%AF%B9%E8%B1%A1%E5%8E%8B%E5%85%A5%E5%88%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E8%BF%9B%E8%80%8C%E5%9C%A8UI%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%8E%B7%E5%8F%96%E5%B9%B6%E6%89%A7%E8%A1%8CRunnable%E5%AF%B9%E8%B1%A1%E3%80%82-%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C"><span class="toc-number">10.1.8.1.</span> <span class="toc-text">1. Handler也可以把一个Runnable对象压入到消息队列中，进而在UI线程的消息队列获取并执行Runnable对象。(在主线程中执行)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%8A%8A%E4%B8%80%E4%B8%AARunnable%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%98%9F%E5%88%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%96%B9%E6%B3%95%E6%9C%89%EF%BC%9A"><span class="toc-number">10.1.8.1.1.</span> <span class="toc-text">（1）把一个Runnable对象入队到消息队列,方法有：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BB%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E7%A7%BB%E9%99%A4%E4%B8%80%E4%B8%AARunnable%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.1.8.1.2.</span> <span class="toc-text">(2)从消息队列中移除一个Runnable对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E4%BA%8EHandler%E7%9A%84Post%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%AE%83%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AARunnable%E5%AF%B9%E8%B1%A1%E5%88%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AARunnable%E5%AF%B9%E8%B1%A1%E4%B8%AD%EF%BC%8C%E9%87%8D%E5%86%99run-%E6%96%B9%E6%B3%95%E3%80%82%E4%B8%80%E8%88%AC%E5%9C%A8%E8%BF%99%E4%B8%AArun-%E6%96%B9%E6%B3%95%E4%B8%AD%E5%86%99%E5%85%A5%E9%9C%80%E8%A6%81%E5%9C%A8UI%E7%BA%BF%E7%A8%8B%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number">10.1.8.2.</span> <span class="toc-text">2.对于Handler的Post方式来说，它传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run()方法。一般在这个run()方法中写入需要在UI线程上的操作。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%B9%B8%E8%BF%90%E5%A4%A7%E6%8A%BD%E5%A5%96%EF%BC%88%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%89"><span class="toc-number">10.1.8.3.</span> <span class="toc-text">3. 案例实现：幸运大抽奖（方式二）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E9%80%94"><span class="toc-number">10.2.</span> <span class="toc-text">服务的原理和用途</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">10.2.1.</span> <span class="toc-text">一、启动服务的两种状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8%E7%8A%B6%E6%80%81%EF%BC%9A%E9%80%9A%E8%BF%87Context%E7%9A%84startService-%E5%90%AF%E5%8A%A8service"><span class="toc-number">10.2.1.1.</span> <span class="toc-text">1.启动状态：通过Context的startService()启动service</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E6%97%A6%E5%90%AF%E5%8A%A8%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%8D%B3%E5%8F%AF%E5%9C%A8%E5%90%8E%E5%8F%B0%EF%BC%88%E6%97%A0UI%EF%BC%89%E6%97%A0%E9%99%90%E6%9C%9F%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%8D%B3%E4%BD%BF%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%BB%84%E4%BB%B6%E5%B7%B2%E8%A2%AB%E9%94%80%E6%AF%81%E4%B9%9F%E4%B8%8D%E5%8F%97%E5%BD%B1%E5%93%8D%EF%BC%8C%E9%99%A4%E9%9D%9E%E6%89%8B%E5%8A%A8%E8%B0%83%E7%94%A8stopService-%E6%88%96%E8%80%85%E8%87%AA%E5%B7%B1%E5%81%9C%E6%AD%A2%EF%BC%88stopSelf%EF%BC%89%E6%89%8D%E8%83%BD%E5%81%9C%E6%AD%A2%E6%9C%8D%E5%8A%A1%E3%80%82%E5%B7%B2%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E9%80%9A%E5%B8%B8%E6%98%AF%E6%89%A7%E8%A1%8C%E5%8D%95%E4%B8%80%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%80%8C%E4%B8%94%E4%B8%8D%E4%BC%9A%E5%B0%86%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E%E7%BB%99%E8%B0%83%E7%94%A8%E6%96%B9%E3%80%82%E4%BE%8B%E5%A6%82%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E4%B8%8A%E4%BC%A0%EF%BC%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%8C%E6%93%8D%E4%BD%9C%E4%B8%80%E6%97%A6%E5%AE%8C%E6%88%90%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%BA%94%E8%AF%A5%E8%87%AA%E5%8A%A8%E9%94%80%E6%AF%81"><span class="toc-number">10.2.1.1.1.</span> <span class="toc-text">一旦启动，服务即可在后台（无UI）无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用stopService()或者自己停止（stopSelf）才能停止服务。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如通过网络上传，下载文件，操作一旦完成，服务应该自动销毁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%91%E5%AE%9A%E7%8A%B6%E6%80%81%EF%BC%9A%E9%80%9A%E8%BF%87Context%E7%9A%84bindService-%E7%BB%91%E5%AE%9AService"><span class="toc-number">10.2.1.2.</span> <span class="toc-text">2.绑定状态：通过Context的bindService()绑定Service</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9C%A8%E6%B8%85%E5%8D%95%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">10.2.2.</span> <span class="toc-text">二、在清单文件中的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8Service"><span class="toc-number">10.2.3.</span> <span class="toc-text">四、使用Service</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A6%96%E5%85%88%E8%A6%81%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%88%9B%E5%BB%BA-Service-%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%88%E6%88%96%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E4%B8%80%E4%B8%AA%E7%8E%B0%E6%9C%89%E5%AD%90%E7%B1%BB%E5%A6%82IntentService%EF%BC%89%E3%80%82"><span class="toc-number">10.2.3.1.</span> <span class="toc-text">1.首先要创建服务，必须创建 Service 的子类（或使用它的一个现有子类如IntentService）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E4%BC%BCActivity%EF%BC%8CService%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%9C%A8%E5%AE%9E%E7%8E%B0%E4%B8%AD%E9%9C%80%E8%A6%81%E9%87%8D%E5%86%99%E4%B8%80%E4%BA%9B%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BB%A5%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E6%9F%90%E4%BA%9B%E5%85%B3%E9%94%AE%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-number">10.2.3.2.</span> <span class="toc-text">2.类似Activity，Service有自己的生命周期，因此在实现中需要重写一些回调方法，以处理服务生命周期的某些关键过程。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9A%8F%E5%90%8E%EF%BC%8C%E7%BB%84%E4%BB%B6-%E4%BE%8B%E5%A6%82%E6%B4%BB%E5%8A%A8-%E4%BB%A5%E5%90%AF%E5%8A%A8%E6%88%96%E8%80%85%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%A7%8B%E5%85%B6%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">10.2.3.3.</span> <span class="toc-text">3.随后，组件(例如活动)以启动或者绑定方式启动服务，服务开始其生命过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Service%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.4.</span> <span class="toc-text">五、Service中常用回调方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-abstract-IBinder-onBind-Intent-intent"><span class="toc-number">10.2.4.1.</span> <span class="toc-text">1.abstract IBinder onBind(Intent intent)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-void-onCreate"><span class="toc-number">10.2.4.2.</span> <span class="toc-text">2.void onCreate()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-void-onDestroy"><span class="toc-number">10.2.4.3.</span> <span class="toc-text">3.void onDestroy()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-void-onStartCommand-Intent-intent-int-flags-int-startId"><span class="toc-number">10.2.4.4.</span> <span class="toc-text">4.void onStartCommand(Intent intent,int flags,int startId)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-boolean-onUnbind-Intent-intent"><span class="toc-number">10.2.4.5.</span> <span class="toc-text">5.boolean onUnbind(Intent intent)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">10.2.5.</span> <span class="toc-text">六、活动的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">10.3.</span> <span class="toc-text">启动方式启动服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81StartService%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="toc-number">10.3.1.</span> <span class="toc-text">一、StartService生命周期及进程相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E5%90%8C%E4%B8%80%E7%B1%BB%E5%9E%8B%E7%9A%84Service%EF%BC%8CService%E5%AE%9E%E4%BE%8B%E6%B0%B8%E8%BF%9C%E5%8F%AA%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%EF%BC%8C%E8%80%8C%E4%B8%8D%E7%AE%A1Client%E6%98%AF%E5%90%A6%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E4%B9%9F%E4%B8%8D%E7%AE%A1Client%E6%98%AF%E5%90%A6%E5%A4%84%E4%BA%8E%E7%9B%B8%E5%90%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%AD%E3%80%82"><span class="toc-number">10.3.1.1.</span> <span class="toc-text">1.对于同一类型的Service，Service实例永远只存在一个，而不管Client是否是相同的组件，也不管Client是否处于相同的进程中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A5%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E7%8B%AC%E7%AB%8B%E7%9A%84%EF%BC%8C%E4%B8%8EClient%E6%9C%AC%E8%BA%AB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%8F%AA%E6%9C%89Client%E8%B0%83%E7%94%A8stopService-%E6%88%96%E6%9C%8D%E5%8A%A1%E6%9C%AC%E8%BA%AB%E8%B0%83%E7%94%A8stopSelf-%E6%89%8D%E8%83%BD%E5%81%9C%E6%AD%A2%E3%80%82%E6%88%96%E8%80%85%EF%BC%8C%E5%BD%93%E7%94%A8%E6%88%B7%E5%BC%BA%E5%88%B6kill%E6%8E%89%E6%9C%8D%E5%8A%A1%E6%89%80%E5%9C%A8%E8%BF%9B%E7%A8%8B%EF%BC%8C%E6%88%96%E7%B3%BB%E7%BB%9F%E5%9B%A0%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E4%B9%9F%E5%8F%AF%E8%83%BDkill%E6%8E%89%E6%AD%A4Service"><span class="toc-number">10.3.1.2.</span> <span class="toc-text">2.以启动方式运行的服务，其生命周期是独立的，与Client本身的生命周期没有任何关系，只有Client调用stopService(..)或服务本身调用stopSelf(..)才能停止。或者，当用户强制kill掉服务所在进程，或系统因内存不足也可能kill掉此Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Client-A-%E9%80%9A%E8%BF%87startService-%E5%90%AF%E5%8A%A8Service%E5%90%8E-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%85%B6%E4%BB%96Client%EF%BC%88%E5%A6%82Client-B%E3%80%81Client-C%EF%BC%89%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8stopService-%E7%BB%93%E6%9D%9F%E6%AD%A4Service"><span class="toc-number">10.3.1.3.</span> <span class="toc-text">3.Client A 通过startService(..)启动Service后,可以在其他Client（如Client B、Client C）通过调用stopService(..)结束此Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Client%E8%B0%83%E7%94%A8stopService-%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8DService%E6%B2%A1%E6%9C%89%E5%90%AF%E5%8A%A8%EF%BC%8C%E4%B9%9F%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%BB%E4%BD%95%E6%8A%A5%E9%94%99%E6%88%96%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8CstopService-%E6%97%A0%E9%9C%80%E5%81%9A%E5%BD%93%E5%89%8DService%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88%E7%9A%84%E5%88%A4%E6%96%AD%E3%80%82"><span class="toc-number">10.3.1.4.</span> <span class="toc-text">4.Client调用stopService(..)时，如果当前Service没有启动，也不会出现任何报错或问题，也就是说，stopService(..)无需做当前Service是否有效的判断。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-startService-Intent-serviceIntent-%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84intent%E6%97%A2%E5%8F%AF%E4%BB%A5%E6%98%AF%E6%98%BE%E5%BC%8FIntent%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AF%E9%9A%90%E5%BC%8FIntent%EF%BC%8C%E5%BD%93Client%E4%B8%8EService%E5%90%8C%E5%A4%84%E4%BA%8E%E4%B8%80%E4%B8%AAApp%E6%97%B6%EF%BC%8C%E4%B8%80%E8%88%AC%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%98%BE%E7%A4%BAIntent%E3%80%82%E5%BD%93%E5%A4%84%E4%BA%8E%E4%B8%8D%E5%90%8CApp%E6%97%B6%EF%BC%8C%E5%8F%AA%E8%83%BD%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8FIntent%E3%80%82"><span class="toc-number">10.3.1.5.</span> <span class="toc-text">5.startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Client%E4%B8%8EService%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3"><span class="toc-number">10.3.2.</span> <span class="toc-text">二、Client与Service通信相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8Service%E6%97%B6"><span class="toc-number">10.3.2.1.</span> <span class="toc-text">1.启动Service时</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%93Client%E8%B0%83%E7%94%A8startService-Intent-serviceIntent-%E5%90%AF%E5%8A%A8Service%E6%97%B6%EF%BC%8CClient%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%8F%82%E6%95%B0%E9%80%9A%E8%BF%87Intent%E7%9B%B4%E6%8E%A5%E4%BC%A0%E9%80%92%E7%BB%99Service%E3%80%82"><span class="toc-number">10.3.2.1.1.</span> <span class="toc-text">当Client调用startService(Intent serviceIntent)启动Service时，Client可以将参数通过Intent直接传递给Service。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Service%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD"><span class="toc-number">10.3.2.2.</span> <span class="toc-text">2.Service执行过程中</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Service%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E5%B0%86%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99Client%EF%BC%8C%E4%B8%80%E8%88%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%80%9F%E5%8A%A9%E4%BA%8E%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E6%AD%A4%E6%97%B6%EF%BC%8CClient%E9%9C%80%E8%A6%81%E6%B3%A8%E5%86%8C%E6%AD%A4%E5%B9%BF%E6%92%AD%EF%BC%89%E3%80%82"><span class="toc-number">10.3.2.2.1.</span> <span class="toc-text">Service执行过程中，如果需要将参数传递给Client，一般可以通过借助于发送广播的方式（此时，Client需要注册此广播）。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">10.4.</span> <span class="toc-text">绑定方式启动服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">10.4.1.</span> <span class="toc-text">一、三个基本特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-C-S%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%BB%91%E5%AE%9A%E7%8A%B6%E6%80%81%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%BB%A3%E8%A1%A8%E7%9D%80%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">10.4.1.1.</span> <span class="toc-text">1.C-S模式：绑定状态的服务代表着客户端-服务器接口中的服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%A4%E4%BA%92%E4%B8%8E%E9%80%9A%E4%BF%A1%EF%BC%9A%E5%BD%93%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6%EF%BC%88%E5%A6%82-Activity%EF%BC%8C%E4%BB%A3%E8%A1%A8%E4%BA%86%E5%AE%A2%E6%88%B7%E7%AB%AFClient%EF%BC%89%E7%BB%91%E5%AE%9A%E5%88%B0%E6%9C%8D%E5%8A%A1%E6%97%B6%EF%BC%8C%E7%BB%84%E4%BB%B6%EF%BC%88%E5%A6%82Activity%EF%BC%89%E5%8F%AF%E4%BB%A5%E5%90%91Service%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%88%96%E8%80%85%E8%B0%83%E7%94%A8Service%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%AD%A4%E6%97%B6%E8%A2%AB%E7%BB%91%E5%AE%9A%E7%9A%84Service%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89%E4%BC%9A%E6%8E%A5%E6%94%B6%E4%BF%A1%E6%81%AF%E5%B9%B6%E5%93%8D%E5%BA%94%EF%BC%8C%E7%94%9A%E8%87%B3%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E7%BB%91%E5%AE%9A%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E6%89%A7%E8%A1%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E3%80%82"><span class="toc-number">10.4.1.2.</span> <span class="toc-text">2.交互与通信：当其他组件（如 Activity，代表了客户端Client）绑定到服务时，组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信 。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%B8%8E%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%90%8C%EF%BC%8C%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%80%9A%E5%B8%B8%E5%8F%AA%E5%9C%A8%E4%B8%BA%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E7%BB%84%E4%BB%B6-%E5%A6%82Activity-%E6%9C%8D%E5%8A%A1%E6%97%B6%E5%A4%84%E4%BA%8E%E6%B4%BB%E5%8A%A8%E7%8A%B6%E6%80%81%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%97%A0%E9%99%90%E6%9C%9F%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E6%89%80%E6%9C%89%E5%AE%BF%E4%B8%BB-%E5%A6%82Activity-%E8%A7%A3%E9%99%A4%E7%BB%91%E5%AE%9A%E5%90%8E%EF%BC%8C%E7%BB%91%E5%AE%9A%E6%9C%8D%E5%8A%A1%E5%B0%B1%E4%BC%9A%E8%A2%AB%E9%94%80%E6%AF%81%E3%80%82"><span class="toc-number">10.4.1.3.</span> <span class="toc-text">3.生命周期：与启动方式启动的服务不同，绑定方式启动的服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说所有宿主(如Activity)解除绑定后，绑定服务就会被销毁。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81BindService%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">10.4.2.</span> <span class="toc-text">二、BindService生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-onBind%E6%96%B9%E6%B3%95%E5%8F%AA%E8%A2%AB%E8%B0%83%E7%94%A8%E4%B8%80%E6%AC%A1%E3%80%82%EF%BC%88%E5%BD%93%E8%B0%83%E7%94%A8bindService-%E6%96%B9%E6%B3%95%E6%98%AF%EF%BC%89Service%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E5%88%9B%E5%BB%BA%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8ConCreate%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B9%8B%E5%90%8E%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8onBind-%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">10.4.2.1.</span> <span class="toc-text">1.onBind方法只被调用一次。（当调用bindService()方法是）Service第一次被创建时会执行onCreate方法，之后自动调用onBind()方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BD%93%E8%B0%83%E7%94%A8unBindService-%E6%96%B9%E6%B3%95%E6%97%B6%EF%BC%8CService%E4%BC%9A%E4%BE%9D%E6%AC%A1%E6%89%A7%E8%A1%8ConUnbind-%E3%80%81onDestroy-%E6%96%B9%E6%B3%95%E7%BB%93%E6%9D%9F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">10.4.2.2.</span> <span class="toc-text">2.当调用unBindService()方法时，Service会依次执行onUnbind()、onDestroy()方法结束生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E6%9E%9C%E7%BB%91%E5%AE%9A%E6%9C%8D%E5%8A%A1%E7%9A%84Client%EF%BC%88Activity%EF%BC%89%E8%A2%AB%E9%94%80%E6%AF%81%EF%BC%8C%E5%88%99Service%E4%B9%9F%E4%BC%9A%E8%A2%AB%E9%94%80%E6%AF%81%EF%BC%8C%E4%B8%8D%E7%AE%A1%E6%98%AF%E5%90%A6Client%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8unbindService-%E8%A7%A3%E9%99%A4%E7%BB%91%E5%AE%9A%E3%80%82"><span class="toc-number">10.4.2.3.</span> <span class="toc-text">3.如果绑定服务的Client（Activity）被销毁，则Service也会被销毁，不管是否Client主动调用unbindService()解除绑定。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-number">10.4.3.</span> <span class="toc-text">三、一般流程！！！</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%8CService%E4%B8%AD"><span class="toc-number">10.4.3.1.</span> <span class="toc-text">1.服务端，Service中</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BABinder%E5%AD%90%E7%B1%BB%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.4.3.1.1.</span> <span class="toc-text">（1）创建Binder子类，返回服务实例对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9C%A8onBind-%E4%B8%AD%E8%BF%94%E5%9B%9EMybinder%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1iBinder"><span class="toc-number">10.4.3.1.2.</span> <span class="toc-text">（2）在onBind()中返回Mybinder的实例对象iBinder</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8CActivity%E4%B8%AD"><span class="toc-number">10.4.3.2.</span> <span class="toc-text">2.客户端，Activity中</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BAServiceConnection%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%9C%A8onServiceConnected-%E4%B8%AD%E6%8E%A5%E6%94%B6%E8%BF%94%E5%9B%9E%E7%9A%84Binder-%E5%AE%9E%E4%BE%8B%EF%BC%8C%E9%80%9A%E8%BF%87Binder%E5%AE%9E%E4%BE%8B%E7%9A%84getService-%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8BmyService"><span class="toc-number">10.4.3.2.1.</span> <span class="toc-text">（1）创建ServiceConnection实例，在onServiceConnected 中接收返回的Binder 实例，通过Binder实例的getService()方法获取服务实例myService</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BB%91%E5%AE%9A%E4%B9%8B%E5%90%8E%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87myService%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.3.2.2.</span> <span class="toc-text">(2)绑定之后可以通过myService方法调用服务中的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%A7%A3%E9%99%A4%E7%BB%91%E5%AE%9A"><span class="toc-number">10.4.3.2.3.</span> <span class="toc-text">（3）解除绑定</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F"><span class="toc-number">10.5.</span> <span class="toc-text">混合使用启动方式和绑定方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B7%B7%E5%90%88%E5%BC%80%E5%90%AF%E6%9C%8D%E5%8A%A1"><span class="toc-number">10.5.1.</span> <span class="toc-text">一、混合开启服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87startService-%E6%96%B9%E5%BC%8F%E5%BC%80%E5%90%AF%E6%9C%8D%E5%8A%A1-%E5%8F%AA%E8%83%BD%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8stopService%E5%81%9C%E6%AD%A2"><span class="toc-number">10.5.1.1.</span> <span class="toc-text">通过startService()方式开启服务(只能通过调用stopService停止)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87bindService%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A%EF%BC%8C%E4%BB%A5%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-%E5%BD%93%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E5%80%99"><span class="toc-number">10.5.1.2.</span> <span class="toc-text">通过bindService进行绑定，以进行服务的方法调用(当需要的时候)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87unbindService%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%BB%91-%E4%B8%8D%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E4%BA%86%EF%BC%8C%E5%9C%A8UI%E7%BA%BF%E7%A8%8B%E8%A2%AB%E9%94%80%E6%AF%81%E4%B9%8B%E5%89%8D%E8%A7%A3%E7%BB%91"><span class="toc-number">10.5.1.3.</span> <span class="toc-text">通过unbindService进行解绑(不需要调用方法了，在UI线程被销毁之前解绑)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87stopService%E5%81%9C%E6%AD%A2%E6%9C%8D%E5%8A%A1"><span class="toc-number">10.5.1.4.</span> <span class="toc-text">通过stopService停止服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%9A%84onCreate%E6%96%B9%E6%B3%95%E5%8F%AA%E4%BC%9A%E8%A2%AB%E8%B0%83%E7%94%A8%E4%B8%80%E6%AC%A1%E3%80%82"><span class="toc-number">10.5.2.</span> <span class="toc-text">二、可以同时使用两种方式启动服务，但是服务的onCreate方法只会被调用一次。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A6%82%E6%9E%9C%E6%83%B3%E5%81%9C%E6%AD%A2%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%BF%85%E9%A1%BB%E8%B0%83%E7%94%A8stopService%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%89%80%E6%9C%89%E8%B0%83%E7%94%A8-bindService-%E7%9A%84-Context%E8%B0%83%E7%94%A8unbindService%E8%A7%A3%E7%BB%91-%E6%88%96%E8%80%85%E4%B9%8B%E5%89%8D%E8%B0%83%E7%94%A8-bindService-%E7%9A%84-Context-%E4%B8%8D%E5%AD%98%E5%9C%A8%E4%BA%86%E3%80%82"><span class="toc-number">10.5.3.</span> <span class="toc-text">三、如果想停止服务，必须调用stopService，并且所有调用 bindService 的 Context调用unbindService解绑,或者之前调用 bindService 的 Context 不存在了。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-number">10.6.</span> <span class="toc-text">服务的更多使用技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8%E5%89%8D%E5%8F%B0%E6%9C%8D%E5%8A%A1"><span class="toc-number">10.6.1.</span> <span class="toc-text">一、使用前台服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E5%9C%A8%E5%90%8E%E5%8F%B0%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7%E4%BD%8E%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%97%B6%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%E3%80%82"><span class="toc-number">10.6.1.1.</span> <span class="toc-text">1.服务运行在后台，优先级低，系统内存不足时，可能会被回收。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8E%E6%99%AE%E9%80%9A%E6%9C%8D%E5%8A%A1%E7%9B%B8%E6%AF%94%EF%BC%9A%E5%9C%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%8F%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%9B%BE%E6%A0%87%E3%80%82%E4%B8%8B%E6%8B%89%E7%8A%B6%E6%80%81%E6%A0%8F%E5%90%8E%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%9B%B4%E5%8A%A0%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%8C%E7%B1%BB%E4%BC%BC%E4%BA%8E%E9%80%9A%E7%9F%A5%E7%9A%84%E6%95%88%E6%9E%9C%E3%80%82"><span class="toc-number">10.6.1.2.</span> <span class="toc-text">2.与普通服务相比：在系统的状态栏显示一个正在运行的图标。下拉状态栏后可以看到更加详细的信息，类似于通知的效果。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-startForeground-%E5%92%8CstopForeground-%E6%96%B9%E6%B3%95"><span class="toc-number">10.6.1.3.</span> <span class="toc-text">3.startForeground()和stopForeground()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8IntentService"><span class="toc-number">10.6.2.</span> <span class="toc-text">二、使用IntentService</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/android_img.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Durango</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,welcome to my <a href="https://www.durango.cn/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'krF5kMcSSzhBp49rUb2CjNu2-gzGzoHsz',
      appKey: 'VJnaTN0zWPbBeDLnEaP8wDWF',
      placeholder: '记得留下你的昵称和邮箱...可以快速收到回复',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener toc scroll 
  window.removeEventListener('scroll', window.tocScrollFn)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":180,"height":250},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>